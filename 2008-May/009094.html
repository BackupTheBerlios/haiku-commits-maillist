<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25662 - in haiku/trunk: build/jam	headers/os/drivers headers/os/drivers/bus	headers/private/drivers headers/private/kernel	headers/private/kernel/fs headers/private/system	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/isa	src/add-ons/kernel/bus_managers/pci	src/add-ons/kernel/bus_managers/pci/arch/m68k	src/add-ons/kernel/bus_managers/pci/arch/ppc	src/add-ons/kernel/bus_managers/pci/arch/x86	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/ide/generic_ide_pci	src/add-ons/kernel/busses/scsi/ahci	src/add-ons/kernel/drivers/disk/scsi/scsi_dsk	src/add-ons/kernel/generic src/add-ons/kernel/generic/block_io	src/add-ons/kernel/generic/ide_adapter	src/add-ons/kernel/generic/scsi_periph src/system/kernel	src/system/kernel/device_manager src/system/kernel/fs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25662%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers%20headers/os/drivers/bus%0A%09headers/private/drivers%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/system%0A%09src/add-ons/kernel/bus_managers/ide%0A%09src/add-ons/kernel/bus_managers/isa%0A%09src/add-ons/kernel/bus_managers/pci%0A%09src/add-ons/kernel/bus_managers/pci/arch/m68k%0A%09src/add-ons/kernel/bus_managers/pci/arch/ppc%0A%09src/add-ons/kernel/bus_managers/pci/arch/x86%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/busses/ide/generic_ide_pci%0A%09src/add-ons/kernel/busses/scsi/ahci%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_dsk%0A%09src/add-ons/kernel/generic%20src/add-ons/kernel/generic/block_io%0A%09src/add-ons/kernel/generic/ide_adapter%0A%09src/add-ons/kernel/generic/scsi_periph%20src/system/kernel%0A%09src/system/kernel/device_manager%20src/system/kernel/fs&In-Reply-To=%3C200805261652.m4QGqawt026476%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009093.html">
   <LINK REL="Next"  HREF="009101.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25662 - in haiku/trunk: build/jam	headers/os/drivers headers/os/drivers/bus	headers/private/drivers headers/private/kernel	headers/private/kernel/fs headers/private/system	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/isa	src/add-ons/kernel/bus_managers/pci	src/add-ons/kernel/bus_managers/pci/arch/m68k	src/add-ons/kernel/bus_managers/pci/arch/ppc	src/add-ons/kernel/bus_managers/pci/arch/x86	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/ide/generic_ide_pci	src/add-ons/kernel/busses/scsi/ahci	src/add-ons/kernel/drivers/disk/scsi/scsi_dsk	src/add-ons/kernel/generic src/add-ons/kernel/generic/block_io	src/add-ons/kernel/generic/ide_adapter	src/add-ons/kernel/generic/scsi_periph src/system/kernel	src/system/kernel/device_manager src/system/kernel/fs</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25662%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers%20headers/os/drivers/bus%0A%09headers/private/drivers%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/system%0A%09src/add-ons/kernel/bus_managers/ide%0A%09src/add-ons/kernel/bus_managers/isa%0A%09src/add-ons/kernel/bus_managers/pci%0A%09src/add-ons/kernel/bus_managers/pci/arch/m68k%0A%09src/add-ons/kernel/bus_managers/pci/arch/ppc%0A%09src/add-ons/kernel/bus_managers/pci/arch/x86%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/busses/ide/generic_ide_pci%0A%09src/add-ons/kernel/busses/scsi/ahci%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_dsk%0A%09src/add-ons/kernel/generic%20src/add-ons/kernel/generic/block_io%0A%09src/add-ons/kernel/generic/ide_adapter%0A%09src/add-ons/kernel/generic/scsi_periph%20src/system/kernel%0A%09src/system/kernel/device_manager%20src/system/kernel/fs&In-Reply-To=%3C200805261652.m4QGqawt026476%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25662 - in haiku/trunk: build/jam	headers/os/drivers headers/os/drivers/bus	headers/private/drivers headers/private/kernel	headers/private/kernel/fs headers/private/system	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/isa	src/add-ons/kernel/bus_managers/pci	src/add-ons/kernel/bus_managers/pci/arch/m68k	src/add-ons/kernel/bus_managers/pci/arch/ppc	src/add-ons/kernel/bus_managers/pci/arch/x86	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/ide/generic_ide_pci	src/add-ons/kernel/busses/scsi/ahci	src/add-ons/kernel/drivers/disk/scsi/scsi_dsk	src/add-ons/kernel/generic src/add-ons/kernel/generic/block_io	src/add-ons/kernel/generic/ide_adapter	src/add-ons/kernel/generic/scsi_periph src/system/kernel	src/system/kernel/device_manager src/system/kernel/fs">axeld at mail.berlios.de
       </A><BR>
    <I>Mon May 26 18:52:36 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009093.html">[Haiku-commits] r25661 -	haiku/trunk/src/system/kernel/disk_device_manager
</A></li>
        <LI>Next message: <A HREF="009101.html">[Haiku-commits] r25662 - in haiku/trunk: build/jam headers/os/drivers headers/os/drivers/bus headers/private/drivers headers/private/kernel headers/private/kernel/fs  headers/private/system src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/isa src/add-ons/kernel/bus_managers/pci src/add-ons/kernel/bus_managers/pci/arch/m68k src/add-ons/kernel/bus_managers/pci/arch/ppc src/add-ons/kernel/bus_managers/pci/arch/x86 src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/busses/ide/generic_ide_pci src/add-ons/kernel/busses/scsi/ahci src/add-ons/kernel/drivers/disk/scsi/scsi_dsk src/add-ons/kernel/generic  src/add-ons/kernel/generic/block_io src/add-ons/kernel/generic/ide_adapter src/add-ons/kernel/generic/scsi_periph src/system/kernel src/system/kernel/device_manager  src/system/kernel/fs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9094">[ date ]</a>
              <a href="thread.html#9094">[ thread ]</a>
              <a href="subject.html#9094">[ subject ]</a>
              <a href="author.html#9094">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-05-26 18:52:27 +0200 (Mon, 26 May 2008)
New Revision: 25662
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25662&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25662&amp;view=rev</A>

Added:
   haiku/trunk/headers/private/system/device_manager_defs.h
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_device.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_private.h
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_root.cpp
   haiku/trunk/src/system/kernel/device_manager/BaseDevice.cpp
   haiku/trunk/src/system/kernel/device_manager/BaseDevice.h
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/device_manager/devfs_private.h
   haiku/trunk/src/system/kernel/device_manager/device_manager.cpp
   haiku/trunk/src/system/kernel/device_manager/id_generator.cpp
   haiku/trunk/src/system/kernel/device_manager/id_generator.h
   haiku/trunk/src/system/kernel/device_manager/io_resources.cpp
   haiku/trunk/src/system/kernel/device_manager/io_resources.h
   haiku/trunk/src/system/kernel/device_manager/legacy_drivers.cpp
   haiku/trunk/src/system/kernel/device_manager/legacy_drivers.h
Removed:
   haiku/trunk/headers/private/drivers/fast_log.h
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_device.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_priv.h
   haiku/trunk/src/add-ons/kernel/generic/fast_log/
   haiku/trunk/src/system/kernel/device_manager/id_generator.c
   haiku/trunk/src/system/kernel/device_manager/io_resources.c
   haiku/trunk/src/system/kernel/device_manager/probe.cpp
   haiku/trunk/src/system/kernel/fs/devfs.cpp
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/headers/os/drivers/block_io.h
   haiku/trunk/headers/os/drivers/bus/IDE.h
   haiku/trunk/headers/os/drivers/bus/ISA.h
   haiku/trunk/headers/os/drivers/bus/PCI.h
   haiku/trunk/headers/os/drivers/bus/SCSI.h
   haiku/trunk/headers/os/drivers/device_manager.h
   haiku/trunk/headers/private/drivers/ide_adapter.h
   haiku/trunk/headers/private/drivers/scsi_periph.h
   haiku/trunk/headers/private/kernel/fs/devfs.h
   haiku/trunk/headers/private/kernel/kdevice_manager.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/basic_protocol.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/channels.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_internal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_sim.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/sync.c
   haiku/trunk/src/add-ons/kernel/bus_managers/isa/isa.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/Jamfile
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/m68k/pci_controller.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/m68k/pci_io.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/ppc/pci_controller.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/ppc/pci_io.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/x86/pci_bios.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/x86/pci_controller.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/arch/x86/pci_io.c
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_info.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/pci/pci_module.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/bus_raw.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/busses.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/device_scan.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/devices.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/emulation.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_internal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_io.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/sim_interface.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/wrapper.h
   haiku/trunk/src/add-ons/kernel/busses/ide/generic_ide_pci/generic_ide_pci.c
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/ahci.c
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/ahci_controller.cpp
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/ahci_controller.h
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/ahci_sim.cpp
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/device.c
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/handle.c
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/scsi_dsk.c
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/scsi_dsk.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/scsi_dsk_int.h
   haiku/trunk/src/add-ons/kernel/generic/Jamfile
   haiku/trunk/src/add-ons/kernel/generic/block_io/block_io.c
   haiku/trunk/src/add-ons/kernel/generic/block_io/block_io_private.h
   haiku/trunk/src/add-ons/kernel/generic/ide_adapter/ide_adapter.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/io.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h
   haiku/trunk/src/system/kernel/device_manager/Jamfile
   haiku/trunk/src/system/kernel/device_manager/device_manager_private.h
   haiku/trunk/src/system/kernel/fs/Jamfile
   haiku/trunk/src/system/kernel/main.cpp
   haiku/trunk/src/system/kernel/module.cpp
Log:
* Integration of the new driver architecture.
* Moved devfs from fs/ to device_manager/, and separated the legacy driver
  support from it.
* Removed fast_log module.
* There are a couple of (temporary) regressions, though:
  - legacy SATA and ISA IDE support is disabled, the drivers haven't been
    ported yet.
  - The not yet used ATA bus manager hasn't been ported yet, either.
  - AHCI changes have not been tested.
  - the listdev command has been removed from the build (as it currently
    doesn't work anymore).
  - device manager generated IDs currently are not freed anymore when a device
    node is removed.
  - generic drivers can't yet use the new driver architecture.
  - simple busses that do not support device types won't work yet.
  - legacy driver publishing/unpublishing (ie. what USB needs) has not been
    tested, and may be broken.


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/build/jam/HaikuImage	2008-05-26 16:52:27 UTC (rev 25662)
@@ -33,7 +33,7 @@
 	funzip #fwcontrol
 	gawk $(X86_ONLY)gdb grep groups gzip gzexe hd head hey hostname id ident
 	ideinfo idestatus ifconfig &lt;bin&gt;install installsound iroster isvolume join
-	keymap kill less lessecho lesskey link listarea listattr listdev listimage
+	keymap kill less lessecho lesskey link listarea listattr listimage #listdev
 	listport listres listsem ln locate logger login logname ls lsindex m4 make
 	makebootable md5sum merge mimeset mkdos mkdir mkfifo mkfs mkindex modifiers mount
 	mount_nfs mountvolume mv nc netstat nl nohup od open passwd paste patch
@@ -145,7 +145,7 @@
 AddFilesToHaikuImage beos system add-ons kernel busses agp_gart
 	: $(X86_ONLY)&lt;agp_gart&gt;intel ;
 AddFilesToHaikuImage beos system add-ons kernel busses ide
-	: generic_ide_pci $(X86_ONLY)ide_isa silicon_image_3112 legacy_sata ;
+	: generic_ide_pci ; #$(X86_ONLY)ide_isa silicon_image_3112 legacy_sata ;
 AddFilesToHaikuImage beos system add-ons kernel busses scsi
 	: ahci ;
 AddFilesToHaikuImage beos system add-ons kernel busses usb
@@ -156,7 +156,7 @@
 AddFilesToHaikuImage beos system add-ons kernel file_systems
 	: $(BEOS_ADD_ONS_FILE_SYSTEMS) ;
 AddFilesToHaikuImage beos system add-ons kernel generic
-	: block_io dpc fast_log ide_adapter locked_pool mpu401 scsi_periph ;
+	: block_io dpc ide_adapter locked_pool mpu401 scsi_periph ;
 AddFilesToHaikuImage beos system add-ons kernel partitioning_systems
 	: intel session ;
 AddFilesToHaikuImage beos system add-ons kernel interrupt_controllers
@@ -172,7 +172,7 @@
 AddDriversToHaikuImage audio hmulti	: $(BEOS_ADD_ONS_DRIVERS_AUDIO) ;
 AddDriversToHaikuImage midi			: $(BEOS_ADD_ONS_DRIVERS_MIDI) ;
 AddDriversToHaikuImage bus			: usb_raw ; # fw_raw
-AddDriversToHaikuImage disk scsi	: scsi_cd scsi_dsk ;
+AddDriversToHaikuImage disk scsi	: scsi_dsk ; #scsi_cd;
 AddDriversToHaikuImage disk usb		: usb_disk ;
 AddDriversToHaikuImage disk virtual	: nbd ;
 AddDriversToHaikuImage dvb			: cx23882 ;
@@ -358,9 +358,9 @@
 AddBootModuleSymlinksToHaikuImage
 	pci $(X86_ONLY)isa config_manager ide scsi
 	$(PPC_ONLY)openpic
-	block_io fast_log ide_adapter locked_pool scsi_periph
-	ahci generic_ide_pci $(X86_ONLY)ide_isa silicon_image_3112 legacy_sata
-	scsi_cd scsi_dsk
+	block_io ide_adapter locked_pool scsi_periph
+	generic_ide_pci ahci # $(X86_ONLY)ide_isa silicon_image_3112 legacy_sata
+	scsi_dsk #scsi_cd
 	intel
 	bfs
 ;
@@ -553,7 +553,7 @@
 if $(HAIKU_IMAGE_HOST_NAME) {
 	actions BuildHaikuImageHostnameFile
 	{
-		echo &quot;$(HAIKU_IMAGE_HOST_NAME)&quot; &gt; $(1) 
+		echo &quot;$(HAIKU_IMAGE_HOST_NAME)&quot; &gt; $(1)
 	}
 
 	local file = &lt;haiku-image&gt;hostname ;

Modified: haiku/trunk/headers/os/drivers/block_io.h
===================================================================
--- haiku/trunk/headers/os/drivers/block_io.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/block_io.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -5,9 +5,7 @@
 #ifndef __BLOCK_IO_H__
 #define __BLOCK_IO_H__
 
-/*
-	Part of Open block device manager
-
+/*!
 	Block devices can be easily written by providing the interface
 	specified hereinafter. The block device manager takes care of
 	DMA and other restrictions imposed by underlying controller or
@@ -24,7 +22,6 @@
 typedef struct block_io_handle_info *block_io_handle;
 
 // cookies issued by device driver
-typedef struct block_device_device_cookie *block_device_device_cookie;
 typedef struct block_device_handle_cookie *block_device_handle_cookie;
 
 
@@ -59,15 +56,20 @@
 // maximum number of scatter/gather blocks (uint32, optional, default: unlimited)
 #define B_BLOCK_DEVICE_MAX_SG_BLOCKS &quot;block_device/max_sg_blocks&quot;
 
+typedef struct block_device_cookie {
+	struct device_node	*node;
+} block_device_cookie;
 
 // interface to be provided by device driver
 typedef struct block_device_interface {
 	driver_module_info info;
 
+	void (*set_device)(block_device_cookie *cookie, block_io_device device);
+
 	// iovecs are physical address here
 	// pos and num_blocks are in blocks; bytes_transferred in bytes
 	// vecs are guaranteed to describe enough data for given block count
-	status_t (*open)(block_device_device_cookie device, block_device_handle_cookie *handle);
+	status_t (*open)(block_device_cookie *cookie, block_device_handle_cookie *handle);
 	status_t (*close)(block_device_handle_cookie handle);
 	status_t (*free)(block_device_handle_cookie handle);
 
@@ -79,12 +81,12 @@
 	status_t (*ioctl)(block_device_handle_cookie handle, int op, void *buf, size_t len);
 } block_device_interface;
 
-#define B_BLOCK_IO_MODULE_NAME &quot;generic/block_io/v1&quot;
+#define B_BLOCK_IO_DEVICE_MODULE_NAME &quot;generic/block_io/device_v1&quot;
 
 
 // Interface for Drivers
 
-// blkman interface used for callbacks done by driver
+// interface used for callbacks done by driver
 typedef struct block_io_for_driver_interface {
 	module_info info;
 

Modified: haiku/trunk/headers/os/drivers/bus/IDE.h
===================================================================
--- haiku/trunk/headers/os/drivers/bus/IDE.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/bus/IDE.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -1,18 +1,11 @@
 /*
-** Copyright 2002/03, Thomas Kurschel. All rights reserved.
-** Distributed under the terms of the OpenBeOS License.
-*/
-
-/*
-	Part of Open IDE bus manager
-
-	IDE bus manager interface
-*/
-
+ * Copyright 2002/03, Thomas Kurschel. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
 #ifndef __IDE_H__
 #define __IDE_H__
 
-#include &lt;bus_manager.h&gt;
+
 #include &lt;device_manager.h&gt;
 #include &lt;KernelExport.h&gt;
 
@@ -37,22 +30,27 @@
 union ide_task_file;
 typedef unsigned int ide_reg_mask;
 
+// channel cookie, issued by ide bus manager
+typedef struct ide_bus_info *ide_channel;
+
 // interface of controller driver
 typedef struct {
 	driver_module_info info;
 
+	void (*set_channel)(void *cookie, ide_channel channel);
+
 	status_t (*write_command_block_regs)
 		(void *channel_cookie, union ide_task_file *tf, ide_reg_mask mask);
 	status_t (*read_command_block_regs)
 		(void *channel_cookie, union ide_task_file *tf, ide_reg_mask mask);
 
 	uint8 (*get_altstatus) (void *channel_cookie);
-	status_t (*write_device_control) (void *channel_cookie, uint8 val);	
+	status_t (*write_device_control) (void *channel_cookie, uint8 val);
 
 	status_t (*write_pio) (void *channel_cookie, uint16 *data, int count, bool force_16bit );
 	status_t (*read_pio) (void *channel_cookie, uint16 *data, int count, bool force_16bit );
 
-	status_t (*prepare_dma)(void *channel_cookie, 
+	status_t (*prepare_dma)(void *channel_cookie,
 							const physical_entry *sg_list, size_t sg_list_count,
 	                        bool write);
 	status_t (*start_dma)(void *channel_cookie);
@@ -60,10 +58,6 @@
 } ide_controller_interface;
 
 
-// channel cookie, issued by ide bus manager
-typedef struct ide_bus_info *ide_channel;
-
-
 // Interface for Controller Driver
 
 // interface of bus manager as seen from controller driver
@@ -77,7 +71,7 @@
 } ide_for_controller_interface;
 
 
-#define IDE_FOR_CONTROLLER_MODULE_NAME &quot;bus_managers/ide/controller/v1&quot;
+#define IDE_FOR_CONTROLLER_MODULE_NAME &quot;bus_managers/ide/controller/driver_v1&quot;
 
 
 #endif	/* __IDE_H__ */

Modified: haiku/trunk/headers/os/drivers/bus/ISA.h
===================================================================
--- haiku/trunk/headers/os/drivers/bus/ISA.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/bus/ISA.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -12,15 +12,15 @@
 
 	All ISA drivers must be Universal driver (see pnp_manager.h), as they
 	are all direct children of the ISA bus node. Having an ISA PnP bus manager
-	(which we don't), one node would be created per ISA device and thus you 
-	could write Specific drivers, but under normal ISA we don't even know 
+	(which we don't), one node would be created per ISA device and thus you
+	could write Specific drivers, but under normal ISA we don't even know
 	how many devices are there, therefore the Universal driver trick.
 
 	Apart from the loading, the main change is the resource manager. In
 	a driver, you must allocate the resources before registering the node and
 	deallocate it when your node is removed and if the driver isn't loaded at
 	this time. If it is, you must delay deallocation until the driver gets
-	unloaded to make sure no new driver touches the same resources like you 
+	unloaded to make sure no new driver touches the same resources like you
 	meanwhile.
 */
 
@@ -30,22 +30,22 @@
 #include &lt;device_manager.h&gt;
 #include &lt;ISA.h&gt;
 
-// maximum size of one dma transfer 
+// maximum size of one dma transfer
 // (in bytes for 8 bit transfer, in words for 16 bit transfer)
 #define B_MAX_ISA_DMA_COUNT	0x10000
 
 typedef struct isa2_module_info {
-	bus_module_info info;
+	driver_module_info info;
 
-	uint8 (*read_io_8)( int mapped_io_addr );
-	void (*write_io_8)( int mapped_io_addr, uint8 value );
-	uint16 (*read_io_16)( int mapped_io_addr );
-	void (*write_io_16)( int mapped_io_addr, uint16 value );
-	uint32 (*read_io_32)( int mapped_io_addr );
-	void (*write_io_32)( int mapped_io_addr, uint32 value );
-	
+	uint8 (*read_io_8)(int mapped_io_addr);
+	void (*write_io_8)(int mapped_io_addr, uint8 value);
+	uint16 (*read_io_16)(int mapped_io_addr);
+	void (*write_io_16)(int mapped_io_addr, uint16 value);
+	uint32 (*read_io_32)(int mapped_io_addr);
+	void (*write_io_32)(int mapped_io_addr, uint32 value);
+
 	// don't know what it's for, remains for compatibility
-	void *(*ram_address)( const void *physical_address_in_system_memory );
+	void *(*ram_address)(const void *physical_address_in_system_memory);
 
 	// start dma transfer (scattered DMA is not supported as it's EISA specific)
 	status_t (*start_isa_dma)(
@@ -64,4 +64,4 @@
 #define ISA_DRIVERS_DIR &quot;isa&quot;
 
 
-#endif
+#endif	/* _ISA2_H */

Modified: haiku/trunk/headers/os/drivers/bus/PCI.h
===================================================================
--- haiku/trunk/headers/os/drivers/bus/PCI.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/bus/PCI.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -1,164 +1,46 @@
 /*
- * Copyright 2002/03, Thomas Kurschel. All rights reserved.
+ * Copyright 2008, Haiku Inc. All rights reserved.
  * Distributed under the terms of the MIT License.
  */
-
-/*
-	PCI bus manager
-*/
-
 #ifndef _PCI2_H
 #define _PCI2_H
 
+
 #include &lt;device_manager.h&gt;
 #include &lt;PCI.h&gt;
 
-// currently, this structure is disabled to avoid collision with R5 header
-#if 0
 
-typedef struct pci_info {
-	ushort	vendor_id;				/* vendor id */
-	ushort	device_id;				/* device id */
-	uchar	bus;					/* bus number */
-	uchar	device;					/* device number on bus */
-	uchar	function;				/* function number in device */
-	uchar	revision;				/* revision id */
-	uchar	class_api;				/* specific register interface type */
-	uchar	class_sub;				/* specific device function */
-	uchar	class_base;				/* device type (display vs network, etc) */
-	uchar	line_size;				/* cache line size in 32 bit words */
-	uchar	latency;				/* latency timer */
-	uchar	header_type;			/* header type */
-	uchar	bist;					/* built-in self-test */
-	uchar	reserved;				/* filler, for alignment */
-	union {
-		struct {
-			ulong	cardbus_cis;			/* CardBus CIS pointer */
-			ushort	subsystem_id;			/* subsystem (add-in card) id */
-			ushort	subsystem_vendor_id;	/* subsystem (add-in card) vendor id */
-			ulong	rom_base;				/* rom base address, viewed from host */
-			ulong	rom_base_pci;			/* rom base addr, viewed from pci */
-			ulong	rom_size;				/* rom size */
-			ulong	base_registers[6];		/* base registers, viewed from host */
-			ulong	base_registers_pci[6];	/* base registers, viewed from pci */
-			ulong	base_register_sizes[6];	/* size of what base regs point to */
-			uchar	base_register_flags[6];	/* flags from base address fields */
-			uchar	interrupt_line;			/* interrupt line */
-			uchar	interrupt_pin;			/* interrupt pin */
-			uchar	min_grant;				/* burst period @ 33 Mhz */
-			uchar	max_latency;			/* how often PCI access needed */
-		} h0;
-		struct {
-			ulong	base_registers[2];		/* base registers, viewed from host */
-			ulong	base_registers_pci[2];	/* base registers, viewed from pci */
-			ulong	base_register_sizes[2];	/* size of what base regs point to */
-			uchar	base_register_flags[2];	/* flags from base address fields */
-			uchar	primary_bus;
-			uchar	secondary_bus;
-			uchar	subordinate_bus;
-			uchar	secondary_latency;
-			uchar	io_base;
-			uchar	io_limit;
-			ushort	secondary_status;
-			ushort	memory_base;
-			ushort	memory_limit;
-			ushort  prefetchable_memory_base;
-			ushort  prefetchable_memory_limit;
-			ulong	prefetchable_memory_base_upper32;
-			ulong	prefetchable_memory_limit_upper32;
-			ushort	io_base_upper16;
-			ushort	io_limit_upper16;
-			ulong	rom_base;				/* rom base address, viewed from host */
-			ulong	rom_base_pci;			/* rom base addr, viewed from pci */
-			uchar	interrupt_line;			/* interrupt line */
-			uchar	interrupt_pin;			/* interrupt pin */
-			ushort	bridge_control;		
-		} h1; 
-	} u;
-} pci_info;
+typedef struct pci_device pci_device;
 
-#endif
-
-
-typedef struct pci_device_info *pci_device;
-
-//	Interface to one PCI device.
-//	Actually, this is a _function_ of a device only, but 
-//	pci_function_module_info would be a bit non-intuitive
 typedef struct pci_device_module_info {
 	driver_module_info info;
 
-	uint8	(*read_io_8)(pci_device device, int mapped_io_addr);
-	void	(*write_io_8)(pci_device device, int mapped_io_addr, uint8 value);
-	uint16	(*read_io_16)(pci_device device, int mapped_io_addr);
-	void	(*write_io_16)(pci_device device, int mapped_io_addr, uint16 value);
-	uint32	(*read_io_32)(pci_device device, int mapped_io_addr);
-	void	(*write_io_32)(pci_device device, int mapped_io_addr, uint32 value);
+	uint8	(*read_io_8)(pci_device *device, addr_t mappedIOAddress);
+	void	(*write_io_8)(pci_device *device, addr_t mappedIOAddress,
+				uint8 value);
+	uint16	(*read_io_16)(pci_device *device, addr_t mappedIOAddress);
+	void	(*write_io_16)(pci_device *device, addr_t mappedIOAddress,
+				uint16 value);
+	uint32	(*read_io_32)(pci_device *device, addr_t mappedIOAddress);
+	void	(*write_io_32)(pci_device *device, addr_t mappedIOAddress,
+				uint32 value);
 
-	uint32	(*read_pci_config)(pci_device device,
-				uchar	offset,		/* offset in configuration space */
-				uchar	size);		/* # bytes to read (1, 2 or 4) */
-	void	(*write_pci_config)(pci_device device, 
-				uchar	offset,		/* offset in configuration space */
-				uchar	size,		/* # bytes to write (1, 2 or 4) */
-				uint32	value);		/* value to write */
+	void	*(*ram_address)(pci_device *device, const void *physicalAddress);
 
-	void *(*ram_address)(pci_device device, const void *physical_address_in_system_memory);
-	
-/*	status_t (*allocate_iomem)( void *base, size_t len, const char *name );
-	status_t (*release_iomem)( void *base, size_t len );
-	
-	status_t (*allocate_ioports)( uint16 ioport_base, size_t len, const char *name );
-	status_t (*release_ioports)( uint16 ioport_base, size_t len );*/
-
-	status_t (*get_pci_info)(pci_device device, struct pci_info *info);
-	
-	status_t (*find_pci_capability)(pci_device device,
-				uchar	cap_id,
-				uchar	*offset);
+	uint32	(*read_pci_config)(pci_device *device, uint8 offset,
+				uint8 size);
+	void	(*write_pci_config)(pci_device *device, uint8 offset,
+				uint8 size, uint32 value);
+	status_t (*find_pci_capability)(pci_device *device, uint8 capID,
+				uint8 *offset);
+	void 	(*get_pci_info)(pci_device *device, struct pci_info *info);
 } pci_device_module_info;
 
 
-// directory of PCI drivers
-#define PCI_DRIVERS_DIR &quot;pci&quot;
+/* Attributes of PCI device nodes */
+#define B_PCI_DEVICE_DOMAIN		&quot;pci/domain&quot;		/* uint32 */
+#define B_PCI_DEVICE_BUS		&quot;pci/bus&quot;			/* uint8 */
+#define B_PCI_DEVICE_DEVICE		&quot;pci/device&quot;		/* uint8 */
+#define B_PCI_DEVICE_FUNCTION	&quot;pci/function&quot;		/* uint8 */
 
-// attributes of PCI device nodes
-// bus idx (uint8)
-#define PCI_DEVICE_BUS_ITEM &quot;pci/bus&quot;
-// device idx (uint8)
-#define PCI_DEVICE_DEVICE_ITEM &quot;pci/device&quot;
-// function idx (uint8)
-#define PCI_DEVICE_FUNCTION_ITEM &quot;pci/function&quot;
-
-// vendor id (uint16)
-#define PCI_DEVICE_VENDOR_ID_ITEM &quot;pci/vendor_id&quot;
-// device id (uint16)
-#define PCI_DEVICE_DEVICE_ID_ITEM &quot;pci/device_id&quot;
-// subsystem id (uint16)
-#define PCI_DEVICE_SUBSYSTEM_ID_ITEM &quot;pci/subsystem_id&quot;
-// subvendor id (uint16)
-#define PCI_DEVICE_SUBVENDOR_ID_ITEM &quot;pci/subvendor_id&quot;
-
-// device base class (uint8)
-#define PCI_DEVICE_BASE_CLASS_ID_ITEM &quot;pci/class/base_id&quot;
-// device subclass (uint8)
-#define PCI_DEVICE_SUB_CLASS_ID_ITEM &quot;pci/class/sub_id&quot;
-// device api (uint8)
-#define PCI_DEVICE_API_ID_ITEM &quot;pci/class/api_id&quot;
-
-
-// dynamic consumer patterns for PCI devices
-#define PCI_DEVICE_DYNAMIC_CONSUMER_0 \
-	PCI_DRIVERS_DIR &quot;/&quot; \
-	&quot;vendor %&quot; PCI_DEVICE_VENDOR_ID_ITEM &quot;%|&quot; \
-	&quot;, device %&quot; PCI_DEVICE_DEVICE_ID_ITEM &quot;%|&quot; \
-	&quot;, subsystem %&quot; PCI_DEVICE_SUBSYSTEM_ID_ITEM &quot;%|&quot; \
-	&quot;, subvendor %&quot; PCI_DEVICE_SUBVENDOR_ID_ITEM &quot;%&quot;
-	
-#define PCI_DEVICE_DYNAMIC_CONSUMER_1 \
-	PCI_DRIVERS_DIR &quot;/&quot; \
-	&quot;base_class %&quot; PCI_DEVICE_BASE_CLASS_ID_ITEM &quot;%|&quot; \
-	&quot;, sub_class %&quot; PCI_DEVICE_SUB_CLASS_ID_ITEM &quot;%|&quot; \
-	&quot;, api %&quot; PCI_DEVICE_API_ID_ITEM &quot;%&quot;
-
-#endif
+#endif	/* _PCI2_H */

Modified: haiku/trunk/headers/os/drivers/bus/SCSI.h
===================================================================
--- haiku/trunk/headers/os/drivers/bus/SCSI.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/bus/SCSI.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, Haiku, Inc. All RightsReserved.
+ * Copyright 2004-2008, Haiku, Inc. All RightsReserved.
  * Copyright 2002/03, Thomas Kurschel. All rights reserved.
  *
  * Distributed under the terms of the MIT License.
@@ -11,13 +11,13 @@
 	SCSI bus manager interface
 
 	The bus manager interface is _based_ on CAM, but I've modified it because :-
-	- HBA engine, target mode and queue freezing (and probably other features) 
+	- HBA engine, target mode and queue freezing (and probably other features)
 	  aren't supported (at least the first two aren't supported by linux too ;)
 	- Asynchronous events aren't supported (no OS/driver I know uses them)
 	- P/T/L was defined by number not by handle, requiring many redundant tests
 	  and thus making adding/removing of devices/busses very hard, especially if
 	  PnP is to be supported
-	- single entry system as proposed by CAM involves extra tests and overhead 
+	- single entry system as proposed by CAM involves extra tests and overhead
 	  because of generalized data structure
 
 
@@ -26,16 +26,16 @@
 	Something about requests involving data transfer: you can either specify
 	the virtual address in &lt;data&gt; of CCB (in which case it must be continuous),
 	or store a pointer to a S/G list that contains physical addresses in
-	&lt;sg_list&gt;/&lt;sg_count&gt;. If &lt;sg_list&gt; is non-Null, &lt;data&gt; is ignored. 
-	The S/G list must be in kernel space because the request can be executed 
-	in a different thread context. This is also the	reason why the S/G list has 
+	&lt;sg_list&gt;/&lt;sg_count&gt;. If &lt;sg_list&gt; is non-Null, &lt;data&gt; is ignored.
+	The S/G list must be in kernel space because the request can be executed
+	in a different thread context. This is also the	reason why the S/G list has
 	to contain physical addresses. For obvious reason, the data buffer specified
 	by &lt;sg_list&gt; must be locked, but &lt;data&gt; doesn't need to be.
 
-	You can either execute the request synchronously (&quot;sync_io&quot;) or 
-	asynchronously (&quot;async_io&quot;; you have to acquire &lt;completion_sem&gt; to find 
-	out when the request is finished). In the first case you can use either 
-	&lt;data&gt; or &lt;sg_list&gt;, in the latter &lt;sg_list&gt; only. 
+	You can either execute the request synchronously (&quot;sync_io&quot;) or
+	asynchronously (&quot;async_io&quot;; you have to acquire &lt;completion_sem&gt; to find
+	out when the request is finished). In the first case you can use either
+	&lt;data&gt; or &lt;sg_list&gt;, in the latter &lt;sg_list&gt; only.
 
 	The SCSI bus manager takes care that the controller can access the data
 	via DMA by copying it into a buffer if necessary. For the paging path,
@@ -49,28 +49,28 @@
 	&lt;data&gt; is a safe bet.
 
 
-	For SIM writers: 
+	For SIM writers:
 
 	Requests sent by peripheral drivers are forwarded to the &lt;scsi_io&gt; entry
-	of the SIM. You should return as soon as some waiting is required. 
+	of the SIM. You should return as soon as some waiting is required.
 	Usually, the controller raises an IRQ when a request can be continued
 	or is finished. As interrupt handlers must be as fast as possible, you
-	can schedule a DPC in the handler (&lt;schedule_dpc&gt;) which executed by a 
-	high priority service thread that is spawned by the SCSI bus manager 
-	for each bus. This service thread also takes care to submit waiting 
+	can schedule a DPC in the handler (&lt;schedule_dpc&gt;) which executed by a
+	high priority service thread that is spawned by the SCSI bus manager
+	for each bus. This service thread also takes care to submit waiting
 	requests.
 
 	You can specify a maximum number of concurrent requests per bus via
-	path_inquiry (&lt;hba_queue_size&gt;) for the bus. The device limit is 
+	path_inquiry (&lt;hba_queue_size&gt;) for the bus. The device limit is
 	determined via INQUIRY. If you need a lower/dynamic limit, you can refuse
 	a request by &lt;requeue&gt;. If &lt;bus_overflow&gt; is true, no further requests
 	to the bus will be sent, if &lt;bus_overflow&gt; is false, no further requests
 	to the device will be sent. To terminate the overflow condition, call
 	&lt;cont_send_device&gt;/&lt;cont_send_bus&gt;. It also terminated when a request
 	for the bus/device is finished via &lt;finished&gt; or &lt;resubmit&gt;.
-	Because of the asynchronous nature,	requests may still arrive after the 
-	overflow condition being signalled, so you should add a safety test to 
-	&lt;scsi_io&gt;. 
+	Because of the asynchronous nature,	requests may still arrive after the
+	overflow condition being signalled, so you should add a safety test to
+	&lt;scsi_io&gt;.
 
 	If a problem occurs during execution, you can ask for a restart via
 	&lt;resubmit&gt;. The request in question will be submitted as soon as possible.
@@ -86,8 +86,8 @@
 	READ6/WRITE6 commands to READ10/WRITE10 commands, MODE REQUEST6/SENSE6
 	to MODE REQUEST10/SENSE10 and fix the version fields of INQUIRY results,
 	so ATAPI devices can be used like standard SCSI devices. Further, the
-	SCSI bus manager can emulate auto-sense by executing a REQUEST SENSE 
-	if &lt;subsys_status&gt; is SCSI_REQ_CMP_ERR and &lt;device_status&gt; is 
+	SCSI bus manager can emulate auto-sense by executing a REQUEST SENSE
+	if &lt;subsys_status&gt; is SCSI_REQ_CMP_ERR and &lt;device_status&gt; is
 	SCSI_STATUS_CHECK_CONDITION when a request is finished. This emulation
 	may be enhanced/generalized in the future.
 */
@@ -296,7 +296,7 @@
 	driver_module_info info;
 
 	// get CCB
-	// warning: if pool of CCBs is exhausted, this call is delayed until a 
+	// warning: if pool of CCBs is exhausted, this call is delayed until a
 	// CCB is freed, so don't try to allocate more then one CCB at once!
 	scsi_ccb *(*alloc_ccb)(scsi_device device);
 	// free CCB
@@ -320,7 +320,7 @@
 	status_t (*ioctl)(scsi_device device, uint32 op, void *buffer, size_t length);
 } scsi_device_interface;
 
-#define SCSI_DEVICE_MODULE_NAME &quot;bus_managers/scsi/driver/v1&quot;
+#define SCSI_DEVICE_MODULE_NAME &quot;bus_managers/scsi/device/driver_v1&quot;
 
 
 // Bus node
@@ -333,10 +333,10 @@
 #define SCSI_BUS_TYPE_NAME &quot;scsi/bus&quot;
 
 // SCSI bus node driver.
-// This interface can be used by peripheral drivers to access the 
+// This interface can be used by peripheral drivers to access the
 // bus directly.
 typedef struct scsi_bus_interface {
-	bus_module_info info;
+	driver_module_info info;
 
 	// get information about host controller
 	uchar (*path_inquiry)(scsi_bus bus, scsi_path_inquiry *inquiry_data);
@@ -345,7 +345,7 @@
 } scsi_bus_interface;
 
 // name of SCSI bus node driver
-#define SCSI_BUS_MODULE_NAME &quot;bus_managers/scsi/bus/v1&quot;
+#define SCSI_BUS_MODULE_NAME &quot;bus_managers/scsi/bus/driver_v1&quot;
 
 
 // Interface for SIM
@@ -354,7 +354,7 @@
 typedef struct scsi_dpc_info *scsi_dpc_cookie;
 
 // Bus manager interface used by SCSI controller drivers.
-// SCSI controller drivers get this interface passed via their init_device 
+// SCSI controller drivers get this interface passed via their init_device
 // method. Further, they must specify this driver as their fixed consumer.
 typedef struct scsi_for_sim_interface {
 	driver_module_info info;
@@ -363,7 +363,7 @@
 	// bus_overflow: true - too many bus requests
 	//               false - too many device requests
 	// bus/device won't receive requests until cont_sent_bus/cont_send_device
-	// is called or a request is finished via finished(); 
+	// is called or a request is finished via finished();
 	// to avoid race conditions (reporting a full and a available bus at once)
 	// the SIM should synchronize calls to requeue, resubmit and finished
 	void (*requeue)(scsi_ccb *ccb, bool bus_overflow);
@@ -374,7 +374,7 @@
 	// num_requests: number of requests that were handled by device
 	//               when the request was sent (read: how full was the device
 	//               queue); needed to find out how large the device queue is;
-	//               e.g. if three were already running plus this request makes 
+	//               e.g. if three were already running plus this request makes
 	//               num_requests=4
 	void (*finished)(scsi_ccb *ccb, uint num_requests);
 
@@ -404,7 +404,7 @@
 } scsi_for_sim_interface;
 
 
-#define SCSI_FOR_SIM_MODULE_NAME &quot;bus_managers/scsi/sim/v1&quot;
+#define SCSI_FOR_SIM_MODULE_NAME &quot;bus_managers/scsi/sim/driver_v1&quot;
 
 
 // SIM Node
@@ -416,34 +416,35 @@
 // controller name (required, string)
 #define SCSI_DESCRIPTION_CONTROLLER_NAME &quot;controller_name&quot;
 
-typedef void * scsi_sim_cookie;
+typedef void *scsi_sim_cookie;
 
 // SIM interface
 // SCSI controller drivers must provide this interface
 typedef struct scsi_sim_interface {
 	driver_module_info info;
 
+	void (*set_scsi_bus)(scsi_sim_cookie cookie, scsi_bus bus);
+
 	// execute request
-	void (*scsi_io)( scsi_sim_cookie cookie, scsi_ccb *ccb );
+	void (*scsi_io)(scsi_sim_cookie cookie, scsi_ccb *ccb);
 	// abort request
-	uchar (*abort)( scsi_sim_cookie cookie, scsi_ccb *ccb_to_abort );
+	uchar (*abort)(scsi_sim_cookie cookie, scsi_ccb *ccb_to_abort);
 	// reset device
-	uchar (*reset_device)( scsi_sim_cookie cookie, uchar target_id, uchar target_lun );
+	uchar (*reset_device)(scsi_sim_cookie cookie, uchar target_id, uchar target_lun);
 	// terminate request
-	uchar (*term_io)( scsi_sim_cookie cookie, scsi_ccb *ccb_to_terminate );
+	uchar (*term_io)(scsi_sim_cookie cookie, scsi_ccb *ccb_to_terminate);
 
 	// get information about bus
-	uchar (*path_inquiry)( scsi_sim_cookie cookie, scsi_path_inquiry *inquiry_data );
+	uchar (*path_inquiry)(scsi_sim_cookie cookie, scsi_path_inquiry *inquiry_data);
 	// scan bus
 	// this is called immediately before the SCSI bus manager scans the bus
-	uchar (*scan_bus)( scsi_sim_cookie cookie );
+	uchar (*scan_bus)(scsi_sim_cookie cookie);
 	// reset bus
-	uchar (*reset_bus)( scsi_sim_cookie cookie );
-	
-	// get restrictions of one device 
+	uchar (*reset_bus)(scsi_sim_cookie cookie);
+
+	// get restrictions of one device
 	// (used for non-SCSI transport protocols and bug fixes)
-	void (*get_restrictions)(
-		scsi_sim_cookie 	cookie,
+	void (*get_restrictions)(scsi_sim_cookie 	cookie,
 		uchar				target_id,		// target id
 		bool				*is_atapi, 		// set to true if this is an ATAPI device that
 											// needs some commands emulated

Modified: haiku/trunk/headers/os/drivers/device_manager.h
===================================================================
--- haiku/trunk/headers/os/drivers/device_manager.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/os/drivers/device_manager.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2005, Haiku Inc. All Rights Reserved.
+ * Copyright 2004-2008, Haiku Inc. All Rights Reserved.
  * Distributed under the terms of the MIT license.
  */
 #ifndef _DEVICE_MANAGER_H
@@ -11,189 +11,170 @@
 #include &lt;module.h&gt;
 
 
-// type of I/O resource
+/* type of I/O resource */
 enum {
-	IO_MEM = 1,
-	IO_PORT = 2,
-	ISA_DMA_CHANNEL = 3
+	B_IO_MEMORY			= 1,
+	B_IO_PORT			= 2,
+	B_ISA_DMA_CHANNEL	= 3
 };
 
 
-// I/O resource description
+/* I/O resource description */
 typedef struct {
 	uint32	type;
-		// type of I/O resource
+		/* type of I/O resource */
 
 	uint32	base;
-		// I/O memory: first physical address (32 bit)
-		// I/O port: first port address (16 bit)
-		// ISA DMA channel: channel number (0-7)
+		/* I/O memory: first physical address (32 bit)
+		 * I/O port: first port address (16 bit)
+		 * ISA DMA channel: channel number (0-7)
+		 */
 
 	uint32	length;
-		// I/O memory: size of address range (32 bit)
-		// I/O port: size of port range (16 bit)
-		// ISA DMA channel: must be 1
+		/* I/O memory: size of address range (32 bit)
+		 * I/O port: size of port range (16 bit)
+		 * ISA DMA channel: must be 1
+		 */
 } io_resource;
 
-// attribute of a device node
+/* attribute of a device node */
 typedef struct {
 	const char		*name;
-	type_code		type;			// for supported types, see value
+	type_code		type;			/* for supported types, see value */
 	union {
-		uint8		ui8;			// B_UINT8_TYPE
-		uint16		ui16;			// B_UINT16_TYPE
-		uint32		ui32;			// B_UINT32_TYPE
-		uint64		ui64;			// B_UINT64_TYPE
-		const char	*string;		// B_STRING_TYPE
-		struct {					// B_RAW_TYPE
-			void	*data;
+		uint8		ui8;			/* B_UINT8_TYPE */
+		uint16		ui16;			/* B_UINT16_TYPE */
+		uint32		ui32;			/* B_UINT32_TYPE */
+		uint64		ui64;			/* B_UINT64_TYPE */
+		const char	*string;		/* B_STRING_TYPE */
+		struct {					/* B_RAW_TYPE */
+			const void *data;
 			size_t	length;
 		} raw;
 	} value;
 } device_attr;
 
 
-typedef struct device_node_info *device_node_handle;
-typedef struct io_resource_info *io_resource_handle;
-typedef struct device_attr_info *device_attr_handle;
-
+typedef struct device_node device_node;
 typedef struct driver_module_info driver_module_info;
 
 
-// interface of the device manager
+/* interface of the device manager */
 
 typedef struct device_manager_info {
 	module_info info;
 
-	status_t (*init_driver)(device_node_handle node, void *userCookie,
-					driver_module_info **interface, void **cookie);
-	status_t (*uninit_driver)(device_node_handle node);
+	status_t (*rescan_node)(device_node *node);
 
-	status_t (*rescan)(device_node_handle node);
+	status_t (*register_node)(device_node *parent, const char *moduleName,
+					const device_attr *attrs, const io_resource *ioResources,
+					device_node **_node);
+	status_t (*unregister_node)(device_node *node);
 
-	status_t (*register_device)(device_node_handle parent,
-					const device_attr *attrs,
-					const io_resource_handle *io_resources,
-					device_node_handle *node);
-	status_t (*unregister_device)(device_node_handle node);
+	status_t (*get_driver)(device_node *node, driver_module_info **_module,
+					void **_cookie);
 
-	device_node_handle (*get_root)();
-	status_t (*get_next_child_device)(device_node_handle parent,
-		device_node_handle *_node, const device_attr *attrs);
-	device_node_handle (*get_parent)(device_node_handle node);
-	void (*put_device_node)(device_node_handle node);
+	device_node *(*get_root_node)();
+	status_t (*get_next_child_node)(device_node *parent,
+					const device_attr *attrs, device_node **node);
+	device_node *(*get_parent_node)(device_node *node);
+	void (*put_node)(device_node *node);
 
-	status_t (*acquire_io_resources)(io_resource *resources,
-					io_resource_handle *handles);
-	status_t (*release_io_resources)(const io_resource_handle *handles);
+	status_t (*publish_device)(device_node *node, const char *path,
+					const char *deviceModuleName);
+	status_t (*unpublish_device)(device_node *node, const char *path);
 
 	int32 (*create_id)(const char *generator);
 	status_t (*free_id)(const char *generator, uint32 id);
 
-	status_t (*get_attr_uint8)(device_node_handle node,
-					const char *name, uint8 *value, bool recursive);
-	status_t (*get_attr_uint16)(device_node_handle node,
-					const char *name, uint16 *value, bool recursive);
-	status_t (*get_attr_uint32)(device_node_handle node,
-					const char *name, uint32 *value, bool recursive);
-	status_t (*get_attr_uint64)(device_node_handle node,
-					const char *name, uint64 *value, bool recursive);
-	status_t (*get_attr_string)(device_node_handle node,
-					const char *name, char **value, bool recursive);
-	status_t (*get_attr_raw)(device_node_handle node,
-					const char *name, void **data, size_t *_size,
-					bool recursive);
+	status_t (*get_attr_uint8)(const device_node *node, const char *name,
+					uint8 *value, bool recursive);
+	status_t (*get_attr_uint16)(const device_node *node, const char *name,
+					uint16 *value, bool recursive);
+	status_t (*get_attr_uint32)(const device_node *node, const char *name,
+					uint32 *value, bool recursive);
+	status_t (*get_attr_uint64)(const device_node *node, const char *name,
+					uint64 *value, bool recursive);
+	status_t (*get_attr_string)(const device_node *node, const char *name,
+					const char **_value, bool recursive);
+	status_t (*get_attr_raw)(const device_node *node, const char *name,
+					const void **_data, size_t *_size, bool recursive);
 
-	status_t (*get_next_attr)(device_node_handle node,
-					device_attr_handle *attrHandle);
-	status_t (*release_attr)(device_node_handle node,
-					device_attr_handle attr_handle);
-	status_t (*retrieve_attr)(device_attr_handle attr_handle,
-					const device_attr **attr);
-	status_t (*write_attr)(device_node_handle node,
-					const device_attr *attr);
-	status_t (*remove_attr)(device_node_handle node, const char *name);
+	status_t (*get_next_attr)(device_node *node, device_attr **_attr);
 } device_manager_info;
 
 
 #define B_DEVICE_MANAGER_MODULE_NAME &quot;system/device_manager/v1&quot;
 
 
-// interface of device driver
+/* interface of device driver */
 
 struct driver_module_info {
 	module_info info;
 
-	float (*supports_device)(device_node_handle parent, bool *_noConnection);
-	status_t (*register_device)(device_node_handle parent);
+	float (*supports_device)(device_node *parent);
+	status_t (*register_device)(device_node *parent);
 
-	status_t (*init_driver)(device_node_handle node, void *user_cookie, void **_cookie);
-	status_t (*uninit_driver)(void *cookie);
+	status_t (*init_driver)(device_node *node, void **_driverCookie);
+	void (*uninit_driver)(void *driverCookie);
+	status_t (*register_child_devices)(void *driverCookie);
+	status_t (*rescan_child_devices)(void *driverCookie);
 
-	void (*device_removed)(device_node_handle node, void *cookie);
-	void (*device_cleanup)(device_node_handle node);
-
-	void (*get_supported_paths)(const char ***_busses, const char ***_devices);
+	void (*device_removed)(void *driverCookie);
+	status_t (*suspend)(void *driverCookie, int32 state);
+	status_t (*resume)(void *driverCookie);
 };
 
 
-// standard device node attributes
+/* standard device node attributes */
 
-#define PNP_MANAGER_ID_GENERATOR &quot;id_generator&quot;
-	// if you are using an id generator (see create_id), you can let the 
-	// manager automatically free the id when the node is deleted by setting 
-	// the following attributes:
-	// name of generator (string)
-#define PNP_MANAGER_AUTO_ID &quot;auto_id&quot;
-	// generated id (uint32)
-	
-#define B_DRIVER_MODULE				&quot;driver/module&quot;
-#define B_DRIVER_PRETTY_NAME		&quot;driver/pretty name&quot;
-#define B_DRIVER_FIXED_CHILD		&quot;driver/fixed child&quot;
-#define B_DRIVER_MAPPING			&quot;driver/mapping&quot;
-#define B_DRIVER_BUS				&quot;driver/bus&quot;
-#define B_DRIVER_FIND_DEVICES_ON_DEMAND &quot;driver/on demand&quot;
-#define B_DRIVER_EXPLORE_LAST		&quot;driver/explore last&quot;
+#define B_DEVICE_PRETTY_NAME		&quot;device/pretty name&quot;		/* string */
+#define B_DEVICE_MAPPING			&quot;device/mapping&quot;			/* string */
+#define B_DEVICE_BUS				&quot;device/bus&quot;				/* string */
+#define B_DEVICE_FIXED_CHILD		&quot;device/fixed child&quot;		/* string */
+#define B_DEVICE_FLAGS				&quot;device/flags&quot;				/* uint32 */
 
-#define B_DRIVER_UNIQUE_DEVICE_ID	&quot;unique id&quot;
-#define B_DRIVER_DEVICE_TYPE		&quot;device type&quot;
+#define B_DEVICE_VENDOR_ID			&quot;device/vendor&quot;				/* uint16 */
+#define B_DEVICE_ID					&quot;device/id&quot;					/* uint16 */
+#define B_DEVICE_TYPE				&quot;device/type&quot;
+	/* uint16, PCI base class */
+#define B_DEVICE_SUB_TYPE			&quot;device/subtype&quot;
+	/* uint16, PCI sub type */
+#define B_DEVICE_INTERFACE			&quot;device/interface&quot;
+	/* uint16, PCI class API */
 
-#define B_AUDIO_DRIVER_TYPE			&quot;audio&quot;
-#define B_BUS_DRIVER_TYPE			&quot;bus&quot;
-#define B_DISK_DRIVER_TYPE			&quot;disk&quot;
-#define B_GRAPHICS_DRIVER_TYPE		&quot;graphics&quot;
-#define B_INPUT_DRIVER_TYPE			&quot;input&quot;
-#define B_MISC_DRIVER_TYPE			&quot;misc&quot;
-#define B_NETWORK_DRIVER_TYPE		&quot;net&quot;
-#define B_VIDEO_DRIVER_TYPE			&quot;video&quot;
-#define B_INTERRUPT_CONTROLLER_DRIVER_TYPE	&quot;interrupt controller&quot;
+#define B_DEVICE_UNIQUE_ID			&quot;device/unique id&quot;			/* string */
 
-#define PNP_DRIVER_CONNECTION &quot;connection&quot;
-	// connection of parent the device is attached to (optional, string)
-	// there can be only one device per connection
+/* device flags */
+#define B_FIND_CHILD_ON_DEMAND		0x01
+#define B_FIND_MULTIPLE_CHILDREN	0x02
+#define B_KEEP_DRIVER_LOADED		0x04
 
 
-// interface of a bus device driver
+/* interface of device */
 
-typedef struct bus_module_info {
-	driver_module_info info;
+typedef struct io_request io_request;
 
-	// scan the bus and register all devices.
-	status_t (*register_child_devices)(void *cookie);
+struct device_module_info {
+	module_info info;
 
-	// user initiated rescan of the bus - only propagate changes
-	// you only need to implement this, if you cannot detect device changes yourself
-	// driver is always loaded during this call, but other hooks may
-	// be called concurrently
-	status_t (*rescan_bus)(void *cookie);
-} bus_module_info;
+	status_t (*init_device)(void *driverCookie, void **_deviceCookie);
+	void (*uninit_device)(void *deviceCookie);
+	void (*device_removed)(void *deviceCookie);
 
+	status_t (*open)(void *deviceCookie, const char *path, int openMode,
+					void **_cookie);
+	status_t (*close)(void *cookie);
+	status_t (*free)(void *cookie);
+	status_t (*read)(void *cookie, off_t pos, void *buffer, size_t *_length);
+	status_t (*write)(void *cookie, off_t pos, const void *buffer,
+					size_t *_length);
+	status_t (*io)(void *cookie, io_request *request);
+	status_t (*control)(void *cookie, uint32 op, void *buffer, size_t length);
+	status_t (*select)(void *cookie, uint8 event, selectsync *sync);
+	status_t (*deselect)(void *cookie, uint8 event, selectsync *sync);
+};
 
-// standard attributes
+extern struct device_manager_info *gDeviceManager;
 
-// PnP bus identification (required, uint8)
-// define this to let the PnP manager know that this is a PnP bus
-// the actual content is ignored
-#define PNP_BUS_IS_BUS &quot;bus/is_bus&quot;
-
 #endif	/* _DEVICE_MANAGER_H */

Deleted: haiku/trunk/headers/private/drivers/fast_log.h

Modified: haiku/trunk/headers/private/drivers/ide_adapter.h
===================================================================
--- haiku/trunk/headers/private/drivers/ide_adapter.h	2008-05-26 16:13:19 UTC (rev 25661)
+++ haiku/trunk/headers/private/drivers/ide_adapter.h	2008-05-26 16:52:27 UTC (rev 25662)
@@ -24,7 +24,7 @@
 
 
 // one Physical Region Descriptor (PRD)

[... truncated: 13453 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009093.html">[Haiku-commits] r25661 -	haiku/trunk/src/system/kernel/disk_device_manager
</A></li>
	<LI>Next message: <A HREF="009101.html">[Haiku-commits] r25662 - in haiku/trunk: build/jam headers/os/drivers headers/os/drivers/bus headers/private/drivers headers/private/kernel headers/private/kernel/fs  headers/private/system src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/isa src/add-ons/kernel/bus_managers/pci src/add-ons/kernel/bus_managers/pci/arch/m68k src/add-ons/kernel/bus_managers/pci/arch/ppc src/add-ons/kernel/bus_managers/pci/arch/x86 src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/busses/ide/generic_ide_pci src/add-ons/kernel/busses/scsi/ahci src/add-ons/kernel/drivers/disk/scsi/scsi_dsk src/add-ons/kernel/generic  src/add-ons/kernel/generic/block_io src/add-ons/kernel/generic/ide_adapter src/add-ons/kernel/generic/scsi_periph src/system/kernel src/system/kernel/device_manager  src/system/kernel/fs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9094">[ date ]</a>
              <a href="thread.html#9094">[ thread ]</a>
              <a href="subject.html#9094">[ subject ]</a>
              <a href="author.html#9094">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
