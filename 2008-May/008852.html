<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25497 -	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25497%20-%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich&In-Reply-To=%3C200805142003.m4EK3VJB021212%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008851.html">
   <LINK REL="Next"  HREF="008940.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25497 -	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25497%20-%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich&In-Reply-To=%3C200805142003.m4EK3VJB021212%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25497 -	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich">korli at mail.berlios.de
       </A><BR>
    <I>Wed May 14 22:03:31 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="008851.html">[Haiku-commits] r25496 - haiku/trunk/src/kits/app
</A></li>
        <LI>Next message: <A HREF="008940.html">[Haiku-commits] r25497	-	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8852">[ date ]</a>
              <a href="thread.html#8852">[ thread ]</a>
              <a href="subject.html#8852">[ subject ]</a>
              <a href="author.html#8852">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2008-05-14 22:03:29 +0200 (Wed, 14 May 2008)
New Revision: 25497
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25497&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25497&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/ac97.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/ac97.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/auich.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/config.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/io.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/io.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/multi.c
Log:
* updated ac97 code with the one from Marcus' ich driver
* merged existing quirks (reversed amp enable and ad1981b)
testing is welcome!


Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/ac97.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/ac97.c	2008-05-14 19:57:12 UTC (rev 25496)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/ac97.c	2008-05-14 20:03:29 UTC (rev 25497)
@@ -1,10 +1,8 @@
 /*
- * Auich BeOS Driver for Intel Southbridge audio
+ * AC97 interface
  *
- * Copyright (c) 2003, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
- *
- * Original code : BeOS Driver for Intel ICH AC'97 Link interface
  * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
+ * Copyright (c) 2008, J&#233;r&#244;me Duval
  *
  * All rights reserved.
  * Redistribution and use in source and binary forms, with or without modification, 
@@ -30,14 +28,20 @@
  */
 #include &lt;OS.h&gt;
 #include &lt;stdio.h&gt;
+#include &lt;malloc.h&gt;
 #include &lt;MediaDefs.h&gt;
 #include &quot;ac97.h&quot;
-
 #include &quot;debug.h&quot;
-#include &quot;io.h&quot;
 
 #define B_UTF8_REGISTERED	&quot;\xC2\xAE&quot;
 
+bool ac97_reg_is_valid(ac97_dev *dev, uint8 reg);
+void ac97_amp_enable(ac97_dev *dev, bool onoff);
+void ac97_dump_capabilities(ac97_dev *dev);
+void ac97_detect_capabilities(ac97_dev *dev);
+void ac97_detect_rates(ac97_dev *dev);
+void ac97_update_register_cache(ac97_dev *dev);
+
 const char * stereo_enhancement_technique[] =
 {
 	&quot;No 3D Stereo Enhancement&quot;,
@@ -58,7 +62,7 @@
 	&quot;ESS Technology&quot;,
 	&quot;Harman International&quot;,
 	&quot;Nvidea&quot;,
-	&quot;Philips&quot;,
+	&quot;Philips&quot;
 	&quot;Texas Instruments&quot;,
 	&quot;VLSI Technology&quot;,
 	&quot;TriTech&quot;,
@@ -74,110 +78,112 @@
 	&quot;Unknown (31)&quot;
 };
 
-typedef void (* codec_init)(device_config *);
-typedef void (* codec_amp_enable)(device_config *, bool);
+void default_init(ac97_dev *dev);
+void ad1819_init(ac97_dev *dev);
+void ad1881_init(ac97_dev *dev);
+void ad1885_init(ac97_dev *dev);
+void ad1886_init(ac97_dev *dev);
+void ad1980_init(ac97_dev *dev);
+void ad1981b_init(ac97_dev *dev);
+void alc650_init(ac97_dev *dev);
+void stac9708_init(ac97_dev *dev);
+void stac9721_init(ac97_dev *dev);
+void stac9744_init(ac97_dev *dev);
+void stac9756_init(ac97_dev *dev);
+void tr28028_init(ac97_dev *dev);
+void wm9701_init(ac97_dev *dev);
+void wm9703_init(ac97_dev *dev);
+void wm9704_init(ac97_dev *dev);
 
-typedef struct codec_ops_tag
-{
-	codec_init init;
-	codec_amp_enable amp_enable;
-} codec_ops;
+bool ad1819_set_rate(ac97_dev *dev, uint8 reg, uint32 rate);
+bool ad1819_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate);
 
-typedef struct codec_table_tag
+typedef struct
 {
 	uint32 id;
 	uint32 mask;
-	codec_ops *ops;
+	codec_init init;
 	const char *info;
 } codec_table;
 
-void default_init(device_config *);
-void ad1886_init(device_config *);
-void ad1981b_init(device_config *);
-
-void default_amp_enable(device_config *, bool);
-void cs4299_amp_enable(device_config *, bool);
-
-codec_ops default_ops = { default_init, default_amp_enable };
-codec_ops ad1886_ops = { ad1886_init, default_amp_enable };
-codec_ops ad1981b_ops = { ad1981b_init, default_amp_enable };
-codec_ops cs4299_ops = { default_init, cs4299_amp_enable };
-
 codec_table codecs[] = 
 {
-	/* Vendor ID and description imported from FreeBSD src/sys/dev/sound/pcm/ac97.c */
-	{ 0x414b4d00, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4540&quot; },
-	{ 0x414b4d01, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4542&quot; },
-	{ 0x414b4d02, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4543&quot; },
-	{ 0x43525900, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297&quot; },
-	{ 0x43525903, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297&quot; },
-	{ 0x43525913, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297A&quot; },
-	{ 0x43525914, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297B&quot; },
-	{ 0x43525923, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4294C&quot; },
-	{ 0x4352592b, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4298C&quot; },
-	{ 0x43525931, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299A&quot; },
-	{ 0x43525933, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299C&quot; },
-	{ 0x43525934, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299D&quot; },
-	{ 0x43525941, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4201A&quot; },
-	{ 0x43525951, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4205A&quot; },
-	{ 0x43525961, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4291A&quot; },
-	{ 0x45838308, 0xffffffff, &amp;default_ops, &quot;ESS Technology ES1921&quot; },
-	{ 0x49434511, 0xffffffff, &amp;default_ops, &quot;ICEnsemble ICE1232&quot; },
-	{ 0x4e534331, 0xffffffff, &amp;default_ops, &quot;National Semiconductor LM4549&quot; },
-	{ 0x83847600, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9700/9783/9784&quot; },
-	{ 0x83847604, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9701/9703/9704/9705&quot; },
-	{ 0x83847605, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9704&quot; },
-	{ 0x83847608, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9708/9711&quot; },
-	{ 0x83847609, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9721/9723&quot; },
-	{ 0x83847644, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9744&quot; },
-	{ 0x83847656, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9756/9757&quot; },
-	{ 0x53494c22, 0xffffffff, &amp;default_ops, &quot;Silicon Laboratory Si3036&quot; },
-	{ 0x53494c23, 0xffffffff, &amp;default_ops, &quot;Silicon Laboratory Si3038&quot; },
-	{ 0x54524103, 0xffffffff, &amp;default_ops, &quot;TriTech TR?????&quot; },
-	{ 0x54524106, 0xffffffff, &amp;default_ops, &quot;TriTech TR28026&quot; },
-	{ 0x54524108, 0xffffffff, &amp;default_ops, &quot;TriTech TR28028&quot; },
-	{ 0x54524123, 0xffffffff, &amp;default_ops, &quot;TriTech TR28602&quot; },
-	{ 0x574d4c00, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9701A&quot; },
-	{ 0x574d4c03, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9703/9704&quot; },
-	{ 0x574d4c04, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9704 (quad)&quot; },
-	/* Assembled from datasheets: */
-	{ 0x41445303, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1819B SoundPort&quot;B_UTF8_REGISTERED },
-	{ 0x41445340, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1881 SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445348, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1881A SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445360, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1885 SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445361, 0xffffffff, &amp;ad1886_ops,  &quot;Analog Devices AD1886 SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445362, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1887 SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445363, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1886A SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445371, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445372, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x41445374, 0xffffffff, &amp;ad1981b_ops, &quot;Analog Devices AD1981B SoundMAX&quot;B_UTF8_REGISTERED },
-	{ 0x414c4320, 0xfffffff0, &amp;default_ops, &quot;Avance Logic (Realtek) ALC100/ALC100P, RL5383/RL5522&quot; },
-	{ 0x414c4730, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC101&quot; },
-#if 0
-	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC200/ALC200A&quot; }, /* datasheet says id2 = 4710 */
-	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC201/ALC201A&quot; }, /* 4710 or 4720 */
-	{ 0x414c4720, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC650&quot; }, /* datasheet says id2 = 4720 */
-#else
-	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC200/ALC200A or ALC201/ALC201A&quot; },
-	{ 0x414c4720, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC650 or ALC201/ALC201A&quot; },
-#endif
-	{ 0x414c4740, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC202/ALC202A&quot; },
+	{ CODEC_ID_AD1819,	0xffffffff, ad1819_init,	&quot;Analog Devices AD1819A, AD1819B SoundPort&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1881,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1881 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1881A,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1881A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1885,	0xffffffff, ad1885_init,	&quot;Analog Devices AD1885 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1886,	0xffffffff, ad1886_init,	&quot;Analog Devices AD1886 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1886A,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1886A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1887,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1887 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1888,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1888 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1980,	0xffffffff, ad1980_init,	&quot;Analog Devices AD1980 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445371,		0xffffffff, default_init,	&quot;Analog Devices 0x41445371 (???)&quot; },
+	{ 0x41445372,		0xffffffff, default_init,	&quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1981B,	0xffffffff, ad1981b_init,	&quot;Analog Devices AD1981B SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1985,	0xffffffff, default_init,	&quot;Analog Devices AD1985 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1986,	0xffffffff, default_init,	&quot;Analog Devices AD1986 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AK4540,	0xffffffff, default_init,	&quot;Asahi Kasei AK4540&quot; },
+	{ CODEC_ID_AK4542,	0xffffffff, default_init,	&quot;Asahi Kasei AK4542&quot; },
+	{ CODEC_ID_AK4543,	0xffffffff, default_init,	&quot;Asahi Kasei AK4543&quot; },
+	{ 0x414c4320,		0xfffffff0, default_init,	&quot;Avance Logic (Realtek) ALC100/ALC100P, RL5383/RL5522&quot; },
+	{ 0x414c4730,		0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC101&quot; },
+	{ CODEC_ID_ALC201A,	0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC200/ALC200A, ALC201/ALC201A&quot; }, /* 0x4710 = ALC201A */
+	{ 0x414c4720,		0xffffffff, alc650_init,	&quot;Avance Logic (Realtek) ALC650&quot; }, /* 0x4720 = ALC650 */
+	{ 0x414c4740,		0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC202/ALC202A&quot; },
+	{ 0x434d4941,		0xffffffff, default_init,	&quot;C-Media CMI9738&quot; },
+	{ 0x434d4961,		0xffffffff, default_init,	&quot;C-Media CMI9739&quot; },
+	{ 0x43525900,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525903,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525913,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297A&quot; },
+	{ 0x43525914,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297B&quot; },
+	{ 0x43525923,		0xffffffff, default_init,	&quot;Cirrus Logic CS4294C&quot; },
+	{ 0x4352592b,		0xffffffff, default_init,	&quot;Cirrus Logic CS4298C&quot; },
+	{ CODEC_ID_CS4299A,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299A&quot; },
+	{ CODEC_ID_CS4299C,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299C&quot; },
+	{ CODEC_ID_CS4299D,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299D&quot; },
+	{ 0x43525941,		0xffffffff, default_init,	&quot;Cirrus Logic CS4201A&quot; },
+	{ 0x43525951,		0xffffffff, default_init,	&quot;Cirrus Logic CS4205A&quot; },
+	{ 0x43525961,		0xffffffff, default_init,	&quot;Cirrus Logic CS4291A&quot; },
+	{ 0x45838308,		0xffffffff, default_init,	&quot;ESS Technology ES1921&quot; },
+	{ 0x49434511,		0xffffffff, default_init,	&quot;ICEnsemble ICE1232&quot; },
+	{ 0x4e534331,		0xffffffff, default_init,	&quot;National Semiconductor LM4549&quot; },
+	{ CODEC_ID_STAC9700,0xffffffff, default_init,	&quot;SigmaTel STAC9700/9783/9784&quot; },
+	{ CODEC_ID_STAC9704,0xffffffff, default_init,	&quot;SigmaTel STAC9701/03, STAC9704/07, STAC9705 (???)&quot; },
+	{ CODEC_ID_STAC9705,0xffffffff, default_init,	&quot;SigmaTel STAC9704 (???)&quot; },
+	{ CODEC_ID_STAC9708,0xffffffff, stac9708_init,	&quot;SigmaTel STAC9708/9711&quot; },
+	{ CODEC_ID_STAC9721,0xffffffff, stac9721_init,	&quot;SigmaTel STAC9721/9723&quot; },
+	{ CODEC_ID_STAC9744,0xffffffff, stac9744_init,	&quot;SigmaTel STAC9744&quot; },
+	{ CODEC_ID_STAC9752,0xffffffff, default_init,	&quot;SigmaTel STAC9752/53&quot; },
+	{ CODEC_ID_STAC9756,0xffffffff, stac9756_init,	&quot;SigmaTel STAC9756/9757&quot; },
+	{ CODEC_ID_STAC9766,0xffffffff, default_init,	&quot;SigmaTel STAC9766/67&quot; },
+	{ 0x53494c22,		0xffffffff, default_init,	&quot;Silicon Laboratory Si3036&quot; },
+	{ 0x53494c23,		0xffffffff, default_init,	&quot;Silicon Laboratory Si3038&quot; },
+	{ 0x54524103,		0xffffffff, default_init,	&quot;TriTech TR?????&quot; },
+	{ 0x54524106,		0xffffffff, default_init,	&quot;TriTech TR28026&quot; },
+	{ 0x54524108,		0xffffffff, tr28028_init,	&quot;TriTech TR28028&quot; },
+	{ 0x54524123,		0xffffffff, default_init,	&quot;TriTech TR28602&quot; },
+	{ 0x574d4c00,		0xffffffff, wm9701_init,	&quot;Wolfson WM9701A&quot; },
+	{ 0x574d4c03,		0xffffffff, wm9703_init,	&quot;Wolfson WM9703/9704&quot; },
+	{ 0x574d4c04,		0xffffffff, wm9704_init,	&quot;Wolfson WM9704 (quad)&quot; },	
 	/* Vendors only: */
-	{ 0x41445300, 0xffffff00, &amp;default_ops, &quot;Analog Devices&quot; },
-	{ 0x414b4d00, 0xffffff00, &amp;default_ops, &quot;Asahi Kasei&quot; },
-	{ 0x414c4700, 0xffffff00, &amp;default_ops, &quot;Avance Logic (Realtek)&quot; },
-	{ 0x43525900, 0xffffff00, &amp;default_ops, &quot;Cirrus Logic&quot; },
-	{ 0x45838300, 0xffffff00, &amp;default_ops, &quot;ESS Technology&quot; },
-	{ 0x49434500, 0xffffff00, &amp;default_ops, &quot;ICEnsemble&quot; },
-	{ 0x4e534300, 0xffffff00, &amp;default_ops, &quot;National Semiconductor&quot; },
-	{ 0x83847600, 0xffffff00, &amp;default_ops, &quot;SigmaTel&quot; },
-	{ 0x53494c00, 0xffffff00, &amp;default_ops, &quot;Silicon Laboratory&quot; },
-	{ 0x54524100, 0xffffff00, &amp;default_ops, &quot;TriTech&quot; },
-	{ 0x574d4c00, 0xffffff00, &amp;default_ops, &quot;Wolfson&quot; },
-	{ 0x00000000, 0x00000000, &amp;default_ops, &quot;Unknown&quot; } /* must be last one, matches every codec */
+	{ 0x41445300,		0xffffff00, default_init,	&quot;Analog Devices&quot; },
+	{ 0x414b4d00,		0xffffff00, default_init,	&quot;Asahi Kasei&quot; },
+	{ 0x414c4700,		0xffffff00, default_init,	&quot;Avance Logic (Realtek)&quot; },
+	{ 0x434d4900,		0xffffff00, default_init,	&quot;C-Media&quot; },
+	{ 0x43525900,		0xffffff00, default_init,	&quot;Cirrus Logic&quot; },
+	{ 0x45838300,		0xffffff00, default_init,	&quot;ESS Technology&quot; },
+	{ 0x49434500,		0xffffff00, default_init,	&quot;ICEnsemble&quot; },
+	{ 0x4e534300,		0xffffff00, default_init,	&quot;National Semiconductor&quot; },
+	{ 0x83847600,		0xffffff00, default_init,	&quot;SigmaTel&quot; },
+	{ 0x53494c00,		0xffffff00, default_init,	&quot;Silicon Laboratory&quot; },
+	{ 0x54524100,		0xffffff00, default_init,	&quot;TriTech&quot; },
+	{ 0x574d4c00,		0xffffff00, default_init,	&quot;Wolfson&quot; },
+	{ 0x00000000,		0x00000000, default_init,	&quot;Unknown&quot; } /* must be last one, matches every codec */
 };
 
-static codec_table *
+codec_table *find_codec_table(uint32 codecid);
+
+codec_table *
 find_codec_table(uint32 codecid)
 {
 	codec_table *codec;
@@ -187,128 +193,761 @@
 	return codec;
 }
 
-const char *
-ac97_get_3d_stereo_enhancement(device_config *config)
+void
+ac97_attach(ac97_dev **_dev, codec_reg_read reg_read, codec_reg_write reg_write, void *cookie,
+	ushort subvendor_id, ushort subsystem_id)
 {
-	uint16 data;
-	data = auich_codec_read(config, AC97_RESET);
-	data = (data &gt;&gt; 10) &amp; 31;
-	return stereo_enhancement_technique[data];
+	ac97_dev *dev;
+	codec_table *codec;
+	
+	*_dev = dev = (ac97_dev *) malloc(sizeof(ac97_dev));
+	dev-&gt;cookie = cookie;
+	dev-&gt;reg_read = reg_read;
+	dev-&gt;reg_write = reg_write;
+	dev-&gt;codec_id = (reg_read(cookie, AC97_VENDOR_ID1) &lt;&lt; 16) | reg_read(cookie, AC97_VENDOR_ID2);
+	codec = find_codec_table(dev-&gt;codec_id);
+	dev-&gt;codec_info = codec-&gt;info;
+	dev-&gt;init = codec-&gt;init;
+	dev-&gt;set_rate = 0;
+	dev-&gt;get_rate = 0;
+	dev-&gt;clock = 48000; /* default clock on non-broken motherboards */
+	dev-&gt;min_vsr = 0x0001;	
+	dev-&gt;max_vsr = 0xffff;
+	dev-&gt;reversed_eamp_polarity = false;
+	dev-&gt;subsystem = (subvendor_id &lt;&lt; 16) | subsystem_id;
+	
+	if (dev-&gt;subsystem == 0x161f202f
+		|| dev-&gt;subsystem == 0x161f203a
+		|| dev-&gt;subsystem == 0x161f204c
+		|| dev-&gt;subsystem == 0x104d8144
+		|| dev-&gt;subsystem == 0x104d8197
+		|| dev-&gt;subsystem == 0x104d81c0
+		|| dev-&gt;subsystem == 0x104d81c5
+		|| dev-&gt;subsystem == 0x103c3089
+		|| dev-&gt;subsystem == 0x103c309a
+		|| dev-&gt;subsystem == 0x10338213
+		|| dev-&gt;subsystem == 0x103382be) {
+		dev-&gt;reversed_eamp_polarity = true;
+	}
+
+	/* reset the codec */	
+	LOG((&quot;codec reset\n&quot;));
+	ac97_reg_uncached_write(dev, AC97_RESET, 0x0000);
+	snooze(50000); // 50 ms
+
+	/* setup register cache */
+	ac97_update_register_cache(dev);
+
+	dev-&gt;codec_3d_stereo_enhancement = stereo_enhancement_technique[(ac97_reg_cached_read(dev, AC97_RESET) &gt;&gt; 10) &amp; 31];
+	dev-&gt;capabilities = 0;
+
+	ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 1, 1); // enable variable rate audio
+
+	ac97_detect_capabilities(dev);
+
+	dev-&gt;init(dev);
+	ac97_amp_enable(dev, true);
+	
+	/* set mixer defaults, enabled Line-out sources are PCM-out, CD-in, Line-in */
+	ac97_reg_update(dev, AC97_CENTER_LFE_VOLUME, 0x0000);	/* set LFE &amp; center volume 0dB */
+	ac97_reg_update(dev, AC97_SURR_VOLUME, 0x0000);			/* set surround volume 0dB */
+	ac97_reg_update(dev, AC97_MASTER_VOLUME, 0x0000);		/* set master output 0dB */
+	ac97_reg_update(dev, AC97_AUX_OUT_VOLUME, 0x0000);		/* set aux output 0dB */
+	ac97_reg_update(dev, AC97_MONO_VOLUME, 0x0000);			/* set mono output 0dB */
+	ac97_reg_update(dev, AC97_PCM_OUT_VOLUME, 0x0808);		/* enable pcm-out */
+	ac97_reg_update(dev, AC97_CD_VOLUME, 0x0808);			/* enable cd-in */
+	ac97_reg_update(dev, AC97_LINE_IN_VOLUME, 0x0808);		/* enable line-in */
+	
+	/* set record line in */
+	ac97_reg_update(dev, AC97_RECORD_SELECT, 0x0404);
+	
+	ac97_dump_capabilities(dev);
 }
 
-const char *
-ac97_get_vendor_id_description(device_config *config)
+void
+ac97_detach(ac97_dev *dev)
 {
-	uint32 id = ac97_get_vendor_id(config);
-	codec_table *codec = find_codec_table(id);
-	char f = (id &gt;&gt; 24) &amp; 0xff;
-	char s = (id &gt;&gt; 16) &amp; 0xff;
-	char t = (id &gt;&gt;  8) &amp; 0xff;
-	if (f == 0) f = '?';
-	if (s == 0) s = '?';
-	if (t == 0) t = '?';
-	LOG((&quot;codec %c%c%c %u\n&quot;,f,s,t,id &amp; 0xff));
-	LOG((&quot;info: %s\n&quot;,codec-&gt;info));
-	return codec-&gt;info;
+	/* Mute everything */
+	ac97_reg_update_bits(dev, AC97_CENTER_LFE_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_SURR_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_MASTER_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_AUX_OUT_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_MONO_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_PCM_OUT_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_CD_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_LINE_IN_VOLUME, 0x8000, 0x8000);
+	
+	ac97_amp_enable(dev, false);	
+
+	free(dev);
 }
 
-uint32
-ac97_get_vendor_id(device_config *config)
+void
+ac97_suspend(ac97_dev *dev)
 {
-	uint16 data1;
-	uint16 data2;
-	data1 = auich_codec_read(config, AC97_VENDOR_ID1);
-	data2 = auich_codec_read(config, AC97_VENDOR_ID2);
-	return (((uint32)data1) &lt;&lt; 16) | data2;
+	ac97_amp_enable(dev, false);
 }
 
 void
-ac97_amp_enable(device_config *config, bool yesno)
+ac97_resume(ac97_dev *dev)
 {
-	codec_table *codec;
-	LOG((&quot;ac97_amp_enable\n&quot;));
-	codec = find_codec_table(ac97_get_vendor_id(config));
-	codec-&gt;ops-&gt;amp_enable(config, yesno);
+	ac97_amp_enable(dev, true);
 }
 
 void
-ac97_init(device_config *config)
+ac97_reg_cached_write(ac97_dev *dev, uint8 reg, uint16 value)
 {
-	codec_table *codec;
-	LOG((&quot;ac97_init\n&quot;));
-	codec = find_codec_table(ac97_get_vendor_id(config));
-	codec-&gt;ops-&gt;init(config);
+	if (!ac97_reg_is_valid(dev, reg))
+		return;
+	dev-&gt;reg_write(dev-&gt;cookie, reg, value);
+	dev-&gt;reg_cache[reg] = value;
+}
+
+uint16
+ac97_reg_cached_read(ac97_dev *dev, uint8 reg)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return 0;
+	return dev-&gt;reg_cache[reg];
+}
+
+void
+ac97_reg_uncached_write(ac97_dev *dev, uint8 reg, uint16 value)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return;
+	dev-&gt;reg_write(dev-&gt;cookie, reg, value);
+}
+
+uint16
+ac97_reg_uncached_read(ac97_dev *dev, uint8 reg)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return 0;
+	return dev-&gt;reg_read(dev-&gt;cookie, reg);
+}
+
+bool
+ac97_reg_update(ac97_dev *dev, uint8 reg, uint16 value)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return false;
+	if (ac97_reg_cached_read(dev, reg) == value)
+		return false;
+	ac97_reg_cached_write(dev, reg, value);
+	return true;
+}
+
+bool
+ac97_reg_update_bits(ac97_dev *dev, uint8 reg, uint16 mask, uint16 value)
+{
+	uint16 old;
+	if (!ac97_reg_is_valid(dev, reg))
+		return false;
+	old = ac97_reg_cached_read(dev, reg);
+	value &amp;= mask;
+	value |= (old &amp; ~mask);
+	if (old == value)
+		return false;
+	ac97_reg_cached_write(dev, reg, value);
+	return true;
+}
+
+void
+ac97_update_register_cache(ac97_dev *dev)
+{
+	int reg;
+	for (reg = 0; reg &lt;= 0x7e; reg += 2)
+		dev-&gt;reg_cache[reg] = ac97_reg_uncached_read(dev, reg);
+}
+
+bool
+ac97_set_rate(ac97_dev *dev, uint8 reg, uint32 rate)
+{
+	uint32 value;
+	uint32 old;
 	
-	auich_codec_write(config, AC97_EXTENDED_AUDIO_STATUS,
-		auich_codec_read(config, AC97_EXTENDED_AUDIO_STATUS) | 1);
+	if (dev-&gt;set_rate)
+		return dev-&gt;set_rate(dev, reg, rate);
+
+	value = (uint32)((rate * 48000ULL) / dev-&gt;clock); /* need 64 bit calculation for rates 96000 or higher */
+
+	LOG((&quot;ac97_set_rate: clock = %d, rate = %d, value = %d\n&quot;, dev-&gt;clock, rate, value));
+	
+	/* if double rate audio is currently enabled, divide value by 2 */
+	if (ac97_reg_cached_read(dev, AC97_EXTENDED_STAT_CTRL) &amp; 0x0002)
+		value /= 2;
 		
+	if (value &lt; dev-&gt;min_vsr || value &gt; dev-&gt;max_vsr)
+		return false;
+
+	old = ac97_reg_cached_read(dev, reg);
+	ac97_reg_cached_write(dev, reg, value);
+	if (value != ac97_reg_uncached_read(dev, reg)) {
+		LOG((&quot;ac97_set_rate failed, new rate %d\n&quot;, ac97_reg_uncached_read(dev, reg)));
+		ac97_reg_cached_write(dev, reg, old);
+		return false;
+	}
+	LOG((&quot;ac97_set_rate done\n&quot;));
+	return true;
 }
 
-void default_init(device_config *config)
+bool
+ac97_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate)
 {
+	uint32 value;
+
+	if (dev-&gt;get_rate)
+		return dev-&gt;get_rate(dev, reg, rate);
+
+	value = ac97_reg_cached_read(dev, reg);
+	if (value == 0)
+		return false;
+
+	/* if double rate audio is currently enabled, multiply value by 2 */
+	if (ac97_reg_cached_read(dev, AC97_EXTENDED_STAT_CTRL) &amp; 0x0002)
+		value *= 2;
+
+	*rate = (uint32)((value * (uint64)dev-&gt;clock) / 48000); /* need 64 bit calculation to avoid overflow*/
+	return true;
+}
+
+void
+ac97_set_clock(ac97_dev *dev, uint32 clock)
+{
+	LOG((&quot;ac97_set_clock: clock = %d\n&quot;, clock));
+	dev-&gt;clock = clock;
+	ac97_detect_rates(dev);
+	ac97_dump_capabilities(dev);
+}
+
+void
+ac97_detect_capabilities(ac97_dev *dev)
+{
+	uint16 val;
+	
+	val = ac97_reg_cached_read(dev, AC97_RESET);
+	if (val &amp; 0x0001)
+		dev-&gt;capabilities |= CAP_PCM_MIC;
+	if (val &amp; 0x0004)
+		dev-&gt;capabilities |= CAP_BASS_TREBLE_CTRL;
+	if (val &amp; 0x0008)
+		dev-&gt;capabilities |= CAP_SIMULATED_STEREO;
+	if (val &amp; 0x0010)
+		dev-&gt;capabilities |= CAP_HEADPHONE_OUT;
+	if (val &amp; 0x0020)
+		dev-&gt;capabilities |= CAP_LAUDNESS;
+	if (val &amp; 0x0040)
+		dev-&gt;capabilities |= CAP_DAC_18BIT;
+	if (val &amp; 0x0080)
+		dev-&gt;capabilities |= CAP_DAC_20BIT;
+	if (val &amp; 0x0100)
+		dev-&gt;capabilities |= CAP_ADC_18BIT;
+	if (val &amp; 0x0200)
+		dev-&gt;capabilities |= CAP_ADC_20BIT;
+	if (val &amp; 0x7C00)
+		dev-&gt;capabilities |= CAP_3D_ENHANCEMENT;
+
+	val = ac97_reg_cached_read(dev, AC97_EXTENDED_ID);
+	if (val &amp; EXID_VRA)
+		dev-&gt;capabilities |= CAP_VARIABLE_PCM;
+	if (val &amp; EXID_DRA)
+		dev-&gt;capabilities |= CAP_DOUBLE_PCM;
+	if (val &amp; EXID_SPDIF)
+		dev-&gt;capabilities |= CAP_SPDIF;
+	if (val &amp; EXID_VRM)
+		dev-&gt;capabilities |= CAP_VARIABLE_MIC;
+	if (val &amp; EXID_CDAC)
+		dev-&gt;capabilities |= CAP_CENTER_DAC;
+	if (val &amp; EXID_SDAC)
+		dev-&gt;capabilities |= CAP_SURR_DAC;
+	if (val &amp; EXID_LDAC)
+		dev-&gt;capabilities |= CAP_LFE_DAC;
+	if (val &amp; EXID_AMAP)
+		dev-&gt;capabilities |= CAP_AMAP;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == 0)
+		dev-&gt;capabilities |= CAP_REV21;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == EXID_REV0)
+		dev-&gt;capabilities |= CAP_REV22;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == EXID_REV1)
+		dev-&gt;capabilities |= CAP_REV23;
+		
+	ac97_detect_rates(dev);
+}		
+
+void
+ac97_detect_rates(ac97_dev *dev)
+{
+	uint32 oldrate;
+	
+	dev-&gt;capabilities &amp;= ~CAP_PCM_RATE_MASK;
+
+	if (!ac97_get_rate(dev, AC97_PCM_FRONT_DAC_RATE, &amp;oldrate))
+		oldrate = 48000;
+	
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 20000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_CONTINUOUS;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 8000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_8000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 11025))
+		dev-&gt;capabilities |= CAP_PCM_RATE_11025;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 12000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_12000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 16000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_16000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 22050))
+		dev-&gt;capabilities |= CAP_PCM_RATE_22050;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 24000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_24000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 32000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_32000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 44100))
+		dev-&gt;capabilities |= CAP_PCM_RATE_44100;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 48000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_48000;
+
+	if (dev-&gt;capabilities &amp; CAP_DOUBLE_PCM) {
+		// enable double rate mode
+		if (ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 0x0002, 0x0002)) {
+			if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 88200))
+				dev-&gt;capabilities |= CAP_PCM_RATE_88200;	
+			if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 96000))
+				dev-&gt;capabilities |= CAP_PCM_RATE_96000;
+			// disable double rate mode
+			ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 0x0002, 0x0000);
+		}
+	}
+		
+	ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, oldrate);
+}
+
+void
+ac97_dump_capabilities(ac97_dev *dev)
+{
+	LOG((&quot;AC97 capabilities:\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_MIC))
+		LOG((&quot;CAP_PCM_MIC\n&quot;));
+	if (ac97_has_capability(dev, CAP_BASS_TREBLE_CTRL))
+		LOG((&quot;CAP_BASS_TREBLE_CTRL\n&quot;));
+	if (ac97_has_capability(dev, CAP_SIMULATED_STEREO))
+		LOG((&quot;CAP_SIMULATED_STEREO\n&quot;));
+	if (ac97_has_capability(dev, CAP_HEADPHONE_OUT))
+		LOG((&quot;CAP_HEADPHONE_OUT\n&quot;));
+	if (ac97_has_capability(dev, CAP_LAUDNESS))
+		LOG((&quot;CAP_LAUDNESS\n&quot;));
+	if (ac97_has_capability(dev, CAP_DAC_18BIT))
+		LOG((&quot;CAP_DAC_18BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_DAC_20BIT))
+		LOG((&quot;CAP_DAC_20BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_ADC_18BIT))
+		LOG((&quot;CAP_ADC_18BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_ADC_20BIT))
+		LOG((&quot;CAP_ADC_20BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_3D_ENHANCEMENT))
+		LOG((&quot;CAP_3D_ENHANCEMENT\n&quot;));
+	if (ac97_has_capability(dev, CAP_VARIABLE_PCM))
+		LOG((&quot;CAP_VARIABLE_PCM\n&quot;));
+	if (ac97_has_capability(dev, CAP_DOUBLE_PCM))
+		LOG((&quot;CAP_DOUBLE_PCM\n&quot;));
+	if (ac97_has_capability(dev, CAP_VARIABLE_MIC))
+		LOG((&quot;CAP_VARIABLE_MIC\n&quot;));
+	if (ac97_has_capability(dev, CAP_CENTER_DAC))
+		LOG((&quot;CAP_CENTER_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_SURR_DAC))
+		LOG((&quot;CAP_SURR_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_LFE_DAC))
+		LOG((&quot;CAP_LFE_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_AMAP))
+		LOG((&quot;CAP_AMAP\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV21))
+		LOG((&quot;CAP_REV21\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV22))
+		LOG((&quot;CAP_REV22\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV23))
+		LOG((&quot;CAP_REV23\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_CONTINUOUS))
+		LOG((&quot;CAP_PCM_RATE_CONTINUOUS\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_8000))
+		LOG((&quot;CAP_PCM_RATE_8000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_11025))
+		LOG((&quot;CAP_PCM_RATE_11025\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_12000))
+		LOG((&quot;CAP_PCM_RATE_12000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_16000))
+		LOG((&quot;CAP_PCM_RATE_16000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_22050))
+		LOG((&quot;CAP_PCM_RATE_22050\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_24000))
+		LOG((&quot;CAP_PCM_RATE_24000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_32000))
+		LOG((&quot;CAP_PCM_RATE_32000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_44100))
+		LOG((&quot;CAP_PCM_RATE_44100\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_48000))
+		LOG((&quot;CAP_PCM_RATE_48000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_88200))
+		LOG((&quot;CAP_PCM_RATE_88200\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_96000))
+		LOG((&quot;CAP_PCM_RATE_96000\n&quot;));
+}
+
+bool
+ac97_has_capability(ac97_dev *dev, uint64 cap)
+{
+	// return (dev-&gt;capabilities &amp; cap); // does not work because of 64 bit to integer trucation 
+	return (dev-&gt;capabilities &amp; cap) != 0;
+}
+
+/*************************************************
+ * Codec specific initialization, etc.
+ */
+
+bool
+ac97_reg_is_valid(ac97_dev *dev, uint8 reg)
+{
+	if (reg &amp; 1)
+		return false;
+	if (reg &gt; 0x7e)
+		return false;
+
+	switch (dev-&gt;codec_id) {
+		case CODEC_ID_AK4540:
+		case CODEC_ID_AK4542:
+			if (reg &lt; 0x1e || reg == 0x20 || reg == 0x26 || reg &gt; 0x7a)
+				return true;
+			return false;
+
+		case CODEC_ID_AD1819:
+		case CODEC_ID_AD1881:
+		case CODEC_ID_AD1881A:
+			if (reg &lt; 0x3a || reg &gt; 0x6e)
+				return true;
+			return false;
+
+		case CODEC_ID_AD1885:
+		case CODEC_ID_AD1886:
+		case CODEC_ID_AD1886A:
+		case CODEC_ID_AD1887:
+			if (reg &lt; 0x3c || reg == 0x5a || reg &gt; 0x6e)
+				return true;
+			return false;
+
+		case CODEC_ID_STAC9700:
+		case CODEC_ID_STAC9704:
+		case CODEC_ID_STAC9705:
+		case CODEC_ID_STAC9708:
+		case CODEC_ID_STAC9721:
+		case CODEC_ID_STAC9744:
+		case CODEC_ID_STAC9756:
+			if (reg &lt; 0x3c || reg &gt; 0x58)
+				return true;
+			return false;
+		
+		default:
+			return true;
+	}
+}
+
+void ac97_amp_enable(ac97_dev *dev, bool yesno)
+{
+	switch (dev-&gt;codec_id) {	
+		case CODEC_ID_CS4299A:
+		case CODEC_ID_CS4299C:
+		case CODEC_ID_CS4299D:
+			LOG((&quot;cs4299_amp_enable\n&quot;));
+			if (yesno)
+				ac97_reg_cached_write(dev, 0x68, 0x8004);
+			else
+				ac97_reg_cached_write(dev, 0x68, 0);
+			break;
+		
+		default:
+			LOG((&quot;ac97_amp_enable, reverse eamp = %d\n&quot;, dev-&gt;reversed_eamp_polarity));
+			LOG((&quot;powerdown register was = %#04x\n&quot;, ac97_reg_uncached_read(dev, AC97_POWERDOWN)));
+			if (dev-&gt;reversed_eamp_polarity)
+				yesno = !yesno;
+			if (yesno)
+				ac97_reg_cached_write(dev, AC97_POWERDOWN, ac97_reg_uncached_read(dev, AC97_POWERDOWN) &amp; ~0x8000); /* switch on (low active) */
+			else
+				ac97_reg_cached_write(dev, AC97_POWERDOWN, ac97_reg_uncached_read(dev, AC97_POWERDOWN) | 0x8000); /* switch off */
+			LOG((&quot;powerdown register is = %#04x\n&quot;, ac97_reg_uncached_read(dev, AC97_POWERDOWN)));
+		break;
+	}
+}
+
+bool
+ad1819_set_rate(ac97_dev *dev, uint8 reg, uint32 rate)
+{
+	uint32 value;
+	
+	value = (uint32)((rate * 48000ULL) / dev-&gt;clock); /* need 64 bit calculation for rates 96000 or higher */
+
+	LOG((&quot;ad1819_set_rate: clock = %d, rate = %d, value = %d\n&quot;, dev-&gt;clock, rate, value));
+	
+	if (value &lt; 0x1B58 || value &gt; 0xBB80)
+		return false;
+
+	switch (reg) {
+		case AC97_PCM_FRONT_DAC_RATE:
+			ac97_reg_cached_write(dev, AC97_AD_SAMPLE_RATE_0, value);
+			return true;
+		
+		case AC97_PCM_L_R_ADC_RATE:
+			ac97_reg_cached_write(dev, AC97_AD_SAMPLE_RATE_1, value);
+			return true;
+
+		default:
+			return false;
+	}
+}
+
+bool
+ad1819_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate)
+{
+	uint32 value;
+	
+	switch (reg) {
+		case AC97_PCM_FRONT_DAC_RATE:
+			value = ac97_reg_cached_read(dev, AC97_AD_SAMPLE_RATE_0);
+			break;
+		
+		case AC97_PCM_L_R_ADC_RATE:
+			value = ac97_reg_cached_read(dev, AC97_AD_SAMPLE_RATE_1);
+			break;
+
+		default:
+			return false;
+	}
+
+	*rate = (uint32)((value * (uint64)dev-&gt;clock) / 48000); /* need 64 bit calculation to avoid overflow*/
+	return true;
+}
+
+
+void default_init(ac97_dev *dev)
+{
 	LOG((&quot;default_init\n&quot;));
 }
 
-void ad1886_init(device_config *config)
+void ad1819_init(ac97_dev *dev)
 {
+	LOG((&quot;ad1819_init\n&quot;));
+
+	/* Default config for system with single AD1819 codec */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x7000);
+	ac97_update_register_cache(dev);
+
+	/* The AD1819 chip has proprietary  sample rate controls
+	 * Setup sample rate 0 generator for DAC,
+	 * Setup sample rate 1 generator for ADC,
+	 * ARSR=1, DRSR=0, ALSR=1, DLSR=0
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0101);
+	/* connect special rate set/get functions */
+	dev-&gt;set_rate = ad1819_set_rate;
+	dev-&gt;get_rate = ad1819_get_rate;
+	ac97_detect_rates(dev);
+	ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 48000);
+	ac97_set_rate(dev, AC97_PCM_L_R_ADC_RATE, 48000);
+}
+
+void ad1881_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1881_init\n&quot;));
+	
+	/* Default config for system with single AD1819 codec,
+	 * BROKEN on systems with master &amp; slave codecs */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x7000);
+	ac97_update_register_cache(dev);
+
+	/* Setup DAC and ADC rate generator assignments compatible with AC97 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0404);
+
+	/* Setup variable frame rate limits */
+	dev-&gt;min_vsr = 0x1B58;	/*  7kHz */
+	dev-&gt;max_vsr = 0xBB80;	/* 48kHz */
+}
+
+void ad1885_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1885_init\n&quot;));
+	ad1881_init(dev);
+	
+	/* disable jack sense 0 and 1 (JS0, JS1) to turn off automatic mute */
+	ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE, ac97_reg_cached_read(dev, AC97_AD_JACK_SENSE) | 0x0300);
+}
+
+void ad1886_init(ac97_dev *dev)
+{
 	LOG((&quot;ad1886_init\n&quot;));
-	auich_codec_write(config, AC97_AD_JACKSENSE, 0x0010);
+	ad1881_init(dev);
+	
+	/* change jack sense to always activate outputs*/
+	ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE, 0x0010);
+	/* change SPDIF to a valid value */
+	ac97_reg_cached_write(dev, AC97_SPDIF_CONTROL, 0x2a20);
 }
 
-void ad1981b_init(device_config *config)
+void ad1980_init(ac97_dev *dev)
 {
-	uint32 id;
+	LOG((&quot;ad1980_init\n&quot;));
+
+	/* Select only master codec,
+	 * SPDIF and DAC are linked
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x1001);
+	ac97_update_register_cache(dev);
+	
+	/* Select Line-out driven with mixer data (not surround data)
+	 * Select Headphone-out driven with mixer data (not surround data),
+	 * LOSEL = 0, HPSEL = 1
+	 * XXX this one needs to be changed to support surround	out
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0400);
+}
+
+void ad1981b_init(ac97_dev *dev)
+{
 	LOG((&quot;ad1981b_init\n&quot;));
-	id = (config-&gt;subvendor_id &lt;&lt; 16) | config-&gt;subsystem_id;
-	if (id == 0x103c0934
-		|| id == 0x103c006d
-		|| id == 0x103c088c
-		|| id == 0x103c0890
-		|| id == 0x103c0934
-		|| id == 0x103c0938
-		|| id == 0x103c0944
-		|| id == 0x103c099c) {
-		auich_codec_write(config, AC97_AD_JACKSENSE,
-			auich_codec_read(config, AC97_AD_JACKSENSE) | 0x0800);
+	if (dev-&gt;subsystem == 0x103c0934
+		|| dev-&gt;subsystem == 0x103c006d
+		|| dev-&gt;subsystem == 0x103c088c
+		|| dev-&gt;subsystem == 0x103c0890
+		|| dev-&gt;subsystem == 0x103c0934
+		|| dev-&gt;subsystem == 0x103c0938
+		|| dev-&gt;subsystem == 0x103c0944
+		|| dev-&gt;subsystem == 0x103c099c
+		|| dev-&gt;subsystem == 0x101402d9) {
+		ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE,
+				ac97_reg_cached_read(dev, AC97_AD_JACK_SENSE) | 0x0800);
 	}
 }
 
-void default_amp_enable(device_config *config, bool yesno)
+void alc650_init(ac97_dev *dev)
 {
-	uint32 id;
-	LOG((&quot;default_amp_enable\n&quot;));
-	LOG((&quot;powerdown register was = %#04x\n&quot;,auich_codec_read(config, AC97_POWERDOWN)));
-	id = (config-&gt;subvendor_id &lt;&lt; 16) | config-&gt;subsystem_id;
-	if (id == 0x161f202f
-		|| id == 0x161f203a
-		|| id == 0x161f204c
-		|| id == 0x104d8144
-		|| id == 0x104d8197
-		|| id == 0x104d81c0
-		|| id == 0x104d81c5
-		|| id == 0x103c3089
-		|| id == 0x103c309a
-		|| id == 0x10338213
-		|| id == 0x103382be) {
-		yesno = !yesno;
-		LOG((&quot;using reverse eamp polarity\n&quot;));
-	}
-	if (yesno)
-		auich_codec_write(config, AC97_POWERDOWN, auich_codec_read(config, AC97_POWERDOWN) &amp; ~0x8000); /* switch on (low active) */
-	else
-		auich_codec_write(config, AC97_POWERDOWN, auich_codec_read(config, AC97_POWERDOWN) | 0x8000); /* switch off */
-	LOG((&quot;powerdown register is = %#04x\n&quot;, auich_codec_read(config, AC97_POWERDOWN)));
+	LOG((&quot;alc650_init\n&quot;));
+
+	/* Enable Surround, LFE and Center downmix into Line-out,
+	 * Set Surround-out as duplicated Line-out.
+	 */
+	ac97_reg_cached_write(dev, AC97_ALC650_MULTI_CHAN_CTRL, 0x0007);
+
+	/* Set Surround DAC Volume to 0dB
+	 * Set Center/LFE DAC Volume to 0dB
+	 * (but both should already be set, as these are hardware reset defaults)
+	 */
+	ac97_reg_cached_write(dev, AC97_ALC650_SURR_VOLUME, 0x0808);
+	ac97_reg_cached_write(dev, AC97_ALC650_CEN_LFE_VOLUME, 0x0808);
 }
 
-void cs4299_amp_enable(device_config *config, bool yesno)
+void stac9708_init(ac97_dev *dev)
 {
-	LOG((&quot;cs4299_amp_enable\n&quot;));
-	if (yesno)
-		auich_codec_write(config, 0x68, 0x8004);
-	else
-		auich_codec_write(config, 0x68, 0);
+	LOG((&quot;stac9708_init\n&quot;));
+	/* ALSA initializes some registers that according to the
+	 * documentation for this codec do not exist. If the
+	 * following doesn't work, we may need to do that, too.
+	 */
+	/* The Analog Special reg is at 0x6C, other codecs have it at 0x6E */
+	/* Set Analog Special to default (DAC/ADC -6dB disabled) */
+	ac97_reg_cached_write(dev, 0x6C, 0x0000);
+	/* Set Multi Channel to default */
+	ac97_reg_cached_write(dev, 0x74, 0x0000);

[... truncated: 599 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008851.html">[Haiku-commits] r25496 - haiku/trunk/src/kits/app
</A></li>
	<LI>Next message: <A HREF="008940.html">[Haiku-commits] r25497	-	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8852">[ date ]</a>
              <a href="thread.html#8852">[ thread ]</a>
              <a href="subject.html#8852">[ subject ]</a>
              <a href="author.html#8852">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
