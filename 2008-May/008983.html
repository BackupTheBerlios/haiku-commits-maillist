<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25583 - in haiku/trunk: build/jam	headers/private/graphics headers/private/graphics/s3	src/add-ons/accelerants src/add-ons/accelerants/s3	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/s3
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25583%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/graphics%20headers/private/graphics/s3%0A%09src/add-ons/accelerants%20src/add-ons/accelerants/s3%0A%09src/add-ons/kernel/drivers/graphics%0A%09src/add-ons/kernel/drivers/graphics/s3&In-Reply-To=%3C200805202109.m4KL9sBu018412%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008987.html">
   <LINK REL="Next"  HREF="008986.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25583 - in haiku/trunk: build/jam	headers/private/graphics headers/private/graphics/s3	src/add-ons/accelerants src/add-ons/accelerants/s3	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/s3</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25583%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/graphics%20headers/private/graphics/s3%0A%09src/add-ons/accelerants%20src/add-ons/accelerants/s3%0A%09src/add-ons/kernel/drivers/graphics%0A%09src/add-ons/kernel/drivers/graphics/s3&In-Reply-To=%3C200805202109.m4KL9sBu018412%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25583 - in haiku/trunk: build/jam	headers/private/graphics headers/private/graphics/s3	src/add-ons/accelerants src/add-ons/accelerants/s3	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/s3">axeld at mail.berlios.de
       </A><BR>
    <I>Tue May 20 23:09:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="008987.html">[Haiku-commits] r25582 - in haiku/trunk: build/jam headers/posix src/system/libroot/posix/pthread
</A></li>
        <LI>Next message: <A HREF="008986.html">[Haiku-commits] r25584 - in	haiku/trunk/headers/private/kernel/arch: m68k ppc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8983">[ date ]</a>
              <a href="thread.html#8983">[ thread ]</a>
              <a href="subject.html#8983">[ subject ]</a>
              <a href="author.html#8983">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-05-20 23:09:49 +0200 (Tue, 20 May 2008)
New Revision: 25583
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25583&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25583&amp;view=rev</A>

Added:
   haiku/trunk/headers/private/graphics/s3/
   haiku/trunk/headers/private/graphics/s3/DriverInterface.h
   haiku/trunk/src/add-ons/accelerants/s3/
   haiku/trunk/src/add-ons/accelerants/s3/Jamfile
   haiku/trunk/src/add-ons/accelerants/s3/accel.cpp
   haiku/trunk/src/add-ons/accelerants/s3/accel.h
   haiku/trunk/src/add-ons/accelerants/s3/cursor.cpp
   haiku/trunk/src/add-ons/accelerants/s3/engine.cpp
   haiku/trunk/src/add-ons/accelerants/s3/hooks.cpp
   haiku/trunk/src/add-ons/accelerants/s3/mode.cpp
   haiku/trunk/src/add-ons/accelerants/s3/register_io.cpp
   haiku/trunk/src/add-ons/accelerants/s3/register_io.h
   haiku/trunk/src/add-ons/accelerants/s3/savage.h
   haiku/trunk/src/add-ons/accelerants/s3/savage_cursor.cpp
   haiku/trunk/src/add-ons/accelerants/s3/savage_dpms.cpp
   haiku/trunk/src/add-ons/accelerants/s3/savage_draw.cpp
   haiku/trunk/src/add-ons/accelerants/s3/savage_edid.cpp
   haiku/trunk/src/add-ons/accelerants/s3/savage_init.cpp
   haiku/trunk/src/add-ons/accelerants/s3/savage_mode.cpp
   haiku/trunk/src/add-ons/accelerants/s3/trio64.h
   haiku/trunk/src/add-ons/accelerants/s3/trio64_cursor.cpp
   haiku/trunk/src/add-ons/accelerants/s3/trio64_dpms.cpp
   haiku/trunk/src/add-ons/accelerants/s3/trio64_draw.cpp
   haiku/trunk/src/add-ons/accelerants/s3/trio64_init.cpp
   haiku/trunk/src/add-ons/accelerants/s3/trio64_mode.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge.h
   haiku/trunk/src/add-ons/accelerants/s3/virge_cursor.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge_dpms.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge_draw.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge_edid.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge_init.cpp
   haiku/trunk/src/add-ons/accelerants/s3/virge_mode.cpp
   haiku/trunk/src/add-ons/kernel/drivers/graphics/s3/
   haiku/trunk/src/add-ons/kernel/drivers/graphics/s3/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/graphics/s3/driver.cpp
Removed:
   haiku/trunk/headers/private/graphics/s3savage/
   haiku/trunk/src/add-ons/accelerants/s3savage/
   haiku/trunk/src/add-ons/kernel/drivers/graphics/s3savage/
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/src/add-ons/accelerants/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/graphics/Jamfile
Log:
* Replaced the old s3savage driver with the new s3 driver, both written by
  Gerald Zajac. Thanks a lot!
* Also put it on the image by default.


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/build/jam/HaikuImage	2008-05-20 21:09:49 UTC (rev 25583)
@@ -83,7 +83,7 @@
 
 BEOS_ADD_ONS_ACCELERANTS = $(X86_ONLY)radeon.accelerant $(X86_ONLY)nvidia.accelerant
 	$(X86_ONLY)matrox.accelerant $(X86_ONLY)neomagic.accelerant
-	$(X86_ONLY)intel_extreme.accelerant $(X86_ONLY)s3savage.accelerant vesa.accelerant
+	$(X86_ONLY)intel_extreme.accelerant $(X86_ONLY)s3.accelerant vesa.accelerant
 	#$(X86_ONLY)via.accelerant
 	#$(X86_ONLY)vmware.accelerant
 ;
@@ -122,7 +122,7 @@
 BEOS_ADD_ONS_DRIVERS_AUDIO = auich auvia emuxki ; #hda
 BEOS_ADD_ONS_DRIVERS_GRAPHICS = $(X86_ONLY)radeon $(X86_ONLY)nvidia
 	$(X86_ONLY)neomagic $(X86_ONLY)matrox $(X86_ONLY)intel_extreme
-	$(X86_ONLY)s3savage vesa #$(X86_ONLY)via #$(X86_ONLY)vmware
+	$(X86_ONLY)s3 vesa #$(X86_ONLY)via #$(X86_ONLY)vmware
 ;
 BEOS_ADD_ONS_DRIVERS_MIDI = emuxki ;
 BEOS_ADD_ONS_DRIVERS_NET = $(X86_ONLY)3com etherpci $(X86_ONLY)ipro1000

Added: haiku/trunk/headers/private/graphics/s3/DriverInterface.h
===================================================================
--- haiku/trunk/headers/private/graphics/s3/DriverInterface.h	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/headers/private/graphics/s3/DriverInterface.h	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,238 @@
+/*
+	Copyright 2007-2008 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Other authors:
+	Gerald Zajac 2007-2008
+*/
+
+#ifndef DRIVERINTERFACE_H
+#define DRIVERINTERFACE_H
+
+
+#include &lt;Accelerant.h&gt;
+#include &lt;GraphicsDefs.h&gt;
+#include &lt;Drivers.h&gt;
+#include &lt;edid.h&gt;
+
+
+// This is the info that needs to be shared between the kernel driver and
+// the accelerant for the sample driver.
+
+#if defined(__cplusplus)
+extern &quot;C&quot; {
+#endif
+
+#define ENABLE_DEBUG_TRACE		// if defined, turns on debug output to syslog
+
+
+#define NUM_ELEMENTS(a) ((int)(sizeof(a) / sizeof(a[0]))) 	// for computing number of elements in an array
+
+struct benaphore {
+	sem_id	sem;
+	int32	ben;
+};
+
+#define INIT_BEN(x) 	x.sem = create_sem(0, &quot;S3 &quot;#x&quot; benaphore&quot;);	x.ben = 0;
+#define AQUIRE_BEN(x)	if((atomic_add(&amp;(x.ben), 1)) &gt;= 1) acquire_sem(x.sem);
+#define RELEASE_BEN(x)	if((atomic_add(&amp;(x.ben), -1)) &gt; 1) release_sem(x.sem);
+#define DELETE_BEN(x)	delete_sem(x.sem);
+
+
+#define S3_PRIVATE_DATA_MAGIC	 0x4521 // a private driver rev, of sorts
+
+
+enum {
+	S3_GET_PRIVATE_DATA = B_DEVICE_OP_CODES_END + 1,
+	S3_DEVICE_NAME,
+	S3_GET_PIO,
+	S3_SET_PIO,
+	S3_RUN_INTERRUPTS,
+};
+
+
+// Chip type numbers.  These are used to group the chips into related
+// groups.	See table S3_ChipTable in driver.c
+
+enum S3_ChipType {
+	S3_TRIO64 = 1,
+	S3_TRIO64_VP,		// Trio64V+ has same ID as Trio64 but different revision number
+	S3_TRIO64_UVP,
+	S3_TRIO64_V2,
+		Trio64ChipsEnd,
+	S3_VIRGE,
+	S3_VIRGE_VX,
+	S3_VIRGE_DXGX,
+	S3_VIRGE_GX2,
+	S3_VIRGE_MX,
+	S3_VIRGE_MXP,
+	S3_TRIO_3D,
+	S3_TRIO_3D_2X,
+		VirgeChipsEnd,
+	S3_SAVAGE_3D,
+	S3_SAVAGE_MX,
+	S3_SAVAGE4,
+	S3_PROSAVAGE,
+	S3_TWISTER,
+	S3_PROSAVAGE_DDR,
+	S3_SUPERSAVAGE,
+	S3_SAVAGE2000,
+};
+
+
+#define S3_TRIO64_FAMILY(chip)	(chip &lt; Trio64ChipsEnd)
+#define S3_VIRGE_FAMILY(chip)	(chip &gt; Trio64ChipsEnd &amp;&amp; chip &lt; VirgeChipsEnd)
+#define S3_SAVAGE_FAMILY(chip)	(chip &gt; VirgeChipsEnd)
+
+#define S3_VIRGE_GX2_SERIES(chip)	(chip == S3_VIRGE_GX2 || chip == S3_TRIO_3D_2X)
+#define S3_VIRGE_MX_SERIES(chip)	(chip == S3_VIRGE_MX || chip == S3_VIRGE_MXP)
+
+#define S3_SAVAGE_3D_SERIES(chip)	((chip == S3_SAVAGE_3D) || (chip == S3_SAVAGE_MX))
+#define S3_SAVAGE4_SERIES(chip)		((chip == S3_SAVAGE4)		\
+									|| (chip == S3_PROSAVAGE)	\
+									|| (chip == S3_TWISTER)		\
+									|| (chip == S3_PROSAVAGE_DDR))
+#define	S3_SAVAGE_MOBILE_SERIES(chip)	((chip == S3_SAVAGE_MX)	\
+										|| (chip == S3_SUPERSAVAGE))
+#define S3_MOBILE_TWISTER_SERIES(chip)	((chip == S3_TWISTER)	\
+										|| (chip == S3_PROSAVAGE_DDR))
+
+
+
+enum MonitorType {
+	MT_CRT,
+	MT_LCD,			// laptop LCD display
+	MT_DFP			// DVI display
+};
+
+
+// Bitmap descriptor structures for BCI (for Savage chips)
+struct HIGH {
+	unsigned short Stride;
+	unsigned char Bpp;
+	unsigned char ResBWTile;
+};
+
+struct BMPDESC1 {
+	unsigned long Offset;
+	HIGH  HighPart;
+};
+
+struct BMPDESC2 {
+	unsigned long LoPart;
+	unsigned long HiPart;
+};
+
+union BMPDESC {
+	BMPDESC1 bd1;
+	BMPDESC2 bd2;
+};
+
+
+
+struct DisplayModeEx : display_mode {
+	uint32	bpp;			// bits/pixel
+	uint32	bytesPerRow;	// number of bytes in one line/row
+};
+
+
+struct SharedInfo {
+	// Device ID info.
+	uint16	vendorID;			// PCI vendor ID, from pci_info
+	uint16	deviceID;			// PCI device ID, from pci_info
+	uint8	revision;			// PCI device revsion, from pci_info
+	uint32	chipType;			// indicates group in which chip belongs (a group has similar functionality)
+	char	chipName[32];		// user recognizable name of chip
+
+	bool	bAccelerantInUse;	// true = accelerant has been initialized
+	bool	bInterruptAssigned;	// card has a useable interrupt assigned to it
+
+	sem_id	vertBlankSem;		// vertical blank semaphore; if &lt; 0, there is no semaphore
+
+	// Memory mappings.
+	area_id regsArea;			// area_id for the memory mapped registers. It will
+								// be cloned into accelerant's address space.
+	area_id videoMemArea;		// video memory area_id.  The addresses are shared with all teams.
+	void*	videoMemAddr;		// video memory addr as viewed from virtual memory
+	void*	videoMemPCI;		// video memory addr as viewed from the PCI bus (for DMA)
+	uint32	videoMemSize; 		// video memory size in bytes.
+
+	uint32	cursorOffset;		// offset of cursor in video memory
+	uint32	frameBufferOffset;	// offset of frame buffer in video memory
+	uint32	maxFrameBufferSize;	// max available video memory for frame buffer
+
+	// Color spaces supported by current video chip/driver.
+	color_space	colorSpaces[6];
+	uint32	colorSpaceCount;	// number of color spaces in array colorSpaces
+
+	// List of screen modes.
+	area_id modeArea;			// area containing list of display modes the driver supports
+	uint32	modeCount;			// number of display modes in the list
+
+	// Cursor info.
+	struct {
+		uint16	hot_x;			// Cursor hot spot. Top left corner of the cursor
+		uint16	hot_y;			// is 0,0
+	} cursor;
+
+	// Current display mode configuration, and other parameters related to
+	// current display mode.
+	DisplayModeEx displayMode;	// current display mode configuration
+	int32	commonCmd;			// flags common to drawing commands of current display mode
+
+	edid1_info	edidInfo;
+	bool		bHaveEDID;		// true = EDID info from device is in edidInfo
+
+	// Acceleration engine.
+	struct {
+		uint64		count;		// last fifo slot used
+		uint64		lastIdle;	// last fifo slot we *know* the engine was idle after
+		benaphore	lock;	 	// for serializing access to the acceleration engine
+	} engine;
+
+	int		mclk;
+
+	MonitorType	displayType;
+
+	uint16	panelX;				// laptop LCD width
+	uint16	panelY;				// laptop LCD height
+
+	// Command Overflow Buffer (COB) parameters for Savage chips.
+	bool	bDisableCOB;		// enable/disable COB for Savage 4 &amp; ProSavage
+	uint32	cobIndex;			// size index
+	uint32	cobSize;			// size in bytes
+	uint32	cobOffset;			// offset in video memory
+	uint32	bciThresholdLo; 	// low and high thresholds for
+	uint32  bciThresholdHi; 	// shadow status update (32bit words)
+
+	BMPDESC GlobalBD;			// Bitmap Descriptor for BCI
+};
+
+
+// Set some boolean condition (like enabling or disabling interrupts)
+struct S3SetBoolState {
+	uint32	magic;		// magic number to make sure the caller groks us
+	bool	bEnable;	// state to set
+};
+
+
+// Retrieve the area_id of the kernel/accelerant shared info
+struct S3GetPrivateData {
+	uint32	magic;		// magic number to make sure the caller groks us
+	area_id sharedInfoArea;	// ID of area containing shared information
+};
+
+
+struct S3GetSetPIO {
+	uint32	  magic;	// magic number to make sure the caller groks us
+	uint32	  offset;	// offset of PIO register to read/write
+	uint32	  size;		// number of bytes to transfer
+	uint32	  value;	// value to write or value that was read
+};
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	// DRIVERINTERFACE_H

Modified: haiku/trunk/src/add-ons/accelerants/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/Jamfile	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/Jamfile	2008-05-20 21:09:49 UTC (rev 25583)
@@ -7,7 +7,7 @@
 SubInclude HAIKU_TOP src add-ons accelerants neomagic ;
 SubInclude HAIKU_TOP src add-ons accelerants nvidia ;
 SubInclude HAIKU_TOP src add-ons accelerants radeon ;
-SubInclude HAIKU_TOP src add-ons accelerants s3savage ;
+SubInclude HAIKU_TOP src add-ons accelerants s3 ;
 SubInclude HAIKU_TOP src add-ons accelerants tdfx ;
 SubInclude HAIKU_TOP src add-ons accelerants vesa ;
 SubInclude HAIKU_TOP src add-ons accelerants via ;

Added: haiku/trunk/src/add-ons/accelerants/s3/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/Jamfile	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/Jamfile	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,43 @@
+SubDir HAIKU_TOP src add-ons accelerants s3 ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+UsePrivateHeaders graphics ;
+UsePrivateHeaders [ FDirName graphics s3 ] ;
+UsePrivateHeaders [ FDirName graphics common ] ;
+
+Addon s3.accelerant :
+	accel.cpp
+	cursor.cpp
+	engine.cpp
+	hooks.cpp
+	mode.cpp
+	register_io.cpp
+	
+	savage_cursor.cpp
+	savage_dpms.cpp
+	savage_draw.cpp
+	savage_edid.cpp
+	savage_init.cpp
+	savage_mode.cpp
+	
+	trio64_cursor.cpp
+	trio64_dpms.cpp
+	trio64_draw.cpp
+	trio64_init.cpp
+	trio64_mode.cpp
+	
+	virge_cursor.cpp
+	virge_dpms.cpp
+	virge_draw.cpp
+	virge_edid.cpp
+	virge_init.cpp
+	virge_mode.cpp
+
+	: be libaccelerantscommon.a
+;
+
+Package haiku-s3-cvs :
+	s3.accelerant :
+	boot home config add-ons accelerants ;
+	

Added: haiku/trunk/src/add-ons/accelerants/s3/accel.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/accel.cpp	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/accel.cpp	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,217 @@
+/*
+	Copyright 2007-2008 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2007-2008
+*/
+
+#include &quot;accel.h&quot;
+
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+
+
+
+AccelerantInfo gInfo;		// global data used by various source files of accelerant.
+
+
+
+static status_t 
+InitCommon(int fileDesc)
+{
+	// Initialization function used by primary and cloned accelerants.
+
+	gInfo.deviceFileDesc = fileDesc;
+
+	// Get pointer to registers and shared data from driver.
+
+	S3GetPrivateData gpd;
+	gpd.magic = S3_PRIVATE_DATA_MAGIC;
+
+	status_t result = ioctl(gInfo.deviceFileDesc, S3_GET_PRIVATE_DATA, &amp;gpd, sizeof(gpd));
+	if (result != B_OK)
+		return result;
+
+	gInfo.sharedInfoArea = clone_area(&quot;S3 shared info&quot;, (void**)&amp;(gInfo.sharedInfo),
+		B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, gpd.sharedInfoArea);
+	if (gInfo.sharedInfoArea &lt; 0)
+		return gInfo.sharedInfoArea;	// sharedInfoArea has error code
+
+	gInfo.regsArea = clone_area(&quot;S3 regs area&quot;, (void**)&amp;(gInfo.regs),
+		B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, gInfo.sharedInfo-&gt;regsArea);
+	if (gInfo.regsArea &lt; 0) {
+		delete_area(gInfo.sharedInfoArea);
+		return gInfo.regsArea;		// regsArea has error code
+	}
+
+	// Set pointers to various device specific functions.
+
+	if (S3_SAVAGE_FAMILY(gInfo.sharedInfo-&gt;chipType))
+		Savage_SetFunctionPointers();
+	else if (S3_TRIO64_FAMILY(gInfo.sharedInfo-&gt;chipType))
+		Trio64_SetFunctionPointers();
+	else if (S3_VIRGE_FAMILY(gInfo.sharedInfo-&gt;chipType))
+		Virge_SetFunctionPointers();
+	else
+		return B_ERROR;		// undefined chip type code
+
+	return B_OK;
+}
+
+
+static void 
+UninitCommon(void)
+{
+	// This function is used by both primary and cloned accelerants.
+
+	delete_area(gInfo.regsArea);
+	gInfo.regs = 0;
+
+	delete_area(gInfo.sharedInfoArea);
+	gInfo.sharedInfo = 0;
+}
+
+
+status_t 
+InitAccelerant(int fileDesc)
+{
+	// Initialize the accelerant.	fileDesc is the file handle of the device
+	// (in /dev/graphics) that has been opened by the app_server.
+
+	TRACE(&quot;Enter InitAccelerant()\n&quot;);
+
+	gInfo.bAccelerantIsClone = false;		// indicate this is primary accelerant
+
+	status_t result = InitCommon(fileDesc);
+	if (result == B_OK) {
+		SharedInfo&amp; si = *gInfo.sharedInfo;
+
+		TRACE(&quot;Vendor ID: 0x%X,  Device ID: 0x%X\n&quot;, si.vendorID, si.deviceID);
+
+		// Ensure that InitAccelerant is executed just once (copies should be clones)
+
+		if (si.bAccelerantInUse) {
+			result = B_NOT_ALLOWED;
+		} else {
+			result = gInfo.ChipInit();	// perform init related to current chip
+			if (result == B_OK) {
+
+				INIT_BEN(si.engine.lock);
+				si.engine.lastIdle = 0;
+				si.engine.count = 0;
+
+				gInfo.ShowCursor(false);
+
+				// ensure that this function won't be executed again (copies should be clones)
+				si.bAccelerantInUse = true;
+			}
+		}
+
+		if (result != B_OK)
+			UninitCommon();
+	}
+
+	TRACE(&quot;Leave InitAccelerant(), result: 0x%X\n&quot;, result);
+	return result;
+}
+
+
+ssize_t 
+AccelerantCloneInfoSize(void)
+{
+	// Return the number of bytes required to hold the information required
+	// to clone the device.  The information is merely the name of the device;
+	// thus, return the size of the name buffer.
+
+	return B_OS_NAME_LENGTH;
+}
+
+
+void 
+GetAccelerantCloneInfo(void* data)
+{
+	// Return the info required to clone the device.  Argument data points to
+	// a buffer which is the size returned by AccelerantCloneInfoSize().
+
+	ioctl(gInfo.deviceFileDesc, S3_DEVICE_NAME, data, B_OS_NAME_LENGTH);
+}
+
+
+status_t 
+CloneAccelerant(void* data)
+{
+	// Initialize a copy of the accelerant as a clone.  Argument data points to
+	// a copy of the data which was returned by GetAccelerantCloneInfo().
+
+	TRACE(&quot;Enter CloneAccelerant()\n&quot;);
+
+	char path[MAXPATHLEN] = &quot;/dev/&quot;;
+	strcat(path, (const char*)data);
+
+	gInfo.deviceFileDesc = open(path, B_READ_WRITE);	// open the device
+	if (gInfo.deviceFileDesc &lt; 0)
+		return errno;
+
+	gInfo.bAccelerantIsClone = true;
+
+	status_t result = InitCommon(gInfo.deviceFileDesc);
+	if (result != B_OK) {
+		close(gInfo.deviceFileDesc);
+		return result;
+	}
+
+	result = gInfo.modeListArea = clone_area(&quot;S3 cloned display_modes&quot;,
+		(void**) &amp;gInfo.modeList, B_ANY_ADDRESS, B_READ_AREA,
+		gInfo.sharedInfo-&gt;modeArea);
+	if (result &lt; 0) {
+		UninitCommon();
+		close(gInfo.deviceFileDesc);
+		return result;
+	}
+
+	TRACE(&quot;Leave CloneAccelerant()\n&quot;);
+	return B_OK;
+}
+
+
+void 
+UninitAccelerant(void)
+{
+	delete_area(gInfo.modeListArea);
+	gInfo.modeList = NULL;
+
+	UninitCommon();
+
+	if (gInfo.bAccelerantIsClone)
+		close(gInfo.deviceFileDesc);
+}
+
+
+sem_id 
+AccelerantRetraceSemaphore(void)
+{
+	// Return the semaphore id that will be used to signal that a vertical
+	// retrace occured.
+
+	return B_ERROR;
+}
+
+
+status_t 
+GetAccelerantDeviceInfo(accelerant_device_info* adi)
+{
+	// Get info about the device.
+
+	SharedInfo&amp; si = *gInfo.sharedInfo;
+
+	adi-&gt;version = 1;
+	strcpy(adi-&gt;name, &quot;S3 chipset&quot;);
+	strcpy(adi-&gt;chipset, si.chipName);
+	strcpy(adi-&gt;serial_no, &quot;unknown&quot;);
+	adi-&gt;memory = si.maxFrameBufferSize;
+	adi-&gt;dac_speed = 270;
+
+	return B_OK;
+}

Added: haiku/trunk/src/add-ons/accelerants/s3/accel.h
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/accel.h	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/accel.h	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,202 @@
+/*
+	Copyright 2007-2008 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2007-2008
+*/
+
+#ifndef _ACCEL_H
+#define _ACCEL_H
+
+#include &quot;DriverInterface.h&quot;
+#include &quot;register_io.h&quot;
+
+
+#if defined(__cplusplus)
+extern &quot;C&quot; {
+#endif
+
+
+
+#undef TRACE
+
+#ifdef ENABLE_DEBUG_TRACE
+extern &quot;C&quot; void  _sPrintf(const char* format, ...);
+#	define TRACE(x...) _sPrintf(&quot;S3: &quot; x)
+#else
+#	define TRACE(x...) ;
+#endif
+
+
+// Global data used by various source files of the accelerant.
+
+struct AccelerantInfo {
+	int			 deviceFileDesc;	// file descriptor of kernel driver
+
+	SharedInfo*	 sharedInfo;		// address of info shared between accelerants &amp; driver
+	area_id		 sharedInfoArea;	// shared info area ID
+
+	uint8*		 regs;				// base address of MMIO register area
+	area_id		 regsArea;			// MMIO register area ID
+
+	display_mode* modeList;			// list of standard display modes
+	area_id		 modeListArea;		// mode list area ID
+
+	bool		 bAccelerantIsClone;// true if this is a cloned accelerant
+
+	// Pointers to wait handlers.
+	void	(*WaitQueue)(uint32);
+	void	(*WaitIdleEmpty)();
+
+	// Pointers to DPMS functions.
+	uint32	(*DPMSCapabilities)(void);
+	uint32	(*DPMSMode)(void);
+	status_t (*SetDPMSMode)(uint32 dpms_flags);
+
+	// Pointers to cursor functions.
+	bool	(*LoadCursorImage)(int width, int height, uint8* and_mask, uint8* xor_mask);
+	void	(*SetCursorPosition)(int x, int y);
+	void	(*ShowCursor)(bool bShow);
+
+	// Pointers to 2D acceleration functions.
+	void	(*FillRectangle)(engine_token*, uint32 color, fill_rect_params*, uint32 count);
+	void	(*FillSpan)(engine_token*, uint32 color, uint16* list, uint32 count);
+	void	(*InvertRectangle)(engine_token*, fill_rect_params*, uint32 count);
+	void	(*ScreenToScreenBlit)(engine_token*, blit_params*, uint32 count);
+
+	// Pointers to other functions.
+	void	(*AdjustFrame)(const DisplayModeEx&amp; mode);
+	status_t (*ChipInit)(void);
+	bool	(*GetColorSpaceParams)(int colorSpace, uint32&amp; bpp, uint32&amp; maxPixelClk);
+	bool	(*SetDisplayMode)(const DisplayModeEx&amp; mode);
+	void	(*SetIndexedColors)(uint count, uint8 first, uint8* color_data, uint32 flags);
+};
+
+extern AccelerantInfo gInfo;
+
+
+// Prototypes of the interface functions called by the app_server.  Note that
+// the functions that are unique to a particular chip family, will be prefixed
+// with the name of the family, and the functions that are applicable to all
+// chips will have no prefix.
+//================================================================
+
+// General
+status_t InitAccelerant(int fd);
+ssize_t  AccelerantCloneInfoSize(void);
+void	 GetAccelerantCloneInfo(void* data);
+status_t CloneAccelerant(void* data);
+void	 UninitAccelerant(void);
+status_t GetAccelerantDeviceInfo(accelerant_device_info* adi);
+sem_id	 AccelerantRetraceSemaphore(void);
+
+// Mode Configuration
+uint32	 AccelerantModeCount(void);
+status_t GetModeList(display_mode* dm);
+status_t ProposeDisplayMode(display_mode* target, const display_mode* low, const display_mode* high);
+status_t SetDisplayMode(display_mode* mode_to_set);
+status_t GetDisplayMode(display_mode* current_mode);
+status_t GetFrameBufferConfig(frame_buffer_config* a_frame_buffer);
+status_t GetPixelClockLimits(display_mode* dm, uint32* low, uint32* high);
+status_t MoveDisplay(uint16 h_display_start, uint16 v_display_start);
+status_t GetTimingConstraints(display_timing_constraints* dtc);
+void	 Savage_SetIndexedColors(uint count, uint8 first, uint8* color_data, uint32 flags);
+void	 Trio64_SetIndexedColors(uint count, uint8 first, uint8* color_data, uint32 flags);
+void	 Virge_SetIndexedColors(uint count, uint8 first, uint8* color_data, uint32 flags);
+status_t GetPreferredDisplayMode(display_mode* preferredMode);
+status_t GetEdidInfo(void* info, size_t size, uint32* _version);
+
+// DPMS
+uint32   Savage_DPMSCapabilities(void);
+uint32   Savage_DPMSMode(void);
+status_t Savage_SetDPMSMode(uint32 dpms_flags);
+
+uint32   Trio64_DPMSCapabilities(void);
+uint32   Trio64_DPMSMode(void);
+status_t Trio64_SetDPMSMode(uint32 dpms_flags);
+
+uint32   Virge_DPMSCapabilities(void);
+uint32   Virge_DPMSMode(void);
+status_t Virge_SetDPMSMode(uint32 dpms_flags);
+
+// Cursor
+status_t SetCursorShape(uint16 width, uint16 height, uint16 hot_x, uint16 hot_y,
+						uint8* andMask, uint8* xorMask);
+void	 MoveCursor(uint16 x, uint16 y);
+void	 Savage_ShowCursor(bool bShow);
+void	 Trio64_ShowCursor(bool bShow);
+void	 Virge_ShowCursor(bool bShow);
+
+// Engine Management
+uint32   AccelerantEngineCount(void);
+status_t AcquireEngine(uint32 capabilities, uint32 max_wait, sync_token* st, engine_token** et);
+status_t ReleaseEngine(engine_token* et, sync_token* st);
+void	 WaitEngineIdle(void);
+status_t GetSyncToken(engine_token* et, sync_token* st);
+status_t SyncToToken(sync_token* st);
+
+// 2D acceleration
+void	 Savage_FillRectangle(engine_token* et, uint32 color, fill_rect_params* list, uint32 count);
+void	 Savage_FillSpan(engine_token* et, uint32 color, uint16* list, uint32 count);
+void	 Savage_InvertRectangle(engine_token* et, fill_rect_params* list, uint32 count);
+void	 Savage_ScreenToScreenBlit(engine_token* et, blit_params* list, uint32 count);
+
+void	 Trio64_FillRectangle(engine_token* et, uint32 color, fill_rect_params* list, uint32 count);
+void	 Trio64_FillSpan(engine_token* et, uint32 color, uint16* list, uint32 count);
+void	 Trio64_InvertRectangle(engine_token* et, fill_rect_params* list, uint32 count);
+void	 Trio64_ScreenToScreenBlit(engine_token* et, blit_params* list, uint32 count);
+
+void	 Virge_FillRectangle(engine_token* et, uint32 color, fill_rect_params* list, uint32 count);
+void	 Virge_FillSpan(engine_token* et, uint32 color, uint16* list, uint32 count);
+void	 Virge_InvertRectangle(engine_token* et, fill_rect_params* list, uint32 count);
+void	 Virge_ScreenToScreenBlit(engine_token* et, blit_params* list, uint32 count);
+
+
+
+// Prototypes for other functions that are called from source files other than
+// where they are defined.
+//============================================================================
+
+status_t CreateModeList(bool (*checkMode)(const display_mode* mode));
+void	 InitCrtcTimingValues(const DisplayModeEx&amp; mode, int horzScaleFactor, uint8 crtc[],
+							  uint8&amp; cr3b, uint8&amp; cr3c, uint8&amp; cr5d, uint8&amp; cr5e);
+bool	 IsModeUsable(const display_mode* mode);
+
+// Savage functions.
+
+bool	 Savage_GetEdidInfo(void);
+
+bool	 Savage_LoadCursorImage(int width, int height, uint8* and_mask, uint8* xor_mask);
+void	 Savage_SetCursorPosition(int x, int y);
+
+void	 Savage_AdjustFrame(const DisplayModeEx&amp; mode);
+bool	 Savage_SetDisplayMode(const DisplayModeEx&amp; mode);
+void	 Savage_SetFunctionPointers(void);
+
+// Trio64 functions.
+
+bool	 Trio64_LoadCursorImage(int width, int height, uint8* and_mask, uint8* xor_mask);
+void	 Trio64_SetCursorPosition(int x, int y);
+
+void	 Trio64_AdjustFrame(const DisplayModeEx&amp; mode);
+bool	 Trio64_SetDisplayMode(const DisplayModeEx&amp; mode);
+void	 Trio64_SetFunctionPointers(void);
+
+// Virge functions.
+
+bool	 Virge_GetEdidInfo(void);
+
+bool	 Virge_LoadCursorImage(int width, int height, uint8* and_mask, uint8* xor_mask);
+void	 Virge_SetCursorPosition(int x, int y);
+
+void	 Virge_AdjustFrame(const DisplayModeEx&amp; mode);
+bool	 Virge_SetDisplayMode(const DisplayModeEx&amp; mode);
+void	 Virge_SetFunctionPointers(void);
+
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif	// _ACCEL_H

Added: haiku/trunk/src/add-ons/accelerants/s3/cursor.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/cursor.cpp	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/cursor.cpp	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,81 @@
+/*
+	Copyright 1999, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+
+	Other authors:
+	Gerald Zajac 2007-2008
+*/
+
+#include &quot;accel.h&quot;
+
+
+status_t 
+SetCursorShape(uint16 width, uint16 height, uint16 hot_x, uint16 hot_y,
+				uint8* andMask, uint8* xorMask)
+{
+	// NOTE: Currently, for BeOS, cursor width and height must be equal to 16.
+
+	if ((width != 16) || (height != 16)) {
+		return B_ERROR;
+	} else if ((hot_x &gt;= width) || (hot_y &gt;= height)) {
+		return B_ERROR;
+	} else {
+		// Update cursor variables appropriately.
+
+		SharedInfo&amp; si = *gInfo.sharedInfo;
+		si.cursor.hot_x = hot_x;
+		si.cursor.hot_y = hot_y;
+
+		if ( ! gInfo.LoadCursorImage(width, height, andMask, xorMask))
+			return B_ERROR;
+	}
+
+	return B_OK;
+}
+
+
+void 
+MoveCursor(uint16 xPos, uint16 yPos)
+{
+	// Move the cursor to the specified position on the desktop.  If we're
+	// using some kind of virtual desktop, adjust the display start position
+	// accordingly and position the cursor in the proper &quot;virtual&quot; location.
+
+	int x = xPos;		// use signed int's since chip specific functions
+	int y = yPos;		// need signed int to determine if cursor off screen
+
+	SharedInfo&amp; si = *gInfo.sharedInfo;
+	DisplayModeEx&amp; dm = si.displayMode;
+
+	uint16 hds = dm.h_display_start;	// current horizontal starting pixel
+	uint16 vds = dm.v_display_start;	// current vertical starting line
+
+	// Clamp cursor to virtual display.
+	if (x &gt;= dm.virtual_width)
+		x = dm.virtual_width - 1;
+	if (y &gt;= dm.virtual_height)
+		y = dm.virtual_height - 1;
+
+	// Adjust h/v display start to move cursor onto screen.
+	if (x &gt;= (dm.timing.h_display + hds))
+		hds = x - dm.timing.h_display + 1;
+	else if (x &lt; hds)
+		hds = x;
+
+	if (y &gt;= (dm.timing.v_display + vds))
+		vds = y - dm.timing.v_display + 1;
+	else if (y &lt; vds)
+		vds = y;
+
+	// Reposition the desktop on the display if required.
+	if (hds != dm.h_display_start || vds != dm.v_display_start)
+		MoveDisplay(hds, vds);
+
+	// Put cursor in correct physical position.
+	x -= (hds + si.cursor.hot_x);
+	y -= (vds + si.cursor.hot_y);
+
+	// Position the cursor on the display.
+	gInfo.SetCursorPosition(x, y);
+}
+

Added: haiku/trunk/src/add-ons/accelerants/s3/engine.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/engine.cpp	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/engine.cpp	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,79 @@
+/*
+	Copyright 1999, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+
+	Other authors:
+	Gerald Zajac 2007
+*/
+
+#include &quot;accel.h&quot;
+
+
+static engine_token engineToken = { 1, B_2D_ACCELERATION, NULL };
+
+
+uint32 
+AccelerantEngineCount(void)
+{
+	return 1;
+}
+
+
+status_t 
+AcquireEngine(uint32 capabilities, uint32 max_wait,
+						sync_token* st, engine_token** et)
+{
+	(void)capabilities;	// avoid compiler warning for unused arg
+	(void)max_wait;		// avoid compiler warning for unused arg
+
+	// Acquire the shared benaphore.
+	AQUIRE_BEN(gInfo.sharedInfo-&gt;engine.lock)
+	// Sync if required.
+	if (st)
+		SyncToToken(st);
+
+	// Return an engine token.
+	*et = &engineToken;
+	return B_OK;
+}
+
+
+status_t 
+ReleaseEngine(engine_token* et, sync_token* st)
+{
+	// Update the sync token, if any.
+	if (st)
+		GetSyncToken(et, st);
+
+	// Release the shared benaphore.
+	RELEASE_BEN(gInfo.sharedInfo-&gt;engine.lock)
+	return B_OK;
+}
+
+
+void 
+WaitEngineIdle(void)
+{
+	gInfo.WaitIdleEmpty();	// wait until engine is completely idle
+}
+
+
+status_t 
+GetSyncToken(engine_token* et, sync_token* st)
+{
+	// Engine count will always be zero: we don't support syncing to token (yet).
+	st-&gt;engine_id = et-&gt;engine_id;
+	st-&gt;counter = gInfo.sharedInfo-&gt;engine.count;
+	return B_OK;
+}
+
+
+status_t 
+SyncToToken(sync_token* st)
+{
+	(void)st;		// avoid compiler warning for unused arg
+
+	WaitEngineIdle();
+	return B_OK;
+}
+

Added: haiku/trunk/src/add-ons/accelerants/s3/hooks.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/s3/hooks.cpp	2008-05-20 20:43:28 UTC (rev 25582)
+++ haiku/trunk/src/add-ons/accelerants/s3/hooks.cpp	2008-05-20 21:09:49 UTC (rev 25583)
@@ -0,0 +1,69 @@
+/*
+	Copyright 2008 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2008
+*/
+
+#include &quot;accel.h&quot;
+
+
+extern &quot;C&quot; void* 
+get_accelerant_hook(uint32 feature, void* data)
+{
+	(void)data;		// avoid compiler warning for unused arg
+
+	switch (feature) {
+		// General
+		case B_INIT_ACCELERANT:				return (void*)InitAccelerant;
+		case B_UNINIT_ACCELERANT:			return (void*)UninitAccelerant;
+		case B_CLONE_ACCELERANT:			return (void*)CloneAccelerant;
+		case B_ACCELERANT_CLONE_INFO_SIZE:	return (void*)AccelerantCloneInfoSize;
+		case B_GET_ACCELERANT_CLONE_INFO:	return (void*)GetAccelerantCloneInfo;
+		case B_GET_ACCELERANT_DEVICE_INFO:	return (void*)GetAccelerantDeviceInfo;
+		case B_ACCELERANT_RETRACE_SEMAPHORE: return (void*)AccelerantRetraceSemaphore;
+
+		// Mode Configuration
+		case B_ACCELERANT_MODE_COUNT:	return (void*)AccelerantModeCount;
+		case B_GET_MODE_LIST:			return (void*)GetModeList;
+		case B_PROPOSE_DISPLAY_MODE:	return (void*)ProposeDisplayMode;
+		case B_SET_DISPLAY_MODE:		return (void*)SetDisplayMode;
+		case B_GET_DISPLAY_MODE:		return (void*)GetDisplayMode;
+#ifdef __HAIKU__
+		case B_GET_PREFERRED_DISPLAY_MODE: return (void*)GetPreferredDisplayMode;
+		case B_GET_EDID_INFO:			return (void*)GetEdidInfo;
+#endif
+		case B_GET_FRAME_BUFFER_CONFIG:	return (void*)GetFrameBufferConfig;
+		case B_GET_PIXEL_CLOCK_LIMITS:	return (void*)GetPixelClockLimits;
+		case B_MOVE_DISPLAY:			return (void*)MoveDisplay;
+		case B_SET_INDEXED_COLORS:		return (void*)(gInfo.SetIndexedColors);
+		case B_GET_TIMING_CONSTRAINTS:	return (void*)GetTimingConstraints;
+
+		// DPMS
+		case B_DPMS_CAPABILITIES:		return (void*)(gInfo.DPMSCapabilities);
+		case B_DPMS_MODE:				return (void*)(gInfo.DPMSMode);
+		case B_SET_DPMS_MODE:			return (void*)(gInfo.SetDPMSMode);
+
+		// Cursor
+		case B_SET_CURSOR_SHAPE:		return (void*)SetCursorShape;
+		case B_MOVE_CURSOR:				return (void*)MoveCursor;
+		case B_SHOW_CURSOR:				return (void*)(gInfo.ShowCursor);
+
+		// Engine Management
+		case B_ACCELERANT_ENGINE_COUNT:	return (void*)AccelerantEngineCount;
+		case B_ACQUIRE_ENGINE:			return (void*)AcquireEngine;
+		case B_RELEASE_ENGINE:			return (void*)ReleaseEngine;
+		case B_WAIT_ENGINE_IDLE:		return (void*)WaitEngineIdle;
+		case B_GET_SYNC_TOKEN:			return (void*)GetSyncToken;
+		case B_SYNC_TO_TOKEN:			return (void*)SyncToToken;
+
+		// 2D acceleration
+		case B_SCREEN_TO_SCREEN_BLIT:	return (void*)(gInfo.ScreenToScreenBlit);

[... truncated: 6442 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008987.html">[Haiku-commits] r25582 - in haiku/trunk: build/jam headers/posix src/system/libroot/posix/pthread
</A></li>
	<LI>Next message: <A HREF="008986.html">[Haiku-commits] r25584 - in	haiku/trunk/headers/private/kernel/arch: m68k ppc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8983">[ date ]</a>
              <a href="thread.html#8983">[ thread ]</a>
              <a href="subject.html#8983">[ subject ]</a>
              <a href="author.html#8983">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
