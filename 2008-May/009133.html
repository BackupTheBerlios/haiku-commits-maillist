<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25687 - in haiku/trunk: headers/private/kernel	src/add-ons/kernel/drivers/disk/virtual/remote_disk	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/network/stack	src/libs/compat/freebsd_network src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/slab
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25687%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09src/add-ons/kernel/drivers/disk/virtual/remote_disk%0A%09src/add-ons/kernel/drivers/tty%20src/add-ons/kernel/file_cache%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/ntfs%0A%09src/add-ons/kernel/network/stack%0A%09src/libs/compat/freebsd_network%20src/system/kernel%0A%09src/system/kernel/arch/m68k%20src/system/kernel/arch/ppc%0A%09src/system/kernel/arch/x86%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/slab&In-Reply-To=%3C200805282312.m4SNCcrk024048%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009132.html">
   <LINK REL="Next"  HREF="009134.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25687 - in haiku/trunk: headers/private/kernel	src/add-ons/kernel/drivers/disk/virtual/remote_disk	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/network/stack	src/libs/compat/freebsd_network src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/slab</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25687%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09src/add-ons/kernel/drivers/disk/virtual/remote_disk%0A%09src/add-ons/kernel/drivers/tty%20src/add-ons/kernel/file_cache%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/ntfs%0A%09src/add-ons/kernel/network/stack%0A%09src/libs/compat/freebsd_network%20src/system/kernel%0A%09src/system/kernel/arch/m68k%20src/system/kernel/arch/ppc%0A%09src/system/kernel/arch/x86%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/slab&In-Reply-To=%3C200805282312.m4SNCcrk024048%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25687 - in haiku/trunk: headers/private/kernel	src/add-ons/kernel/drivers/disk/virtual/remote_disk	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/network/stack	src/libs/compat/freebsd_network src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/slab">bonefish at mail.berlios.de
       </A><BR>
    <I>Thu May 29 01:12:38 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009132.html">[Haiku-commits] r25686 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="009134.html">[Haiku-commits] r25688 - in haiku/trunk: build/jam	src/add-ons/kernel/busses/ide/legacy_sata
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9133">[ date ]</a>
              <a href="thread.html#9133">[ thread ]</a>
              <a href="subject.html#9133">[ subject ]</a>
              <a href="author.html#9133">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-05-29 01:12:36 +0200 (Thu, 29 May 2008)
New Revision: 25687
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25687&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25687&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/kernel/lock.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/virtual/remote_disk/remote_disk.cpp
   haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp
   haiku/trunk/src/add-ons/kernel/file_cache/launch_speedup.cpp
   haiku/trunk/src/add-ons/kernel/file_cache/rule_based_prefetcher.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c
   haiku/trunk/src/add-ons/kernel/network/stack/interfaces.cpp
   haiku/trunk/src/libs/compat/freebsd_network/mutex.c
   haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
   haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/fs/node_monitor.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/lock.cpp
   haiku/trunk/src/system/kernel/module.cpp
   haiku/trunk/src/system/kernel/slab/Slab.cpp
Log:
* Changed recursive_lock to use a mutex instead of a semaphore.
* Adjusted code using recursive locks respectively. The initialization
  cannot fail anymore, and it is possible to use recursive locks in the
  early boot process (even uninitialized, if in BSS), which simplifies
  things a little.


Modified: haiku/trunk/headers/private/kernel/lock.h
===================================================================
--- haiku/trunk/headers/private/kernel/lock.h	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/headers/private/kernel/lock.h	2008-05-28 23:12:36 UTC (rev 25687)
@@ -9,16 +9,35 @@
 #ifndef _KERNEL_LOCK_H
 #define _KERNEL_LOCK_H
 
-
 #include &lt;OS.h&gt;
 #include &lt;debug.h&gt;
 
+
+struct mutex_waiter;
+
+typedef struct mutex {
+	const char*				name;
+	struct mutex_waiter*	waiters;
+#ifdef KDEBUG
+	thread_id				holder;
+#else
+	int32					count;
+#endif
+	uint8					flags;
+} mutex;
+
+#define MUTEX_FLAG_CLONE_NAME	0x1
+
+
 typedef struct recursive_lock {
-	sem_id		sem;
+	mutex		lock;
+#ifndef KDEBUG
 	thread_id	holder;
+#endif
 	int			recursion;
 } recursive_lock;
 
+
 typedef struct benaphore {
 	sem_id	sem;
 	int32	count;
@@ -35,22 +54,6 @@
 
 #define RW_MAX_READERS 1000000
 
-struct mutex_waiter;
-
-typedef struct mutex {
-	const char*				name;
-	struct mutex_waiter*	waiters;
-#ifdef KDEBUG
-	thread_id				holder;
-#else
-	int32					count;
-#endif
-	uint8					flags;
-} mutex;
-
-#define MUTEX_FLAG_CLONE_NAME	0x1
-
-
 #if 0 &amp;&amp; KDEBUG // XXX disable this for now, it causes problems when including thread.h here
 #	include &lt;thread.h&gt;
 #define ASSERT_LOCKED_RECURSIVE(r) { ASSERT(thread_get_current_thread_id() == (r)-&gt;holder); }
@@ -65,7 +68,10 @@
 extern &quot;C&quot; {
 #endif
 
-extern status_t	recursive_lock_init(recursive_lock *lock, const char *name);
+extern void	recursive_lock_init(recursive_lock *lock, const char *name);
+	// name is *not* cloned nor freed in recursive_lock_destroy()
+extern void recursive_lock_init_etc(recursive_lock *lock, const char *name,
+	uint32 flags);
 extern void recursive_lock_destroy(recursive_lock *lock);
 extern status_t recursive_lock_lock(recursive_lock *lock);
 extern void recursive_lock_unlock(recursive_lock *lock);

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/virtual/remote_disk/remote_disk.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/virtual/remote_disk/remote_disk.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/virtual/remote_disk/remote_disk.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -49,7 +49,8 @@
 
 	status_t Init()
 	{
-		return recursive_lock_init(this, &quot;remote disk device&quot;);
+		recursive_lock_init(this, &quot;remote disk device&quot;);
+		return B_OK;
 	}
 
 	void Uninit()

Modified: haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -52,9 +52,7 @@
 	memset(gDeviceNames, 0, sizeof(gDeviceNames));
 
 	// create the request mutex
-	status_t error = recursive_lock_init(&amp;gTTYRequestLock, &quot;tty requests&quot;);
-	if (error != B_OK)
-		return error;
+	recursive_lock_init(&amp;gTTYRequestLock, &quot;tty requests&quot;);
 
 	// create the global mutex
 	mutex_init(&amp;gGlobalTTYLock, &quot;tty global&quot;);

Modified: haiku/trunk/src/add-ons/kernel/file_cache/launch_speedup.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_cache/launch_speedup.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/file_cache/launch_speedup.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -852,10 +852,7 @@
 		goto err1;
 	}
 
-	if (recursive_lock_init(&amp;sLock, &quot;launch speedup&quot;) &lt; B_OK) {
-		status = sLock.sem;
-		goto err2;
-	}
+	recursive_lock_init(&amp;sLock, &quot;launch speedup&quot;);
 
 	// register kernel syscalls
 	if (register_generic_syscall(LAUNCH_SPEEDUP_SYSCALLS,
@@ -877,7 +874,6 @@
 
 err3:
 	recursive_lock_destroy(&amp;sLock);
-err2:
 	hash_uninit(sPrefetchHash);
 err1:
 	hash_uninit(sTeamHash);

Modified: haiku/trunk/src/add-ons/kernel/file_cache/rule_based_prefetcher.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_cache/rule_based_prefetcher.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/file_cache/rule_based_prefetcher.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -753,23 +753,14 @@
 
 	sRulesHash = hash_init(64, 0, &amp;rules_compare, &amp;rules_hash);
 	if (sRulesHash == NULL) {
-		status = B_NO_MEMORY;
-		goto err1;
+		hash_uninit(sTeamHash);
+		return B_NO_MEMORY;
 	}
 
-	if (recursive_lock_init(&amp;sLock, &quot;rule based prefetcher&quot;) &lt; B_OK) {
-		status = sLock.sem;
-		goto err2;
-	}
+	recursive_lock_init(&amp;sLock, &quot;rule based prefetcher&quot;);
 
 	load_rules();
 	return B_OK;
-
-err2:
-	hash_uninit(sRulesHash);
-err1:
-	hash_uninit(sTeamHash);
-	return status;
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c	2008-05-28 23:12:36 UTC (rev 25687)
@@ -747,10 +747,7 @@
 			goto error;
 		}
 		sprintf(name, &quot;fat lock %lx&quot;, vol-&gt;id);
-		if ((result = recursive_lock_init(&amp;(vol-&gt;vlock), name)) != 0) {
-			dprintf(&quot;error creating lock (%s)\n&quot;, strerror(result));
-			goto error;
-		}
+		recursive_lock_init_etc(&amp;(vol-&gt;vlock), name, MUTEX_FLAG_CLONE_NAME);
 
 #if DEBUG
 		if (atomic_add(&amp;instances, 1) == 0) {

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c	2008-05-28 23:12:36 UTC (rev 25687)
@@ -155,14 +155,13 @@
 	sprintf(lockname, &quot;ntfs_lock %lx&quot;, ns-&gt;id);
 
 #ifdef __HAIKU__
-	if ((result = recursive_lock_init(&amp;(ns-&gt;vlock), lockname)) != 0)
+	recursive_lock_init_etc(&amp;(ns-&gt;vlock), lockname, MUTEX_FLAG_CLONE_NAME);
 #else
-	if ((result = new_lock(&amp;(ns-&gt;vlock), lockname)) != B_OK)
-#endif
-	{
-			ERRPRINT(&quot;fs_mount - error creating lock (%s)\n&quot;, strerror(result));
-			goto exit;
+	if ((result = new_lock(&amp;(ns-&gt;vlock), lockname)) != B_OK) {
+		ERRPRINT(&quot;fs_mount - error creating lock (%s)\n&quot;, strerror(result));
+		goto exit;
 	}
+#endif
 
 	handle = load_driver_settings(&quot;ntfs&quot;);
 	ns-&gt;show_sys_files = ! (strcasecmp(get_driver_parameter(handle, &quot;hide_sys_files&quot;, &quot;true&quot;, &quot;true&quot;), &quot;true&quot;) == 0);

Modified: haiku/trunk/src/add-ons/kernel/network/stack/interfaces.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/interfaces.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/add-ons/kernel/network/stack/interfaces.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -118,8 +118,7 @@
 	if (interface == NULL)
 		goto error_0;
 
-	if (recursive_lock_init(&amp;interface-&gt;rx_lock, &quot;rx lock&quot;) &lt; B_OK)
-		goto error_1;
+	recursive_lock_init(&amp;interface-&gt;rx_lock, &quot;rx lock&quot;);
 
 	char name[128];
 	snprintf(name, sizeof(name), &quot;%s receive queue&quot;, device-&gt;name);
@@ -154,8 +153,6 @@
 
 error_2:
 	recursive_lock_destroy(&amp;interface-&gt;rx_lock);
-
-error_1:
 	delete interface;
 
 error_0:

Modified: haiku/trunk/src/libs/compat/freebsd_network/mutex.c
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/mutex.c	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/libs/compat/freebsd_network/mutex.c	2008-05-28 23:12:36 UTC (rev 25687)
@@ -22,8 +22,7 @@
 	if (opts == MTX_DEF) {
 		mutex_init_etc(&amp;m-&gt;u.mutex, name, MUTEX_FLAG_CLONE_NAME);
 	} else if (opts == MTX_RECURSE) {
-		if (recursive_lock_init(&amp;m-&gt;u.recursive, name) &lt; B_OK)
-			panic(&quot;Hell just froze as someone was trying to init a recursive mutex.&quot;);
+		recursive_lock_init_etc(&amp;m-&gt;u.recursive, name, MUTEX_FLAG_CLONE_NAME);
 	} else
 		panic(&quot;Uh-oh, someone is pressing the wrong buttons&quot;);
 

Modified: haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -1099,15 +1099,7 @@
 	map-&gt;ops = &amp;tmap_ops;
 	map-&gt;map_count = 0;
 
-	if (!kernel) {
-		// During the boot process, there are no semaphores available at this
-		// point, so we only try to create the translation map lock if we're
-		// initialize a user translation map.
-		// vm_translation_map_init_kernel_map_post_sem() is used to complete
-		// the kernel translation map.
-		if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-			return map-&gt;lock.sem;
-	}
+	recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;);
 
 	map-&gt;arch_data = (vm_translation_map_arch_info *)malloc(sizeof(vm_translation_map_arch_info));
 	if (map == NULL) {
@@ -1164,9 +1156,6 @@
 static status_t
 arch_vm_translation_map_init_kernel_map_post_sem(vm_translation_map *map)
 {
-	if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-		return map-&gt;lock.sem;
-
 	return B_OK;
 }
 

Modified: haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -486,15 +486,7 @@
 	map-&gt;ops = &amp;tmap_ops;
 	map-&gt;map_count = 0;
 
-	if (!kernel) {
-		// During the boot process, there are no semaphores available at this
-		// point, so we only try to create the translation map lock if we're
-		// initialize a user translation map.
-		// vm_translation_map_init_kernel_map_post_sem() is used to complete
-		// the kernel translation map.
-		if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-			return map-&gt;lock.sem;
-	}
+	recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;);
 
 	map-&gt;arch_data = (vm_translation_map_arch_info *)malloc(sizeof(vm_translation_map_arch_info));
 	if (map-&gt;arch_data == NULL) {
@@ -545,9 +537,6 @@
 status_t
 arch_vm_translation_map_init_kernel_map_post_sem(vm_translation_map *map)
 {
-	if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-		return map-&gt;lock.sem;
-
 	return B_OK;
 }
 

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -774,15 +774,7 @@
 	map-&gt;ops = &amp;tmap_ops;
 	map-&gt;map_count = 0;
 
-	if (!kernel) {
-		// During the boot process, there are no semaphores available at this
-		// point, so we only try to create the translation map lock if we're
-		// initialize a user translation map.
-		// vm_translation_map_init_kernel_map_post_sem() is used to complete
-		// the kernel translation map.
-		if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-			return map-&gt;lock.sem;
-	}
+	recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;);
 
 	map-&gt;arch_data = (vm_translation_map_arch_info *)malloc(sizeof(vm_translation_map_arch_info));
 	if (map == NULL) {
@@ -839,9 +831,6 @@
 status_t
 arch_vm_translation_map_init_kernel_map_post_sem(vm_translation_map *map)
 {
-	if (recursive_lock_init(&amp;map-&gt;lock, &quot;translation map&quot;) &lt; B_OK)
-		return map-&gt;lock.sem;
-
 	return B_OK;
 }
 

Modified: haiku/trunk/src/system/kernel/device_manager/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -873,9 +873,7 @@
 	fs-&gt;id = volume-&gt;id;
 	fs-&gt;next_vnode_id = 0;
 
-	err = recursive_lock_init(&amp;fs-&gt;lock, &quot;devfs lock&quot;);
-	if (err &lt; B_OK)
-		goto err1;
+	recursive_lock_init(&amp;fs-&gt;lock, &quot;devfs lock&quot;);
 
 	fs-&gt;vnode_hash = hash_init(DEVFS_HASH_SIZE, offsetof(devfs_vnode, all_next),
 		//(addr_t)&amp;vnode-&gt;all_next - (addr_t)vnode,
@@ -912,7 +910,6 @@
 	hash_uninit(fs-&gt;vnode_hash);
 err2:
 	recursive_lock_destroy(&amp;fs-&gt;lock);
-err1:
 	free(fs);
 err:
 	return err;

Modified: haiku/trunk/src/system/kernel/fs/node_monitor.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/node_monitor.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/fs/node_monitor.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -239,7 +239,7 @@
 status_t
 NodeMonitorService::InitCheck()
 {
-	return fRecursiveLock.sem &gt;= B_OK ? B_OK : fRecursiveLock.sem;
+	return B_OK;
 }
 
 

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -2626,7 +2626,7 @@
 	kprintf(&quot; root_vnode:    %p\n&quot;, mount-&gt;root_vnode);
 	kprintf(&quot; covers_vnode:  %p\n&quot;, mount-&gt;covers_vnode);
 	kprintf(&quot; partition:     %p\n&quot;, mount-&gt;partition);
-	kprintf(&quot; lock:          %ld\n&quot;, mount-&gt;rlock.sem);
+	kprintf(&quot; lock:          %p\n&quot;, &amp;mount-&gt;rlock);
 	kprintf(&quot; flags:        %s%s\n&quot;, mount-&gt;unmounting ? &quot; unmounting&quot; : &quot;&quot;,
 		mount-&gt;owns_file_device ? &quot; owns_file_device&quot; : &quot;&quot;);
 
@@ -4416,9 +4416,7 @@
 
 	mutex_init(&amp;sFileSystemsMutex, &quot;vfs_lock&quot;);
 
-	if (recursive_lock_init(&amp;sMountOpLock, &quot;vfs_mount_op_lock&quot;) &lt; 0)
-		panic(&quot;vfs_init: error allocating mount op lock\n&quot;);
-
+	recursive_lock_init(&amp;sMountOpLock, &quot;vfs_mount_op_lock&quot;);
 	mutex_init(&amp;sMountMutex, &quot;vfs_mount_lock&quot;);
 	mutex_init(&amp;sVnodeCoveredByMutex, &quot;vfs_vnode_covered_by_lock&quot;);
 	mutex_init(&amp;sVnodeMutex, &quot;vfs_vnode_lock&quot;);
@@ -6388,9 +6386,7 @@
 		goto err3;
 	}
 
-	status = recursive_lock_init(&amp;mount-&gt;rlock, &quot;mount rlock&quot;);
-	if (status &lt; B_OK)
-		goto err4;
+	recursive_lock_init(&amp;mount-&gt;rlock, &quot;mount rlock&quot;);
 
 	// initialize structure
 	mount-&gt;id = sNextMountID++;
@@ -6511,7 +6507,6 @@
 	mutex_unlock(&amp;sMountMutex);
 
 	recursive_lock_destroy(&amp;mount-&gt;rlock);
-err4:
 	put_file_system(mount-&gt;fs);
 	free(mount-&gt;device_name);
 err3:

Modified: haiku/trunk/src/system/kernel/lock.cpp
===================================================================
--- haiku/trunk/src/system/kernel/lock.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/lock.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -33,33 +33,38 @@
 #define MUTEX_FLAG_RELEASED		0x2
 
 
+#ifdef KDEBUG
+#	define RECURSIVE_LOCK_HOLDER(lock)	((lock)-&gt;lock.holder)
+#else
+#	define RECURSIVE_LOCK_HOLDER(lock)	((lock)-&gt;holder)
+#endif
+
+
 int32
 recursive_lock_get_recursion(recursive_lock *lock)
 {
-	if (lock-&gt;holder == thread_get_current_thread_id())
+	if (RECURSIVE_LOCK_HOLDER(lock) == thread_get_current_thread_id())
 		return lock-&gt;recursion;
 
 	return -1;
 }
 
 
-status_t
+void
 recursive_lock_init(recursive_lock *lock, const char *name)
 {
-	if (lock == NULL)
-		return B_BAD_VALUE;
+	mutex_init(&amp;lock-&gt;lock, name != NULL ? name : &quot;recursive lock&quot;);
+	RECURSIVE_LOCK_HOLDER(lock) = -1;
+	lock-&gt;recursion = 0;
+}
 
-	if (name == NULL)
-		name = &quot;recursive lock&quot;;
 
-	lock-&gt;holder = -1;
+void
+recursive_lock_init_etc(recursive_lock *lock, const char *name, uint32 flags)
+{
+	mutex_init_etc(&amp;lock-&gt;lock, name != NULL ? name : &quot;recursive lock&quot;, flags);
+	RECURSIVE_LOCK_HOLDER(lock) = -1;
 	lock-&gt;recursion = 0;
-	lock-&gt;sem = create_sem(1, name);
-
-	if (lock-&gt;sem &gt;= B_OK)
-		return B_OK;
-
-	return lock-&gt;sem;
 }
 
 
@@ -69,8 +74,7 @@
 	if (lock == NULL)
 		return;
 
-	delete_sem(lock-&gt;sem);
-	lock-&gt;sem = -1;
+	mutex_destroy(&amp;lock-&gt;lock);
 }
 
 
@@ -80,15 +84,16 @@
 	thread_id thread = thread_get_current_thread_id();
 
 	if (!kernel_startup &amp;&amp; !are_interrupts_enabled())
-		panic(&quot;recursive_lock_lock: called with interrupts disabled for lock %p, sem %#lx\n&quot;, lock, lock-&gt;sem);
+		panic(&quot;recursive_lock_lock: called with interrupts disabled for lock &quot;
+			&quot;%p (\&quot;%s\&quot;)\n&quot;, lock, lock-&gt;lock.name);
 
-	if (thread != lock-&gt;holder) {
-		status_t status = acquire_sem(lock-&gt;sem);
-		if (status &lt; B_OK)
-			return status;
-
+	if (thread != RECURSIVE_LOCK_HOLDER(lock)) {
+		mutex_lock(&amp;lock-&gt;lock);
+#ifndef KDEBUG
 		lock-&gt;holder = thread;
+#endif
 	}
+
 	lock-&gt;recursion++;
 	return B_OK;
 }
@@ -97,12 +102,14 @@
 void
 recursive_lock_unlock(recursive_lock *lock)
 {
-	if (thread_get_current_thread_id() != lock-&gt;holder)
+	if (thread_get_current_thread_id() != RECURSIVE_LOCK_HOLDER(lock))
 		panic(&quot;recursive_lock %p unlocked by non-holder thread!\n&quot;, lock);
 
 	if (--lock-&gt;recursion == 0) {
+#ifndef KDEBUG
 		lock-&gt;holder = -1;
-		release_sem_etc(lock-&gt;sem, 1, 0/*B_DO_NOT_RESCHEDULE*/);
+#endif
+		mutex_unlock(&amp;lock-&gt;lock);
 	}
 }
 

Modified: haiku/trunk/src/system/kernel/module.cpp
===================================================================
--- haiku/trunk/src/system/kernel/module.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/module.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -1094,8 +1094,7 @@
 {
 	struct preloaded_image *image;
 
-	if (recursive_lock_init(&amp;sModulesLock, &quot;modules rlock&quot;) &lt; B_OK)
-		return B_ERROR;
+	recursive_lock_init(&amp;sModulesLock, &quot;modules rlock&quot;);
 
 	sModulesHash = hash_init(MODULE_HASH_SIZE, 0, module_compare, module_hash);
 	if (sModulesHash == NULL)

Modified: haiku/trunk/src/system/kernel/slab/Slab.cpp
===================================================================
--- haiku/trunk/src/system/kernel/slab/Slab.cpp	2008-05-28 21:52:51 UTC (rev 25686)
+++ haiku/trunk/src/system/kernel/slab/Slab.cpp	2008-05-28 23:12:36 UTC (rev 25687)
@@ -172,7 +172,6 @@
 
 static status_t object_cache_reserve_internal(object_cache *cache,
 	size_t object_count, uint32 flags);
-static status_t object_depot_init_locks(object_depot *depot);
 static depot_magazine *alloc_magazine();
 static void free_magazine(depot_magazine *magazine);
 
@@ -406,20 +405,6 @@
 
 
 static status_t
-recursive_lock_boot_init(recursive_lock *lock, const char *name, uint32 flags)
-{
-	if (flags &amp; CACHE_DURING_BOOT) {
-		lock-&gt;sem = -1;
-		lock-&gt;holder = 1;
-		lock-&gt;recursion = 0;
-		return B_OK;
-	}
-
-	return recursive_lock_init(lock, name);
-}
-
-
-static status_t
 area_allocate_pages(object_cache *cache, void **pages, uint32 flags)
 {
 	TRACE_CACHE(cache, &quot;allocate pages (%lu, 0x0%lx)&quot;, cache-&gt;slab_size, flags);
@@ -618,16 +603,6 @@
 }
 
 
-static status_t
-object_cache_init_locks(object_cache *cache)
-{
-	if (cache-&gt;flags &amp; CACHE_NO_DEPOT)
-		return B_OK;
-
-	return object_depot_init_locks(&amp;cache-&gt;depot);
-}
-
-
 static void
 object_cache_commit_slab(object_cache *cache, slab *slab)
 {
@@ -1280,9 +1255,7 @@
 	depot-&gt;empty = NULL;
 	depot-&gt;full_count = depot-&gt;empty_count = 0;
 
-	status_t status = recursive_lock_boot_init(&amp;depot-&gt;lock, &quot;depot&quot;, flags);
-	if (status &lt; B_OK)
-		return status;
+	recursive_lock_init(&amp;depot-&gt;lock, &quot;depot&quot;);
 
 	depot-&gt;stores = (depot_cpu_store *)internal_alloc(sizeof(depot_cpu_store)
 		* smp_get_num_cpus(), flags);
@@ -1292,7 +1265,7 @@
 	}
 
 	for (int i = 0; i &lt; smp_get_num_cpus(); i++) {
-		recursive_lock_boot_init(&amp;depot-&gt;stores[i].lock, &quot;cpu store&quot;, flags);
+		recursive_lock_init(&amp;depot-&gt;stores[i].lock, &quot;cpu store&quot;);
 		depot-&gt;stores[i].loaded = depot-&gt;stores[i].previous = NULL;
 	}
 
@@ -1302,23 +1275,6 @@
 }
 
 
-status_t
-object_depot_init_locks(object_depot *depot)
-{
-	status_t status = recursive_lock_init(&amp;depot-&gt;lock, &quot;depot&quot;);
-	if (status &lt; B_OK)
-		return status;
-
-	for (int i = 0; i &lt; smp_get_num_cpus(); i++) {
-		status = recursive_lock_init(&amp;depot-&gt;stores[i].lock, &quot;cpu store&quot;);
-		if (status &lt; B_OK)
-			return status;
-	}
-
-	return B_OK;
-}
-
-
 void
 object_depot_destroy(object_depot *depot)
 {
@@ -1504,8 +1460,6 @@
 
 	while (it.HasNext()) {
 		object_cache *cache = it.Next();
-		if (object_cache_init_locks(cache) &lt; B_OK)
-			panic(&quot;slab_init: failed to create sems&quot;);
 		if (cache-&gt;allocate_pages == early_allocate_pages)
 			object_cache_commit_pre_pages(cache);
 	}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009132.html">[Haiku-commits] r25686 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="009134.html">[Haiku-commits] r25688 - in haiku/trunk: build/jam	src/add-ons/kernel/busses/ide/legacy_sata
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9133">[ date ]</a>
              <a href="thread.html#9133">[ thread ]</a>
              <a href="subject.html#9133">[ subject ]</a>
              <a href="author.html#9133">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
