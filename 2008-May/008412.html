<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25283 - in haiku/trunk: headers/private/kernel	headers/private/kernel/util	src/add-ons/kernel/drivers/arch/x86/keyboard	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/network/protocols/tcp	src/libs/compat/freebsd_network	src/libs/compat/freebsd_network/compat/sys src/system/kernel	src/system/kernel/arch/generic src/system/kernel/cache	src/system/kernel/fs src/system/kernel/util	src/system/kernel/vm src/system/libroot/os
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25283%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/util%0A%09src/add-ons/kernel/drivers/arch/x86/keyboard%0A%09src/add-ons/kernel/drivers/tty%20src/add-ons/kernel/file_cache%0A%09src/add-ons/kernel/network/protocols/tcp%0A%09src/libs/compat/freebsd_network%0A%09src/libs/compat/freebsd_network/compat/sys%20src/system/kernel%0A%09src/system/kernel/arch/generic%20src/system/kernel/cache%0A%09src/system/kernel/fs%20src/system/kernel/util%0A%09src/system/kernel/vm%20src/system/libroot/os&In-Reply-To=%3C200805012207.m41M7fFS017717%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008411.html">
   <LINK REL="Next"  HREF="008413.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25283 - in haiku/trunk: headers/private/kernel	headers/private/kernel/util	src/add-ons/kernel/drivers/arch/x86/keyboard	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/network/protocols/tcp	src/libs/compat/freebsd_network	src/libs/compat/freebsd_network/compat/sys src/system/kernel	src/system/kernel/arch/generic src/system/kernel/cache	src/system/kernel/fs src/system/kernel/util	src/system/kernel/vm src/system/libroot/os</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25283%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/util%0A%09src/add-ons/kernel/drivers/arch/x86/keyboard%0A%09src/add-ons/kernel/drivers/tty%20src/add-ons/kernel/file_cache%0A%09src/add-ons/kernel/network/protocols/tcp%0A%09src/libs/compat/freebsd_network%0A%09src/libs/compat/freebsd_network/compat/sys%20src/system/kernel%0A%09src/system/kernel/arch/generic%20src/system/kernel/cache%0A%09src/system/kernel/fs%20src/system/kernel/util%0A%09src/system/kernel/vm%20src/system/libroot/os&In-Reply-To=%3C200805012207.m41M7fFS017717%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25283 - in haiku/trunk: headers/private/kernel	headers/private/kernel/util	src/add-ons/kernel/drivers/arch/x86/keyboard	src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache	src/add-ons/kernel/network/protocols/tcp	src/libs/compat/freebsd_network	src/libs/compat/freebsd_network/compat/sys src/system/kernel	src/system/kernel/arch/generic src/system/kernel/cache	src/system/kernel/fs src/system/kernel/util	src/system/kernel/vm src/system/libroot/os">bonefish at mail.berlios.de
       </A><BR>
    <I>Fri May  2 00:07:41 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="008411.html">[Haiku-commits] r25282 - haiku/trunk/src/bin/strace
</A></li>
        <LI>Next message: <A HREF="008413.html">[Haiku-commits] r25283 - in haiku/trunk: headers/private/kernel headers/private/kernel/util src/add-ons/kernel/drivers/arch/x86/keyboard src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache src/add-ons/kernel/network/protocols/tcp src/libs/compat/freebsd_network src/libs/compat/freebsd_network/compat/sys src/system/kernel src/system/kernel/arch/generic src/system/kernel/cache src/system/kernel/fs src/system/kernel/util src/system/kernel/vm src/system/libroot/os
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8412">[ date ]</a>
              <a href="thread.html#8412">[ thread ]</a>
              <a href="subject.html#8412">[ subject ]</a>
              <a href="author.html#8412">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-05-02 00:07:36 +0200 (Fri, 02 May 2008)
New Revision: 25283
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25283&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25283&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/kernel/lock.h
   haiku/trunk/headers/private/kernel/thread_types.h
   haiku/trunk/headers/private/kernel/util/AutoLock.h
   haiku/trunk/headers/private/kernel/vm_types.h
   haiku/trunk/src/add-ons/kernel/drivers/arch/x86/keyboard/keyboard.c
   haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp
   haiku/trunk/src/add-ons/kernel/drivers/tty/master.cpp
   haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp
   haiku/trunk/src/add-ons/kernel/file_cache/log.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp
   haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h
   haiku/trunk/src/libs/compat/freebsd_network/mutex.c
   haiku/trunk/src/libs/compat/freebsd_network/taskqueue.c
   haiku/trunk/src/system/kernel/Notifications.cpp
   haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.cpp
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/fs/IOScheduler.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/heap.cpp
   haiku/trunk/src/system/kernel/image.c
   haiku/trunk/src/system/kernel/kernel_daemon.c
   haiku/trunk/src/system/kernel/lock.cpp
   haiku/trunk/src/system/kernel/syscalls.cpp
   haiku/trunk/src/system/kernel/thread.cpp
   haiku/trunk/src/system/kernel/util/cbuf.c
   haiku/trunk/src/system/kernel/vm/vm.cpp
   haiku/trunk/src/system/kernel/vm/vm_cache.cpp
   haiku/trunk/src/system/kernel/vm/vm_daemons.cpp
   haiku/trunk/src/system/kernel/vm/vm_low_memory.cpp
   haiku/trunk/src/system/kernel/vm/vm_page.cpp
   haiku/trunk/src/system/libroot/os/driver_settings.c
Log:
* Removed old mutex implementation and renamed cutex to mutex.
* Trivial adjustments of code using mutexes. Mostly removing the
  mutex_init() return value check.
* Added mutex_lock_threads_locked(), which is called with the threads
  spinlock being held. The spinlock is released while waiting, of
  course. This function is useful in cases where the existence of the
  mutex object is ensured by holding the threads spinlock.
* Changed the two instances in the VFS code where an IO context of
  another team needs to be locked to use mutex_lock_threads_locked().
  Before it required a semaphore-based mutex implementation.


Modified: haiku/trunk/headers/private/kernel/lock.h
===================================================================
--- haiku/trunk/headers/private/kernel/lock.h	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/headers/private/kernel/lock.h	2008-05-01 22:07:36 UTC (rev 25283)
@@ -1,4 +1,5 @@
 /*
+ * Copyright 2008, Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ingo_weinhold at gmx.de.</A>
  * Copyright 2002-2008, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
  * Distributed under the terms of the MIT License.
  *
@@ -18,11 +19,6 @@
 	int			recursion;
 } recursive_lock;
 
-typedef struct mutex {
-	sem_id		sem;
-	thread_id	holder;
-} mutex;
-
 typedef struct benaphore {
 	sem_id	sem;
 	int32	count;
@@ -39,31 +35,29 @@
 
 #define RW_MAX_READERS 1000000
 
-struct cutex_waiter;
+struct mutex_waiter;
 
-typedef struct cutex {
+typedef struct mutex {
 	const char*				name;
-	struct cutex_waiter*	waiters;
+	struct mutex_waiter*	waiters;
 #ifdef KDEBUG
 	thread_id				holder;
 #else
 	int32					count;
 #endif
 	uint8					flags;
-} cutex;
+} mutex;
 
-#define CUTEX_FLAG_CLONE_NAME	0x1
+#define MUTEX_FLAG_CLONE_NAME	0x1
 
 
 #if 0 &amp;&amp; KDEBUG // XXX disable this for now, it causes problems when including thread.h here
 #	include &lt;thread.h&gt;
 #define ASSERT_LOCKED_RECURSIVE(r) { ASSERT(thread_get_current_thread_id() == (r)-&gt;holder); }
 #define ASSERT_LOCKED_MUTEX(m) { ASSERT(thread_get_current_thread_id() == (m)-&gt;holder); }
-#define ASSERT_LOCKED_CUTEX(m) { ASSERT(thread_get_current_thread_id() == (m)-&gt;holder); }
 #else
 #define ASSERT_LOCKED_RECURSIVE(r)
 #define ASSERT_LOCKED_MUTEX(m)
-#define ASSERT_LOCKED_CUTEX(m)
 #endif
 
 
@@ -77,12 +71,6 @@
 extern void recursive_lock_unlock(recursive_lock *lock);
 extern int32 recursive_lock_get_recursion(recursive_lock *lock);
 
-extern status_t	mutex_init(mutex *m, const char *name);
-extern void mutex_destroy(mutex *m);
-extern status_t mutex_trylock(mutex *mutex);
-extern status_t mutex_lock(mutex *m);
-extern void mutex_unlock(mutex *m);
-
 extern status_t benaphore_init(benaphore *ben, const char *name);
 extern void benaphore_destroy(benaphore *ben);
 
@@ -121,36 +109,49 @@
 extern status_t rw_lock_write_lock(rw_lock *lock);
 extern status_t rw_lock_write_unlock(rw_lock *lock);
 
-extern void cutex_init(cutex* lock, const char *name);
-	// name is *not* cloned nor freed in cutex_destroy()
-extern void cutex_init_etc(cutex* lock, const char *name, uint32 flags);
-extern void cutex_destroy(cutex* lock);
+extern void mutex_init(mutex* lock, const char *name);
+	// name is *not* cloned nor freed in mutex_destroy()
+extern void mutex_init_etc(mutex* lock, const char *name, uint32 flags);
+extern void mutex_destroy(mutex* lock);
 
 // implementation private:
-extern status_t _cutex_lock(cutex* lock);
-extern void _cutex_unlock(cutex* lock);
-extern status_t _cutex_trylock(cutex* lock);
+extern status_t _mutex_lock(mutex* lock, bool threadsLocked);
+extern void _mutex_unlock(mutex* lock);
+extern status_t _mutex_trylock(mutex* lock);
 
 
 static inline status_t
-cutex_lock(cutex* lock)
+mutex_lock(mutex* lock)
 {
 #ifdef KDEBUG
-	return _cutex_lock(lock);
+	return _mutex_lock(lock, false);
 #else
 	if (atomic_add(&amp;lock-&gt;count, -1) &lt; 0)
-		return _cutex_lock(lock);
+		return _mutex_lock(lock, false);
 	return B_OK;
 #endif
 }
 
 
 static inline status_t
-cutex_trylock(cutex* lock)
+mutex_lock_threads_locked(mutex* lock)
 {
 #ifdef KDEBUG
-	return _cutex_trylock(lock);
+	return _mutex_lock(lock, true);
 #else
+	if (atomic_add(&amp;lock-&gt;count, -1) &lt; 0)
+		return _mutex_lock(lock, true);
+	return B_OK;
+#endif
+}
+
+
+static inline status_t
+mutex_trylock(mutex* lock)
+{
+#ifdef KDEBUG
+	return _mutex_trylock(lock);
+#else
 	if (atomic_test_and_set(&amp;lock-&gt;count, -1, 0) != 0)
 		return B_WOULD_BLOCK;
 	return B_OK;
@@ -159,13 +160,13 @@
 
 
 static inline void
-cutex_unlock(cutex* lock)
+mutex_unlock(mutex* lock)
 {
 #ifdef KDEBUG
-	_cutex_unlock(lock);
+	_mutex_unlock(lock);
 #else
 	if (atomic_add(&amp;lock-&gt;count, 1) &lt; -1)
-		_cutex_unlock(lock);
+		_mutex_unlock(lock);
 #endif
 }
 

Modified: haiku/trunk/headers/private/kernel/thread_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/thread_types.h	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/headers/private/kernel/thread_types.h	2008-05-01 22:07:36 UTC (rev 25283)
@@ -62,7 +62,7 @@
 	THREAD_BLOCK_TYPE_CONDITION_VARIABLE	= 1,
 	THREAD_BLOCK_TYPE_SNOOZE				= 2,
 	THREAD_BLOCK_TYPE_SIGNAL				= 3,
-	THREAD_BLOCK_TYPE_CUTEX					= 4,
+	THREAD_BLOCK_TYPE_MUTEX					= 4,
 
 	THREAD_BLOCK_TYPE_OTHER					= 9999,
 	THREAD_BLOCK_TYPE_USER_BASE				= 10000

Modified: haiku/trunk/headers/private/kernel/util/AutoLock.h
===================================================================
--- haiku/trunk/headers/private/kernel/util/AutoLock.h	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/headers/private/kernel/util/AutoLock.h	2008-05-01 22:07:36 UTC (rev 25283)
@@ -67,24 +67,6 @@
 // BenaphoreLocker
 typedef AutoLocker&lt;benaphore, BenaphoreLocking&gt; BenaphoreLocker;
 
-// CutexLocking
-class CutexLocking {
-public:
-	inline bool Lock(cutex *lockable)
-	{
-		cutex_lock(lockable);
-		return true;
-	}
-
-	inline void Unlock(cutex *lockable)
-	{
-		cutex_unlock(lockable);
-	}
-};
-
-// CutexLocker
-typedef AutoLocker&lt;cutex, CutexLocking&gt; CutexLocker;
-
 // InterruptsLocking
 class InterruptsLocking {
 public:
@@ -171,7 +153,6 @@
 using BPrivate::MutexLocker;
 using BPrivate::RecursiveLocker;
 using BPrivate::BenaphoreLocker;
-using BPrivate::CutexLocker;
 using BPrivate::InterruptsLocker;
 using BPrivate::SpinLocker;
 using BPrivate::InterruptsSpinLocker;

Modified: haiku/trunk/headers/private/kernel/vm_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm_types.h	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/headers/private/kernel/vm_types.h	2008-05-01 22:07:36 UTC (rev 25283)
@@ -135,7 +135,7 @@
 };
 
 struct vm_cache {
-	cutex				lock;
+	mutex				lock;
 	struct vm_area		*areas;
 	vint32				ref_count;
 	struct list_link	consumer_link;

Modified: haiku/trunk/src/add-ons/kernel/drivers/arch/x86/keyboard/keyboard.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/arch/x86/keyboard/keyboard.c	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/drivers/arch/x86/keyboard/keyboard.c	2008-05-01 22:07:36 UTC (rev 25283)
@@ -265,8 +265,7 @@
 	if (keyboard_sem &lt; 0)
 		panic(&quot;could not create keyboard sem!\n&quot;);
 
-	if (mutex_init(&amp;keyboard_read_mutex, &quot;keyboard_read_mutex&quot;) &lt; 0)
-		panic(&quot;could not create keyboard read mutex!\n&quot;);
+	mutex_init(&amp;keyboard_read_mutex, &quot;keyboard_read_mutex&quot;);
 
 	shift = false;
 	sControl = false;

Modified: haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/drivers/tty/driver.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -51,26 +51,17 @@
 
 	memset(gDeviceNames, 0, sizeof(gDeviceNames));
 
-	// create the global mutex
-	status_t error = mutex_init(&amp;gGlobalTTYLock, &quot;tty global&quot;);
+	// create the request mutex
+	status_t error = recursive_lock_init(&amp;gTTYRequestLock, &quot;tty requests&quot;);
 	if (error != B_OK)
 		return error;
 
+	// create the global mutex
+	mutex_init(&amp;gGlobalTTYLock, &quot;tty global&quot;);
+
 	// create the cookie mutex
-	error = mutex_init(&amp;gTTYCookieLock, &quot;tty cookies&quot;);
-	if (error != B_OK) {
-		mutex_destroy(&amp;gGlobalTTYLock);
-		return error;
-	}
+	mutex_init(&amp;gTTYCookieLock, &quot;tty cookies&quot;);
 
-	// create the request mutex
-	error = recursive_lock_init(&amp;gTTYRequestLock, &quot;tty requests&quot;);
-	if (error != B_OK) {
-		mutex_destroy(&amp;gTTYCookieLock);
-		mutex_destroy(&amp;gGlobalTTYLock);
-		return error;
-	}
-
 	// create driver name array and initialize basic TTY structures
 
 	char letter = 'p';

Modified: haiku/trunk/src/add-ons/kernel/drivers/tty/master.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/tty/master.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/drivers/tty/master.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -42,13 +42,9 @@
 	if (cookie == NULL)
 		return B_NO_MEMORY;
 
-	status_t error = mutex_init(&amp;cookie-&gt;lock, &quot;tty lock&quot;);
-	if (error != B_OK) {
-		free(cookie);
-		return error;
-	}
+	mutex_init(&amp;cookie-&gt;lock, &quot;tty lock&quot;);
 
-	error = init_tty_cookie(cookie, master, slave, openMode);
+	status_t error = init_tty_cookie(cookie, master, slave, openMode);
 	if (error != B_OK) {
 		mutex_destroy(&amp;cookie-&gt;lock);
 		free(cookie);

Modified: haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -1866,7 +1866,7 @@
 	kprintf(&quot;  open_count:   %ld\n&quot;, tty.open_count);
 	kprintf(&quot;  select_pool:  %p\n&quot;, tty.select_pool);
 	kprintf(&quot;  pending_eof:  %lu\n&quot;, tty.pending_eof);
-	kprintf(&quot;  lock.sem:     %ld\n&quot;, tty.lock-&gt;sem);
+	kprintf(&quot;  lock:         %ld\n&quot;, &amp;tty.lock);
 
 	kprintf(&quot;  input_buffer:\n&quot;);
 	kprintf(&quot;    first:      %ld\n&quot;, tty.input_buffer.first);

Modified: haiku/trunk/src/add-ons/kernel/file_cache/log.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_cache/log.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/file_cache/log.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -386,14 +386,12 @@
 
 	sLogEntrySem = create_sem(kNumLogEntries, &quot;cache log entries&quot;);
 	if (sLogEntrySem &gt;= B_OK) {
-		if (mutex_init(&amp;sLock, &quot;log cache module&quot;) &gt;= B_OK) {
-			register_kernel_daemon(log_writer_daemon, NULL, kLogWriterFrequency);
-			register_generic_syscall(CACHE_LOG_SYSCALLS, log_control, 1, 0);
+		mutex_init(&amp;sLock, &quot;log cache module&quot;);
+		register_kernel_daemon(log_writer_daemon, NULL, kLogWriterFrequency);
+		register_generic_syscall(CACHE_LOG_SYSCALLS, log_control, 1, 0);
 
-			TRACE((&quot;** - log init\n&quot;));
-			return B_OK;
-		}
-		delete_sem(sLogEntrySem);
+		TRACE((&quot;** - log init\n&quot;));
+		return B_OK;
 	}
 
 	close(sLogFile);

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -429,9 +429,6 @@
 status_t
 TCPEndpoint::InitCheck() const
 {
-	if (fLock.sem &lt; B_OK)
-		return fLock.sem;
-
 	if (fReceiveList.InitCheck() &lt; B_OK)
 		return fReceiveList.InitCheck();
 
@@ -2175,7 +2172,9 @@
 	kprintf(&quot;TCP endpoint %p\n&quot;, this);
 	kprintf(&quot;  state: %s\n&quot;, name_for_state(fState));
 	kprintf(&quot;  flags: 0x%lx\n&quot;, fFlags);
-	kprintf(&quot;  lock: { sem: %ld, holder: %ld }\n&quot;, fLock.sem, fLock.holder);
+#ifdef KDEBUG
+	kprintf(&quot;  lock: { %p, holder: %ld }\n&quot;, &amp;fLock, fLock.holder);
+#endif
 	kprintf(&quot;  accept sem: %ld\n&quot;, fAcceptSemaphore);
 	kprintf(&quot;  options: 0x%lx\n&quot;, (uint32)fOptions);
 	kprintf(&quot;  send\n&quot;);

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -721,13 +721,10 @@
 static status_t
 tcp_init()
 {
-	status_t status = mutex_init(&amp;sEndpointManagersLock,
-		&quot;endpoint managers lock&quot;);
+	mutex_init(&amp;sEndpointManagersLock, &quot;endpoint managers lock&quot;);
 
-	if (status &lt; B_OK)
-		return status;
-
-	status = gStackModule-&gt;register_domain_protocols(AF_INET, SOCK_STREAM, 0,
+	status_t status = gStackModule-&gt;register_domain_protocols(AF_INET,
+		SOCK_STREAM, 0,
 		&quot;network/protocols/tcp/v1&quot;,
 		&quot;network/protocols/ipv4/v1&quot;,
 		NULL);

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h	2008-05-01 22:07:36 UTC (rev 25283)
@@ -9,7 +9,7 @@
 #include &lt;Drivers.h&gt;
 #include &lt;KernelExport.h&gt;
 
-#include &lt;lock.h&gt;
+#include &lt;kernel/lock.h&gt;
 #include &lt;net_stack.h&gt;
 
 #undef ASSERT

Modified: haiku/trunk/src/libs/compat/freebsd_network/mutex.c
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/mutex.c	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/libs/compat/freebsd_network/mutex.c	2008-05-01 22:07:36 UTC (rev 25283)
@@ -20,8 +20,7 @@
 mtx_init(struct mtx *m, const char *name, const char *type, int opts)
 {
 	if (opts == MTX_DEF) {
-		if (mutex_init(&amp;m-&gt;u.mutex, name) &lt; B_OK)
-			panic(&quot;Panic! Dance like it's 1979, we ran out of semaphores&quot;);
+		mutex_init_etc(&amp;m-&gt;u.mutex, name, MUTEX_FLAG_CLONE_NAME);
 	} else if (opts == MTX_RECURSE) {
 		if (recursive_lock_init(&amp;m-&gt;u.recursive, name) &lt; B_OK)
 			panic(&quot;Hell just froze as someone was trying to init a recursive mutex.&quot;);

Modified: haiku/trunk/src/libs/compat/freebsd_network/taskqueue.c
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/taskqueue.c	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/libs/compat/freebsd_network/taskqueue.c	2008-05-01 22:07:36 UTC (rev 25283)
@@ -45,10 +45,7 @@
 	if (fast) {
 		tq-&gt;tq_spinlock = 0;
 	} else {
-		if (mutex_init(&amp;tq-&gt;tq_mutex, name) &lt; B_OK) {
-			free(tq);
-			return NULL;
-		}
+		mutex_init_etc(&amp;tq-&gt;tq_mutex, name, MUTEX_FLAG_CLONE_NAME);
 	}
 
 	strlcpy(tq-&gt;tq_name, name, sizeof(tq-&gt;tq_name));

Modified: haiku/trunk/src/system/kernel/Notifications.cpp
===================================================================
--- haiku/trunk/src/system/kernel/Notifications.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/Notifications.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -154,9 +154,7 @@
 status_t
 NotificationManager::_Init()
 {
-	status_t status = mutex_init(&amp;fLock, &quot;notification manager&quot;);
-	if (status &lt; B_OK)
-		return status;
+	mutex_init(&amp;fLock, &quot;notification manager&quot;);
 
 	return fServiceHash.InitCheck();
 }

Modified: haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -282,8 +282,7 @@
 	memset(virtual_pmappings, 0, sizeof(paddr_chunk_desc *) * num_virtual_chunks);
 	first_free_vmapping = 0;
 	queue_init(&amp;mapped_paddr_lru);
-	sMutex.sem = -1;
-	sMutex.holder = -1;
+	mutex_init(&amp;sMutex, &quot;iospace_mutex&quot;);
 	sChunkAvailableSem = -1;
 
 	TRACE((&quot;generic_vm_physical_page_mapper_init: done\n&quot;));
@@ -332,7 +331,6 @@
 status_t
 generic_vm_physical_page_mapper_init_post_sem(kernel_args *args)
 {
-	mutex_init(&amp;sMutex, &quot;iospace_mutex&quot;);
 	sChunkAvailableSem = create_sem(1, &quot;iospace chunk available&quot;);
 
 	return sChunkAvailableSem &gt;= B_OK ? B_OK : sChunkAvailableSem;

Modified: haiku/trunk/src/system/kernel/cache/file_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -119,7 +119,7 @@
 {
 	if (vm_low_memory_state() != B_NO_LOW_MEMORY) {
 		vm_cache *cache = ref-&gt;cache;
-		cutex_lock(&amp;cache-&gt;lock);
+		mutex_lock(&amp;cache-&gt;lock);
 
 		if (list_is_empty(&amp;cache-&gt;consumers) &amp;&amp; cache-&gt;areas == NULL
 			&amp;&amp; access_is_sequential(ref)) {
@@ -153,7 +153,7 @@
 				}
 			}
 		}
-		cutex_unlock(&amp;cache-&gt;lock);
+		mutex_unlock(&amp;cache-&gt;lock);
 	}
 
 	vm_page_reserve_pages(reservePages);
@@ -208,7 +208,7 @@
 	}
 
 	push_access(ref, offset, bufferSize, false);
-	cutex_unlock(&amp;cache-&gt;lock);
+	mutex_unlock(&amp;cache-&gt;lock);
 	vm_page_unreserve_pages(lastReservedPages);
 
 	// read file into reserved pages
@@ -229,7 +229,7 @@
 			}
 		}
 
-		cutex_lock(&amp;cache-&gt;lock);
+		mutex_lock(&amp;cache-&gt;lock);
 
 		for (int32 i = 0; i &lt; pageIndex; i++) {
 			busyConditions[i].Unpublish();
@@ -263,7 +263,7 @@
 	}
 
 	reserve_pages(ref, reservePages, false);
-	cutex_lock(&amp;cache-&gt;lock);
+	mutex_lock(&amp;cache-&gt;lock);
 
 	// make the pages accessible in the cache
 	for (int32 i = pageIndex; i-- &gt; 0;) {
@@ -292,7 +292,7 @@
 	vec.iov_len = bufferSize;
 
 	push_access(ref, offset, bufferSize, false);
-	cutex_unlock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_unlock(&amp;ref-&gt;cache-&gt;lock);
 	vm_page_unreserve_pages(lastReservedPages);
 
 	status_t status = vfs_read_pages(ref-&gt;vnode, cookie, offset + pageOffset,
@@ -300,7 +300,7 @@
 	if (status == B_OK)
 		reserve_pages(ref, reservePages, false);
 
-	cutex_lock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_lock(&amp;ref-&gt;cache-&gt;lock);
 
 	return status;
 }
@@ -351,7 +351,7 @@
 	}
 
 	push_access(ref, offset, bufferSize, true);
-	cutex_unlock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_unlock(&amp;ref-&gt;cache-&gt;lock);
 	vm_page_unreserve_pages(lastReservedPages);
 
 	// copy contents (and read in partially written pages first)
@@ -433,7 +433,7 @@
 	if (status == B_OK)
 		reserve_pages(ref, reservePages, true);
 
-	cutex_lock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_lock(&amp;ref-&gt;cache-&gt;lock);
 
 	// unmap the pages again
 
@@ -482,7 +482,7 @@
 	vec.iov_len = bufferSize;
 
 	push_access(ref, offset, bufferSize, true);
-	cutex_unlock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_unlock(&amp;ref-&gt;cache-&gt;lock);
 	vm_page_unreserve_pages(lastReservedPages);
 
 	status_t status = B_OK;
@@ -508,7 +508,7 @@
 	if (status == B_OK)
 		reserve_pages(ref, reservePages, true);
 
-	cutex_lock(&amp;ref-&gt;cache-&gt;lock);
+	mutex_lock(&amp;ref-&gt;cache-&gt;lock);
 
 	return status;
 }
@@ -604,7 +604,7 @@
 	size_t reservePages = 0;
 
 	reserve_pages(ref, lastReservedPages, doWrite);
-	CutexLocker locker(cache-&gt;lock);
+	MutexLocker locker(cache-&gt;lock);
 
 	while (bytesLeft &gt; 0) {
 		// check if this page is already in memory
@@ -780,7 +780,7 @@
 	off_t lastOffset = offset;
 	size_t lastSize = 0;
 
-	cutex_lock(&amp;cache-&gt;lock);
+	mutex_lock(&amp;cache-&gt;lock);
 
 	for (; bytesLeft &gt; 0; offset += B_PAGE_SIZE) {
 		// check if this page is already in memory
@@ -792,9 +792,9 @@
 				// if busy retry again later
 				ConditionVariableEntry entry;
 				entry.Add(page);
-				cutex_unlock(&amp;cache-&gt;lock);
+				mutex_unlock(&amp;cache-&gt;lock);
 				entry.Wait();
-				cutex_lock(&amp;cache-&gt;lock);
+				mutex_lock(&amp;cache-&gt;lock);
 
 				goto restart;
 			}
@@ -825,7 +825,7 @@
 	read_into_cache(ref, lastOffset, lastLeft, NULL, 0);
 
 out:
-	cutex_unlock(&amp;cache-&gt;lock);
+	mutex_unlock(&amp;cache-&gt;lock);
 	vm_cache_release_ref(cache);
 #endif
 }
@@ -985,7 +985,7 @@
 	if (ref == NULL)
 		return B_OK;
 
-	CutexLocker _(ref-&gt;cache-&gt;lock);
+	MutexLocker _(ref-&gt;cache-&gt;lock);
 
 	off_t offset = ref-&gt;cache-&gt;virtual_size;
 	off_t size = newSize;

Modified: haiku/trunk/src/system/kernel/fs/IOScheduler.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/IOScheduler.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/fs/IOScheduler.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -66,9 +66,6 @@
 status_t
 IOScheduler::InitCheck() const
 {
-	if (fLock.sem &lt; B_OK)
-		return fLock.sem;
-
 	if (fThread &lt; B_OK)
 		return fThread;
 

Modified: haiku/trunk/src/system/kernel/fs/rootfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/rootfs.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/fs/rootfs.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -357,9 +357,7 @@
 	fs-&gt;id = volume-&gt;id;
 	fs-&gt;next_vnode_id = 1;
 
-	err = mutex_init(&amp;fs-&gt;lock, &quot;rootfs_mutex&quot;);
-	if (err &lt; B_OK)
-		goto err1;
+	mutex_init(&amp;fs-&gt;lock, &quot;rootfs_mutex&quot;);
 
 	fs-&gt;vnode_list_hash = hash_init(ROOTFS_HASH_SIZE, (addr_t)&amp;vnode-&gt;all_next - (addr_t)vnode,
 		&amp;rootfs_vnode_compare_func, &amp;rootfs_vnode_hash_func);
@@ -388,7 +386,6 @@
 	hash_uninit(fs-&gt;vnode_list_hash);
 err2:
 	mutex_destroy(&amp;fs-&gt;lock);
-err1:
 	free(fs);
 
 	return err;

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -1514,12 +1514,12 @@
 
 	while (true) {
 		struct io_context *context = NULL;
-		sem_id contextMutex = -1;
+		bool contextLocked = false;
 		struct team *team = NULL;
 		team_id lastTeamID;
 
 		cpu_status state = disable_interrupts();
-		GRAB_TEAM_LOCK();
+		SpinLocker teamsLock(team_spinlock);
 
 		lastTeamID = peek_next_thread_id();
 		if (nextTeamID &lt; lastTeamID) {
@@ -1531,12 +1531,20 @@
 
 			if (team) {
 				context = (io_context *)team-&gt;io_context;
-				contextMutex = context-&gt;io_mutex.sem;
+
+				// Some acrobatics to lock the context in a safe way
+				// (cf. _kern_get_next_fd_info() for details).
+				GRAB_THREAD_LOCK();
+				teamsLock.Unlock();
+				contextLocked = mutex_lock_threads_locked(&amp;context-&gt;io_mutex)
+					== B_OK;
+				RELEASE_THREAD_LOCK();
+
 				nextTeamID++;
 			}
 		}
 
-		RELEASE_TEAM_LOCK();
+		teamsLock.Unlock();
 		restore_interrupts(state);
 
 		if (context == NULL)
@@ -1546,7 +1554,7 @@
 		// safe access to the team structure, we now need to lock the mutex
 		// manually
 
-		if (acquire_sem(contextMutex) != B_OK) {
+		if (!contextLocked) {
 			// team seems to be gone, go over to the next team
 			continue;
 		}
@@ -1554,8 +1562,6 @@
 		// the team cannot be deleted completely while we're owning its
 		// io_context mutex, so we can safely play with it now
 
-		context-&gt;io_mutex.holder = thread_get_current_thread_id();
-
 		replace_vnode_if_disconnected(mount, vnodeToDisconnect, context-&gt;root,
 			sRoot, true);
 		replace_vnode_if_disconnected(mount, vnodeToDisconnect, context-&gt;cwd,
@@ -4141,11 +4147,7 @@
 		+ sizeof(struct select_sync*) * tableSize
 		+ (tableSize + 7) / 8);
 
-	if (mutex_init(&amp;context-&gt;io_mutex, &quot;I/O context&quot;) &lt; 0) {
-		free(context-&gt;fds);
-		free(context);
-		return NULL;
-	}
+	mutex_init(&amp;context-&gt;io_mutex, &quot;I/O context&quot;);
 
 	// Copy all parent file descriptors
 
@@ -4403,21 +4405,15 @@
 
 	sRoot = NULL;
 
-	if (mutex_init(&amp;sFileSystemsMutex, &quot;vfs_lock&quot;) &lt; 0)
-		panic(&quot;vfs_init: error allocating file systems lock\n&quot;);
+	mutex_init(&amp;sFileSystemsMutex, &quot;vfs_lock&quot;);
 
 	if (recursive_lock_init(&amp;sMountOpLock, &quot;vfs_mount_op_lock&quot;) &lt; 0)
 		panic(&quot;vfs_init: error allocating mount op lock\n&quot;);
 
-	if (mutex_init(&amp;sMountMutex, &quot;vfs_mount_lock&quot;) &lt; 0)
-		panic(&quot;vfs_init: error allocating mount lock\n&quot;);
+	mutex_init(&amp;sMountMutex, &quot;vfs_mount_lock&quot;);
+	mutex_init(&amp;sVnodeCoveredByMutex, &quot;vfs_vnode_covered_by_lock&quot;);
+	mutex_init(&amp;sVnodeMutex, &quot;vfs_vnode_lock&quot;);
 
-	if (mutex_init(&amp;sVnodeCoveredByMutex, &quot;vfs_vnode_covered_by_lock&quot;) &lt; 0)
-		panic(&quot;vfs_init: error allocating vnode::covered_by lock\n&quot;);
-
-	if (mutex_init(&amp;sVnodeMutex, &quot;vfs_vnode_lock&quot;) &lt; 0)
-		panic(&quot;vfs_init: error allocating vnode lock\n&quot;);
-
 	if (benaphore_init(&amp;sIOContextRootLock, &quot;io_context::root lock&quot;) &lt; 0)
 		panic(&quot;vfs_init: error allocating io_context::root lock\n&quot;);
 
@@ -7000,26 +6996,31 @@
 		return B_BAD_VALUE;
 
 	struct io_context *context = NULL;
-	sem_id contextMutex = -1;
 	struct team *team = NULL;
 
 	cpu_status state = disable_interrupts();
 	GRAB_TEAM_LOCK();
 
+	bool contextLocked = false;
 	team = team_get_team_struct_locked(teamID);
 	if (team) {
+		// We cannot lock the IO context while holding the team lock, nor can
+		// we just drop the team lock, since it might be deleted in the
+		// meantime. team_remove_team() acquires the thread lock when removing
+		// the team from the team hash table, though. Hence we switch to the
+		// thread lock and use mutex_lock_threads_locked().
 		context = (io_context *)team-&gt;io_context;
-		contextMutex = context-&gt;io_mutex.sem;
-	}
 
-	RELEASE_TEAM_LOCK();
+		GRAB_THREAD_LOCK();
+		RELEASE_TEAM_LOCK();
+		contextLocked = mutex_lock_threads_locked(&amp;context-&gt;io_mutex) == B_OK;
+		RELEASE_THREAD_LOCK();
+	} else
+		RELEASE_TEAM_LOCK();
+
 	restore_interrupts(state);
 
-	// we now have a context - since we couldn't lock it while having
-	// safe access to the team structure, we now need to lock the mutex
-	// manually
-
-	if (context == NULL || acquire_sem(contextMutex) != B_OK) {
+	if (!contextLocked) {
 		// team doesn't exit or seems to be gone
 		return B_BAD_TEAM_ID;
 	}
@@ -7027,8 +7028,6 @@
 	// the team cannot be deleted completely while we're owning its
 	// io_context mutex, so we can safely play with it now
 
-	context-&gt;io_mutex.holder = thread_get_current_thread_id();
-
 	uint32 slot = *_cookie;
 
 	struct file_descriptor *descriptor;

Modified: haiku/trunk/src/system/kernel/heap.cpp
===================================================================
--- haiku/trunk/src/system/kernel/heap.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/heap.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -469,8 +469,8 @@
 // #pragma mark - Heap functions
 
 
-heap_allocator *
-heap_attach(addr_t base, size_t size, bool postSem)
+static heap_allocator *
+heap_attach(addr_t base, size_t size)
 {
 	heap_allocator *heap = (heap_allocator *)base;
 	base += sizeof(heap_allocator);
@@ -517,16 +517,7 @@
 	heap-&gt;free_pages = &amp;heap-&gt;page_table[0];
 	heap-&gt;page_table[0].prev = NULL;
 
-	if (postSem) {
-		if (mutex_init(&amp;heap-&gt;lock, &quot;heap_mutex&quot;) &lt; 0) {
-			panic(&quot;heap_attach(): error creating heap mutex\n&quot;);
-			return NULL;
-		}
-	} else {
-		// pre-init the mutex to at least fall through any semaphore calls
-		heap-&gt;lock.sem = -1;
-		heap-&gt;lock.holder = -1;
-	}
+	mutex_init(&amp;heap-&gt;lock, &quot;heap_mutex&quot;);
 
 	heap-&gt;next = NULL;
 	dprintf(&quot;heap_attach: attached to %p - usable range 0x%08lx - 0x%08lx\n&quot;,
@@ -1014,7 +1005,7 @@
 		}
 
 		heap_allocator *newHeap = heap_attach((addr_t)heapAddress,
-			HEAP_GROW_SIZE, true);
+			HEAP_GROW_SIZE);
 		if (newHeap == NULL) {
 			panic(&quot;heap_grower: could not attach additional heap!\n&quot;);
 			delete_area(heapArea);
@@ -1038,7 +1029,7 @@
 status_t
 heap_init(addr_t base, size_t size)
 {
-	sHeapList = heap_attach(base, size, false);
+	sHeapList = heap_attach(base, size);
 
 	// set up some debug commands
 	add_debugger_command_etc(&quot;heap&quot;, &amp;dump_heap_list,
@@ -1063,12 +1054,6 @@
 status_t
 heap_init_post_sem()
 {
-	// create the lock for the initial heap
-	if (mutex_init(&amp;sHeapList-&gt;lock, &quot;heap_mutex&quot;) &lt; B_OK) {
-		panic(&quot;heap_init_post_sem(): error creating heap mutex\n&quot;);
-		return B_ERROR;
-	}
-
 	sHeapGrowSem = create_sem(0, &quot;heap_grow_sem&quot;);
 	if (sHeapGrowSem &lt; 0) {
 		panic(&quot;heap_init_post_sem(): failed to create heap grow sem\n&quot;);
@@ -1097,7 +1082,7 @@
 		return area;
 	}
 
-	sGrowHeap = heap_attach((addr_t)dedicated, HEAP_DEDICATED_GROW_SIZE, true);
+	sGrowHeap = heap_attach((addr_t)dedicated, HEAP_DEDICATED_GROW_SIZE);
 	if (sGrowHeap == NULL) {
 		panic(&quot;heap_init_post_thread(): failed to attach dedicated grow heap\n&quot;);
 		delete_area(area);

Modified: haiku/trunk/src/system/kernel/image.c
===================================================================
--- haiku/trunk/src/system/kernel/image.c	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/image.c	2008-05-01 22:07:36 UTC (rev 25283)
@@ -274,7 +274,8 @@
 	add_debugger_command(&quot;team_images&quot;, &amp;dump_images_list, &quot;Dump all registered images from the current team&quot;);
 #endif
 
-	return mutex_init(&amp;sImageMutex, &quot;image&quot;);
+	mutex_init(&amp;sImageMutex, &quot;image&quot;);
+	return B_OK;
 }
 
 

Modified: haiku/trunk/src/system/kernel/kernel_daemon.c
===================================================================
--- haiku/trunk/src/system/kernel/kernel_daemon.c	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/kernel_daemon.c	2008-05-01 22:07:36 UTC (rev 25283)
@@ -127,8 +127,7 @@
 {
 	thread_id thread;
 
-	if (mutex_init(&amp;sDaemonMutex, &quot;kernel daemon&quot;) &lt; B_OK)
-		return B_ERROR;
+	mutex_init(&amp;sDaemonMutex, &quot;kernel daemon&quot;);
 
 	list_init(&amp;sDaemons);
 

Modified: haiku/trunk/src/system/kernel/lock.cpp
===================================================================
--- haiku/trunk/src/system/kernel/lock.cpp	2008-05-01 21:59:46 UTC (rev 25282)
+++ haiku/trunk/src/system/kernel/lock.cpp	2008-05-01 22:07:36 UTC (rev 25283)
@@ -23,14 +23,14 @@
 #include &lt;util/AutoLock.h&gt;
 
 
-struct cutex_waiter {
+struct mutex_waiter {
 	struct thread*	thread;
-	cutex_waiter*	next;		// next in queue
-	cutex_waiter*	last;		// last in queue (valid for the first in queue)
+	mutex_waiter*	next;		// next in queue
+	mutex_waiter*	last;		// last in queue (valid for the first in queue)
 };
 
-#define CUTEX_FLAG_OWNS_NAME	CUTEX_FLAG_CLONE_NAME
-#define CUTEX_FLAG_RELEASED		0x2
+#define MUTEX_FLAG_OWNS_NAME	MUTEX_FLAG_CLONE_NAME
+#define MUTEX_FLAG_RELEASED		0x2
 
 
 int32
@@ -111,106 +111,6 @@
 
 
 status_t
-mutex_init(mutex *m, const char *name)
-{
-	if (m == NULL)
-		return EINVAL;
-
-	if (name == NULL)
-		name = &quot;mutex_sem&quot;;
-
-	m-&gt;holder = -1;
-
-	m-&gt;sem = create_sem(1, name);
-	if (m-&gt;sem &gt;= B_OK)
-		return B_OK;
-
-	return m-&gt;sem;
-}
-
-
-void
-mutex_destroy(mutex *mutex)
-{
-	if (mutex == NULL)
-		return;
-
-	if (mutex-&gt;sem &gt;= 0) {
-		delete_sem(mutex-&gt;sem);
-		mutex-&gt;sem = -1;
-	}
-	mutex-&gt;holder = -1;
-}
-
-
-status_t
-mutex_trylock(mutex *mutex)
-{
-	thread_id me = thread_get_current_thread_id();
-	status_t status;
-
-	if (kernel_startup)
-		return B_OK;
-
-	status = acquire_sem_etc(mutex-&gt;sem, 1, B_RELATIVE_TIMEOUT, 0);
-	if (status &lt; B_OK)
-		return status;
-
-	if (me == mutex-&gt;holder) {
-		panic(&quot;mutex_trylock failure: mutex %p (sem = 0x%lx) acquired twice by&quot;
-			&quot; thread 0x%lx\n&quot;, mutex, mutex-&gt;sem, me);
-	}
-
-	mutex-&gt;holder = me;
-	return B_OK;
-}
-
-
-status_t
-mutex_lock(mutex *mutex)
-{
-	thread_id me = thread_get_current_thread_id();
-	status_t status;
-
-	if (kernel_startup)
-		return B_OK;

[... truncated: 1046 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008411.html">[Haiku-commits] r25282 - haiku/trunk/src/bin/strace
</A></li>
	<LI>Next message: <A HREF="008413.html">[Haiku-commits] r25283 - in haiku/trunk: headers/private/kernel headers/private/kernel/util src/add-ons/kernel/drivers/arch/x86/keyboard src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_cache src/add-ons/kernel/network/protocols/tcp src/libs/compat/freebsd_network src/libs/compat/freebsd_network/compat/sys src/system/kernel src/system/kernel/arch/generic src/system/kernel/cache src/system/kernel/fs src/system/kernel/util src/system/kernel/vm src/system/libroot/os
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8412">[ date ]</a>
              <a href="thread.html#8412">[ thread ]</a>
              <a href="subject.html#8412">[ subject ]</a>
              <a href="author.html#8412">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
