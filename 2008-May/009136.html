<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25690 - in haiku/trunk: headers/private/kernel headers/private/kernel/util headers/private/net src/add-ons/kernel/bus_managers/ata src/add-ons/kernel/bus_managers/firewire src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/bus_managers/usb src/add-ons/kernel/busses/ide/generic_ide_pci src/add-ons/kernel/busses/ide/ide_isa src/add-ons/kernel/busses/ide/promise_tx2 src/add-ons/kernel/busses/usb src/add-ons/kernel/drivers/bus/scsi src/add-ons/kernel/drivers/bus/usb src/add-ons/kernel/drivers/disk/scsi/scsi_cd src/add-ons/kernel/drivers/disk/scsi/scsi_dsk src/add-ons/kernel/drivers/disk/usb/usb_disk src/add-ons/kernel/drivers/disk/virtual/nbd src/add-ons/kernel/drivers/ports/usb_serial src/add-ons/kernel/file_systems/googlefs src/add-ons/kernel/generic/block_io src/add-ons/kernel/generic/ide_adapter src/add-ons/kernel/generic/locked_pool src/add-ons/kernel/generic/scsi_periph src/add-ons/kernel/network/datalink_protocols/arp src! /add-ons/kernel/network/devices/ethernet src/add-ons/kernel/network/protocols/ipv4 src/add-ons/kernel/network/protocols/udp src/add-ons/kernel/network/protocols/unix src/add-ons/kernel/network/stack src/system/kernel src/system/kernel/device_manager
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25690%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%20headers/private/kernel/util%20headers/private/net%0A%20src/add-ons/kernel/bus_managers/ata%0A%20src/add-ons/kernel/bus_managers/firewire%0A%20src/add-ons/kernel/bus_managers/ide%20src/add-ons/kernel/bus_managers/scsi%0A%20src/add-ons/kernel/bus_managers/usb%0A%20src/add-ons/kernel/busses/ide/generic_ide_pci%0A%20src/add-ons/kernel/busses/ide/ide_isa%0A%20src/add-ons/kernel/busses/ide/promise_tx2%20src/add-ons/kernel/busses/usb%0A%20src/add-ons/kernel/drivers/bus/scsi%20src/add-ons/kernel/drivers/bus/usb%0A%20src/add-ons/kernel/drivers/disk/scsi/scsi_cd%0A%20src/add-ons/kernel/drivers/disk/scsi/scsi_dsk%0A%20src/add-ons/kernel/drivers/disk/usb/usb_disk%0A%20src/add-ons/kernel/drivers/disk/virtual/nbd%0A%20src/add-ons/kernel/drivers/ports/usb_serial%0A%20src/add-ons/kernel/file_systems/googlefs%0A%20src/add-ons/kernel/generic/block_io%20src/add-ons/kernel/generic/ide_adapter%0A%20src/add-ons/kernel/generic/locked_pool%0A%20src/add-ons/kernel/generic/scsi_periph%0A%20src/add-ons/kernel/network/datalink_protocols/arp%20src%21%0A%20/add-ons/kernel/network/devices/ethernet%0A%20src/add-ons/kernel/network/protocols/ipv4%0A%20src/add-ons/kernel/network/protocols/udp%0A%20src/add-ons/kernel/network/protocols/unix%20src/add-ons/kernel/network/stack%0A%20src/system/kernel%20src/system/kernel/device_manager&In-Reply-To=%3C200805290208.m4T28R8P000899%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009144.html">
   <LINK REL="Next"  HREF="009137.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25690 - in haiku/trunk: headers/private/kernel headers/private/kernel/util headers/private/net src/add-ons/kernel/bus_managers/ata src/add-ons/kernel/bus_managers/firewire src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/bus_managers/usb src/add-ons/kernel/busses/ide/generic_ide_pci src/add-ons/kernel/busses/ide/ide_isa src/add-ons/kernel/busses/ide/promise_tx2 src/add-ons/kernel/busses/usb src/add-ons/kernel/drivers/bus/scsi src/add-ons/kernel/drivers/bus/usb src/add-ons/kernel/drivers/disk/scsi/scsi_cd src/add-ons/kernel/drivers/disk/scsi/scsi_dsk src/add-ons/kernel/drivers/disk/usb/usb_disk src/add-ons/kernel/drivers/disk/virtual/nbd src/add-ons/kernel/drivers/ports/usb_serial src/add-ons/kernel/file_systems/googlefs src/add-ons/kernel/generic/block_io src/add-ons/kernel/generic/ide_adapter src/add-ons/kernel/generic/locked_pool src/add-ons/kernel/generic/scsi_periph src/add-ons/kernel/network/datalink_protocols/arp src! /add-ons/kernel/network/devices/ethernet src/add-ons/kernel/network/protocols/ipv4 src/add-ons/kernel/network/protocols/udp src/add-ons/kernel/network/protocols/unix src/add-ons/kernel/network/stack src/system/kernel src/system/kernel/device_manager</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25690%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%20headers/private/kernel/util%20headers/private/net%0A%20src/add-ons/kernel/bus_managers/ata%0A%20src/add-ons/kernel/bus_managers/firewire%0A%20src/add-ons/kernel/bus_managers/ide%20src/add-ons/kernel/bus_managers/scsi%0A%20src/add-ons/kernel/bus_managers/usb%0A%20src/add-ons/kernel/busses/ide/generic_ide_pci%0A%20src/add-ons/kernel/busses/ide/ide_isa%0A%20src/add-ons/kernel/busses/ide/promise_tx2%20src/add-ons/kernel/busses/usb%0A%20src/add-ons/kernel/drivers/bus/scsi%20src/add-ons/kernel/drivers/bus/usb%0A%20src/add-ons/kernel/drivers/disk/scsi/scsi_cd%0A%20src/add-ons/kernel/drivers/disk/scsi/scsi_dsk%0A%20src/add-ons/kernel/drivers/disk/usb/usb_disk%0A%20src/add-ons/kernel/drivers/disk/virtual/nbd%0A%20src/add-ons/kernel/drivers/ports/usb_serial%0A%20src/add-ons/kernel/file_systems/googlefs%0A%20src/add-ons/kernel/generic/block_io%20src/add-ons/kernel/generic/ide_adapter%0A%20src/add-ons/kernel/generic/locked_pool%0A%20src/add-ons/kernel/generic/scsi_periph%0A%20src/add-ons/kernel/network/datalink_protocols/arp%20src%21%0A%20/add-ons/kernel/network/devices/ethernet%0A%20src/add-ons/kernel/network/protocols/ipv4%0A%20src/add-ons/kernel/network/protocols/udp%0A%20src/add-ons/kernel/network/protocols/unix%20src/add-ons/kernel/network/stack%0A%20src/system/kernel%20src/system/kernel/device_manager&In-Reply-To=%3C200805290208.m4T28R8P000899%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25690 - in haiku/trunk: headers/private/kernel headers/private/kernel/util headers/private/net src/add-ons/kernel/bus_managers/ata src/add-ons/kernel/bus_managers/firewire src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/bus_managers/usb src/add-ons/kernel/busses/ide/generic_ide_pci src/add-ons/kernel/busses/ide/ide_isa src/add-ons/kernel/busses/ide/promise_tx2 src/add-ons/kernel/busses/usb src/add-ons/kernel/drivers/bus/scsi src/add-ons/kernel/drivers/bus/usb src/add-ons/kernel/drivers/disk/scsi/scsi_cd src/add-ons/kernel/drivers/disk/scsi/scsi_dsk src/add-ons/kernel/drivers/disk/usb/usb_disk src/add-ons/kernel/drivers/disk/virtual/nbd src/add-ons/kernel/drivers/ports/usb_serial src/add-ons/kernel/file_systems/googlefs src/add-ons/kernel/generic/block_io src/add-ons/kernel/generic/ide_adapter src/add-ons/kernel/generic/locked_pool src/add-ons/kernel/generic/scsi_periph src/add-ons/kernel/network/datalink_protocols/arp src! /add-ons/kernel/network/devices/ethernet src/add-ons/kernel/network/protocols/ipv4 src/add-ons/kernel/network/protocols/udp src/add-ons/kernel/network/protocols/unix src/add-ons/kernel/network/stack src/system/kernel src/system/kernel/device_manager">bonefish at mail.berlios.de
       </A><BR>
    <I>Thu May 29 04:08:27 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009144.html">[Haiku-commits] r25689 - in haiku/trunk: headers/private/kernel src/system/kernel
</A></li>
        <LI>Next message: <A HREF="009137.html">[Haiku-commits] r25691 - haiku/trunk/headers/private/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9136">[ date ]</a>
              <a href="thread.html#9136">[ thread ]</a>
              <a href="subject.html#9136">[ subject ]</a>
              <a href="author.html#9136">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-05-29 04:08:23 +0200 (Thu, 29 May 2008)
New Revision: 25690
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25690&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25690&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/kernel/lock.h
   haiku/trunk/headers/private/kernel/util/AutoLock.h
   haiku/trunk/headers/private/net/ProtocolUtilities.h
   haiku/trunk/headers/private/net/net_stack.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ata/ide_internal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ata/wrapper.h
   haiku/trunk/src/add-ons/kernel/bus_managers/firewire/firewire.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_internal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/wrapper.h
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_internal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/wrapper.h
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/BeOSCompatibility.h
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.h
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb_p.h
   haiku/trunk/src/add-ons/kernel/busses/ide/generic_ide_pci/wrapper.h
   haiku/trunk/src/add-ons/kernel/busses/ide/ide_isa/wrapper.h
   haiku/trunk/src/add-ons/kernel/busses/ide/promise_tx2/wrapper.h
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci.h
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci.h
   haiku/trunk/src/add-ons/kernel/drivers/bus/scsi/wrapper.h
   haiku/trunk/src/add-ons/kernel/drivers/bus/usb/usb_raw.cpp
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd/wrapper.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_dsk/wrapper.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/usb/usb_disk/usb_disk.cpp
   haiku/trunk/src/add-ons/kernel/drivers/disk/usb/usb_disk/usb_disk.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/virtual/nbd/nbd.c
   haiku/trunk/src/add-ons/kernel/drivers/ports/usb_serial/BeOSCompatibility.h
   haiku/trunk/src/add-ons/kernel/drivers/ports/usb_serial/SerialDevice.cpp
   haiku/trunk/src/add-ons/kernel/drivers/ports/usb_serial/SerialDevice.h
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/googlefs.h
   haiku/trunk/src/add-ons/kernel/generic/block_io/block_io.c
   haiku/trunk/src/add-ons/kernel/generic/block_io/block_io_private.h
   haiku/trunk/src/add-ons/kernel/generic/block_io/wrapper.h
   haiku/trunk/src/add-ons/kernel/generic/ide_adapter/wrapper.h
   haiku/trunk/src/add-ons/kernel/generic/locked_pool/locked_pool.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/wrapper.h
   haiku/trunk/src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp
   haiku/trunk/src/add-ons/kernel/network/devices/ethernet/ethernet.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/udp/udp.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/unix/UnixAddressManager.h
   haiku/trunk/src/add-ons/kernel/network/protocols/unix/UnixEndpoint.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/unix/UnixEndpoint.h
   haiku/trunk/src/add-ons/kernel/network/stack/datalink.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/domains.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/domains.h
   haiku/trunk/src/add-ons/kernel/network/stack/interfaces.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/link.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/routes.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/stack.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/utility.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/utility.h
   haiku/trunk/src/system/kernel/device_manager/device_manager.cpp
   haiku/trunk/src/system/kernel/lock.cpp
Log:
* Replaced all instances of benaphores in the kernel code by mutexes.
* Removed kernel benaphores.


Modified: haiku/trunk/headers/private/kernel/lock.h
===================================================================
--- haiku/trunk/headers/private/kernel/lock.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/headers/private/kernel/lock.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -38,12 +38,6 @@
 } recursive_lock;
 
 
-typedef struct benaphore {
-	sem_id	sem;
-	int32	count;
-} benaphore;
-
-
 struct rw_lock_waiter;
 
 typedef struct rw_lock {
@@ -81,37 +75,6 @@
 extern void recursive_lock_unlock(recursive_lock *lock);
 extern int32 recursive_lock_get_recursion(recursive_lock *lock);
 
-extern status_t benaphore_init(benaphore *ben, const char *name);
-extern void benaphore_destroy(benaphore *ben);
-
-
-static inline status_t
-benaphore_lock(benaphore *ben)
-{
-#ifdef KDEBUG
-	return acquire_sem(ben-&gt;sem);
-#else
-	if (atomic_add(&amp;ben-&gt;count, -1) &lt;= 0)
-		return acquire_sem(ben-&gt;sem);
-
-	return B_OK;
-#endif
-}
-
-
-static inline status_t
-benaphore_unlock(benaphore *ben)
-{
-#ifdef KDEBUG
-	return release_sem(ben-&gt;sem);
-#else
-	if (atomic_add(&amp;ben-&gt;count, 1) &lt; 0)
-		return release_sem(ben-&gt;sem);
-
-	return B_OK;
-#endif
-}
-
 extern void rw_lock_init(rw_lock* lock, const char* name);
 	// name is *not* cloned nor freed in rw_lock_destroy()
 extern void rw_lock_init_etc(rw_lock* lock, const char* name, uint32 flags);

Modified: haiku/trunk/headers/private/kernel/util/AutoLock.h
===================================================================
--- haiku/trunk/headers/private/kernel/util/AutoLock.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/headers/private/kernel/util/AutoLock.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -50,23 +50,6 @@
 // RecursiveLocker
 typedef AutoLocker&lt;recursive_lock, RecursiveLockLocking&gt; RecursiveLocker;
 
-// BenaphoreLocking
-class BenaphoreLocking {
-public:
-	inline bool Lock(benaphore *lockable)
-	{
-		return benaphore_lock(lockable) == B_OK;
-	}
-
-	inline void Unlock(benaphore *lockable)
-	{
-		benaphore_unlock(lockable);
-	}
-};
-
-// BenaphoreLocker
-typedef AutoLocker&lt;benaphore, BenaphoreLocking&gt; BenaphoreLocker;
-
 // InterruptsLocking
 class InterruptsLocking {
 public:
@@ -152,7 +135,6 @@
 using BPrivate::AutoLocker;
 using BPrivate::MutexLocker;
 using BPrivate::RecursiveLocker;
-using BPrivate::BenaphoreLocker;
 using BPrivate::InterruptsLocker;
 using BPrivate::SpinLocker;
 using BPrivate::InterruptsSpinLocker;

Modified: haiku/trunk/headers/private/net/ProtocolUtilities.h
===================================================================
--- haiku/trunk/headers/private/net/ProtocolUtilities.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/headers/private/net/ProtocolUtilities.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -21,16 +21,16 @@
 #include &lt;net_stack.h&gt;
 
 
-class BenaphoreLocking {
+class MutexLocking {
 public:
-	typedef benaphore Type;
-	typedef BenaphoreLocker AutoLocker;
+	typedef mutex Type;
+	typedef MutexLocker AutoLocker;
 
-	static status_t Init(benaphore *lock, const char *name)
-		{ return benaphore_init(lock, name); }
-	static void Destroy(benaphore *lock) { benaphore_destroy(lock); }
-	static status_t Lock(benaphore *lock) { return benaphore_lock(lock); }
-	static status_t Unlock(benaphore *lock) { return benaphore_unlock(lock); }
+	static status_t Init(mutex *lock, const char *name)
+		{ mutex_init_etc(lock, name, MUTEX_FLAG_CLONE_NAME); return B_OK; }
+	static void Destroy(mutex *lock) { mutex_destroy(lock); }
+	static status_t Lock(mutex *lock) { return mutex_lock(lock); }
+	static status_t Unlock(mutex *lock) { mutex_unlock(lock); return B_OK; }
 };
 
 
@@ -87,7 +87,7 @@
 }
 
 
-template&lt;typename LockingBase = BenaphoreLocking,
+template&lt;typename LockingBase = MutexLocking,
 	typename ModuleBundle = NetModuleBundleGetter&gt;
 class DatagramSocket : public ProtocolSocket {
 public:

Modified: haiku/trunk/headers/private/net/net_stack.h
===================================================================
--- haiku/trunk/headers/private/net/net_stack.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/headers/private/net/net_stack.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -27,7 +27,7 @@
 typedef struct ancillary_data_container ancillary_data_container;
 
 struct net_fifo {
-	benaphore	lock;
+	mutex		lock;
 	sem_id		notify;
 	int32		waiting;
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ata/ide_internal.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ata/ide_internal.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ata/ide_internal.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -139,7 +139,7 @@
 
 	ata_bus_state			state;		// current state of bus
 
-	benaphore status_report_ben; // to lock when you report XPT about bus state
+	mutex status_report_ben; 	// to lock when you report XPT about bus state
 								// i.e. during requeue, resubmit or finished
 
 	bool disconnected;			// true, if controller is lost

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ata/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ata/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ata/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/firewire/firewire.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/firewire/firewire.c	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/firewire/firewire.c	2008-05-29 02:08:23 UTC (rev 25690)
@@ -225,7 +225,7 @@
 fw_xferwake(struct fw_xfer *xfer)
 {
 //	struct mtx *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
-	benaphore *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
+	mutex *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
 
 	mtx_lock(lock);
 	xfer-&gt;flag |= FWXF_WAKE;
@@ -240,7 +240,7 @@
 fw_xferwait(struct fw_xfer *xfer)
 {
 //	struct mtx *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
-	benaphore *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
+	mutex *lock = &amp;xfer-&gt;fc-&gt;wait_lock;
 	int err = 0;
 
 	mtx_lock(lock);

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_internal.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_internal.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ide/ide_internal.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -176,7 +176,7 @@
 
 	ide_bus_state state;		// current state of bus
 
-	benaphore status_report_ben; // to lock when you report XPT about bus state
+	mutex status_report_ben; 	// to lock when you report XPT about bus state
 								// i.e. during requeue, resubmit or finished
 
 	bool disconnected;			// true, if controller is lost

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ide/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ide/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ide/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_internal.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_internal.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scsi_internal.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -94,7 +94,7 @@
 	sem_id start_service;		// released whenever service thread has work to do
 	bool shutting_down;			// set to true to tell service thread to shut down
 
-	benaphore mutex;			// used to synchronize changes in queueing and blocking
+	struct mutex mutex;			// used to synchronize changes in queueing and blocking
 
 	sem_id scan_lun_lock;		// allocated whenever a lun is scanned
 
@@ -174,7 +174,7 @@
 	scsi_res_inquiry inquiry_data;
 	device_node *node;	// device node
 
-	benaphore dma_buffer_lock;	// lock between DMA buffer user and clean-up daemon
+	struct mutex dma_buffer_lock;	// lock between DMA buffer user and clean-up daemon
 	sem_id dma_buffer_owner;	// to be acquired before using DMA buffer
 	dma_buffer dma_buffer;		// DMA buffer
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/BeOSCompatibility.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/BeOSCompatibility.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/BeOSCompatibility.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -30,14 +30,14 @@
 #endif
 
 
-typedef struct benaphore {
+typedef struct mutex {
 	sem_id	sem;
 	int32	count;
-} benaphore;
+} mutex;
 
 
 inline status_t
-benaphore_init(benaphore *ben, const char *name)
+mutex_init(mutex *ben, const char *name)
 {
 	if (ben == NULL || name == NULL)
 		return B_BAD_VALUE;
@@ -52,7 +52,7 @@
 
 
 inline void
-benaphore_destroy(benaphore *ben)
+mutex_destroy(mutex *ben)
 {
 	delete_sem(ben-&gt;sem);
 	ben-&gt;sem = -1;
@@ -60,7 +60,7 @@
 
 
 inline status_t
-benaphore_lock(benaphore *ben)
+mutex_lock(mutex *ben)
 {
 	if (atomic_add(&amp;ben-&gt;count, -1) &lt;= 0)
 		return acquire_sem(ben-&gt;sem);
@@ -69,7 +69,7 @@
 
 
 inline status_t
-benaphore_unlock(benaphore *ben)
+mutex_unlock(mutex *ben)
 {
 	if (atomic_add(&amp;ben-&gt;count, 1) &lt; 0)
 		return release_sem(ben-&gt;sem);

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -14,10 +14,7 @@
 	:	fInitOK(false),
 		fRootHub(NULL)
 {
-	if (benaphore_init(&amp;fLock, &quot;usb busmanager lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB BusManager: failed to create busmanager lock\n&quot;));
-		return;
-	}
+	mutex_init(&amp;fLock, &quot;usb busmanager lock&quot;);
 
 	fRootObject = new(std::nothrow) Object(stack, this);
 	if (!fRootObject)
@@ -39,7 +36,7 @@
 BusManager::~BusManager()
 {
 	Lock();
-	benaphore_destroy(&amp;fLock);
+	mutex_destroy(&amp;fLock);
 	for (int32 i = 0; i &lt;= USB_SPEED_MAX; i++)
 		delete fDefaultPipes[i];
 	delete fRootObject;
@@ -59,14 +56,14 @@
 bool
 BusManager::Lock()
 {
-	return (benaphore_lock(&amp;fLock) == B_OK);
+	return (mutex_lock(&amp;fLock) == B_OK);
 }
 
 
 void
 BusManager::Unlock()
 {
-	benaphore_unlock(&amp;fLock);
+	mutex_unlock(&amp;fLock);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -30,10 +30,7 @@
 		fStatus(B_NO_INIT)
 {
 	fName = strdup(name);
-	if (benaphore_init(&amp;fLock, fName) &lt; B_OK) {
-		TRACE_ERROR((&quot;PMA: failed to create benaphore lock\n&quot;));
-		return;
-	}
+	mutex_init_etc(&amp;fLock, fName, MUTEX_FLAG_CLONE_NAME);
 
 	fArrayCount = 1;
 	size_t biggestSize = minSize;
@@ -103,21 +100,21 @@
 	free(fName);
 
 	delete_area(fArea);
-	benaphore_destroy(&amp;fLock);
+	mutex_destroy(&amp;fLock);
 }
 
 
 bool
 PhysicalMemoryAllocator::_Lock()
 {
-	return (benaphore_lock(&amp;fLock) == B_OK);
+	return (mutex_lock(&amp;fLock) == B_OK);
 }
 
 
 void
 PhysicalMemoryAllocator::_Unlock()
 {
-	benaphore_unlock(&amp;fLock);
+	mutex_unlock(&amp;fLock);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -47,7 +47,7 @@
 		size_t						fManagedMemory;
 		status_t					fStatus;
 
-		benaphore					fLock;
+		mutex						fLock;
 		area_id						fArea;
 		void						*fLogicalBase;
 		void						*fPhysicalBase;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -28,16 +28,9 @@
 {
 	TRACE((&quot;USB Stack: stack init\n&quot;));
 
-	if (benaphore_init(&amp;fStackLock, &quot;usb stack lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Stack: failed to create stack lock\n&quot;));
-		return;
-	}
+	mutex_init(&amp;fStackLock, &quot;usb stack lock&quot;);
+	mutex_init(&amp;fExploreLock, &quot;usb explore lock&quot;);
 
-	if (benaphore_init(&amp;fExploreLock, &quot;usb explore lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Stack: failed to create explore lock\n&quot;));
-		return;
-	}
-
 	size_t objectArraySize = fObjectMaxCount * sizeof(Object *);
 	fObjectArray = (Object **)malloc(objectArraySize);
 	memset(fObjectArray, 0, objectArraySize);
@@ -106,10 +99,10 @@
 	fStopThreads = true;
 	wait_for_thread(fExploreThread, &amp;result);
 
-	benaphore_lock(&amp;fStackLock);
-	benaphore_destroy(&amp;fStackLock);
-	benaphore_lock(&amp;fExploreLock);
-	benaphore_destroy(&amp;fExploreLock);
+	mutex_lock(&amp;fStackLock);
+	mutex_destroy(&amp;fStackLock);
+	mutex_lock(&amp;fExploreLock);
+	mutex_destroy(&amp;fExploreLock);
 
 	//Release the bus modules
 	for (Vector&lt;BusManager *&gt;::Iterator i = fBusManagers.Begin();
@@ -133,14 +126,14 @@
 bool
 Stack::Lock()
 {
-	return (benaphore_lock(&amp;fStackLock) == B_OK);
+	return (mutex_lock(&amp;fStackLock) == B_OK);
 }
 
 
 void
 Stack::Unlock()
 {
-	benaphore_unlock(&amp;fStackLock);
+	mutex_unlock(&amp;fStackLock);
 }
 
 
@@ -211,7 +204,7 @@
 	Stack *stack = (Stack *)data;
 
 	while (!stack-&gt;fStopThreads) {
-		if (benaphore_lock(&amp;stack-&gt;fExploreLock) != B_OK)
+		if (mutex_lock(&amp;stack-&gt;fExploreLock) != B_OK)
 			break;
 
 		rescan_item *rescanList = NULL;
@@ -236,7 +229,7 @@
 		}
 
 		stack-&gt;fFirstExploreDone = true;
-		benaphore_unlock(&amp;stack-&gt;fExploreLock);
+		mutex_unlock(&amp;stack-&gt;fExploreLock);
 		stack-&gt;RescanDrivers(rescanList);
 		snooze(USB_DELAY_HUB_EXPLORE);
 	}
@@ -461,7 +454,7 @@
 	usb_driver_info *element = fDriverList;
 	while (element) {
 		if (strcmp(element-&gt;driver_name, driverName) == 0) {
-			if (benaphore_lock(&amp;fExploreLock) != B_OK)
+			if (mutex_lock(&amp;fExploreLock) != B_OK)
 				return B_ERROR;
 
 			// inform driver about any already present devices
@@ -477,7 +470,7 @@
 
 			element-&gt;notify_hooks.device_added = hooks-&gt;device_added;
 			element-&gt;notify_hooks.device_removed = hooks-&gt;device_removed;
-			benaphore_unlock(&amp;fExploreLock);
+			mutex_unlock(&amp;fExploreLock);
 			return B_OK;
 		}
 
@@ -496,7 +489,7 @@
 	usb_driver_info *element = fDriverList;
 	while (element) {
 		if (strcmp(element-&gt;driver_name, driverName) == 0) {
-			if (benaphore_lock(&amp;fExploreLock) != B_OK)
+			if (mutex_lock(&amp;fExploreLock) != B_OK)
 				return B_ERROR;
 
 			// trigger the device removed hook
@@ -510,7 +503,7 @@
 
 			element-&gt;notify_hooks.device_added = NULL;
 			element-&gt;notify_hooks.device_removed = NULL;
-			benaphore_unlock(&amp;fExploreLock);
+			mutex_unlock(&amp;fExploreLock);
 			return B_OK;
 		}
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb_p.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb_p.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb_p.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -149,8 +149,8 @@
 		bool							fFirstExploreDone;
 		bool							fStopThreads;
 
-		benaphore						fStackLock;
-		benaphore						fExploreLock;
+		mutex							fStackLock;
+		mutex							fExploreLock;
 		PhysicalMemoryAllocator			*fAllocator;
 
 		uint32							fObjectIndex;
@@ -204,7 +204,7 @@
 private:
 		ControlPipe 					*_GetDefaultPipe(usb_speed);
 
-		benaphore						fLock;
+		mutex							fLock;
 
 		bool							fDeviceMap[128];
 		int8							fDeviceIndex;

Modified: haiku/trunk/src/add-ons/kernel/busses/ide/generic_ide_pci/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/ide/generic_ide_pci/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/ide/generic_ide_pci/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/busses/ide/ide_isa/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/ide/ide_isa/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/ide/ide_isa/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/busses/ide/promise_tx2/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/ide/promise_tx2/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/ide/promise_tx2/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/busses/usb/ohci.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/usb/ohci.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/usb/ohci.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -80,10 +80,7 @@
 	TRACE((&quot;usb_ohci: constructing new OHCI Host Controller Driver\n&quot;));
 	fInitOK = false;
 
-	if (benaphore_init(&amp;fEndpointLock, &quot;ohci endpoint lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;usb_ohci: failed to create endpoint lock\n&quot;));
-		return;
-	}
+	mutex_init(&amp;fEndpointLock, &quot;ohci endpoint lock&quot;);
 
 	// enable busmaster and memory mapped access
 	uint16 command = sPCIModule-&gt;read_pci_config(fPCIInfo-&gt;bus,
@@ -335,7 +332,7 @@
 	wait_for_thread(fFinishThread, &amp;result);
 
 	_LockEndpoints();
-	benaphore_destroy(&amp;fEndpointLock);
+	mutex_destroy(&amp;fEndpointLock);
 
 	if (fHccaArea &gt;= B_OK)
 		delete_area(fHccaArea);
@@ -1718,14 +1715,14 @@
 bool
 OHCI::_LockEndpoints()
 {
-	return (benaphore_lock(&amp;fEndpointLock) == B_OK);
+	return (mutex_lock(&amp;fEndpointLock) == B_OK);
 }
 
 
 void
 OHCI::_UnlockEndpoints()
 {
-	benaphore_unlock(&amp;fEndpointLock);
+	mutex_unlock(&amp;fEndpointLock);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/busses/usb/ohci.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/usb/ohci.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/usb/ohci.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -152,7 +152,7 @@
 		ohci_endpoint_descriptor	**fInterruptEndpoints;
 
 		// Endpoint management
-		benaphore					fEndpointLock;
+		mutex						fEndpointLock;
 		ohci_endpoint_descriptor	*fDummyControl;
 		ohci_endpoint_descriptor	*fDummyBulk;
 		ohci_endpoint_descriptor	*fDummyIsochronous;

Modified: haiku/trunk/src/add-ons/kernel/busses/usb/uhci.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/usb/uhci.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/usb/uhci.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -90,10 +90,7 @@
 {
 	fStack = stack;
 
-	if (benaphore_init(&amp;fLock, &quot;uhci queue lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;usb_uhci: failed to create queue lock\n&quot;));
-		return;
-	}
+	mutex_init(&amp;fLock, &quot;uhci queue lock&quot;);
 
 	void *physicalAddress;
 	fStatus = fStack-&gt;AllocateChunk((void **)&amp;fQueueHead, &amp;physicalAddress,
@@ -112,7 +109,7 @@
 Queue::~Queue()
 {
 	Lock();
-	benaphore_destroy(&amp;fLock);
+	mutex_destroy(&amp;fLock);
 
 	fStack-&gt;FreeChunk(fQueueHead, (void *)fQueueHead-&gt;this_phy, sizeof(uhci_qh));
 
@@ -132,14 +129,14 @@
 bool
 Queue::Lock()
 {
-	return (benaphore_lock(&amp;fLock) == B_OK);
+	return (mutex_lock(&amp;fLock) == B_OK);
 }
 
 
 void
 Queue::Unlock()
 {
-	benaphore_unlock(&amp;fLock);
+	mutex_unlock(&amp;fLock);
 }
 
 
@@ -434,10 +431,7 @@
 	resume_thread(fFinishThread);
 
 	// Create a lock for the isochronous transfer list
-	if (benaphore_init(&amp;fIsochronousLock, &quot;UHCI isochronous lock&quot;) &lt; B_OK) {
-		TRACE_ERROR((&quot;usb_uhci: failed to create isochronous lock\n&quot;));
-		return;
-	}
+	mutex_init(&amp;fIsochronousLock, &quot;UHCI isochronous lock&quot;);
 
 	// Create semaphore the isochronous finisher thread will wait for
 	fFinishIsochronousTransfersSem = create_sem(0,
@@ -484,7 +478,7 @@
 		delete isoTransfer;
 		isoTransfer = next;
 	}
-	benaphore_destroy(&amp;fIsochronousLock);
+	mutex_destroy(&amp;fIsochronousLock);
 
 	Lock();
 	transfer_data *transfer = fFirstTransfer;
@@ -2070,14 +2064,14 @@
 bool
 UHCI::LockIsochronous()
 {
-	return (benaphore_lock(&amp;fIsochronousLock) == B_OK);
+	return (mutex_lock(&amp;fIsochronousLock) == B_OK);
 }
 
 
 void
 UHCI::UnlockIsochronous()
 {
-	benaphore_unlock(&amp;fIsochronousLock);
+	mutex_unlock(&amp;fIsochronousLock);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/busses/usb/uhci.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/usb/uhci.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/busses/usb/uhci.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -52,7 +52,7 @@
 		uhci_qh						*fQueueHead;
 		uhci_td						*fStrayDescriptor;
 		uhci_qh						*fQueueTop;
-		benaphore					fLock;
+		mutex						fLock;
 };
 
 
@@ -225,7 +225,7 @@
 		isochronous_transfer_data	*fLastIsochronousTransfer;
 		sem_id						fFinishIsochronousTransfersSem;
 		thread_id					fFinishIsochronousThread;
-		benaphore					fIsochronousLock;
+		mutex						fIsochronousLock;
 		bool						fStopFinishIsochronousThread;
 
 		// Root hub

Modified: haiku/trunk/src/add-ons/kernel/drivers/bus/scsi/wrapper.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/bus/scsi/wrapper.h	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/drivers/bus/scsi/wrapper.h	2008-05-29 02:08:23 UTC (rev 25690)
@@ -7,10 +7,11 @@
 
 // benaphores
 
-#define INIT_BEN(x, prefix)	benaphore_init(x, prefix)
-#define	DELETE_BEN(x)		benaphore_destroy(x)
-#define ACQUIRE_BEN(x)		benaphore_lock(x)
-#define RELEASE_BEN(x)		benaphore_unlock(x)
+#define INIT_BEN(x, prefix)	(mutex_init_etc(x, prefix, MUTEX_FLAG_CLONE_NAME), \
+								B_OK)
+#define	DELETE_BEN(x)		mutex_destroy(x)
+#define ACQUIRE_BEN(x)		mutex_lock(x)
+#define RELEASE_BEN(x)		mutex_unlock(x)
 
 // debug output
 

Modified: haiku/trunk/src/add-ons/kernel/drivers/bus/usb/usb_raw.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/bus/usb/usb_raw.cpp	2008-05-29 00:32:06 UTC (rev 25689)
+++ haiku/trunk/src/add-ons/kernel/drivers/bus/usb/usb_raw.cpp	2008-05-29 02:08:23 UTC (rev 25690)
@@ -28,7 +28,7 @@
 
 typedef struct {
 	usb_device			device;
-	benaphore			lock;
+	mutex				lock;
 	uint32				reference_count;
 
 	char				name[32];
@@ -43,7 +43,7 @@
 static usb_module_info *gUSBModule = NULL;
 static raw_device *gDeviceList = NULL;
 static uint32 gDeviceCount = 0;
-static benaphore gDeviceListLock;
+static mutex gDeviceListLock;
 static char **gDeviceNames = NULL;
 
 static status_t
@@ -52,15 +52,11 @@
 	TRACE((DRIVER_NAME&quot;: device_added(0x%08lx)\n&quot;, newDevice));
 	raw_device *device = (raw_device *)malloc(sizeof(raw_device));
 
-	status_t result = benaphore_init(&amp;device-&gt;lock, &quot;usb_raw device lock&quot;);
-	if (result &lt; B_OK) {
-		free(device);
-		return result;
-	}
+	mutex_init(&amp;device-&gt;lock, &quot;usb_raw device lock&quot;);
 
 	device-&gt;notify = create_sem(0, &quot;usb_raw callback notify&quot;);
 	if (device-&gt;notify &lt; B_OK) {
-		benaphore_destroy(&amp;device-&gt;lock);
+		mutex_destroy(&amp;device-&gt;lock);
 		free(device);
 		return B_NO_MORE_SEMS;
 	}
@@ -76,11 +72,11 @@
 	device-&gt;device = newDevice;
 	device-&gt;reference_count = 0;
 
-	benaphore_lock(&amp;gDeviceListLock);
+	mutex_lock(&amp;gDeviceListLock);
 	device-&gt;link = (void *)gDeviceList;
 	gDeviceList = device;
 	gDeviceCount++;
-	benaphore_unlock(&amp;gDeviceListLock);
+	mutex_unlock(&amp;gDeviceListLock);
 
 	TRACE((DRIVER_NAME&quot;: new device: 0x%08lx\n&quot;, (uint32)device));
 	*cookie = (void *)device;
@@ -94,7 +90,7 @@
 	TRACE((DRIVER_NAME&quot;: device_removed(0x%08lx)\n&quot;, (uint32)cookie));
 	raw_device *device = (raw_device *)cookie;
 
-	benaphore_lock(&amp;gDeviceListLock);
+	mutex_lock(&amp;gDeviceListLock);
 	if (gDeviceList == device) {
 		gDeviceList = (raw_device *)device-&gt;link;
 	} else {
@@ -109,12 +105,12 @@
 		}
 	}
 	gDeviceCount--;
-	benaphore_unlock(&amp;gDeviceListLock);
+	mutex_unlock(&amp;gDeviceListLock);
 
 	device-&gt;device = 0;
 	if (device-&gt;reference_count == 0) {
-		benaphore_lock(&amp;device-&gt;lock);
-		benaphore_destroy(&amp;device-&gt;lock);
+		mutex_lock(&amp;device-&gt;lock);
+		mutex_destroy(&amp;device-&gt;lock);
 		delete_sem(device-&gt;notify);
 		free(device);
 	}
@@ -132,20 +128,20 @@
 usb_raw_open(const char *name, uint32 flags, void **cookie)
 {
 	TRACE((DRIVER_NAME&quot;: open()\n&quot;));
-	benaphore_lock(&amp;gDeviceListLock);
+	mutex_lock(&amp;gDeviceListLock);
 	raw_device *element = gDeviceList;
 	while (element) {
 		if (strcmp(name, element-&gt;name) == 0) {
 			element-&gt;reference_count++;
 			*cookie = element;
-			benaphore_unlock(&amp;gDeviceListLock);
+			mutex_unlock(&amp;gDeviceListLock);
 			return B_OK;
 		}
 
 		element = (raw_device *)element-&gt;link;
 	}
 
-	benaphore_unlock(&amp;gDeviceListLock);
+	mutex_unlock(&amp;gDeviceListLock);
 	return B_NAME_NOT_FOUND;
 }
 
@@ -162,18 +158,18 @@
 usb_raw_free(void *cookie)
 {
 	TRACE((DRIVER_NAME&quot;: free()\n&quot;));
-	benaphore_lock(&amp;gDeviceListLock);
+	mutex_lock(&amp;gDeviceListLock);
 
 	raw_device *device = (raw_device *)cookie;
 	device-&gt;reference_count--;
 	if (device-&gt;device == 0) {
-		benaphore_lock(&amp;device-&gt;lock);
-		benaphore_destroy(&amp;device-&gt;lock);
+		mutex_lock(&amp;device-&gt;lock);
+		mutex_destroy(&amp;device-&gt;lock);
 		delete_sem(device-&gt;notify);
 		free(device);
 	}
 
-	benaphore_unlock(&amp;gDeviceListLock);
+	mutex_unlock(&amp;gDeviceListLock);
 	return B_OK;
 }
 
@@ -538,7 +534,7 @@
 		}
 
 		case B_USB_RAW_COMMAND_CONTROL_TRANSFER: {
-			benaphore_lock(&amp;device-&gt;lock);
+			mutex_lock(&amp;device-&gt;lock);
 			if (gUSBModule-&gt;queue_request(device-&gt;device,
 				command-&gt;control.request_type, command-&gt;control.request,
 				command-&gt;control.value, command-&gt;control.index,
@@ -546,14 +542,14 @@
 				usb_raw_callback, device) &lt; B_OK) {
 				command-&gt;control.status = B_USB_RAW_STATUS_FAILED;
 				command-&gt;control.length = 0;
-				benaphore_unlock(&amp;device-&gt;lock);
+				mutex_unlock(&amp;device-&gt;lock);
 				return B_OK;
 			}
 
 			acquire_sem(device-&gt;notify);
 			command-&gt;control.status = device-&gt;status;
 			command-&gt;control.length = device-&gt;actual_length;
-			benaphore_unlock(&amp;device-&gt;lock);
+			mutex_unlock(&amp;device-&gt;lock);
 			return B_OK;
 		}
 
@@ -609,7 +605,7 @@
 			}
 
 			status_t status;
-			benaphore_lock(&amp;device-&gt;lock);
+			mutex_lock(&amp;device-&gt;lock);
 			if (op == B_USB_RAW_COMMAND_INTERRUPT_TRANSFER) {
 				status = gUSBModule-&gt;queue_interrupt(endpointInfo-&gt;handle,
 					command-&gt;transfer.data, command-&gt;transfer.length,
@@ -629,14 +625,14 @@
 				command-&gt;transfer.status = B_USB_RAW_STATUS_FAILED;
 				command-&gt;transfer.length = 0;
 				free(packetDescriptors);
-				benaphore_unlock(&amp;device-&gt;lock);
+				mutex_unlock(&amp;device-&gt;lock);
 				return B_OK;
 			}
 
 			acquire_sem(device-&gt;notify);
 			command-&gt;transfer.status = device-&gt;status;
 			command-&gt;transfer.length = device-&gt;actual_length;
-			benaphore_unlock(&amp;device-&gt;lock);
+			mutex_unlock(&amp;device-&gt;lock);
 
 			if (op == B_USB_RAW_COMMAND_ISOCHRONOUS_TRANSFER) {
 				memcpy(command-&gt;isochronous.packet_descriptors,
@@ -694,17 +690,14 @@
 
 	gDeviceList = NULL;
 	gDeviceCount = 0;
-	status_t result = benaphore_init(&amp;gDeviceListLock, &quot;usb_raw device list lock&quot;);
-	if (result &lt; B_OK) {
-		TRACE((DRIVER_NAME&quot;: failed to create device list lock\n&quot;));
-		return result;
-	}
+	mutex_init(&amp;gDeviceListLock, &quot;usb_raw device list lock&quot;);

[... truncated: 2953 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009144.html">[Haiku-commits] r25689 - in haiku/trunk: headers/private/kernel src/system/kernel
</A></li>
	<LI>Next message: <A HREF="009137.html">[Haiku-commits] r25691 - haiku/trunk/headers/private/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9136">[ date ]</a>
              <a href="thread.html#9136">[ thread ]</a>
              <a href="subject.html#9136">[ subject ]</a>
              <a href="author.html#9136">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
