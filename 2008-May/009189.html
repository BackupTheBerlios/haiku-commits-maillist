<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25718 - haiku/trunk/src/kits/tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25718%20-%20haiku/trunk/src/kits/tracker&In-Reply-To=%3C200805300907.m4U977Kx018628%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009187.html">
   <LINK REL="Next"  HREF="009190.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25718 - haiku/trunk/src/kits/tracker</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25718%20-%20haiku/trunk/src/kits/tracker&In-Reply-To=%3C200805300907.m4U977Kx018628%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25718 - haiku/trunk/src/kits/tracker">axeld at mail.berlios.de
       </A><BR>
    <I>Fri May 30 11:07:07 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009187.html">[Haiku-commits] r25717 - haiku/trunk/src/system/kernel/vm
</A></li>
        <LI>Next message: <A HREF="009190.html">[Haiku-commits] r25719 - haiku/trunk/src/kits/tracker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9189">[ date ]</a>
              <a href="thread.html#9189">[ thread ]</a>
              <a href="subject.html#9189">[ subject ]</a>
              <a href="author.html#9189">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-05-30 11:07:06 +0200 (Fri, 30 May 2008)
New Revision: 25718
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25718&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25718&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/tracker/PoseView.cpp
Log:
A bit of cleanup.


Modified: haiku/trunk/src/kits/tracker/PoseView.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/PoseView.cpp	2008-05-30 01:02:29 UTC (rev 25717)
+++ haiku/trunk/src/kits/tracker/PoseView.cpp	2008-05-30 09:07:06 UTC (rev 25718)
@@ -102,7 +102,7 @@
 
 namespace BPrivate {
 extern bool delete_point(void *);
-	// ToDo: exterminate this
+	// TODO: exterminate this
 }
 
 const float kSlowScrollBucket = 30;
@@ -140,10 +140,10 @@
 struct AddPosesResult {
 	~AddPosesResult();
 	void ReleaseModels();
-	
-	Model *fModels[kMaxAddPosesChunk]; 
-	PoseInfo fPoseInfos[kMaxAddPosesChunk]; 
-	int32 fCount; 
+
+	Model *fModels[kMaxAddPosesChunk];
+	PoseInfo fPoseInfos[kMaxAddPosesChunk];
+	int32 fCount;
 };
 
 
@@ -237,7 +237,7 @@
 	delete fViewState;
 	delete fModel;
 	delete fKeyRunner;
-	
+
 	IconCache::sIconCache-&gt;Deleting(this);
 }
 
@@ -247,15 +247,15 @@
 {
 	RestoreState(node);
 	InitCommon();
-}	
+}
 
-	
+
 void
 BPoseView::Init(const BMessage &amp;message)
 {
 	RestoreState(message);
 	InitCommon();
-}	
+}
 
 
 void
@@ -329,7 +329,7 @@
 }
 
 
-void 
+void
 BPoseView::RestoreColumnState(AttributeStreamNode *node)
 {
 	fColumnList-&gt;MakeEmpty();
@@ -364,8 +364,8 @@
 
 				// Clear old column list if neccessary
 
-				//	Put items in the list in order so they can be checked
-				//	for overlaps below.
+				// Put items in the list in order so they can be checked
+				// for overlaps below.
 				BObjectList&lt;BColumn&gt; tempSortedList;
 				for (;;) {
 					BColumn *column = BColumn::InstantiateFromStream(&amp;stream,
@@ -390,7 +390,7 @@
 }
 
 
-void 
+void
 BPoseView::RestoreColumnState(const BMessage &amp;message)
 {
 	fColumnList-&gt;MakeEmpty();
@@ -441,7 +441,7 @@
 }
 
 
-void 
+void
 BPoseView::RestoreState(AttributeStreamNode *node)
 {
 	RestoreColumnState(node);
@@ -492,7 +492,7 @@
 }
 
 
-void 
+void
 BPoseView::RestoreState(const BMessage &amp;message)
 {
 	RestoreColumnState(message);
@@ -565,7 +565,7 @@
 }
 
 
-void 
+void
 BPoseView::SaveColumnState(AttributeStreamNode *node)
 {
 	BMallocIO stream;
@@ -589,7 +589,7 @@
 }
 
 
-void 
+void
 BPoseView::SaveColumnState(BMessage &amp;message) const
 {
 	for (int32 index = 0; ; index++) {
@@ -601,7 +601,7 @@
 }
 
 
-void 
+void
 BPoseView::SaveState(AttributeStreamNode *node)
 {
 	SaveColumnState(node);
@@ -635,7 +635,7 @@
 }
 
 
-void 
+void
 BPoseView::SaveState(BMessage &amp;message) const
 {
 	SaveColumnState(message);
@@ -649,14 +649,14 @@
 }
 
 
-float 
+float
 BPoseView::StringWidth(const char *str) const
 {
 	return sWidthBuffer-&gt;StringWidth(str, 0, (int32)strlen(str), &amp;sCurrentFont);
 }
 
 
-float 
+float
 BPoseView::StringWidth(const char *str, int32 len) const
 {
 	ASSERT(strlen(str) == (uint32)len);
@@ -744,16 +744,16 @@
 				BVolumeRoster().GetBootVolume(&amp;bootVol);
 				if (FSGetDeskDir(&amp;dir, bootVol.Device()) == B_OK) {
 					if (dir.WriteAttr(kAttrDisksPoseInfo, B_RAW_TYPE, 0,
-						&amp;poseInfo, sizeof(poseInfo)) == sizeof(poseInfo)) 
+						&amp;poseInfo, sizeof(poseInfo)) == sizeof(poseInfo))
 						// nuke opposite endianness
 						dir.RemoveAttr(kAttrDisksPoseInfoForeign);
 
 					if (desktop &amp;&amp; dir.WriteAttr(kAttrExtendedDisksPoseInfo,
 						B_RAW_TYPE, 0,
 						extendedPoseInfo, extendedPoseInfoSize)
-							== (ssize_t)extendedPoseInfoSize) 
+							== (ssize_t)extendedPoseInfoSize)
 						// nuke opposite endianness
-						dir.RemoveAttr(kAttrExtendedDisksPoseInfoForegin);						
+						dir.RemoveAttr(kAttrExtendedDisksPoseInfoForegin);
 				}
 			} else {
 				model-&gt;WriteAttrKillForegin(kAttrPoseInfo, kAttrPoseInfoForeign,
@@ -767,14 +767,13 @@
 			}
 
 			delete [] (char *)extendedPoseInfo;
-				// ToDo:
-				// fix up this mess
+				// TODO: fix up this mess
 		}
 	}
 }
 
 
-void 
+void
 BPoseView::StartWatching()
 {
 	// watch volumes
@@ -787,7 +786,7 @@
 }
 
 
-void 
+void
 BPoseView::StopWatching()
 {
 	stop_watching(this);
@@ -823,9 +822,9 @@
 	BContainerWindow *window = ContainerWindow();
 	if (!window)
 		return;
-	
+
 	window-&gt;PulseTaskLoop();
-		// make sure task loop gets pulsed properly, if installed 
+		// make sure task loop gets pulsed properly, if installed
 
 	// update item count view in window if necessary
 	UpdateCount();
@@ -862,7 +861,7 @@
 BPoseView::AttachedToWindow()
 {
 	fIsDesktopWindow = (dynamic_cast&lt;BDeskWindow *&gt;(Window()) != 0);
-	if (fIsDesktopWindow) 
+	if (fIsDesktopWindow)
 		AddFilter(new TPoseViewFilter(this));
 
 	AddFilter(new ShortcutFilter(B_RETURN, B_OPTION_KEY, kOpenSelection, this));
@@ -905,17 +904,17 @@
 			fViewState-&gt;SetIconSize(B_LARGE_ICON);
 			fIconPoseHeight = ceilf(IconSizeInt() + sFontHeight + 1);
 			break;
-		
+
 		case kMiniIconMode:
 			fViewState-&gt;SetIconSize(B_MINI_ICON);
 			fIconPoseHeight = ceilf(sFontHeight &lt; IconSizeInt() ? IconSizeInt() : sFontHeight + 1);
 			break;
-		
+
 		case kScaleIconMode:
 			// IconSize should allready be set in MessageReceived()
 			fIconPoseHeight = ceilf(IconSizeInt() + sFontHeight + 1);
 			break;
-		
+
 		default:
 			fViewState-&gt;SetIconSize(B_MINI_ICON);
 			fIconPoseHeight = fListElemHeight;
@@ -937,12 +936,12 @@
 			grid-&gt;Set(60, 60);
 			offset-&gt;Set(20, 20);
 			break;
-		
+
 		case kScaleIconMode:
 			grid-&gt;Set(IconSizeInt() + 28, IconSizeInt() + 28);
 			offset-&gt;Set(20, 20);
 			break;
-		
+
 		default:
 			grid-&gt;Set(0, 0);
 			offset-&gt;Set(5, 5);
@@ -1012,7 +1011,7 @@
 {
 	// set up a directory iteration
 	Model sourceModel(ref, false, true);
-	if (sourceModel.InitCheck() != B_OK) 
+	if (sourceModel.InitCheck() != B_OK)
 		return NULL;
 
 	ASSERT(!sourceModel.IsQuery());
@@ -1020,7 +1019,7 @@
 	ASSERT(dynamic_cast&lt;BDirectory *&gt;(sourceModel.Node()));
 
 	EntryListBase *result = new CachedDirectoryEntryList(
-		*dynamic_cast&lt;BDirectory *&gt;(sourceModel.Node()));	
+		*dynamic_cast&lt;BDirectory *&gt;(sourceModel.Node()));
 
 	if (result-&gt;Rewind() != B_OK) {
 		delete result;
@@ -1035,7 +1034,7 @@
 }
 
 
-uint32 
+uint32
 BPoseView::WatchNewNodeMask()
 {
 #ifdef __HAIKU__
@@ -1046,20 +1045,20 @@
 }
 
 
-status_t 
+status_t
 BPoseView::WatchNewNode(const node_ref *item)
 {
 	return WatchNewNode(item, WatchNewNodeMask(), BMessenger(this));
 }
 
 
-status_t 
+status_t
 BPoseView::WatchNewNode(const node_ref *item, uint32 mask, BMessenger messenger)
 {
 	status_t result = TTracker::WatchNode(item, mask, messenger);
 
 #if DEBUG
-	if (result != B_OK) 
+	if (result != B_OK)
 		PRINT((&quot;failed to watch node %s\n&quot;, strerror(result)));
 #endif
 
@@ -1109,7 +1108,7 @@
 			B_DISPLAY_PRIORITY, params);
 
 	if (addPosesThread &gt;= B_OK) {
-		fAddPosesThreads.insert(addPosesThread); 
+		fAddPosesThreads.insert(addPosesThread);
 		resume_thread(addPosesThread);
 	} else
 		delete params;
@@ -1148,7 +1147,7 @@
 			if (!hasLock)
 				hasLock = messenger.LockTarget();
 
-			return hasLock;				
+			return hasLock;
 		}
 
 		bool IsLocked() const
@@ -1258,7 +1257,7 @@
 				// a new model is added to the array; start with modelChunkIndex = -1
 
 			int32 count = container-&gt;GetNextDirents(eptr, 1024, 1);
-			if (count &lt;= 0 &amp;&amp; !modelChunkIndex) 
+			if (count &lt;= 0 &amp;&amp; !modelChunkIndex)
 				break;
 
 			if (count) {
@@ -1302,7 +1301,7 @@
 				throw failToLock();
 			}
 
-			if (count) {		
+			if (count) {
 					// try to watch the model, no matter what
 
 				if (result != B_OK) {
@@ -1324,9 +1323,9 @@
 					delete model;
 					continue;
 				}
-					// ToDo:
-					// we are only watching nodes that are visible and not zombies
-					// EntryCreated watches everything, which is probably more correct
+					// TODO: we are only watching nodes that are visible and
+					// not zombies. EntryCreated watches everything, which is
+					// probably more correct.
 					// clean this up
 
 				modelChunkIndex++;
@@ -1377,17 +1376,17 @@
 	delete container;
 	// build attributes menu based on mime types we've added
 
- 	if (lock.Lock()) { 
-  		view-&gt;AddPosesCompleted(); 
-#ifdef MSIPL_COMPILE_H 
-	// workaround for broken PPC STL, not needed with the SGI headers for x86 
- 		set&lt;thread_id&gt;::iterator i = view-&gt;fAddPosesThreads.find(threadID); 
- 		if (i != view-&gt;fAddPosesThreads.end()) 
- 			view-&gt;fAddPosesThreads.erase(i); 
-#else 
-		view-&gt;fAddPosesThreads.erase(threadID); 
-#endif 
-	} 
+ 	if (lock.Lock()) {
+  		view-&gt;AddPosesCompleted();
+#ifdef MSIPL_COMPILE_H
+	// workaround for broken PPC STL, not needed with the SGI headers for x86
+ 		set&lt;thread_id&gt;::iterator i = view-&gt;fAddPosesThreads.find(threadID);
+ 		if (i != view-&gt;fAddPosesThreads.end())
+ 			view-&gt;fAddPosesThreads.erase(i);
+#else
+		view-&gt;fAddPosesThreads.erase(threadID);
+#endif
+	}
 
 	return B_OK;
 }
@@ -1451,7 +1450,7 @@
 					index++;
 			}
 		}
-	} 
+	}
 
 	SortPoses();
 	UpdateCount();
@@ -1459,7 +1458,7 @@
 }
 
 
-void 
+void
 BPoseView::AddTrashPoses()
 {
 	// the trash window needs to display a union of all the
@@ -1483,7 +1482,7 @@
 }
 
 
-void 
+void
 BPoseView::AddPosesCompleted()
 {
 	BContainerWindow *containerWindow = ContainerWindow();
@@ -1497,7 +1496,7 @@
 
 	HideBarberPole();
 
-	// make sure that the last item in the list is not placed 
+	// make sure that the last item in the list is not placed
 	// above the top of the view (leaving you with an empty window)
 	if (ViewMode() == kListMode) {
 		BRect bounds(Bounds());
@@ -1738,13 +1737,13 @@
 
 	FinishPendingScroll(listViewScrollBy, viewBounds);
 
-	if (lastPoseIndexPtr) 
+	if (lastPoseIndexPtr)
 		*lastPoseIndexPtr = poseIndex;
 }
 
 
 
-bool 
+bool
 BPoseView::PoseVisible(const Model *model, const PoseInfo *poseInfo,
 	bool inFilePanel)
 {
@@ -1802,18 +1801,18 @@
 
 
 void
-BPoseView::RefreshMimeTypeList() 
-{ 
-	fMimeTypeList-&gt;MakeEmpty(); 
+BPoseView::RefreshMimeTypeList()
+{
+	fMimeTypeList-&gt;MakeEmpty();
 	fMimeTypeListIsDirty = false;
 
-	for (int32 index = 0;; index++) { 
-		BPose *pose = PoseAtIndex(index); 
-		if (!pose) 
-			break; 
+	for (int32 index = 0;; index++) {
+		BPose *pose = PoseAtIndex(index);
+		if (!pose)
+			break;
 
-		if (pose-&gt;TargetModel()) 
-			AddMimeType(pose-&gt;TargetModel()-&gt;MimeType()); 
+		if (pose-&gt;TargetModel())
+			AddMimeType(pose-&gt;TargetModel()-&gt;MimeType());
 	}
 }
 
@@ -1823,8 +1822,7 @@
 	BRect *invalidRect)
 {
 	if (orientation == kInsertAfter) {
-		// ToDo:
-		// get rid of this
+		// TODO: get rid of this
 		(*index)++;
 	}
 
@@ -1836,7 +1834,7 @@
 	BRect destRect(srcRect);
 	destRect.OffsetBy(0, fListElemHeight);
 
-	if (srcRect.Intersects(bounds) || destRect.Intersects(bounds)) 
+	if (srcRect.Intersects(bounds) || destRect.Intersects(bounds))
 		CopyBits(srcRect, destRect);
 
 	// this is the invalid rectangle
@@ -1963,14 +1961,14 @@
 			entry_ref ref;
 			message-&gt;FindPointer(&quot;currentPoses&quot;, reinterpret_cast&lt;void **&gt;(&amp;currentPoses));
 			message-&gt;FindRef(&quot;ref&quot;, &amp;ref);
-			
+
 			// check if CreatePoses should be called (abort if dir has been switched
 			// under normal circumstances, ignore in several special cases
 			if (AddPosesThreadValid(&amp;ref)) {
 				CreatePoses(currentPoses-&gt;fModels, currentPoses-&gt;fPoseInfos,
 					currentPoses-&gt;fCount, NULL, true, 0, 0, true);
 				currentPoses-&gt;ReleaseModels();
-			} 
+			}
 			delete currentPoses;
 			break;
 		}
@@ -1985,7 +1983,7 @@
 
 		case B_NODE_MONITOR:
 		case B_QUERY_UPDATE:
-			if (!FSNotification(message)) 
+			if (!FSNotification(message))
 				pendingNodeMonitorCache.Add(message);
 			break;
 
@@ -2157,7 +2155,7 @@
 				break;
 
 			BPose *pose = fSelectionList-&gt;FirstItem();
-			if (pose) { 
+			if (pose) {
 				pose-&gt;EditFirstWidget(BPoint(0,
 						fPoseList-&gt;IndexOf(pose) * fListElemHeight), this);
 			}
@@ -2251,7 +2249,7 @@
 		case 'dbug':
 		{
 			int32 count = fSelectionList-&gt;CountItems();
-			for (int32 index = 0; index &lt; count; index++) 
+			for (int32 index = 0; index &lt; count; index++)
 				fSelectionList-&gt;ItemAt(index)-&gt;PrintToStream();
 
 			break;
@@ -2360,7 +2358,7 @@
 	float offset = columnToRemove-&gt;Offset();
 
 	int32 count = fPoseList-&gt;CountItems();
-	for (int32 index = 0; index &lt; count; index++) 
+	for (int32 index = 0; index &lt; count; index++)
 		fPoseList-&gt;ItemAt(index)-&gt;RemoveWidget(this, columnToRemove);
 	fColumnList-&gt;RemoveItem(columnToRemove, false);
 	fTitleView-&gt;RemoveTitle(columnToRemove);
@@ -2396,7 +2394,7 @@
 
 		if (!anyDateAttributesLeft)
 			StopWatchDateFormatChange();
-	}	
+	}
 
 	fStateNeedsSaving = true;
 
@@ -2404,7 +2402,7 @@
 }
 
 
-bool 
+bool
 BPoseView::AddColumn(BColumn *newColumn, const BColumn *after)
 {
 	if (!after)
@@ -2519,7 +2517,7 @@
 			attrName, attrType, displayAs, isStatfield, isEditable);
 		AddColumn(column);
 		if (item-&gt;Menu()-&gt;Supermenu() == NULL)
-			delete item-&gt;Menu(); 
+			delete item-&gt;Menu();
 	}
 }
 
@@ -2688,7 +2686,7 @@
 		else
 			Window()-&gt;AddChild(fTitleView);
 	}
-	
+
 	CommitActivePose();
 	SetIconPoseHeight();
 	GetLayoutInfo(ViewMode(), &amp;fGrid, &amp;fOffset);
@@ -2746,7 +2744,7 @@
 	}
 
 	// sort poselist if we are switching to list mode
-	if (newMode == kListMode) 
+	if (newMode == kListMode)
 		SortPoses();
 	else
 		RecalcExtent();
@@ -2913,14 +2911,14 @@
 		setPosition = true;
 		location = ConvertFromScreen(location);
 	} else if (ViewMode() != kListMode) {
-		// new folder created by keyboard shortcut			
+		// new folder created by keyboard shortcut
 		uint32 buttons;
 		GetMouse(&amp;location, &amp;buttons);
 		BPoint globalLocation(location);
 		ConvertToScreen(&amp;globalLocation);
 		// check if mouse over window
 		if (Window()-&gt;Frame().Contains(globalLocation))
-			// create folder under mouse				
+			// create folder under mouse
 			setPosition = true;
 	}
 
@@ -2948,15 +2946,15 @@
 
 	entry_ref srcRef;
 	message-&gt;FindRef(&quot;refs_template&quot;, &amp;srcRef);
-	
-	BDirectory dir(&amp;srcRef); 
-	
+
+	BDirectory dir(&amp;srcRef);
+
 	if (dir.InitCheck() == B_OK) {
 		// special handling of directories
 		if (FSCreateNewFolderIn(TargetModel()-&gt;NodeRef(), &amp;destEntryRef, &amp;destNodeRef) == B_OK) {
 			BEntry destEntry(&amp;destEntryRef);
 			destEntry.Rename(fileName);
-		}	
+		}
 	} else {
 		BFile srcFile(&amp;srcRef, B_READ_ONLY);
 		BFile destFile(&amp;destDir, fileName, B_READ_WRITE | B_CREATE_FILE);
@@ -2994,7 +2992,7 @@
 	BPose *pose = EntryCreated(TargetModel()-&gt;NodeRef(), &amp;destNodeRef,
 		destEntryRef.name, &amp;index);
 
-	if (pose) {					
+	if (pose) {
 		UpdateScrollRange();
 		CommitActivePose();
 		SelectPose(pose, index);
@@ -3018,7 +3016,7 @@
 
 		int32 index;
 		BPose *pose = EntryCreated(TargetModel()-&gt;NodeRef(), &amp;nodeRef, ref.name, &amp;index);
-		if (pose) {					
+		if (pose) {
 			UpdateScrollRange();
 			CommitActivePose();
 			SelectPose(pose, index);
@@ -3033,7 +3031,7 @@
 {
 	if (ViewMode() == kListMode)
 		return;
-	
+
 	BContainerWindow *window = ContainerWindow();
 	if (!window)
 		return;
@@ -3205,18 +3203,18 @@
 		ASSERT(newFrame);
 		deskFrame = *newFrame;
 	}
-	
+
 	ASSERT(ViewMode() != kListMode);
-	
+
 	BRect bounds(Bounds());
 	bounds.InsetBy(20, 20);
-	
+
 	int32 count = fPoseList-&gt;CountItems();
 	for (int32 index = 0; index &lt; count; index++) {
 		BPose *pose = fPoseList-&gt;ItemAt(index);
 		BPoint newLocation(pose-&gt;Location());
 		bool locationNeedsUpdating = false;
-		
+
 		if (desktop) {
 			// we just switched screen resolution, pick up the right
 			// icon locations for the new resolution
@@ -3236,10 +3234,9 @@
 				}
 			}
 			delete [] (char *)info;
-				// ToDo:
-				// fix up this mess
+				// TODO: fix up this mess
 		}
-				
+
 		BRect rect(pose-&gt;CalcRect(this));
 		if (!rect.Intersects(bounds)) {
 			// pose doesn't fit on screen
@@ -3283,18 +3280,18 @@
 		if (fHintLocation.x != point.x)
 			return true;
 	}
-	
+
 	// search only nearby poses (vertically)
 	int32 index = FirstIndexAtOrBelow((int32)(poseRect.top - IconPoseHeight()));
 	int32 numPoses = fVSPoseList-&gt;CountItems();
 
 	while (index &lt; numPoses &amp;&amp; fVSPoseList-&gt;ItemAt(index)-&gt;Location().y
 		&lt; poseRect.bottom) {
-		
+
 		BRect rect(fVSPoseList-&gt;ItemAt(index)-&gt;CalcRect(this));
 		if (poseRect.Intersects(rect))
 			return true;
-		
+
 		index++;
 	}
 
@@ -3305,7 +3302,7 @@
 void
 BPoseView::NextSlot(BPose *pose, BRect &amp;poseRect, BRect viewBounds)
 {
-	// move to next slot 
+	// move to next slot
 	poseRect.OffsetBy(fGrid.x, 0);
 
 	// if we reached the end of row go down to next row
@@ -3382,7 +3379,7 @@
 		ASSERT(matchingPose);
 		if (!matchingPose)
 			return -1;
-	
+
 		if (pose == matchingPose) {
 			fVSPoseList-&gt;RemoveItemAt(index);
 			return index;
@@ -3433,7 +3430,7 @@
 	fMimeTypesInSelectionCache.MakeEmpty();
 	fSelectionPivotPose = NULL;
 	fRealPivotPose = NULL;
-	
+
 	bool iconMode = ViewMode() != kListMode;
 	BPoint loc(0, start * fListElemHeight);
 	BRect bounds(Bounds());
@@ -3481,7 +3478,7 @@
 			testRect.left = 0;
 			testRect.right = testRect.left + 1;
 		}
-		if (!Bounds().Contains(testRect)) 
+		if (!Bounds().Contains(testRect))
 			SetScrollBarsTo(testRect.LeftTop());
 	}
 
@@ -3503,14 +3500,13 @@
 void
 BPoseView::AddPoseToSelection(BPose *pose, int32 index, bool scrollIntoView)
 {
-	// ToDo:
-	// need to check if pose is member of selection list
+	// TODO: need to check if pose is member of selection list
 	if (pose &amp;&amp; !pose-&gt;IsSelected()) {
 		pose-&gt;Select(true);
 		fSelectionList-&gt;AddItem(pose);
 
 		ScrollIntoView(pose, index, !scrollIntoView);
-	
+
 		if (fSelectionChangedHook)
 			ContainerWindow()-&gt;SelectionChanged();
 	}
@@ -3524,16 +3520,15 @@
 		fSelectionPivotPose = NULL;
 	if (fRealPivotPose == pose)
 		fRealPivotPose = NULL;
-	
+
 	if (!fSelectionList-&gt;RemoveItem(pose))
 		// wasn't selected to begin with
 		return;
-		
+
 	pose-&gt;Select(false);
 	if (ViewMode() == kListMode) {
-		// ToDo:
-		// need a simple call to CalcRect that works both in listView and icon view modes
-		// without the need for an index/pos
+		// TODO: need a simple call to CalcRect that works both in listView and
+		// icon view modes without the need for an index/pos
 		int32 count = fPoseList-&gt;CountItems();
 		BPoint loc(0, 0);
 		for (int32 index = 0; index &lt; count; index++) {
@@ -3564,7 +3559,7 @@
 
 	PoseList *selectionList = srcWindow-&gt;PoseView()-&gt;SelectionList();
 	int32 count = selectionList-&gt;CountItems();
-	
+
 	for (int32 index = 0; index &lt; count; index++) {
 		BPose *pose = selectionList-&gt;ItemAt(index);
 		if (func(pose, poseView, passThru))
@@ -3597,14 +3592,14 @@
 	for (int32 index = 0;
 			dragMessage-&gt;FindInt32(&quot;be:actions&quot;, index, &amp;action) == B_OK; index++) {
 		switch (action) {
-			case B_MOVE_TARGET: 
+			case B_MOVE_TARGET:
 				canMove = true;
 				break;
-				
+
 			case B_COPY_TARGET:
 				canCopy = true;
-				break;	
-		
+				break;
+
 			case B_TRASH_TARGET:
 				canErase = true;
 				break;
@@ -3639,7 +3634,7 @@
 		const char *type;
 		if (dragMessage-&gt;FindString(&quot;be:types&quot;, index, &amp;type) != B_OK)
 			break;
-		
+
 		if (strcasecmp(type, B_FILE_MIME_TYPE) == 0)
 			return true;
 	}
@@ -3668,16 +3663,15 @@
 		FindDragNDropAction(dragMessage, canCopy, canMove, canLink, canErase);
 		if (canErase &amp;&amp; CanTrashForeignDrag(target))
 			return true;
-	
+
 		if (canCopy || canMove) {
 			if (CanCopyOrMoveForeignDrag(target, dragMessage))
 				return true;
-			
-			// ToDo:
-			// collect all mime types here and pass into
+
+			// TODO: collect all mime types here and pass into
 			// target-&gt;IsDropTargetForList(mimeTypeList);
 		}
-		
+
 		// handle an old style entry_refs only darg message
 		if (dragMessage-&gt;HasRef(&quot;refs&quot;) &amp;&amp; target-&gt;IsDirectory())
 			return true;
@@ -3693,12 +3687,11 @@
 				|| dragMessage-&gt;HasData(kMiniIconType, B_MESSAGE_TYPE)))
 			return true;
 
-		// ToDo:
-		// check for a drag message full of refs, feed a list of their types to
-		// target-&gt;IsDropTargetForList(mimeTypeList);
+		// TODO: check for a drag message full of refs, feed a list of their
+		// types to target-&gt;IsDropTargetForList(mimeTypeList);
 		return false;
 	}
-	
+
 	AutoLock&lt;BWindow&gt; lock(srcWindow);
 	if (!lock)
 		return false;
@@ -3708,7 +3701,7 @@
 		if (!selectionList-&gt;IsEmpty()) {
 			// no cached data yet, build the cache
 			int32 count = selectionList-&gt;CountItems();
-			
+
 			for (int32 index = 0; index &lt; count; index++) {
 				// get the mime type of the model, following a possible symlink
 				BEntry entry(selectionList-&gt;ItemAt(index)-&gt;TargetModel()-&gt;EntryRef(), true);
@@ -3717,21 +3710,21 @@
 
  				BFile file(&amp;entry, O_RDONLY);
 				BNodeInfo mime(&amp;file);
-				
+
 				if (mime.InitCheck() != B_OK)
 					continue;
-				
+
 				char mimeType[B_MIME_TYPE_LENGTH];
 				mime.GetType(mimeType);
-								
+
 				// add unique type string
 				if (!WhileEachListItem(mimeTypeList, ContainsOne, (const char *)mimeType)) {
 					BString *newMimeString = new BString(mimeType);
 					mimeTypeList-&gt;AddItem(newMimeString);
 				}
 			}
-		}	
-	}	
+		}
+	}
 
 	return target-&gt;IsDropTargetForList(mimeTypeList);
 }
@@ -3761,13 +3754,13 @@
 	// build a file name
 	// try picking it up from the message
 	const char *suggestedName;
-	if (message &amp;&amp; message-&gt;FindString(&quot;be:clip_name&quot;, &amp;suggestedName) == B_OK) 
+	if (message &amp;&amp; message-&gt;FindString(&quot;be:clip_name&quot;, &amp;suggestedName) == B_OK)
 		strncpy(resultingName, suggestedName, B_FILE_NAME_LENGTH - 1);
 	else
 		strcpy(resultingName, fallbackName);
-	
+
 	FSMakeOriginalName(resultingName, dir, &quot;&quot;);
-	
+
 	// create a clipping file
 	status_t error = dir-&gt;CreateFile(resultingName, &amp;result, true);
 	if (error != B_OK)
@@ -3785,18 +3778,18 @@
 	const BObjectList&lt;BString&gt; *specificItems, BPoint where)
 {
 	int32 count;
-	
+
 	if (types)
 		count = types-&gt;CountItems();
 	else
 		count = specificItems-&gt;CountItems();
-		
+
 	if (!count)
 		return 0;
 
 	BPopUpMenu *menu = new BPopUpMenu(&quot;create clipping&quot;);
 	menu-&gt;SetFont(be_plain_font);
-	
+
 	for (int32 index = 0; index &lt; count; index++) {
 
 		const char *embedTypeAs = NULL;
@@ -3804,7 +3797,7 @@
 		if (types) {
 			types-&gt;ItemAt(index)-&gt;String();
 			BMimeType mimeType(embedTypeAs);
-			
+
 			if (mimeType.GetShortDescription(buffer) == B_OK)
 				embedTypeAs = buffer;
 		}
@@ -3812,13 +3805,13 @@
 		BString description;
 		if (specificItems-&gt;ItemAt(index)-&gt;Length()) {
 			description &lt;&lt; (const BString &amp;)(*specificItems-&gt;ItemAt(index));
-			
+
 			if (embedTypeAs)
 				description &lt;&lt; &quot; (&quot; &lt;&lt; embedTypeAs &lt;&lt; &quot;)&quot;;
 
 		} else if (types)
 			description = embedTypeAs;
-		
+
 		const char *labelText;
 		char text[1024];
 		if (actionText) {
@@ -3834,10 +3827,10 @@
 
 		menu-&gt;AddItem(new BMenuItem(labelText, 0));
 	}
-	
+
 	menu-&gt;AddSeparatorItem();
 	menu-&gt;AddItem(new BMenuItem(&quot;Cancel&quot;, 0));
-	
+
 	int32 result = -1;
 	BMenuItem *resultingItem = menu-&gt;Go(where, false, true);
 	if (resultingItem) {
@@ -3847,7 +3840,7 @@
 	}
 
 	delete menu;
-	
+
 	return result;
 }
 
@@ -3919,9 +3912,9 @@
 			targetModel = poseView-&gt;TargetModel();
 
 		// figure out if we dropped a file onto a directory and set the targetDirectory
-		// to it, else set it to this pose view	
+		// to it, else set it to this pose view
 		BDirectory targetDirectory;
-		if (targetModel &amp;&amp; targetModel-&gt;IsDirectory()) 
+		if (targetModel &amp;&amp; targetModel-&gt;IsDirectory())
 			targetDirectory.SetTo(targetModel-&gt;EntryRef());
 
 		if (targetModel-&gt;IsRoot())
@@ -3940,7 +3933,7 @@
 				message-&gt;SendReply(&amp;reply);
 				return true;
 			}
-			
+
 			if ((canCopy || canMove)
 				&amp;&amp; CanCopyOrMoveForeignDrag(targetModel, message)) {
 				// handle the promise style drag&amp;drop
@@ -3951,7 +3944,7 @@
 					const char *string;

[... truncated: 1560 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009187.html">[Haiku-commits] r25717 - haiku/trunk/src/system/kernel/vm
</A></li>
	<LI>Next message: <A HREF="009190.html">[Haiku-commits] r25719 - haiku/trunk/src/kits/tracker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9189">[ date ]</a>
              <a href="thread.html#9189">[ thread ]</a>
              <a href="subject.html#9189">[ subject ]</a>
              <a href="author.html#9189">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
