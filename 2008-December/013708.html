<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28771 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . ar81xx	ar81xx/dev ar81xx/dev/ale ar81xx/dev/mii
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28771%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20ar81xx%0A%09ar81xx/dev%20ar81xx/dev/ale%20ar81xx/dev/mii&In-Reply-To=%3C200812032010.mB3KApr9023911%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013707.html">
   <LINK REL="Next"  HREF="013709.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28771 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . ar81xx	ar81xx/dev ar81xx/dev/ale ar81xx/dev/mii</H1>
    <B>colacoder at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28771%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20ar81xx%0A%09ar81xx/dev%20ar81xx/dev/ale%20ar81xx/dev/mii&In-Reply-To=%3C200812032010.mB3KApr9023911%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28771 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . ar81xx	ar81xx/dev ar81xx/dev/ale ar81xx/dev/mii">colacoder at mail.berlios.de
       </A><BR>
    <I>Wed Dec  3 21:10:51 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="013707.html">[Haiku-commits] r28770 - in	haiku/trunk/src/libs/compat/freebsd_network/compat: machine net sys
</A></li>
        <LI>Next message: <A HREF="013709.html">[Haiku-commits] r28771 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . ar81xx	ar81xx/dev ar81xx/dev/ale ar81xx/dev/mii
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13708">[ date ]</a>
              <a href="thread.html#13708">[ thread ]</a>
              <a href="subject.html#13708">[ subject ]</a>
              <a href="author.html#13708">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: colacoder
Date: 2008-12-03 21:10:48 +0100 (Wed, 03 Dec 2008)
New Revision: 28771
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28771&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28771&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_ale.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_alereg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_alevar.h
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/mii/
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/mii/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/mii/ukphy_subr.c
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
Log:
Add network driver for Atheros AR8121/AR8113/AR8114 controllers to the build. These are used in the EeePC 901 and later.


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2008-12-03 20:10:48 UTC (rev 28771)
@@ -24,6 +24,7 @@
 SubInclude HAIKU_TOP src add-ons kernel drivers network pcnet ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network syskonnect ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network attansic_l2 ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network ar81xx ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network rtl81xx ;
 
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm440x ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/Jamfile	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/Jamfile	2008-12-03 20:10:48 UTC (rev 28771)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network ar81xx ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network ar81xx dev ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/Jamfile	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/Jamfile	2008-12-03 20:10:48 UTC (rev 28771)
@@ -0,0 +1,5 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network ar81xx dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network ar81xx dev mii ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network  ar81xx dev ale ;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/Jamfile	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/Jamfile	2008-12-03 20:10:48 UTC (rev 28771)
@@ -0,0 +1,14 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network ar81xx dev ale ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 ] ;
+
+KernelAddon ar81xx :
+	if_ale.c
+	glue.c
+	: libfreebsd_network.a ar81xx_mii.a
+	;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/glue.c	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/glue.c	2008-12-03 20:10:48 UTC (rev 28771)
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2007, Hugo Santos. All Rights Reserved.
+ * Copyright 2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include &lt;sys/bus.h&gt;
+
+
+HAIKU_FBSD_DRIVER_GLUE(ar81xx, ale, pci)
+
+extern driver_t *DRIVER_MODULE_NAME(ukphy, miibus);
+
+driver_t *
+__haiku_select_miibus_driver(device_t dev)
+{
+	driver_t *drivers[] = {
+		DRIVER_MODULE_NAME(ukphy, miibus),
+		NULL
+	};
+
+	return __haiku_probe_miibus(dev, drivers);
+}
+
+NO_HAIKU_CHECK_DISABLE_INTERRUPTS();
+NO_HAIKU_REENABLE_INTERRUPTS();
+
+HAIKU_DRIVER_REQUIREMENTS(FBSD_TASKQUEUES | FBSD_FAST_TASKQUEUE | FBSD_SWI_TASKQUEUE);

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_ale.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_ale.c	2008-12-03 20:05:20 UTC (rev 28770)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ar81xx/dev/ale/if_ale.c	2008-12-03 20:10:48 UTC (rev 28771)
@@ -0,0 +1,3112 @@
+/*-
+ * Copyright (c) 2008, Pyun YongHyeon &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">yongari at FreeBSD.org</A>&gt;
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* Driver for Atheros AR8121/AR8113/AR8114 PCIe Ethernet. */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/ale/if_ale.c,v 1.3 2008/12/03 09:01:12 yongari Exp $&quot;);
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/bus.h&gt;
+#include &lt;sys/endian.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/malloc.h&gt;
+#include &lt;sys/mbuf.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/rman.h&gt;
+#include &lt;sys/queue.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/sockio.h&gt;
+#include &lt;sys/sysctl.h&gt;
+#include &lt;sys/taskqueue.h&gt;
+
+#include &lt;net/bpf.h&gt;
+#include &lt;net/if.h&gt;
+#include &lt;net/if_arp.h&gt;
+#include &lt;net/ethernet.h&gt;
+#include &lt;net/if_dl.h&gt;
+#include &lt;net/if_llc.h&gt;
+#include &lt;net/if_media.h&gt;
+#include &lt;net/if_types.h&gt;
+#include &lt;net/if_vlan_var.h&gt;
+
+#include &lt;netinet/in.h&gt;
+#include &lt;netinet/in_systm.h&gt;
+#include &lt;netinet/ip.h&gt;
+#include &lt;netinet/tcp.h&gt;
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+
+#include &lt;dev/pci/pcireg.h&gt;
+#include &lt;dev/pci/pcivar.h&gt;
+
+#include &lt;machine/atomic.h&gt;
+#include &lt;machine/bus.h&gt;
+#include &lt;machine/in_cksum.h&gt;
+
+#include &lt;dev/ale/if_alereg.h&gt;
+#include &lt;dev/ale/if_alevar.h&gt;
+
+/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */
+#include &quot;miibus_if.h&quot;
+
+/* For more information about Tx checksum offload issues see ale_encap(). */
+#define	ALE_CSUM_FEATURES	(CSUM_TCP | CSUM_UDP)
+#ifndef	IFCAP_VLAN_HWTSO
+#define	IFCAP_VLAN_HWTSO	0
+#endif
+
+MODULE_DEPEND(ale, pci, 1, 1, 1);
+MODULE_DEPEND(ale, ether, 1, 1, 1);
+MODULE_DEPEND(ale, miibus, 1, 1, 1);
+
+/* Tunables. */
+static int msi_disable = 0;
+static int msix_disable = 0;
+TUNABLE_INT(&quot;hw.ale.msi_disable&quot;, &amp;msi_disable);
+TUNABLE_INT(&quot;hw.ale.msix_disable&quot;, &amp;msix_disable);
+
+/*
+ * Devices supported by this driver.
+ */
+static struct ale_dev {
+	uint16_t	ale_vendorid;
+	uint16_t	ale_deviceid;
+	const char	*ale_name;
+} ale_devs[] = {
+    { VENDORID_ATHEROS, DEVICEID_ATHEROS_AR81XX,
+    &quot;Atheros AR8121/AR8113/AR8114 PCIe Ethernet&quot; },
+};
+
+static int	ale_attach(device_t);
+static int	ale_check_boundary(struct ale_softc *);
+static int	ale_detach(device_t);
+static int	ale_dma_alloc(struct ale_softc *);
+static void	ale_dma_free(struct ale_softc *);
+static void	ale_dmamap_cb(void *, bus_dma_segment_t *, int, int);
+static int	ale_encap(struct ale_softc *, struct mbuf **);
+static void	ale_get_macaddr(struct ale_softc *);
+static void	ale_init(void *);
+static void	ale_init_locked(struct ale_softc *);
+static void	ale_init_rx_pages(struct ale_softc *);
+static void	ale_init_tx_ring(struct ale_softc *);
+static void	ale_int_task(void *, int);
+static int	ale_intr(void *);
+static int	ale_ioctl(struct ifnet *, u_long, caddr_t);
+static void	ale_link_task(void *, int);
+static void	ale_mac_config(struct ale_softc *);
+static int	ale_miibus_readreg(device_t, int, int);
+static void	ale_miibus_statchg(device_t);
+static int	ale_miibus_writereg(device_t, int, int, int);
+static int	ale_mediachange(struct ifnet *);
+static void	ale_mediastatus(struct ifnet *, struct ifmediareq *);
+static void	ale_phy_reset(struct ale_softc *);
+static int	ale_probe(device_t);
+static void	ale_reset(struct ale_softc *);
+static int	ale_resume(device_t);
+static void	ale_rx_update_page(struct ale_softc *, struct ale_rx_page **,
+    uint32_t, uint32_t *);
+static void	ale_rxcsum(struct ale_softc *, struct mbuf *, uint32_t);
+static int	ale_rxeof(struct ale_softc *sc, int);
+static void	ale_rxfilter(struct ale_softc *);
+static void	ale_rxvlan(struct ale_softc *);
+static void	ale_setlinkspeed(struct ale_softc *);
+static void	ale_setwol(struct ale_softc *);
+static int	ale_shutdown(device_t);
+static void	ale_start(struct ifnet *);
+static void	ale_stats_clear(struct ale_softc *);
+static void	ale_stats_update(struct ale_softc *);
+static void	ale_stop(struct ale_softc *);
+static void	ale_stop_mac(struct ale_softc *);
+static int	ale_suspend(device_t);
+static void	ale_sysctl_node(struct ale_softc *);
+static void	ale_tick(void *);
+static void	ale_tx_task(void *, int);
+static void	ale_txeof(struct ale_softc *);
+static void	ale_watchdog(struct ale_softc *);
+static int	sysctl_int_range(SYSCTL_HANDLER_ARGS, int, int);
+static int	sysctl_hw_ale_proc_limit(SYSCTL_HANDLER_ARGS);
+static int	sysctl_hw_ale_int_mod(SYSCTL_HANDLER_ARGS);
+
+static device_method_t ale_methods[] = {
+	/* Device interface. */
+	DEVMETHOD(device_probe,		ale_probe),
+	DEVMETHOD(device_attach,	ale_attach),
+	DEVMETHOD(device_detach,	ale_detach),
+	DEVMETHOD(device_shutdown,	ale_shutdown),
+	DEVMETHOD(device_suspend,	ale_suspend),
+	DEVMETHOD(device_resume,	ale_resume),
+
+	/* MII interface. */
+	DEVMETHOD(miibus_readreg,	ale_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	ale_miibus_writereg),
+	DEVMETHOD(miibus_statchg,	ale_miibus_statchg),
+
+	{ NULL, NULL }
+};
+
+static driver_t ale_driver = {
+	&quot;ale&quot;,
+	ale_methods,
+	sizeof(struct ale_softc)
+};
+
+static devclass_t ale_devclass;
+
+DRIVER_MODULE(ale, pci, ale_driver, ale_devclass, 0, 0);
+DRIVER_MODULE(miibus, ale, miibus_driver, miibus_devclass, 0, 0);
+
+static struct resource_spec ale_res_spec_mem[] = {
+	{ SYS_RES_MEMORY,	PCIR_BAR(0),	RF_ACTIVE },
+	{ -1,			0,		0 }
+};
+
+static struct resource_spec ale_irq_spec_legacy[] = {
+	{ SYS_RES_IRQ,		0,		RF_ACTIVE | RF_SHAREABLE },
+	{ -1,			0,		0 }
+};
+
+static struct resource_spec ale_irq_spec_msi[] = {
+	{ SYS_RES_IRQ,		1,		RF_ACTIVE },
+	{ -1,			0,		0 }
+};
+
+static struct resource_spec ale_irq_spec_msix[] = {
+	{ SYS_RES_IRQ,		1,		RF_ACTIVE },
+	{ -1,			0,		0 }
+};
+
+static int
+ale_miibus_readreg(device_t dev, int phy, int reg)
+{
+	struct ale_softc *sc;
+	uint32_t v;
+	int i;
+
+	sc = device_get_softc(dev);
+
+	if (phy != sc-&gt;ale_phyaddr)
+		return (0);
+
+	CSR_WRITE_4(sc, ALE_MDIO, MDIO_OP_EXECUTE | MDIO_OP_READ |
+	    MDIO_SUP_PREAMBLE | MDIO_CLK_25_4 | MDIO_REG_ADDR(reg));
+	for (i = ALE_PHY_TIMEOUT; i &gt; 0; i--) {
+		DELAY(5);
+		v = CSR_READ_4(sc, ALE_MDIO);
+		if ((v &amp; (MDIO_OP_EXECUTE | MDIO_OP_BUSY)) == 0)
+			break;
+	}
+
+	if (i == 0) {
+		device_printf(sc-&gt;ale_dev, &quot;phy read timeout : %d\n&quot;, reg);
+		return (0);
+	}
+
+	return ((v &amp; MDIO_DATA_MASK) &gt;&gt; MDIO_DATA_SHIFT);
+}
+
+static int
+ale_miibus_writereg(device_t dev, int phy, int reg, int val)
+{
+	struct ale_softc *sc;
+	uint32_t v;
+	int i;
+
+	sc = device_get_softc(dev);
+
+	if (phy != sc-&gt;ale_phyaddr)
+		return (0);
+
+	CSR_WRITE_4(sc, ALE_MDIO, MDIO_OP_EXECUTE | MDIO_OP_WRITE |
+	    (val &amp; MDIO_DATA_MASK) &lt;&lt; MDIO_DATA_SHIFT |
+	    MDIO_SUP_PREAMBLE | MDIO_CLK_25_4 | MDIO_REG_ADDR(reg));
+	for (i = ALE_PHY_TIMEOUT; i &gt; 0; i--) {
+		DELAY(5);
+		v = CSR_READ_4(sc, ALE_MDIO);
+		if ((v &amp; (MDIO_OP_EXECUTE | MDIO_OP_BUSY)) == 0)
+			break;
+	}
+
+	if (i == 0)
+		device_printf(sc-&gt;ale_dev, &quot;phy write timeout : %d\n&quot;, reg);
+
+	return (0);
+}
+
+static void
+ale_miibus_statchg(device_t dev)
+{
+	struct ale_softc *sc;
+
+	sc = device_get_softc(dev);
+
+	taskqueue_enqueue(taskqueue_swi, &amp;sc-&gt;ale_link_task);
+}
+
+static void
+ale_mediastatus(struct ifnet *ifp, struct ifmediareq *ifmr)
+{
+	struct ale_softc *sc;
+	struct mii_data *mii;
+
+	sc = ifp-&gt;if_softc;
+	ALE_LOCK(sc);
+	mii = device_get_softc(sc-&gt;ale_miibus);
+
+	mii_pollstat(mii);
+	ALE_UNLOCK(sc);
+	ifmr-&gt;ifm_status = mii-&gt;mii_media_status;
+	ifmr-&gt;ifm_active = mii-&gt;mii_media_active;
+}
+
+static int
+ale_mediachange(struct ifnet *ifp)
+{
+	struct ale_softc *sc;
+	struct mii_data *mii;
+	struct mii_softc *miisc;
+	int error;
+
+	sc = ifp-&gt;if_softc;
+	ALE_LOCK(sc);
+	mii = device_get_softc(sc-&gt;ale_miibus);
+	if (mii-&gt;mii_instance != 0) {
+		LIST_FOREACH(miisc, &amp;mii-&gt;mii_phys, mii_list)
+			mii_phy_reset(miisc);
+	}
+	error = mii_mediachg(mii);
+	ALE_UNLOCK(sc);
+
+	return (error);
+}
+
+static int
+ale_probe(device_t dev)
+{
+	struct ale_dev *sp;
+	int i;
+	uint16_t vendor, devid;
+
+	vendor = pci_get_vendor(dev);
+	devid = pci_get_device(dev);
+	sp = ale_devs;
+	for (i = 0; i &lt; sizeof(ale_devs) / sizeof(ale_devs[0]); i++) {
+		if (vendor == sp-&gt;ale_vendorid &amp;&amp;
+		    devid == sp-&gt;ale_deviceid) {
+			device_set_desc(dev, sp-&gt;ale_name);
+			return (BUS_PROBE_DEFAULT);
+		}
+		sp++;
+	}
+
+	return (ENXIO);
+}
+
+static void
+ale_get_macaddr(struct ale_softc *sc)
+{
+	uint32_t ea[2], reg;
+	int i, vpdc;
+
+	reg = CSR_READ_4(sc, ALE_SPI_CTRL);
+	if ((reg &amp; SPI_VPD_ENB) != 0) {
+		reg &amp;= ~SPI_VPD_ENB;
+		CSR_WRITE_4(sc, ALE_SPI_CTRL, reg);
+	}
+
+	if (pci_find_extcap(sc-&gt;ale_dev, PCIY_VPD, &amp;vpdc) == 0) {
+		/*
+		 * PCI VPD capability found, let TWSI reload EEPROM.
+		 * This will set ethernet address of controller.
+		 */
+		CSR_WRITE_4(sc, ALE_TWSI_CTRL, CSR_READ_4(sc, ALE_TWSI_CTRL) |
+		    TWSI_CTRL_SW_LD_START);
+		for (i = 100; i &gt; 0; i--) {
+			DELAY(1000);
+			reg = CSR_READ_4(sc, ALE_TWSI_CTRL);
+			if ((reg &amp; TWSI_CTRL_SW_LD_START) == 0)
+				break;
+		}
+		if (i == 0)
+			device_printf(sc-&gt;ale_dev,
+			    &quot;reloading EEPROM timeout!\n&quot;);
+	} else {
+		if (bootverbose)
+			device_printf(sc-&gt;ale_dev,
+			    &quot;PCI VPD capability not found!\n&quot;);
+	}
+
+	ea[0] = CSR_READ_4(sc, ALE_PAR0);
+	ea[1] = CSR_READ_4(sc, ALE_PAR1);
+	sc-&gt;ale_eaddr[0] = (ea[1] &gt;&gt; 8) &amp; 0xFF;
+	sc-&gt;ale_eaddr[1] = (ea[1] &gt;&gt; 0) &amp; 0xFF;
+	sc-&gt;ale_eaddr[2] = (ea[0] &gt;&gt; 24) &amp; 0xFF;
+	sc-&gt;ale_eaddr[3] = (ea[0] &gt;&gt; 16) &amp; 0xFF;
+	sc-&gt;ale_eaddr[4] = (ea[0] &gt;&gt; 8) &amp; 0xFF;
+	sc-&gt;ale_eaddr[5] = (ea[0] &gt;&gt; 0) &amp; 0xFF;
+}
+
+static void
+ale_phy_reset(struct ale_softc *sc)
+{
+
+	/* Reset magic from Linux. */
+	CSR_WRITE_2(sc, ALE_GPHY_CTRL,
+	    GPHY_CTRL_HIB_EN | GPHY_CTRL_HIB_PULSE | GPHY_CTRL_SEL_ANA_RESET |
+	    GPHY_CTRL_PHY_PLL_ON);
+	DELAY(1000);
+	CSR_WRITE_2(sc, ALE_GPHY_CTRL,
+	    GPHY_CTRL_EXT_RESET | GPHY_CTRL_HIB_EN | GPHY_CTRL_HIB_PULSE |
+	    GPHY_CTRL_SEL_ANA_RESET | GPHY_CTRL_PHY_PLL_ON);
+	DELAY(1000);
+
+#define	ATPHY_DBG_ADDR		0x1D
+#define	ATPHY_DBG_DATA		0x1E
+
+	/* Enable hibernation mode. */
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x0B);
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_DATA, 0xBC00);
+	/* Set Class A/B for all modes. */
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x00);
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_DATA, 0x02EF);
+	/* Enable 10BT power saving. */
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x12);
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_DATA, 0x4C04);
+	/* Adjust 1000T power. */
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x04);
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x8BBB);
+	/* 10BT center tap voltage. */
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x05);
+	ale_miibus_writereg(sc-&gt;ale_dev, sc-&gt;ale_phyaddr,
+	    ATPHY_DBG_ADDR, 0x2C46);
+
+#undef	ATPHY_DBG_ADDR
+#undef	ATPHY_DBG_DATA
+	DELAY(1000);
+}
+
+static int
+ale_attach(device_t dev)
+{
+	struct ale_softc *sc;
+	struct ifnet *ifp;
+	uint16_t burst;
+	int error, i, msic, msixc, pmc;
+	uint32_t rxf_len, txf_len;
+
+	error = 0;
+	sc = device_get_softc(dev);
+	sc-&gt;ale_dev = dev;
+
+	mtx_init(&amp;sc-&gt;ale_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,
+	    MTX_DEF);
+	callout_init_mtx(&amp;sc-&gt;ale_tick_ch, &amp;sc-&gt;ale_mtx, 0);
+	TASK_INIT(&amp;sc-&gt;ale_int_task, 0, ale_int_task, sc);
+	TASK_INIT(&amp;sc-&gt;ale_link_task, 0, ale_link_task, sc);
+
+	/* Map the device. */
+	pci_enable_busmaster(dev);
+	sc-&gt;ale_res_spec = ale_res_spec_mem;
+	sc-&gt;ale_irq_spec = ale_irq_spec_legacy;
+	error = bus_alloc_resources(dev, sc-&gt;ale_res_spec, sc-&gt;ale_res);
+	if (error != 0) {
+		device_printf(dev, &quot;cannot allocate memory resources.\n&quot;);
+		goto fail;
+	}
+
+	/* Set PHY address. */
+	sc-&gt;ale_phyaddr = ALE_PHY_ADDR;
+
+	/* Reset PHY. */
+	ale_phy_reset(sc);
+
+	/* Reset the ethernet controller. */
+	ale_reset(sc);
+
+	/* Get PCI and chip id/revision. */
+	sc-&gt;ale_rev = pci_get_revid(dev);
+	if (sc-&gt;ale_rev &gt;= 0xF0) {
+		/* L2E Rev. B. AR8114 */
+		sc-&gt;ale_flags |= ALE_FLAG_FASTETHER;
+	} else {
+		if ((CSR_READ_4(sc, ALE_PHY_STATUS) &amp; PHY_STATUS_100M) != 0) {
+			/* L1E AR8121 */
+			sc-&gt;ale_flags |= ALE_FLAG_JUMBO;
+		} else {
+			/* L2E Rev. A. AR8113 */
+			sc-&gt;ale_flags |= ALE_FLAG_FASTETHER;
+		}
+	}
+	/*
+	 * All known controllers seems to require 4 bytes alignment
+	 * of Tx buffers to make Tx checksum offload with custom
+	 * checksum generation method work.
+	 */
+	sc-&gt;ale_flags |= ALE_FLAG_TXCSUM_BUG;
+	/*
+	 * All known controllers seems to have issues on Rx checksum
+	 * offload for fragmented IP datagrams.
+	 */
+	sc-&gt;ale_flags |= ALE_FLAG_RXCSUM_BUG;
+	/*
+	 * Don't use Tx CMB. It is known to cause RRS update failure
+	 * under certain circumstances. Typical phenomenon of the
+	 * issue would be unexpected sequence number encountered in
+	 * Rx handler.
+	 */
+	sc-&gt;ale_flags |= ALE_FLAG_TXCMB_BUG;
+	sc-&gt;ale_chip_rev = CSR_READ_4(sc, ALE_MASTER_CFG) &gt;&gt;
+	    MASTER_CHIP_REV_SHIFT;
+	if (bootverbose) {
+		device_printf(dev, &quot;PCI device revision : 0x%04x\n&quot;,
+		    sc-&gt;ale_rev);
+		device_printf(dev, &quot;Chip id/revision : 0x%04x\n&quot;,
+		    sc-&gt;ale_chip_rev);
+	}
+	txf_len = CSR_READ_4(sc, ALE_SRAM_TX_FIFO_LEN);
+	rxf_len = CSR_READ_4(sc, ALE_SRAM_RX_FIFO_LEN);
+	/*
+	 * Uninitialized hardware returns an invalid chip id/revision
+	 * as well as 0xFFFFFFFF for Tx/Rx fifo length.
+	 */
+	if (sc-&gt;ale_chip_rev == 0xFFFF || txf_len == 0xFFFFFFFF ||
+	    rxf_len == 0xFFFFFFF) {
+		device_printf(dev,&quot;chip revision : 0x%04x, %u Tx FIFO &quot;
+		    &quot;%u Rx FIFO -- not initialized?\n&quot;, sc-&gt;ale_chip_rev,
+		    txf_len, rxf_len);
+		error = ENXIO;
+		goto fail;
+	}
+	device_printf(dev, &quot;%u Tx FIFO, %u Rx FIFO\n&quot;, txf_len, rxf_len);
+
+	/* Allocate IRQ resources. */
+	msixc = pci_msix_count(dev);
+	msic = pci_msi_count(dev);
+	if (bootverbose) {
+		device_printf(dev, &quot;MSIX count : %d\n&quot;, msixc);
+		device_printf(dev, &quot;MSI count : %d\n&quot;, msic);
+	}
+
+	/* Prefer MSIX over MSI. */
+	if (msix_disable == 0 || msi_disable == 0) {
+		if (msix_disable == 0 &amp;&amp; msixc == ALE_MSIX_MESSAGES &amp;&amp;
+		    pci_alloc_msix(dev, &amp;msixc) == 0) {
+			if (msic == ALE_MSIX_MESSAGES) {
+				device_printf(dev, &quot;Using %d MSIX messages.\n&quot;,
+				    msixc);
+				sc-&gt;ale_flags |= ALE_FLAG_MSIX;
+				sc-&gt;ale_irq_spec = ale_irq_spec_msix;
+			} else
+				pci_release_msi(dev);
+		}
+		if (msi_disable == 0 &amp;&amp; (sc-&gt;ale_flags &amp; ALE_FLAG_MSIX) == 0 &amp;&amp;
+		    msic == ALE_MSI_MESSAGES &amp;&amp;
+		    pci_alloc_msi(dev, &amp;msic) == 0) {
+			if (msic == ALE_MSI_MESSAGES) {
+				device_printf(dev, &quot;Using %d MSI messages.\n&quot;,
+				    msic);
+				sc-&gt;ale_flags |= ALE_FLAG_MSI;
+				sc-&gt;ale_irq_spec = ale_irq_spec_msi;
+			} else
+				pci_release_msi(dev);
+		}
+	}
+
+	error = bus_alloc_resources(dev, sc-&gt;ale_irq_spec, sc-&gt;ale_irq);
+	if (error != 0) {
+		device_printf(dev, &quot;cannot allocate IRQ resources.\n&quot;);
+		goto fail;
+	}
+
+	/* Get DMA parameters from PCIe device control register. */
+	if (pci_find_extcap(dev, PCIY_EXPRESS, &amp;i) == 0) {
+		sc-&gt;ale_flags |= ALE_FLAG_PCIE;
+		burst = pci_read_config(dev, i + 0x08, 2);
+		/* Max read request size. */
+		sc-&gt;ale_dma_rd_burst = ((burst &gt;&gt; 12) &amp; 0x07) &lt;&lt;
+		    DMA_CFG_RD_BURST_SHIFT;
+		/* Max payload size. */
+		sc-&gt;ale_dma_wr_burst = ((burst &gt;&gt; 5) &amp; 0x07) &lt;&lt;
+		    DMA_CFG_WR_BURST_SHIFT;
+		if (bootverbose) {
+			device_printf(dev, &quot;Read request size : %d bytes.\n&quot;,
+			    128 &lt;&lt; ((burst &gt;&gt; 12) &amp; 0x07));
+			device_printf(dev, &quot;TLP payload size : %d bytes.\n&quot;,
+			    128 &lt;&lt; ((burst &gt;&gt; 5) &amp; 0x07));
+		}
+	} else {
+		sc-&gt;ale_dma_rd_burst = DMA_CFG_RD_BURST_128;
+		sc-&gt;ale_dma_wr_burst = DMA_CFG_WR_BURST_128;
+	}
+
+	/* Create device sysctl node. */
+	ale_sysctl_node(sc);
+
+	if ((error = ale_dma_alloc(sc) != 0))
+		goto fail;
+
+	/* Load station address. */
+	ale_get_macaddr(sc);
+
+	ifp = sc-&gt;ale_ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		device_printf(dev, &quot;cannot allocate ifnet structure.\n&quot;);
+		error = ENXIO;
+		goto fail;
+	}
+
+	ifp-&gt;if_softc = sc;
+	if_initname(ifp, device_get_name(dev), device_get_unit(dev));
+	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+	ifp-&gt;if_ioctl = ale_ioctl;
+	ifp-&gt;if_start = ale_start;
+	ifp-&gt;if_init = ale_init;
+	ifp-&gt;if_snd.ifq_drv_maxlen = ALE_TX_RING_CNT - 1;
+	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, ifp-&gt;if_snd.ifq_drv_maxlen);
+	IFQ_SET_READY(&amp;ifp-&gt;if_snd);
+	ifp-&gt;if_capabilities = IFCAP_RXCSUM | IFCAP_TXCSUM | IFCAP_TSO4;
+	ifp-&gt;if_hwassist = ALE_CSUM_FEATURES | CSUM_TSO;
+#ifdef ENABLE_WOL
+	if (pci_find_extcap(dev, PCIY_PMG, &amp;pmc) == 0) {
+		sc-&gt;ale_flags |= ALE_FLAG_PMCAP;
+		ifp-&gt;if_capabilities |= IFCAP_WOL_MAGIC | IFCAP_WOL_MCAST;
+	}
+#endif
+	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;
+
+	/* Set up MII bus. */
+	if ((error = mii_phy_probe(dev, &amp;sc-&gt;ale_miibus, ale_mediachange,
+	    ale_mediastatus)) != 0) {
+		device_printf(dev, &quot;no PHY found!\n&quot;);
+		goto fail;
+	}
+
+	ether_ifattach(ifp, sc-&gt;ale_eaddr);
+
+	/* VLAN capability setup. */
+	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU;
+	ifp-&gt;if_capabilities |= IFCAP_VLAN_HWTAGGING | IFCAP_VLAN_HWCSUM;
+	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;
+
+	/* Tell the upper layer(s) we support long frames. */
+	ifp-&gt;if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
+
+	/* Create local taskq. */
+	TASK_INIT(&amp;sc-&gt;ale_tx_task, 1, ale_tx_task, ifp);
+	sc-&gt;ale_tq = taskqueue_create_fast(&quot;ale_taskq&quot;, M_WAITOK,
+	    taskqueue_thread_enqueue, &amp;sc-&gt;ale_tq);
+	if (sc-&gt;ale_tq == NULL) {
+		device_printf(dev, &quot;could not create taskqueue.\n&quot;);
+		ether_ifdetach(ifp);
+		error = ENXIO;
+		goto fail;
+	}
+	taskqueue_start_threads(&amp;sc-&gt;ale_tq, 1, PI_NET, &quot;%s taskq&quot;,
+	    device_get_nameunit(sc-&gt;ale_dev));
+
+	if ((sc-&gt;ale_flags &amp; ALE_FLAG_MSIX) != 0)
+		msic = ALE_MSIX_MESSAGES;
+	else if ((sc-&gt;ale_flags &amp; ALE_FLAG_MSI) != 0)
+		msic = ALE_MSI_MESSAGES;
+	else
+		msic = 1;
+	for (i = 0; i &lt; msic; i++) {
+		error = bus_setup_intr(dev, sc-&gt;ale_irq[i],
+		    INTR_TYPE_NET | INTR_MPSAFE, ale_intr, NULL, sc,
+		    &amp;sc-&gt;ale_intrhand[i]);
+		if (error != 0)
+			break;
+	}
+	if (error != 0) {
+		device_printf(dev, &quot;could not set up interrupt handler.\n&quot;);
+		taskqueue_free(sc-&gt;ale_tq);
+		sc-&gt;ale_tq = NULL;
+		ether_ifdetach(ifp);
+		goto fail;
+	}
+
+fail:
+	if (error != 0)
+		ale_detach(dev);
+
+	return (error);
+}
+
+static int
+ale_detach(device_t dev)
+{
+	struct ale_softc *sc;
+	struct ifnet *ifp;
+	int i, msic;
+
+	sc = device_get_softc(dev);
+
+	ifp = sc-&gt;ale_ifp;
+	if (device_is_attached(dev)) {
+		ALE_LOCK(sc);
+		sc-&gt;ale_flags |= ALE_FLAG_DETACH;
+		ale_stop(sc);
+		ALE_UNLOCK(sc);
+		callout_drain(&amp;sc-&gt;ale_tick_ch);
+		taskqueue_drain(sc-&gt;ale_tq, &amp;sc-&gt;ale_int_task);
+		taskqueue_drain(sc-&gt;ale_tq, &amp;sc-&gt;ale_tx_task);
+		taskqueue_drain(taskqueue_swi, &amp;sc-&gt;ale_link_task);
+		ether_ifdetach(ifp);
+	}
+
+	if (sc-&gt;ale_tq != NULL) {
+		taskqueue_drain(sc-&gt;ale_tq, &amp;sc-&gt;ale_int_task);
+		taskqueue_free(sc-&gt;ale_tq);
+		sc-&gt;ale_tq = NULL;
+	}
+
+	if (sc-&gt;ale_miibus != NULL) {
+		device_delete_child(dev, sc-&gt;ale_miibus);
+		sc-&gt;ale_miibus = NULL;
+	}
+	bus_generic_detach(dev);
+	ale_dma_free(sc);
+
+	if (ifp != NULL) {
+		if_free(ifp);
+		sc-&gt;ale_ifp = NULL;
+	}
+
+	if ((sc-&gt;ale_flags &amp; ALE_FLAG_MSIX) != 0)
+		msic = ALE_MSIX_MESSAGES;
+	else if ((sc-&gt;ale_flags &amp; ALE_FLAG_MSI) != 0)
+		msic = ALE_MSI_MESSAGES;
+	else
+		msic = 1;
+	for (i = 0; i &lt; msic; i++) {
+		if (sc-&gt;ale_intrhand[i] != NULL) {
+			bus_teardown_intr(dev, sc-&gt;ale_irq[i],
+			    sc-&gt;ale_intrhand[i]);
+			sc-&gt;ale_intrhand[i] = NULL;
+		}
+	}
+
+	bus_release_resources(dev, sc-&gt;ale_irq_spec, sc-&gt;ale_irq);
+	if ((sc-&gt;ale_flags &amp; (ALE_FLAG_MSI | ALE_FLAG_MSIX)) != 0)
+		pci_release_msi(dev);
+	bus_release_resources(dev, sc-&gt;ale_res_spec, sc-&gt;ale_res);
+	mtx_destroy(&amp;sc-&gt;ale_mtx);
+
+	return (0);
+}
+
+#define	ALE_SYSCTL_STAT_ADD32(c, h, n, p, d)	\
+	    SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)
+
+#if __FreeBSD_version &gt; 800000
+#define	ALE_SYSCTL_STAT_ADD64(c, h, n, p, d)	\
+	    SYSCTL_ADD_QUAD(c, h, OID_AUTO, n, CTLFLAG_RD, p, d)
+#else
+#define	ALE_SYSCTL_STAT_ADD64(c, h, n, p, d)	\
+	    SYSCTL_ADD_ULONG(c, h, OID_AUTO, n, CTLFLAG_RD, p, d)
+#endif
+
+static void
+ale_sysctl_node(struct ale_softc *sc)
+{
+	struct sysctl_ctx_list *ctx;
+	struct sysctl_oid_list *child, *parent;
+	struct sysctl_oid *tree;
+	struct ale_hw_stats *stats;
+	int error;
+
+	stats = &amp;sc-&gt;ale_stats;
+	ctx = device_get_sysctl_ctx(sc-&gt;ale_dev);
+	child = SYSCTL_CHILDREN(device_get_sysctl_tree(sc-&gt;ale_dev));
+
+	SYSCTL_ADD_PROC(ctx, child, OID_AUTO, &quot;int_rx_mod&quot;,
+	    CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;ale_int_rx_mod, 0,
+	    sysctl_hw_ale_int_mod, &quot;I&quot;, &quot;ale Rx interrupt moderation&quot;);
+	SYSCTL_ADD_PROC(ctx, child, OID_AUTO, &quot;int_tx_mod&quot;,
+	    CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;ale_int_tx_mod, 0,
+	    sysctl_hw_ale_int_mod, &quot;I&quot;, &quot;ale Tx interrupt moderation&quot;);
+	/* Pull in device tunables. */
+	sc-&gt;ale_int_rx_mod = ALE_IM_RX_TIMER_DEFAULT;
+	error = resource_int_value(device_get_name(sc-&gt;ale_dev),
+	    device_get_unit(sc-&gt;ale_dev), &quot;int_rx_mod&quot;, &amp;sc-&gt;ale_int_rx_mod);
+	if (error == 0) {
+		if (sc-&gt;ale_int_rx_mod &lt; ALE_IM_TIMER_MIN ||
+		    sc-&gt;ale_int_rx_mod &gt; ALE_IM_TIMER_MAX) {
+			device_printf(sc-&gt;ale_dev, &quot;int_rx_mod value out of &quot;
+			    &quot;range; using default: %d\n&quot;,
+			    ALE_IM_RX_TIMER_DEFAULT);
+			sc-&gt;ale_int_rx_mod = ALE_IM_RX_TIMER_DEFAULT;
+		}
+	}
+	sc-&gt;ale_int_tx_mod = ALE_IM_TX_TIMER_DEFAULT;
+	error = resource_int_value(device_get_name(sc-&gt;ale_dev),
+	    device_get_unit(sc-&gt;ale_dev), &quot;int_tx_mod&quot;, &amp;sc-&gt;ale_int_tx_mod);
+	if (error == 0) {
+		if (sc-&gt;ale_int_tx_mod &lt; ALE_IM_TIMER_MIN ||
+		    sc-&gt;ale_int_tx_mod &gt; ALE_IM_TIMER_MAX) {
+			device_printf(sc-&gt;ale_dev, &quot;int_tx_mod value out of &quot;
+			    &quot;range; using default: %d\n&quot;,
+			    ALE_IM_TX_TIMER_DEFAULT);
+			sc-&gt;ale_int_tx_mod = ALE_IM_TX_TIMER_DEFAULT;
+		}
+	}
+	SYSCTL_ADD_PROC(ctx, child, OID_AUTO, &quot;process_limit&quot;,
+	    CTLTYPE_INT | CTLFLAG_RW, &amp;sc-&gt;ale_process_limit, 0,
+	    sysctl_hw_ale_proc_limit, &quot;I&quot;,
+	    &quot;max number of Rx events to process&quot;);
+	/* Pull in device tunables. */
+	sc-&gt;ale_process_limit = ALE_PROC_DEFAULT;
+	error = resource_int_value(device_get_name(sc-&gt;ale_dev),
+	    device_get_unit(sc-&gt;ale_dev), &quot;process_limit&quot;,
+	    &amp;sc-&gt;ale_process_limit);
+	if (error == 0) {
+		if (sc-&gt;ale_process_limit &lt; ALE_PROC_MIN ||
+		    sc-&gt;ale_process_limit &gt; ALE_PROC_MAX) {
+			device_printf(sc-&gt;ale_dev,
+			    &quot;process_limit value out of range; &quot;
+			    &quot;using default: %d\n&quot;, ALE_PROC_DEFAULT);
+			sc-&gt;ale_process_limit = ALE_PROC_DEFAULT;
+		}
+	}
+
+	/* Misc statistics. */
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;reset_brk_seq&quot;,
+	    &amp;stats-&gt;reset_brk_seq,
+	    &quot;Controller resets due to broken Rx sequnce number&quot;);
+
+	tree = SYSCTL_ADD_NODE(ctx, child, OID_AUTO, &quot;stats&quot;, CTLFLAG_RD,
+	    NULL, &quot;ATE statistics&quot;);
+	parent = SYSCTL_CHILDREN(tree);
+
+	/* Rx statistics. */
+	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;rx&quot;, CTLFLAG_RD,
+	    NULL, &quot;Rx MAC statistics&quot;);
+	child = SYSCTL_CHILDREN(tree);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_frames&quot;,
+	    &amp;stats-&gt;rx_frames, &quot;Good frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_bcast_frames&quot;,
+	    &amp;stats-&gt;rx_bcast_frames, &quot;Good broadcast frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_mcast_frames&quot;,
+	    &amp;stats-&gt;rx_mcast_frames, &quot;Good multicast frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;pause_frames&quot;,
+	    &amp;stats-&gt;rx_pause_frames, &quot;Pause control frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;control_frames&quot;,
+	    &amp;stats-&gt;rx_control_frames, &quot;Control frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;crc_errs&quot;,
+	    &amp;stats-&gt;rx_crcerrs, &quot;CRC errors&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;len_errs&quot;,
+	    &amp;stats-&gt;rx_lenerrs, &quot;Frames with length mismatched&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_octets&quot;,
+	    &amp;stats-&gt;rx_bytes, &quot;Good octets&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_bcast_octets&quot;,
+	    &amp;stats-&gt;rx_bcast_bytes, &quot;Good broadcast octets&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_mcast_octets&quot;,
+	    &amp;stats-&gt;rx_mcast_bytes, &quot;Good multicast octets&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;runts&quot;,
+	    &amp;stats-&gt;rx_runts, &quot;Too short frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;fragments&quot;,
+	    &amp;stats-&gt;rx_fragments, &quot;Fragmented frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_64&quot;,
+	    &amp;stats-&gt;rx_pkts_64, &quot;64 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_65_127&quot;,
+	    &amp;stats-&gt;rx_pkts_65_127, &quot;65 to 127 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_128_255&quot;,
+	    &amp;stats-&gt;rx_pkts_128_255, &quot;128 to 255 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_256_511&quot;,
+	    &amp;stats-&gt;rx_pkts_256_511, &quot;256 to 511 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_512_1023&quot;,
+	    &amp;stats-&gt;rx_pkts_512_1023, &quot;512 to 1023 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_1024_1518&quot;,
+	    &amp;stats-&gt;rx_pkts_1024_1518, &quot;1024 to 1518 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_1519_max&quot;,
+	    &amp;stats-&gt;rx_pkts_1519_max, &quot;1519 to max frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;trunc_errs&quot;,
+	    &amp;stats-&gt;rx_pkts_truncated, &quot;Truncated frames due to MTU size&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;fifo_oflows&quot;,
+	    &amp;stats-&gt;rx_fifo_oflows, &quot;FIFO overflows&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;rrs_errs&quot;,
+	    &amp;stats-&gt;rx_rrs_errs, &quot;Return status write-back errors&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;align_errs&quot;,
+	    &amp;stats-&gt;rx_alignerrs, &quot;Alignment errors&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;filtered&quot;,
+	    &amp;stats-&gt;rx_pkts_filtered,
+	    &quot;Frames dropped due to address filtering&quot;);
+
+	/* Tx statistics. */
+	tree = SYSCTL_ADD_NODE(ctx, parent, OID_AUTO, &quot;tx&quot;, CTLFLAG_RD,
+	    NULL, &quot;Tx MAC statistics&quot;);
+	child = SYSCTL_CHILDREN(tree);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_frames&quot;,
+	    &amp;stats-&gt;tx_frames, &quot;Good frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_bcast_frames&quot;,
+	    &amp;stats-&gt;tx_bcast_frames, &quot;Good broadcast frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;good_mcast_frames&quot;,
+	    &amp;stats-&gt;tx_mcast_frames, &quot;Good multicast frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;pause_frames&quot;,
+	    &amp;stats-&gt;tx_pause_frames, &quot;Pause control frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;control_frames&quot;,
+	    &amp;stats-&gt;tx_control_frames, &quot;Control frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;excess_defers&quot;,
+	    &amp;stats-&gt;tx_excess_defer, &quot;Frames with excessive derferrals&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;defers&quot;,
+	    &amp;stats-&gt;tx_excess_defer, &quot;Frames with derferrals&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_octets&quot;,
+	    &amp;stats-&gt;tx_bytes, &quot;Good octets&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_bcast_octets&quot;,
+	    &amp;stats-&gt;tx_bcast_bytes, &quot;Good broadcast octets&quot;);
+	ALE_SYSCTL_STAT_ADD64(ctx, child, &quot;good_mcast_octets&quot;,
+	    &amp;stats-&gt;tx_mcast_bytes, &quot;Good multicast octets&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_64&quot;,
+	    &amp;stats-&gt;tx_pkts_64, &quot;64 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_65_127&quot;,
+	    &amp;stats-&gt;tx_pkts_65_127, &quot;65 to 127 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_128_255&quot;,
+	    &amp;stats-&gt;tx_pkts_128_255, &quot;128 to 255 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_256_511&quot;,
+	    &amp;stats-&gt;tx_pkts_256_511, &quot;256 to 511 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_512_1023&quot;,
+	    &amp;stats-&gt;tx_pkts_512_1023, &quot;512 to 1023 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_1024_1518&quot;,
+	    &amp;stats-&gt;tx_pkts_1024_1518, &quot;1024 to 1518 bytes frames&quot;);
+	ALE_SYSCTL_STAT_ADD32(ctx, child, &quot;frames_1519_max&quot;,
+	    &amp;stats-&gt;tx_pkts_1519_max, &quot;1519 to max frames&quot;);

[... truncated: 3615 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013707.html">[Haiku-commits] r28770 - in	haiku/trunk/src/libs/compat/freebsd_network/compat: machine net sys
</A></li>
	<LI>Next message: <A HREF="013709.html">[Haiku-commits] r28771 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . ar81xx	ar81xx/dev ar81xx/dev/ale ar81xx/dev/mii
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13708">[ date ]</a>
              <a href="thread.html#13708">[ thread ]</a>
              <a href="subject.html#13708">[ subject ]</a>
              <a href="author.html#13708">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
