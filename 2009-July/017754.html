<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31427 -	haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31427%20-%0A%09haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker&In-Reply-To=%3C200907061720.n66HKIBw032706%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017753.html">
   <LINK REL="Next"  HREF="017755.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31427 -	haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker</H1>
    <B>aldeck at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31427%20-%0A%09haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker&In-Reply-To=%3C200907061720.n66HKIBw032706%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31427 -	haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker">aldeck at mail.berlios.de
       </A><BR>
    <I>Mon Jul  6 19:20:18 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="017753.html">[Haiku-commits] r31426 - in haiku/trunk/docs: . userguide/en	userguide/en/applications userguide/en/preferences
</A></li>
        <LI>Next message: <A HREF="017755.html">[Haiku-commits] r31428 - haiku/trunk/docs/userguide/en/installation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17754">[ date ]</a>
              <a href="thread.html#17754">[ thread ]</a>
              <a href="subject.html#17754">[ subject ]</a>
              <a href="author.html#17754">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: aldeck
Date: 2009-07-06 19:19:45 +0200 (Mon, 06 Jul 2009)
New Revision: 31427
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31427&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31427&amp;view=rev</A>

Removed:
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/OpenHashTable.h
Modified:
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AttributeStream.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/BackgroundImage.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/BackgroundImage.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Bitmaps.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Commands.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/ContainerWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/CountView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/CountView.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/DeskWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/DesktopPoseView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/DialogPane.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/DialogPane.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/EntryIterator.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/EntryIterator.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FSClipboard.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FSClipboard.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FSUtils.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FSUtils.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FavoritesConfig.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FilePanel.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FilePanelPriv.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FilePermissionsView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FindPanel.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/FindPanel.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/IconCache.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/InfoWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/InfoWindow.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Jamfile
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Model.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/MountMenu.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/MountMenu.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/OpenWithWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/OpenWithWindow.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Pose.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Pose.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/PoseView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/PoseView.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/QueryPoseView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/StatusWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TaskLoop.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Tests.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TextWidget.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TextWidget.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Thread.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TitleView.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TitleView.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Tracker.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Tracker.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TrackerInitialState.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TrackerScripting.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TrackerSettings.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/TrackerSettingsWindow.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Utilities.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/Utilities.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/ViewState.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/ViewState.h
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/WidgetAttributeText.cpp
   haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/WidgetAttributeText.h
Log:
Merging changes from trunk up to r31378

Modified: haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AttributeStream.cpp
===================================================================
--- haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AttributeStream.cpp	2009-07-06 16:53:55 UTC (rev 31426)
+++ haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AttributeStream.cpp	2009-07-06 17:19:45 UTC (rev 31427)
@@ -32,9 +32,11 @@
 All rights reserved.
 */
 
-#include &lt;Node.h&gt;
 #include &quot;AttributeStream.h&quot;
 
+#include &lt;Debug.h&gt;
+#include &lt;Node.h&gt;
+
 // ToDo:
 // lazy Rewind from Drive, only if data is available
 // BMessage node
@@ -43,7 +45,7 @@
 AttributeInfo::AttributeInfo(const AttributeInfo &amp;cloneThis)
 	:	fName(cloneThis.fName),
 		fInfo(cloneThis.fInfo)
-		
+
 {
 }
 
@@ -68,34 +70,34 @@
 	return fName.String();
 }
 
-uint32 
+uint32
 AttributeInfo::Type() const
 {
 	return fInfo.type;
 }
 
-off_t 
+off_t
 AttributeInfo::Size() const
 {
 	return fInfo.size;
 }
 
 
-void 
+void
 AttributeInfo::SetTo(const AttributeInfo &amp;attr)
 {
 	fName = attr.fName;
 	fInfo = attr.fInfo;
 }
 
-void 
+void
 AttributeInfo::SetTo(const char *name, attr_info info)
 {
 	fName = name;
 	fInfo = info;
 }
 
-void 
+void
 AttributeInfo::SetTo(const char *name, uint32 type, off_t size)
 {
 	fName = name;
@@ -121,26 +123,26 @@
 {
 	fReadFrom = &source;
 	fReadFrom-&gt;fWriteTo = this;
-	if (fReadFrom-&gt;CanFeed()) 
+	if (fReadFrom-&gt;CanFeed())
 		fReadFrom-&gt;Start();
 
 	return source;
 }
 
-void 
+void
 AttributeStreamNode::Rewind()
 {
 	if (fReadFrom)
 		fReadFrom-&gt;Rewind();
 }
 
-void 
+void
 AttributeStreamFileNode::MakeEmpty()
 {
 	TRESPASS();
 }
 
-off_t 
+off_t
 AttributeStreamNode::Contains(const char *name, uint32 type)
 {
 	if (!fReadFrom)
@@ -150,27 +152,27 @@
 }
 
 
-off_t 
+off_t
 AttributeStreamNode::Read(const char *name, const char *foreignName, uint32 type,
 	off_t size, void *buffer, void (*swapFunc)(void *))
 {
 	if (!fReadFrom)
 		return 0;
-	
+
 	return fReadFrom-&gt;Read(name, foreignName, type, size, buffer, swapFunc);
 }
 
-off_t 
+off_t
 AttributeStreamNode::Write(const char *name, const char *foreignName, uint32 type,
 	off_t size, const void *buffer)
 {
 	if (!fWriteTo)
 		return 0;
-	
+
 	return fWriteTo-&gt;Write(name, foreignName, type, size, buffer);
 }
 
-bool 
+bool
 AttributeStreamNode::Drive()
 {
 	ASSERT(CanFeed());
@@ -200,17 +202,17 @@
 	return fReadFrom-&gt;Get();
 }
 
-bool 
+bool
 AttributeStreamNode::Fill(char *buffer) const
 {
 	ASSERT(fReadFrom);
 	return fReadFrom-&gt;Fill(buffer);
 }
 
-bool 
+bool
 AttributeStreamNode::Start()
 {
-	if (!fWriteTo) 
+	if (!fWriteTo)
 		// we are at the head of the stream, start drivin'
 		return Drive();
 
@@ -224,11 +226,11 @@
 	AttributeStreamNode *tmpTo = fWriteTo;
 	fReadFrom = NULL;
 	fWriteTo = NULL;
-	
-	if (tmpFrom) 
+
+	if (tmpFrom)
 		tmpFrom-&gt;Detach();
 	if (tmpTo)
-		tmpTo-&gt;Detach();			
+		tmpTo-&gt;Detach();
 }
 
 
@@ -244,21 +246,21 @@
 	ASSERT(fNode);
 }
 
-void 
+void
 AttributeStreamFileNode::Rewind()
 {
 	_inherited::Rewind();
 	fNode-&gt;RewindAttrs();
 }
 
-void 
+void
 AttributeStreamFileNode::SetTo(BNode *node)
 {
 	fNode = node;
 }
 
 
-off_t 
+off_t
 AttributeStreamFileNode::Contains(const char *name, uint32 type)
 {
 	ASSERT(fNode);
@@ -272,13 +274,13 @@
 	return info.size;
 }
 
-off_t 
+off_t
 AttributeStreamFileNode::Read(const char *name, const char *foreignName, uint32 type,
 	off_t size, void *buffer, void (*swapFunc)(void *))
 {
 	if (name &amp;&amp; fNode-&gt;ReadAttr(name, type, 0, buffer, (size_t)size) == size)
 		return size;
-	
+
 	// didn't find the attribute under the native name, try the foreign name
 	if (foreignName &amp;&amp; fNode-&gt;ReadAttr(foreignName, type, 0, buffer, (size_t)size) == size) {
 		// foreign attribute, swap the data
@@ -289,7 +291,7 @@
 	return 0;
 }
 
-off_t 
+off_t
 AttributeStreamFileNode::Write(const char *name, const char *foreignName, uint32 type,
 	off_t size, const void *buffer)
 {
@@ -300,11 +302,11 @@
 		// the write operation worked fine, remove the foreign attribute
 		// to not let stale data hang around
 		fNode-&gt;RemoveAttr(foreignName);
-	
+
 	return result;
 }
 
-bool 
+bool
 AttributeStreamFileNode::Drive()
 {
 	ASSERT(fNode);
@@ -330,7 +332,7 @@
 	return NULL;
 }
 
-bool 
+bool
 AttributeStreamFileNode::Fill(char *buffer) const
 {
 	ASSERT(fNode);
@@ -350,7 +352,7 @@
 	attr_info info;
 	if (fNode-&gt;GetAttrInfo(attrName, &amp;info) != B_OK)
 		return NULL;
-	
+
 	fCurrentAttr.SetTo(attrName, info);
 	return &fCurrentAttr;
 }
@@ -362,13 +364,13 @@
 {
 }
 
-void 
+void
 AttributeStreamMemoryNode::MakeEmpty()
 {
 	fAttributes.MakeEmpty();
 }
 
-void 
+void
 AttributeStreamMemoryNode::Rewind()
 {
 	_inherited::Rewind();
@@ -387,7 +389,7 @@
 	return -1;
 }
 
-off_t 
+off_t
 AttributeStreamMemoryNode::Contains(const char *name, uint32 type)
 {
 	int32 index = Find(name, type);
@@ -397,7 +399,7 @@
 }
 
 
-off_t 
+off_t
 AttributeStreamMemoryNode::Read(const char *name, const char *DEBUG_ONLY(foreignName),
 	uint32 type, off_t bufferSize, void *buffer, void (*DEBUG_ONLY(swapFunc))(void *))
 {
@@ -413,7 +415,7 @@
 		off_t size = fReadFrom-&gt;Contains(name, type);
 		if (!size)
 			return 0;
-		
+
 		attrNode = BufferingGet(name, type, size);
 		if (!attrNode)
 			return 0;
@@ -422,12 +424,12 @@
 
 	if (attrNode-&gt;fAttr.Size() &gt; bufferSize)
 		return 0;
-	
+
 	memcpy(buffer, attrNode-&gt;fData, (size_t)attrNode-&gt;fAttr.Size());
 	return attrNode-&gt;fAttr.Size();
 }
 
-off_t 
+off_t
 AttributeStreamMemoryNode::Write(const char *name, const char *, uint32 type,
 	off_t size,	const void *buffer)
 {
@@ -439,15 +441,15 @@
 	return size;
 }
 
-bool 
+bool
 AttributeStreamMemoryNode::Drive()
 {
 	if (!_inherited::Drive())
 		return false;
-	
+
 	while (BufferingGet())
 		;
-	
+
 	return true;
 }
 
@@ -456,7 +458,7 @@
 {
 	char *newBuffer = new char[size];
 	if (!fReadFrom-&gt;Fill(newBuffer)) {
-		delete newBuffer;
+		delete[] newBuffer;
 		return NULL;
 	}
 
@@ -471,7 +473,7 @@
 {
 	if (!fReadFrom)
 		return NULL;
-	
+
 	const AttributeInfo *attr = fReadFrom-&gt;Next();
 	if (!attr)
 		return NULL;
@@ -500,7 +502,7 @@
 	return fAttributes.ItemAt(fCurrentIndex)-&gt;fData;
 }
 
-bool 
+bool
 AttributeStreamMemoryNode::Fill(char *buffer) const
 {
 	ASSERT(fCurrentIndex &lt; fAttributes.CountItems());
@@ -519,17 +521,17 @@
 {
 }
 
-off_t 
+off_t
 AttributeStreamTemplateNode::Contains(const char *name, uint32 type)
 {
 	int32 index = Find(name, type);
 	if (index &lt; 0)
 		return 0;
-	
+
 	return fAttributes[index].fSize;
 }
 
-void 
+void
 AttributeStreamTemplateNode::Rewind()
 {
 	fCurrentIndex = -1;
@@ -556,7 +558,7 @@
 	return fAttributes[fCurrentIndex].fBits;
 }
 
-bool 
+bool
 AttributeStreamTemplateNode::Fill(char *buffer) const
 {
 	ASSERT(fCurrentIndex &lt; fCount);
@@ -565,18 +567,18 @@
 	return true;
 }
 
-int32 
+int32
 AttributeStreamTemplateNode::Find(const char *name, uint32 type) const
 {
 	for (int32 index = 0; index &lt; fCount; index++)
 		if (fAttributes[index].fAttributeType == type &amp;&amp;
 			strcmp(name, fAttributes[index].fAttributeName) == 0)
 			return index;
-	
+
 	return -1;
 }
 
-bool 
+bool
 AttributeStreamFilterNode::Reject(const char *, uint32 , off_t )
 {
 	// simple pass everything filter
@@ -600,43 +602,43 @@
 	return NULL;
 }
 
-off_t 
+off_t
 AttributeStreamFilterNode::Contains(const char *name, uint32 type)
 {
 	if (!fReadFrom)
 		return 0;
-	
+
 	off_t size = fReadFrom-&gt;Contains(name, type);
 
 	if (!Reject(name, type, size))
 		return size;
-	
+
 	return 0;
 }
 
-off_t 
+off_t
 AttributeStreamFilterNode::Read(const char *name, const char *foreignName, uint32 type,
 	off_t size,	void *buffer, void (*swapFunc)(void *))
 {
 	if (!fReadFrom)
 		return 0;
-	
+
 	if (!Reject(name, type, size))
 		return fReadFrom-&gt;Read(name, foreignName, type, size, buffer, swapFunc);
-	
+
 	return 0;
 }
 
-off_t 
+off_t
 AttributeStreamFilterNode::Write(const char *name, const char *foreignName, uint32 type,
 	off_t size,	const void *buffer)
 {
 	if (!fWriteTo)
 		return 0;
-	
+
 	if (!Reject(name, type, size))
 		return fWriteTo-&gt;Write(name, foreignName, type, size, buffer);
-	
+
 	return size;
 }
 
@@ -646,7 +648,7 @@
 {
 }
 
-bool 
+bool
 NamesToAcceptAttrFilter::Reject(const char *name, uint32 , off_t )
 {
 	for (int32 index = 0; ;index++) {
@@ -679,7 +681,7 @@
 		delete [] fTransformedBuffers.ItemAt(index);
 }
 
-void 
+void
 SelectiveAttributeTransformer::Rewind()
 {
 	for (int32 index = fTransformedBuffers.CountItems() - 1; index &gt;= 0; index--)
@@ -689,13 +691,13 @@
 }
 
 
-off_t 
+off_t
 SelectiveAttributeTransformer::Read(const char *name, const char *foreignName,
 	uint32 type, off_t size, void *buffer, void (*swapFunc)(void *))
 {
 	if (!fReadFrom)
 		return 0;
-	
+
 	off_t result = fReadFrom-&gt;Read(name, foreignName, type, size, buffer, swapFunc);
 
 	if (WillTransform(name, type, size, (const char *)buffer))
@@ -704,21 +706,21 @@
 	return result;
 }
 
-bool 
+bool
 SelectiveAttributeTransformer::WillTransform(const char *name, uint32 , off_t ,
 	const char *) const
 {
 	return strcmp(name, fAttributeNameToTransform) == 0;
 }
 
-bool 
+bool
 SelectiveAttributeTransformer::ApplyTransformer(const char *name, uint32 type, off_t size,
 	char *data)
 {
 	return (fTransformFunc)(name, type, size, data, fTransformParams);
 }
 
-char * 
+char *
 SelectiveAttributeTransformer::CopyAndApplyTransformer(const char *name, uint32 type,
 	off_t size, const char *data)
 {
@@ -751,15 +753,15 @@
 {
 	if (!fReadFrom)
 		return NULL;
-	
+
 	const char *result = fReadFrom-&gt;Get();
-	
+
 	if (!WillTransform(fCurrentAttr.Name(), fCurrentAttr.Type(), fCurrentAttr.Size(), result))
 		return result;
 
 	char *transformedData = CopyAndApplyTransformer(fCurrentAttr.Name(), fCurrentAttr.Type(),
 		fCurrentAttr.Size(), result);
-	
+
 	// enlist for proper disposal when our job is done
 	if (transformedData) {
 		fTransformedBuffers.AddItem(transformedData);

Modified: haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.cpp
===================================================================
--- haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.cpp	2009-07-06 16:53:55 UTC (rev 31426)
+++ haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.cpp	2009-07-06 17:19:45 UTC (rev 31427)
@@ -34,6 +34,8 @@
 
 #include &quot;AutoMounter.h&quot;
 
+#include &lt;Debug.h&gt;
+
 #include &quot;AutoLock.h&quot;
 #include &quot;AutoMounterSettings.h&quot;
 #include &quot;Commands.h&quot;
@@ -46,6 +48,7 @@
 #	include &lt;DiskDevice.h&gt;
 #	include &lt;DiskDeviceList.h&gt;
 #	include &lt;DiskDeviceTypes.h&gt;
+#	include &lt;DiskSystem.h&gt;
 #	include &lt;fs_volume.h&gt;
 #endif
 
@@ -84,18 +87,85 @@
 		fRemovableMode = kNoVolumes;
 	}
 
+	BDiskDeviceRoster().StartWatching(this,
+		B_DEVICE_REQUEST_DEVICE | B_DEVICE_REQUEST_DEVICE_LIST);
 	PostMessage(kMsgInitialScan);
 }
 
 
 AutoMounter::~AutoMounter()
 {
+	BDiskDeviceRoster().StopWatching(this);
 }
 
 
+static bool
+suggest_mount_flags(const BPartition* partition, uint32* _flags)
+{
+	uint32 mountFlags = 0;
+
+	bool askReadOnly = true;
+	bool isBFS = false;
+
+	if (partition-&gt;ContentType() != NULL
+		&amp;&amp; strcmp(partition-&gt;ContentType(), kPartitionTypeBFS) == 0) {
+#if 0
+		askReadOnly = false;
+#endif
+		isBFS = true;
+	}
+
+	BDiskSystem diskSystem;
+	status_t status = partition-&gt;GetDiskSystem(&amp;diskSystem);
+	if (status == B_OK &amp;&amp; !diskSystem.SupportsWriting())
+		askReadOnly = false;
+
+	if (partition-&gt;IsReadOnly())
+		askReadOnly = false;
+
+	if (askReadOnly) {
+		// Suggest to the user to mount read-only until Haiku is more mature.
+		BString string;
+		string &lt;&lt; &quot;Mounting volume &quot;;
+		if (partition-&gt;ContentName() != NULL)
+			string &lt;&lt; &quot;'&quot; &lt;&lt; partition-&gt;ContentName() &lt;&lt; &quot;'\n\n&quot;;
+		else
+			string &lt;&lt; &quot;&lt;unnamed volume&gt;\n\n&quot;;
+		// TODO: Use distro name instead of &quot;Haiku&quot;...
+		if (!isBFS) {
+			string &lt;&lt; &quot;The file system on this volume is not the Haiku file &quot;
+				&quot;system. It is strongly suggested to mount it in read-only &quot;
+				&quot;mode. &quot;;
+		} else {
+			string &lt;&lt; &quot;It is suggested to mount all additional Haiku volumes &quot;
+				&quot;in read-only mode. &quot;;
+		}
+		string &lt;&lt; &quot;This will prevent unintentional data loss because of &quot;
+			&quot;errors in Haiku.&quot;;
+		BAlert* alert = new BAlert(&quot;Mount Warning&quot;, string.String(),
+			&quot;Mount Read/Write&quot;, &quot;Cancel&quot;, &quot;Mount Read-only&quot;,
+			B_WIDTH_FROM_WIDEST, B_WARNING_ALERT);
+		alert-&gt;SetShortcut(1, B_ESCAPE);
+		int32 choice = alert-&gt;Go();
+		switch (choice) {
+			case 0:
+				break;
+			case 1:
+				return false;
+			case 2:
+				mountFlags |= B_MOUNT_READ_ONLY;
+				break;
+		}
+	}
+
+	*_flags = mountFlags;
+	return true;
+}
+
+
 void
 AutoMounter::_MountVolumes(mount_mode normal, mount_mode removable,
-	bool initialRescan)
+	bool initialRescan, partition_id deviceID)
 {
 	if (normal == kNoVolumes &amp;&amp; removable == kNoVolumes)
 		return;
@@ -103,12 +173,14 @@
 	class InitialMountVisitor : public BDiskDeviceVisitor {
 		public:
 			InitialMountVisitor(mount_mode normalMode, mount_mode removableMode,
-					bool initialRescan, BMessage&amp; previous)
+					bool initialRescan, BMessage&amp; previous,
+					partition_id deviceID)
 				:
 				fNormalMode(normalMode),
 				fRemovableMode(removableMode),
 				fInitialRescan(initialRescan),
-				fPrevious(previous)
+				fPrevious(previous),
+				fOnlyOnDeviceID(deviceID)
 			{
 			}
 
@@ -126,7 +198,23 @@
 			virtual bool
 			Visit(BPartition* partition, int32 level)
 			{
-				mount_mode mode = partition-&gt;Device()-&gt;IsRemovableMedia()
+				if (fOnlyOnDeviceID &gt;= 0) {
+					// only mount partitions on the given device id
+					// or if the partition ID is already matched
+					BPartition* device = partition;
+					while (device-&gt;Parent() != NULL) {
+						if (device-&gt;ID() == fOnlyOnDeviceID) {
+							// we are happy
+							break;
+						}
+						device = device-&gt;Parent();
+					}
+					if (device-&gt;ID() != fOnlyOnDeviceID)
+						return false;
+				}
+
+				mount_mode mode = !fInitialRescan
+					&amp;&amp; partition-&gt;Device()-&gt;IsRemovableMedia()
 					? fRemovableMode : fNormalMode;
 				if (mode == kNoVolumes
 					|| partition-&gt;IsMounted()
@@ -134,11 +222,13 @@
 					return false;
 
 				BPath path;
+				if (partition-&gt;GetPath(&amp;path) != B_OK)
+					return false;
+
 				if (mode == kRestorePreviousVolumes) {
 					// mount all volumes that were stored in the settings file
 					const char *volumeName = NULL;
-					if (partition-&gt;GetPath(&amp;path) != B_OK
-						|| partition-&gt;ContentName() == NULL
+					if (partition-&gt;ContentName() == NULL
 						|| fPrevious.FindString(path.Path(), &amp;volumeName)
 							!= B_OK
 						|| strcmp(volumeName, partition-&gt;ContentName()))
@@ -150,11 +240,18 @@
 				}
 
 				uint32 mountFlags;
-				BString mountFlagsKey(path.Path());
-				mountFlagsKey &lt;&lt; kMountFlagsKeyExtension;
-				if (fPrevious.FindInt32(mountFlagsKey.String(),
-						(int32*)&amp;mountFlags) &lt; B_OK) {
-					mountFlags = 0;
+				if (!fInitialRescan) {
+					// Ask the user about mount flags if this is not the
+					// initial scan.
+					if (!suggest_mount_flags(partition, &amp;mountFlags))
+						return false;
+				} else {
+					BString mountFlagsKey(path.Path());
+					mountFlagsKey &lt;&lt; kMountFlagsKeyExtension;
+					if (fPrevious.FindInt32(mountFlagsKey.String(),
+							(int32*)&amp;mountFlags) &lt; B_OK) {
+						mountFlags = 0;
+					}
 				}
 
 				if (partition-&gt;Mount(NULL, mountFlags) == B_OK
@@ -169,11 +266,12 @@
 			}
 
 		private:
-			mount_mode	fNormalMode;
-			mount_mode	fRemovableMode;
-			bool		fInitialRescan;
-			BMessage&amp;	fPrevious;
-	} visitor(normal, removable, initialRescan, fSettings);
+			mount_mode		fNormalMode;
+			mount_mode		fRemovableMode;
+			bool			fInitialRescan;
+			BMessage&amp;		fPrevious;
+			partition_id	fOnlyOnDeviceID;
+	} visitor(normal, removable, initialRescan, fSettings, deviceID);
 
 	BDiskDeviceList devices;
 	status_t status = devices.Fetch();
@@ -183,7 +281,7 @@
 
 
 void
-AutoMounter::_MountVolume(BMessage *message)
+AutoMounter::_MountVolume(const BMessage* message)
 {
 	int32 id;
 	if (message-&gt;FindInt32(&quot;id&quot;, &amp;id) != B_OK)
@@ -195,33 +293,9 @@
 	if (roster.GetPartitionWithID(id, &amp;device, &amp;partition) != B_OK)
 		return;
 
-	uint32 mountFlags = 0;
-	if (partition-&gt;ContentType() == NULL
-		|| strcmp(partition-&gt;ContentType(), kPartitionTypeBFS) != 0) {
-		// not a BFS volume, suggest to the user to mount read-only
-		// until Haiku is more mature.
-		// TODO: would be nice to skip this for file systems which don't have
-		// support for writing anyways.
-		BString string;
-		// TODO: Use distro name instead of &quot;Haiku&quot;...
-		string &lt;&lt; &quot;The file system on this volume is not the Haiku file &quot;
-			&quot;system. It is strongly suggested to mount it in read-only mode.&quot;
-			&quot;This will prevent unintentional data loss because of errors &quot;
-			&quot;in Haiku.&quot;;
-		BAlert* alert = new BAlert(&quot;Mount Warning&quot;, string.String(),
-			&quot;Mount Read/Write&quot;, &quot;Cancel&quot;, &quot;Mount Read-only&quot;,
-			B_WIDTH_FROM_WIDEST, B_WARNING_ALERT);
-		int32 choice = alert-&gt;Go();
-		switch (choice) {
-			case 0:
-				break;
-			case 1:
-				return;
-			case 2:
-				mountFlags |= B_MOUNT_READ_ONLY;
-				break;
-		}
-	}
+	uint32 mountFlags;
+	if (!suggest_mount_flags(partition, &amp;mountFlags))
+		return;
 
 	status_t status = partition-&gt;Mount(NULL, mountFlags);
 	if (status &lt; B_OK) {
@@ -237,12 +311,14 @@
 {
 	BString text;
 	text &lt;&lt; &quot;Could not unmount disk \&quot;&quot; &lt;&lt; name &lt;&lt; &quot;\&quot;:\n\t&quot; &lt;&lt; strerror(error);
-	text &lt;&lt; &quot;\n\nShould I force unmounting the disk?\n\n&quot;
+	text &lt;&lt; &quot;\n\nShould unmounting be forced?\n\n&quot;
 		&quot;Note: if an application is currently writing to the volume, unmounting&quot;
 		&quot; it now might result in loss of data.\n&quot;;
 
-	int32 choice = (new BAlert(&quot;&quot;, text.String(), &quot;Cancel&quot;, &quot;Force Unmount&quot;,
-		NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT))-&gt;Go();
+	BAlert* alert = new BAlert(&quot;&quot;, text.String(), &quot;Cancel&quot;, &quot;Force Unmount&quot;,
+		NULL, B_WIDTH_AS_USUAL, B_WARNING_ALERT);
+	alert-&gt;SetShortcut(0, B_ESCAPE);
+	int32 choice = alert-&gt;Go();
 
 	return choice == 1;
 }
@@ -263,6 +339,13 @@
 AutoMounter::_UnmountAndEjectVolume(BPartition* partition, BPath&amp; mountPoint,
 	const char* name)
 {
+	BDiskDevice device;
+	if (partition == NULL) {
+		// Try to retrieve partition
+		BDiskDeviceRoster().FindPartitionByMountPoint(mountPoint.Path(),
+			&amp;device, &amp;partition);
+	}
+
 	status_t status;
 	if (partition != NULL)
 		status = partition-&gt;Unmount();
@@ -284,8 +367,46 @@
 		return;
 	}
 
-	// TODO: eject!
+	if (TrackerSettings().EjectWhenUnmounting() &amp;&amp; partition != NULL) {
+		// eject device if it doesn't have any mounted partitions left
+		class IsMountedVisitor : public BDiskDeviceVisitor {
+		public:
+			IsMountedVisitor()
+				:
+				fHasMounted(false)
+			{
+			}
 
+			virtual bool Visit(BDiskDevice* device)
+			{
+				return Visit(device, 0);
+			}
+
+			virtual bool Visit(BPartition* partition, int32 level)
+			{
+				if (partition-&gt;IsMounted()) {
+					fHasMounted = true;
+					return true;
+				}
+
+				return false;
+			}
+
+			bool HasMountedPartitions() const
+			{
+				return fHasMounted;
+			}
+
+		private:
+			bool	fHasMounted;
+		} visitor;
+
+		partition-&gt;Device()-&gt;VisitEachDescendant(&amp;visitor);
+
+		if (!visitor.HasMountedPartitions())
+			partition-&gt;Device()-&gt;Eject();
+	}
+
 	// remove the directory if it's a directory in rootfs
 	if (dev_for_path(mountPoint.Path()) == dev_for_path(&quot;/&quot;))
 		rmdir(mountPoint.Path());
@@ -495,9 +616,9 @@
 	while (volumeRoster.GetNextVolume(&amp;volume) == B_OK) {
         fs_info info;
         if (fs_stat_dev(volume.Device(), &amp;info) == 0
-			&amp;&amp; info.flags &amp; (B_FS_IS_REMOVABLE | B_FS_IS_PERSISTENT)) {
+			&amp;&amp; (info.flags &amp; (B_FS_IS_REMOVABLE | B_FS_IS_PERSISTENT)) != 0) {
 			message-&gt;AddString(info.device_name, info.volume_name);
-			
+
 			BString mountFlagsKey(info.device_name);
 			mountFlagsKey &lt;&lt; kMountFlagsKeyExtension;
 			uint32 mountFlags = 0;
@@ -510,7 +631,7 @@
 
 
 void
-AutoMounter::MessageReceived(BMessage *message)
+AutoMounter::MessageReceived(BMessage* message)
 {
 	switch (message-&gt;what) {
 		case kMsgInitialScan:
@@ -536,14 +657,28 @@
 			_WriteSettings();
 
 			if (rescanNow)
-				_MountVolumes(fNormalMode, fRemovableMode, false);
+				_MountVolumes(fNormalMode, fRemovableMode);
 			break;
 		}
 
 		case kMountAllNow:
-			_MountVolumes(kAllVolumes, kAllVolumes, false);
+			_MountVolumes(kAllVolumes, kAllVolumes);
 			break;
 
+		case B_DEVICE_UPDATE:
+			int32 event;
+			if (message-&gt;FindInt32(&quot;event&quot;, &amp;event) != B_OK
+				|| (event != B_DEVICE_MEDIA_CHANGED
+					&amp;&amp; event != B_DEVICE_ADDED))
+				break;
+
+			partition_id deviceID;
+			if (message-&gt;FindInt32(&quot;id&quot;, &amp;deviceID) != B_OK)
+				break;
+
+			_MountVolumes(kNoVolumes, fRemovableMode, false, deviceID);
+			break;
+
 #if 0
 		case B_NODE_MONITOR:
 		{
@@ -919,8 +1054,10 @@
 			text &lt;&lt; &quot;To unmount &quot; &lt;&lt; partition-&gt;VolumeName() &lt;&lt; &quot; some query &quot;
 			&quot;windows have to be closed. Would you like to close the query &quot;
 			&quot;windows?&quot;;
-			if ((new BAlert(&quot;&quot;, text.String(), &quot;Cancel&quot;, &quot;Close and unmount&quot;, NULL,
-				B_WIDTH_FROM_LABEL))-&gt;Go() == 0)
+			BAlert* alert = new BAlert(&quot;&quot;, text.String(), &quot;Cancel&quot;,
+				&quot;Close and unmount&quot;, NULL, B_WIDTH_FROM_LABEL);
+			alert-&gt;SetShortcut(0, B_ESCAPE);
+			if (alert-&gt;Go() == 0)
 				return partition;
 			tracker-&gt;CloseActiveQueryWindows(params-&gt;device);
 		}

Modified: haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.h
===================================================================
--- haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.h	2009-07-06 16:53:55 UTC (rev 31426)
+++ haiku/branches/developer/aldeck/tracker_refactor/src/kits/tracker/AutoMounter.h	2009-07-06 17:19:45 UTC (rev 31427)
@@ -42,6 +42,7 @@
 #ifndef __HAIKU__
 #	include &quot;DeviceMap.h&quot;
 #else
+#	include &lt;DiskDeviceDefs.h&gt;
 class BPartition;
 class BPath;
 #endif
@@ -57,49 +58,56 @@
 //	#pragma mark - Haiku Disk Device API
 
 class AutoMounter : public BLooper {
-	public:
-		AutoMounter();
-		virtual ~AutoMounter();
+public:
+								AutoMounter();
+	virtual						~AutoMounter();
 
-		virtual bool QuitRequested();
+	virtual	bool				QuitRequested();
 
-		void GetSettings(BMessage* message);
+			void				GetSettings(BMessage* message);
 
-	private:
-		enum mount_mode {
-			kNoVolumes,
-			kOnlyBFSVolumes,
-			kAllVolumes,
-			kRestorePreviousVolumes
-		};
+private:
+			enum mount_mode {
+				kNoVolumes,
+				kOnlyBFSVolumes,
+				kAllVolumes,
+				kRestorePreviousVolumes
+			};
 
-		void _MountVolumes(mount_mode normal, mount_mode removable,
-			bool initialRescan);
-		void _MountVolume(BMessage* message);
-		bool _SuggestForceUnmount(const char* name, status_t error);
-		void _ReportUnmountError(const char* name, status_t error);
-		void _UnmountAndEjectVolume(BPartition* partition, BPath&amp; mountPoint,
-			const char* name);
-		void _UnmountAndEjectVolume(BMessage* message);
+			void				_MountVolumes(mount_mode normal,
+									mount_mode removable,
+									bool initialRescan = false,
+									partition_id deviceID = -1);
+			void				_MountVolume(const BMessage* message);
+			bool				_SuggestForceUnmount(const char* name,
+									status_t error);
+			void				_ReportUnmountError(const char* name,
+									status_t error);
+			void				_UnmountAndEjectVolume(BPartition* partition,
+									BPath&amp; mountPoint, const char* name);
+			void				_UnmountAndEjectVolume(BMessage* message);

[... truncated: 13956 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017753.html">[Haiku-commits] r31426 - in haiku/trunk/docs: . userguide/en	userguide/en/applications userguide/en/preferences
</A></li>
	<LI>Next message: <A HREF="017755.html">[Haiku-commits] r31428 - haiku/trunk/docs/userguide/en/installation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17754">[ date ]</a>
              <a href="thread.html#17754">[ thread ]</a>
              <a href="subject.html#17754">[ subject ]</a>
              <a href="author.html#17754">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
