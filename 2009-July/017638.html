<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31358 - in haiku/trunk: build/jam	src/add-ons/media/plugins/avcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31358%20-%20in%20haiku/trunk%3A%20build/jam%0A%09src/add-ons/media/plugins/avcodec&In-Reply-To=%3C200907011852.n61Iqt5R011976%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017637.html">
   <LINK REL="Next"  HREF="017639.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31358 - in haiku/trunk: build/jam	src/add-ons/media/plugins/avcodec</H1>
    <B>stippi at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31358%20-%20in%20haiku/trunk%3A%20build/jam%0A%09src/add-ons/media/plugins/avcodec&In-Reply-To=%3C200907011852.n61Iqt5R011976%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31358 - in haiku/trunk: build/jam	src/add-ons/media/plugins/avcodec">stippi at mail.berlios.de
       </A><BR>
    <I>Wed Jul  1 20:52:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="017637.html">[Haiku-commits] r31357 -	haiku/trunk/src/apps/icon-o-matic/generic/gui/scrollview
</A></li>
        <LI>Next message: <A HREF="017639.html">[Haiku-commits] r31358 - in haiku/trunk: build/jam	src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17638">[ date ]</a>
              <a href="thread.html#17638">[ thread ]</a>
              <a href="subject.html#17638">[ subject ]</a>
              <a href="author.html#17638">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2009-07-01 20:52:48 +0200 (Wed, 01 Jul 2009)
New Revision: 31358
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31358&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31358&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/CodecTable.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/CodecTable.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/FFmpegPlugin.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/FFmpegPlugin.h
Removed:
   haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/avcodecplugin.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/Jamfile
Log:
Cleaned up the source file names and code locations in the avcodec plugin,
unified the Reader and Decoder plugins and renamed the add-on to &quot;ffmpeg&quot;.


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2009-07-01 18:50:22 UTC (rev 31357)
+++ haiku/trunk/build/jam/HaikuImage	2009-07-01 18:52:48 UTC (rev 31358)
@@ -122,7 +122,7 @@
 	#legacy.media_addon
 ;
 SYSTEM_ADD_ONS_MEDIA_PLUGINS = $(GPL_ONLY)ac3_decoder
-	aiff_reader asf_reader au_reader $(X86_ONLY)avcodec avi_reader
+	aiff_reader asf_reader au_reader avi_reader $(X86_ONLY)ffmpeg
 	matroska mov_reader
 	mp3_decoder mp3_reader
 	mp4_reader musepack

Copied: haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.cpp (from rev 31322, haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp)
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp	2009-06-30 10:14:54 UTC (rev 31322)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.cpp	2009-07-01 18:52:48 UTC (rev 31358)
@@ -0,0 +1,617 @@
+/*
+ * Copyright (C) 2001 Carlos Hasan
+ * Copyright (C) 2001 Fran&#231;ois Revol
+ * Copyright (C) 2001 Axel D&#246;rfler
+ * Copyright (C) 2004 Marcus Overhagen
+ * Copyright (C) 2009 Stephan Am&#223;us &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">superstippi at gmx.de</A>&gt;
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+
+//! libavcodec based decoder for Haiku
+
+#include &quot;AVCodecDecoder.h&quot;
+
+#include &lt;Debug.h&gt;
+#include &lt;OS.h&gt;
+#include &lt;Bitmap.h&gt;
+#include &lt;string.h&gt;
+
+#define DO_PROFILING 0
+
+#undef TRACE
+#define TRACE_AV_CODEC
+#ifdef TRACE_AV_CODEC
+#	define TRACE(x...)	printf(x)
+#else
+#	define TRACE(x...)
+#endif
+
+struct wave_format_ex {
+	uint16 format_tag;
+	uint16 channels;
+	uint32 frames_per_sec;
+	uint32 avg_bytes_per_sec;
+	uint16 block_align;
+	uint16 bits_per_sample;
+	uint16 extra_size;
+	// extra_data[extra_size]
+} _PACKED;
+
+static bigtime_t diff1 = 0, diff2 = 0;
+static long prof_cnt = 0;
+
+// uncommenting will make Decode() set the current thread priority to time
+// sharing, so it won't totally freeze if you busy-loop in there (to help debug
+// with CD Manager)
+//#define UNREAL
+ 
+AVCodecDecoder::AVCodecDecoder()
+	:	fHeader(),
+		fInfo(),
+		fInputFormat(),
+		fOutputVideoFormat(),
+		fFrame(0),
+		isAudio(false),
+		fCodec(NULL),
+		ffc(NULL),
+		fCodecInitDone(false),
+		conv_func(NULL),
+		fExtraData(NULL),
+		fExtraDataSize(0),
+		fBlockAlign(0),
+		fOutputBuffer(0)
+{
+	TRACE(&quot;AVCodecDecoder::AVCodecDecoder()\n&quot;);
+
+	// prevent multiple inits
+	static volatile vint32 ff_init_count = 0;
+	static bool ff_init_done = false;
+	if (atomic_add(&amp;ff_init_count, 1) &gt; 1) {
+		atomic_add(&amp;ff_init_count, -1);
+		// spin until the thread that is initing is done
+		while (!ff_init_done)
+			snooze(20000);
+	} else {
+		avcodec_init();
+		avcodec_register_all();
+		ff_init_done = true;
+	}
+
+	ffc = avcodec_alloc_context();
+	ffpicture = avcodec_alloc_frame();
+	opicture = avcodec_alloc_frame();
+}
+
+
+AVCodecDecoder::~AVCodecDecoder()
+{
+	TRACE(&quot;[%c] AVCodecDecoder::~AVCodecDecoder()\n&quot;, isAudio?('a'):('v'));
+
+#ifdef DO_PROFILING
+	if (prof_cnt &gt; 0) {
+			printf(&quot;[%c] profile: d1 = %lld, d2 = %lld (%Ld)\n&quot;,
+				isAudio?('a'):('v'), diff1/prof_cnt, diff2/prof_cnt,
+				fFrame);
+	}
+#endif
+
+	if (fCodecInitDone)
+		avcodec_close(ffc);
+
+	free(opicture);
+	free(ffpicture);
+	free(ffc);
+	
+	delete [] fExtraData;
+	delete [] fOutputBuffer;
+}
+
+
+void
+AVCodecDecoder::GetCodecInfo(media_codec_info *mci)
+{
+	sprintf(mci-&gt;short_name, &quot;ff:%s&quot;, fCodec-&gt;name);
+	sprintf(mci-&gt;pretty_name, &quot;%s (libavcodec %s)&quot;,
+		gCodecTable[ffcodec_index_in_table].prettyname, fCodec-&gt;name);
+}
+
+
+status_t
+AVCodecDecoder::Setup(media_format *ioEncodedFormat, const void *infoBuffer,
+	size_t infoSize)
+{
+	if (ioEncodedFormat-&gt;type != B_MEDIA_ENCODED_AUDIO
+		&amp;&amp; ioEncodedFormat-&gt;type != B_MEDIA_ENCODED_VIDEO)
+		return B_ERROR;
+		
+	isAudio = (ioEncodedFormat-&gt;type == B_MEDIA_ENCODED_AUDIO);
+	TRACE(&quot;[%c] AVCodecDecoder::Setup()\n&quot;, isAudio?('a'):('v'));
+
+	if (isAudio &amp;&amp; !fOutputBuffer)
+		fOutputBuffer = new char[AVCODEC_MAX_AUDIO_FRAME_SIZE];
+
+//#if DEBUG
+	char buffer[1024];
+	string_for_format(*ioEncodedFormat, buffer, sizeof(buffer));
+	TRACE(&quot;[%c]   input_format=%s\n&quot;, isAudio?('a'):('v'), buffer);
+	TRACE(&quot;[%c]   infoSize=%ld\n&quot;, isAudio?('a'):('v'), infoSize);
+	TRACE(&quot;[%c]   user_data_type=%08lx\n&quot;, isAudio?('a'):('v'),	ioEncodedFormat-&gt;user_data_type);
+	TRACE(&quot;[%c]   meta_data_size=%ld\n&quot;, isAudio?('a'):('v'), ioEncodedFormat-&gt;MetaDataSize());
+	TRACE(&quot;[%c]   info_size=%ld\n&quot;, isAudio?('a'):('v'), infoSize);
+//#endif
+
+	media_format_description descr;
+	for (int32 i = 0; gCodecTable[i].id; i++) {
+		ffcodec_index_in_table = i;
+		uint64 cid;
+		
+		if (BMediaFormats().GetCodeFor(*ioEncodedFormat, gCodecTable[i].family,
+				&amp;descr) == B_OK
+		    &amp;&amp; gCodecTable[i].type == ioEncodedFormat-&gt;type) {
+			switch(gCodecTable[i].family) {
+				case B_WAV_FORMAT_FAMILY:
+					cid = descr.u.wav.codec;
+					break;
+				case B_AIFF_FORMAT_FAMILY:
+					cid = descr.u.aiff.codec;
+					break;
+				case B_AVI_FORMAT_FAMILY:
+					cid = descr.u.avi.codec;
+					break;
+				case B_MPEG_FORMAT_FAMILY:
+					cid = descr.u.mpeg.id;
+					break;
+				case B_QUICKTIME_FORMAT_FAMILY:
+					cid = descr.u.quicktime.codec;
+					break;
+				case B_MISC_FORMAT_FAMILY:
+					cid = (((uint64)descr.u.misc.file_format) &lt;&lt; 32)
+						| descr.u.misc.codec;
+					break;
+				default:
+					puts(&quot;ERR family&quot;);
+					return B_ERROR;
+			}
+			TRACE(&quot;  0x%04lx codec id = \&quot;%c%c%c%c\&quot;\n&quot;, uint32(cid), (char)((cid &gt;&gt; 24) &amp; 0xff),
+				(char)((cid &gt;&gt; 16) &amp; 0xff), (char)((cid &gt;&gt; 8) &amp; 0xff),
+				(char)(cid &amp; 0xff));
+
+			if (gCodecTable[i].family == descr.family
+				&amp;&amp; gCodecTable[i].fourcc == cid) {
+				fCodec = avcodec_find_decoder(gCodecTable[i].id);
+				if (!fCodec) {
+					TRACE(&quot;AVCodecDecoder: unable to find the correct ffmpeg decoder &quot;
+						&quot;(id = %d)!!!\n&quot;,gCodecTable[i].id);
+					return B_ERROR;
+				}
+				TRACE(&quot;AVCodecDecoder: found decoder %s\n&quot;,fCodec-&gt;name);
+				
+				if (gCodecTable[i].family == B_WAV_FORMAT_FAMILY &amp;&amp; infoSize &gt;= sizeof(wave_format_ex)) {
+					const wave_format_ex *wfmt_data
+						= (const wave_format_ex *)infoBuffer;
+					size_t wfmt_size = infoSize;
+					if (wfmt_data &amp;&amp; wfmt_size) {
+						fBlockAlign = wfmt_data-&gt;block_align;
+						fExtraDataSize = wfmt_data-&gt;extra_size;
+						if (fExtraDataSize) {
+							fExtraData = new char [fExtraDataSize];
+							memcpy(fExtraData, wfmt_data + 1, fExtraDataSize);
+						}
+					}
+				} else {
+					fBlockAlign = ioEncodedFormat-&gt;u.encoded_audio.output.buffer_size;
+					TRACE(&quot;AVCodecDecoder: extra data size %ld\n&quot;,infoSize);
+					fExtraDataSize = infoSize;
+					if (fExtraDataSize) {
+						fExtraData = new char [fExtraDataSize];
+						memcpy(fExtraData, infoBuffer, fExtraDataSize);
+					}
+				}
+
+				fInputFormat = *ioEncodedFormat;
+				return B_OK;
+			}
+		}
+	}
+	printf(&quot;AVCodecDecoder::Setup failed!\n&quot;);
+	return B_ERROR;
+}
+
+
+status_t
+AVCodecDecoder::Seek(uint32 seekTo,
+				 int64 seekFrame, int64 *frame,
+				 bigtime_t seekTime, bigtime_t *time)
+{
+	// reset the ffmpeg codec
+	// to flush buffers, so we keep the sync
+	if (isAudio &amp;&amp; fCodecInitDone) {
+		fCodecInitDone = false;
+		avcodec_close(ffc);
+		fCodecInitDone = (avcodec_open(ffc, fCodec) &gt;= 0);
+	}
+	
+	if (seekTo == B_MEDIA_SEEK_TO_TIME) {
+		TRACE(&quot;AVCodecDecoder::Seek by time &quot;);
+		TRACE(&quot;from frame %Ld and time %.6f TO Required Time %.6f. &quot;, fFrame, fStartTime / 1000000.0, seekTime / 1000000.0);
+
+		*frame = (int64)(seekTime * fOutputFrameRate / 1000000LL);
+		*time = seekTime;
+	} else if (seekTo == B_MEDIA_SEEK_TO_FRAME) {
+		TRACE(&quot;AVCodecDecoder::Seek by Frame &quot;);
+		TRACE(&quot;from time %.6f and frame %Ld TO Required Frame %Ld. &quot;, fStartTime / 1000000.0, fFrame, seekFrame);
+
+		*time = (bigtime_t)(seekFrame * 1000000LL / fOutputFrameRate);
+		*frame = seekFrame;
+	} else
+		return B_BAD_VALUE;
+
+	fFrame = *frame;
+	fStartTime = *time;
+	TRACE(&quot;so new frame is %Ld at time %.6f\n&quot;, *frame, *time / 1000000.0);
+	return B_OK;
+}
+
+
+status_t
+AVCodecDecoder::NegotiateOutputFormat(media_format *inout_format)
+{
+	TRACE(&quot;[%c] AVCodecDecoder::NegotiateOutputFormat()\n&quot;, isAudio?('a'):('v'));
+
+	int result;
+	
+#if DEBUG
+	char buffer[1024];
+	string_for_format(*inout_format, buffer, sizeof(buffer));
+	TRACE(&quot;[%c]  in_format=%s\n&quot;, isAudio?('a'):('v'), buffer);
+#endif
+
+	if (isAudio) {
+		media_multi_audio_format outputAudioFormat;
+		outputAudioFormat = media_raw_audio_format::wildcard;
+		outputAudioFormat.format = media_raw_audio_format::B_AUDIO_SHORT;
+		outputAudioFormat.byte_order = B_MEDIA_HOST_ENDIAN;
+		outputAudioFormat.frame_rate
+			= fInputFormat.u.encoded_audio.output.frame_rate;
+		outputAudioFormat.channel_count
+			= fInputFormat.u.encoded_audio.output.channel_count;
+		outputAudioFormat.buffer_size
+			= 1024 * fInputFormat.u.encoded_audio.output.channel_count;
+		inout_format-&gt;type = B_MEDIA_RAW_AUDIO;
+		inout_format-&gt;u.raw_audio = outputAudioFormat;
+
+		ffc-&gt;bit_rate = (int) fInputFormat.u.encoded_audio.bit_rate;
+		ffc-&gt;sample_rate = (int) fInputFormat.u.encoded_audio.output.frame_rate;
+		ffc-&gt;channels = fInputFormat.u.encoded_audio.output.channel_count;
+		ffc-&gt;block_align = fBlockAlign;
+		ffc-&gt;extradata = (uint8_t *)fExtraData;
+		ffc-&gt;extradata_size = fExtraDataSize;
+
+		TRACE(&quot;bit_rate %d, sample_rate %d, channels %d, block_align %d, &quot;
+			&quot;extradata_size %d\n&quot;, ffc-&gt;bit_rate, ffc-&gt;sample_rate,
+			ffc-&gt;channels, ffc-&gt;block_align, ffc-&gt;extradata_size);
+
+		// close any previous instance
+		if (fCodecInitDone) {
+			fCodecInitDone = false;
+			avcodec_close(ffc);
+		}
+
+		// open new
+		result = avcodec_open(ffc, fCodec);
+		fCodecInitDone = (result &gt;= 0);
+
+		TRACE(&quot;audio: bit_rate = %d, sample_rate = %d, chans = %d Init = %d\n&quot;,
+			ffc-&gt;bit_rate, ffc-&gt;sample_rate, ffc-&gt;channels, result);
+
+		fStartTime = 0;
+		fOutputFrameSize = 2 * outputAudioFormat.channel_count;
+		fOutputFrameCount = outputAudioFormat.buffer_size / fOutputFrameSize;
+		fOutputFrameRate = outputAudioFormat.frame_rate;
+		fChunkBuffer = 0;
+		fChunkBufferOffset = 0;
+		fChunkBufferSize = 0;
+		fOutputBufferOffset = 0;
+		fOutputBufferSize = 0;
+		
+		inout_format-&gt;require_flags = 0;
+		inout_format-&gt;deny_flags = B_MEDIA_MAUI_UNDEFINED_FLAGS;
+
+		if (!fCodecInitDone) {
+			TRACE(&quot;avcodec_open() failed!\n&quot;);
+			return B_ERROR;
+		}
+
+		return B_OK;
+
+	} else {	// VIDEO
+
+		fOutputVideoFormat = fInputFormat.u.encoded_video.output;
+
+		ffc-&gt;width = fOutputVideoFormat.display.line_width;
+		ffc-&gt;height = fOutputVideoFormat.display.line_count;
+//		ffc-&gt;frame_rate = (int)(fOutputVideoFormat.field_rate
+//			* ffc-&gt;frame_rate_base);
+		
+		fOutputFrameRate = fOutputVideoFormat.field_rate;
+		
+		ffc-&gt;extradata = (uint8_t *)fExtraData;
+		ffc-&gt;extradata_size = fExtraDataSize;
+
+//		if (fInputFormat.MetaDataSize() &gt; 0) {
+//			ffc-&gt;extradata = (uint8_t *)fInputFormat.MetaData();
+//			ffc-&gt;extradata_size = fInputFormat.MetaDataSize();
+//		}
+
+		TRACE(&quot;#### requested video format 0x%x\n&quot;,
+			inout_format-&gt;u.raw_video.display.format);
+
+		// make MediaPlayer happy (if not in rgb32 screen depth and no overlay,
+		// it will only ask for YCbCr, which DrawBitmap doesn't handle, so the
+		// default colordepth is RGB32)
+		if (inout_format-&gt;u.raw_video.display.format == B_YCbCr422)
+			fOutputVideoFormat.display.format = B_YCbCr422;
+		else
+			fOutputVideoFormat.display.format = B_RGB32;
+
+		// search for a pixel-format the codec handles
+		// XXX We should try this a couple of times until it succeeds, each time
+		// XXX using another format pixel-format that is supported by the
+		// XXX decoder. But libavcodec doesn't seem to offer any way to tell the
+		// XXX decoder which format it should use.
+		conv_func = 0;
+		for (int i = 0; i &lt; 1; i++) { // iterate over supported codec formats
+			// close any previous instance
+			if (fCodecInitDone) {
+				fCodecInitDone = false;
+				avcodec_close(ffc);
+			}
+			// XXX set n-th ffc-&gt;pix_fmt here
+			if (avcodec_open(ffc, fCodec) &gt;= 0) {
+				fCodecInitDone = true;
+
+				conv_func = resolve_colorspace(fOutputVideoFormat.display.format, ffc-&gt;pix_fmt);
+			}
+			if (conv_func != 0)
+				break;
+		}
+
+		if (!fCodecInitDone) {
+			TRACE(&quot;avcodec_open() failed to init codec!\n&quot;);
+			return B_ERROR;
+		}
+
+		if (!conv_func) {
+			TRACE(&quot;no conv_func found or decoder has not set the pixel format yet!\n&quot;);
+		}
+
+		if (fOutputVideoFormat.display.format == B_YCbCr422) {
+			fOutputVideoFormat.display.bytes_per_row
+				= 2 * fOutputVideoFormat.display.line_width;
+		} else {
+			fOutputVideoFormat.display.bytes_per_row
+				= 4 * fOutputVideoFormat.display.line_width;
+		}
+
+		inout_format-&gt;type = B_MEDIA_RAW_VIDEO;
+		inout_format-&gt;u.raw_video = fOutputVideoFormat;
+
+		inout_format-&gt;require_flags = 0;
+		inout_format-&gt;deny_flags = B_MEDIA_MAUI_UNDEFINED_FLAGS;
+
+	#if DEBUG		
+		string_for_format(*inout_format, buffer, sizeof(buffer));
+		TRACE(&quot;[%c]  out_format=%s\n&quot;, isAudio?('a'):('v'), buffer);
+	#endif
+
+		TRACE(&quot;#### returned  video format 0x%x\n&quot;,
+			inout_format-&gt;u.raw_video.display.format);
+
+		return B_OK;
+	}
+}
+
+
+status_t
+AVCodecDecoder::Decode(void *out_buffer, int64 *out_frameCount,
+				media_header *mh, media_decode_info *info)
+{
+	const void *data;
+
+	if (!fCodecInitDone)
+		return B_BAD_VALUE;
+
+#ifdef DO_PROFILING
+	bigtime_t prof_t1, prof_t2, prof_t3;
+#endif
+
+#ifdef UNREAL
+	set_thread_priority(find_thread(NULL), B_NORMAL_PRIORITY);
+#endif
+
+//	TRACE(&quot;[%c] AVCodecDecoder::Decode() for time %Ld\n&quot;, isAudio?('a'):('v'), fStartTime);
+
+	mh-&gt;start_time = fStartTime;
+
+	if (isAudio) {
+
+//		TRACE(&quot;audio start_time %.6f\n&quot;, mh-&gt;start_time / 1000000.0);
+
+		char *output_buffer = (char *)out_buffer;
+		*out_frameCount = 0;
+		while (*out_frameCount &lt; fOutputFrameCount) {
+			if (fOutputBufferSize &lt; 0) {
+				TRACE(&quot;############ fOutputBufferSize %ld\n&quot;,
+					fOutputBufferSize);
+				fOutputBufferSize = 0;
+			}
+			if (fChunkBufferSize &lt; 0) {
+				TRACE(&quot;############ fChunkBufferSize %ld\n&quot;,
+					fChunkBufferSize);
+				fChunkBufferSize = 0;
+			}
+		
+			if (fOutputBufferSize &gt; 0) {
+				int32 frames = min_c(fOutputFrameCount - *out_frameCount,
+					fOutputBufferSize / fOutputFrameSize);
+				memcpy(output_buffer, fOutputBuffer + fOutputBufferOffset,
+					frames * fOutputFrameSize);
+				fOutputBufferOffset += frames * fOutputFrameSize;
+				fOutputBufferSize -= frames * fOutputFrameSize;
+				output_buffer += frames * fOutputFrameSize;
+				*out_frameCount += frames;
+				fStartTime += (bigtime_t)((1000000LL * frames) / fOutputFrameRate);
+				continue;
+			}
+			if (fChunkBufferSize == 0) {
+				media_header chunk_mh;
+				status_t err;
+				err = GetNextChunk(&amp;fChunkBuffer, &amp;fChunkBufferSize, &amp;chunk_mh);
+				if (err == B_LAST_BUFFER_ERROR) {
+					TRACE(&quot;Last Chunk with chunk size %ld\n&quot;,fChunkBufferSize);
+					fChunkBufferSize = 0;
+					return err;
+				}
+				if (err != B_OK || fChunkBufferSize &lt; 0) {
+					printf(&quot;GetNextChunk error %ld\n&quot;,fChunkBufferSize);
+					fChunkBufferSize = 0;
+					break;
+				}
+				fChunkBufferOffset = 0;
+				fStartTime = chunk_mh.start_time;
+				if (*out_frameCount == 0)
+					mh-&gt;start_time = chunk_mh.start_time;
+				continue;
+			}
+			if (fOutputBufferSize == 0) {
+				int len;
+				int out_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
+				len = avcodec_decode_audio2(ffc, (short *)fOutputBuffer,
+					&amp;out_size, (uint8_t*)fChunkBuffer + fChunkBufferOffset,
+					fChunkBufferSize);
+				if (len &lt; 0) {
+					TRACE(&quot;########### audio decode error, &quot;
+						&quot;fChunkBufferSize %ld, fChunkBufferOffset %ld\n&quot;,
+						fChunkBufferSize, fChunkBufferOffset);
+					out_size = 0;
+					len = 0;
+					fChunkBufferOffset = 0;
+					fChunkBufferSize = 0;
+//				} else {
+//					TRACE(&quot;audio decode: len %d, out_size %d\n&quot;, len, out_size);
+				}
+				fChunkBufferOffset += len;
+				fChunkBufferSize -= len;
+				fOutputBufferOffset = 0;
+				fOutputBufferSize = out_size;			
+			}
+		}
+		fFrame += *out_frameCount;
+
+//		TRACE(&quot;Played %Ld frames at time %Ld\n&quot;,*out_frameCount, mh-&gt;start_time);
+
+	} else {	// Video
+
+		media_header chunk_mh;
+		status_t err;
+		size_t size;
+
+		err = GetNextChunk(&amp;data, &amp;size, &amp;chunk_mh);
+		if (err != B_OK) {
+			TRACE(&quot;AVCodecDecoder::Decode(): error 0x%08lx from GetNextChunk()\n&quot;,	err);
+			return err;
+		}
+
+		mh-&gt;type = B_MEDIA_RAW_VIDEO;
+//		mh-&gt;start_time = chunk_mh.start_time;
+		mh-&gt;file_pos = 0;
+		mh-&gt;orig_size = 0;
+		mh-&gt;u.raw_video.field_gamma = 1.0;
+		mh-&gt;u.raw_video.field_sequence = fFrame;
+		mh-&gt;u.raw_video.field_number = 0;
+		mh-&gt;u.raw_video.pulldown_number = 0;
+		mh-&gt;u.raw_video.first_active_line = 1;
+		mh-&gt;u.raw_video.line_count = fOutputVideoFormat.display.line_count;
+
+		TRACE(&quot;[%c] start_time=%02d:%02d.%02d field_sequence=%lu\n&quot;,
+			isAudio ? ('a') : ('v'),
+			int((mh-&gt;start_time / 60000000) % 60),
+			int((mh-&gt;start_time / 1000000) % 60),
+			int((mh-&gt;start_time / 10000) % 100),
+			mh-&gt;u.raw_video.field_sequence);
+
+#ifdef DO_PROFILING
+		prof_t1 = system_time();
+#endif
+
+		int got_picture = 0;
+		int len;
+		len = avcodec_decode_video(ffc, ffpicture, &amp;got_picture,
+			(uint8_t *)data, size);
+
+//TRACE(&quot;FFDEC: PTS = %d:%d:%d.%d - ffc-&gt;frame_number = %ld &quot;
+//	&quot;ffc-&gt;frame_rate = %ld\n&quot;, (int)(ffc-&gt;pts / (60*60*1000000)),
+//	(int)(ffc-&gt;pts / (60*1000000)), (int)(ffc-&gt;pts / (1000000)),
+//	(int)(ffc-&gt;pts % 1000000), ffc-&gt;frame_number, ffc-&gt;frame_rate);
+//TRACE(&quot;FFDEC: PTS = %d:%d:%d.%d - ffc-&gt;frame_number = %ld &quot;
+//	&quot;ffc-&gt;frame_rate = %ld\n&quot;, (int)(ffpicture-&gt;pts / (60*60*1000000)),
+//	(int)(ffpicture-&gt;pts / (60*1000000)), (int)(ffpicture-&gt;pts / (1000000)),
+//	(int)(ffpicture-&gt;pts % 1000000), ffc-&gt;frame_number, ffc-&gt;frame_rate);
+
+		if (len &lt; 0) {
+			printf(&quot;[%c] AVCodecDecoder: error in decoding frame %lld\n&quot;,
+				isAudio?('a'):('v'), *out_frameCount);
+		}
+
+		if (got_picture) {
+#ifdef DO_PROFILING
+			prof_t2 = system_time();
+#endif
+//			TRACE(&quot;ONE FRAME OUT !! len=%d size=%ld (%s)\n&quot;, len, size,
+//				pixfmt_to_string(ffc-&gt;pix_fmt));
+
+			// Some decoders do not set pix_fmt until they have decoded 1 frame				
+			if (conv_func == 0) {
+				conv_func = resolve_colorspace(fOutputVideoFormat.display.format, ffc-&gt;pix_fmt);
+			}
+			opicture-&gt;data[0] = (uint8_t *)out_buffer;
+			opicture-&gt;linesize[0] = fOutputVideoFormat.display.bytes_per_row;
+			
+			if (conv_func) {
+				(*conv_func)(ffpicture, opicture,
+					fOutputVideoFormat.display.line_width,
+					fOutputVideoFormat.display.line_count);
+			}
+#ifdef DEBUG
+			dump_ffframe(ffpicture, &quot;ffpict&quot;);
+//			dump_ffframe(opicture, &quot;opict&quot;);
+#endif
+			*out_frameCount = 1;				
+			fFrame++;
+
+#ifdef DO_PROFILING
+			prof_t3 = system_time();
+			diff1 += prof_t2 - prof_t1;
+			diff2 += prof_t3 - prof_t2;
+			prof_cnt++;
+			if (!(fFrame % 10)) {
+				if (info) {
+					TRACE(&quot;[%c] profile: d1 = %lld, d2 = %lld (%Ld) required %Ld\n&quot;,
+						isAudio?('a'):('v'), diff1/prof_cnt, diff2/prof_cnt,
+						fFrame, info-&gt;time_to_decode);
+				} else {
+					TRACE(&quot;[%c] profile: d1 = %lld, d2 = %lld (%Ld) required %Ld\n&quot;,
+						isAudio?('a'):('v'), diff1/prof_cnt, diff2/prof_cnt,
+						fFrame, bigtime_t(1000000LL / fOutputFrameRate));
+				}
+			}
+#endif
+		}
+	}
+
+	fStartTime = (bigtime_t) (1000000LL * fFrame / fOutputFrameRate);
+
+	return B_OK;
+}
+

Copied: haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.h (from rev 31355, haiku/trunk/src/add-ons/media/plugins/avcodec/avcodecplugin.h)
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/avcodecplugin.h	2009-07-01 14:45:20 UTC (rev 31355)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/AVCodecDecoder.h	2009-07-01 18:52:48 UTC (rev 31358)
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2001 Carlos Hasan.
+ * Copyright (C) 2001 Fran&#231;ois Revol.
+ * Copyright (C) 2001 Axel D&#246;rfler.
+ * Copyright (C) 2004 Marcus Overhagen.
+ * Copyright (C) 2009 Stephan A&#223;mus &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">superstippi at gmx.de</A>&gt;.
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef AVCODEC_DECODER_H
+#define AVCODEC_DECODER_H
+
+//! libavcodec based decoder for Haiku
+
+#include &lt;MediaFormats.h&gt;
+
+#include &quot;DecoderPlugin.h&quot;
+#include &quot;ReaderPlugin.h&quot;
+
+#include &quot;CodecTable.h&quot;
+
+
+class AVCodecDecoder : public Decoder {
+public:
+								AVCodecDecoder();
+		
+	virtual						~AVCodecDecoder();
+		
+	virtual	void				GetCodecInfo(media_codec_info* mci);
+	
+	virtual	status_t			Setup(media_format* ioEncodedFormat,
+								   const void* infoBuffer, size_t infoSize);
+   
+	virtual	status_t			NegotiateOutputFormat(
+									media_format* outputFormat);
+	
+	virtual	status_t			Decode(void* outBuffer, int64* outFrameCount,
+						    		media_header* mediaHeader,
+						    		media_decode_info* info);
+
+	virtual	status_t			Seek(uint32 seekTo, int64 seekFrame,
+									int64* frame, bigtime_t seekTime,
+									bigtime_t* time);
+	
+	
+protected:
+			media_header		fHeader;
+			media_decode_info	fInfo;
+	
+//	friend class avCodecInputStream;
+		
+private:
+			media_format		fInputFormat;
+			media_raw_video_format fOutputVideoFormat;
+
+			int64				fFrame;
+			bool				isAudio;
+	
+			int					ffcodec_index_in_table;
+									// helps to find codecpretty
+		
+			// ffmpeg related datas
+			AVCodec*			fCodec;
+			AVCodecContext*		ffc;
+			AVFrame*			ffpicture;
+			AVFrame*			opicture;
+		
+			bool 				fCodecInitDone;
+
+			gfx_convert_func	conv_func; // colorspace convert func
+
+			char*				fExtraData;
+			int					fExtraDataSize;
+			int					fBlockAlign;
+		
+			bigtime_t			fStartTime;
+			int32				fOutputFrameCount;
+			float				fOutputFrameRate;
+			int					fOutputFrameSize; // sample size * channel count
+		
+			const void*			fChunkBuffer;
+			int32				fChunkBufferOffset;
+			size_t				fChunkBufferSize;
+
+			char*				fOutputBuffer;
+			int32				fOutputBufferOffset;
+			int32				fOutputBufferSize;
+
+};
+
+#endif // AVCODEC_DECODER_H

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.cpp	2009-07-01 18:50:22 UTC (rev 31357)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.cpp	2009-07-01 18:52:48 UTC (rev 31358)
@@ -87,14 +87,6 @@
 };
 
 
-void
-avcodec_register_all()
-{
-	// av_register_all() will call libavcodec's avcodec_register_all(),
-	// but we do not link against libavcodec in this plugin.
-}
-
-
 static int
 init_libavformat()
 {
@@ -103,9 +95,6 @@
 }
 
 
-static int dummy = init_libavformat();
-
-
 // #pragma mark - AVFormatReader
 
 
@@ -218,18 +207,3 @@
 }
 
 
-// #pragma mark -
-
-
-Reader*
-AVFormatPlugin::NewReader()
-{
-	return new(std::nothrow) AVFormatReader;
-}
-
-
-MediaPlugin*
-instantiate_plugin()
-{
-	return new(std::nothrow) AVFormatPlugin;
-}

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.h	2009-07-01 18:50:22 UTC (rev 31357)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/AVFormatReader.h	2009-07-01 18:52:48 UTC (rev 31358)
@@ -46,11 +46,4 @@
 };
 
 
-class AVFormatPlugin : public ReaderPlugin {
-public:
-			Reader*				NewReader();
-};
-
-MediaPlugin *instantiate_plugin();
-
 #endif // AV_FORMAT_READER_H

Copied: haiku/trunk/src/add-ons/media/plugins/avcodec/CodecTable.cpp (from rev 31355, haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp)
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp	2009-07-01 14:45:20 UTC (rev 31355)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/CodecTable.cpp	2009-07-01 18:52:48 UTC (rev 31358)
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2001 Carlos Hasan. All Rights Reserved.
+ * Copyright (C) 2001 Fran&#231;ois Revol. All Rights Reserved.
+ * Copyright (C) 2001 Axel D&#246;rfler. All Rights Reserved.
+ *
+ * Distributed under the terms of the MIT License.
+ */
+
+#include &quot;CodecTable.h&quot;
+
+#define HAS_WMA_AUDIO
+//#define HAS_MACE_AUDIO
+#define HAS_PHOTO_JPEG
+#define HAS_MOTION_JPEG
+
+#define FOURCC(a) B_SWAP_INT32(a)
+
+const struct codec_table gCodecTable[] = {
+
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x06, &quot;aLaw&quot;},
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_AIFF_FORMAT_FAMILY,	'alaw' , &quot;aLaw&quot;},
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_AIFF_FORMAT_FAMILY,	'ALAW' , &quot;aLaw&quot;},
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_MISC_FORMAT_FAMILY,	(uint64('au') &lt;&lt; 32) | 27, &quot;aLaw&quot;},
+
+	{CODEC_ID_PCM_MULAW,	B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'ulaw', &quot;&#181;Law&quot;},
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'alaw', &quot;aLaw&quot;},
+	{CODEC_ID_PCM_ALAW,		B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'ALAW', &quot;aLaw&quot;},
+
+	{CODEC_ID_PCM_MULAW,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x07, &quot;&#181;Law&quot;},
+	{CODEC_ID_PCM_MULAW,	B_MEDIA_ENCODED_AUDIO,	B_AIFF_FORMAT_FAMILY,	'ulaw', &quot;&#181;Law&quot;},
+	{CODEC_ID_PCM_MULAW,	B_MEDIA_ENCODED_AUDIO,	B_AIFF_FORMAT_FAMILY,	'ULAW', &quot;&#181;Law&quot;},
+	{CODEC_ID_PCM_MULAW,	B_MEDIA_ENCODED_AUDIO,	B_MISC_FORMAT_FAMILY,	(uint64('au') &lt;&lt; 32) | 1, &quot;&#181;Law&quot;},
+
+	{CODEC_ID_ADPCM_IMA_WAV,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x0011, &quot;IMA ADPCM&quot;},
+	{CODEC_ID_ADPCM_MS,			B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x0002, &quot;MS ADPCM&quot;},
+	{CODEC_ID_ADPCM_IMA_WAV,	B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	0x6D730011, &quot;IMA ADPCM&quot;},
+	{CODEC_ID_ADPCM_MS,			B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	0x6D730002, &quot;MS ADPCM&quot;},
+	{CODEC_ID_MP2,				B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	0x6D730050, &quot;MP Layer2&quot;},
+	{CODEC_ID_MP2,				B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	0x6D730055, &quot;MP Layer3&quot;},
+	{CODEC_ID_ADPCM_IMA_QT,		B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'ima4', &quot;Quicktime IMA4&quot;},
+	{CODEC_ID_ADPCM_IMA_QT,		B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'IMA4', &quot;Quicktime IMA4&quot;},
+	{CODEC_ID_AAC,			B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'mp4a', &quot;MPEG4 AAC&quot;},
+	{CODEC_ID_MPEG4,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'mp4v', &quot;MPEG4 Video&quot;},
+	{CODEC_ID_AAC,			B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'a4pm', &quot;MPEG4 AAC&quot;},
+	{CODEC_ID_MPEG4,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'v4pm', &quot;MPEG4 Video&quot;},
+	{CODEC_ID_AAC,			B_MEDIA_ENCODED_AUDIO,	B_MISC_FORMAT_FAMILY,	'mp4a', &quot;MPEG4 AAC&quot;},	/* For matroska */
+	{CODEC_ID_AAC,			B_MEDIA_ENCODED_AUDIO,	B_MISC_FORMAT_FAMILY,	'a4pm', &quot;MPEG4 AAC&quot;},	/* For matroska */
+
+#ifdef HAS_MACE_AUDIO
+	{CODEC_ID_MACE3,	B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'MAC3', &quot;MACE 3:1&quot;},
+	{CODEC_ID_MACE6,	B_MEDIA_ENCODED_AUDIO,	B_QUICKTIME_FORMAT_FAMILY,	'MAC6', &quot;MACE 6:1&quot;},
+#endif
+
+#if 0
+	{CODEC_ID_MP2,		B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x0050, &quot;MPEG Audio Layer 2&quot;},	/* mpeg audio layer 2 */
+	{CODEC_ID_MP2,		B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x0055, &quot;MPEG Audio Layer 3&quot;},	/* mpeg audio layer 3 */
+#endif
+
+	{CODEC_ID_WMAV1,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x160, &quot;MS WMA v1&quot;},
+	{CODEC_ID_WMAV2,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x161, &quot;MS WMA v2&quot;},
+
+	{CODEC_ID_CINEPAK,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('cvid'), &quot;Cinepak Video&quot;},
+	{CODEC_ID_CINEPAK,	B_MEDIA_ENCODED_VIDEO, B_QUICKTIME_FORMAT_FAMILY,	'cvid', &quot;Cinepak Video&quot;},
+
+	{CODEC_ID_MSRLE,	B_MEDIA_ENCODED_VIDEO, B_QUICKTIME_FORMAT_FAMILY,	FOURCC(' elr'), &quot;MS RLE&quot;}, // ???
+	
+	{CODEC_ID_MSRLE,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('RLE '), &quot;MS RLE&quot;}, // ???
+	{CODEC_ID_MSRLE,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('mrle'), &quot;MS RLE&quot;}, // ???
+	
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('MSVC'), &quot;MS Video 1 (MSVC)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('msvc'), &quot;MS Video 1 (msvc)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('CRAM'), &quot;MS Video 1 (CRAM)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('cram'), &quot;MS Video 1 (cram)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('WHAM'), &quot;MS Video 1 (WHAM)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('wham'), &quot;MS Video 1 (wham)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	0x01, &quot;MS Video 1 (1)&quot;},
+	{CODEC_ID_MSVIDEO1,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC(0x01), &quot;MS Video 1 (not 1)&quot;},
+
+	{CODEC_ID_H263,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('U263'), &quot;U263&quot;},
+	{CODEC_ID_H263,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('H263'), &quot;U263&quot;},
+//	{CODEC_ID_H263P,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('U263'), &quot;U263&quot;},
+	{CODEC_ID_H263I,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('I263'), &quot;Intel H263&quot;},	/* intel h263 */
+	{CODEC_ID_H263,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'h263', &quot;H263&quot;},
+	{CODEC_ID_H263,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'H263', &quot;H263&quot;},
+
+	{CODEC_ID_H264,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'h264', &quot;H264&quot;},
+	{CODEC_ID_H264,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'H264', &quot;H264&quot;},
+	{CODEC_ID_H264,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'x264', &quot;H264&quot;},
+	{CODEC_ID_H264,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'avc1', &quot;AVC&quot;},	/* MPEG-4 AVC */
+
+#ifdef HAS_PHOTO_JPEG
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'JPEG', &quot;Photo-JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'jpeg', &quot;Photo-JPEG&quot;}, /* used in BeOS_BBC.mov */
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'GEPJ', &quot;Photo-JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'gepj', &quot;Photo-JPEG&quot;}, /* used in BeOS_BBC.mov */
+#endif
+#ifdef HAS_MOTION_JPEG
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('MJPG'), &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('mjpg'), &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'AVDJ', &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'mjpa', &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEGB,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'mjpb', &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'JDVA', &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEG,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'apjm', &quot;Motion JPEG&quot;},
+	{CODEC_ID_MJPEGB,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'bpjm', &quot;Motion JPEG&quot;},
+#endif
+
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'FMP4', &quot;ffmpeg MPEG4&quot;},
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'4PMF', &quot;ffmpeg MPEG4&quot;},
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'DIVX', &quot;MPEG4&quot;},	/* OpenDivX */ /* XXX: doesn't seem to work */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'divx', &quot;MPEG4&quot;},	/* OpenDivX */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'mp4v', &quot;MPEG4&quot;},	/* MPEG-4 ASP */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'XVID', &quot;XviD (MPEG4)&quot;},	/* OpenDivX ??? XXX: test */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'FMP4', &quot;ffmpeg MPEG4&quot;},
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'4PMF', &quot;ffmpeg MPEG4&quot;},
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DIVX'), &quot;MPEG4&quot;},	/* OpenDivX */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('divx'), &quot;MPEG4&quot;},	/* OpenDivX */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('XVID'), &quot;XviD (MPEG4)&quot;},	/* XVID */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('xvid'), &quot;XviD (MPEG4)&quot;},	/* XVID */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DX50'), &quot;DivX 5 (MPEG4)&quot;},	/* DivX 5.0 */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('dx50'), &quot;DivX 5 (MPEG4)&quot;},	/* DivX 5.0 */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('3IV2'), &quot;3ivx v2&quot;},	/* 3ivx v2 */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('3iv2'), &quot;3ivx v2&quot;},	/* 3ivx v2 */
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('ffds'), &quot;ff DirectShow&quot;},	/* XVID Variant */
+
+	{CODEC_ID_MPEG4,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('\004\0\0\0'), &quot;MPEG4&quot;}, /* some broken avi use this */
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DIV3'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},	/* default signature when using MSMPEG4 */
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('div3'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DIV4'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('div4'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DIV5'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('div5'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DIV6'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('div6'), &quot;DivX ;-) (MS MPEG4 v3)&quot;},
+	{CODEC_ID_MSMPEG4V1,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('MP41'), &quot;MS MPEG4 v1&quot;},	/* microsoft mpeg4 v1 */
+	{CODEC_ID_MSMPEG4V1,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('mp41'), &quot;MS MPEG4 v1&quot;},	/* microsoft mpeg4 v1 */
+	{CODEC_ID_MSMPEG4V2,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('MP42'), &quot;MS MPEG4 v2&quot;},	/* seems to be broken */
+	{CODEC_ID_MSMPEG4V2,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('mp42'), &quot;MS MPEG4 v2&quot;},	/* seems to be broken */
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('MP43'), &quot;MS MPEG4 v3&quot;},	/* microsoft mpeg4 v3 */
+	{CODEC_ID_MPEG4,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('S4PM'), &quot;MPEG4&quot;},	/* mpeg4 */
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('34PM'), &quot;MS MPEG4 v3&quot;},	/* microsoft mpeg4 v3 */
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('mp43'), &quot;MS MPEG4 v3&quot;},	/* microsoft mpeg4 v3 */
+	{CODEC_ID_MSMPEG4V1,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('MPG4'), &quot;MS MPEG4&quot;},
+	{CODEC_ID_MSMPEG4V3,	B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('AP41'), &quot;Angel Potion (MS MPEG4 v3)&quot;},	/* AngelPotion 1 (it's so simple to release a new codec... :^) ) */
+
+	{CODEC_ID_WMV1,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('WMV1'), &quot;Microsoft WMV v1&quot;},
+	{CODEC_ID_WMV2,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('WMV2'), &quot;Microsoft WMV v2&quot;},
+	{CODEC_ID_WMV3,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('WMV3'), &quot;Microsoft WMV v3&quot;},
+
+//SVQ1
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'SVQ1', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'svq1', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'SVQ1', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'svq1', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'svqi', &quot;Sorenson Video v1&quot;}, /* (from QT specs) */
+
+	{CODEC_ID_SVQ3,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'SVQ3', &quot;Sorenson Video v3&quot;},
+	{CODEC_ID_SVQ3,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'svq3', &quot;Sorenson Video v3&quot;},
+
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'1QVS', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'1qvs', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'1QVS', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'1qvs', &quot;Sorenson Video v1&quot;},
+	{CODEC_ID_SVQ1,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'iqvs', &quot;Sorenson Video v1&quot;}, /* (from QT specs) */
+
+	{CODEC_ID_SVQ3,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'3QVS', &quot;Sorenson Video v3&quot;},
+	{CODEC_ID_SVQ3,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'3qvs', &quot;Sorenson Video v3&quot;},
+
+/*
+	{CODEC_ID_RV10,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'RV10', &quot;RealVideo v1&quot;},
+	{CODEC_ID_RV10,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	'rv10', &quot;RealVideo v1&quot;},
+	{CODEC_ID_RV10,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'RV10', &quot;RealVideo v1&quot;},
+	{CODEC_ID_RV10,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'rv10', &quot;RealVideo v1&quot;},
+*/
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('dvsd'), &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('DVSD'), &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('dvhd'), &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('dvsl'), &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('dv25'), &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'dvc ', &quot;DV Video&quot;},
+	{CODEC_ID_DVVIDEO,		B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'dvcp', &quot;DV Video&quot;},
+
+	{CODEC_ID_MPEG1VIDEO,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'MPG1', &quot;MPEG1 Video&quot;},
+	{CODEC_ID_MPEG1VIDEO,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'MPG2', &quot;MPEG1 Video&quot;},
+	{CODEC_ID_MPEG1VIDEO,	B_MEDIA_ENCODED_VIDEO,	B_QUICKTIME_FORMAT_FAMILY,	'PIM1', &quot;MPEG1 Video&quot;},
+
+	{CODEC_ID_MPEG1VIDEO,	B_MEDIA_ENCODED_VIDEO,	B_MPEG_FORMAT_FAMILY,	B_MPEG_1_VIDEO, &quot;MPEG1 Video&quot;},
+	{CODEC_ID_MPEG2VIDEO,	B_MEDIA_ENCODED_VIDEO,	B_MPEG_FORMAT_FAMILY,	B_MPEG_2_VIDEO, &quot;MPEG2 Video&quot;},
+
+	{CODEC_ID_INDEO3,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('iv31'), &quot;Indeo 3&quot;},
+	{CODEC_ID_INDEO3,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('iv32'), &quot;Indeo 3&quot;},
+	{CODEC_ID_INDEO3,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('IV31'), &quot;Indeo 3&quot;},
+	{CODEC_ID_INDEO3,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('IV32'), &quot;Indeo 3&quot;},
+
+	{CODEC_ID_INDEO5,		B_MEDIA_ENCODED_VIDEO,	B_AVI_FORMAT_FAMILY,	FOURCC('iv50'), &quot;Indeo 5&quot;},

[... truncated: 242 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017637.html">[Haiku-commits] r31357 -	haiku/trunk/src/apps/icon-o-matic/generic/gui/scrollview
</A></li>
	<LI>Next message: <A HREF="017639.html">[Haiku-commits] r31358 - in haiku/trunk: build/jam	src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17638">[ date ]</a>
              <a href="thread.html#17638">[ thread ]</a>
              <a href="subject.html#17638">[ subject ]</a>
              <a href="author.html#17638">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
