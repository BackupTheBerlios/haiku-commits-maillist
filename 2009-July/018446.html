<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31907 -	haiku/trunk/src/add-ons/kernel/partitioning_systems/intel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31907%20-%0A%09haiku/trunk/src/add-ons/kernel/partitioning_systems/intel&In-Reply-To=%3C200907291315.n6TDFHVY021410%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018445.html">
   <LINK REL="Next"  HREF="018448.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31907 -	haiku/trunk/src/add-ons/kernel/partitioning_systems/intel</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31907%20-%0A%09haiku/trunk/src/add-ons/kernel/partitioning_systems/intel&In-Reply-To=%3C200907291315.n6TDFHVY021410%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31907 -	haiku/trunk/src/add-ons/kernel/partitioning_systems/intel">bonefish at mail.berlios.de
       </A><BR>
    <I>Wed Jul 29 15:15:17 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="018445.html">[Haiku-commits] r31906 - in haiku/trunk/src/add-ons/kernel:	file_systems/ext2 partitioning_systems/efi
</A></li>
        <LI>Next message: <A HREF="018448.html">[Haiku-commits] r31908 - haiku/trunk/src/kits/app
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18446">[ date ]</a>
              <a href="thread.html#18446">[ thread ]</a>
              <a href="subject.html#18446">[ subject ]</a>
              <a href="author.html#18446">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-07-29 15:15:12 +0200 (Wed, 29 Jul 2009)
New Revision: 31907
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31907&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31907&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionLocker.h
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.h
Log:
Patch by Bryce Groff: Style cleanup.


Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionLocker.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionLocker.h	2009-07-29 13:12:48 UTC (rev 31906)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionLocker.h	2009-07-29 13:15:12 UTC (rev 31907)
@@ -27,7 +27,7 @@
 	partition_id PartitionId() const;
 
 protected:
-	const disk_device_data	*fDevice;
+	const disk_device_data*	fDevice;
 
 private:
 	partition_id			fPartitionID;

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp	2009-07-29 13:12:48 UTC (rev 31906)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp	2009-07-29 13:15:12 UTC (rev 31907)
@@ -58,7 +58,7 @@
 #ifdef _BOOT_MODE
 
 inline int32
-atomic_add(int32 *a, int32 num)
+atomic_add(int32* a, int32 num)
 {
 	int32 oldA = *a;
 	*a += num;
@@ -72,7 +72,7 @@
 
 // get_type_for_content_type (for both pm_* and ep_*)
 static status_t
-get_type_for_content_type(const char *contentType, char *type)
+get_type_for_content_type(const char* contentType, char* type)
 {
 	TRACE((&quot;intel: get_type_for_content_type(%s)\n&quot;,
 		   contentType));
@@ -111,7 +111,7 @@
 
 // pm_identify_partition
 static float
-pm_identify_partition(int fd, partition_data *partition, void **cookie)
+pm_identify_partition(int fd, partition_data* partition, void** cookie)
 {
 	// check parameters
 	if (fd &lt; 0 || !partition || !cookie)
@@ -127,7 +127,7 @@
 	}
 
 	// allocate a PartitionMap
-	PartitionMapCookie *map = new(nothrow) PartitionMapCookie;
+	PartitionMapCookie* map = new(nothrow) PartitionMapCookie;
 	if (!map)
 		return -1;
 
@@ -176,7 +176,7 @@
 
 // pm_scan_partition
 static status_t
-pm_scan_partition(int fd, partition_data *partition, void *cookie)
+pm_scan_partition(int fd, partition_data* partition, void* cookie)
 {
 	// check parameters
 	if (fd &lt; 0 || !partition || !cookie)
@@ -186,7 +186,7 @@
 		   partition-&gt;id, partition-&gt;offset, partition-&gt;size,
 		   partition-&gt;block_size));
 
-	PartitionMapCookie *map = (PartitionMapCookie*)cookie;
+	PartitionMapCookie* map = (PartitionMapCookie*)cookie;
 	// fill in the partition_data structure
 	partition-&gt;status = B_PARTITION_VALID;
 	partition-&gt;flags |= B_PARTITION_PARTITIONING_SYSTEM;
@@ -199,9 +199,9 @@
 	status_t error = B_OK;
 	int32 index = 0;
 	for (int32 i = 0; i &lt; 4; i++) {
-		PrimaryPartition *primary = map-&gt;PrimaryPartitionAt(i);
+		PrimaryPartition* primary = map-&gt;PrimaryPartitionAt(i);
 		if (!primary-&gt;IsEmpty()) {
-			partition_data *child = create_child_partition(partition-&gt;id,
+			partition_data* child = create_child_partition(partition-&gt;id,
 				index, partition-&gt;offset + primary-&gt;Offset(), primary-&gt;Size(),
 				-1);
 			index++;
@@ -237,7 +237,7 @@
 	} else {
 		partition-&gt;content_cookie = NULL;
 		for (int32 i = 0; i &lt; partition-&gt;child_count; i++) {
-			if (partition_data *child = get_child_partition(partition-&gt;id, i))
+			if (partition_data* child = get_child_partition(partition-&gt;id, i))
 				child-&gt;cookie = NULL;
 		}
 	}
@@ -248,10 +248,10 @@
 
 // pm_free_identify_partition_cookie
 static void
-pm_free_identify_partition_cookie(partition_data */*partition*/, void *cookie)
+pm_free_identify_partition_cookie(partition_data*/* partition*/, void* cookie)
 {
 	if (cookie) {
-		PartitionMapCookie *map = (PartitionMapCookie*)cookie;
+		PartitionMapCookie* map = (PartitionMapCookie*)cookie;
 		if (atomic_add(&amp;map-&gt;ref_count, -1) == 1)
 			delete map;
 	}
@@ -260,7 +260,7 @@
 
 // pm_free_partition_cookie
 static void
-pm_free_partition_cookie(partition_data *partition)
+pm_free_partition_cookie(partition_data* partition)
 {
 	// called for the primary partitions: the PrimaryPartition is allocated
 	// by the partition containing the partition map
@@ -271,7 +271,7 @@
 
 // pm_free_partition_content_cookie
 static void
-pm_free_partition_content_cookie(partition_data *partition)
+pm_free_partition_content_cookie(partition_data* partition)
 {
 	if (partition &amp;&amp; partition-&gt;content_cookie) {
 		pm_free_identify_partition_cookie(partition, partition-&gt;content_cookie);
@@ -299,7 +299,7 @@
 
 // ep_identify_partition
 static float
-ep_identify_partition(int fd, partition_data *partition, void **cookie)
+ep_identify_partition(int fd, partition_data* partition, void** cookie)
 {
 	// check parameters
 	if (fd &lt; 0 || !partition || !cookie || !partition-&gt;cookie)
@@ -314,7 +314,7 @@
 		|| strcmp(partition-&gt;type, kPartitionTypeIntelExtended)) {
 		return -1;
 	}
-	partition_data *parent = get_parent_partition(partition-&gt;id);
+	partition_data* parent = get_parent_partition(partition-&gt;id);
 	if (!parent || !parent-&gt;content_type
 		|| strcmp(parent-&gt;content_type, kPartitionTypeIntel)) {
 		return -1;
@@ -327,7 +327,7 @@
 
 // ep_scan_partition
 static status_t
-ep_scan_partition(int fd, partition_data *partition, void *cookie)
+ep_scan_partition(int fd, partition_data* partition, void* cookie)
 {
 	// check parameters
 	if (fd &lt; 0 || !partition || !partition-&gt;cookie)
@@ -336,10 +336,10 @@
 	TRACE((&quot;intel: ep_scan_partition(%d, %lld, %lld, %ld)\n&quot;, fd,
 		partition-&gt;offset, partition-&gt;size, partition-&gt;block_size));
 
-	partition_data *parent = get_parent_partition(partition-&gt;id);
+	partition_data* parent = get_parent_partition(partition-&gt;id);
 	if (!parent)
 		return B_ERROR;
-	PrimaryPartition *primary = (PrimaryPartition*)partition-&gt;cookie;
+	PrimaryPartition* primary = (PrimaryPartition*)partition-&gt;cookie;
 	// fill in the partition_data structure
 	partition-&gt;status = B_PARTITION_VALID;
 	partition-&gt;flags |= B_PARTITION_PARTITIONING_SYSTEM;
@@ -352,8 +352,8 @@
 	status_t error = B_OK;
 	int32 index = 0;
 	for (int32 i = 0; i &lt; primary-&gt;CountLogicalPartitions(); i++) {
-		LogicalPartition *logical = primary-&gt;LogicalPartitionAt(i);
-		partition_data *child = create_child_partition(partition-&gt;id, index,
+		LogicalPartition* logical = primary-&gt;LogicalPartitionAt(i);
+		partition_data* child = create_child_partition(partition-&gt;id, index,
 			parent-&gt;offset + logical-&gt;Offset(), logical-&gt;Size(), -1);
 		index++;
 		if (!child) {
@@ -389,7 +389,7 @@
 	if (error != B_OK) {
 		partition-&gt;content_cookie = NULL;
 		for (int32 i = 0; i &lt; partition-&gt;child_count; i++) {
-			if (partition_data *child = get_child_partition(partition-&gt;id, i))
+			if (partition_data* child = get_child_partition(partition-&gt;id, i))
 				child-&gt;cookie = NULL;
 		}
 	}
@@ -399,7 +399,7 @@
 
 // ep_free_identify_partition_cookie
 static void
-ep_free_identify_partition_cookie(partition_data *partition, void *cookie)
+ep_free_identify_partition_cookie(partition_data* partition, void* cookie)
 {
 	// nothing to do
 }
@@ -407,7 +407,7 @@
 
 // ep_free_partition_cookie
 static void
-ep_free_partition_cookie(partition_data *partition)
+ep_free_partition_cookie(partition_data* partition)
 {
 	// the logical partition's cookie belongs to the partition map partition
 	if (partition)
@@ -417,7 +417,7 @@
 
 // ep_free_partition_content_cookie
 static void
-ep_free_partition_content_cookie(partition_data *partition)
+ep_free_partition_content_cookie(partition_data* partition)
 {
 	// the extended partition's cookie belongs to the partition map partition
 	if (partition)
@@ -603,8 +603,8 @@
 
 
 #ifndef _BOOT_MODE
-extern &quot;C&quot; partition_module_info *modules[];
-_EXPORT partition_module_info *modules[] =
+extern &quot;C&quot; partition_module_info* modules[];
+_EXPORT partition_module_info* modules[] =
 {
 	&amp;intel_partition_map_module,
 	&amp;intel_extended_partition_module,

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.h	2009-07-29 13:12:48 UTC (rev 31906)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.h	2009-07-29 13:15:12 UTC (rev 31907)
@@ -13,27 +13,27 @@
 				uint32 mask = ~0);
 uint32		pm_get_supported_child_operations(partition_data* partition,
 				partition_data* child, uint32 mask = ~0);
-bool		pm_is_sub_system_for(partition_data *partition);
+bool		pm_is_sub_system_for(partition_data* partition);
 
-bool		pm_validate_resize(partition_data *partition, off_t *size);
-bool		pm_validate_resize_child(partition_data *partition,
-				partition_data *child, off_t *size);
-bool		pm_validate_move(partition_data *partition, off_t *start);
-bool		pm_validate_move_child(partition_data *partition,
-				partition_data *child, off_t *start);
-bool		pm_validate_set_type(partition_data *partition, const char *type);
-bool		pm_validate_initialize(partition_data *partition, char *name,
-				const char *parameters);
-bool		pm_validate_create_child(partition_data *partition, off_t *start,
-				off_t *size, const char *type, const char *name,
-				const char *parameters, int32 *index);
+bool		pm_validate_resize(partition_data* partition, off_t* size);
+bool		pm_validate_resize_child(partition_data* partition,
+				partition_data* child, off_t* size);
+bool		pm_validate_move(partition_data* partition, off_t* start);
+bool		pm_validate_move_child(partition_data* partition,
+				partition_data* child, off_t* start);
+bool		pm_validate_set_type(partition_data* partition, const char* type);
+bool		pm_validate_initialize(partition_data* partition, char* name,
+				const char* parameters);
+bool		pm_validate_create_child(partition_data* partition, off_t* start,
+				off_t* size, const char* type, const char* name,
+				const char* parameters, int32* index);
 
-status_t	pm_get_partitionable_spaces(partition_data *partition,
-				partitionable_space_data *buffer, int32 count,
-				int32 *actualCount);
-status_t	pm_get_next_supported_type(partition_data *partition, int32 *cookie,
-				char *_type);
-status_t	pm_shadow_changed(partition_data *partition, partition_data *child,
+status_t	pm_get_partitionable_spaces(partition_data* partition,
+				partitionable_space_data* buffer, int32 count,
+				int32* actualCount);
+status_t	pm_get_next_supported_type(partition_data* partition,
+				int32* cookie, char* _type);
+status_t	pm_shadow_changed(partition_data* partition, partition_data* child,
 				uint32 operation);
 
 status_t	pm_resize(int fd, partition_id partitionID, off_t size,
@@ -44,14 +44,14 @@
 				disk_job_id job);
 status_t	pm_move_child(int fd, partition_id partitionID,
 				partition_id childID, off_t offset, disk_job_id job);
-status_t	pm_set_type(int fd, partition_id partitionID, const char *type,
+status_t	pm_set_type(int fd, partition_id partitionID, const char* type,
 				disk_job_id job);
-status_t	pm_initialize(int fd, partition_id partitionID, const char *name,
-				const char *parameters, off_t partitionSize, disk_job_id job);
+status_t	pm_initialize(int fd, partition_id partitionID, const char* name,
+				const char* parameters, off_t partitionSize, disk_job_id job);
 status_t	pm_create_child(int fd, partition_id partitionID, off_t offset,
-				off_t size, const char *type, const char *name,
-				const char *parameters, disk_job_id job, 
-				partition_id *childID);
+				off_t size, const char* type, const char* name,
+				const char* parameters, disk_job_id job,
+				partition_id* childID);
 status_t	pm_delete_child(int fd, partition_id partitionID,
 				partition_id childID, disk_job_id job);
 
@@ -60,26 +60,26 @@
 				uint32 mask = ~0);
 uint32		ep_get_supported_child_operations(partition_data* partition,
 				partition_data* child, uint32 mask = ~0);
-bool		ep_is_sub_system_for(partition_data *partition);
+bool		ep_is_sub_system_for(partition_data* partition);
 
-bool		ep_validate_resize(partition_data *partition, off_t *size);
-bool		ep_validate_resize_child(partition_data *partition,
-				partition_data *child, off_t *_size);
-bool		ep_validate_move(partition_data *partition, off_t *start);
-bool		ep_validate_move_child(partition_data *partition,
-				partition_data *child, off_t *_start);
-bool		ep_validate_set_type(partition_data *partition, const char *type);
-bool		ep_validate_initialize(partition_data *partition, char *name,
-				const char *parameters);
-bool		ep_validate_create_child(partition_data *partition, off_t *_start,
-				off_t *_size, const char *type, const char* name,
-				const char *parameters, int32 *index);
-status_t	ep_get_partitionable_spaces(partition_data *partition,
-				partitionable_space_data *buffer, int32 count,
-				int32 *actualCount);
-status_t	ep_get_next_supported_type(partition_data *partition, int32 *cookie,
-				char *_type);
-status_t	ep_shadow_changed(partition_data *partition, partition_data *child,
+bool		ep_validate_resize(partition_data* partition, off_t* size);
+bool		ep_validate_resize_child(partition_data* partition,
+				partition_data* child, off_t* _size);
+bool		ep_validate_move(partition_data* partition, off_t* start);
+bool		ep_validate_move_child(partition_data* partition,
+				partition_data* child, off_t* _start);
+bool		ep_validate_set_type(partition_data* partition, const char* type);
+bool		ep_validate_initialize(partition_data* partition, char* name,
+				const char* parameters);
+bool		ep_validate_create_child(partition_data* partition, off_t* _start,
+				off_t* _size, const char* type, const char* name,
+				const char* parameters, int32* index);
+status_t	ep_get_partitionable_spaces(partition_data* partition,
+				partitionable_space_data* buffer, int32 count,
+				int32* actualCount);
+status_t	ep_get_next_supported_type(partition_data* partition,
+				int32* cookie, char* _type);
+status_t	ep_shadow_changed(partition_data* partition, partition_data* child,
 				uint32 operation);
 
 status_t	ep_resize(int fd, partition_id partitionID, off_t size,
@@ -90,14 +90,14 @@
 				disk_job_id job);
 status_t	ep_move_child(int fd, partition_id partitionID,
 				partition_id childID, off_t offset, disk_job_id job);
-status_t	ep_set_type(int fd, partition_id partitionID, const char *type,
+status_t	ep_set_type(int fd, partition_id partitionID, const char* type,
 				disk_job_id job);
-status_t	ep_initialize(int fd, partition_id partitionID, const char *name,
-				const char *parameters, off_t partitionSize, disk_job_id job);
+status_t	ep_initialize(int fd, partition_id partitionID, const char* name,
+				const char* parameters, off_t partitionSize, disk_job_id job);
 status_t	ep_create_child(int fd, partition_id partitionID, off_t offset,
-				off_t size, const char *type, const char *name,
-				const char *parameters, disk_job_id job,
-				partition_id *childID);
+				off_t size, const char* type, const char* name,
+				const char* parameters, disk_job_id job,
+				partition_id* childID);
 status_t	ep_delete_child(int fd, partition_id partitionID,
 				partition_id childID, disk_job_id job);
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018445.html">[Haiku-commits] r31906 - in haiku/trunk/src/add-ons/kernel:	file_systems/ext2 partitioning_systems/efi
</A></li>
	<LI>Next message: <A HREF="018448.html">[Haiku-commits] r31908 - haiku/trunk/src/kits/app
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18446">[ date ]</a>
              <a href="thread.html#18446">[ thread ]</a>
              <a href="subject.html#18446">[ subject ]</a>
              <a href="author.html#18446">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
