<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31710 - in haiku/trunk: headers/os/storage	src/kits/storage
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31710%20-%20in%20haiku/trunk%3A%20headers/os/storage%0A%09src/kits/storage&In-Reply-To=%3C200907230945.n6N9jtL4018913%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018191.html">
   <LINK REL="Next"  HREF="018194.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31710 - in haiku/trunk: headers/os/storage	src/kits/storage</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31710%20-%20in%20haiku/trunk%3A%20headers/os/storage%0A%09src/kits/storage&In-Reply-To=%3C200907230945.n6N9jtL4018913%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31710 - in haiku/trunk: headers/os/storage	src/kits/storage">axeld at mail.berlios.de
       </A><BR>
    <I>Thu Jul 23 11:45:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="018191.html">[Haiku-commits] r31709 - haiku/trunk/src/system/kernel/arch/ppc
</A></li>
        <LI>Next message: <A HREF="018194.html">[Haiku-commits] r31711 - in haiku/trunk: headers/os/storage	src/kits/storage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18193">[ date ]</a>
              <a href="thread.html#18193">[ thread ]</a>
              <a href="subject.html#18193">[ subject ]</a>
              <a href="author.html#18193">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2009-07-23 11:45:54 +0200 (Thu, 23 Jul 2009)
New Revision: 31710
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31710&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31710&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/storage/Query.h
   haiku/trunk/src/kits/storage/Query.cpp
Log:
* Cleanup.


Modified: haiku/trunk/headers/os/storage/Query.h
===================================================================
--- haiku/trunk/headers/os/storage/Query.h	2009-07-23 08:33:57 UTC (rev 31709)
+++ haiku/trunk/headers/os/storage/Query.h	2009-07-23 09:45:54 UTC (rev 31710)
@@ -1,23 +1,19 @@
-//----------------------------------------------------------------------
-//  This software is part of the OpenBeOS distribution and is covered 
-//  by the OpenBeOS license.
-//---------------------------------------------------------------------
-/*!
-	\file Query.h
-	BQuery interface declaration.
-*/
-
+/*
+ * Copyright 2002-2009, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
 #ifndef _QUERY_H
 #define _QUERY_H
 
+
 #include &lt;EntryList.h&gt;
 #include &lt;Messenger.h&gt;
 #include &lt;OS.h&gt;
-#include &lt;SupportDefs.h&gt;
 
 class BVolume;
 struct entry_ref;
 
+
 namespace BPrivate {
 	namespace Storage {
 		class QueryNode;
@@ -43,81 +39,84 @@
 	_B_RESERVED_OP_	= 0x100000
 } query_op;
 
+
 /*!
 	\class BQuery
 	\brief Represents a live or non-live file system query
-	
+
 	Provides an interface for creating file system queries. Implements
 	the BEntryList for iterating through the found entries.
 
 	\author &lt;a href='mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at users.sf.net</A>'&gt;Ingo Weinhold&lt;/a&gt;
-	
+
 	\version 0.0.0
 */
 class BQuery : public BEntryList {
 public:
-	BQuery();
-	virtual ~BQuery();
+							BQuery();
+	virtual					~BQuery();
 
-	status_t Clear();
+			status_t		Clear();
 
-	status_t PushAttr(const char *attrName);
-	status_t PushOp(query_op op);
+			status_t		PushAttr(const char* attrName);
+			status_t		PushOp(query_op op);
 
-	status_t PushUInt32(uint32 value);
-	status_t PushInt32(int32 value);
-	status_t PushUInt64(uint64 value);
-	status_t PushInt64(int64 value);
-	status_t PushFloat(float value);
-	status_t PushDouble(double value);
-	status_t PushString(const char *value, bool caseInsensitive = false);
-	status_t PushDate(const char *date);
+			status_t		PushUInt32(uint32 value);
+			status_t		PushInt32(int32 value);
+			status_t		PushUInt64(uint64 value);
+			status_t		PushInt64(int64 value);
+			status_t		PushFloat(float value);
+			status_t		PushDouble(double value);
+			status_t		PushString(const char* value,
+								bool caseInsensitive = false);
+			status_t		PushDate(const char* date);
 
-	status_t SetVolume(const BVolume *volume);
-	status_t SetPredicate(const char *expression);
-	status_t SetTarget(BMessenger messenger);
+			status_t		SetVolume(const BVolume* volume);
+			status_t		SetPredicate(const char* expression);
+			status_t		SetTarget(BMessenger messenger);
 
-	bool IsLive() const;
+			bool			IsLive() const;
 
-	status_t GetPredicate(char *buffer, size_t length);
-	status_t GetPredicate(BString *predicate);
-	size_t PredicateLength();
+			status_t		GetPredicate(char* buffer, size_t length);
+			status_t		GetPredicate(BString* predicate);
+			size_t			PredicateLength();
 
-	dev_t TargetDevice() const;
+			dev_t			TargetDevice() const;
 
-	status_t Fetch();
+			status_t		Fetch();
 
 	// BEntryList interface
-	virtual status_t GetNextEntry(BEntry *entry, bool traverse = false);
-	virtual status_t GetNextRef(entry_ref *ref);
-	virtual int32 GetNextDirents(struct dirent *buf, size_t length,
+	virtual	status_t		GetNextEntry(BEntry* entry, bool traverse = false);
+	virtual	status_t		GetNextRef(entry_ref* ref);
+	virtual	int32			GetNextDirents(struct dirent* buffer, size_t length,
 								 int32 count = INT_MAX);
-	virtual status_t Rewind();
-	virtual int32 CountEntries();
+	virtual	status_t		Rewind();
+	virtual	int32			CountEntries();
 
 private:
-	bool _HasFetched() const;
-	status_t _PushNode(BPrivate::Storage::QueryNode *node, bool deleteOnError);
-	status_t _SetPredicate(const char *expression);
-	status_t _EvaluateStack();
+			bool			_HasFetched() const;
+			status_t		_PushNode(BPrivate::Storage::QueryNode* node,
+								bool deleteOnError);
+			status_t		_SetPredicate(const char* expression);
+			status_t		_EvaluateStack();
 
 	// FBC
-	virtual void _QwertyQuery1();
-	virtual void _QwertyQuery2();
-	virtual void _QwertyQuery3();
-	virtual void _QwertyQuery4();
-	virtual void _QwertyQuery5();
-	virtual void _QwertyQuery6();
+	virtual	void			_QwertyQuery1();
+	virtual	void			_QwertyQuery2();
+	virtual	void			_QwertyQuery3();
+	virtual	void			_QwertyQuery4();
+	virtual	void			_QwertyQuery5();
+	virtual	void			_QwertyQuery6();
 
 private:
-	int32		_reservedData[4];	// FBC
-	BPrivate::Storage::QueryStack *fStack;
-	char		*fPredicate;
-	dev_t		fDevice;
-	bool		fLive;
-	port_id		fPort;
-	long		fToken;
-	int			fQueryFd;
+			BPrivate::Storage::QueryStack* fStack;
+			char*			fPredicate;
+			dev_t			fDevice;
+			bool			fLive;
+			port_id			fPort;
+			long			fToken;
+			int				fQueryFd;
+			int32			_reservedData[4];
 };
 
 #endif	// _QUERY_H

Modified: haiku/trunk/src/kits/storage/Query.cpp
===================================================================
--- haiku/trunk/src/kits/storage/Query.cpp	2009-07-23 08:33:57 UTC (rev 31709)
+++ haiku/trunk/src/kits/storage/Query.cpp	2009-07-23 09:45:54 UTC (rev 31710)
@@ -1,20 +1,23 @@
-//----------------------------------------------------------------------
-//  This software is part of the Haiku distribution and is covered 
-//  by the MIT license.
-//---------------------------------------------------------------------
-/*!
-	\file Query.cpp
-	BQuery implementation.
-*/
+/*
+ * Copyright 2002-2009, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Tyler Dauwalder
+ *		Ingo Weinhold
+ *		Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+ */
 
+
+#include &lt;Query.h&gt;
+
 #include &lt;fcntl.h&gt;
 #include &lt;new&gt;
-#include &lt;parsedate.h&gt;
 #include &lt;time.h&gt;
 
 #include &lt;Entry.h&gt;
 #include &lt;fs_query.h&gt;
-#include &lt;Query.h&gt;
+#include &lt;parsedate.h&gt;
 #include &lt;Volume.h&gt;
 
 #include &lt;MessengerPrivate.h&gt;
@@ -26,24 +29,23 @@
 using namespace std;
 using namespace BPrivate::Storage;
 
-// BQuery
 
-// constructor
 /*!	\brief Creates an uninitialized BQuery.
 */
 BQuery::BQuery()
-	  : BEntryList(),
-		fStack(NULL),
-		fPredicate(NULL),
-		fDevice((dev_t)B_ERROR),
-		fLive(false),
-		fPort(B_ERROR),
-		fToken(0),
-		fQueryFd(-1)
+	:
+	BEntryList(),
+	fStack(NULL),
+	fPredicate(NULL),
+	fDevice((dev_t)B_ERROR),
+	fLive(false),
+	fPort(B_ERROR),
+	fToken(0),
+	fQueryFd(-1)
 {
 }
 
-// destructor
+
 /*!	\brief Frees all resources associated with the object.
 */
 BQuery::~BQuery()
@@ -51,7 +53,7 @@
 	Clear();
 }
 
-// Clear
+
 /*!	\brief Resets the object to a uninitialized state.
 	\return \c B_OK
 */
@@ -77,7 +79,7 @@
 	return error;
 }
 
-// PushAttr
+
 /*!	\brief Pushes an attribute name onto the BQuery's predicate stack.
 	\param attrName the attribute name
 	\return
@@ -93,12 +95,12 @@
 		  to be called and Clear() also deletes the predicate.
 */
 status_t
-BQuery::PushAttr(const char *attrName)
+BQuery::PushAttr(const char* attrName)
 {
 	return _PushNode(new(nothrow) AttributeNode(attrName), true);
 }
 
-// PushOp
+
 /*!	\brief Pushes an operator onto the BQuery's predicate stack.
 	\param op the code representing the operator
 	\return
@@ -141,7 +143,7 @@
 	return error;
 }
 
-// PushUInt32
+
 /*!	\brief Pushes a uint32 value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -162,7 +164,7 @@
 	return _PushNode(new(nothrow) UInt32ValueNode(value), true);
 }
 
-// PushInt32
+
 /*!	\brief Pushes an int32 value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -183,7 +185,7 @@
 	return _PushNode(new(nothrow) Int32ValueNode(value), true);
 }
 
-// PushUInt64
+
 /*!	\brief Pushes a uint64 value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -204,7 +206,7 @@
 	return _PushNode(new(nothrow) UInt64ValueNode(value), true);
 }
 
-// PushInt64
+
 /*!	\brief Pushes an int64 value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -225,7 +227,7 @@
 	return _PushNode(new(nothrow) Int64ValueNode(value), true);
 }
 
-// PushFloat
+
 /*!	\brief Pushes a float value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -246,7 +248,7 @@
 	return _PushNode(new(nothrow) FloatValueNode(value), true);
 }
 
-// PushDouble
+
 /*!	\brief Pushes a double value onto the BQuery's predicate stack.
 	\param value the value
 	\return
@@ -267,7 +269,7 @@
 	return _PushNode(new(nothrow) DoubleValueNode(value), true);
 }
 
-// PushString
+
 /*!	\brief Pushes a string value onto the BQuery's predicate stack.
 	\param value the value
 	\param caseInsensitive \c true, if the case of the string should be
@@ -285,12 +287,12 @@
 		  to be called and Clear() also deletes the predicate.
 */
 status_t
-BQuery::PushString(const char *value, bool caseInsensitive)
+BQuery::PushString(const char* value, bool caseInsensitive)
 {
 	return _PushNode(new(nothrow) StringNode(value, caseInsensitive), true);
 }
 
-// PushDate
+
 /*!	\brief Pushes a date value onto the BQuery's predicate stack.
 	The supplied date can be any string understood by the POSIX function
 	parsedate().
@@ -306,22 +308,15 @@
 		  to be called and Clear() also deletes the predicate.
 */
 status_t
-BQuery::PushDate(const char *date)
+BQuery::PushDate(const char* date)
 {
-	status_t error = (date ? B_OK : B_BAD_VALUE);
-	if (error == B_OK) {
-		time_t t;
-		time(&amp;t);
-		t = parsedate(date, t);
-		if (t &lt; 0)
-			error = B_BAD_VALUE;
-	}
-	if (error == B_OK)
-		error =  _PushNode(new(nothrow) DateNode(date), true);
-	return error;
+	if (date == NULL || !date[0] || parsedate(date, time(NULL)) &lt; 0)
+		return B_BAD_VALUE;
+
+	return _PushNode(new(nothrow) DateNode(date), true);
 }
 
-// SetVolume
+
 /*!	\brief Sets the BQuery's volume.
 	A query is restricted to one volume. This method sets this volume. It
 	fails, if called after Fetch(). To reuse a BQuery object it has to be
@@ -332,21 +327,22 @@
 	- \c B_NOT_ALLOWED: SetVolume() was called after Fetch().
 */
 status_t
-BQuery::SetVolume(const BVolume *volume)
+BQuery::SetVolume(const BVolume* volume)
 {
-	status_t error = (volume ? B_OK : B_BAD_VALUE);
-	if (error == B_OK &amp;&amp; _HasFetched())
-		error = B_NOT_ALLOWED;
-	if (error == B_OK) {
-		if (volume-&gt;InitCheck() == B_OK)
-			fDevice = volume-&gt;Device();
-		else
-			fDevice = (dev_t)B_ERROR;
-	}
-	return error;
+	if (volume == NULL)
+		return B_BAD_VALUE;
+	if (_HasFetched())
+		return B_NOT_ALLOWED;
+
+	if (volume-&gt;InitCheck() == B_OK)
+		fDevice = volume-&gt;Device();
+	else
+		fDevice = (dev_t)B_ERROR;
+
+	return B_OK;
 }
 
-// SetPredicate
+
 /*!	\brief Sets the BQuery's predicate.
 	A predicate can be set either using this method or constructing one on
 	the predicate stack. The two methods can not be mixed. The letter one
@@ -360,7 +356,7 @@
 	- \c B_NO_MEMORY: Insufficient memory to store the predicate.
 */
 status_t
-BQuery::SetPredicate(const char *expression)
+BQuery::SetPredicate(const char* expression)
 {
 	status_t error = (expression ? B_OK : B_BAD_VALUE);
 	if (error == B_OK &amp;&amp; _HasFetched())
@@ -370,7 +366,7 @@
 	return error;
 }
 
-// SetTarget
+
 /*!	\brief Sets the BQuery's target and makes the query live.
 	The query update messages are sent to the specified target. They might
 	roll in immediately after calling Fetch().
@@ -397,7 +393,7 @@
 	return error;
 }
 
-// IsLive
+
 /*!	\brief Returns whether the query associated with this object is live.
 	\return \c true, if the query is live, \c false otherwise
 */
@@ -407,7 +403,7 @@
 	return fLive;
 }
 
-// GetPredicate
+
 /*!	\brief Returns the BQuery's predicate.
 	Regardless of whether the predicate has been constructed using the
 	predicate stack or set via SetPredicate(), this method returns a
@@ -423,7 +419,7 @@
 		  You can't interleave Push*() and GetPredicate() calls.
 */
 status_t
-BQuery::GetPredicate(char *buffer, size_t length)
+BQuery::GetPredicate(char* buffer, size_t length)
 {
 	status_t error = (buffer ? B_OK : B_BAD_VALUE);
 	if (error == B_OK)
@@ -437,7 +433,7 @@
 	return error;
 }
 
-// GetPredicate
+
 /*!	\brief Returns the BQuery's predicate.
 	Regardless of whether the predicate has been constructed using the
 	predicate stack or set via SetPredicate(), this method returns a
@@ -452,7 +448,7 @@
 		  You can't interleave Push*() and GetPredicate() calls.
 */
 status_t
-BQuery::GetPredicate(BString *predicate)
+BQuery::GetPredicate(BString* predicate)
 {
 	status_t error = (predicate ? B_OK : B_BAD_VALUE);
 	if (error == B_OK)
@@ -464,7 +460,7 @@
 	return error;
 }
 
-// PredicateLength
+
 /*!	\brief Returns the length of the BQuery's predicate string.
 	Regardless of whether the predicate has been constructed using the
 	predicate stack or set via SetPredicate(), this method returns the length
@@ -487,11 +483,10 @@
 	return size;
 }
 
-// TargetDevice
+
 /*!	\brief Returns the device ID identifying the BQuery's volume.
 	\return the device ID of the BQuery's volume or \c B_NO_INIT, if the
 			volume isn't set.
-	
 */
 dev_t
 BQuery::TargetDevice() const
@@ -499,7 +494,7 @@
 	return fDevice;
 }
 
-// Fetch
+
 /*!	\brief Tells the BQuery to start fetching entries satisfying the predicate.
 	After Fetch() has been called GetNextEntry(), GetNextRef() and
 	GetNextDirents() can be used to retrieve the enties. Live query updates
@@ -535,9 +530,9 @@
 }
 
 
-// BEntryList interface
+//	#pragma mark - BEntryList interface
 
-// GetNextEntry
+
 /*!	\brief Returns the BQuery's next entry as a BEntry.
 	Places the next entry in the list in \a entry, traversing symlinks if
 	\a traverse is \c true.
@@ -553,7 +548,7 @@
 	- \c B_FILE_ERROR: Fetch() has not been called before.
 */
 status_t
-BQuery::GetNextEntry(BEntry *entry, bool traverse)
+BQuery::GetNextEntry(BEntry* entry, bool traverse)
 {
 	status_t error = (entry ? B_OK : B_BAD_VALUE);
 	if (error == B_OK) {
@@ -565,7 +560,7 @@
 	return error;
 }
 
-// GetNextRef
+
 /*!	\brief Returns the BQuery's next entry as an entry_ref.
 	Places an entry_ref to the next entry in the list into \a ref.
 	\param ref a pointer to an entry_ref to be filled in with the data of the
@@ -579,7 +574,7 @@
 	- \c B_FILE_ERROR: Fetch() has not been called before.
 */
 status_t
-BQuery::GetNextRef(entry_ref *ref)
+BQuery::GetNextRef(entry_ref* ref)
 {
 	status_t error = (ref ? B_OK : B_BAD_VALUE);
 	if (error == B_OK &amp;&amp; !_HasFetched())
@@ -604,7 +599,7 @@
 	return error;
 }
 
-// GetNextDirents
+
 /*!	\brief Returns the BQuery's next entries as dirent structures.
 	Reads a number of entries into the array of dirent structures pointed to by
 	\a buf. Reads as many but no more than \a count entries, as many entries as
@@ -622,16 +617,16 @@
 	- \c B_FILE_ERROR: Fetch() has not been called before.
 */
 int32
-BQuery::GetNextDirents(struct dirent *buf, size_t length, int32 count)
+BQuery::GetNextDirents(struct dirent* buffer, size_t length, int32 count)
 {
-	if (!buf)
+	if (!buffer)
 		return B_BAD_VALUE;
 	if (!_HasFetched())
 		return B_FILE_ERROR;
-	return _kern_read_dir(fQueryFd, buf, length, count);
+	return _kern_read_dir(fQueryFd, buffer, length, count);
 }
 
-// Rewind
+
 /*!	\brief Rewinds the entry list back to the first entry.
 
 	Unlike R5 Haiku implements this method for BQuery.
@@ -648,7 +643,7 @@
 	return _kern_rewind_dir(fQueryFd);
 }
 
-// CountEntries
+
 /*!	\brief Unimplemented method of the BEntryList interface.
 	\return 0.
 */
@@ -658,7 +653,7 @@
 	return B_ERROR;
 }
 
-// _HasFetched
+
 /*!	Returns whether Fetch() has already been called on this object.
 	\return \c true, if Fetch() has successfully been invoked, \c false
 			otherwise.
@@ -666,10 +661,10 @@
 bool
 BQuery::_HasFetched() const
 {
-	return (fQueryFd &gt;= 0);
+	return fQueryFd &gt;= 0;
 }
 
-// _PushNode
+
 /*!	\brief Pushs a node onto the predicate stack.
 	If the stack has not been allocate until this time, this method does
 	allocate it.
@@ -679,7 +674,7 @@
 	node and thus is responsible for deleting it, if \a deleteOnError is
 	\c false. If it is \c true, the node is deleted, if an error occurs.
 	\param node the node to be pushed
-	\param deleteOnError 
+	\param deleteOnError
 	\return
 	- \c B_OK: Everything went fine.
 	- \c B_NO_MEMORY: \c NULL \a node or insuffient memory to allocate the
@@ -687,7 +682,7 @@
 	- \c B_NOT_ALLOWED: _PushNode() was called after Fetch().
 */
 status_t
-BQuery::_PushNode(QueryNode *node, bool deleteOnError)
+BQuery::_PushNode(QueryNode* node, bool deleteOnError)
 {
 	status_t error = (node ? B_OK : B_NO_MEMORY);
 	if (error == B_OK &amp;&amp; _HasFetched())
@@ -705,7 +700,7 @@
 	return error;
 }
 
-// _SetPredicate
+
 /*!	\brief Helper method to set the BQuery's predicate.
 	It is not checked whether Fetch() has already been invoked.
 	\param predicate the predicate string
@@ -714,7 +709,7 @@
 	- \c B_NO_MEMORY: Insufficient memory to store the predicate.
 */
 status_t
-BQuery::_SetPredicate(const char *expression)
+BQuery::_SetPredicate(const char* expression)
 {
 	status_t error = B_OK;
 	// unset the old predicate
@@ -731,7 +726,7 @@
 	return error;
 }
 
-// _EvaluateStack
+
 /*!	Evaluates the query's predicate stack.
 	The method does nothing (and returns \c B_OK), if the stack is \c NULL.
 	If the stack is non-null and Fetch() has already been called, the method
@@ -751,7 +746,7 @@
 		if (_HasFetched())
 			error = B_NOT_ALLOWED;
 		// convert the stack to a tree and evaluate it
-		QueryNode *node = NULL;
+		QueryNode* node = NULL;
 		if (error == B_OK)
 			error = fStack-&gt;ConvertToTree(node);
 		BString predicate;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018191.html">[Haiku-commits] r31709 - haiku/trunk/src/system/kernel/arch/ppc
</A></li>
	<LI>Next message: <A HREF="018194.html">[Haiku-commits] r31711 - in haiku/trunk: headers/os/storage	src/kits/storage
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18193">[ date ]</a>
              <a href="thread.html#18193">[ thread ]</a>
              <a href="subject.html#18193">[ subject ]</a>
              <a href="author.html#18193">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
