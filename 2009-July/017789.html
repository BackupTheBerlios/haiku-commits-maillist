<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31447 - in haiku/trunk/src/apps/debugger: . arch	arch/x86 debug_info gui/team_window model
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31447%20-%20in%20haiku/trunk/src/apps/debugger%3A%20.%20arch%0A%09arch/x86%20debug_info%20gui/team_window%20model&In-Reply-To=%3C200907072047.n67Klgpi006476%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017788.html">
   <LINK REL="Next"  HREF="017790.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31447 - in haiku/trunk/src/apps/debugger: . arch	arch/x86 debug_info gui/team_window model</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31447%20-%20in%20haiku/trunk/src/apps/debugger%3A%20.%20arch%0A%09arch/x86%20debug_info%20gui/team_window%20model&In-Reply-To=%3C200907072047.n67Klgpi006476%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31447 - in haiku/trunk/src/apps/debugger: . arch	arch/x86 debug_info gui/team_window model">bonefish at mail.berlios.de
       </A><BR>
    <I>Tue Jul  7 22:47:42 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="017788.html">[Haiku-commits] r31446 - haiku/trunk/src/servers/bluetooth
</A></li>
        <LI>Next message: <A HREF="017790.html">[Haiku-commits] r31447 - in haiku/trunk/src/apps/debugger: . arch arch/x86 debug_info gui/team_window model
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17789">[ date ]</a>
              <a href="thread.html#17789">[ thread ]</a>
              <a href="subject.html#17789">[ subject ]</a>
              <a href="author.html#17789">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-07-07 22:47:39 +0200 (Tue, 07 Jul 2009)
New Revision: 31447
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31447&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31447&amp;view=rev</A>

Added:
   haiku/trunk/src/apps/debugger/debug_info/Function.cpp
   haiku/trunk/src/apps/debugger/debug_info/Function.h
   haiku/trunk/src/apps/debugger/debug_info/FunctionInstance.cpp
   haiku/trunk/src/apps/debugger/debug_info/FunctionInstance.h
   haiku/trunk/src/apps/debugger/model/UserBreakpoint.cpp
   haiku/trunk/src/apps/debugger/model/UserBreakpoint.h
Modified:
   haiku/trunk/src/apps/debugger/BreakpointManager.cpp
   haiku/trunk/src/apps/debugger/BreakpointManager.h
   haiku/trunk/src/apps/debugger/Jamfile
   haiku/trunk/src/apps/debugger/Jobs.cpp
   haiku/trunk/src/apps/debugger/Jobs.h
   haiku/trunk/src/apps/debugger/TeamDebugger.cpp
   haiku/trunk/src/apps/debugger/TeamDebugger.h
   haiku/trunk/src/apps/debugger/ThreadHandler.cpp
   haiku/trunk/src/apps/debugger/arch/Architecture.cpp
   haiku/trunk/src/apps/debugger/arch/x86/ArchitectureX86.cpp
   haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/FunctionDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/FunctionDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/ImageDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/ImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/SpecificImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/TeamDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/TeamDebugInfo.h
   haiku/trunk/src/apps/debugger/gui/team_window/ImageFunctionsView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/ImageFunctionsView.h
   haiku/trunk/src/apps/debugger/gui/team_window/SourceView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/StackTraceView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/TeamWindow.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/TeamWindow.h
   haiku/trunk/src/apps/debugger/model/Breakpoint.cpp
   haiku/trunk/src/apps/debugger/model/Breakpoint.h
   haiku/trunk/src/apps/debugger/model/DisassembledCode.cpp
   haiku/trunk/src/apps/debugger/model/DisassembledCode.h
   haiku/trunk/src/apps/debugger/model/FileSourceCode.cpp
   haiku/trunk/src/apps/debugger/model/FileSourceCode.h
   haiku/trunk/src/apps/debugger/model/Image.cpp
   haiku/trunk/src/apps/debugger/model/Image.h
   haiku/trunk/src/apps/debugger/model/SourceCode.h
   haiku/trunk/src/apps/debugger/model/StackFrame.cpp
   haiku/trunk/src/apps/debugger/model/StackFrame.h
   haiku/trunk/src/apps/debugger/model/Statement.cpp
   haiku/trunk/src/apps/debugger/model/Statement.h
   haiku/trunk/src/apps/debugger/model/Team.cpp
   haiku/trunk/src/apps/debugger/model/Team.h
   haiku/trunk/src/apps/debugger/model/TeamDebugModel.cpp
   haiku/trunk/src/apps/debugger/model/TeamDebugModel.h
Log:
Very much work in progress, not in a particularly working state. Haiku munged
a good part of the source tree, so I rather get those changes into the
repository before continuing.
The general aim of the work is to deal with multiple instances of the same
function, e.g. inlined or non-inlined inline functions or those weird duplicates
gcc (4 at least) seems to be generating for no apparent reason.
* Added classes FunctionInstance (wrapping FunctionDebugInfo) and Function.
  FunctionInstance represents a physical instance of a function (e.g. inlined
  function at a particular address). A Function collects all FunctionInstances
  referring to the same source code location.
* Moved the SourceCode property from FunctionDebugInfo to Function accordingly.
* Since SourceCode is no longer associated with a concrete function instance,
  several methods dealing with statements have been removed and the
  functionality has been provided through other means (e.g. TeamDebugModel or
  SpecificImageDebugModel). This part is not yet completed.
* Introduced UserBreakpoint and UserBreakpointInstance. The user sets a
  breakpoint at a source code location, which is represented by a
  UserBreakpoint. Since that source location can be mapped to one address per
  instance of the respective function, UserBreakpoint has a
  UserBreakpointInstance per such function instance, which in turn refers to a
  Breakpoint (an actual breakpoint at an address).
* Adjusted Breakpoint, BreakpointManager, and TeamDebugger accordingly.


Modified: haiku/trunk/src/apps/debugger/BreakpointManager.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/BreakpointManager.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/BreakpointManager.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -38,108 +38,179 @@
 
 
 status_t
-BreakpointManager::InstallUserBreakpoint(target_addr_t address,
+BreakpointManager::InstallUserBreakpoint(UserBreakpoint* userBreakpoint,
 	bool enabled)
 {
-	user_breakpoint_state state = enabled
-		? USER_BREAKPOINT_ENABLED : USER_BREAKPOINT_DISABLED;
-
+printf(&quot;BreakpointManager::InstallUserBreakpoint(%p, %d)\n&quot;, userBreakpoint, enabled);
+	AutoLocker&lt;BLocker&gt; installLocker(fLock);
 	AutoLocker&lt;TeamDebugModel&gt; modelLocker(fDebugModel);
 
-	// If there already is a breakpoint, it might already have the requested
-	// state.
-	Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
-	if (breakpoint != NULL &amp;&amp; breakpoint-&gt;UserState() == state)
+	bool oldEnabled = userBreakpoint-&gt;IsEnabled();
+	if (userBreakpoint-&gt;IsValid() &amp;&amp; enabled == oldEnabled)
+{
+printf(&quot;  user breakpoint already valid and with same enabled state\n&quot;);
 		return B_OK;
+}
 
-	// create a breakpoint, if it doesn't exist yet
-	if (breakpoint == NULL) {
-		Image* image = fDebugModel-&gt;GetTeam()-&gt;ImageByAddress(address);
-		if (image == NULL)
-			return B_BAD_ADDRESS;
+	// get/create the breakpoints for all instances
+printf(&quot;  creating breakpoints for breakpoint instances\n&quot;);
+	status_t error = B_OK;
+	for (int32 i = 0;
+		UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i); i++) {
+printf(&quot;    breakpoint instance %p\n&quot;, instance);
+		if (instance-&gt;GetBreakpoint() != NULL)
+{
+printf(&quot;    -&gt; already has breakpoint\n&quot;);
+			continue;
+}
 
-		breakpoint = new(std::nothrow) Breakpoint(image, address);
-		if (breakpoint == NULL)
-			return B_NO_MEMORY;
+		target_addr_t address = instance-&gt;Address();
+		Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
+		if (breakpoint == NULL) {
+printf(&quot;    -&gt; no breakpoint at that address yet\n&quot;);
+			Image* image = fDebugModel-&gt;GetTeam()-&gt;ImageByAddress(address);
+			if (image == NULL) {
+printf(&quot;    -&gt; no image at that address\n&quot;);
+				error = B_BAD_ADDRESS;
+				break;
+			}
 
-		if (!fDebugModel-&gt;AddBreakpoint(breakpoint))
-			return B_NO_MEMORY;
-	}
+			breakpoint = new(std::nothrow) Breakpoint(image, address);
+			if (breakpoint == NULL) {
+				error = B_NO_MEMORY;
+				break;
+			}
 
-	user_breakpoint_state oldState = breakpoint-&gt;UserState();
+			if (!fDebugModel-&gt;AddBreakpoint(breakpoint)) {
+				error = B_NO_MEMORY;
+				break;
+			}
+		}
 
-	// set the breakpoint state
-	breakpoint-&gt;SetUserState(state);
-	fDebugModel-&gt;NotifyUserBreakpointChanged(breakpoint);
+printf(&quot;    -&gt; adding instance to breakpoint %p\n&quot;, breakpoint);
+		breakpoint-&gt;AddUserBreakpoint(instance);
+		instance-&gt;SetBreakpoint(breakpoint);
+	}
 
-	AutoLocker&lt;BLocker&gt; installLocker(fLock);
-		// We need to make the installation decision with both locks held, and
-		// we keep this lock until we have the breakpoint installed/uninstalled.
+	// If everything looks good so far mark the user breakpoint according to
+	// its new state.
+	if (error == B_OK)
+		userBreakpoint-&gt;SetEnabled(enabled);
 
-	bool install = breakpoint-&gt;ShouldBeInstalled();
-	if (breakpoint-&gt;IsInstalled() == install)
-		return B_OK;
+	// notify user breakpoint listeners
+	if (error == B_OK) {
+		for (int32 i = 0;
+			UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i);
+			i++) {
+			fDebugModel-&gt;NotifyUserBreakpointChanged(instance-&gt;GetBreakpoint());
+		}
+	}
 
-	// The breakpoint needs to be installed/uninstalled.
-	Reference&lt;Breakpoint&gt; breakpointReference(breakpoint);
 	modelLocker.Unlock();
 
-	status_t error = install
-		? fDebuggerInterface-&gt;InstallBreakpoint(address)
-		: fDebuggerInterface-&gt;UninstallBreakpoint(address);
-
-	// Mark the breakpoint installed/uninstalled, if everything went fine.
+	// install/uninstall the breakpoints as needed
+printf(&quot;  updating breakpoints\n&quot;);
 	if (error == B_OK) {
-		breakpoint-&gt;SetInstalled(install);
-		return B_OK;
+		for (int32 i = 0;
+			UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i);
+			i++) {
+printf(&quot;    breakpoint instance %p\n&quot;, instance);
+			error = _UpdateBreakpointInstallation(instance-&gt;GetBreakpoint());
+			if (error != B_OK)
+				break;
+		}
 	}
 
-	// revert on error
-	installLocker. Unlock();
-	modelLocker.Lock();
+	if (error == B_OK) {
+printf(&quot;  success, marking user breakpoint valid\n&quot;);
+		// everything went fine -- mark the user breakpoint valid
+		if (!userBreakpoint-&gt;IsValid()) {
+			modelLocker.Lock();
+			userBreakpoint-&gt;SetValid(true);
+			userBreakpoint-&gt;AcquireReference();
+				// TODO: Put the user breakpoint some place?
+			modelLocker.Unlock();
+		}
+	} else {
+		// something went wrong -- revert the situation
+printf(&quot;  error, reverting\n&quot;);
+		modelLocker.Lock();
+		userBreakpoint-&gt;SetEnabled(oldEnabled);
+		modelLocker.Unlock();
 
-	breakpoint-&gt;SetUserState(oldState);
-	fDebugModel-&gt;NotifyUserBreakpointChanged(breakpoint);
+		if (!oldEnabled || !userBreakpoint-&gt;IsValid()) {
+			for (int32 i = 0;  UserBreakpointInstance* instance
+					= userBreakpoint-&gt;InstanceAt(i);
+				i++) {
+				Breakpoint* breakpoint = instance-&gt;GetBreakpoint();
+				if (breakpoint == NULL)
+					continue;
 
-	if (breakpoint-&gt;IsUnused())
-		fDebugModel-&gt;RemoveBreakpoint(breakpoint);
+				if (!userBreakpoint-&gt;IsValid()) {
+					instance-&gt;SetBreakpoint(NULL);
+					breakpoint-&gt;RemoveUserBreakpoint(instance);
+				}
 
+				_UpdateBreakpointInstallation(breakpoint);
+
+				modelLocker.Lock();
+				fDebugModel-&gt;NotifyUserBreakpointChanged(breakpoint);
+
+				if (breakpoint-&gt;IsUnused())
+					fDebugModel-&gt;RemoveBreakpoint(breakpoint);
+				modelLocker.Unlock();
+			}
+		}
+	}
+
+	installLocker.Unlock();
+
 	return error;
 }
 
 
 void
-BreakpointManager::UninstallUserBreakpoint(target_addr_t address)
+BreakpointManager::UninstallUserBreakpoint(UserBreakpoint* userBreakpoint)
 {
+	AutoLocker&lt;BLocker&gt; installLocker(fLock);
 	AutoLocker&lt;TeamDebugModel&gt; modelLocker(fDebugModel);
 
-	Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
-	if (breakpoint == NULL || breakpoint-&gt;UserState() == USER_BREAKPOINT_NONE)
+	if (!userBreakpoint-&gt;IsValid())
 		return;
 
-	// set the breakpoint state
-	breakpoint-&gt;SetUserState(USER_BREAKPOINT_NONE);
-	fDebugModel-&gt;NotifyUserBreakpointChanged(breakpoint);
+	userBreakpoint-&gt;SetValid(false);
+	userBreakpoint-&gt;SetEnabled(false);
 
-	AutoLocker&lt;BLocker&gt; installLocker(fLock);
-		// We need to make the uninstallation decision with both locks held, and
-		// we keep this lock until we have the breakpoint uninstalled.
+	modelLocker.Unlock();
 
-	// check whether the breakpoint needs to be uninstalled
-	bool uninstall = !breakpoint-&gt;ShouldBeInstalled()
-		&amp;&amp; breakpoint-&gt;IsInstalled();
+	// uninstall the breakpoints as needed
+	for (int32 i = 0;
+		UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i); i++) {
+		if (Breakpoint* breakpoint = instance-&gt;GetBreakpoint())
+			_UpdateBreakpointInstallation(breakpoint);
+	}
 
-	// if unused remove it
-	Reference&lt;Breakpoint&gt; breakpointReference(breakpoint);
-	if (breakpoint-&gt;IsUnused())
-		fDebugModel-&gt;RemoveBreakpoint(breakpoint);
+	modelLocker.Lock();
 
+	// detach the breakpoints from the user breakpoint instances
+	for (int32 i = 0;
+		UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i); i++) {
+		if (Breakpoint* breakpoint = instance-&gt;GetBreakpoint()) {
+			instance-&gt;SetBreakpoint(NULL);
+			breakpoint-&gt;RemoveUserBreakpoint(instance);
+
+			fDebugModel-&gt;NotifyUserBreakpointChanged(breakpoint);
+
+			if (breakpoint-&gt;IsUnused())
+				fDebugModel-&gt;RemoveBreakpoint(breakpoint);
+		}
+	}
+
 	modelLocker.Unlock();
+	installLocker.Unlock();
 
-	if (uninstall) {
-		fDebuggerInterface-&gt;UninstallBreakpoint(address);
-		breakpoint-&gt;SetInstalled(false);
-	}
+	// release the reference from InstallUserBreakpoint()
+	userBreakpoint-&gt;ReleaseReference();
 }
 
 
@@ -147,6 +218,7 @@
 BreakpointManager::InstallTemporaryBreakpoint(target_addr_t address,
 	BreakpointClient* client)
 {
+	AutoLocker&lt;BLocker&gt; installLocker(fLock);
 	AutoLocker&lt;TeamDebugModel&gt; modelLocker(fDebugModel);
 
 	// create a breakpoint, if it doesn't exist yet
@@ -169,10 +241,6 @@
 	// add the client
 	status_t error;
 	if (breakpoint-&gt;AddClient(client)) {
-		AutoLocker&lt;BLocker&gt; installLocker(fLock);
-			// We need to make the installation decision with both locks held,
-			// and we keep this lock until we have the breakpoint installed.
-
 		if (breakpoint-&gt;IsInstalled())
 			return B_OK;
 
@@ -185,7 +253,6 @@
 			return B_OK;
 		}
 
-		installLocker.Unlock();
 		modelLocker.Lock();
 
 		breakpoint-&gt;RemoveClient(client);
@@ -204,6 +271,7 @@
 BreakpointManager::UninstallTemporaryBreakpoint(target_addr_t address,
 	BreakpointClient* client)
 {
+	AutoLocker&lt;BLocker&gt; installLocker(fLock);
 	AutoLocker&lt;TeamDebugModel&gt; modelLocker(fDebugModel);
 
 	Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
@@ -213,10 +281,6 @@
 	// remove the client
 	breakpoint-&gt;RemoveClient(client);
 
-	AutoLocker&lt;BLocker&gt; installLocker(fLock);
-		// We need to make the uninstallation decision with both locks held, and
-		// we keep this lock until we have the breakpoint uninstalled.
-
 	// check whether the breakpoint needs to be uninstalled
 	bool uninstall = !breakpoint-&gt;ShouldBeInstalled()
 		&amp;&amp; breakpoint-&gt;IsInstalled();
@@ -233,3 +297,30 @@
 		breakpoint-&gt;SetInstalled(false);
 	}
 }
+
+
+status_t
+BreakpointManager::_UpdateBreakpointInstallation(Breakpoint* breakpoint)
+{
+	bool shouldBeInstalled = breakpoint-&gt;ShouldBeInstalled();
+printf(&quot;BreakpointManager::_UpdateBreakpointInstallation(%p): should be installed: %d, is installed: %d\n&quot;, breakpoint, shouldBeInstalled, breakpoint-&gt;IsInstalled());
+	if (shouldBeInstalled == breakpoint-&gt;IsInstalled())
+		return B_OK;
+
+	if (shouldBeInstalled) {
+		// install
+		status_t error = fDebuggerInterface-&gt;InstallBreakpoint(
+			breakpoint-&gt;Address());
+		if (error != B_OK)
+			return error;
+printf(&quot;BREAKPOINT at %#llx installed: %s\n&quot;, breakpoint-&gt;Address(), strerror(error));
+		breakpoint-&gt;SetInstalled(true);
+	} else {
+		// uninstall
+		fDebuggerInterface-&gt;UninstallBreakpoint(breakpoint-&gt;Address());
+printf(&quot;BREAKPOINT at %#llx uninstalled\n&quot;, breakpoint-&gt;Address());
+		breakpoint-&gt;SetInstalled(false);
+	}
+
+	return B_OK;
+}

Modified: haiku/trunk/src/apps/debugger/BreakpointManager.h
===================================================================
--- haiku/trunk/src/apps/debugger/BreakpointManager.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/BreakpointManager.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -22,9 +22,15 @@
 
 			status_t			Init();
 
-			status_t			InstallUserBreakpoint(target_addr_t address,
+//			status_t			InstallUserBreakpoint(target_addr_t address,
+//									bool enabled);
+//			void				UninstallUserBreakpoint(target_addr_t address);
+
+			status_t			InstallUserBreakpoint(
+									UserBreakpoint* userBreakpoint,
 									bool enabled);
-			void				UninstallUserBreakpoint(target_addr_t address);
+			void				UninstallUserBreakpoint(
+									UserBreakpoint* userBreakpoint);
 
 			status_t			InstallTemporaryBreakpoint(
 									target_addr_t address,
@@ -34,6 +40,11 @@
 									BreakpointClient* client);
 
 private:
+			status_t			_UpdateBreakpointInstallation(
+									Breakpoint* breakpoint);
+										// fLock must be held
+
+private:
 			BLocker				fLock;	// used to synchronize un-/installing
 			TeamDebugModel*		fDebugModel;
 			DebuggerInterface*	fDebuggerInterface;

Modified: haiku/trunk/src/apps/debugger/Jamfile
===================================================================
--- haiku/trunk/src/apps/debugger/Jamfile	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/Jamfile	2009-07-07 20:47:39 UTC (rev 31447)
@@ -56,7 +56,9 @@
 	DwarfFunctionDebugInfo.cpp
 	DwarfImageDebugInfo.cpp
 	DwarfTeamDebugInfo.cpp
+	Function.cpp
 	FunctionDebugInfo.cpp
+	FunctionInstance.cpp
 	ImageDebugInfo.cpp
 	ImageDebugInfoProvider.cpp
 	SpecificImageDebugInfo.cpp
@@ -97,6 +99,7 @@
 	StackTrace.cpp
 	Statement.cpp
 	SymbolInfo.cpp
+	UserBreakpoint.cpp
 	Team.cpp
 	TeamDebugModel.cpp
 	TeamMemory.cpp

Modified: haiku/trunk/src/apps/debugger/Jobs.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/Jobs.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/Jobs.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -12,7 +12,7 @@
 #include &quot;Architecture.h&quot;
 #include &quot;CpuState.h&quot;
 #include &quot;DebuggerInterface.h&quot;
-#include &quot;FunctionDebugInfo.h&quot;
+#include &quot;Function.h&quot;
 #include &quot;Image.h&quot;
 #include &quot;ImageDebugInfo.h&quot;
 #include &quot;SourceCode.h&quot;
@@ -258,7 +258,7 @@
 	// set the result
 	locker.Lock();
 	if (error == B_OK) {
-		fImage-&gt;SetImageDebugInfo(debugInfo, IMAGE_DEBUG_INFO_LOADED);
+		error = fImage-&gt;SetImageDebugInfo(debugInfo, IMAGE_DEBUG_INFO_LOADED);
 		debugInfo-&gt;RemoveReference();
 	} else {
 		fImage-&gt;SetImageDebugInfo(NULL, IMAGE_DEBUG_INFO_UNAVAILABLE);
@@ -319,7 +319,7 @@
 
 LoadSourceCodeJob::LoadSourceCodeJob(
 	DebuggerInterface* debuggerInterface, Architecture* architecture,
-	Team* team, FunctionDebugInfo* function)
+	Team* team, Function* function)
 	:
 	fDebuggerInterface(debuggerInterface),
 	fArchitecture(architecture),
@@ -346,13 +346,29 @@
 status_t
 LoadSourceCodeJob::Do()
 {
+	// Get the function debug info for an instance which we can use to load the
+	// source code.
+	AutoLocker&lt;Team&gt; locker(fTeam);
+
+	status_t error = B_OK;
+	FunctionDebugInfo* functionDebugInfo = NULL;
+	if (FunctionInstance* instance = fFunction-&gt;FirstInstance()) {
+		functionDebugInfo = instance-&gt;GetFunctionDebugInfo();
+	} else
+		error = B_ENTRY_NOT_FOUND;
+	Reference&lt;FunctionDebugInfo&gt; functionDebugInfoReference(functionDebugInfo);
+
+	locker.Unlock();
+
 	// load the source code, if we can
 	SourceCode* sourceCode = NULL;
-	status_t error = fFunction-&gt;GetSpecificImageDebugInfo()-&gt;LoadSourceCode(
-		fFunction, sourceCode);
+	if (error == B_OK) {
+		error = functionDebugInfo-&gt;GetSpecificImageDebugInfo()-&gt;LoadSourceCode(
+			functionDebugInfo, sourceCode);
+	}
 
 	// set the result
-	AutoLocker&lt;Team&gt; locker(fTeam);
+	locker.Lock();
 	if (error == B_OK) {
 		fFunction-&gt;SetSourceCode(sourceCode, FUNCTION_SOURCE_LOADED);
 		sourceCode-&gt;RemoveReference();

Modified: haiku/trunk/src/apps/debugger/Jobs.h
===================================================================
--- haiku/trunk/src/apps/debugger/Jobs.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/Jobs.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -12,7 +12,7 @@
 class Architecture;
 class CpuState;
 class DebuggerInterface;
-class FunctionDebugInfo;
+class Function;
 class Image;
 class StackFrame;
 class Team;
@@ -112,8 +112,8 @@
 public:
 								LoadSourceCodeJob(
 									DebuggerInterface* debuggerInterface,
-									Architecture* architecture,
-									Team* team, FunctionDebugInfo* function);
+									Architecture* architecture, Team* team,
+									Function* function);
 	virtual						~LoadSourceCodeJob();
 
 	virtual	JobKey				Key() const;
@@ -123,7 +123,7 @@
 			DebuggerInterface*	fDebuggerInterface;
 			Architecture*		fArchitecture;
 			Team*				fTeam;
-			FunctionDebugInfo*	fFunction;
+			Function*			fFunction;
 };
 
 

Modified: haiku/trunk/src/apps/debugger/TeamDebugger.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/TeamDebugger.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/TeamDebugger.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -21,11 +21,15 @@
 #include &quot;CpuState.h&quot;
 #include &quot;DebuggerInterface.h&quot;
 #include &quot;FileManager.h&quot;
+#include &quot;Function.h&quot;
+#include &quot;ImageDebugInfo.h&quot;
 #include &quot;Jobs.h&quot;
 #include &quot;LocatableFile.h&quot;
 #include &quot;MessageCodes.h&quot;
+#include &quot;SourceCode.h&quot;
+#include &quot;SpecificImageDebugInfo.h&quot;
+#include &quot;Statement.h&quot;
 #include &quot;SymbolInfo.h&quot;
-#include &quot;Statement.h&quot;
 #include &quot;TeamDebugInfo.h&quot;
 #include &quot;TeamDebugModel.h&quot;
 
@@ -479,8 +483,10 @@
 
 void
 TeamDebugger::FunctionSourceCodeRequested(TeamWindow* window,
-	FunctionDebugInfo* function)
+	FunctionInstance* functionInstance)
 {
+	Function* function = functionInstance-&gt;GetFunction();
+
 	// mark loading
 	AutoLocker&lt; ::Team&gt; locker(fTeam);
 	if (function-&gt;SourceCodeState() != FUNCTION_SOURCE_NOT_LOADED)
@@ -821,6 +827,8 @@
 		imageHandler-&gt;ReleaseReference();
 	}
 
+// TODO: Remove breakpoints in the image!
+
 	return false;
 }
 
@@ -837,7 +845,114 @@
 TeamDebugger::_HandleSetUserBreakpoint(target_addr_t address, bool enabled)
 {
 printf(&quot;TeamDebugger::_HandleSetUserBreakpoint(%#llx, %d)\n&quot;, address, enabled);
-	status_t error = fBreakpointManager-&gt;InstallUserBreakpoint(address,
+	// check whether there already is a breakpoint
+	AutoLocker&lt; ::Team&gt; locker(fTeam);
+
+	Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
+	UserBreakpoint* userBreakpoint = NULL;
+	if (breakpoint != NULL &amp;&amp; breakpoint-&gt;FirstUserBreakpoint() != NULL)
+		userBreakpoint = breakpoint-&gt;FirstUserBreakpoint()-&gt;GetUserBreakpoint();
+	Reference&lt;UserBreakpoint&gt; userBreakpointReference(userBreakpoint);
+
+	if (userBreakpoint == NULL) {
+printf(&quot;  no breakpoint yet\n&quot;);
+		// get the function at the address
+		Image* image = fTeam-&gt;ImageByAddress(address);
+printf(&quot;  image: %p\n&quot;, image);
+		if (image == NULL)
+			return;
+		ImageDebugInfo* imageDebugInfo = image-&gt;GetImageDebugInfo();
+printf(&quot;  image debug info: %p\n&quot;, imageDebugInfo);
+		if (imageDebugInfo == NULL)
+			return;
+			// TODO: Handle this case by loading the debug info, if possible!
+		FunctionInstance* functionInstance
+			= imageDebugInfo-&gt;FunctionAtAddress(address);
+printf(&quot;  function instance: %p\n&quot;, functionInstance);
+		if (functionInstance == NULL)
+			return;
+		Function* function = functionInstance-&gt;GetFunction();
+printf(&quot;  function: %p\n&quot;, function);
+
+		// get the source location for the address
+		FunctionDebugInfo* functionDebugInfo
+			= functionInstance-&gt;GetFunctionDebugInfo();
+		SourceLocation sourceLocation;
+		Statement* breakpointStatement = NULL;
+//		if (SourceCode* sourceCode = functionDebugInfo-&gt;GetSourceCode()) {
+//			breakpointStatement = sourceCode-&gt;StatementAtAddress(address);
+//			if (breakpointStatement != NULL)
+//				sourceLocation = breakpointStatement-&gt;StartSourceLocation();
+//		}
+
+		if (breakpointStatement == NULL
+			&amp;&amp; functionDebugInfo-&gt;GetSpecificImageDebugInfo()-&gt;GetStatement(
+				functionDebugInfo, address, breakpointStatement) != B_OK) {
+			return;
+		}
+
+		sourceLocation = breakpointStatement-&gt;StartSourceLocation();
+		breakpointStatement-&gt;ReleaseReference();
+
+		target_addr_t relativeAddress = address - functionInstance-&gt;Address();
+printf(&quot;  relative address: %#llx, source location: (%ld, %ld)\n&quot;, relativeAddress, sourceLocation.Line(), sourceLocation.Column());
+
+		// create the user breakpoint
+		userBreakpoint = new(std::nothrow) UserBreakpoint(function);
+		if (userBreakpoint == NULL)
+			return;
+		userBreakpointReference.SetTo(userBreakpoint, true);
+printf(&quot;  created user breakpoint: %p\n&quot;, userBreakpoint);
+
+		// iterate through all function instances and create
+		// UserBreakpointInstances
+		for (FunctionInstanceList::ConstIterator it
+					= function-&gt;Instances().GetIterator();
+				FunctionInstance* instance = it.Next();) {
+printf(&quot;  function instance %p: range: %#llx - %#llx\n&quot;, instance, instance-&gt;Address(), instance-&gt;Address() + instance-&gt;Size());
+			// get the breakpoint address for the instance
+			target_addr_t instanceAddress = 0;
+			if (instance == functionInstance) {
+				instanceAddress = address;
+			} else if (functionInstance-&gt;SourceFile() != NULL) {
+				// We have a source file, so get the address for the source
+				// location.
+				Statement* statement = NULL;
+				functionDebugInfo = instance-&gt;GetFunctionDebugInfo();
+				functionDebugInfo-&gt;GetSpecificImageDebugInfo()
+					-&gt;GetStatementForSourceLocation(functionDebugInfo,
+						sourceLocation, statement);
+				if (statement != NULL) {
+					instanceAddress = statement-&gt;CoveringAddressRange().Start();
+						// TODO: What about BreakpointAllowed()?
+					statement-&gt;ReleaseReference();
+				}
+			}
+printf(&quot;    breakpoint address using source info: %llx\n&quot;, instanceAddress);
+
+			if (instanceAddress == 0) {
+				// No source file (or we failed getting the statement), so try
+				// to use the same relative address.
+				if (relativeAddress &gt; instance-&gt;Size())
+					continue;
+				instanceAddress = instance-&gt;Address() + relativeAddress;
+			}
+printf(&quot;    final breakpoint address: %llx\n&quot;, instanceAddress);
+
+			UserBreakpointInstance* breakpointInstance = new(std::nothrow)
+				UserBreakpointInstance(userBreakpoint, instanceAddress);
+			if (breakpointInstance == NULL
+				|| !userBreakpoint-&gt;AddInstance(breakpointInstance)) {
+				delete breakpointInstance;
+				return;
+			}
+printf(&quot;  breakpoint instance: %p\n&quot;, breakpointInstance);
+		}
+	}
+
+	locker.Unlock();
+
+	status_t error = fBreakpointManager-&gt;InstallUserBreakpoint(userBreakpoint,
 		enabled);
 	if (error != B_OK) {
 		_NotifyUser(&quot;Install Breakpoint&quot;, &quot;Failed to install breakpoint: %s&quot;,
@@ -850,7 +965,19 @@
 TeamDebugger::_HandleClearUserBreakpoint(target_addr_t address)
 {
 printf(&quot;TeamDebugger::_HandleClearUserBreakpoint(%#llx)\n&quot;, address);
-	fBreakpointManager-&gt;UninstallUserBreakpoint(address);
+
+	AutoLocker&lt; ::Team&gt; locker(fTeam);
+
+	Breakpoint* breakpoint = fDebugModel-&gt;BreakpointAtAddress(address);
+	if (breakpoint == NULL || breakpoint-&gt;FirstUserBreakpoint() == NULL)
+		return;
+	UserBreakpoint* userBreakpoint
+		= breakpoint-&gt;FirstUserBreakpoint()-&gt;GetUserBreakpoint();
+	Reference&lt;UserBreakpoint&gt; userBreakpointReference(userBreakpoint);
+
+	locker.Unlock();
+
+	fBreakpointManager-&gt;UninstallUserBreakpoint(userBreakpoint);
 }
 
 

Modified: haiku/trunk/src/apps/debugger/TeamDebugger.h
===================================================================
--- haiku/trunk/src/apps/debugger/TeamDebugger.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/TeamDebugger.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -42,7 +42,7 @@
 private:
 	// TeamWindow::Listener
 	virtual	void				FunctionSourceCodeRequested(TeamWindow* window,
-									FunctionDebugInfo* function);
+									FunctionInstance* function);
 	virtual	void				ImageDebugInfoRequested(TeamWindow* window,
 									Image* image);
 	virtual	void				ThreadActionRequested(TeamWindow* window,

Modified: haiku/trunk/src/apps/debugger/ThreadHandler.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/ThreadHandler.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/ThreadHandler.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -15,7 +15,7 @@
 #include &quot;BreakpointManager.h&quot;
 #include &quot;CpuState.h&quot;
 #include &quot;DebuggerInterface.h&quot;
-#include &quot;FunctionDebugInfo.h&quot;
+#include &quot;FunctionInstance.h&quot;
 #include &quot;ImageDebugInfo.h&quot;
 #include &quot;InstructionInfo.h&quot;
 #include &quot;Jobs.h&quot;
@@ -126,7 +126,7 @@
 			// spurious breakpoint -- might be a temporary breakpoint, that has
 			// already been uninstalled
 			continueThread = true;
-		} else if (breakpoint-&gt;UserState() != USER_BREAKPOINT_ENABLED) {
+		} else if (breakpoint-&gt;HasEnabledUserBreakpoint()) {
 			// breakpoint of another thread or one that has been disabled in
 			// the meantime
 			continueThread = true;
@@ -382,20 +382,21 @@
 {
 	AutoLocker&lt;TeamDebugModel&gt; locker(fDebugModel);
 
-	FunctionDebugInfo* function = frame-&gt;Function();
-	if (function == NULL)
+	FunctionInstance* functionInstance = frame-&gt;Function();
+	if (functionInstance == NULL)
 		return NULL;
+	FunctionDebugInfo* function = functionInstance-&gt;GetFunctionDebugInfo();
 
 	// If there's source code attached to the function, we can just get the
 	// statement.
-	SourceCode* sourceCode = function-&gt;GetSourceCode();
-	if (sourceCode != NULL) {
-		Statement* statement = sourceCode-&gt;StatementAtAddress(
-			frame-&gt;InstructionPointer());
-		if (statement != NULL)
-			statement-&gt;AddReference();
-		return statement;
-	}
+//	SourceCode* sourceCode = function-&gt;GetSourceCode();
+//	if (sourceCode != NULL) {
+//		Statement* statement = sourceCode-&gt;StatementAtAddress(
+//			frame-&gt;InstructionPointer());
+//		if (statement != NULL)
+//			statement-&gt;AddReference();
+//		return statement;
+//	}
 
 	locker.Unlock();
 

Modified: haiku/trunk/src/apps/debugger/arch/Architecture.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/arch/Architecture.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/arch/Architecture.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -11,7 +11,7 @@
 #include &lt;AutoLocker.h&gt;
 
 #include &quot;CpuState.h&quot;
-#include &quot;FunctionDebugInfo.h&quot;
+#include &quot;FunctionInstance.h&quot;
 #include &quot;Image.h&quot;
 #include &quot;ImageDebugInfo.h&quot;
 #include &quot;ImageDebugInfoProvider.h&quot;
@@ -75,31 +75,38 @@
 
 		// get the function
 		teamLocker.Lock();
-		FunctionDebugInfo* function = NULL;
-		if (imageDebugInfo != NULL)
+		FunctionInstance* function = NULL;
+		FunctionDebugInfo* functionDebugInfo = NULL;
+		if (imageDebugInfo != NULL) {
 			function = imageDebugInfo-&gt;FunctionAtAddress(instructionPointer);
-		Reference&lt;FunctionDebugInfo&gt; functionReference(function);
+			if (function != NULL)
+				functionDebugInfo = function-&gt;GetFunctionDebugInfo();
+		}
+		Reference&lt;FunctionInstance&gt; functionReference(function);
 		teamLocker.Unlock();
 
 		// If the last frame had been created by the architecture, we update the
 		// CPU state.
-		if (architectureFrame)
-			UpdateStackFrameCpuState(frame, image, function, cpuState);
+		if (architectureFrame) {
+			UpdateStackFrameCpuState(frame, image,
+				functionDebugInfo, cpuState);
+		}
 
 		// create the frame using the debug info
 		StackFrame* previousFrame = NULL;
 		CpuState* previousCpuState = NULL;
 		if (function != NULL) {
-			status_t error = function-&gt;GetSpecificImageDebugInfo()-&gt;CreateFrame(
-				image, function, cpuState, previousFrame, previousCpuState);
+			status_t error = functionDebugInfo-&gt;GetSpecificImageDebugInfo()
+				-&gt;CreateFrame(image, functionDebugInfo, cpuState, previousFrame,
+					previousCpuState);
 			if (error != B_OK &amp;&amp; error != B_UNSUPPORTED)
 				break;
 		}
 
 		// If we have no frame yet, let the architecture create it.
 		if (previousFrame == NULL) {
-			status_t error = CreateStackFrame(image, function, cpuState,
-				frame == NULL, previousFrame, previousCpuState);
+			status_t error = CreateStackFrame(image, functionDebugInfo,
+				cpuState, frame == NULL, previousFrame, previousCpuState);
 			if (error != B_OK)
 				break;
 			architectureFrame = true;

Modified: haiku/trunk/src/apps/debugger/arch/x86/ArchitectureX86.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/arch/x86/ArchitectureX86.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/arch/x86/ArchitectureX86.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -296,8 +296,9 @@
 	bool breakpointAllowed;
 	while (disassembler.GetNextInstruction(line, instructionAddress,
 				instructionSize, breakpointAllowed) == B_OK) {
+// TODO: Respect breakpointAllowed!
 		if (!source-&gt;AddInstructionLine(line, instructionAddress,
-				instructionSize, breakpointAllowed)) {
+				instructionSize)) {
 			return B_NO_MEMORY;
 		}
 	}
@@ -320,9 +321,7 @@
 
 	// create a statement
 	ContiguousStatement* statement = new(std::nothrow) ContiguousStatement(
-		SourceLocation(0), SourceLocation(1),
-		TargetAddressRange(info.Address(), info.Size()),
-		info.IsBreakpointAllowed());
+		SourceLocation(0), TargetAddressRange(info.Address(), info.Size()));
 	if (statement == NULL)
 		return B_NO_MEMORY;
 

Modified: haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -49,17 +49,17 @@
 }
 
 
-const char*
+const BString&amp;
 BasicFunctionDebugInfo::Name() const
 {
-	return fName.String();
+	return fName;
 }
 
 
-const char*
+const BString&amp;
 BasicFunctionDebugInfo::PrettyName() const
 {
-	return fPrettyName.String();
+	return fPrettyName;
 }
 
 

Modified: haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.h
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/BasicFunctionDebugInfo.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -23,8 +23,8 @@
 	virtual	SpecificImageDebugInfo* GetSpecificImageDebugInfo() const;
 	virtual	target_addr_t		Address() const;
 	virtual	target_size_t		Size() const;
-	virtual	const char*			Name() const;
-	virtual	const char*			PrettyName() const;
+	virtual	const BString&amp;		Name() const;
+	virtual	const BString&amp;		PrettyName() const;
 
 	virtual	LocatableFile*		SourceFile() const;
 	virtual	SourceLocation		SourceStartLocation() const;

Modified: haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -118,6 +118,15 @@
 }
 
 
+status_t
+DebuggerImageDebugInfo::GetStatementForSourceLocation(
+	FunctionDebugInfo* function, const SourceLocation&amp; sourceLocation,
+	Statement*&amp; _statement)
+{
+	return B_ENTRY_NOT_FOUND;
+}
+
+
 /*static*/ int
 DebuggerImageDebugInfo::_CompareSymbols(const SymbolInfo* a,
 	const SymbolInfo* b)

Modified: haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.h
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/DebuggerImageDebugInfo.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -36,6 +36,10 @@
 	virtual	status_t			GetStatement(FunctionDebugInfo* function,
 									target_addr_t address,
 									Statement*&amp; _statement);
+	virtual	status_t			GetStatementForSourceLocation(
+									FunctionDebugInfo* function,
+									const SourceLocation&amp; sourceLocation,
+									Statement*&amp; _statement);
 
 private:
 	static	int					_CompareSymbols(const SymbolInfo* a,

Modified: haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -63,17 +63,17 @@
 }
 
 
-const char*
+const BString&amp;
 DwarfFunctionDebugInfo::Name() const
 {
-	return fName.String();
+	return fName;
 }
 
 
-const char*
+const BString&amp;
 DwarfFunctionDebugInfo::PrettyName() const
 {
-	return fName.String();
+	return fName;
 }
 
 

Modified: haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.h
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.h	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/DwarfFunctionDebugInfo.h	2009-07-07 20:47:39 UTC (rev 31447)
@@ -32,8 +32,8 @@
 	virtual	SpecificImageDebugInfo* GetSpecificImageDebugInfo() const;
 	virtual	target_addr_t		Address() const;
 	virtual	target_size_t		Size() const;
-	virtual	const char*			Name() const;
-	virtual	const char*			PrettyName() const;
+	virtual	const BString&amp;		Name() const;
+	virtual	const BString&amp;		PrettyName() const;
 
 	virtual	LocatableFile*		SourceFile() const;
 	virtual	SourceLocation		SourceStartLocation() const;

Modified: haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.cpp	2009-07-07 19:46:40 UTC (rev 31446)
+++ haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.cpp	2009-07-07 20:47:39 UTC (rev 31447)
@@ -320,15 +320,183 @@
 
 
 status_t
-DwarfImageDebugInfo::GetStatement(FunctionDebugInfo* function,
+DwarfImageDebugInfo::GetStatement(FunctionDebugInfo* _function,
 	target_addr_t address, Statement*&amp; _statement)
 {
-	// TODO:...
-	return fArchitecture-&gt;GetStatement(function, address, _statement);
+	DwarfFunctionDebugInfo* function
+		= dynamic_cast&lt;DwarfFunctionDebugInfo*&gt;(_function);
+	if (function == NULL)
+		return B_BAD_VALUE;
+
+	AutoLocker&lt;BLocker&gt; locker(fLock);
+
+	// get the source file
+	LocatableFile* file = function-&gt;SourceFile();
+	if (file == NULL)
+		return B_ENTRY_NOT_FOUND;
+
+	// maybe the source code is already loaded -- this will simplify things
+	CompilationUnit* unit = function-&gt;GetCompilationUnit();
+//	FileSourceCode* sourceCode = _LookupSourceCode(unit, file);
+//	if (sourceCode) {
+//		Statement* statement = sourceCode-&gt;StatementAtAddress(address);
+//		if (statement == NULL)
+//			return B_ENTRY_NOT_FOUND;
+//
+//		statement-&gt;AcquireReference();
+//		_statement = statement;
+//		return B_OK;
+//	}
+
+	// get the index of the source file in the compilation unit for cheaper
+	// comparison below
+	int32 fileIndex = _GetSourceFileIndex(unit, file);
+
+	// Get the statement by executing the line number program for the
+	// compilation unit.
+	LineNumberProgram&amp; program = unit-&gt;GetLineNumberProgram();
+	if (!program.IsValid())
+		return B_BAD_DATA;
+
+	LineNumberProgram::State state;
+	program.GetInitialState(state);
+
+	target_addr_t statementAddress = 0;
+	int32 statementLine = -1;
+	int32 statementColumn = -1;

[... truncated: 2551 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017788.html">[Haiku-commits] r31446 - haiku/trunk/src/servers/bluetooth
</A></li>
	<LI>Next message: <A HREF="017790.html">[Haiku-commits] r31447 - in haiku/trunk/src/apps/debugger: . arch arch/x86 debug_info gui/team_window model
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17789">[ date ]</a>
              <a href="thread.html#17789">[ thread ]</a>
              <a href="subject.html#17789">[ subject ]</a>
              <a href="author.html#17789">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
