<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27536 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27536%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil&In-Reply-To=%3C200809151351.m8FDpf8x031383%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011999.html">
   <LINK REL="Next"  HREF="011847.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27536 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27536%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil&In-Reply-To=%3C200809151351.m8FDpf8x031383%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27536 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 15:51:41 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011999.html">[Haiku-commits] r27535 - haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
        <LI>Next message: <A HREF="011847.html">[Haiku-commits] r27537 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11846">[ date ]</a>
              <a href="thread.html#11846">[ thread ]</a>
              <a href="subject.html#11846">[ subject ]</a>
              <a href="author.html#11846">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 15:51:33 +0200 (Mon, 15 Sep 2008)
New Revision: 27536
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27536&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27536&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/common.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc_data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/des.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/des.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/fifo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/fifo.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/integer.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/integer.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/internal.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intfloat_readwrite.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intfloat_readwrite.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intreadwrite.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lfg.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lfg.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lls.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lls.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/log.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/log.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lzo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lzo.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mathematics.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mathematics.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/md5.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/md5.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mem.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mem.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/pca.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/pca.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rational.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rational.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rc4.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rc4.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/sha1.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/sha1.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/softfloat.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/softfloat.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/string.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/tree.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/tree.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/utils.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/x86_cpu.h
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,35 @@
+SubDir HAIKU_TOP src add-ons media plugins avcodec libavutil ;
+
+# filter warnings we don't want here
+TARGET_WARNING_CCFLAGS = [ FFilter $(TARGET_WARNING_CCFLAGS)
+	: -Wall -Wmissing-prototypes -Wsign-compare -Wpointer-arith ] ;
+
+SubDirCcFlags -fomit-frame-pointer -DPIC ;
+SubDirCcFlags -DHAVE_AV_CONFIG_H=1 ;
+
+StaticLibrary libavutil.a :
+	adler32.c
+	aes.c
+	base64.c
+	crc.c
+	des.c
+	fifo.c
+	integer.c
+	intfloat_readwrite.c
+	lfg.c
+	lls.c
+	log.c
+	lzo.c
+	mathematics.c
+	md5.c
+	mem.c
+	pca.c
+	random.c
+	rational.c
+	rc4.c
+	sha1.c
+	softfloat.c
+	string.c
+	tree.c
+	utils.c
+;

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,71 @@
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * This is a modified version based on adler32.c from the zlib library.
+ *
+ * Copyright (C) 1995 Mark Adler
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any damages
+ * arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute it
+ * freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must not
+ *    claim that you wrote the original software. If you use this software
+ *    in a product, an acknowledgment in the product documentation would be
+ *    appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must not be
+ *    misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source distribution.
+ */
+
+#include &quot;common.h&quot;
+#include &quot;adler32.h&quot;
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+
+#define DO1(buf)  {s1 += *buf++; s2 += s1;}
+#define DO4(buf)  DO1(buf); DO1(buf); DO1(buf); DO1(buf);
+#define DO16(buf) DO4(buf); DO4(buf); DO4(buf); DO4(buf);
+
+unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf, unsigned int len)
+{
+    unsigned long s1 = adler &amp; 0xffff;
+    unsigned long s2 = adler &gt;&gt; 16;
+
+    while (len&gt;0) {
+#ifdef CONFIG_SMALL
+        while(len&gt;4 &amp;&amp; s2 &lt; (1U&lt;&lt;31)){
+            DO4(buf); len-=4;
+#else
+        while(len&gt;16 &amp;&amp; s2 &lt; (1U&lt;&lt;31)){
+            DO16(buf); len-=16;
+#endif
+        }
+        DO1(buf); len--;
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 &lt;&lt; 16) | s1;
+}
+
+#ifdef TEST
+#include &quot;log.h&quot;
+#define LEN 7001
+volatile int checksum;
+int main(void){
+    int i;
+    char data[LEN];
+    av_log_level = AV_LOG_DEBUG;
+    for(i=0; i&lt;LEN; i++)
+        data[i]= ((i*i)&gt;&gt;3) + 123*i;
+    for(i=0; i&lt;1000; i++){
+        START_TIMER
+        checksum= av_adler32_update(1, data, LEN);
+        STOP_TIMER(&quot;adler&quot;)
+    }
+    av_log(NULL, AV_LOG_DEBUG, &quot;%X == 50E6E508\n&quot;, checksum);
+    return 0;
+}
+#endif

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,30 @@
+/*
+ * copyright (c) 2006 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_ADLER32_H
+#define FFMPEG_ADLER32_H
+
+#include &lt;stdint.h&gt;
+#include &quot;common.h&quot;
+
+unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
+                                unsigned int len) av_pure;
+
+#endif /* FFMPEG_ADLER32_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,243 @@
+/*
+ * copyright (c) 2007 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * some optimization ideas from aes128.c by Reimar Doeffinger
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;common.h&quot;
+#include &quot;aes.h&quot;
+
+typedef struct AVAES{
+    // Note: round_key[16] is accessed in the init code, but this only
+    // overwrites state, which does not matter (see also r7471).
+    uint8_t round_key[15][4][4];
+    uint8_t state[2][4][4];
+    int rounds;
+}AVAES;
+
+const int av_aes_size= sizeof(AVAES);
+
+static const uint8_t rcon[10] = {
+  0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
+};
+
+static uint8_t     sbox[256];
+static uint8_t inv_sbox[256];
+#ifdef CONFIG_SMALL
+static uint32_t enc_multbl[1][256];
+static uint32_t dec_multbl[1][256];
+#else
+static uint32_t enc_multbl[4][256];
+static uint32_t dec_multbl[4][256];
+#endif
+
+static inline void addkey(uint64_t dst[2], uint64_t src[2], uint64_t round_key[2]){
+    dst[0] = src[0] ^ round_key[0];
+    dst[1] = src[1] ^ round_key[1];
+}
+
+static void subshift(uint8_t s0[2][16], int s, uint8_t *box){
+    uint8_t (*s1)[16]= s0[0] - s;
+    uint8_t (*s3)[16]= s0[0] + s;
+    s0[0][0]=box[s0[1][ 0]]; s0[0][ 4]=box[s0[1][ 4]]; s0[0][ 8]=box[s0[1][ 8]]; s0[0][12]=box[s0[1][12]];
+    s1[0][3]=box[s1[1][ 7]]; s1[0][ 7]=box[s1[1][11]]; s1[0][11]=box[s1[1][15]]; s1[0][15]=box[s1[1][ 3]];
+    s0[0][2]=box[s0[1][10]]; s0[0][10]=box[s0[1][ 2]]; s0[0][ 6]=box[s0[1][14]]; s0[0][14]=box[s0[1][ 6]];
+    s3[0][1]=box[s3[1][13]]; s3[0][13]=box[s3[1][ 9]]; s3[0][ 9]=box[s3[1][ 5]]; s3[0][ 5]=box[s3[1][ 1]];
+}
+
+static inline int mix_core(uint32_t multbl[4][256], int a, int b, int c, int d){
+#ifdef CONFIG_SMALL
+#define ROT(x,s) ((x&lt;&lt;s)|(x&gt;&gt;(32-s)))
+    return multbl[0][a] ^ ROT(multbl[0][b], 8) ^ ROT(multbl[0][c], 16) ^ ROT(multbl[0][d], 24);
+#else
+    return multbl[0][a] ^ multbl[1][b] ^ multbl[2][c] ^ multbl[3][d];
+#endif
+}
+
+static inline void mix(uint8_t state[2][4][4], uint32_t multbl[4][256], int s1, int s3){
+    ((uint32_t *)(state))[0] = mix_core(multbl, state[1][0][0], state[1][s1  ][1], state[1][2][2], state[1][s3  ][3]);
+    ((uint32_t *)(state))[1] = mix_core(multbl, state[1][1][0], state[1][s3-1][1], state[1][3][2], state[1][s1-1][3]);
+    ((uint32_t *)(state))[2] = mix_core(multbl, state[1][2][0], state[1][s3  ][1], state[1][0][2], state[1][s1  ][3]);
+    ((uint32_t *)(state))[3] = mix_core(multbl, state[1][3][0], state[1][s1-1][1], state[1][1][2], state[1][s3-1][3]);
+}
+
+static inline void crypt(AVAES *a, int s, uint8_t *sbox, uint32_t *multbl){
+    int r;
+
+    for(r=a-&gt;rounds-1; r&gt;0; r--){
+        mix(a-&gt;state, multbl, 3-s, 1+s);
+        addkey(a-&gt;state[1], a-&gt;state[0], a-&gt;round_key[r]);
+    }
+    subshift(a-&gt;state[0][0], s, sbox);
+}
+
+void av_aes_crypt(AVAES *a, uint8_t *dst, uint8_t *src, int count, uint8_t *iv, int decrypt){
+    while(count--){
+        addkey(a-&gt;state[1], src, a-&gt;round_key[a-&gt;rounds]);
+        if(decrypt) {
+            crypt(a, 0, inv_sbox, dec_multbl);
+            if(iv){
+                addkey(a-&gt;state[0], a-&gt;state[0], iv);
+                memcpy(iv, src, 16);
+            }
+            addkey(dst, a-&gt;state[0], a-&gt;round_key[0]);
+        }else{
+            if(iv) addkey(a-&gt;state[1], a-&gt;state[1], iv);
+            crypt(a, 2,     sbox, enc_multbl);
+            addkey(dst, a-&gt;state[0], a-&gt;round_key[0]);
+            if(iv) memcpy(iv, dst, 16);
+        }
+        src+=16;
+        dst+=16;
+    }
+}
+
+static void init_multbl2(uint8_t tbl[1024], int c[4], uint8_t *log8, uint8_t *alog8, uint8_t *sbox){
+    int i, j;
+    for(i=0; i&lt;1024; i++){
+        int x= sbox[i&gt;&gt;2];
+        if(x) tbl[i]= alog8[ log8[x] + log8[c[i&amp;3]] ];
+    }
+#ifndef CONFIG_SMALL
+    for(j=256; j&lt;1024; j++)
+        for(i=0; i&lt;4; i++)
+            tbl[4*j+i]= tbl[4*j + ((i-1)&amp;3) - 1024];
+#endif
+}
+
+// this is based on the reference AES code by Paulo Barreto and Vincent Rijmen
+int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt) {
+    int i, j, t, rconpointer = 0;
+    uint8_t tk[8][4];
+    int KC= key_bits&gt;&gt;5;
+    int rounds= KC + 6;
+    uint8_t  log8[256];
+    uint8_t alog8[512];
+
+    if(!enc_multbl[0][sizeof(enc_multbl)/sizeof(enc_multbl[0][0])-1]){
+        j=1;
+        for(i=0; i&lt;255; i++){
+            alog8[i]=
+            alog8[i+255]= j;
+            log8[j]= i;
+            j^= j+j;
+            if(j&gt;255) j^= 0x11B;
+        }
+        for(i=0; i&lt;256; i++){
+            j= i ? alog8[255-log8[i]] : 0;
+            j ^= (j&lt;&lt;1) ^ (j&lt;&lt;2) ^ (j&lt;&lt;3) ^ (j&lt;&lt;4);
+            j = (j ^ (j&gt;&gt;8) ^ 99) &amp; 255;
+            inv_sbox[j]= i;
+            sbox    [i]= j;
+        }
+        init_multbl2(dec_multbl[0], (int[4]){0xe, 0x9, 0xd, 0xb}, log8, alog8, inv_sbox);
+        init_multbl2(enc_multbl[0], (int[4]){0x2, 0x1, 0x1, 0x3}, log8, alog8, sbox);
+    }
+
+    if(key_bits!=128 &amp;&amp; key_bits!=192 &amp;&amp; key_bits!=256)
+        return -1;
+
+    a-&gt;rounds= rounds;
+
+    memcpy(tk, key, KC*4);
+
+    for(t= 0; t &lt; (rounds+1)*16;) {
+        memcpy(a-&gt;round_key[0][0]+t, tk, KC*4);
+        t+= KC*4;
+
+        for(i = 0; i &lt; 4; i++)
+            tk[0][i] ^= sbox[tk[KC-1][(i+1)&amp;3]];
+        tk[0][0] ^= rcon[rconpointer++];
+
+        for(j = 1; j &lt; KC; j++){
+            if(KC != 8 || j != KC&gt;&gt;1)
+                for(i = 0; i &lt; 4; i++) tk[j][i] ^=      tk[j-1][i];
+            else
+                for(i = 0; i &lt; 4; i++) tk[j][i] ^= sbox[tk[j-1][i]];
+        }
+    }
+
+    if(decrypt){
+        for(i=1; i&lt;rounds; i++){
+            uint8_t tmp[3][16];
+            memcpy(tmp[2], a-&gt;round_key[i][0], 16);
+            subshift(tmp[1], 0, sbox);
+            mix(tmp, dec_multbl, 1, 3);
+            memcpy(a-&gt;round_key[i][0], tmp[0], 16);
+        }
+    }else{
+        for(i=0; i&lt;(rounds+1)&gt;&gt;1; i++){
+            for(j=0; j&lt;16; j++)
+                FFSWAP(int, a-&gt;round_key[i][0][j], a-&gt;round_key[rounds-i][0][j]);
+        }
+    }
+
+    return 0;
+}
+
+#ifdef TEST
+#include &quot;log.h&quot;
+
+#undef random
+
+int main(void){
+    int i,j;
+    AVAES ae, ad, b;
+    uint8_t rkey[2][16]= {
+        {0},
+        {0x10, 0xa5, 0x88, 0x69, 0xd7, 0x4b, 0xe5, 0xa3, 0x74, 0xcf, 0x86, 0x7c, 0xfb, 0x47, 0x38, 0x59}};
+    uint8_t pt[16], rpt[2][16]= {
+        {0x6a, 0x84, 0x86, 0x7c, 0xd7, 0x7e, 0x12, 0xad, 0x07, 0xea, 0x1b, 0xe8, 0x95, 0xc5, 0x3f, 0xa3},
+        {0}};
+    uint8_t rct[2][16]= {
+        {0x73, 0x22, 0x81, 0xc0, 0xa0, 0xaa, 0xb8, 0xf7, 0xa5, 0x4a, 0x0c, 0x67, 0xa0, 0xc4, 0x5e, 0xcf},
+        {0x6d, 0x25, 0x1e, 0x69, 0x44, 0xb0, 0x51, 0xe0, 0x4e, 0xaa, 0x6f, 0xb4, 0xdb, 0xf7, 0x84, 0x65}};
+    uint8_t temp[16];
+
+    av_aes_init(&amp;ae, &quot;PI=3.141592654..&quot;, 128, 0);
+    av_aes_init(&amp;ad, &quot;PI=3.141592654..&quot;, 128, 1);
+    av_log_level= AV_LOG_DEBUG;
+
+    for(i=0; i&lt;2; i++){
+        av_aes_init(&amp;b, rkey[i], 128, 1);
+        av_aes_crypt(&amp;b, temp, rct[i], 1, NULL, 1);
+        for(j=0; j&lt;16; j++)
+            if(rpt[i][j] != temp[j])
+                av_log(NULL, AV_LOG_ERROR, &quot;%d %02X %02X\n&quot;, j, rpt[i][j], temp[j]);
+    }
+
+    for(i=0; i&lt;10000; i++){
+        for(j=0; j&lt;16; j++){
+            pt[j]= random();
+        }
+{START_TIMER
+        av_aes_crypt(&amp;ae, temp, pt, 1, NULL, 0);
+        if(!(i&amp;(i-1)))
+            av_log(NULL, AV_LOG_ERROR, &quot;%02X %02X %02X %02X\n&quot;, temp[0], temp[5], temp[10], temp[15]);
+        av_aes_crypt(&amp;ad, temp, temp, 1, NULL, 1);
+STOP_TIMER(&quot;aes&quot;)}
+        for(j=0; j&lt;16; j++){
+            if(pt[j] != temp[j]){
+                av_log(NULL, AV_LOG_ERROR, &quot;%d %d %02X %02X\n&quot;, i,j, pt[j], temp[j]);
+            }
+        }
+    }
+    return 0;
+}
+#endif

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,47 @@
+/*
+ * copyright (c) 2007 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_AES_H
+#define FFMPEG_AES_H
+
+#include &lt;stdint.h&gt;
+
+extern const int av_aes_size;
+
+struct AVAES;
+
+/**
+ * Initializes an AVAES context.
+ * @param key_bits 128, 192 or 256
+ * @param decrypt 0 for encryption, 1 for decryption
+ */
+int av_aes_init(struct AVAES *a, const uint8_t *key, int key_bits, int decrypt);
+
+/**
+ * Encrypts / decrypts.
+ * @param count number of 16 byte blocks
+ * @param dst destination array, can be equal to src
+ * @param src source array, can be equal to dst
+ * @param iv initialization vector for CBC mode, if NULL then ECB will be used
+ * @param decrypt 0 for encryption, 1 for decryption
+ */
+void av_aes_crypt(struct AVAES *a, uint8_t *dst, uint8_t *src, int count, uint8_t *iv, int decrypt);
+
+#endif /* FFMPEG_AES_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2007 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_AVSTRING_H
+#define FFMPEG_AVSTRING_H
+
+#include &lt;stddef.h&gt;
+
+/**
+ * Return non-zero if pfx is a prefix of str. If it is, *ptr is set to
+ * the address of the first character in str after the prefix.
+ *
+ * @param str input string
+ * @param pfx prefix to test
+ * @param ptr updated after the prefix in str in there is a match
+ * @return non-zero if the prefix matches, zero otherwise
+ */
+int av_strstart(const char *str, const char *pfx, const char **ptr);
+
+/**
+ * Return non-zero if pfx is a prefix of str independent of case. If
+ * it is, *ptr is set to the address of the first character in str
+ * after the prefix.
+ *
+ * @param str input string
+ * @param pfx prefix to test
+ * @param ptr updated after the prefix in str in there is a match
+ * @return non-zero if the prefix matches, zero otherwise
+ */
+int av_stristart(const char *str, const char *pfx, const char **ptr);
+
+/**
+ * Copy the string src to dst, but no more than size - 1 bytes, and
+ * null terminate dst.
+ *
+ * This function is the same as BSD strlcpy().
+ *
+ * @param dst destination buffer
+ * @param src source string
+ * @param size size of destination buffer
+ * @return the length of src
+ */
+size_t av_strlcpy(char *dst, const char *src, size_t size);
+
+/**
+ * Append the string src to the string dst, but to a total length of
+ * no more than size - 1 bytes, and null terminate dst.
+ *
+ * This function is similar to BSD strlcat(), but differs when
+ * size &lt;= strlen(dst).
+ *
+ * @param dst destination buffer
+ * @param src source string
+ * @param size size of destination buffer
+ * @return the total length of src and dst
+ */
+size_t av_strlcat(char *dst, const char *src, size_t size);
+
+/**
+ * Append output to a string, according to a format. Never write out of
+ * the destination buffer, and and always put a terminating 0 within
+ * the buffer.
+ * @param dst destination buffer (string to which the output is
+ *  appended)
+ * @param size total size of the destination buffer
+ * @param fmt printf-compatible format string, specifying how the
+ *  following parameters are used
+ * @return the length of the string that would have been generated
+ *  if enough space had been available
+ */
+size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...);
+
+#endif /* FFMPEG_AVSTRING_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,147 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_AVUTIL_H
+#define FFMPEG_AVUTIL_H
+
+/**
+ * @file avutil.h
+ * external API header
+ */
+
+
+#define AV_STRINGIFY(s)         AV_TOSTRING(s)
+#define AV_TOSTRING(s) #s
+
+#define AV_VERSION_INT(a, b, c) (a&lt;&lt;16 | b&lt;&lt;8 | c)
+#define AV_VERSION_DOT(a, b, c) a ##.## b ##.## c
+#define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
+
+#define LIBAVUTIL_VERSION_MAJOR 49
+#define LIBAVUTIL_VERSION_MINOR 10
+#define LIBAVUTIL_VERSION_MICRO  0
+
+#define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
+                                               LIBAVUTIL_VERSION_MINOR, \
+                                               LIBAVUTIL_VERSION_MICRO)
+#define LIBAVUTIL_VERSION       AV_VERSION(LIBAVUTIL_VERSION_MAJOR,     \
+                                           LIBAVUTIL_VERSION_MINOR,     \
+                                           LIBAVUTIL_VERSION_MICRO)
+#define LIBAVUTIL_BUILD         LIBAVUTIL_VERSION_INT
+
+#define LIBAVUTIL_IDENT         &quot;Lavu&quot; AV_STRINGIFY(LIBAVUTIL_VERSION)
+
+/**
+ * Returns the LIBAVUTIL_VERSION_INT constant.
+ */
+unsigned avutil_version(void);
+
+#include &quot;common.h&quot;
+#include &quot;mathematics.h&quot;
+#include &quot;rational.h&quot;
+#include &quot;intfloat_readwrite.h&quot;
+#include &quot;log.h&quot;
+
+/**
+ * Pixel format. Notes:
+ *
+ * PIX_FMT_RGB32 is handled in an endian-specific manner. A RGBA
+ * color is put together as:
+ *  (A &lt;&lt; 24) | (R &lt;&lt; 16) | (G &lt;&lt; 8) | B
+ * This is stored as BGRA on little endian CPU architectures and ARGB on
+ * big endian CPUs.
+ *
+ * When the pixel format is palettized RGB (PIX_FMT_PAL8), the palettized
+ * image data is stored in AVFrame.data[0]. The palette is transported in
+ * AVFrame.data[1] and, is 1024 bytes long (256 4-byte entries) and is
+ * formatted the same as in PIX_FMT_RGB32 described above (i.e., it is
+ * also endian-specific). Note also that the individual RGB palette
+ * components stored in AVFrame.data[1] should be in the range 0..255.
+ * This is important as many custom PAL8 video codecs that were designed
+ * to run on the IBM VGA graphics adapter use 6-bit palette components.
+ */
+enum PixelFormat {
+    PIX_FMT_NONE= -1,
+    PIX_FMT_YUV420P,   ///&lt; Planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)
+    PIX_FMT_YUYV422,   ///&lt; Packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
+    PIX_FMT_RGB24,     ///&lt; Packed RGB 8:8:8, 24bpp, RGBRGB...
+    PIX_FMT_BGR24,     ///&lt; Packed RGB 8:8:8, 24bpp, BGRBGR...
+    PIX_FMT_YUV422P,   ///&lt; Planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)
+    PIX_FMT_YUV444P,   ///&lt; Planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)
+    PIX_FMT_RGB32,     ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8A 8R 8G 8B(lsb), in cpu endianness
+    PIX_FMT_YUV410P,   ///&lt; Planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)
+    PIX_FMT_YUV411P,   ///&lt; Planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)
+    PIX_FMT_RGB565,    ///&lt; Packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), in cpu endianness
+    PIX_FMT_RGB555,    ///&lt; Packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), in cpu endianness most significant bit to 0
+    PIX_FMT_GRAY8,     ///&lt;        Y        ,  8bpp
+    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black
+    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white
+    PIX_FMT_PAL8,      ///&lt; 8 bit with PIX_FMT_RGB32 palette
+    PIX_FMT_YUVJ420P,  ///&lt; Planar YUV 4:2:0, 12bpp, full scale (jpeg)
+    PIX_FMT_YUVJ422P,  ///&lt; Planar YUV 4:2:2, 16bpp, full scale (jpeg)
+    PIX_FMT_YUVJ444P,  ///&lt; Planar YUV 4:4:4, 24bpp, full scale (jpeg)
+    PIX_FMT_XVMC_MPEG2_MC,///&lt; XVideo Motion Acceleration via common packet passing(xvmc_render.h)
+    PIX_FMT_XVMC_MPEG2_IDCT,
+    PIX_FMT_UYVY422,   ///&lt; Packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
+    PIX_FMT_UYYVYY411, ///&lt; Packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
+    PIX_FMT_BGR32,     ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8A 8B 8G 8R(lsb), in cpu endianness
+    PIX_FMT_BGR565,    ///&lt; Packed RGB 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), in cpu endianness
+    PIX_FMT_BGR555,    ///&lt; Packed RGB 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), in cpu endianness most significant bit to 1
+    PIX_FMT_BGR8,      ///&lt; Packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
+    PIX_FMT_BGR4,      ///&lt; Packed RGB 1:2:1,  4bpp, (msb)1B 2G 1R(lsb)
+    PIX_FMT_BGR4_BYTE, ///&lt; Packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
+    PIX_FMT_RGB8,      ///&lt; Packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
+    PIX_FMT_RGB4,      ///&lt; Packed RGB 1:2:1,  4bpp, (msb)2R 3G 3B(lsb)
+    PIX_FMT_RGB4_BYTE, ///&lt; Packed RGB 1:2:1,  8bpp, (msb)2R 3G 3B(lsb)
+    PIX_FMT_NV12,      ///&lt; Planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 for UV
+    PIX_FMT_NV21,      ///&lt; as above, but U and V bytes are swapped
+
+    PIX_FMT_RGB32_1,   ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8R 8G 8B 8A(lsb), in cpu endianness
+    PIX_FMT_BGR32_1,   ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8B 8G 8R 8A(lsb), in cpu endianness
+
+    PIX_FMT_GRAY16BE,  ///&lt;        Y        , 16bpp, big-endian
+    PIX_FMT_GRAY16LE,  ///&lt;        Y        , 16bpp, little-endian
+    PIX_FMT_YUV440P,   ///&lt; Planar YUV 4:4:0 (1 Cr &amp; Cb sample per 1x2 Y samples)
+    PIX_FMT_YUVJ440P,  ///&lt; Planar YUV 4:4:0 full scale (jpeg)
+    PIX_FMT_YUVA420P,  ///&lt; Planar YUV 4:2:0, 20bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples)
+    PIX_FMT_NB,        ///&lt; number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
+};
+
+#ifdef WORDS_BIGENDIAN
+#define PIX_FMT_RGBA PIX_FMT_RGB32_1
+#define PIX_FMT_BGRA PIX_FMT_BGR32_1
+#define PIX_FMT_ARGB PIX_FMT_RGB32
+#define PIX_FMT_ABGR PIX_FMT_BGR32
+#define PIX_FMT_GRAY16 PIX_FMT_GRAY16BE
+#else
+#define PIX_FMT_RGBA PIX_FMT_BGR32
+#define PIX_FMT_BGRA PIX_FMT_RGB32
+#define PIX_FMT_ARGB PIX_FMT_BGR32_1
+#define PIX_FMT_ABGR PIX_FMT_RGB32_1
+#define PIX_FMT_GRAY16 PIX_FMT_GRAY16LE
+#endif
+
+#if LIBAVUTIL_VERSION_INT &lt; (50&lt;&lt;16)
+#define PIX_FMT_UYVY411 PIX_FMT_UYYVYY411
+#define PIX_FMT_RGBA32  PIX_FMT_RGB32
+#define PIX_FMT_YUV422  PIX_FMT_YUYV422
+#endif
+
+#endif /* FFMPEG_AVUTIL_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,228 @@
+/*
+ * Base64.c
+ * Copyright (c) 2006 Ryan Martell. (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+* @file base64.c
+ * @brief Base64 Encode/Decode
+ * @author Ryan Martell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>&gt; (with lots of Michael)
+ */
+
+#include &quot;common.h&quot;
+#include &quot;base64.h&quot;
+
+/* ---------------- private code */
+static const uint8_t map2[] =
+{
+    0x3e, 0xff, 0xff, 0xff, 0x3f, 0x34, 0x35, 0x36,
+    0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x01,
+    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
+    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
+    0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1a, 0x1b,
+    0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
+    0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
+    0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33
+};
+
+int av_base64_decode(uint8_t * out, const char *in, int out_length)
+{
+    int i, v;
+    uint8_t *dst = out;
+
+    v = 0;
+    for (i = 0; in[i] &amp;&amp; in[i] != '='; i++) {
+        unsigned int index= in[i]-43;
+        if (index&gt;=(sizeof(map2)/sizeof(map2[0])) || map2[index] == 0xff)
+            return -1;
+        v = (v &lt;&lt; 6) + map2[index];
+        if (i &amp; 3) {
+            if (dst - out &lt; out_length) {
+                *dst++ = v &gt;&gt; (6 - 2 * (i &amp; 3));
+            }
+        }
+    }
+
+    return dst - out;
+}
+
+/*****************************************************************************
+* b64_encode: stolen from VLC's http.c
+* simplified by michael
+* fixed edge cases and made it work from data (vs. strings) by ryan.
+*****************************************************************************/
+
+char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len)
+{
+    static const char b64[] =
+        &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+    char *ret, *dst;
+    unsigned i_bits = 0;
+    int i_shift = 0;
+    int bytes_remaining = len;
+
+    if (len &gt;= UINT_MAX / 4 ||
+        buf_len &lt; len * 4 / 3 + 12)
+        return NULL;
+    ret = dst = buf;
+    while (bytes_remaining) {
+        i_bits = (i_bits &lt;&lt; 8) + *src++;
+        bytes_remaining--;
+        i_shift += 8;
+
+        do {
+            *dst++ = b64[(i_bits &lt;&lt; 6 &gt;&gt; i_shift) &amp; 0x3f];
+            i_shift -= 6;
+        } while (i_shift &gt; 6 || (bytes_remaining == 0 &amp;&amp; i_shift &gt; 0));
+    }
+    while ((dst - ret) &amp; 3)
+        *dst++ = '=';
+    *dst = '\0';
+
+    return ret;
+}
+
+// #define TEST_BASE64
+
+#ifdef TEST_BASE64
+#include &quot;avutil.h&quot;
+
+int b64test()
+{
+    int numerr = 0;
+    int len;
+    int numtest = 1;
+    uint8_t decode[1000];
+    struct test {
+        void *data;
+        int len;
+        const char *result;
+    } *t, tests[] = {
+        {
+        &quot;&quot;, 0, &quot;&quot;}, {
+        &quot;1&quot;, 1, &quot;MQ==&quot;}, {
+        &quot;22&quot;, 2, &quot;MjI=&quot;}, {
+        &quot;333&quot;, 3, &quot;MzMz&quot;}, {
+        &quot;4444&quot;, 4, &quot;NDQ0NA==&quot;}, {
+        &quot;55555&quot;, 5, &quot;NTU1NTU=&quot;}, {
+        &quot;abc:def&quot;, 7, &quot;YWJjOmRlZg==&quot;}, {
+        NULL}
+    };
+    for (t = tests; t-&gt;data; t++) {
+        char *str;
+
+        av_log(NULL, AV_LOG_ERROR, &quot;Encoding %s...\n&quot;, (char *) t-&gt;data);
+        str = av_base64_encode(t-&gt;data, t-&gt;len);
+        if (str) {
+            av_log(NULL, AV_LOG_ERROR, &quot;Encoded to %s...\n&quot;, str);
+            if (strcmp(str, t-&gt;result) != 0) {
+                av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: %s != %s\n&quot;,
+                       numtest, str, t-&gt;result);
+                numerr++;
+            }
+            av_free(str);
+        }
+
+        av_log(NULL, AV_LOG_ERROR, &quot;Done encoding, about to decode...\n&quot;);
+        len = av_base64_decode(decode, t-&gt;result, sizeof(decode));
+        if (len != t-&gt;len) {
+            av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: len %d != %d\n&quot;,
+                   numtest, len, t-&gt;len);
+            numerr++;
+        } else if (memcmp(decode, t-&gt;data, t-&gt;len) != 0) {
+            av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: data\n&quot;, numtest);
+            numerr++;
+        } else {
+            av_log(NULL, AV_LOG_ERROR, &quot;Decoded to %s\n&quot;,
+                   (char *) t-&gt;data);
+        }
+        numtest++;
+    }
+
+#undef srand
+#undef rand
+
+    {
+        int test_count;
+        srand(123141);          // time(NULL));
+        for (test_count = 0; test_count &lt; 100; test_count++) {
+            int size = rand() % 1024;
+            int ii;
+            uint8_t *data;
+            char *encoded_result;
+
+            av_log(NULL, AV_LOG_ERROR, &quot;Test %d: Size %d bytes...&quot;,
+                   test_count, size);
+            data = (uint8_t *) av_malloc(size);
+            for (ii = 0; ii &lt; size; ii++) {
+                data[ii] = rand() % 255;
+            }
+
+            encoded_result = av_base64_encode(data, size);
+            if (encoded_result) {
+                int decode_buffer_size = size + 10;     // try without 10 as well
+                uint8_t *decode_buffer = av_malloc(decode_buffer_size);
+                if (decode_buffer) {
+                    int decoded_size =
+                        av_base64_decode(decode_buffer, encoded_result,
+                                   decode_buffer_size);
+
+                    if (decoded_size != size) {
+                        av_log(NULL, AV_LOG_ERROR,
+                               &quot;Decoded/Encoded size mismatch (%d != %d)\n&quot;,
+                               decoded_size, size);
+                    } else {
+                        if (memcmp(decode_buffer, data, decoded_size) == 0) {
+                            av_log(NULL, AV_LOG_ERROR, &quot;Passed!\n&quot;);
+                        } else {
+                            av_log(NULL, AV_LOG_ERROR,
+                                   &quot;Failed (Data differs)!\n&quot;);
+                        }
+                    }
+                    av_free(decode_buffer);
+                }
+
+                av_free(encoded_result);
+            }
+        }
+    }
+
+    // these are invalid strings, that it currently decodes (which it probably shouldn't?)
+    {
+        uint8_t str[32];
+        if (av_base64_decode(str, &quot;M=M=&quot;, sizeof(str)) != -1) {
+            av_log(NULL, AV_LOG_ERROR,
+                   &quot;failed test %d: successful decode of `M=M='\n&quot;,
+                   numtest++);
+            numerr++;
+        }
+        if (av_base64_decode(str, &quot;MQ===&quot;, sizeof(str)) != -1) {
+            av_log(NULL, AV_LOG_ERROR,
+                   &quot;failed test %d: successful decode of `MQ==='\n&quot;,
+                   numtest++);
+            numerr++;
+        }
+    }
+
+    return numerr;
+}
+#endif
+

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,40 @@
+/*
+ * Base64.c
+ * Copyright (c) 2006 Ryan Martell. (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_BASE64_H
+#define FFMPEG_BASE64_H
+
+#include &lt;stdint.h&gt;
+
+/**
+ * decodes base64
+ * param order as strncpy()
+ */
+int av_base64_decode(uint8_t * out, const char *in, int out_length);
+
+/**
+ * encodes base64
+ * @param src data, not a string
+ * @param buf output string
+ */
+char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len);
+
+#endif /* FFMPEG_BASE64_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h	2008-09-15 13:51:10 UTC (rev 27535)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h	2008-09-15 13:51:33 UTC (rev 27536)
@@ -0,0 +1,132 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *

[... truncated: 5926 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011999.html">[Haiku-commits] r27535 - haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
	<LI>Next message: <A HREF="011847.html">[Haiku-commits] r27537 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11846">[ date ]</a>
              <a href="thread.html#11846">[ thread ]</a>
              <a href="subject.html#11846">[ subject ]</a>
              <a href="author.html#11846">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
