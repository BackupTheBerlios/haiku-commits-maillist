<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27644 - haiku/trunk/src/kits/interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27644%20-%20haiku/trunk/src/kits/interface&In-Reply-To=%3C200809201017.m8KAH1K5028180%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012029.html">
   <LINK REL="Next"  HREF="012031.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27644 - haiku/trunk/src/kits/interface</H1>
    <B>julun at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27644%20-%20haiku/trunk/src/kits/interface&In-Reply-To=%3C200809201017.m8KAH1K5028180%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27644 - haiku/trunk/src/kits/interface">julun at mail.berlios.de
       </A><BR>
    <I>Sat Sep 20 12:17:01 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="012029.html">[Haiku-commits] r27643 - haiku/trunk/headers/os/interface
</A></li>
        <LI>Next message: <A HREF="012031.html">[Haiku-commits] r27645 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12030">[ date ]</a>
              <a href="thread.html#12030">[ thread ]</a>
              <a href="subject.html#12030">[ subject ]</a>
              <a href="author.html#12030">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: julun
Date: 2008-09-20 12:17:00 +0200 (Sat, 20 Sep 2008)
New Revision: 27644
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27644&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27644&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/interface/Menu.cpp
Log:
* automatic whitespace cleanup



Modified: haiku/trunk/src/kits/interface/Menu.cpp
===================================================================
--- haiku/trunk/src/kits/interface/Menu.cpp	2008-09-20 10:09:32 UTC (rev 27643)
+++ haiku/trunk/src/kits/interface/Menu.cpp	2008-09-20 10:17:00 UTC (rev 27644)
@@ -860,7 +860,7 @@
 					// if we have no submenu and we're an
 					// item in the top menu below the menubar,
 					// pass the keypress to the menubar
-					// so you can use the keypress to switch menus.				
+					// so you can use the keypress to switch menus.
 					BMessenger msgr(Supermenu());
 					msgr.SendMessage(Window()-&gt;CurrentMessage());
 				}
@@ -871,7 +871,7 @@
 		case B_SPACE:
 			if (fSelected) {
 				_InvokeItem(fSelected);
-				_QuitTracking(false);			
+				_QuitTracking(false);
 			}
 			break;
 
@@ -1263,7 +1263,7 @@
 
 	fLayoutData = new LayoutData;
 	fLayoutData-&gt;lastResizingMode = ResizingMode();
-	
+
 	SetLowColor(sMenuInfo.background_color);
 	SetViewColor(sMenuInfo.background_color);
 
@@ -1285,7 +1285,7 @@
 		archive-&gt;FindFloat(&quot;_maxwidth&quot;, &amp;fMaxContentWidth);
 
 		BMessage msg;
-       		for (int32 i = 0; archive-&gt;FindMessage(&quot;_items&quot;, i, &amp;msg) == B_OK; i++) {
+			for (int32 i = 0; archive-&gt;FindMessage(&quot;_items&quot;, i, &amp;msg) == B_OK; i++) {
 			BArchivable *object = instantiate_object(&amp;msg);
 			if (BMenuItem *item = dynamic_cast&lt;BMenuItem *&gt;(object)) {
 				BRect bounds;
@@ -1389,7 +1389,7 @@
 const static bigtime_t kOpenSubmenuDelay = 225000;
 const static bigtime_t kNavigationAreaTimeout = 1000000;
 const static bigtime_t kHysteresis = 200000; // TODO: Test and reduce if needed.
-const static int32 kMouseMotionThreshold = 15; 
+const static int32 kMouseMotionThreshold = 15;
 	// TODO: Same as above. Actually, we could get rid of the kHysteresis
 
 
@@ -1422,19 +1422,19 @@
 
 		if (!LockLooper())
 			break;
-		
+
 		BMenuWindow *window = static_cast&lt;BMenuWindow *&gt;(Window());
 		BPoint screenLocation = ConvertToScreen(location);
 		if (window-&gt;CheckForScrolling(screenLocation)) {
-			UnlockLooper();		
+			UnlockLooper();
 			continue;
 		}
-	
+
 		// The order of the checks is important
 		// to be able to handle overlapping menus:
 		// first we check if mouse is inside a submenu,
 		// then if the menu is inside this menu,
-		// then if it's over a super menu. 
+		// then if it's over a super menu.
 		bool overSub = _OverSubmenu(fSelected, screenLocation);
 		item = _HitTestItems(location, B_ORIGIN);
 		if (overSub) {
@@ -1453,21 +1453,21 @@
 			// The following call blocks until the submenu
 			// gives control back to us, either because the mouse
 			// pointer goes out of the submenu's bounds, or because
-			// the user closes the menu 
+			// the user closes the menu
 			BMenuItem *submenuItem = submenu-&gt;_Track(&amp;submenuAction);
 			if (submenuAction == MENU_STATE_CLOSED) {
 				item = submenuItem;
-				fState = MENU_STATE_CLOSED;			
+				fState = MENU_STATE_CLOSED;
 			}
 			if (!LockLooper())
-				break;			
+				break;
 		} else if (item != NULL) {
 			_UpdateStateOpenSelect(item, location, navAreaRectAbove,
 				navAreaRectBelow, selectedTime, navigationAreaTime);
 			if (!releasedOnce)
-				releasedOnce = true;		
+				releasedOnce = true;
 		} else if (_OverSuper(screenLocation)) {
-			fState = MENU_STATE_TRACKING;			
+			fState = MENU_STATE_TRACKING;
 			UnlockLooper();
 			break;
 		} else {
@@ -1497,13 +1497,13 @@
 
 			BPoint newLocation;
 			uint32 newButtons;
-			
+
 			bigtime_t newPollTime = system_time();
-			if (LockLooper()) {	
+			if (LockLooper()) {
 				GetMouse(&amp;newLocation, &amp;newButtons, true);
-				UnlockLooper();		
+				UnlockLooper();
 			}
-			
+
 			// mouseSpeed in px per ms
 			// (actually point_distance returns the square of the distance,
 			// so it's more px^2 per ms)
@@ -1512,14 +1512,14 @@
 
 			if (newLocation != location || newButtons != buttons) {
 				if (!releasedOnce &amp;&amp; newButtons == 0 &amp;&amp; buttons != 0)
-					releasedOnce = true;				
+					releasedOnce = true;
 				location = newLocation;
-				buttons = newButtons;				
+				buttons = newButtons;
 			}
-		
+
 			if (releasedOnce)
 				_UpdateStateClose(item, location, buttons);
-		}	
+		}
 	}
 
 	if (action != NULL)
@@ -1548,7 +1548,7 @@
 	// submenus, as the cursor can be moved to submenu items directly instead
 	// of having to move it horizontally into the submenu first. The concept
 	// is illustrated below:
-	// 
+	//
 	// +-------+----+---------+
 	// |       |   /|         |
 	// |       |  /*|         |
@@ -1570,7 +1570,7 @@
 	// [3] Lower navigation area rectangle ('navAreaRectBelow')
 	// [4] Upper navigation area
 	// [5] Lower navigation area
-	// [6] Submenu	
+	// [6] Submenu
 	//
 	// The rectangles are used to calculate if the cursor is in the actual
 	// navigation area (see _UpdateStateOpenSelect()).
@@ -1602,7 +1602,7 @@
 			navAreaRectBelow.Set(menuBounds.left,
 				position.y, position.x - NAV_AREA_THRESHOLD,
 				submenuBounds.bottom);
-		}	
+		}
 	} else {
 		navAreaRectAbove = BRect();
 		navAreaRectBelow = BRect();
@@ -1855,7 +1855,7 @@
 BSize
 BMenu::_ValidatePreferredSize()
 {
-	if (!fLayoutData-&gt;preferred.IsWidthSet() || ResizingMode() != fLayoutData-&gt;lastResizingMode)		
+	if (!fLayoutData-&gt;preferred.IsWidthSet() || ResizingMode() != fLayoutData-&gt;lastResizingMode)
 		_ComputeLayout(0, true, false, NULL, NULL);
 
 	return fLayoutData-&gt;preferred;
@@ -1869,7 +1869,7 @@
 	// TODO: Take &quot;bestFit&quot;, &quot;moveItems&quot;, &quot;index&quot; into account,
 	// Recalculate only the needed items,
 	// not the whole layout every time
-	
+
 	fLayoutData-&gt;lastResizingMode = ResizingMode();
 
 	BRect frame;
@@ -2357,21 +2357,21 @@
 BMenu::_NextItem(BMenuItem *item, bool forward) const
 {
 	// go to next item, and skip over disabled items such as separators
- 	int32 index = fItems.IndexOf(item);
+	int32 index = fItems.IndexOf(item);
 	const int32 numItems = fItems.CountItems();
 	if (index &lt; 0) {
 		if (forward)
 			index = -1;
 		else
 			index = numItems;
-	}	
+	}
 	int32 startIndex = index;
 	do {
 		if (forward)
 			index++;
 		else
 			index--;
- 		
+
 		// cycle through menu items
 		if (index &lt; 0)
 			index = numItems - 1;
@@ -2398,7 +2398,7 @@
 {
 	if (fStickyMode == on)
 		return;
-	
+
 	fStickyMode = on;
 
 	// If we are switching to sticky mode, propagate the status
@@ -2579,7 +2579,7 @@
 
 	// Close the whole menu hierarchy
 	if (!onlyThis &amp;&amp; _IsStickyMode())
-		_SetStickyMode(false);	
+		_SetStickyMode(false);
 
 	_Hide();
 }
@@ -2628,7 +2628,7 @@
 
 // MenuPrivate
 namespace BPrivate {
-	
+
 MenuPrivate::MenuPrivate(BMenu *menu)
 	:
 	fMenu(menu)
@@ -2656,7 +2656,7 @@
 	fMenu-&gt;_CacheFontInfo();
 }
 
-	
+
 float
 MenuPrivate::FontHeight() const
 {
@@ -2699,7 +2699,7 @@
 	return fMenu-&gt;_State(item);
 }
 
-		
+
 void
 MenuPrivate::Install(BWindow *window)
 {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012029.html">[Haiku-commits] r27643 - haiku/trunk/headers/os/interface
</A></li>
	<LI>Next message: <A HREF="012031.html">[Haiku-commits] r27645 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12030">[ date ]</a>
              <a href="thread.html#12030">[ thread ]</a>
              <a href="subject.html#12030">[ subject ]</a>
              <a href="author.html#12030">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
