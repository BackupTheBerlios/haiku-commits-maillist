<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27556%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151409.m8FE9IfD000904%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011865.html">
   <LINK REL="Next"  HREF="011867.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27556%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151409.m8FE9IfD000904%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:09:18 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011865.html">[Haiku-commits] r27555 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011867.html">[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11866">[ date ]</a>
              <a href="thread.html#11866">[ thread ]</a>
              <a href="subject.html#11866">[ subject ]</a>
              <a href="author.html#11866">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:09:14 +0200 (Mon, 15 Sep 2008)
New Revision: 27556
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27556&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27556&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12data.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12decdata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12enc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg4audio.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg4audio.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg4video_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg4video_parser.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudio_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodata.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodecheader.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodecheader.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudioenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegvideo_common.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegvideo_enc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegvideo_parser.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg4data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudio.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudio.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiodectab.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegaudiotab.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegvideo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpegvideo.h
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12.c	2008-09-15 14:08:35 UTC (rev 27555)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpeg12.c	2008-09-15 14:09:14 UTC (rev 27556)
@@ -1,115 +1,104 @@
 /*
- * MPEG1 codec / MPEG2 decoder
+ * MPEG-1/2 decoder
  * Copyright (c) 2000,2001 Fabrice Bellard.
- * Copyright (c) 2002-2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt; 
+ * Copyright (c) 2002-2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
- 
+
 /**
  * @file mpeg12.c
- * MPEG1/2 codec
+ * MPEG-1/2 decoder
  */
- 
+
 //#define DEBUG
 #include &quot;avcodec.h&quot;
 #include &quot;dsputil.h&quot;
 #include &quot;mpegvideo.h&quot;
 
+#include &quot;mpeg12.h&quot;
 #include &quot;mpeg12data.h&quot;
+#include &quot;mpeg12decdata.h&quot;
+#include &quot;bytestream.h&quot;
 
 //#undef NDEBUG
 //#include &lt;assert.h&gt;
 
 
-/* Start codes. */
-#define SEQ_END_CODE		0x000001b7
-#define SEQ_START_CODE		0x000001b3
-#define GOP_START_CODE		0x000001b8
-#define PICTURE_START_CODE	0x00000100
-#define SLICE_MIN_START_CODE	0x00000101
-#define SLICE_MAX_START_CODE	0x000001af
-#define EXT_START_CODE		0x000001b5
-#define USER_START_CODE		0x000001b2
-
-#define DC_VLC_BITS 9
 #define MV_VLC_BITS 9
 #define MBINCR_VLC_BITS 9
 #define MB_PAT_VLC_BITS 9
 #define MB_PTYPE_VLC_BITS 6
 #define MB_BTYPE_VLC_BITS 6
-#define TEX_VLC_BITS 9
 
-#ifdef CONFIG_ENCODERS
-static void mpeg1_encode_block(MpegEncContext *s, 
-                         DCTELEM *block, 
-                         int component);
-static void mpeg1_encode_motion(MpegEncContext *s, int val, int f_or_b_code);    // RAL: f_code parameter added
-#endif //CONFIG_ENCODERS
-static inline int mpeg1_decode_block_inter(MpegEncContext *s, 
-                              DCTELEM *block, 
+static inline int mpeg1_decode_block_inter(MpegEncContext *s,
+                              DCTELEM *block,
                               int n);
-static inline int mpeg1_decode_block_intra(MpegEncContext *s, 
-                              DCTELEM *block, 
+static inline int mpeg1_decode_block_intra(MpegEncContext *s,
+                              DCTELEM *block,
                               int n);
-static inline int mpeg2_decode_block_non_intra(MpegEncContext *s, 
-                                        DCTELEM *block, 
+static inline int mpeg1_fast_decode_block_inter(MpegEncContext *s, DCTELEM *block, int n);
+static inline int mpeg2_decode_block_non_intra(MpegEncContext *s,
+                                        DCTELEM *block,
                                         int n);
-static inline int mpeg2_decode_block_intra(MpegEncContext *s, 
-                                    DCTELEM *block, 
+static inline int mpeg2_decode_block_intra(MpegEncContext *s,
+                                    DCTELEM *block,
                                     int n);
+static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s, DCTELEM *block, int n);
+static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s, DCTELEM *block, int n);
 static int mpeg_decode_motion(MpegEncContext *s, int fcode, int pred);
 static void exchange_uv(MpegEncContext *s);
 
-#ifdef HAVE_XVMC
 extern int XVMC_field_start(MpegEncContext *s, AVCodecContext *avctx);
 extern int XVMC_field_end(MpegEncContext *s);
 extern void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 extern void XVMC_init_block(MpegEncContext *s);//set s-&gt;block
-#endif
 
-#ifdef CONFIG_ENCODERS
-static uint8_t (*mv_penalty)[MAX_MV*2+1]= NULL;
-static uint8_t fcode_tab[MAX_MV*2+1];
+static const enum PixelFormat pixfmt_yuv_420[]= {PIX_FMT_YUV420P,PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_yuv_422[]= {PIX_FMT_YUV422P,PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_yuv_444[]= {PIX_FMT_YUV444P,PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
+                                           PIX_FMT_XVMC_MPEG2_IDCT,
+                                           PIX_FMT_XVMC_MPEG2_MC,
+                                           PIX_FMT_NONE};
 
-static uint32_t uni_mpeg1_ac_vlc_bits[64*64*2];
-static uint8_t  uni_mpeg1_ac_vlc_len [64*64*2];
+uint8_t ff_mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
 
-/* simple include everything table for dc, first byte is bits number next 3 are code*/
-static uint32_t mpeg1_lum_dc_uni[512];
-static uint32_t mpeg1_chr_dc_uni[512];
 
-static uint8_t mpeg1_index_run[2][64];
-static int8_t mpeg1_max_level[2][64];
-#endif //CONFIG_ENCODERS
+#define INIT_2D_VLC_RL(rl, static_size)\
+{\
+    static RL_VLC_ELEM rl_vlc_table[static_size];\
+    INIT_VLC_STATIC(&amp;rl.vlc, TEX_VLC_BITS, rl.n + 2,\
+             &amp;rl.table_vlc[0][1], 4, 2,\
+             &amp;rl.table_vlc[0][0], 4, 2, static_size);\
+\
+    rl.rl_vlc[0]= rl_vlc_table;\
+    init_2d_vlc_rl(&amp;rl);\
+}
 
 static void init_2d_vlc_rl(RLTable *rl)
 {
     int i;
-    
-    init_vlc(&amp;rl-&gt;vlc, TEX_VLC_BITS, rl-&gt;n + 2, 
-             &amp;rl-&gt;table_vlc[0][1], 4, 2,
-             &amp;rl-&gt;table_vlc[0][0], 4, 2);
 
-    
-    rl-&gt;rl_vlc[0]= av_malloc(rl-&gt;vlc.table_size*sizeof(RL_VLC_ELEM));
     for(i=0; i&lt;rl-&gt;vlc.table_size; i++){
         int code= rl-&gt;vlc.table[i][0];
         int len = rl-&gt;vlc.table[i][1];
         int level, run;
-    
+
         if(len==0){ // illegal code
             run= 65;
             level= MAX_LEVEL;
@@ -134,223 +123,14 @@
     }
 }
 
-#ifdef CONFIG_ENCODERS
-static void init_uni_ac_vlc(RLTable *rl, uint32_t *uni_ac_vlc_bits, uint8_t *uni_ac_vlc_len){
-    int i;
-
-    for(i=0; i&lt;128; i++){
-        int level= i-64;
-        int run;
-        for(run=0; run&lt;64; run++){
-            int len, bits, code;
-            
-            int alevel= ABS(level);
-            int sign= (level&gt;&gt;31)&amp;1;
-
-            if (alevel &gt; rl-&gt;max_level[0][run])
-                code= 111; /*rl-&gt;n*/
-            else
-                code= rl-&gt;index_run[0][run] + alevel - 1;
-
-            if (code &lt; 111 /* rl-&gt;n */) {
-	    	/* store the vlc &amp; sign at once */
-                len=   mpeg1_vlc[code][1]+1;
-                bits= (mpeg1_vlc[code][0]&lt;&lt;1) + sign;
-            } else {
-                len=  mpeg1_vlc[111/*rl-&gt;n*/][1]+6;
-                bits= mpeg1_vlc[111/*rl-&gt;n*/][0]&lt;&lt;6;
-
-                bits|= run;
-                if (alevel &lt; 128) {
-                    bits&lt;&lt;=8; len+=8;
-                    bits|= level &amp; 0xff;
-                } else {
-                    bits&lt;&lt;=16; len+=16;
-                    bits|= level &amp; 0xff;
-                    if (level &lt; 0) {
-                        bits|= 0x8001 + level + 255;
-                    } else {
-                        bits|= level &amp; 0xffff;
-                    }
-                }
-            }
-
-            uni_ac_vlc_bits[UNI_AC_ENC_INDEX(run, i)]= bits;
-            uni_ac_vlc_len [UNI_AC_ENC_INDEX(run, i)]= len;
-        }
-    }
-}
-
-
-static int find_frame_rate_index(MpegEncContext *s){
-    int i;
-    int64_t dmin= INT64_MAX;
-    int64_t d;
-
-    for(i=1;i&lt;14;i++) {
-        if(s-&gt;avctx-&gt;strict_std_compliance &gt;= 0 &amp;&amp; i&gt;=9) break;
-         
-        d = ABS(MPEG1_FRAME_RATE_BASE*(int64_t)s-&gt;avctx-&gt;frame_rate - frame_rate_tab[i]*(int64_t)s-&gt;avctx-&gt;frame_rate_base);
-        if(d &lt; dmin){
-            dmin=d;
-            s-&gt;frame_rate_index= i;
-        }
-    }
-    if(dmin)
-        return -1;
-    else
-        return 0;
-}
-
-static int encode_init(AVCodecContext *avctx)
+void ff_mpeg12_common_init(MpegEncContext *s)
 {
-    MpegEncContext *s = avctx-&gt;priv_data;
 
-    if(MPV_encode_init(avctx) &lt; 0)
-        return -1;
+    s-&gt;y_dc_scale_table=
+    s-&gt;c_dc_scale_table= mpeg2_dc_scale_table[s-&gt;intra_dc_precision];
 
-    if(find_frame_rate_index(s) &lt; 0){
-        if(s-&gt;strict_std_compliance &gt;=0){
-            av_log(avctx, AV_LOG_ERROR, &quot;MPEG1/2 doesnt support %d/%d fps\n&quot;, avctx-&gt;frame_rate, avctx-&gt;frame_rate_base);
-            return -1;
-        }else{
-            av_log(avctx, AV_LOG_INFO, &quot;MPEG1/2 doesnt support %d/%d fps, there may be AV sync issues\n&quot;, avctx-&gt;frame_rate, avctx-&gt;frame_rate_base);
-        }
-    }
-    
-    return 0;
 }
 
-static void put_header(MpegEncContext *s, int header)
-{
-    align_put_bits(&amp;s-&gt;pb);
-    put_bits(&amp;s-&gt;pb, 16, header&gt;&gt;16);
-    put_bits(&amp;s-&gt;pb, 16, header&amp;0xFFFF);
-}
-
-/* put sequence header if needed */
-static void mpeg1_encode_sequence_header(MpegEncContext *s)
-{
-        unsigned int vbv_buffer_size;
-        unsigned int fps, v;
-        int n, i;
-        uint64_t time_code;
-        float best_aspect_error= 1E10;
-        float aspect_ratio= av_q2d(s-&gt;avctx-&gt;sample_aspect_ratio);
-        int constraint_parameter_flag;
-        
-        if(aspect_ratio==0.0) aspect_ratio= 1.0; //pixel aspect 1:1 (VGA)
-        
-        if (s-&gt;current_picture.key_frame) {
-            /* mpeg1 header repeated every gop */
-            put_header(s, SEQ_START_CODE);
- 
-            put_bits(&amp;s-&gt;pb, 12, s-&gt;width);
-            put_bits(&amp;s-&gt;pb, 12, s-&gt;height);
-            
-            for(i=1; i&lt;15; i++){
-                float error= aspect_ratio;
-                if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO || i &lt;=1)
-                    error-= 1.0/mpeg1_aspect[i];
-                else
-                    error-= av_q2d(mpeg2_aspect[i])*s-&gt;height/s-&gt;width;
-             
-                error= ABS(error);
-                
-                if(error &lt; best_aspect_error){
-                    best_aspect_error= error;
-                    s-&gt;aspect_ratio_info= i;
-                }
-            }
-            
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;aspect_ratio_info);
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;frame_rate_index);
-            
-            if(s-&gt;avctx-&gt;rc_max_rate){
-                v = (s-&gt;avctx-&gt;rc_max_rate + 399) / 400;
-                if (v &gt; 0x3ffff &amp;&amp; s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
-                    v = 0x3ffff;
-            }else{
-                v= 0x3FFFF;
-            }
-
-            if(s-&gt;avctx-&gt;rc_buffer_size)
-                vbv_buffer_size = s-&gt;avctx-&gt;rc_buffer_size;
-            else
-                /* VBV calculation: Scaled so that a VCD has the proper VBV size of 40 kilobytes */
-                vbv_buffer_size = (( 20 * s-&gt;bit_rate) / (1151929 / 2)) * 8 * 1024;
-            vbv_buffer_size= (vbv_buffer_size + 16383) / 16384;
-
-            put_bits(&amp;s-&gt;pb, 18, v &amp; 0x3FFFF);
-            put_bits(&amp;s-&gt;pb, 1, 1); /* marker */
-            put_bits(&amp;s-&gt;pb, 10, vbv_buffer_size &amp; 0x3FF);
-
-            constraint_parameter_flag= 
-                s-&gt;width &lt;= 768 &amp;&amp; s-&gt;height &lt;= 576 &amp;&amp; 
-                s-&gt;mb_width * s-&gt;mb_height &lt;= 396 &amp;&amp;
-                s-&gt;mb_width * s-&gt;mb_height * frame_rate_tab[s-&gt;frame_rate_index] &lt;= MPEG1_FRAME_RATE_BASE*396*25 &amp;&amp;
-                frame_rate_tab[s-&gt;frame_rate_index] &lt;= MPEG1_FRAME_RATE_BASE*30 &amp;&amp;
-                vbv_buffer_size &lt;= 20 &amp;&amp;
-                v &lt;= 1856000/400 &amp;&amp;
-                s-&gt;codec_id == CODEC_ID_MPEG1VIDEO;
-                
-            put_bits(&amp;s-&gt;pb, 1, constraint_parameter_flag);
-            
-            ff_write_quant_matrix(&amp;s-&gt;pb, s-&gt;avctx-&gt;intra_matrix);
-            ff_write_quant_matrix(&amp;s-&gt;pb, s-&gt;avctx-&gt;inter_matrix);
-
-            if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO){
-                put_header(s, EXT_START_CODE);
-                put_bits(&amp;s-&gt;pb, 4, 1); //seq ext
-                put_bits(&amp;s-&gt;pb, 1, 0); //esc
-                put_bits(&amp;s-&gt;pb, 3, 4); //profile
-                put_bits(&amp;s-&gt;pb, 4, 8); //level
-                put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_sequence);
-                put_bits(&amp;s-&gt;pb, 2, 1); //chroma format 4:2:0
-                put_bits(&amp;s-&gt;pb, 2, 0); //horizontal size ext
-                put_bits(&amp;s-&gt;pb, 2, 0); //vertical size ext
-                put_bits(&amp;s-&gt;pb, 12, v&gt;&gt;18); //bitrate ext
-                put_bits(&amp;s-&gt;pb, 1, 1); //marker
-                put_bits(&amp;s-&gt;pb, 8, vbv_buffer_size &gt;&gt;10); //vbv buffer ext
-                put_bits(&amp;s-&gt;pb, 1, s-&gt;low_delay);
-                put_bits(&amp;s-&gt;pb, 2, 0); // frame_rate_ext_n
-                put_bits(&amp;s-&gt;pb, 5, 0); // frame_rate_ext_d
-            }
-            
-            put_header(s, GOP_START_CODE);
-            put_bits(&amp;s-&gt;pb, 1, 0); /* do drop frame */
-            /* time code : we must convert from the real frame rate to a
-               fake mpeg frame rate in case of low frame rate */
-            fps = (frame_rate_tab[s-&gt;frame_rate_index] + MPEG1_FRAME_RATE_BASE/2)/ MPEG1_FRAME_RATE_BASE;
-            time_code = s-&gt;current_picture_ptr-&gt;coded_picture_number;
-
-            s-&gt;gop_picture_number = time_code;
-            put_bits(&amp;s-&gt;pb, 5, (uint32_t)((time_code / (fps * 3600)) % 24));
-            put_bits(&amp;s-&gt;pb, 6, (uint32_t)((time_code / (fps * 60)) % 60));
-            put_bits(&amp;s-&gt;pb, 1, 1);
-            put_bits(&amp;s-&gt;pb, 6, (uint32_t)((time_code / fps) % 60));
-            put_bits(&amp;s-&gt;pb, 6, (uint32_t)((time_code % fps)));
-            put_bits(&amp;s-&gt;pb, 1, !!(s-&gt;flags &amp; CODEC_FLAG_CLOSED_GOP));
-            put_bits(&amp;s-&gt;pb, 1, 0); /* broken link */
-        }
-}
-
-static inline void encode_mb_skip_run(MpegEncContext *s, int run){
-    while (run &gt;= 33) {
-        put_bits(&amp;s-&gt;pb, 11, 0x008);
-        run -= 33;
-    }
-    put_bits(&amp;s-&gt;pb, mbAddrIncrTable[run][1], 
-             mbAddrIncrTable[run][0]);
-}
-#endif //CONFIG_ENCODERS
-
-static void common_init(MpegEncContext *s)
-{
-    s-&gt;y_dc_scale_table=
-    s-&gt;c_dc_scale_table= ff_mpeg1_dc_scale_table;
-}
-
 void ff_mpeg1_clean_buffers(MpegEncContext *s){
     s-&gt;last_dc[0] = 1 &lt;&lt; (7 + s-&gt;intra_dc_precision);
     s-&gt;last_dc[1] = s-&gt;last_dc[0];
@@ -358,623 +138,56 @@
     memset(s-&gt;last_mv, 0, sizeof(s-&gt;last_mv));
 }
 
-#ifdef CONFIG_ENCODERS
 
-void ff_mpeg1_encode_slice_header(MpegEncContext *s){
-    put_header(s, SLICE_MIN_START_CODE + s-&gt;mb_y);
-    put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale); /* quantizer scale */
-    put_bits(&amp;s-&gt;pb, 1, 0); /* slice extra information */
-}
-
-void mpeg1_encode_picture_header(MpegEncContext *s, int picture_number)
-{
-    mpeg1_encode_sequence_header(s);
-
-    /* mpeg1 picture header */
-    put_header(s, PICTURE_START_CODE);
-    /* temporal reference */
-
-    // RAL: s-&gt;picture_number instead of s-&gt;fake_picture_number
-    put_bits(&amp;s-&gt;pb, 10, (s-&gt;picture_number - 
-                          s-&gt;gop_picture_number) &amp; 0x3ff); 
-    put_bits(&amp;s-&gt;pb, 3, s-&gt;pict_type);
-
-    s-&gt;vbv_delay_ptr= s-&gt;pb.buf + get_bit_count(&amp;s-&gt;pb)/8;
-    put_bits(&amp;s-&gt;pb, 16, 0xFFFF); /* vbv_delay */
-    
-    // RAL: Forward f_code also needed for B frames
-    if (s-&gt;pict_type == P_TYPE || s-&gt;pict_type == B_TYPE) {
-        put_bits(&amp;s-&gt;pb, 1, 0); /* half pel coordinates */
-        if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
-            put_bits(&amp;s-&gt;pb, 3, s-&gt;f_code); /* forward_f_code */
-        else
-            put_bits(&amp;s-&gt;pb, 3, 7); /* forward_f_code */
-    }
-    
-    // RAL: Backward f_code necessary for B frames
-    if (s-&gt;pict_type == B_TYPE) {
-        put_bits(&amp;s-&gt;pb, 1, 0); /* half pel coordinates */
-        if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)
-            put_bits(&amp;s-&gt;pb, 3, s-&gt;b_code); /* backward_f_code */
-        else
-            put_bits(&amp;s-&gt;pb, 3, 7); /* backward_f_code */
-    }
-
-    put_bits(&amp;s-&gt;pb, 1, 0); /* extra bit picture */
-
-    s-&gt;frame_pred_frame_dct = 1;
-    if(s-&gt;codec_id == CODEC_ID_MPEG2VIDEO){
-        put_header(s, EXT_START_CODE);
-        put_bits(&amp;s-&gt;pb, 4, 8); //pic ext
-        if (s-&gt;pict_type == P_TYPE || s-&gt;pict_type == B_TYPE) {
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;f_code);
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;f_code);
-        }else{
-            put_bits(&amp;s-&gt;pb, 8, 255);
-        }
-        if (s-&gt;pict_type == B_TYPE) {
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;b_code);
-            put_bits(&amp;s-&gt;pb, 4, s-&gt;b_code);
-        }else{
-            put_bits(&amp;s-&gt;pb, 8, 255);
-        }
-        put_bits(&amp;s-&gt;pb, 2, s-&gt;intra_dc_precision);
-        put_bits(&amp;s-&gt;pb, 2, s-&gt;picture_structure= PICT_FRAME);
-        if (s-&gt;progressive_sequence) {
-            put_bits(&amp;s-&gt;pb, 1, 0); /* no repeat */
-        } else {
-            put_bits(&amp;s-&gt;pb, 1, s-&gt;current_picture_ptr-&gt;top_field_first);
-        }
-        /* XXX: optimize the generation of this flag with entropy
-           measures */
-        s-&gt;frame_pred_frame_dct = s-&gt;progressive_sequence;
-        
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;frame_pred_frame_dct);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;concealment_motion_vectors);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;q_scale_type);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;intra_vlc_format);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;alternate_scan);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;repeat_first_field);
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;chroma_420_type=1);
-        s-&gt;progressive_frame = s-&gt;progressive_sequence;
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;progressive_frame);
-        put_bits(&amp;s-&gt;pb, 1, 0); //composite_display_flag
-    }
-    if(s-&gt;flags &amp; CODEC_FLAG_SVCD_SCAN_OFFSET){
-        int i;
-
-        put_header(s, USER_START_CODE);
-        for(i=0; i&lt;sizeof(svcd_scan_offset_placeholder); i++){
-            put_bits(&amp;s-&gt;pb, 8, svcd_scan_offset_placeholder[i]);
-        }
-    }
-    
-    s-&gt;mb_y=0;
-    ff_mpeg1_encode_slice_header(s);
-}
-
-static inline void put_mb_modes(MpegEncContext *s, int n, int bits, 
-                                int has_mv, int field_motion)
-{
-    put_bits(&amp;s-&gt;pb, n, bits);
-    if (!s-&gt;frame_pred_frame_dct) {
-        if (has_mv) 
-            put_bits(&amp;s-&gt;pb, 2, 2 - field_motion); /* motion_type: frame/field */
-        put_bits(&amp;s-&gt;pb, 1, s-&gt;interlaced_dct);
-    }
-}
-
-void mpeg1_encode_mb(MpegEncContext *s,
-                     DCTELEM block[6][64],
-                     int motion_x, int motion_y)
-{
-    int i, cbp;
-    const int mb_x = s-&gt;mb_x;
-    const int mb_y = s-&gt;mb_y;
-    const int first_mb= mb_x == s-&gt;resync_mb_x &amp;&amp; mb_y == s-&gt;resync_mb_y;
-
-    /* compute cbp */
-    cbp = 0;
-    for(i=0;i&lt;6;i++) {
-        if (s-&gt;block_last_index[i] &gt;= 0)
-            cbp |= 1 &lt;&lt; (5 - i);
-    }
-    
-    if (cbp == 0 &amp;&amp; !first_mb &amp;&amp; (mb_x != s-&gt;mb_width - 1 || (mb_y != s-&gt;mb_height - 1 &amp;&amp; s-&gt;codec_id == CODEC_ID_MPEG1VIDEO)) &amp;&amp; 
-        ((s-&gt;pict_type == P_TYPE &amp;&amp; s-&gt;mv_type == MV_TYPE_16X16 &amp;&amp; (motion_x | motion_y) == 0) ||
-        (s-&gt;pict_type == B_TYPE &amp;&amp; s-&gt;mv_dir == s-&gt;last_mv_dir &amp;&amp; (((s-&gt;mv_dir &amp; MV_DIR_FORWARD) ? ((s-&gt;mv[0][0][0] - s-&gt;last_mv[0][0][0])|(s-&gt;mv[0][0][1] - s-&gt;last_mv[0][0][1])) : 0) |
-        ((s-&gt;mv_dir &amp; MV_DIR_BACKWARD) ? ((s-&gt;mv[1][0][0] - s-&gt;last_mv[1][0][0])|(s-&gt;mv[1][0][1] - s-&gt;last_mv[1][0][1])) : 0)) == 0))) {
-        s-&gt;mb_skip_run++;
-        s-&gt;qscale -= s-&gt;dquant;
-        s-&gt;skip_count++;
-        s-&gt;misc_bits++;
-        s-&gt;last_bits++;
-        if(s-&gt;pict_type == P_TYPE){
-            s-&gt;last_mv[0][1][0]= s-&gt;last_mv[0][0][0]= 
-            s-&gt;last_mv[0][1][1]= s-&gt;last_mv[0][0][1]= 0;
-        }
-    } else {
-        if(first_mb){
-            assert(s-&gt;mb_skip_run == 0);
-            encode_mb_skip_run(s, s-&gt;mb_x);
-        }else{
-            encode_mb_skip_run(s, s-&gt;mb_skip_run);
-        }
-        
-        if (s-&gt;pict_type == I_TYPE) {
-            if(s-&gt;dquant &amp;&amp; cbp){
-                put_mb_modes(s, 2, 1, 0, 0); /* macroblock_type : macroblock_quant = 1 */
-                put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-            }else{
-                put_mb_modes(s, 1, 1, 0, 0); /* macroblock_type : macroblock_quant = 0 */
-                s-&gt;qscale -= s-&gt;dquant;
-            }
-            s-&gt;misc_bits+= get_bits_diff(s);
-            s-&gt;i_count++;
-        } else if (s-&gt;mb_intra) {
-            if(s-&gt;dquant &amp;&amp; cbp){
-                put_mb_modes(s, 6, 0x01, 0, 0);
-                put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-            }else{
-                put_mb_modes(s, 5, 0x03, 0, 0);
-                s-&gt;qscale -= s-&gt;dquant;
-            }
-            s-&gt;misc_bits+= get_bits_diff(s);
-            s-&gt;i_count++;
-            memset(s-&gt;last_mv, 0, sizeof(s-&gt;last_mv));
-        } else if (s-&gt;pict_type == P_TYPE) { 
-            if(s-&gt;mv_type == MV_TYPE_16X16){
-                if (cbp != 0) {
-                    if ((motion_x|motion_y) == 0) {
-                        if(s-&gt;dquant){
-                            put_mb_modes(s, 5, 1, 0, 0); /* macroblock_pattern &amp; quant */
-                            put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-                        }else{
-                            put_mb_modes(s, 2, 1, 0, 0); /* macroblock_pattern only */
-                        }
-                        s-&gt;misc_bits+= get_bits_diff(s);
-                    } else {
-                        if(s-&gt;dquant){
-                            put_mb_modes(s, 5, 2, 1, 0); /* motion + cbp */
-                            put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-                        }else{
-                            put_mb_modes(s, 1, 1, 1, 0); /* motion + cbp */
-                        }
-                        s-&gt;misc_bits+= get_bits_diff(s);
-                        mpeg1_encode_motion(s, motion_x - s-&gt;last_mv[0][0][0], s-&gt;f_code);    // RAL: f_code parameter added
-                        mpeg1_encode_motion(s, motion_y - s-&gt;last_mv[0][0][1], s-&gt;f_code);    // RAL: f_code parameter added
-                        s-&gt;mv_bits+= get_bits_diff(s);
-                    }
-                } else {
-                    put_bits(&amp;s-&gt;pb, 3, 1); /* motion only */
-                    if (!s-&gt;frame_pred_frame_dct)
-                        put_bits(&amp;s-&gt;pb, 2, 2); /* motion_type: frame */
-                    s-&gt;misc_bits+= get_bits_diff(s);
-                    mpeg1_encode_motion(s, motion_x - s-&gt;last_mv[0][0][0], s-&gt;f_code);    // RAL: f_code parameter added
-                    mpeg1_encode_motion(s, motion_y - s-&gt;last_mv[0][0][1], s-&gt;f_code);    // RAL: f_code parameter added
-                    s-&gt;qscale -= s-&gt;dquant;
-                    s-&gt;mv_bits+= get_bits_diff(s);
-                }
-                s-&gt;last_mv[0][1][0]= s-&gt;last_mv[0][0][0]= motion_x;
-                s-&gt;last_mv[0][1][1]= s-&gt;last_mv[0][0][1]= motion_y;
-            }else{
-                assert(!s-&gt;frame_pred_frame_dct &amp;&amp; s-&gt;mv_type == MV_TYPE_FIELD);
-
-                if (cbp) {
-                    if(s-&gt;dquant){
-                        put_mb_modes(s, 5, 2, 1, 1); /* motion + cbp */
-                        put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-                    }else{
-                        put_mb_modes(s, 1, 1, 1, 1); /* motion + cbp */
-                    }
-                } else {
-                    put_bits(&amp;s-&gt;pb, 3, 1); /* motion only */
-                    put_bits(&amp;s-&gt;pb, 2, 1); /* motion_type: field */
-                    s-&gt;qscale -= s-&gt;dquant;
-                }
-                s-&gt;misc_bits+= get_bits_diff(s);
-                for(i=0; i&lt;2; i++){
-                    put_bits(&amp;s-&gt;pb, 1, s-&gt;field_select[0][i]);
-                    mpeg1_encode_motion(s, s-&gt;mv[0][i][0] -  s-&gt;last_mv[0][i][0]    , s-&gt;f_code);
-                    mpeg1_encode_motion(s, s-&gt;mv[0][i][1] - (s-&gt;last_mv[0][i][1]&gt;&gt;1), s-&gt;f_code);
-                    s-&gt;last_mv[0][i][0]=   s-&gt;mv[0][i][0];
-                    s-&gt;last_mv[0][i][1]= 2*s-&gt;mv[0][i][1];
-                }
-                s-&gt;mv_bits+= get_bits_diff(s);
-            }
-            if(cbp)
-                put_bits(&amp;s-&gt;pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);
-            s-&gt;f_count++;
-        } else{  
-            static const int mb_type_len[4]={0,3,4,2}; //bak,for,bi
-
-            if(s-&gt;mv_type == MV_TYPE_16X16){
-                if (cbp){    // With coded bloc pattern
-                    if (s-&gt;dquant) {
-                        if(s-&gt;mv_dir == MV_DIR_FORWARD)
-                            put_mb_modes(s, 6, 3, 1, 0);
-                        else
-                            put_mb_modes(s, mb_type_len[s-&gt;mv_dir]+3, 2, 1, 0);
-                        put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-                    } else {
-                        put_mb_modes(s, mb_type_len[s-&gt;mv_dir], 3, 1, 0);
-                    }
-                }else{    // No coded bloc pattern
-                    put_bits(&amp;s-&gt;pb, mb_type_len[s-&gt;mv_dir], 2);
-                    if (!s-&gt;frame_pred_frame_dct)
-                        put_bits(&amp;s-&gt;pb, 2, 2); /* motion_type: frame */
-                    s-&gt;qscale -= s-&gt;dquant;
-                }
-                s-&gt;misc_bits += get_bits_diff(s);
-                if (s-&gt;mv_dir&amp;MV_DIR_FORWARD){
-                    mpeg1_encode_motion(s, s-&gt;mv[0][0][0] - s-&gt;last_mv[0][0][0], s-&gt;f_code); 
-                    mpeg1_encode_motion(s, s-&gt;mv[0][0][1] - s-&gt;last_mv[0][0][1], s-&gt;f_code); 
-                    s-&gt;last_mv[0][0][0]=s-&gt;last_mv[0][1][0]= s-&gt;mv[0][0][0];
-                    s-&gt;last_mv[0][0][1]=s-&gt;last_mv[0][1][1]= s-&gt;mv[0][0][1];
-                    s-&gt;f_count++;
-                }
-                if (s-&gt;mv_dir&amp;MV_DIR_BACKWARD){
-                    mpeg1_encode_motion(s, s-&gt;mv[1][0][0] - s-&gt;last_mv[1][0][0], s-&gt;b_code); 
-                    mpeg1_encode_motion(s, s-&gt;mv[1][0][1] - s-&gt;last_mv[1][0][1], s-&gt;b_code); 
-                    s-&gt;last_mv[1][0][0]=s-&gt;last_mv[1][1][0]= s-&gt;mv[1][0][0];
-                    s-&gt;last_mv[1][0][1]=s-&gt;last_mv[1][1][1]= s-&gt;mv[1][0][1];
-                    s-&gt;b_count++;
-                }
-            }else{
-                assert(s-&gt;mv_type == MV_TYPE_FIELD);
-                assert(!s-&gt;frame_pred_frame_dct);
-                if (cbp){    // With coded bloc pattern
-                    if (s-&gt;dquant) {
-                        if(s-&gt;mv_dir == MV_DIR_FORWARD)
-                            put_mb_modes(s, 6, 3, 1, 1);
-                        else
-                            put_mb_modes(s, mb_type_len[s-&gt;mv_dir]+3, 2, 1, 1);
-                        put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
-                    } else {
-                        put_mb_modes(s, mb_type_len[s-&gt;mv_dir], 3, 1, 1);
-                    }
-                }else{    // No coded bloc pattern
-                    put_bits(&amp;s-&gt;pb, mb_type_len[s-&gt;mv_dir], 2);
-                    put_bits(&amp;s-&gt;pb, 2, 1); /* motion_type: field */
-                    s-&gt;qscale -= s-&gt;dquant;
-                }
-                s-&gt;misc_bits += get_bits_diff(s);
-                if (s-&gt;mv_dir&amp;MV_DIR_FORWARD){
-                    for(i=0; i&lt;2; i++){
-                        put_bits(&amp;s-&gt;pb, 1, s-&gt;field_select[0][i]);
-                        mpeg1_encode_motion(s, s-&gt;mv[0][i][0] -  s-&gt;last_mv[0][i][0]    , s-&gt;f_code);
-                        mpeg1_encode_motion(s, s-&gt;mv[0][i][1] - (s-&gt;last_mv[0][i][1]&gt;&gt;1), s-&gt;f_code);
-                        s-&gt;last_mv[0][i][0]=   s-&gt;mv[0][i][0];
-                        s-&gt;last_mv[0][i][1]= 2*s-&gt;mv[0][i][1];
-                    }
-                    s-&gt;f_count++;
-                }
-                if (s-&gt;mv_dir&amp;MV_DIR_BACKWARD){
-                    for(i=0; i&lt;2; i++){
-                        put_bits(&amp;s-&gt;pb, 1, s-&gt;field_select[1][i]);
-                        mpeg1_encode_motion(s, s-&gt;mv[1][i][0] -  s-&gt;last_mv[1][i][0]    , s-&gt;b_code);
-                        mpeg1_encode_motion(s, s-&gt;mv[1][i][1] - (s-&gt;last_mv[1][i][1]&gt;&gt;1), s-&gt;b_code);
-                        s-&gt;last_mv[1][i][0]=   s-&gt;mv[1][i][0];
-                        s-&gt;last_mv[1][i][1]= 2*s-&gt;mv[1][i][1];
-                    }
-                    s-&gt;b_count++;
-                }
-            }
-            s-&gt;mv_bits += get_bits_diff(s);
-            if(cbp)
-                put_bits(&amp;s-&gt;pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]);
-        }
-        for(i=0;i&lt;6;i++) {
-            if (cbp &amp; (1 &lt;&lt; (5 - i))) {
-                mpeg1_encode_block(s, block[i], i);
-            }
-        }
-        s-&gt;mb_skip_run = 0;
-        if(s-&gt;mb_intra)
-            s-&gt;i_tex_bits+= get_bits_diff(s);
-        else
-            s-&gt;p_tex_bits+= get_bits_diff(s);
-    }
-}
-
-// RAL: Parameter added: f_or_b_code
-static void mpeg1_encode_motion(MpegEncContext *s, int val, int f_or_b_code)
-{
-    int code, bit_size, l, m, bits, range, sign;
-
-    if (val == 0) {
-        /* zero vector */
-        code = 0;
-        put_bits(&amp;s-&gt;pb,
-                 mbMotionVectorTable[0][1], 
-                 mbMotionVectorTable[0][0]); 
-    } else {
-        bit_size = f_or_b_code - 1;
-        range = 1 &lt;&lt; bit_size;
-        /* modulo encoding */
-        l = 16 * range;
-        m = 2 * l;
-        if (val &lt; -l) {
-            val += m;
-        } else if (val &gt;= l) {
-            val -= m;
-        }
-
-        if (val &gt;= 0) {
-            val--;
-            code = (val &gt;&gt; bit_size) + 1;
-            bits = val &amp; (range - 1);
-            sign = 0;
-        } else {
-            val = -val;
-            val--;
-            code = (val &gt;&gt; bit_size) + 1;
-            bits = val &amp; (range - 1);
-            sign = 1;
-        }
-
-        assert(code &gt; 0 &amp;&amp; code &lt;= 16);
-
-        put_bits(&amp;s-&gt;pb,
-                 mbMotionVectorTable[code][1], 
-                 mbMotionVectorTable[code][0]); 
-
-        put_bits(&amp;s-&gt;pb, 1, sign);
-        if (bit_size &gt; 0) {
-            put_bits(&amp;s-&gt;pb, bit_size, bits);
-        }
-    }
-}
-
-void ff_mpeg1_encode_init(MpegEncContext *s)
-{
-    static int done=0;
-
-    common_init(s);
-
-    if(!done){
-        int f_code;
-        int mv;
-	int i;
-
-        done=1;
-        init_rl(&amp;rl_mpeg1);
-
-	for(i=0; i&lt;64; i++)
-	{
-		mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];
-		mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];
-	}
-        
-        init_uni_ac_vlc(&amp;rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);
-
-	/* build unified dc encoding tables */
-	for(i=-255; i&lt;256; i++)
-	{
-		int adiff, index;
-		int bits, code;
-		int diff=i;
-
-		adiff = ABS(diff);
-		if(diff&lt;0) diff--;
-		index = vlc_dc_table[adiff];
-
-		bits= vlc_dc_lum_bits[index] + index;
-		code= (vlc_dc_lum_code[index]&lt;&lt;index) + (diff &amp; ((1 &lt;&lt; index) - 1));
-		mpeg1_lum_dc_uni[i+255]= bits + (code&lt;&lt;8);
-		
-		bits= vlc_dc_chroma_bits[index] + index;
-		code= (vlc_dc_chroma_code[index]&lt;&lt;index) + (diff &amp; ((1 &lt;&lt; index) - 1));
-		mpeg1_chr_dc_uni[i+255]= bits + (code&lt;&lt;8);
-	}
-
-        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );
-
-        for(f_code=1; f_code&lt;=MAX_FCODE; f_code++){
-            for(mv=-MAX_MV; mv&lt;=MAX_MV; mv++){
-                int len;
-
-                if(mv==0) len= mbMotionVectorTable[0][1];
-                else{
-                    int val, bit_size, range, code;
-
-                    bit_size = s-&gt;f_code - 1;
-                    range = 1 &lt;&lt; bit_size;
-
-                    val=mv;
-                    if (val &lt; 0) 
-                        val = -val;
-                    val--;
-                    code = (val &gt;&gt; bit_size) + 1;
-                    if(code&lt;17){
-                        len= mbMotionVectorTable[code][1] + 1 + bit_size;
-                    }else{
-                        len= mbMotionVectorTable[16][1] + 2 + bit_size;
-                    }
-                }
-
-                mv_penalty[f_code][mv+MAX_MV]= len;
-            }
-        }
-        
-
-        for(f_code=MAX_FCODE; f_code&gt;0; f_code--){
-            for(mv=-(8&lt;&lt;f_code); mv&lt;(8&lt;&lt;f_code); mv++){
-                fcode_tab[mv+MAX_MV]= f_code;
-            }
-        }
-    }
-    s-&gt;me.mv_penalty= mv_penalty;
-    s-&gt;fcode_tab= fcode_tab;
-    if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO){
-        s-&gt;min_qcoeff=-255;
-        s-&gt;max_qcoeff= 255;
-    }else{
-        s-&gt;min_qcoeff=-2047;
-        s-&gt;max_qcoeff= 2047;
-    }
-    s-&gt;intra_ac_vlc_length=
-    s-&gt;inter_ac_vlc_length=
-    s-&gt;intra_ac_vlc_last_length=
-    s-&gt;inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;
-}
-
-static inline void encode_dc(MpegEncContext *s, int diff, int component)
-{
-    if (component == 0) {
-        put_bits(
-	    &amp;s-&gt;pb, 
-	    mpeg1_lum_dc_uni[diff+255]&amp;0xFF,
-	    mpeg1_lum_dc_uni[diff+255]&gt;&gt;8);
-    } else {
-        put_bits(
-            &amp;s-&gt;pb, 
-	    mpeg1_chr_dc_uni[diff+255]&amp;0xFF,
-	    mpeg1_chr_dc_uni[diff+255]&gt;&gt;8);
-    }
-}
-
-static void mpeg1_encode_block(MpegEncContext *s, 
-                               DCTELEM *block, 
-                               int n)
-{
-    int alevel, level, last_non_zero, dc, diff, i, j, run, last_index, sign;
-    int code, component;
-//    RLTable *rl = &amp;rl_mpeg1;
-
-    last_index = s-&gt;block_last_index[n];
-
-    /* DC coef */
-    if (s-&gt;mb_intra) {
-        component = (n &lt;= 3 ? 0 : n - 4 + 1);
-        dc = block[0]; /* overflow is impossible */
-        diff = dc - s-&gt;last_dc[component];
-        encode_dc(s, diff, component);
-        s-&gt;last_dc[component] = dc;
-        i = 1;
-/*
-        if (s-&gt;intra_vlc_format)
-            rl = &amp;rl_mpeg2;
-        else
-            rl = &amp;rl_mpeg1;
-*/
-    } else {
-        /* encode the first coefficient : needs to be done here because
-           it is handled slightly differently */
-        level = block[0];
-        if (abs(level) == 1) {
-                code = ((uint32_t)level &gt;&gt; 31); /* the sign bit */
-                put_bits(&amp;s-&gt;pb, 2, code | 0x02);
-                i = 1;
-        } else {
-            i = 0;
-            last_non_zero = -1;
-            goto next_coef;
-        }
-    }
-
-    /* now quantify &amp; encode AC coefs */
-    last_non_zero = i - 1;
-
-    for(;i&lt;=last_index;i++) {
-        j = s-&gt;intra_scantable.permutated[i];
-        level = block[j];
-    next_coef:
-#if 0
-        if (level != 0)
-            dprintf(&quot;level[%d]=%d\n&quot;, i, level);
-#endif            
-        /* encode using VLC */
-        if (level != 0) {
-            run = i - last_non_zero - 1;
-            
-            alevel= level;
-            MASK_ABS(sign, alevel)
-            sign&amp;=1;
-
-//            code = get_rl_index(rl, 0, run, alevel);
-            if (alevel &lt;= mpeg1_max_level[0][run]){
-                code= mpeg1_index_run[0][run] + alevel - 1;
-	    	/* store the vlc &amp; sign at once */
-                put_bits(&amp;s-&gt;pb, mpeg1_vlc[code][1]+1, (mpeg1_vlc[code][0]&lt;&lt;1) + sign);
-            } else {
-		/* escape seems to be pretty rare &lt;5% so i dont optimize it */
-                put_bits(&amp;s-&gt;pb, mpeg1_vlc[111/*rl-&gt;n*/][1], mpeg1_vlc[111/*rl-&gt;n*/][0]);
-                /* escape: only clip in this case */
-                put_bits(&amp;s-&gt;pb, 6, run);
-                if(s-&gt;codec_id == CODEC_ID_MPEG1VIDEO){
-                    if (alevel &lt; 128) {
-                        put_bits(&amp;s-&gt;pb, 8, level &amp; 0xff);
-                    } else {
-                        if (level &lt; 0) {
-                            put_bits(&amp;s-&gt;pb, 16, 0x8001 + level + 255);
-                        } else {
-                            put_bits(&amp;s-&gt;pb, 16, level &amp; 0xffff);
-                        }
-                    }
-                }else{
-                    put_bits(&amp;s-&gt;pb, 12, level &amp; 0xfff);
-                }
-            }
-            last_non_zero = i;
-        }
-    }
-    /* end of block */
-    put_bits(&amp;s-&gt;pb, 2, 0x2);
-}
-#endif //CONFIG_ENCODERS
-
 /******************************************/
 /* decoding */
 
-static VLC dc_lum_vlc;
-static VLC dc_chroma_vlc;
 static VLC mv_vlc;
 static VLC mbincr_vlc;
 static VLC mb_ptype_vlc;
 static VLC mb_btype_vlc;
 static VLC mb_pat_vlc;
 
-static void init_vlcs()
+av_cold void ff_mpeg12_init_vlcs(void)
 {
     static int done = 0;
 
     if (!done) {
         done = 1;
 
-        init_vlc(&amp;dc_lum_vlc, DC_VLC_BITS, 12, 
-                 vlc_dc_lum_bits, 1, 1,
-                 vlc_dc_lum_code, 2, 2);
-        init_vlc(&amp;dc_chroma_vlc,  DC_VLC_BITS, 12, 
-                 vlc_dc_chroma_bits, 1, 1,
-                 vlc_dc_chroma_code, 2, 2);
-        init_vlc(&amp;mv_vlc, MV_VLC_BITS, 17, 
-                 &amp;mbMotionVectorTable[0][1], 2, 1,
-                 &amp;mbMotionVectorTable[0][0], 2, 1);
-        init_vlc(&amp;mbincr_vlc, MBINCR_VLC_BITS, 36, 
-                 &amp;mbAddrIncrTable[0][1], 2, 1,
-                 &amp;mbAddrIncrTable[0][0], 2, 1);
-        init_vlc(&amp;mb_pat_vlc, MB_PAT_VLC_BITS, 63, 
-                 &amp;mbPatTable[0][1], 2, 1,
-                 &amp;mbPatTable[0][0], 2, 1);
-        
-        init_vlc(&amp;mb_ptype_vlc, MB_PTYPE_VLC_BITS, 7, 
+        INIT_VLC_STATIC(&amp;dc_lum_vlc, DC_VLC_BITS, 12,
+                 ff_mpeg12_vlc_dc_lum_bits, 1, 1,

[... truncated: 23969 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011865.html">[Haiku-commits] r27555 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011867.html">[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11866">[ date ]</a>
              <a href="thread.html#11866">[ thread ]</a>
              <a href="subject.html#11866">[ subject ]</a>
              <a href="author.html#11866">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
