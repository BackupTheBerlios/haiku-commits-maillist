<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27552 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27552%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151407.m8FE77qS000556%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011861.html">
   <LINK REL="Next"  HREF="011863.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27552 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27552%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151407.m8FE77qS000556%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27552 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:07:07 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011861.html">[Haiku-commits] r27551 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011863.html">[Haiku-commits] r27553 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11862">[ date ]</a>
              <a href="thread.html#11862">[ thread ]</a>
              <a href="subject.html#11862">[ subject ]</a>
              <a href="author.html#11862">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:07:05 +0200 (Mon, 15 Sep 2008)
New Revision: 27552
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27552&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27552&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/w32thread.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wavpack.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wma.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wma.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmaenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmv2.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmv2dec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmv2enc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wnv1.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ws-snd1.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmadata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmadec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wmv2.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/w32thread.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/w32thread.c	2008-09-15 14:05:40 UTC (rev 27551)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/w32thread.c	2008-09-15 14:07:05 UTC (rev 27552)
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+//#define DEBUG
+
+#include &quot;avcodec.h&quot;
+
+#define WIN32_LEAN_AND_MEAN
+#include &lt;windows.h&gt;
+#include &lt;process.h&gt;
+
+typedef struct ThreadContext{
+    AVCodecContext *avctx;
+    HANDLE thread;
+    HANDLE work_sem;
+    HANDLE done_sem;
+    int (*func)(AVCodecContext *c, void *arg);
+    void *arg;
+    int ret;
+}ThreadContext;
+
+
+static unsigned WINAPI attribute_align_arg thread_func(void *v){
+    ThreadContext *c= v;
+
+    for(;;){
+//printf(&quot;thread_func %X enter wait\n&quot;, (int)v); fflush(stdout);
+        WaitForSingleObject(c-&gt;work_sem, INFINITE);
+//printf(&quot;thread_func %X after wait (func=%X)\n&quot;, (int)v, (int)c-&gt;func); fflush(stdout);
+        if(c-&gt;func)
+            c-&gt;ret= c-&gt;func(c-&gt;avctx, c-&gt;arg);
+        else
+            return 0;
+//printf(&quot;thread_func %X signal complete\n&quot;, (int)v); fflush(stdout);
+        ReleaseSemaphore(c-&gt;done_sem, 1, 0);
+    }
+
+    return 0;
+}
+
+/**
+ * Free what has been allocated by avcodec_thread_init().
+ * Must be called after decoding has finished, especially do not call while avcodec_thread_execute() is running.
+ */
+void avcodec_thread_free(AVCodecContext *s){
+    ThreadContext *c= s-&gt;thread_opaque;
+    int i;
+
+    for(i=0; i&lt;s-&gt;thread_count; i++){
+
+        c[i].func= NULL;
+        ReleaseSemaphore(c[i].work_sem, 1, 0);
+        WaitForSingleObject(c[i].thread, INFINITE);
+        if(c[i].work_sem) CloseHandle(c[i].work_sem);
+        if(c[i].done_sem) CloseHandle(c[i].done_sem);
+    }
+
+    av_freep(&amp;s-&gt;thread_opaque);
+}
+
+int avcodec_thread_execute(AVCodecContext *s, int (*func)(AVCodecContext *c2, void *arg2),void **arg, int *ret, int count){
+    ThreadContext *c= s-&gt;thread_opaque;
+    int i;
+
+    assert(s == c-&gt;avctx);
+    assert(count &lt;= s-&gt;thread_count);
+
+    /* note, we can be certain that this is not called with the same AVCodecContext by different threads at the same time */
+
+    for(i=0; i&lt;count; i++){
+        c[i].arg= arg[i];
+        c[i].func= func;
+        c[i].ret= 12345;
+
+        ReleaseSemaphore(c[i].work_sem, 1, 0);
+    }
+    for(i=0; i&lt;count; i++){
+        WaitForSingleObject(c[i].done_sem, INFINITE);
+
+        c[i].func= NULL;
+        if(ret) ret[i]= c[i].ret;
+    }
+    return 0;
+}
+
+int avcodec_thread_init(AVCodecContext *s, int thread_count){
+    int i;
+    ThreadContext *c;
+    uint32_t threadid;
+
+    s-&gt;thread_count= thread_count;
+
+    assert(!s-&gt;thread_opaque);
+    c= av_mallocz(sizeof(ThreadContext)*thread_count);
+    s-&gt;thread_opaque= c;
+
+    for(i=0; i&lt;thread_count; i++){
+//printf(&quot;init semaphors %d\n&quot;, i); fflush(stdout);
+        c[i].avctx= s;
+
+        if(!(c[i].work_sem = CreateSemaphore(NULL, 0, s-&gt;thread_count, NULL)))
+            goto fail;
+        if(!(c[i].done_sem = CreateSemaphore(NULL, 0, s-&gt;thread_count, NULL)))
+            goto fail;
+
+//printf(&quot;create thread %d\n&quot;, i); fflush(stdout);
+        c[i].thread = (HANDLE)_beginthreadex(NULL, 0, thread_func, &amp;c[i], 0, &amp;threadid );
+        if( !c[i].thread ) goto fail;
+    }
+//printf(&quot;init done\n&quot;); fflush(stdout);
+
+    s-&gt;execute= avcodec_thread_execute;
+
+    return 0;
+fail:
+    avcodec_thread_free(s);
+    return -1;
+}

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wavpack.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wavpack.c	2008-09-15 14:05:40 UTC (rev 27551)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wavpack.c	2008-09-15 14:07:05 UTC (rev 27552)
@@ -0,0 +1,587 @@
+/*
+ * WavPack lossless audio decoder
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#define ALT_BITSTREAM_READER_LE
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;unary.h&quot;
+
+/**
+ * @file wavpack.c
+ * WavPack lossless audio decoder
+ */
+
+#define WV_JOINT_STEREO 0x00000010
+#define WV_FALSE_STEREO 0x40000000
+
+enum WP_ID_Flags{
+    WP_IDF_MASK   = 0x1F,
+    WP_IDF_IGNORE = 0x20,
+    WP_IDF_ODD    = 0x40,
+    WP_IDF_LONG   = 0x80
+};
+
+enum WP_ID{
+    WP_ID_DUMMY = 0,
+    WP_ID_ENCINFO,
+    WP_ID_DECTERMS,
+    WP_ID_DECWEIGHTS,
+    WP_ID_DECSAMPLES,
+    WP_ID_ENTROPY,
+    WP_ID_HYBRID,
+    WP_ID_SHAPING,
+    WP_ID_FLOATINFO,
+    WP_ID_INT32INFO,
+    WP_ID_DATA,
+    WP_ID_CORR,
+    WP_ID_FLT,
+    WP_ID_CHANINFO
+};
+
+#define MAX_TERMS 16
+
+typedef struct Decorr {
+    int delta;
+    int value;
+    int weightA;
+    int weightB;
+    int samplesA[8];
+    int samplesB[8];
+} Decorr;
+
+typedef struct WavpackContext {
+    AVCodecContext *avctx;
+    int stereo, stereo_in;
+    int joint;
+    uint32_t CRC;
+    GetBitContext gb;
+    int data_size; // in bits
+    int samples;
+    int median[6];
+    int terms;
+    Decorr decorr[MAX_TERMS];
+    int zero, one, zeroes;
+    int and, or, shift;
+} WavpackContext;
+
+// exponent table copied from WavPack source
+static const uint8_t wp_exp2_table [256] = {
+    0x00, 0x01, 0x01, 0x02, 0x03, 0x03, 0x04, 0x05, 0x06, 0x06, 0x07, 0x08, 0x08, 0x09, 0x0a, 0x0b,
+    0x0b, 0x0c, 0x0d, 0x0e, 0x0e, 0x0f, 0x10, 0x10, 0x11, 0x12, 0x13, 0x13, 0x14, 0x15, 0x16, 0x16,
+    0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1d, 0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23,
+    0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
+    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3a, 0x3b, 0x3c, 0x3d,
+    0x3e, 0x3f, 0x40, 0x41, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x48, 0x49, 0x4a, 0x4b,
+    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a,
+    0x5b, 0x5c, 0x5d, 0x5e, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
+    0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
+    0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x87, 0x88, 0x89, 0x8a,
+    0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,
+    0x9c, 0x9d, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad,
+    0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
+    0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc8, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf, 0xd0, 0xd2, 0xd3, 0xd4,
+    0xd6, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2, 0xe4, 0xe5, 0xe6, 0xe8, 0xe9,
+    0xea, 0xec, 0xed, 0xee, 0xf0, 0xf1, 0xf2, 0xf4, 0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff
+};
+
+static av_always_inline int wp_exp2(int16_t val)
+{
+    int res, neg = 0;
+
+    if(val &lt; 0){
+        val = -val;
+        neg = 1;
+    }
+
+    res = wp_exp2_table[val &amp; 0xFF] | 0x100;
+    val &gt;&gt;= 8;
+    res = (val &gt; 9) ? (res &lt;&lt; (val - 9)) : (res &gt;&gt; (9 - val));
+    return neg ? -res : res;
+}
+
+// macros for manipulating median values
+#define GET_MED(n) ((median[n] &gt;&gt; 4) + 1)
+#define DEC_MED(n) median[n] -= ((median[n] + (128&gt;&gt;n) - 2) / (128&gt;&gt;n)) * 2
+#define INC_MED(n) median[n] += ((median[n] + (128&gt;&gt;n)) / (128&gt;&gt;n)) * 5
+
+// macros for applying weight
+#define UPDATE_WEIGHT_CLIP(weight, delta, samples, in) \
+        if(samples &amp;&amp; in){ \
+            if((samples ^ in) &lt; 0){ \
+                weight -= delta; \
+                if(weight &lt; -1024) weight = -1024; \
+            }else{ \
+                weight += delta; \
+                if(weight &gt; 1024) weight = 1024; \
+            } \
+        }
+
+
+static av_always_inline int get_tail(GetBitContext *gb, int k)
+{
+    int p, e, res;
+
+    if(k&lt;1)return 0;
+    p = av_log2(k);
+    e = (1 &lt;&lt; (p + 1)) - k - 1;
+    res = p ? get_bits(gb, p) : 0;
+    if(res &gt;= e){
+        res = (res&lt;&lt;1) - e + get_bits1(gb);
+    }
+    return res;
+}
+
+static int wv_get_value(WavpackContext *ctx, GetBitContext *gb, int *median, int *last)
+{
+    int t, t2;
+    int sign, base, add, ret;
+
+    *last = 0;
+
+    if((ctx-&gt;median[0] &lt; 2U) &amp;&amp; (ctx-&gt;median[3] &lt; 2U) &amp;&amp; !ctx-&gt;zero &amp;&amp; !ctx-&gt;one){
+        if(ctx-&gt;zeroes){
+            ctx-&gt;zeroes--;
+            if(ctx-&gt;zeroes)
+                return 0;
+        }else{
+            t = get_unary_0_33(gb);
+            if(t &gt;= 2) t = get_bits(gb, t - 1) | (1 &lt;&lt; (t-1));
+            ctx-&gt;zeroes = t;
+            if(ctx-&gt;zeroes){
+                memset(ctx-&gt;median, 0, sizeof(ctx-&gt;median));
+                return 0;
+            }
+        }
+    }
+
+    if(get_bits_count(gb) &gt;= ctx-&gt;data_size){
+        *last = 1;
+        return 0;
+    }
+
+    if(ctx-&gt;zero){
+        t = 0;
+        ctx-&gt;zero = 0;
+    }else{
+        t = get_unary_0_33(gb);
+        if(get_bits_count(gb) &gt;= ctx-&gt;data_size){
+            *last = 1;
+            return 0;
+        }
+        if(t == 16) {
+            t2 = get_unary_0_33(gb);
+            if(t2 &lt; 2) t += t2;
+            else t += get_bits(gb, t2 - 1) | (1 &lt;&lt; (t2 - 1));
+        }
+
+        if(ctx-&gt;one){
+            ctx-&gt;one = t&amp;1;
+            t = (t&gt;&gt;1) + 1;
+        }else{
+            ctx-&gt;one = t&amp;1;
+            t &gt;&gt;= 1;
+        }
+        ctx-&gt;zero = !ctx-&gt;one;
+    }
+
+    if(!t){
+        base = 0;
+        add = GET_MED(0) - 1;
+        DEC_MED(0);
+    }else if(t == 1){
+        base = GET_MED(0);
+        add = GET_MED(1) - 1;
+        INC_MED(0);
+        DEC_MED(1);
+    }else if(t == 2){
+        base = GET_MED(0) + GET_MED(1);
+        add = GET_MED(2) - 1;
+        INC_MED(0);
+        INC_MED(1);
+        DEC_MED(2);
+    }else{
+        base = GET_MED(0) + GET_MED(1) + GET_MED(2) * (t - 2);
+        add = GET_MED(2) - 1;
+        INC_MED(0);
+        INC_MED(1);
+        INC_MED(2);
+    }
+    ret = base + get_tail(gb, add);
+    sign = get_bits1(gb);
+    return sign ? ~ret : ret;
+}
+
+static int wv_unpack_stereo(WavpackContext *s, GetBitContext *gb, int16_t *dst)
+{
+    int i, j, count = 0;
+    int last, t;
+    int A, B, L, L2, R, R2, bit;
+    int pos = 0;
+    uint32_t crc = 0xFFFFFFFF;
+
+    s-&gt;one = s-&gt;zero = s-&gt;zeroes = 0;
+    do{
+        L = wv_get_value(s, gb, s-&gt;median, &amp;last);
+        if(last) break;
+        R = wv_get_value(s, gb, s-&gt;median + 3, &amp;last);
+        if(last) break;
+        for(i = 0; i &lt; s-&gt;terms; i++){
+            t = s-&gt;decorr[i].value;
+            j = 0;
+            if(t &gt; 0){
+                if(t &gt; 8){
+                    if(t &amp; 1){
+                        A = 2 * s-&gt;decorr[i].samplesA[0] - s-&gt;decorr[i].samplesA[1];
+                        B = 2 * s-&gt;decorr[i].samplesB[0] - s-&gt;decorr[i].samplesB[1];
+                    }else{
+                        A = (3 * s-&gt;decorr[i].samplesA[0] - s-&gt;decorr[i].samplesA[1]) &gt;&gt; 1;
+                        B = (3 * s-&gt;decorr[i].samplesB[0] - s-&gt;decorr[i].samplesB[1]) &gt;&gt; 1;
+                    }
+                    s-&gt;decorr[i].samplesA[1] = s-&gt;decorr[i].samplesA[0];
+                    s-&gt;decorr[i].samplesB[1] = s-&gt;decorr[i].samplesB[0];
+                    j = 0;
+                }else{
+                    A = s-&gt;decorr[i].samplesA[pos];
+                    B = s-&gt;decorr[i].samplesB[pos];
+                    j = (pos + t) &amp; 7;
+                }
+                L2 = L + ((s-&gt;decorr[i].weightA * A + 512) &gt;&gt; 10);
+                R2 = R + ((s-&gt;decorr[i].weightB * B + 512) &gt;&gt; 10);
+                if(A &amp;&amp; L) s-&gt;decorr[i].weightA -= ((((L ^ A) &gt;&gt; 30) &amp; 2) - 1) * s-&gt;decorr[i].delta;
+                if(B &amp;&amp; R) s-&gt;decorr[i].weightB -= ((((R ^ B) &gt;&gt; 30) &amp; 2) - 1) * s-&gt;decorr[i].delta;
+                s-&gt;decorr[i].samplesA[j] = L = L2;
+                s-&gt;decorr[i].samplesB[j] = R = R2;
+            }else if(t == -1){
+                L2 = L + ((s-&gt;decorr[i].weightA * s-&gt;decorr[i].samplesA[0] + 512) &gt;&gt; 10);
+                UPDATE_WEIGHT_CLIP(s-&gt;decorr[i].weightA, s-&gt;decorr[i].delta, s-&gt;decorr[i].samplesA[0], L);
+                L = L2;
+                R2 = R + ((s-&gt;decorr[i].weightB * L2 + 512) &gt;&gt; 10);
+                UPDATE_WEIGHT_CLIP(s-&gt;decorr[i].weightB, s-&gt;decorr[i].delta, L2, R);
+                R = R2;
+                s-&gt;decorr[i].samplesA[0] = R;
+            }else{
+                R2 = R + ((s-&gt;decorr[i].weightB * s-&gt;decorr[i].samplesB[0] + 512) &gt;&gt; 10);
+                UPDATE_WEIGHT_CLIP(s-&gt;decorr[i].weightB, s-&gt;decorr[i].delta, s-&gt;decorr[i].samplesB[0], R);
+                R = R2;
+
+                if(t == -3){
+                    R2 = s-&gt;decorr[i].samplesA[0];
+                    s-&gt;decorr[i].samplesA[0] = R;
+                }
+
+                L2 = L + ((s-&gt;decorr[i].weightA * R2 + 512) &gt;&gt; 10);
+                UPDATE_WEIGHT_CLIP(s-&gt;decorr[i].weightA, s-&gt;decorr[i].delta, R2, L);
+                L = L2;
+                s-&gt;decorr[i].samplesB[0] = L;
+            }
+        }
+        pos = (pos + 1) &amp; 7;
+        if(s-&gt;joint)
+            L += (R -= (L &gt;&gt; 1));
+        crc = (crc * 3 + L) * 3 + R;
+        bit = (L &amp; s-&gt;and) | s-&gt;or;
+        *dst++ = ((L + bit) &lt;&lt; s-&gt;shift) - bit;
+        bit = (R &amp; s-&gt;and) | s-&gt;or;
+        *dst++ = ((R + bit) &lt;&lt; s-&gt;shift) - bit;
+        count++;
+    }while(!last &amp;&amp; count &lt; s-&gt;samples);
+
+    if(crc != s-&gt;CRC){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;CRC error\n&quot;);
+        return -1;
+    }
+    return count * 2;
+}
+
+static int wv_unpack_mono(WavpackContext *s, GetBitContext *gb, int16_t *dst)
+{
+    int i, j, count = 0;
+    int last, t;
+    int A, S, T, bit;
+    int pos = 0;
+    uint32_t crc = 0xFFFFFFFF;
+
+    s-&gt;one = s-&gt;zero = s-&gt;zeroes = 0;
+    do{
+        T = wv_get_value(s, gb, s-&gt;median, &amp;last);
+        S = 0;
+        if(last) break;
+        for(i = 0; i &lt; s-&gt;terms; i++){
+            t = s-&gt;decorr[i].value;
+            if(t &gt; 8){
+                if(t &amp; 1)
+                    A = 2 * s-&gt;decorr[i].samplesA[0] - s-&gt;decorr[i].samplesA[1];
+                else
+                    A = (3 * s-&gt;decorr[i].samplesA[0] - s-&gt;decorr[i].samplesA[1]) &gt;&gt; 1;
+                s-&gt;decorr[i].samplesA[1] = s-&gt;decorr[i].samplesA[0];
+                j = 0;
+            }else{
+                A = s-&gt;decorr[i].samplesA[pos];
+                j = (pos + t) &amp; 7;
+            }
+            S = T + ((s-&gt;decorr[i].weightA * A + 512) &gt;&gt; 10);
+            if(A &amp;&amp; T) s-&gt;decorr[i].weightA -= ((((T ^ A) &gt;&gt; 30) &amp; 2) - 1) * s-&gt;decorr[i].delta;
+            s-&gt;decorr[i].samplesA[j] = T = S;
+        }
+        pos = (pos + 1) &amp; 7;
+        crc = crc * 3 + S;
+        bit = (S &amp; s-&gt;and) | s-&gt;or;
+        *dst++ = ((S + bit) &lt;&lt; s-&gt;shift) - bit;
+        count++;
+    }while(!last &amp;&amp; count &lt; s-&gt;samples);
+
+    if(crc != s-&gt;CRC){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;CRC error\n&quot;);
+        return -1;
+    }
+    return count;
+}
+
+static av_cold int wavpack_decode_init(AVCodecContext *avctx)
+{
+    WavpackContext *s = avctx-&gt;priv_data;
+
+    s-&gt;avctx = avctx;
+    s-&gt;stereo = (avctx-&gt;channels == 2);
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+
+    return 0;
+}
+
+static int wavpack_decode_frame(AVCodecContext *avctx,
+                            void *data, int *data_size,
+                            const uint8_t *buf, int buf_size)
+{
+    WavpackContext *s = avctx-&gt;priv_data;
+    int16_t *samples = data;
+    int samplecount;
+    int got_terms = 0, got_weights = 0, got_samples = 0, got_entropy = 0, got_bs = 0;
+    const uint8_t* buf_end = buf + buf_size;
+    int i, j, id, size, ssize, weights, t;
+
+    if (buf_size == 0){
+        *data_size = 0;
+        return 0;
+    }
+
+    memset(s-&gt;decorr, 0, MAX_TERMS * sizeof(Decorr));
+    memset(s-&gt;median, 0, sizeof(s-&gt;median));
+    s-&gt;and = s-&gt;or = s-&gt;shift = 0;
+
+    s-&gt;samples = AV_RL32(buf); buf += 4;
+    if(!s-&gt;samples){
+        *data_size = 0;
+        return buf_size;
+    }
+    /* should not happen but who knows */
+    if(s-&gt;samples * 2 * avctx-&gt;channels &gt; *data_size){
+        av_log(avctx, AV_LOG_ERROR, &quot;Packet size is too big to be handled in lavc!\n&quot;);
+        return -1;
+    }
+    s-&gt;stereo_in = (AV_RL32(buf) &amp; WV_FALSE_STEREO) ? 0 : s-&gt;stereo;
+    s-&gt;joint = AV_RL32(buf) &amp; WV_JOINT_STEREO; buf += 4;
+    s-&gt;CRC = AV_RL32(buf); buf += 4;
+    // parse metadata blocks
+    while(buf &lt; buf_end){
+        id = *buf++;
+        size = *buf++;
+        if(id &amp; WP_IDF_LONG) {
+            size |= (*buf++) &lt;&lt; 8;
+            size |= (*buf++) &lt;&lt; 16;
+        }
+        size &lt;&lt;= 1; // size is specified in words
+        ssize = size;
+        if(id &amp; WP_IDF_ODD) size--;
+        if(size &lt; 0){
+            av_log(avctx, AV_LOG_ERROR, &quot;Got incorrect block %02X with size %i\n&quot;, id, size);
+            break;
+        }
+        if(buf + ssize &gt; buf_end){
+            av_log(avctx, AV_LOG_ERROR, &quot;Block size %i is out of bounds\n&quot;, size);
+            break;
+        }
+        if(id &amp; WP_IDF_IGNORE){
+            buf += ssize;
+            continue;
+        }
+        switch(id &amp; WP_IDF_MASK){
+        case WP_ID_DECTERMS:
+            s-&gt;terms = size;
+            if(s-&gt;terms &gt; MAX_TERMS){
+                av_log(avctx, AV_LOG_ERROR, &quot;Too many decorrelation terms\n&quot;);
+                buf += ssize;
+                continue;
+            }
+            for(i = 0; i &lt; s-&gt;terms; i++) {
+                s-&gt;decorr[s-&gt;terms - i - 1].value = (*buf &amp; 0x1F) - 5;
+                s-&gt;decorr[s-&gt;terms - i - 1].delta = *buf &gt;&gt; 5;
+                buf++;
+            }
+            got_terms = 1;
+            break;
+        case WP_ID_DECWEIGHTS:
+            if(!got_terms){
+                av_log(avctx, AV_LOG_ERROR, &quot;No decorrelation terms met\n&quot;);
+                continue;
+            }
+            weights = size &gt;&gt; s-&gt;stereo_in;
+            if(weights &gt; MAX_TERMS || weights &gt; s-&gt;terms){
+                av_log(avctx, AV_LOG_ERROR, &quot;Too many decorrelation weights\n&quot;);
+                buf += ssize;
+                continue;
+            }
+            for(i = 0; i &lt; weights; i++) {
+                t = (int8_t)(*buf++);
+                s-&gt;decorr[s-&gt;terms - i - 1].weightA = t &lt;&lt; 3;
+                if(s-&gt;decorr[s-&gt;terms - i - 1].weightA &gt; 0)
+                    s-&gt;decorr[s-&gt;terms - i - 1].weightA += (s-&gt;decorr[s-&gt;terms - i - 1].weightA + 64) &gt;&gt; 7;
+                if(s-&gt;stereo_in){
+                    t = (int8_t)(*buf++);
+                    s-&gt;decorr[s-&gt;terms - i - 1].weightB = t &lt;&lt; 3;
+                    if(s-&gt;decorr[s-&gt;terms - i - 1].weightB &gt; 0)
+                        s-&gt;decorr[s-&gt;terms - i - 1].weightB += (s-&gt;decorr[s-&gt;terms - i - 1].weightB + 64) &gt;&gt; 7;
+                }
+            }
+            got_weights = 1;
+            break;
+        case WP_ID_DECSAMPLES:
+            if(!got_terms){
+                av_log(avctx, AV_LOG_ERROR, &quot;No decorrelation terms met\n&quot;);
+                continue;
+            }
+            t = 0;
+            for(i = s-&gt;terms - 1; (i &gt;= 0) &amp;&amp; (t &lt; size); i--) {
+                if(s-&gt;decorr[i].value &gt; 8){
+                    s-&gt;decorr[i].samplesA[0] = wp_exp2(AV_RL16(buf)); buf += 2;
+                    s-&gt;decorr[i].samplesA[1] = wp_exp2(AV_RL16(buf)); buf += 2;
+                    if(s-&gt;stereo_in){
+                        s-&gt;decorr[i].samplesB[0] = wp_exp2(AV_RL16(buf)); buf += 2;
+                        s-&gt;decorr[i].samplesB[1] = wp_exp2(AV_RL16(buf)); buf += 2;
+                        t += 4;
+                    }
+                    t += 4;
+                }else if(s-&gt;decorr[i].value &lt; 0){
+                    s-&gt;decorr[i].samplesA[0] = wp_exp2(AV_RL16(buf)); buf += 2;
+                    s-&gt;decorr[i].samplesB[0] = wp_exp2(AV_RL16(buf)); buf += 2;
+                    t += 4;
+                }else{
+                    for(j = 0; j &lt; s-&gt;decorr[i].value; j++){
+                        s-&gt;decorr[i].samplesA[j] = wp_exp2(AV_RL16(buf)); buf += 2;
+                        if(s-&gt;stereo_in){
+                            s-&gt;decorr[i].samplesB[j] = wp_exp2(AV_RL16(buf)); buf += 2;
+                        }
+                    }
+                    t += s-&gt;decorr[i].value * 2 * (s-&gt;stereo_in + 1);
+                }
+            }
+            got_samples = 1;
+            break;
+        case WP_ID_ENTROPY:
+            if(size != 6 * (s-&gt;stereo_in + 1)){
+                av_log(avctx, AV_LOG_ERROR, &quot;Entropy vars size should be %i, got %i&quot;, 6 * (s-&gt;stereo_in + 1), size);
+                buf += ssize;
+                continue;
+            }
+            for(i = 0; i &lt; 3 * (s-&gt;stereo_in + 1); i++){
+                s-&gt;median[i] = wp_exp2(AV_RL16(buf));
+                buf += 2;
+            }
+            got_entropy = 1;
+            break;
+        case WP_ID_INT32INFO:
+            if(size != 4 || *buf){
+                av_log(avctx, AV_LOG_ERROR, &quot;Invalid INT32INFO, size = %i, sent_bits = %i\n&quot;, size, *buf);
+                buf += ssize;
+                continue;
+            }
+            if(buf[1])
+                s-&gt;shift = buf[1];
+            else if(buf[2]){
+                s-&gt;and = s-&gt;or = 1;
+                s-&gt;shift = buf[2];
+            }else if(buf[3]){
+                s-&gt;and = 1;
+                s-&gt;shift = buf[3];
+            }
+            buf += 4;
+            break;
+        case WP_ID_DATA:
+            init_get_bits(&amp;s-&gt;gb, buf, size * 8);
+            s-&gt;data_size = size * 8;
+            buf += size;
+            got_bs = 1;
+            break;
+        default:
+            buf += size;
+        }
+        if(id &amp; WP_IDF_ODD) buf++;
+    }
+    if(!got_terms){
+        av_log(avctx, AV_LOG_ERROR, &quot;No block with decorrelation terms\n&quot;);
+        return -1;
+    }
+    if(!got_weights){
+        av_log(avctx, AV_LOG_ERROR, &quot;No block with decorrelation weights\n&quot;);
+        return -1;
+    }
+    if(!got_samples){
+        av_log(avctx, AV_LOG_ERROR, &quot;No block with decorrelation samples\n&quot;);
+        return -1;
+    }
+    if(!got_entropy){
+        av_log(avctx, AV_LOG_ERROR, &quot;No block with entropy info\n&quot;);
+        return -1;
+    }
+    if(!got_bs){
+        av_log(avctx, AV_LOG_ERROR, &quot;Packed samples not found\n&quot;);
+        return -1;
+    }
+
+    if(s-&gt;stereo_in)
+        samplecount = wv_unpack_stereo(s, &amp;s-&gt;gb, samples);
+    else{
+        samplecount = wv_unpack_mono(s, &amp;s-&gt;gb, samples);
+        if(s-&gt;stereo){
+            int16_t *dst = samples + samplecount * 2;
+            int16_t *src = samples + samplecount;
+            int cnt = samplecount;
+            while(cnt--){
+                *--dst = *--src;
+                *--dst = *src;
+            }
+            samplecount *= 2;
+        }
+    }
+    *data_size = samplecount * 2;
+
+    return buf_size;
+}
+
+AVCodec wavpack_decoder = {
+    &quot;wavpack&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_WAVPACK,
+    sizeof(WavpackContext),
+    wavpack_decode_init,
+    NULL,
+    NULL,
+    wavpack_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;WavPack&quot;),
+};

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wma.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wma.c	2008-09-15 14:05:40 UTC (rev 27551)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/wma.c	2008-09-15 14:07:05 UTC (rev 27552)
@@ -0,0 +1,384 @@
+/*
+ * WMA compatible codec
+ * Copyright (c) 2002-2007 The FFmpeg Project.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;wma.h&quot;
+#include &quot;wmadata.h&quot;
+
+#undef NDEBUG
+#include &lt;assert.h&gt;
+
+/* XXX: use same run/length optimization as mpeg decoders */
+//FIXME maybe split decode / encode or pass flag
+static void init_coef_vlc(VLC *vlc,
+                          uint16_t **prun_table, uint16_t **plevel_table, uint16_t **pint_table,
+                          const CoefVLCTable *vlc_table)
+{
+    int n = vlc_table-&gt;n;
+    const uint8_t *table_bits = vlc_table-&gt;huffbits;
+    const uint32_t *table_codes = vlc_table-&gt;huffcodes;
+    const uint16_t *levels_table = vlc_table-&gt;levels;
+    uint16_t *run_table, *level_table, *int_table;
+    int i, l, j, k, level;
+
+    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);
+
+    run_table = av_malloc(n * sizeof(uint16_t));
+    level_table = av_malloc(n * sizeof(uint16_t));
+    int_table = av_malloc(n * sizeof(uint16_t));
+    i = 2;
+    level = 1;
+    k = 0;
+    while (i &lt; n) {
+        int_table[k]= i;
+        l = levels_table[k++];
+        for(j=0;j&lt;l;j++) {
+            run_table[i] = j;
+            level_table[i] = level;
+            i++;
+        }
+        level++;
+    }
+    *prun_table = run_table;
+    *plevel_table = level_table;
+    *pint_table= int_table;
+}
+
+int ff_wma_init(AVCodecContext * avctx, int flags2)
+{
+    WMACodecContext *s = avctx-&gt;priv_data;
+    int i;
+    float bps1, high_freq;
+    volatile float bps;
+    int sample_rate1;
+    int coef_vlc_table;
+
+    if(   avctx-&gt;sample_rate&lt;=0 || avctx-&gt;sample_rate&gt;50000
+       || avctx-&gt;channels&lt;=0 || avctx-&gt;channels&gt;8
+       || avctx-&gt;bit_rate&lt;=0)
+        return -1;
+
+    s-&gt;sample_rate = avctx-&gt;sample_rate;
+    s-&gt;nb_channels = avctx-&gt;channels;
+    s-&gt;bit_rate = avctx-&gt;bit_rate;
+    s-&gt;block_align = avctx-&gt;block_align;
+
+    dsputil_init(&amp;s-&gt;dsp, avctx);
+
+    if (avctx-&gt;codec-&gt;id == CODEC_ID_WMAV1) {
+        s-&gt;version = 1;
+    } else {
+        s-&gt;version = 2;
+    }
+
+    /* compute MDCT block size */
+    if (s-&gt;sample_rate &lt;= 16000) {
+        s-&gt;frame_len_bits = 9;
+    } else if (s-&gt;sample_rate &lt;= 22050 ||
+               (s-&gt;sample_rate &lt;= 32000 &amp;&amp; s-&gt;version == 1)) {
+        s-&gt;frame_len_bits = 10;
+    } else {
+        s-&gt;frame_len_bits = 11;
+    }
+    s-&gt;frame_len = 1 &lt;&lt; s-&gt;frame_len_bits;
+    if (s-&gt;use_variable_block_len) {
+        int nb_max, nb;
+        nb = ((flags2 &gt;&gt; 3) &amp; 3) + 1;
+        if ((s-&gt;bit_rate / s-&gt;nb_channels) &gt;= 32000)
+            nb += 2;
+        nb_max = s-&gt;frame_len_bits - BLOCK_MIN_BITS;
+        if (nb &gt; nb_max)
+            nb = nb_max;
+        s-&gt;nb_block_sizes = nb + 1;
+    } else {
+        s-&gt;nb_block_sizes = 1;
+    }
+
+    /* init rate dependent parameters */
+    s-&gt;use_noise_coding = 1;
+    high_freq = s-&gt;sample_rate * 0.5;
+
+    /* if version 2, then the rates are normalized */
+    sample_rate1 = s-&gt;sample_rate;
+    if (s-&gt;version == 2) {
+        if (sample_rate1 &gt;= 44100)
+            sample_rate1 = 44100;
+        else if (sample_rate1 &gt;= 22050)
+            sample_rate1 = 22050;
+        else if (sample_rate1 &gt;= 16000)
+            sample_rate1 = 16000;
+        else if (sample_rate1 &gt;= 11025)
+            sample_rate1 = 11025;
+        else if (sample_rate1 &gt;= 8000)
+            sample_rate1 = 8000;
+    }
+
+    bps = (float)s-&gt;bit_rate / (float)(s-&gt;nb_channels * s-&gt;sample_rate);
+    s-&gt;byte_offset_bits = av_log2((int)(bps * s-&gt;frame_len / 8.0 + 0.5)) + 2;
+
+    /* compute high frequency value and choose if noise coding should
+       be activated */
+    bps1 = bps;
+    if (s-&gt;nb_channels == 2)
+        bps1 = bps * 1.6;
+    if (sample_rate1 == 44100) {
+        if (bps1 &gt;= 0.61)
+            s-&gt;use_noise_coding = 0;
+        else
+            high_freq = high_freq * 0.4;
+    } else if (sample_rate1 == 22050) {
+        if (bps1 &gt;= 1.16)
+            s-&gt;use_noise_coding = 0;
+        else if (bps1 &gt;= 0.72)
+            high_freq = high_freq * 0.7;
+        else
+            high_freq = high_freq * 0.6;
+    } else if (sample_rate1 == 16000) {
+        if (bps &gt; 0.5)
+            high_freq = high_freq * 0.5;
+        else
+            high_freq = high_freq * 0.3;
+    } else if (sample_rate1 == 11025) {
+        high_freq = high_freq * 0.7;
+    } else if (sample_rate1 == 8000) {
+        if (bps &lt;= 0.625) {
+            high_freq = high_freq * 0.5;
+        } else if (bps &gt; 0.75) {
+            s-&gt;use_noise_coding = 0;
+        } else {
+            high_freq = high_freq * 0.65;
+        }
+    } else {
+        if (bps &gt;= 0.8) {
+            high_freq = high_freq * 0.75;
+        } else if (bps &gt;= 0.6) {
+            high_freq = high_freq * 0.6;
+        } else {
+            high_freq = high_freq * 0.5;
+        }
+    }
+    dprintf(s-&gt;avctx, &quot;flags2=0x%x\n&quot;, flags2);
+    dprintf(s-&gt;avctx, &quot;version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\n&quot;,
+           s-&gt;version, s-&gt;nb_channels, s-&gt;sample_rate, s-&gt;bit_rate,
+           s-&gt;block_align);
+    dprintf(s-&gt;avctx, &quot;bps=%f bps1=%f high_freq=%f bitoffset=%d\n&quot;,
+           bps, bps1, high_freq, s-&gt;byte_offset_bits);
+    dprintf(s-&gt;avctx, &quot;use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\n&quot;,
+           s-&gt;use_noise_coding, s-&gt;use_exp_vlc, s-&gt;nb_block_sizes);
+
+    /* compute the scale factor band sizes for each MDCT block size */
+    {
+        int a, b, pos, lpos, k, block_len, i, j, n;
+        const uint8_t *table;
+
+        if (s-&gt;version == 1) {
+            s-&gt;coefs_start = 3;
+        } else {
+            s-&gt;coefs_start = 0;
+        }
+        for(k = 0; k &lt; s-&gt;nb_block_sizes; k++) {
+            block_len = s-&gt;frame_len &gt;&gt; k;
+
+            if (s-&gt;version == 1) {
+                lpos = 0;
+                for(i=0;i&lt;25;i++) {
+                    a = wma_critical_freqs[i];
+                    b = s-&gt;sample_rate;
+                    pos = ((block_len * 2 * a)  + (b &gt;&gt; 1)) / b;
+                    if (pos &gt; block_len)
+                        pos = block_len;
+                    s-&gt;exponent_bands[0][i] = pos - lpos;
+                    if (pos &gt;= block_len) {
+                        i++;
+                        break;
+                    }
+                    lpos = pos;
+                }
+                s-&gt;exponent_sizes[0] = i;
+            } else {
+                /* hardcoded tables */
+                table = NULL;
+                a = s-&gt;frame_len_bits - BLOCK_MIN_BITS - k;
+                if (a &lt; 3) {
+                    if (s-&gt;sample_rate &gt;= 44100)
+                        table = exponent_band_44100[a];
+                    else if (s-&gt;sample_rate &gt;= 32000)
+                        table = exponent_band_32000[a];
+                    else if (s-&gt;sample_rate &gt;= 22050)
+                        table = exponent_band_22050[a];
+                }
+                if (table) {
+                    n = *table++;
+                    for(i=0;i&lt;n;i++)
+                        s-&gt;exponent_bands[k][i] = table[i];
+                    s-&gt;exponent_sizes[k] = n;
+                } else {
+                    j = 0;
+                    lpos = 0;
+                    for(i=0;i&lt;25;i++) {
+                        a = wma_critical_freqs[i];
+                        b = s-&gt;sample_rate;
+                        pos = ((block_len * 2 * a)  + (b &lt;&lt; 1)) / (4 * b);
+                        pos &lt;&lt;= 2;
+                        if (pos &gt; block_len)
+                            pos = block_len;
+                        if (pos &gt; lpos)
+                            s-&gt;exponent_bands[k][j++] = pos - lpos;
+                        if (pos &gt;= block_len)
+                            break;
+                        lpos = pos;
+                    }
+                    s-&gt;exponent_sizes[k] = j;
+                }
+            }
+
+            /* max number of coefs */
+            s-&gt;coefs_end[k] = (s-&gt;frame_len - ((s-&gt;frame_len * 9) / 100)) &gt;&gt; k;
+            /* high freq computation */
+            s-&gt;high_band_start[k] = (int)((block_len * 2 * high_freq) /
+                                          s-&gt;sample_rate + 0.5);
+            n = s-&gt;exponent_sizes[k];
+            j = 0;
+            pos = 0;
+            for(i=0;i&lt;n;i++) {
+                int start, end;

[... truncated: 4188 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011861.html">[Haiku-commits] r27551 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011863.html">[Haiku-commits] r27553 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11862">[ date ]</a>
              <a href="thread.html#11862">[ thread ]</a>
              <a href="subject.html#11862">[ subject ]</a>
              <a href="author.html#11862">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
