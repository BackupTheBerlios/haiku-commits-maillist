<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27563%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151412.m8FECrVK001532%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011872.html">
   <LINK REL="Next"  HREF="011874.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27563%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151412.m8FECrVK001532%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:12:53 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011872.html">[Haiku-commits] r27562 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011874.html">[Haiku-commits] r27564 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11873">[ date ]</a>
              <a href="thread.html#11873">[ thread ]</a>
              <a href="subject.html#11873">[ subject ]</a>
              <a href="author.html#11873">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:12:50 +0200 (Mon, 15 Sep 2008)
New Revision: 27563
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27563&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27563&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30dsp.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv34.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv34.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv34data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv34vlc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv40.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv40data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv40vlc2.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv10.c
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv10.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv10.c	2008-09-15 14:12:05 UTC (rev 27562)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv10.c	2008-09-15 14:12:50 UTC (rev 27563)
@@ -3,26 +3,28 @@
  * Copyright (c) 2000,2001 Fabrice Bellard.
  * Copyright (c) 2002-2004 Michael Niedermayer
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file rv10.c
  * RV10 codec.
  */
- 
+
 #include &quot;avcodec.h&quot;
 #include &quot;dsputil.h&quot;
 #include &quot;mpegvideo.h&quot;
@@ -67,7 +69,7 @@
  0x0f78, 0x0f79, 0x0f7a, 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f,
 };
 
-static const uint8_t rv_lum_bits[256] = 
+static const uint8_t rv_lum_bits[256] =
 {
  14, 12, 12, 12, 12, 12, 12, 12,
  12, 12, 12, 12, 12, 12, 12, 12,
@@ -193,12 +195,12 @@
             } else if (code == 0x7d) {
                 code = -128 + get_bits(&amp;s-&gt;gb, 7);
             } else if (code == 0x7e) {
-                if (get_bits(&amp;s-&gt;gb, 1) == 0)
+                if (get_bits1(&amp;s-&gt;gb) == 0)
                     code = (int8_t)(get_bits(&amp;s-&gt;gb, 8) + 1);
                 else
                     code = (int8_t)(get_bits(&amp;s-&gt;gb, 8));
             } else if (code == 0x7f) {
-                get_bits(&amp;s-&gt;gb, 11);
+                skip_bits(&amp;s-&gt;gb, 11);
                 code = 1;
             }
         } else {
@@ -214,7 +216,7 @@
             } else if (code == 0x1fd) {
                 code = -128 + get_bits(&amp;s-&gt;gb, 7);
             } else if (code == 0x1fe) {
-                get_bits(&amp;s-&gt;gb, 9);
+                skip_bits(&amp;s-&gt;gb, 9);
                 code = 1;
             } else {
                 av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;chroma dc error\n&quot;);
@@ -235,29 +237,59 @@
     int full_frame= 0;
 
     align_put_bits(&amp;s-&gt;pb);
-    
-    put_bits(&amp;s-&gt;pb, 1, 1);	/* marker */
 
-    put_bits(&amp;s-&gt;pb, 1, (s-&gt;pict_type == P_TYPE));
+    put_bits(&amp;s-&gt;pb, 1, 1);     /* marker */
 
-    put_bits(&amp;s-&gt;pb, 1, 0);	/* not PB frame */
+    put_bits(&amp;s-&gt;pb, 1, (s-&gt;pict_type == FF_P_TYPE));
 
+    put_bits(&amp;s-&gt;pb, 1, 0);     /* not PB frame */
+
     put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
 
-    if (s-&gt;pict_type == I_TYPE) {
-	/* specific MPEG like DC coding not used */
+    if (s-&gt;pict_type == FF_I_TYPE) {
+        /* specific MPEG like DC coding not used */
     }
     /* if multiple packets per frame are sent, the position at which
        to display the macro blocks is coded here */
     if(!full_frame){
-        put_bits(&amp;s-&gt;pb, 6, 0);	/* mb_x */
-        put_bits(&amp;s-&gt;pb, 6, 0);	/* mb_y */
+        put_bits(&amp;s-&gt;pb, 6, 0); /* mb_x */
+        put_bits(&amp;s-&gt;pb, 6, 0); /* mb_y */
         put_bits(&amp;s-&gt;pb, 12, s-&gt;mb_width * s-&gt;mb_height);
     }
 
-    put_bits(&amp;s-&gt;pb, 3, 0);	/* ignored */
+    put_bits(&amp;s-&gt;pb, 3, 0);     /* ignored */
 }
 
+void rv20_encode_picture_header(MpegEncContext *s, int picture_number){
+    put_bits(&amp;s-&gt;pb, 2, s-&gt;pict_type); //I 0 vs. 1 ?
+    put_bits(&amp;s-&gt;pb, 1, 0);     /* unknown bit */
+    put_bits(&amp;s-&gt;pb, 5, s-&gt;qscale);
+
+    put_sbits(&amp;s-&gt;pb, 8, picture_number); //FIXME wrong, but correct is not known
+    s-&gt;mb_x= s-&gt;mb_y= 0;
+    ff_h263_encode_mba(s);
+
+    put_bits(&amp;s-&gt;pb, 1, s-&gt;no_rounding);
+
+    assert(s-&gt;f_code == 1);
+    assert(s-&gt;unrestricted_mv == 1);
+//    assert(s-&gt;h263_aic== (s-&gt;pict_type == FF_I_TYPE));
+    assert(s-&gt;alt_inter_vlc == 0);
+    assert(s-&gt;umvplus == 0);
+    assert(s-&gt;modified_quant==1);
+    assert(s-&gt;loop_filter==1);
+
+    s-&gt;h263_aic= s-&gt;pict_type == FF_I_TYPE;
+    if(s-&gt;h263_aic){
+        s-&gt;y_dc_scale_table=
+        s-&gt;c_dc_scale_table= ff_aic_dc_scale_table;
+    }else{
+        s-&gt;y_dc_scale_table=
+        s-&gt;c_dc_scale_table= ff_mpeg1_dc_scale_table;
+    }
+}
+
+#if 0 /* unused, remove? */
 static int get_num(GetBitContext *gb)
 {
     int n, n1;
@@ -270,30 +302,30 @@
         return (n &lt;&lt; 16) | n1;
     }
 }
+#endif
 
 #endif //CONFIG_ENCODERS
 
 /* read RV 1.0 compatible frame header */
 static int rv10_decode_picture_header(MpegEncContext *s)
 {
-    int mb_count, pb_frame, marker, full_frame, unk;
-    
-    full_frame= s-&gt;avctx-&gt;slice_count==1;
+    int mb_count, pb_frame, marker, unk, mb_xy;
+
 //printf(&quot;ff:%d\n&quot;, full_frame);
-    marker = get_bits(&amp;s-&gt;gb, 1);
+    marker = get_bits1(&amp;s-&gt;gb);
 
-    if (get_bits(&amp;s-&gt;gb, 1))
-        s-&gt;pict_type = P_TYPE;
+    if (get_bits1(&amp;s-&gt;gb))
+        s-&gt;pict_type = FF_P_TYPE;
     else
-        s-&gt;pict_type = I_TYPE;
+        s-&gt;pict_type = FF_I_TYPE;
 //printf(&quot;h:%X ver:%d\n&quot;,h,s-&gt;rv10_version);
     if(!marker) av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;marker missing\n&quot;);
-    pb_frame = get_bits(&amp;s-&gt;gb, 1);
+    pb_frame = get_bits1(&amp;s-&gt;gb);
 
 #ifdef DEBUG
-    printf(&quot;pict_type=%d pb_frame=%d\n&quot;, s-&gt;pict_type, pb_frame);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;pict_type=%d pb_frame=%d\n&quot;, s-&gt;pict_type, pb_frame);
 #endif
-    
+
     if (pb_frame){
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;pb frame not supported\n&quot;);
         return -1;
@@ -305,14 +337,14 @@
         return -1;
     }
 
-    if (s-&gt;pict_type == I_TYPE) {
+    if (s-&gt;pict_type == FF_I_TYPE) {
         if (s-&gt;rv10_version == 3) {
             /* specific MPEG like DC coding not used */
             s-&gt;last_dc[0] = get_bits(&amp;s-&gt;gb, 8);
             s-&gt;last_dc[1] = get_bits(&amp;s-&gt;gb, 8);
             s-&gt;last_dc[2] = get_bits(&amp;s-&gt;gb, 8);
 #ifdef DEBUG
-            printf(&quot;DC:%d %d %d\n&quot;,
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;DC:%d %d %d\n&quot;,
                    s-&gt;last_dc[0],
                    s-&gt;last_dc[1],
                    s-&gt;last_dc[2]);
@@ -321,16 +353,18 @@
     }
     /* if multiple packets per frame are sent, the position at which
        to display the macro blocks is coded here */
-    if ((!full_frame) || show_bits(&amp;s-&gt;gb, 12)==0) {
-        s-&gt;mb_x = get_bits(&amp;s-&gt;gb, 6);	/* mb_x */
-        s-&gt;mb_y = get_bits(&amp;s-&gt;gb, 6);	/* mb_y */
+
+    mb_xy= s-&gt;mb_x + s-&gt;mb_y*s-&gt;mb_width;
+    if(show_bits(&amp;s-&gt;gb, 12)==0 || (mb_xy &amp;&amp; mb_xy &lt; s-&gt;mb_num)){
+        s-&gt;mb_x = get_bits(&amp;s-&gt;gb, 6); /* mb_x */
+        s-&gt;mb_y = get_bits(&amp;s-&gt;gb, 6); /* mb_y */
         mb_count = get_bits(&amp;s-&gt;gb, 12);
     } else {
         s-&gt;mb_x = 0;
         s-&gt;mb_y = 0;
         mb_count = s-&gt;mb_width * s-&gt;mb_height;
     }
-    unk= get_bits(&amp;s-&gt;gb, 3);	/* ignored */
+    unk= get_bits(&amp;s-&gt;gb, 3);   /* ignored */
 //printf(&quot;%d\n&quot;, unk);
     s-&gt;f_code = 1;
     s-&gt;unrestricted_mv = 1;
@@ -341,26 +375,48 @@
 static int rv20_decode_picture_header(MpegEncContext *s)
 {
     int seq, mb_pos, i;
-    
+
+#if 0
+    GetBitContext gb= s-&gt;gb;
+    for(i=0; i&lt;64; i++){
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%d&quot;, get_bits1(&amp;gb));
+        if(i%4==3) av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; &quot;);
+    }
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+#endif
+#if 0
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%3dx%03d/%02Xx%02X &quot;, s-&gt;width, s-&gt;height, s-&gt;width/4, s-&gt;height/4);
+    for(i=0; i&lt;s-&gt;avctx-&gt;extradata_size; i++){
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%02X &quot;, ((uint8_t*)s-&gt;avctx-&gt;extradata)[i]);
+        if(i%4==3) av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; &quot;);
+    }
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+#endif
+
     if(s-&gt;avctx-&gt;sub_id == 0x30202002 || s-&gt;avctx-&gt;sub_id == 0x30203002){
         if (get_bits(&amp;s-&gt;gb, 3)){
             av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown triplet set\n&quot;);
             return -1;
-        } 
-    }   
+        }
+    }
 
     i= get_bits(&amp;s-&gt;gb, 2);
     switch(i){
-    case 0: s-&gt;pict_type= I_TYPE; break;
-    case 1: s-&gt;pict_type= I_TYPE; break; //hmm ...
-    case 2: s-&gt;pict_type= P_TYPE; break;
-    case 3: s-&gt;pict_type= B_TYPE; break;
-    default: 
+    case 0: s-&gt;pict_type= FF_I_TYPE; break;
+    case 1: s-&gt;pict_type= FF_I_TYPE; break; //hmm ...
+    case 2: s-&gt;pict_type= FF_P_TYPE; break;
+    case 3: s-&gt;pict_type= FF_B_TYPE; break;
+    default:
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown frame type\n&quot;);
         return -1;
     }
-    
-    if (get_bits(&amp;s-&gt;gb, 1)){
+
+    if(s-&gt;last_picture_ptr==NULL &amp;&amp; s-&gt;pict_type==FF_B_TYPE){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;early B pix\n&quot;);
+        return -1;
+    }
+
+    if (get_bits1(&amp;s-&gt;gb)){
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown bit set\n&quot;);
         return -1;
     }
@@ -371,31 +427,62 @@
         return -1;
     }
     if(s-&gt;avctx-&gt;sub_id == 0x30203002){
-        if (get_bits(&amp;s-&gt;gb, 1)){
+        if (get_bits1(&amp;s-&gt;gb)){
             av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown bit2 set\n&quot;);
             return -1;
         }
     }
-        
+
     if(s-&gt;avctx-&gt;has_b_frames){
-        if (get_bits(&amp;s-&gt;gb, 1)){
-//            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown bit3 set\n&quot;);
+        int f, new_w, new_h;
+        int v= s-&gt;avctx-&gt;extradata_size &gt;= 4 ? 7&amp;((uint8_t*)s-&gt;avctx-&gt;extradata)[1] : 0;
+
+        if (get_bits1(&amp;s-&gt;gb)){
+            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown bit3 set\n&quot;);
 //            return -1;
         }
-        seq= get_bits(&amp;s-&gt;gb, 15);
+        seq= get_bits(&amp;s-&gt;gb, 13)&lt;&lt;2;
+
+        f= get_bits(&amp;s-&gt;gb, av_log2(v)+1);
+
+        if(f){
+            new_w= 4*((uint8_t*)s-&gt;avctx-&gt;extradata)[6+2*f];
+            new_h= 4*((uint8_t*)s-&gt;avctx-&gt;extradata)[7+2*f];
+        }else{
+            new_w= s-&gt;width; //FIXME wrong we of course must save the original in the context
+            new_h= s-&gt;height;
+        }
+        if(new_w != s-&gt;width || new_h != s-&gt;height){
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;attempting to change resolution to %dx%d\n&quot;, new_w, new_h);
+            if (avcodec_check_dimensions(s-&gt;avctx, new_h, new_w) &lt; 0)
+                return -1;
+            MPV_common_end(s);
+            s-&gt;width  = s-&gt;avctx-&gt;width = new_w;
+            s-&gt;height = s-&gt;avctx-&gt;height= new_h;
+            if (MPV_common_init(s) &lt; 0)
+                return -1;
+        }
+
+        if(s-&gt;avctx-&gt;debug &amp; FF_DEBUG_PICT_INFO){
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;F %d/%d\n&quot;, f, v);
+        }
+    }else{
+        seq= get_bits(&amp;s-&gt;gb, 8)*128;
+    }
+
+//     if(s-&gt;avctx-&gt;sub_id &lt;= 0x20201002){ //0x20201002 definitely needs this
+    mb_pos= ff_h263_decode_mba(s);
+/*    }else{
         mb_pos= get_bits(&amp;s-&gt;gb, av_log2(s-&gt;mb_num-1)+1);
         s-&gt;mb_x= mb_pos % s-&gt;mb_width;
         s-&gt;mb_y= mb_pos / s-&gt;mb_width;
-    }else{
-        seq= get_bits(&amp;s-&gt;gb, 8)*128;
-        mb_pos= ff_h263_decode_mba(s);
-    }
-//printf(&quot;%d\n&quot;, seq);
+    }*/
+//av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%d\n&quot;, seq);
     seq |= s-&gt;time &amp;~0x7FFF;
     if(seq - s-&gt;time &gt;  0x4000) seq -= 0x8000;
     if(seq - s-&gt;time &lt; -0x4000) seq += 0x8000;
-    if(seq != s-&gt;time){  
-        if(s-&gt;pict_type!=B_TYPE){
+    if(seq != s-&gt;time){
+        if(s-&gt;pict_type!=FF_B_TYPE){
             s-&gt;time= seq;
             s-&gt;pp_time= s-&gt;time - s-&gt;last_non_b_time;
             s-&gt;last_non_b_time= s-&gt;time;
@@ -403,39 +490,45 @@
             s-&gt;time= seq;
             s-&gt;pb_time= s-&gt;pp_time - (s-&gt;last_non_b_time - s-&gt;time);
             if(s-&gt;pp_time &lt;=s-&gt;pb_time || s-&gt;pp_time &lt;= s-&gt;pp_time - s-&gt;pb_time || s-&gt;pp_time&lt;=0){
-                printf(&quot;messed up order, seeking?, skiping current b frame\n&quot;);
-                return FRAME_SKIPED;
+                av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;messed up order, possible from seeking? skipping current b frame\n&quot;);
+                return FRAME_SKIPPED;
             }
+            ff_mpeg4_init_direct_mv(s);
         }
     }
 //    printf(&quot;%d %d %d %d %d\n&quot;, seq, (int)s-&gt;time, (int)s-&gt;last_non_b_time, s-&gt;pp_time, s-&gt;pb_time);
+/*for(i=0; i&lt;32; i++){
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%d&quot;, get_bits1(&amp;s-&gt;gb));
+}
+av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);*/
+    s-&gt;no_rounding= get_bits1(&amp;s-&gt;gb);
 
-    s-&gt;no_rounding= get_bits1(&amp;s-&gt;gb);
-    
     s-&gt;f_code = 1;
     s-&gt;unrestricted_mv = 1;
-    s-&gt;h263_aic= s-&gt;pict_type == I_TYPE;
+    s-&gt;h263_aic= s-&gt;pict_type == FF_I_TYPE;
 //    s-&gt;alt_inter_vlc=1;
 //    s-&gt;obmc=1;
 //    s-&gt;umvplus=1;
     s-&gt;modified_quant=1;
     s-&gt;loop_filter=1;
-    
+
     if(s-&gt;avctx-&gt;debug &amp; FF_DEBUG_PICT_INFO){
-            av_log(s-&gt;avctx, AV_LOG_INFO, &quot;num:%5d x:%2d y:%2d type:%d qscale:%2d rnd:%d\n&quot;, 
+            av_log(s-&gt;avctx, AV_LOG_INFO, &quot;num:%5d x:%2d y:%2d type:%d qscale:%2d rnd:%d\n&quot;,
                    seq, s-&gt;mb_x, s-&gt;mb_y, s-&gt;pict_type, s-&gt;qscale, s-&gt;no_rounding);
     }
 
-    assert(s-&gt;pict_type != B_TYPE || !s-&gt;low_delay);
+    assert(s-&gt;pict_type != FF_B_TYPE || !s-&gt;low_delay);
 
     return s-&gt;mb_width*s-&gt;mb_height - mb_pos;
 }
 
-static int rv10_decode_init(AVCodecContext *avctx)
+static av_cold int rv10_decode_init(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
     static int done=0;
 
+    MPV_decode_defaults(s);
+
     s-&gt;avctx= avctx;
     s-&gt;out_format = FMT_H263;
     s-&gt;codec_id= avctx-&gt;codec_id;
@@ -443,61 +536,59 @@
     s-&gt;width = avctx-&gt;width;
     s-&gt;height = avctx-&gt;height;
 
-    switch(avctx-&gt;sub_id){
-    case 0x10000000:
+    s-&gt;h263_long_vectors= ((uint8_t*)avctx-&gt;extradata)[3] &amp; 1;
+    avctx-&gt;sub_id= AV_RB32((uint8_t*)avctx-&gt;extradata + 4);
+
+    if (avctx-&gt;sub_id == 0x10000000) {
         s-&gt;rv10_version= 0;
-        s-&gt;h263_long_vectors=0;
         s-&gt;low_delay=1;
-        break;
-    case 0x10003000:
+    } else if (avctx-&gt;sub_id == 0x10002000) {
         s-&gt;rv10_version= 3;
-        s-&gt;h263_long_vectors=1;
         s-&gt;low_delay=1;
-        break;
-    case 0x10003001:
+        s-&gt;obmc=1;
+    } else if (avctx-&gt;sub_id == 0x10003000) {
         s-&gt;rv10_version= 3;
-        s-&gt;h263_long_vectors=0;
         s-&gt;low_delay=1;
-        break;
-    case 0x20001000:
-    case 0x20100001:
-    case 0x20101001:
+    } else if (avctx-&gt;sub_id == 0x10003001) {
+        s-&gt;rv10_version= 3;
         s-&gt;low_delay=1;
-        break;
-    case 0x20200002:
-    case 0x30202002:
-    case 0x30203002:
+    } else if (    avctx-&gt;sub_id == 0x20001000
+               || (avctx-&gt;sub_id &gt;= 0x20100000 &amp;&amp; avctx-&gt;sub_id &lt; 0x201a0000)) {
+        s-&gt;low_delay=1;
+    } else if (    avctx-&gt;sub_id == 0x30202002
+               ||  avctx-&gt;sub_id == 0x30203002
+               || (avctx-&gt;sub_id &gt;= 0x20200002 &amp;&amp; avctx-&gt;sub_id &lt; 0x20300000)) {
         s-&gt;low_delay=0;
         s-&gt;avctx-&gt;has_b_frames=1;
-        break;
-    default:
+    } else
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;unknown header %X\n&quot;, avctx-&gt;sub_id);
+
+    if(avctx-&gt;debug &amp; FF_DEBUG_PICT_INFO){
+        av_log(avctx, AV_LOG_DEBUG, &quot;ver:%X ver0:%X\n&quot;, avctx-&gt;sub_id, avctx-&gt;extradata_size &gt;= 4 ? ((uint32_t*)avctx-&gt;extradata)[0] : -1);
     }
-//printf(&quot;ver:%X\n&quot;, avctx-&gt;sub_id);
+
+    avctx-&gt;pix_fmt = PIX_FMT_YUV420P;
+
     if (MPV_common_init(s) &lt; 0)
         return -1;
 
     h263_decode_init_vlc(s);
 
-    s-&gt;progressive_sequence=1;
-
     /* init rv vlc */
     if (!done) {
-        init_vlc(&amp;rv_dc_lum, DC_VLC_BITS, 256, 
+        init_vlc(&amp;rv_dc_lum, DC_VLC_BITS, 256,
                  rv_lum_bits, 1, 1,
-                 rv_lum_code, 2, 2);
-        init_vlc(&amp;rv_dc_chrom, DC_VLC_BITS, 256, 
+                 rv_lum_code, 2, 2, 1);
+        init_vlc(&amp;rv_dc_chrom, DC_VLC_BITS, 256,
                  rv_chrom_bits, 1, 1,
-                 rv_chrom_code, 2, 2);
+                 rv_chrom_code, 2, 2, 1);
         done = 1;
     }
-    
-    avctx-&gt;pix_fmt = PIX_FMT_YUV420P;
 
     return 0;
 }
 
-static int rv10_decode_end(AVCodecContext *avctx)
+static av_cold int rv10_decode_end(AVCodecContext *avctx)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
 
@@ -505,19 +596,13 @@
     return 0;
 }
 
-static int rv10_decode_packet(AVCodecContext *avctx, 
-                             uint8_t *buf, int buf_size)
+static int rv10_decode_packet(AVCodecContext *avctx,
+                             const uint8_t *buf, int buf_size)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
-    int i, mb_count, mb_pos, left;
+    int mb_count, mb_pos, left, start_mb_x;
 
     init_get_bits(&amp;s-&gt;gb, buf, buf_size*8);
-#if 0
-    for(i=0; i&lt;buf_size*8 &amp;&amp; i&lt;200; i++)
-        printf(&quot;%d&quot;, get_bits1(&amp;s-&gt;gb));
-    printf(&quot;\n&quot;);
-    return 0;
-#endif
     if(s-&gt;codec_id ==CODEC_ID_RV10)
         mb_count = rv10_decode_picture_header(s);
     else
@@ -526,7 +611,7 @@
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;HEADER ERROR\n&quot;);
         return -1;
     }
-    
+
     if (s-&gt;mb_x &gt;= s-&gt;mb_width ||
         s-&gt;mb_y &gt;= s-&gt;mb_height) {
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;POS ERROR %d %d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
@@ -538,31 +623,34 @@
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;COUNT ERROR\n&quot;);
         return -1;
     }
-//if(s-&gt;pict_type == P_TYPE) return 0;
+//if(s-&gt;pict_type == FF_P_TYPE) return 0;
 
     if ((s-&gt;mb_x == 0 &amp;&amp; s-&gt;mb_y == 0) || s-&gt;current_picture_ptr==NULL) {
+        if(s-&gt;current_picture_ptr){ //FIXME write parser so we always have complete frames?
+            ff_er_frame_end(s);
+            MPV_frame_end(s);
+            s-&gt;mb_x= s-&gt;mb_y = s-&gt;resync_mb_x = s-&gt;resync_mb_y= 0;
+        }
         if(MPV_frame_start(s, avctx) &lt; 0)
             return -1;
+        ff_er_frame_start(s);
     }
 
-    if(s-&gt;pict_type == B_TYPE){ //FIXME remove after cleaning mottion_val indexing
-        memset(s-&gt;current_picture.motion_val[0], 0, sizeof(int16_t)*2*(s-&gt;mb_width*2+2)*(s-&gt;mb_height*2+2));
-    }
-
 #ifdef DEBUG
-    printf(&quot;qscale=%d\n&quot;, s-&gt;qscale);
+    av_log(avctx, AV_LOG_DEBUG, &quot;qscale=%d\n&quot;, s-&gt;qscale);
 #endif
 
     /* default quantization values */
     if(s-&gt;codec_id== CODEC_ID_RV10){
         if(s-&gt;mb_y==0) s-&gt;first_slice_line=1;
     }else{
-        s-&gt;first_slice_line=1;    
+        s-&gt;first_slice_line=1;
         s-&gt;resync_mb_x= s-&gt;mb_x;
-        s-&gt;resync_mb_y= s-&gt;mb_y;
     }
+    start_mb_x= s-&gt;mb_x;
+    s-&gt;resync_mb_y= s-&gt;mb_y;
     if(s-&gt;h263_aic){
-        s-&gt;y_dc_scale_table= 
+        s-&gt;y_dc_scale_table=
         s-&gt;c_dc_scale_table= ff_aic_dc_scale_table;
     }else{
         s-&gt;y_dc_scale_table=
@@ -571,7 +659,7 @@
 
     if(s-&gt;modified_quant)
         s-&gt;chroma_qscale_table= ff_h263_chroma_qscale_table;
-        
+
     ff_set_qscale(s, s-&gt;qscale);
 
     s-&gt;rv10_first_dc_coded[0] = 0;
@@ -581,28 +669,28 @@
     s-&gt;block_wrap[0]=
     s-&gt;block_wrap[1]=
     s-&gt;block_wrap[2]=
-    s-&gt;block_wrap[3]= s-&gt;mb_width*2 + 2;
+    s-&gt;block_wrap[3]= s-&gt;b8_stride;
     s-&gt;block_wrap[4]=
-    s-&gt;block_wrap[5]= s-&gt;mb_width + 2;
+    s-&gt;block_wrap[5]= s-&gt;mb_stride;
     ff_init_block_index(s);
     /* decode each macroblock */
-    for(i=0;i&lt;mb_count;i++) {
+
+    for(s-&gt;mb_num_left= mb_count; s-&gt;mb_num_left&gt;0; s-&gt;mb_num_left--) {
         int ret;
         ff_update_block_index(s);
 #ifdef DEBUG
-        printf(&quot;**mb x=%d y=%d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
+        av_log(avctx, AV_LOG_DEBUG, &quot;**mb x=%d y=%d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
 #endif
-        
-	s-&gt;dsp.clear_blocks(s-&gt;block[0]);
+
         s-&gt;mv_dir = MV_DIR_FORWARD;
-        s-&gt;mv_type = MV_TYPE_16X16; 
+        s-&gt;mv_type = MV_TYPE_16X16;
         ret=ff_h263_decode_mb(s, s-&gt;block);
 
-        if (ret == SLICE_ERROR) {
+        if (ret == SLICE_ERROR || s-&gt;gb.size_in_bits &lt; get_bits_count(&amp;s-&gt;gb)) {
             av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;ERROR at MB %d %d\n&quot;, s-&gt;mb_x, s-&gt;mb_y);
             return -1;
         }
-        if(s-&gt;pict_type != B_TYPE)
+        if(s-&gt;pict_type != FF_B_TYPE)
             ff_h263_update_motion_val(s);
         MPV_decode_mb(s, s-&gt;block);
         if(s-&gt;loop_filter)
@@ -618,63 +706,70 @@
         if(ret == SLICE_END) break;
     }
 
+    ff_er_add_slice(s, start_mb_x, s-&gt;resync_mb_y, s-&gt;mb_x-1, s-&gt;mb_y, AC_END|DC_END|MV_END);
+
     return buf_size;
 }
 
-static int rv10_decode_frame(AVCodecContext *avctx, 
+static int get_slice_offset(AVCodecContext *avctx, const uint8_t *buf, int n)
+{
+    if(avctx-&gt;slice_count) return avctx-&gt;slice_offset[n];
+    else                   return AV_RL32(buf + n*8);
+}
+
+static int rv10_decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     MpegEncContext *s = avctx-&gt;priv_data;
     int i;
-    AVFrame *pict = data; 
+    AVFrame *pict = data;
+    int slice_count;
+    const uint8_t *slices_hdr = NULL;
 
 #ifdef DEBUG
-    printf(&quot;*****frame %d size=%d\n&quot;, avctx-&gt;frame_number, buf_size);
+    av_log(avctx, AV_LOG_DEBUG, &quot;*****frame %d size=%d\n&quot;, avctx-&gt;frame_number, buf_size);
 #endif
 
     /* no supplementary picture */
     if (buf_size == 0) {
-        *data_size = 0;
         return 0;
     }
 
-    if(avctx-&gt;slice_count){
-        for(i=0; i&lt;avctx-&gt;slice_count; i++){
-            int offset= avctx-&gt;slice_offset[i];
-            int size;
-            
-            if(i+1 == avctx-&gt;slice_count)
-                size= buf_size - offset;
-            else
-                size= avctx-&gt;slice_offset[i+1] - offset;
+    if(!avctx-&gt;slice_count){
+        slice_count = (*buf++) + 1;
+        slices_hdr = buf + 4;
+        buf += 8 * slice_count;
+    }else
+        slice_count = avctx-&gt;slice_count;
 
-            if( rv10_decode_packet(avctx, buf+offset, size) &lt; 0 )
-                return -1;
-        }
-    }else{
-        if( rv10_decode_packet(avctx, buf, buf_size) &lt; 0 )
-            return -1;
+    for(i=0; i&lt;slice_count; i++){
+        int offset= get_slice_offset(avctx, slices_hdr, i);
+        int size;
+
+        if(i+1 == slice_count)
+            size= buf_size - offset;
+        else
+            size= get_slice_offset(avctx, slices_hdr, i+1) - offset;
+
+        rv10_decode_packet(avctx, buf+offset, size);
     }
-    
-    if(s-&gt;pict_type == B_TYPE){ //FIXME remove after cleaning mottion_val indexing
-        memset(s-&gt;current_picture.motion_val[0], 0, sizeof(int16_t)*2*(s-&gt;mb_width*2+2)*(s-&gt;mb_height*2+2));
-    }
 
-    if(s-&gt;mb_y&gt;=s-&gt;mb_height){
+    if(s-&gt;current_picture_ptr != NULL &amp;&amp; s-&gt;mb_y&gt;=s-&gt;mb_height){
+        ff_er_frame_end(s);
         MPV_frame_end(s);
-    
-        if(s-&gt;pict_type==B_TYPE || s-&gt;low_delay){
-            *pict= *(AVFrame*)&amp;s-&gt;current_picture;
+
+        if (s-&gt;pict_type == FF_B_TYPE || s-&gt;low_delay) {
+            *pict= *(AVFrame*)s-&gt;current_picture_ptr;
+        } else if (s-&gt;last_picture_ptr != NULL) {
+            *pict= *(AVFrame*)s-&gt;last_picture_ptr;
+        }
+
+        if(s-&gt;last_picture_ptr || s-&gt;low_delay){
+            *data_size = sizeof(AVFrame);
             ff_print_debug_info(s, pict);
-        } else {
-            *pict= *(AVFrame*)&amp;s-&gt;last_picture;
-            ff_print_debug_info(s, pict);
         }
-        
-        *data_size = sizeof(AVFrame);
-    }else{
-        *data_size = 0;
+        s-&gt;current_picture_ptr= NULL; //so we can detect if frame_end wasnt called (find some nicer solution...)
     }
 
     return buf_size;
@@ -689,7 +784,8 @@
     NULL,
     rv10_decode_end,
     rv10_decode_frame,
-    CODEC_CAP_DR1
+    CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealVideo 1.0&quot;),
 };
 
 AVCodec rv20_decoder = {
@@ -701,6 +797,8 @@
     NULL,
     rv10_decode_end,
     rv10_decode_frame,
-    CODEC_CAP_DR1
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY,
+    .flush= ff_mpeg_flush,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealVideo 2.0&quot;),
 };
 

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30.c	2008-09-15 14:12:05 UTC (rev 27562)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30.c	2008-09-15 14:12:50 UTC (rev 27563)
@@ -0,0 +1,148 @@
+/*
+ * RV30 decoder
+ * Copyright (c) 2007 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rv30.c
+ * RV30 decoder
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;mpegvideo.h&quot;
+#include &quot;golomb.h&quot;
+
+#include &quot;rv34.h&quot;
+#include &quot;rv30data.h&quot;
+
+
+static int rv30_parse_slice_header(RV34DecContext *r, GetBitContext *gb, SliceInfo *si)
+{
+    int mb_bits;
+    int w = r-&gt;s.width, h = r-&gt;s.height;
+    int mb_size;
+
+    memset(si, 0, sizeof(SliceInfo));
+    skip_bits(gb, 3);
+    si-&gt;type = get_bits(gb, 2);
+    if(si-&gt;type == 1) si-&gt;type = 0;
+    if(get_bits1(gb))
+        return -1;
+    si-&gt;quant = get_bits(gb, 5);
+    skip_bits1(gb);
+    si-&gt;pts = get_bits(gb, 13);
+    skip_bits(gb, r-&gt;rpr);
+    si-&gt;width  = w;
+    si-&gt;height = h;
+    mb_size = ((w + 15) &gt;&gt; 4) * ((h + 15) &gt;&gt; 4);
+    mb_bits = ff_rv34_get_start_offset(gb, mb_size);
+    si-&gt;start = get_bits(gb, mb_bits);
+    skip_bits1(gb);
+    return 0;
+}
+
+/**
+ * Decode 4x4 intra types array.
+ */
+static int rv30_decode_intra_types(RV34DecContext *r, GetBitContext *gb, int8_t *dst)
+{
+    int i, j, k;
+
+    for(i = 0; i &lt; 4; i++, dst += r-&gt;s.b4_stride - 4){
+        for(j = 0; j &lt; 4; j+= 2){
+            int code = svq3_get_ue_golomb(gb) &lt;&lt; 1;
+            if(code &gt;= 81*2){
+                av_log(r-&gt;s.avctx, AV_LOG_ERROR, &quot;Incorrect intra prediction code\n&quot;);
+                return -1;
+            }
+            for(k = 0; k &lt; 2; k++){
+                int A = dst[-r-&gt;s.b4_stride] + 1;
+                int B = dst[-1] + 1;
+                *dst++ = rv30_itype_from_context[A * 90 + B * 9 + rv30_itype_code[code + k]];
+                if(dst[-1] == 9){
+                    av_log(r-&gt;s.avctx, AV_LOG_ERROR, &quot;Incorrect intra prediction mode\n&quot;);
+                    return -1;
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode macroblock information.
+ */
+static int rv30_decode_mb_info(RV34DecContext *r)
+{
+    static const int rv30_p_types[6] = { RV34_MB_SKIP, RV34_MB_P_16x16, RV34_MB_P_8x8, -1, RV34_MB_TYPE_INTRA, RV34_MB_TYPE_INTRA16x16 };
+    static const int rv30_b_types[6] = { RV34_MB_SKIP, RV34_MB_B_DIRECT, RV34_MB_B_FORWARD, RV34_MB_B_BACKWARD, RV34_MB_TYPE_INTRA, RV34_MB_TYPE_INTRA16x16 };
+    MpegEncContext *s = &amp;r-&gt;s;
+    GetBitContext *gb = &amp;s-&gt;gb;
+    int code = svq3_get_ue_golomb(gb);
+
+    if(code &gt; 11){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Incorrect MB type code\n&quot;);
+        return -1;
+    }
+    if(code &gt; 5){
+        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;dquant needed\n&quot;);
+        code -= 6;
+    }
+    if(s-&gt;pict_type != FF_B_TYPE)
+        return rv30_p_types[code];
+    else
+        return rv30_b_types[code];
+}
+
+/**
+ * Initialize decoder.
+ */
+static av_cold int rv30_decode_init(AVCodecContext *avctx)
+{
+    RV34DecContext *r = avctx-&gt;priv_data;
+
+    r-&gt;rv30 = 1;
+    ff_rv34_decode_init(avctx);
+    if(avctx-&gt;extradata_size &lt; 2){
+        av_log(avctx, AV_LOG_ERROR, &quot;Extradata is too small.\n&quot;);
+        return -1;
+    }
+    r-&gt;rpr = (avctx-&gt;extradata[1] &amp; 7) &gt;&gt; 1;
+    r-&gt;rpr = FFMIN(r-&gt;rpr + 1, 3);
+    r-&gt;parse_slice_header = rv30_parse_slice_header;
+    r-&gt;decode_intra_types = rv30_decode_intra_types;
+    r-&gt;decode_mb_info     = rv30_decode_mb_info;
+    r-&gt;luma_dc_quant_i = rv30_luma_dc_quant;
+    r-&gt;luma_dc_quant_p = rv30_luma_dc_quant;
+    return 0;
+}
+
+AVCodec rv30_decoder = {
+    &quot;rv30&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_RV30,
+    sizeof(RV34DecContext),
+    rv30_decode_init,
+    NULL,
+    ff_rv34_decode_end,
+    ff_rv34_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealVideo 3.0&quot;),
+};

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30data.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30data.h	2008-09-15 14:12:05 UTC (rev 27562)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rv30data.h	2008-09-15 14:12:50 UTC (rev 27563)
@@ -0,0 +1,174 @@
+/*
+ * RealVideo 3 decoder
+ * copyright (c) 2007 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rv30data.h
+ * miscellaneous RV30 tables
+ */
+
+#ifndef FFMPEG_RV30DATA_H
+#define FFMPEG_RV30DATA_H
+
+#include &lt;stdint.h&gt;
+
+/** DC quantizer mapping for RV30 */
+static const uint8_t rv30_luma_dc_quant[32] = {
+     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+    16, 17, 18, 19, 20, 21, 22, 22, 22, 23, 23, 23, 24, 24, 25, 25
+};
+
+/**
+ * This table is used for storing the differences
+ * between the predicted and the real intra type.
+ */
+static const uint8_t rv30_itype_code[9*9*2] = {
+    0, 0, 0, 1, 1, 0, 1, 1, 0, 2, 2, 0, 0, 3, 3, 0, 1, 2,
+    2, 1, 0, 4, 4, 0, 3, 1, 1, 3, 0, 5, 5, 0, 2, 2, 1, 4,
+    4, 1, 0, 6, 3, 2, 1, 5, 2, 3, 5, 1, 6, 0, 0, 7, 4, 2,
+    2, 4, 3, 3, 6, 1, 1, 6, 7, 0, 0, 8, 5, 2, 4, 3, 2, 5,
+    3, 4, 1, 7, 4, 4, 7, 1, 8, 0, 6, 2, 3, 5, 5, 3, 2, 6,
+    1, 8, 2, 7, 7, 2, 8, 1, 5, 4, 4, 5, 3, 6, 6, 3, 8, 2,
+    4, 6, 5, 5, 6, 4, 2, 8, 7, 3, 3, 7, 6, 5, 5, 6, 7, 4,
+    4, 7, 8, 3, 3, 8, 7, 5, 8, 4, 5, 7, 4, 8, 6, 6, 7, 6,
+    5, 8, 8, 5, 6, 7, 8, 6, 7, 7, 6, 8, 8, 7, 7, 8, 8, 8,
+};
+
+/**
+ * This table is used for retrieving the current intra type
+ * based on its neighbors and adjustment provided by
+ * code read and decoded before.
+ *
+ * This is really a three-dimensional matrix with dimensions
+ * [-1..9][-1..9][0..9]. The first and second coordinates are
+ * detemined by the top and left neighbors (-1 if unavailable).
+ */
+static const uint8_t rv30_itype_from_context[900] = {
+    0, 9, 9, 9, 9, 9, 9, 9, 9,
+    0, 2, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    2, 0, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+    9, 9, 9, 9, 9, 9, 9, 9, 9,
+
+    0, 1, 9, 9, 9, 9, 9, 9, 9,
+    0, 2, 1, 6, 4, 8, 5, 7, 3,
+    1, 0, 2, 6, 5, 4, 3, 8, 7,
+    2, 8, 0, 1, 7, 4, 3, 6, 5,
+    2, 0, 1, 3, 8, 5, 4, 7, 6,
+    2, 0, 1, 4, 6, 7, 8, 3, 5,
+    0, 1, 5, 2, 6, 3, 8, 4, 7,
+    0, 1, 6, 2, 4, 7, 5, 8, 3,
+    2, 7, 0, 1, 4, 8, 6, 3, 5,
+    2, 8, 0, 1, 7, 3, 4, 5, 6,
+
+    1, 0, 9, 9, 9, 9, 9, 9, 9,
+    1, 2, 5, 6, 3, 0, 4, 8, 7,
+    1, 6, 2, 5, 3, 0, 4, 8, 7,
+    2, 1, 7, 6, 8, 3, 5, 0, 4,
+    1, 2, 5, 3, 6, 8, 4, 7, 0,
+    1, 6, 2, 0, 4, 5, 8, 7, 3,

[... truncated: 7139 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011872.html">[Haiku-commits] r27562 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011874.html">[Haiku-commits] r27564 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11873">[ date ]</a>
              <a href="thread.html#11873">[ thread ]</a>
              <a href="subject.html#11873">[ subject ]</a>
              <a href="author.html#11873">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
