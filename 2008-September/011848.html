<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27538 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27538%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale&In-Reply-To=%3C200809151352.m8FDqpLe031497%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011847.html">
   <LINK REL="Next"  HREF="011938.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27538 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27538%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale&In-Reply-To=%3C200809151352.m8FDqpLe031497%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27538 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 15:52:51 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011847.html">[Haiku-commits] r27537 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
        <LI>Next message: <A HREF="011938.html">[Haiku-commits] r27538 - haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11848">[ date ]</a>
              <a href="thread.html#11848">[ thread ]</a>
              <a href="subject.html#11848">[ subject ]</a>
              <a href="author.html#11848">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 15:52:45 +0200 (Mon, 15 Sep 2008)
New Revision: 27538
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27538&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27538&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/config.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/cs_test.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/internal_bfin.S
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb_template.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale-example.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale_altivec_template.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale_avoption.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale_bfin.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale_internal.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/swscale_template.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb_bfin.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb_mlib.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb_template.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/yuv2rgb_vis.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile	2008-09-15 13:52:29 UTC (rev 27537)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile	2008-09-15 13:52:45 UTC (rev 27538)
@@ -0,0 +1,18 @@
+SubDir HAIKU_TOP src add-ons media plugins avcodec libswscale ;
+
+SubDirHdrs [ FDirName $(SUBDIR) ../libavutil ] ;
+SubDirHdrs [ FDirName $(SUBDIR) ../libavcodec ] ;
+
+# filter warnings we don't want here
+TARGET_WARNING_CCFLAGS = [ FFilter $(TARGET_WARNING_CCFLAGS)
+	: -Wall -Wmissing-prototypes -Wsign-compare -Wpointer-arith ] ;
+
+SubDirCcFlags -fomit-frame-pointer -DPIC ;
+SubDirCcFlags -DHAVE_AV_CONFIG_H=1 ;
+
+StaticLibrary libswscale.a :
+	rgb2rgb.c
+	swscale.c
+	swscale_avoption.c
+	yuv2rgb.c
+;

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/config.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/config.h	2008-09-15 13:52:29 UTC (rev 27537)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/config.h	2008-09-15 13:52:45 UTC (rev 27538)
@@ -0,0 +1 @@
+link /boot/home/programming/haiku/src/add-ons/media/plugins/avcodec/libavcodec/config.h
\ No newline at end of file


Property changes on: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/config.h
___________________________________________________________________
Name: svn:special
   + *

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/cs_test.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/cs_test.c	2008-09-15 13:52:29 UTC (rev 27537)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/cs_test.c	2008-09-15 13:52:45 UTC (rev 27538)
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2002 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;              /* for memset() */
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;inttypes.h&gt;
+
+#include &quot;swscale.h&quot;
+#include &quot;rgb2rgb.h&quot;
+
+#define SIZE 1000
+#define srcByte 0x55
+#define dstByte 0xBB
+
+#define FUNC(s,d,n) {s,d,#n,n}
+
+static int cpu_caps;
+
+static char *args_parse(int argc, char *argv[])
+{
+    int o;
+
+    while ((o = getopt(argc, argv, &quot;m23&quot;)) != -1) {
+        switch (o) {
+            case 'm':
+                cpu_caps |= SWS_CPU_CAPS_MMX;
+                break;
+            case '2':
+                cpu_caps |= SWS_CPU_CAPS_MMX2;
+                break;
+            case '3':
+                cpu_caps |= SWS_CPU_CAPS_3DNOW;
+                break;
+            default:
+                av_log(NULL, AV_LOG_ERROR, &quot;Unknown option %c\n&quot;, o);
+        }
+    }
+
+    return argv[optind];
+}
+
+int main(int argc, char **argv)
+{
+    int i, funcNum;
+    uint8_t *srcBuffer= (uint8_t*)av_malloc(SIZE);
+    uint8_t *dstBuffer= (uint8_t*)av_malloc(SIZE);
+    int failedNum=0;
+    int passedNum=0;
+
+    av_log(NULL, AV_LOG_INFO, &quot;memory corruption test ...\n&quot;);
+    args_parse(argc, argv);
+    av_log(NULL, AV_LOG_INFO, &quot;CPU capabilities forced to %x\n&quot;, cpu_caps);
+    sws_rgb2rgb_init(cpu_caps);
+
+    for(funcNum=0; ; funcNum++){
+        struct func_info_s {
+            int src_bpp;
+            int dst_bpp;
+            char *name;
+            void (*func)(const uint8_t *src, uint8_t *dst, long src_size);
+        } func_info[] = {
+            FUNC(2, 2, rgb15to16),
+            FUNC(2, 3, rgb15to24),
+            FUNC(2, 4, rgb15to32),
+            FUNC(2, 3, rgb16to24),
+            FUNC(2, 4, rgb16to32),
+            FUNC(3, 2, rgb24to15),
+            FUNC(3, 2, rgb24to16),
+            FUNC(3, 4, rgb24to32),
+            FUNC(4, 2, rgb32to15),
+            FUNC(4, 2, rgb32to16),
+            FUNC(4, 3, rgb32to24),
+            FUNC(2, 2, rgb16to15),
+            FUNC(2, 2, rgb15tobgr15),
+            FUNC(2, 2, rgb15tobgr16),
+            FUNC(2, 3, rgb15tobgr24),
+            FUNC(2, 4, rgb15tobgr32),
+            FUNC(2, 2, rgb16tobgr15),
+            FUNC(2, 2, rgb16tobgr16),
+            FUNC(2, 3, rgb16tobgr24),
+            FUNC(2, 4, rgb16tobgr32),
+            FUNC(3, 2, rgb24tobgr15),
+            FUNC(3, 2, rgb24tobgr16),
+            FUNC(3, 3, rgb24tobgr24),
+            FUNC(3, 4, rgb24tobgr32),
+            FUNC(4, 2, rgb32tobgr15),
+            FUNC(4, 2, rgb32tobgr16),
+            FUNC(4, 3, rgb32tobgr24),
+            FUNC(4, 4, rgb32tobgr32),
+            FUNC(0, 0, NULL)
+        };
+        int width;
+        int failed=0;
+        int srcBpp=0;
+        int dstBpp=0;
+
+        if (!func_info[funcNum].func) break;
+
+        av_log(NULL, AV_LOG_INFO,&quot;.&quot;);
+        memset(srcBuffer, srcByte, SIZE);
+
+        for(width=63; width&gt;0; width--){
+            int dstOffset;
+            for(dstOffset=128; dstOffset&lt;196; dstOffset+=4){
+                int srcOffset;
+                memset(dstBuffer, dstByte, SIZE);
+
+                for(srcOffset=128; srcOffset&lt;196; srcOffset+=4){
+                    uint8_t *src= srcBuffer+srcOffset;
+                    uint8_t *dst= dstBuffer+dstOffset;
+                    char *name=NULL;
+
+                    if(failed) break; //don't fill the screen with shit ...
+
+                    srcBpp = func_info[funcNum].src_bpp;
+                    dstBpp = func_info[funcNum].dst_bpp;
+                    name   = func_info[funcNum].name;
+
+                    func_info[funcNum].func(src, dst, width*srcBpp);
+
+                    if(!srcBpp) break;
+
+                    for(i=0; i&lt;SIZE; i++){
+                        if(srcBuffer[i]!=srcByte){
+                            av_log(NULL, AV_LOG_INFO, &quot;src damaged at %d w:%d src:%d dst:%d %s\n&quot;,
+                                   i, width, srcOffset, dstOffset, name);
+                            failed=1;
+                            break;
+                        }
+                    }
+                    for(i=0; i&lt;dstOffset; i++){
+                        if(dstBuffer[i]!=dstByte){
+                            av_log(NULL, AV_LOG_INFO, &quot;dst damaged at %d w:%d src:%d dst:%d %s\n&quot;,
+                                   i, width, srcOffset, dstOffset, name);
+                            failed=1;
+                            break;
+                        }
+                    }
+                    for(i=dstOffset + width*dstBpp; i&lt;SIZE; i++){
+                        if(dstBuffer[i]!=dstByte){
+                            av_log(NULL, AV_LOG_INFO, &quot;dst damaged at %d w:%d src:%d dst:%d %s\n&quot;,
+                                   i, width, srcOffset, dstOffset, name);
+                            failed=1;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if(failed) failedNum++;
+        else if(srcBpp) passedNum++;
+    }
+
+    av_log(NULL, AV_LOG_INFO, &quot;\n%d converters passed, %d converters randomly overwrote memory\n&quot;, passedNum, failedNum);
+    return failedNum;
+}

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/internal_bfin.S
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/internal_bfin.S	2008-09-15 13:52:29 UTC (rev 27537)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/internal_bfin.S	2008-09-15 13:52:45 UTC (rev 27538)
@@ -0,0 +1,606 @@
+/*
+ * Copyright (C) 2007 Marc Hoffman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marc.hoffman at analog.com</A>&gt;
+ *                    April 20, 2007
+ *
+ * Blackfin video color space converter operations
+ * convert I420 YV12 to RGB in various formats
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+/*
+YUV420 to RGB565 conversion. This routine takes a YUV 420 planar macroblock
+and converts it to RGB565. R:5 bits, G:6 bits, B:5 bits.. packed into shorts.
+
+
+The following calculation is used for the conversion:
+
+  r = clipz((y-oy)*cy  + crv*(v-128))
+  g = clipz((y-oy)*cy  + cgv*(v-128) + cgu*(u-128))
+  b = clipz((y-oy)*cy  + cbu*(u-128))
+
+y,u,v are prescaled by a factor of 4 i.e. left-shifted to gain precision.
+
+
+New factorization to eliminate the truncation error which was
+occurring due to the byteop3p.
+
+
+1) Use the bytop16m to subtract quad bytes we use this in U8 this
+ then so the offsets need to be renormalized to 8bits.
+
+2) Scale operands up by a factor of 4 not 8 because Blackfin
+   multiplies include a shift.
+
+3) Compute into the accumulators cy*yx0, cy*yx1.
+
+4) Compute each of the linear equations:
+     r = clipz((y - oy) * cy  + crv * (v - 128))
+
+     g = clipz((y - oy) * cy  + cgv * (v - 128) + cgu * (u - 128))
+
+     b = clipz((y - oy) * cy  + cbu * (u - 128))
+
+   Reuse of the accumulators requires that we actually multiply
+   twice once with addition and the second time with a subtraction.
+
+   Because of this we need to compute the equations in the order R B
+   then G saving the writes for B in the case of 24/32 bit color
+   formats.
+
+   API: yuv2rgb_kind (uint8_t *Y, uint8_t *U, uint8_t *V, int *out,
+                      int dW, uint32_t *coeffs);
+
+       A          B
+       ---        ---
+       i2 = cb    i3 = cr
+       i1 = coeff i0 = y
+
+Where coeffs have the following layout in memory.
+
+uint32_t oy,oc,zero,cy,crv,rmask,cbu,bmask,cgu,cgv;
+
+coeffs is a pointer to oy.
+
+The {rgb} masks are only utilized by the 565 packing algorithm. Note the data
+replication is used to simplify the internal algorithms for the dual Mac
+architecture of BlackFin.
+
+All routines are exported with _ff_bfin_ as a symbol prefix.
+
+Rough performance gain compared against -O3:
+
+2779809/1484290 187.28%
+
+which translates to ~33c/pel to ~57c/pel for the reference vs 17.5
+c/pel for the optimized implementations. Not sure why there is such a
+huge variation on the reference codes on Blackfin I guess it must have
+to do with the memory system.
+*/
+
+#define mL3 .text
+#ifdef __FDPIC__
+#define mL1 .l1.text
+#else
+#define mL1 mL3
+#endif
+#define MEM mL1
+
+#define DEFUN(fname,where,interface) \
+        .section where;              \
+        .global _ff_bfin_ ## fname;  \
+        .type _ff_bfin_ ## fname, STT_FUNC; \
+        .align 8;                    \
+        _ff_bfin_ ## fname
+
+#define DEFUN_END(fname) \
+        .size _ff_bfin_ ## fname, . - _ff_bfin_ ## fname
+
+
+.text
+
+#define COEFF_LEN        11*4
+#define COEFF_REL_CY_OFF 4*4
+
+#define ARG_OUT   20
+#define ARG_W     24
+#define ARG_COEFF 28
+
+DEFUN(yuv2rgb565_line,MEM,
+   (uint8_t *Y, uint8_t *U, uint8_t *V, int *out, int dW, uint32_t *coeffs)):
+        link 0;
+        [--sp] = (r7:4);
+        p1 = [fp+ARG_OUT];
+        r3 = [fp+ARG_W];
+
+        i0 = r0;
+        i2 = r1;
+        i3 = r2;
+
+        r0 = [fp+ARG_COEFF];
+        i1 = r0;
+        b1 = i1;
+        l1 = COEFF_LEN;
+        m0 = COEFF_REL_CY_OFF;
+        p0 = r3;
+
+        r0   = [i0++];         // 2Y
+        r1.l = w[i2++];        // 2u
+        r1.h = w[i3++];        // 2v
+        p0 = p0&gt;&gt;2;
+
+        lsetup (.L0565, .L1565) lc0 = p0;
+
+        /*
+           uint32_t oy,oc,zero,cy,crv,rmask,cbu,bmask,cgu,cgv
+           r0 -- used to load 4ys
+           r1 -- used to load 2us,2vs
+           r4 -- y3,y2
+           r5 -- y1,y0
+           r6 -- u1,u0
+           r7 -- v1,v0
+        */
+                                                              r2=[i1++]; // oy
+.L0565:
+        /*
+        rrrrrrrr gggggggg bbbbbbbb
+         5432109876543210
+                    bbbbb &gt;&gt;3
+              gggggggg    &lt;&lt;3
+         rrrrrrrr         &lt;&lt;8
+         rrrrrggggggbbbbb
+        */
+        (r4,r5) = byteop16m (r1:0, r3:2)                   || r3=[i1++]; // oc
+        (r7,r6) = byteop16m (r1:0, r3:2) (r);
+        r5 = r5 &lt;&lt; 2 (v);                                                // y1,y0
+        r4 = r4 &lt;&lt; 2 (v);                                                // y3,y2
+        r6 = r6 &lt;&lt; 2 (v)                                   || r0=[i1++]; // u1,u0, r0=zero
+        r7 = r7 &lt;&lt; 2 (v)                                   || r1=[i1++]; // v1,v0  r1=cy
+        /* Y' = y*cy */
+        a1 = r1.h*r5.h, a0 = r1.l*r5.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+                a1 -= r1.h*r7.l,          a0 -= r1.l*r7.l  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2 = r2 &gt;&gt; 3 (v);
+        r3 = r2 &amp; r5;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.l), r2.l = (a0 += r1.l*r6.l);
+                a1 -= r1.h*r6.l,          a0 -= r1.l*r6.l  || r5=[i1++]; // bmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+        r2 = r2 &lt;&lt; 8 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.l,          a0 += r1.l*r6.l  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r5=[i1++m0]; // gmask
+        r2 = r2 &lt;&lt; 3 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+        [p1++]=r3                                          || r1=[i1++]; // cy
+
+        /* Y' = y*cy */
+
+        a1 = r1.h*r4.h, a0 = r1.l*r4.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h);
+                a1 -= r1.h*r7.h,          a0 -= r1.l*r7.h  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2 = r2 &gt;&gt; 3 (v);
+        r3 = r2 &amp; r5;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.h), r2.l = (a0 += r1.l*r6.h);
+                a1 -= r1.h*r6.h,          a0 -= r1.l*r6.h  || r5=[i1++]; // bmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+        r2 = r2 &lt;&lt; 8 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.h,          a0 += r1.l*r6.h  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h) || r5=[i1++]; // gmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r0   =  [i0++];        // 2Y
+        r2 = r2 &lt;&lt; 3 (v)                                   || r1.l = w[i2++];        // 2u
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+        [p1++]=r3                                          || r1.h = w[i3++];        // 2v
+.L1565:                                                       r2=[i1++]; // oy
+
+        l1 = 0;
+
+        (r7:4) = [sp++];
+        unlink;
+        rts;
+DEFUN_END(yuv2rgb565_line)
+
+DEFUN(yuv2rgb555_line,MEM,
+   (uint8_t *Y, uint8_t *U, uint8_t *V, int *out, int dW, uint32_t *coeffs)):
+        link 0;
+        [--sp] = (r7:4);
+        p1 = [fp+ARG_OUT];
+        r3 = [fp+ARG_W];
+
+        i0 = r0;
+        i2 = r1;
+        i3 = r2;
+
+        r0 = [fp+ARG_COEFF];
+        i1 = r0;
+        b1 = i1;
+        l1 = COEFF_LEN;
+        m0 = COEFF_REL_CY_OFF;
+        p0 = r3;
+
+        r0   = [i0++];         // 2Y
+        r1.l = w[i2++];        // 2u
+        r1.h = w[i3++];        // 2v
+        p0 = p0&gt;&gt;2;
+
+        lsetup (.L0555, .L1555) lc0 = p0;
+
+        /*
+           uint32_t oy,oc,zero,cy,crv,rmask,cbu,bmask,cgu,cgv
+           r0 -- used to load 4ys
+           r1 -- used to load 2us,2vs
+           r4 -- y3,y2
+           r5 -- y1,y0
+           r6 -- u1,u0
+           r7 -- v1,v0
+        */
+                                                              r2=[i1++]; // oy
+.L0555:
+        /*
+        rrrrrrrr gggggggg bbbbbbbb
+         5432109876543210
+                    bbbbb &gt;&gt;3
+               gggggggg   &lt;&lt;2
+          rrrrrrrr        &lt;&lt;7
+         xrrrrrgggggbbbbb
+        */
+
+        (r4,r5) = byteop16m (r1:0, r3:2)                   || r3=[i1++]; // oc
+        (r7,r6) = byteop16m (r1:0, r3:2) (r);
+        r5 = r5 &lt;&lt; 2 (v);                                                // y1,y0
+        r4 = r4 &lt;&lt; 2 (v);                                                // y3,y2
+        r6 = r6 &lt;&lt; 2 (v)                                   || r0=[i1++]; // u1,u0, r0=zero
+        r7 = r7 &lt;&lt; 2 (v)                                   || r1=[i1++]; // v1,v0  r1=cy
+        /* Y' = y*cy */
+        a1 = r1.h*r5.h, a0 = r1.l*r5.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+                a1 -= r1.h*r7.l,          a0 -= r1.l*r7.l  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2 = r2 &gt;&gt; 3 (v);
+        r3 = r2 &amp; r5;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.l), r2.l = (a0 += r1.l*r6.l);
+                a1 -= r1.h*r6.l,          a0 -= r1.l*r6.l  || r5=[i1++]; // bmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+        r2 = r2 &lt;&lt; 7 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.l,          a0 += r1.l*r6.l  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r5=[i1++m0]; // gmask
+        r2 = r2 &lt;&lt; 2 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+        [p1++]=r3                                          || r1=[i1++]; // cy
+
+        /* Y' = y*cy */
+
+        a1 = r1.h*r4.h, a0 = r1.l*r4.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h);
+                a1 -= r1.h*r7.h,          a0 -= r1.l*r7.h  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2 = r2 &gt;&gt; 3 (v);
+        r3 = r2 &amp; r5;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.h), r2.l = (a0 += r1.l*r6.h);
+                a1 -= r1.h*r6.h,          a0 -= r1.l*r6.h  || r5=[i1++]; // bmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+        r2 = r2 &lt;&lt; 7 (v);
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.h,          a0 += r1.l*r6.h  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h) || r5=[i1++]; // gmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r0=[i0++];     // 4Y
+        r2 = r2 &lt;&lt; 2 (v)                                   || r1.l=w[i2++];  // 2u
+        r2 = r2 &amp; r5;
+        r3 = r3 | r2;
+        [p1++]=r3                                          || r1.h=w[i3++]; // 2v
+
+.L1555:                                                       r2=[i1++]; // oy
+
+        l1 = 0;
+
+        (r7:4) = [sp++];
+        unlink;
+        rts;
+DEFUN_END(yuv2rgb555_line)
+
+DEFUN(yuv2rgb24_line,MEM,
+   (uint8_t *Y, uint8_t *U, uint8_t *V, int *out, int dW, uint32_t *coeffs)):
+        link 0;
+        [--sp] = (r7:4);
+        p1 = [fp+ARG_OUT];
+        r3 = [fp+ARG_W];
+        p2 = p1;
+        p2 += 3;
+
+        i0 = r0;
+        i2 = r1;
+        i3 = r2;
+
+        r0 = [fp+ARG_COEFF]; // coeff buffer
+        i1 = r0;
+        b1 = i1;
+        l1 = COEFF_LEN;
+        m0 = COEFF_REL_CY_OFF;
+        p0 = r3;
+
+        r0   = [i0++];         // 2Y
+        r1.l = w[i2++];        // 2u
+        r1.h = w[i3++];        // 2v
+        p0 = p0&gt;&gt;2;
+
+        lsetup (.L0888, .L1888) lc0 = p0;
+
+        /*
+           uint32_t oy,oc,zero,cy,crv,rmask,cbu,bmask,cgu,cgv
+           r0 -- used to load 4ys
+           r1 -- used to load 2us,2vs
+           r4 -- y3,y2
+           r5 -- y1,y0
+           r6 -- u1,u0
+           r7 -- v1,v0
+        */
+                                                              r2=[i1++]; // oy
+.L0888:
+        (r4,r5) = byteop16m (r1:0, r3:2)                   || r3=[i1++]; // oc
+        (r7,r6) = byteop16m (r1:0, r3:2) (r);
+        r5 = r5 &lt;&lt; 2 (v);               // y1,y0
+        r4 = r4 &lt;&lt; 2 (v);               // y3,y2
+        r6 = r6 &lt;&lt; 2 (v) || r0=[i1++];  // u1,u0, r0=zero
+        r7 = r7 &lt;&lt; 2 (v) || r1=[i1++];  // v1,v0  r1=cy
+
+        /* Y' = y*cy */
+        a1 = r1.h*r5.h, a0 = r1.l*r5.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+                a1 -= r1.h*r7.l,          a0 -= r1.l*r7.l  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2=r2&gt;&gt;16 || B[p1++]=r2;
+                     B[p2++]=r2;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.l), r2.l = (a0 += r1.l*r6.l);
+                a1 -= r1.h*r6.l,          a0 -= r1.l*r6.l  || r5=[i1++]; // bmask
+        r3 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.l,          a0 += r1.l*r6.l  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.l), r2.l = (a0 += r1.l*r7.l);
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r5=[i1++m0]; // gmask, oy,cy,zero
+
+        r2=r2&gt;&gt;16 || B[p1++]=r2;
+                     B[p2++]=r2;
+
+        r3=r3&gt;&gt;16 || B[p1++]=r3;
+                     B[p2++]=r3                            || r1=[i1++]; // cy
+
+        p1+=3;
+        p2+=3;
+        /* Y' = y*cy */
+        a1 = r1.h*r4.h, a0 = r1.l*r4.l                     || r1=[i1++]; // crv
+
+        /* R = Y+ crv*(Cr-128) */
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h);
+                a1 -= r1.h*r7.h,          a0 -= r1.l*r7.h  || r5=[i1++]; // rmask
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cbu
+        r2=r2&gt;&gt;16 || B[p1++]=r2;
+        B[p2++]=r2;
+
+        /* B = Y+ cbu*(Cb-128) */
+        r2.h = (a1 += r1.h*r6.h), r2.l = (a0 += r1.l*r6.h);
+                a1 -= r1.h*r6.h,          a0 -= r1.l*r6.h  || r5=[i1++]; // bmask
+        r3 = byteop3p(r3:2, r1:0)(LO)                      || r1=[i1++]; // cgu
+
+        /* G = Y+ cgu*(Cb-128)+cgv*(Cr-128) */
+                a1 += r1.h*r6.h,          a0 += r1.l*r6.h  || r1=[i1++]; // cgv
+        r2.h = (a1 += r1.h*r7.h), r2.l = (a0 += r1.l*r7.h);
+        r2 = byteop3p(r3:2, r1:0)(LO)                      || r5=[i1++]; // gmask
+        r2=r2&gt;&gt;16 || B[p1++]=r2 || r0 = [i0++];    // 4y
+                     B[p2++]=r2 || r1.l = w[i2++]; // 2u
+        r3=r3&gt;&gt;16 || B[p1++]=r3 || r1.h = w[i3++]; // 2v
+                     B[p2++]=r3 || r2=[i1++];      // oy
+
+        p1+=3;
+.L1888: p2+=3;
+
+        l1 = 0;
+
+        (r7:4) = [sp++];
+        unlink;
+        rts;
+DEFUN_END(yuv2rgb24_line)
+
+
+
+#define ARG_vdst        20
+#define ARG_width       24
+#define ARG_height      28
+#define ARG_lumStride   32
+#define ARG_chromStride 36
+#define ARG_srcStride   40
+
+DEFUN(uyvytoyv12, mL3,  (const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                         long width, long height,
+                         long lumStride, long chromStride, long srcStride)):
+        link 0;
+        [--sp] = (r7:4,p5:4);
+
+        p0 = r1;       // Y top even
+
+        i2 = r2; // *u
+        r2 = [fp + ARG_vdst];
+        i3 = r2; // *v
+
+        r1 = [fp + ARG_srcStride];
+        r2 = r0 + r1;
+        r1 += -8;  // i0,i1 is pre read need to correct
+        m0 = r1;
+
+        i0 = r0;  // uyvy_T even
+        i1 = r2;  // uyvy_B odd
+
+        p2 = [fp + ARG_lumStride];
+        p1 = p0 + p2;  // Y bot odd
+
+        p5 = [fp + ARG_width];
+        p4 = [fp + ARG_height];
+        r0 = p5;
+        p4 = p4 &gt;&gt; 1;
+        p5 = p5 &gt;&gt; 2;
+
+        r2 = [fp + ARG_chromStride];
+        r0 = r0 &gt;&gt; 1;
+        r2 = r2 - r0;
+        m1 = r2;
+
+        /*   I0,I1 - src input line pointers
+         *   p0,p1 - luma output line pointers
+         *   I2    - dstU
+         *   I3    - dstV
+         */
+
+        lsetup (0f, 1f) lc1 = p4;   // H/2
+0:        r0 = [i0++] || r2 = [i1++];
+          r1 = [i0++] || r3 = [i1++];
+          r4 = byteop1p(r1:0, r3:2);
+          r5 = byteop1p(r1:0, r3:2) (r);
+          lsetup (2f, 3f) lc0 = p5; // W/4
+2:          r0 = r0 &gt;&gt; 8(v);
+            r1 = r1 &gt;&gt; 8(v);
+            r2 = r2 &gt;&gt; 8(v);
+            r3 = r3 &gt;&gt; 8(v);
+            r0 = bytepack(r0, r1);
+            r2 = bytepack(r2, r3)         ||  [p0++] = r0;    // yyyy
+            r6 = pack(r5.l, r4.l)         ||  [p1++] = r2;    // yyyy
+            r7 = pack(r5.h, r4.h)         ||  r0 = [i0++] || r2 = [i1++];
+            r6 = bytepack(r6, r7)         ||  r1 = [i0++] || r3 = [i1++];
+            r4 = byteop1p(r1:0, r3:2)     ||  w[i2++] = r6.l; // uu
+3:          r5 = byteop1p(r1:0, r3:2) (r) ||  w[i3++] = r6.h; // vv
+
+          i0 += m0;
+          i1 += m0;
+          i2 += m1;
+          i3 += m1;
+          p0 = p0 + p2;
+1:        p1 = p1 + p2;
+
+        (r7:4,p5:4) = [sp++];
+        unlink;
+        rts;
+DEFUN_END(uyvytoyv12)
+
+DEFUN(yuyvtoyv12, mL3,  (const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                         long width, long height,
+                         long lumStride, long chromStride, long srcStride)):
+        link 0;
+        [--sp] = (r7:4,p5:4);
+
+        p0 = r1;       // Y top even
+
+        i2 = r2; // *u
+        r2 = [fp + ARG_vdst];
+        i3 = r2; // *v
+
+        r1 = [fp + ARG_srcStride];
+        r2 = r0 + r1;
+        r1 += -8;  // i0,i1 is pre read need to correct
+        m0 = r1;
+
+        i0 = r0;  // uyvy_T even
+        i1 = r2;  // uyvy_B odd
+
+        p2 = [fp + ARG_lumStride];
+        p1 = p0 + p2;  // Y bot odd
+
+        p5 = [fp + ARG_width];
+        p4 = [fp + ARG_height];
+        r0 = p5;
+        p4 = p4 &gt;&gt; 1;
+        p5 = p5 &gt;&gt; 2;
+
+        r2 = [fp + ARG_chromStride];
+        r0 = r0 &gt;&gt; 1;
+        r2 = r2 - r0;
+        m1 = r2;
+
+        /*   I0,I1 - src input line pointers
+         *   p0,p1 - luma output line pointers
+         *   I2    - dstU
+         *   I3    - dstV
+         */
+
+        lsetup (0f, 1f) lc1 = p4;   // H/2
+0:        r0 = [i0++] || r2 = [i1++];
+          r1 = [i0++] || r3 = [i1++];
+          r4 = bytepack(r0, r1);
+          r5 = bytepack(r2, r3);
+          lsetup (2f, 3f) lc0 = p5; // W/4
+2:          r0 = r0 &gt;&gt; 8(v) || [p0++] = r4;  // yyyy-even
+            r1 = r1 &gt;&gt; 8(v) || [p1++] = r5;  // yyyy-odd
+            r2 = r2 &gt;&gt; 8(v);
+            r3 = r3 &gt;&gt; 8(v);
+            r4 = byteop1p(r1:0, r3:2);
+            r5 = byteop1p(r1:0, r3:2) (r);
+            r6 = pack(r5.l, r4.l);
+            r7 = pack(r5.h, r4.h)         ||  r0 = [i0++] || r2 = [i1++];
+            r6 = bytepack(r6, r7)         ||  r1 = [i0++] || r3 = [i1++];
+            r4 = bytepack(r0, r1)         ||  w[i2++] = r6.l; // uu
+3:          r5 = bytepack(r2, r3)         ||  w[i3++] = r6.h; // vv
+
+          i0 += m0;
+          i1 += m0;
+          i2 += m1;
+          i3 += m1;
+          p0 = p0 + p2;
+1:        p1 = p1 + p2;
+
+        (r7:4,p5:4) = [sp++];
+        unlink;
+        rts;
+DEFUN_END(yuyvtoyv12)

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb.c	2008-09-15 13:52:29 UTC (rev 27537)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/rgb2rgb.c	2008-09-15 13:52:45 UTC (rev 27538)
@@ -0,0 +1,534 @@
+/*
+ * software RGB to RGB converter
+ * pluralize by software PAL8 to RGB converter
+ *              software YUV to YUV converter
+ *              software YUV to RGB converter
+ * Written by Nick Kurshev.
+ * palette &amp; YUV &amp; runtime CPU stuff by Michael (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ * The C code (not assembly, MMX, ...) of this file can be used
+ * under the LGPL license.
+ */
+#include &lt;inttypes.h&gt;
+#include &quot;config.h&quot;
+#include &quot;x86_cpu.h&quot;
+#include &quot;bswap.h&quot;
+#include &quot;rgb2rgb.h&quot;
+#include &quot;swscale.h&quot;
+#include &quot;swscale_internal.h&quot;
+
+#define FAST_BGR2YV12 // use 7-bit instead of 15-bit coefficients
+
+void (*rgb24to32)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb15to32)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb16to32)(const uint8_t *src, uint8_t *dst, long src_size);
+//void (*rgb24tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb24tobgr15)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32tobgr32)(const uint8_t *src, uint8_t *dst, long src_size);
+//void (*rgb32tobgr24)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32tobgr16)(const uint8_t *src, uint8_t *dst, long src_size);
+void (*rgb32tobgr15)(const uint8_t *src, uint8_t *dst, long src_size);
+
+void (*yv12toyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
+                   long width, long height,
+                   long lumStride, long chromStride, long dstStride);
+void (*yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
+                   long width, long height,
+                   long lumStride, long chromStride, long dstStride);
+void (*yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
+                      long width, long height,
+                      long lumStride, long chromStride, long dstStride);
+void (*yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                   long width, long height,
+                   long lumStride, long chromStride, long srcStride);
+void (*rgb24toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,
+                    long width, long height,
+                    long lumStride, long chromStride, long srcStride);
+void (*planar2x)(const uint8_t *src, uint8_t *dst, long width, long height,
+                 long srcStride, long dstStride);
+void (*interleaveBytes)(uint8_t *src1, uint8_t *src2, uint8_t *dst,
+                        long width, long height, long src1Stride,
+                        long src2Stride, long dstStride);
+void (*vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,
+                    uint8_t *dst1, uint8_t *dst2,
+                    long width, long height,
+                    long srcStride1, long srcStride2,
+                    long dstStride1, long dstStride2);
+void (*yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,
+                     uint8_t *dst,
+                     long width, long height,
+                     long srcStride1, long srcStride2,
+                     long srcStride3, long dstStride);
+
+#if defined(ARCH_X86) &amp;&amp; defined(CONFIG_GPL)
+DECLARE_ASM_CONST(8, uint64_t, mmx_null)     = 0x0000000000000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mmx_one)      = 0xFFFFFFFFFFFFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32b)      = 0x000000FF000000FFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32g)      = 0x0000FF000000FF00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32r)      = 0x00FF000000FF0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask32)       = 0x00FFFFFF00FFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3216br)   = 0x00F800F800F800F8ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3216g)    = 0x0000FC000000FC00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask3215g)    = 0x0000F8000000F800ULL;
+DECLARE_ASM_CONST(8, uint64_t, mul3216)      = 0x2000000420000004ULL;
+DECLARE_ASM_CONST(8, uint64_t, mul3215)      = 0x2000000820000008ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24b)      = 0x00FF0000FF0000FFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24g)      = 0xFF0000FF0000FF00ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24r)      = 0x0000FF0000FF0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24l)      = 0x0000000000FFFFFFULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24h)      = 0x0000FFFFFF000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hh)     = 0xffff000000000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hhh)    = 0xffffffff00000000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask24hhhh)   = 0xffffffffffff0000ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15b)      = 0x001F001F001F001FULL; /* 00000000 00011111  xxB */
+DECLARE_ASM_CONST(8, uint64_t, mask15rg)     = 0x7FE07FE07FE07FE0ULL; /* 01111111 11100000  RGx */
+DECLARE_ASM_CONST(8, uint64_t, mask15s)      = 0xFFE0FFE0FFE0FFE0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15g)      = 0x03E003E003E003E0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask15r)      = 0x7C007C007C007C00ULL;
+#define mask16b mask15b
+DECLARE_ASM_CONST(8, uint64_t, mask16g)      = 0x07E007E007E007E0ULL;
+DECLARE_ASM_CONST(8, uint64_t, mask16r)      = 0xF800F800F800F800ULL;
+DECLARE_ASM_CONST(8, uint64_t, red_16mask)   = 0x0000f8000000f800ULL;
+DECLARE_ASM_CONST(8, uint64_t, green_16mask) = 0x000007e0000007e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, blue_16mask)  = 0x0000001f0000001fULL;
+DECLARE_ASM_CONST(8, uint64_t, red_15mask)   = 0x00007c0000007c00ULL;
+DECLARE_ASM_CONST(8, uint64_t, green_15mask) = 0x000003e0000003e0ULL;
+DECLARE_ASM_CONST(8, uint64_t, blue_15mask)  = 0x0000001f0000001fULL;
+
+#if 0
+static volatile uint64_t __attribute__((aligned(8))) b5Dither;
+static volatile uint64_t __attribute__((aligned(8))) g5Dither;
+static volatile uint64_t __attribute__((aligned(8))) g6Dither;
+static volatile uint64_t __attribute__((aligned(8))) r5Dither;
+
+static uint64_t __attribute__((aligned(8))) dither4[2]={
+    0x0103010301030103LL,
+    0x0200020002000200LL,};
+
+static uint64_t __attribute__((aligned(8))) dither8[2]={
+    0x0602060206020602LL,
+    0x0004000400040004LL,};
+#endif
+#endif /* defined(ARCH_X86) */
+
+#define RGB2YUV_SHIFT 8
+#define BY ((int)( 0.098*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define BV ((int)(-0.071*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define BU ((int)( 0.439*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define GY ((int)( 0.504*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define GV ((int)(-0.368*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define GU ((int)(-0.291*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define RY ((int)( 0.257*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define RV ((int)( 0.439*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+#define RU ((int)(-0.148*(1&lt;&lt;RGB2YUV_SHIFT)+0.5))
+
+//Note: We have C, MMX, MMX2, 3DNOW versions, there is no 3DNOW + MMX2 one.
+//plain C versions
+#undef HAVE_MMX
+#undef HAVE_MMX2
+#undef HAVE_3DNOW
+#undef HAVE_SSE2
+#define RENAME(a) a ## _C
+#include &quot;rgb2rgb_template.c&quot;
+
+#if defined(ARCH_X86) &amp;&amp; defined(CONFIG_GPL)
+
+//MMX versions
+#undef RENAME

[... truncated: 13807 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011847.html">[Haiku-commits] r27537 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
	<LI>Next message: <A HREF="011938.html">[Haiku-commits] r27538 - haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11848">[ date ]</a>
              <a href="thread.html#11848">[ thread ]</a>
              <a href="subject.html#11848">[ subject ]</a>
              <a href="author.html#11848">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
