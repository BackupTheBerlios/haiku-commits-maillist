<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27567 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27567%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151414.m8FEEdJj001901%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011998.html">
   <LINK REL="Next"  HREF="011878.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27567 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27567%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151414.m8FEEdJj001901%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27567 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:14:39 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011998.html">[Haiku-commits] r27566 - haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011878.html">[Haiku-commits] r27568 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11877">[ date ]</a>
              <a href="thread.html#11877">[ thread ]</a>
              <a href="subject.html#11877">[ subject ]</a>
              <a href="author.html#11877">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:14:35 +0200 (Mon, 15 Sep 2008)
New Revision: 27567
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27567&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27567&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/8svx.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/kmvc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/nellymoser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/nellymoser.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/nellymoserdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/noise_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/nuv.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/opt.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/opt.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/os2thread.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qdm2.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qdm2data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qdrw.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qpeg.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qtrle.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/qtrleenc.c
Removed:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/adx.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/avcodec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/berrno.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/bswap.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/common.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/common.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/fastmemcpy.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcl.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mem.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/opts.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rational.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rational.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/4xm.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/8bps.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/Jamfile
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/4xm.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/4xm.c	2008-09-15 14:14:13 UTC (rev 27566)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/4xm.c	2008-09-15 14:14:35 UTC (rev 27567)
@@ -2,29 +2,32 @@
  * 4XM codec
  * Copyright (c) 2003 Michael Niedermayer
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
- 
+
 /**
  * @file 4xm.c
  * 4XM codec.
  */
- 
+
 #include &quot;avcodec.h&quot;
 #include &quot;dsputil.h&quot;
-#include &quot;mpegvideo.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;bytestream.h&quot;
 
 //#undef NDEBUG
 //#include &lt;assert.h&gt;
@@ -34,7 +37,8 @@
 
 #define CFRAME_BUFFER_COUNT 100
 
-static const uint8_t block_type_tab[4][8][2]={
+static const uint8_t block_type_tab[2][4][8][2]={
+ {
   {   //{8,4,2}x{8,4,2}
     { 0,1}, { 2,2}, { 6,3}, {14,4}, {30,5}, {31,5}, { 0,0}
   },{ //{8,4}x1
@@ -44,6 +48,17 @@
   },{ //1x2, 2x1
     { 0,1}, { 0,0}, { 0,0}, { 2,2}, { 6,3}, {14,4}, {15,4}
   }
+ },{
+  {  //{8,4,2}x{8,4,2}
+    { 1,2}, { 4,3}, { 5,3}, {0,2}, {6,3}, {7,3}, {0,0}
+  },{//{8,4}x1
+    { 1,2}, { 0,0}, { 2,2}, {0,2}, {6,3}, {7,3}, {0,0}
+  },{//1x{8,4}
+    { 1,2}, { 2,2}, { 0,0}, {0,2}, {6,3}, {7,3}, {0,0}
+  },{//1x2, 2x1
+    { 1,2}, { 0,0}, { 0,0}, {0,2}, {2,2}, {6,3}, {7,3}
+  }
+ }
 };
 
 static const uint8_t size2index[4][4]={
@@ -100,12 +115,12 @@
  20, 35, 34, 32, 31, 22, 15,  8,
 };
 
-static VLC block_type_vlc[4];
+static VLC block_type_vlc[2][4];
 
 
 typedef struct CFrameBuffer{
-    int allocated_size;
-    int size;
+    unsigned int allocated_size;
+    unsigned int size;
     int id;
     uint8_t *data;
 }CFrameBuffer;
@@ -116,14 +131,15 @@
     AVFrame current_picture, last_picture;
     GetBitContext pre_gb;          ///&lt; ac/dc prefix
     GetBitContext gb;
-    uint8_t *bytestream;
-    uint16_t *wordstream;
+    const uint8_t *bytestream;
+    const uint16_t *wordstream;
     int mv[256];
     VLC pre_vlc;
     int last_dc;
-    DCTELEM __align8 block[6][64];
+    DECLARE_ALIGNED_8(DCTELEM, block[6][64]);
     uint8_t *bitstream_buffer;
-    int bitstream_buffer_size;
+    unsigned int bitstream_buffer_size;
+    int version;
     CFrameBuffer cfrm[CFRAME_BUFFER_COUNT];
 } FourXContext;
 
@@ -141,7 +157,7 @@
     int z5, z10, z11, z12, z13;
     int i;
     int temp[64];
-    
+
     for(i=0; i&lt;8; i++){
         tmp10 = block[8*0 + i] + block[8*4 + i];
         tmp11 = block[8*0 + i] - block[8*4 + i];
@@ -153,7 +169,7 @@
         tmp3 = tmp10 - tmp13;
         tmp1 = tmp11 + tmp12;
         tmp2 = tmp11 - tmp12;
-        
+
         z13 = block[8*5 + i] + block[8*3 + i];
         z10 = block[8*5 + i] - block[8*3 + i];
         z11 = block[8*1 + i] + block[8*7 + i];
@@ -179,7 +195,7 @@
         temp[8*4 + i] = tmp3 + tmp4;
         temp[8*3 + i] = tmp3 - tmp4;
     }
-  
+
     for(i=0; i&lt;8*8; i+=8){
         tmp10 = temp[0 + i] + temp[4 + i];
         tmp11 = temp[0 + i] - temp[4 + i];
@@ -219,18 +235,13 @@
     }
 }
 
-static void init_vlcs(FourXContext *f){
-    static int done = 0;
+static av_cold void init_vlcs(FourXContext *f){
     int i;
 
-    if (!done) {
-        done = 1;
-
-        for(i=0; i&lt;4; i++){
-            init_vlc(&amp;block_type_vlc[i], BLOCK_TYPE_VLC_BITS, 7, 
-                     &amp;block_type_tab[i][0][1], 2, 1,
-                     &amp;block_type_tab[i][0][0], 2, 1);
-        }
+    for(i=0; i&lt;8; i++){
+        init_vlc(&amp;block_type_vlc[0][i], BLOCK_TYPE_VLC_BITS, 7,
+                 &amp;block_type_tab[0][i][0][1], 2, 1,
+                 &amp;block_type_tab[0][i][0][0], 2, 1, 1);
     }
 }
 
@@ -238,7 +249,10 @@
     int i;
 
     for(i=0; i&lt;256; i++){
-        f-&gt;mv[i] = mv[i][0] + mv[i][1]*f-&gt;current_picture.linesize[0]/2;
+        if(f-&gt;version&gt;1)
+            f-&gt;mv[i] = mv[i][0]   + mv[i][1]  *f-&gt;current_picture.linesize[0]/2;
+        else
+            f-&gt;mv[i] = (i&amp;15) - 8 + ((i&gt;&gt;4)-8)*f-&gt;current_picture.linesize[0]/2;
     }
 }
 
@@ -286,12 +300,18 @@
 static void decode_p_block(FourXContext *f, uint16_t *dst, uint16_t *src, int log2w, int log2h, int stride){
     const int index= size2index[log2h][log2w];
     const int h= 1&lt;&lt;log2h;
-    int code= get_vlc2(&amp;f-&gt;gb, block_type_vlc[index].table, BLOCK_TYPE_VLC_BITS, 1);
-    
+    int code= get_vlc2(&amp;f-&gt;gb, block_type_vlc[1-(f-&gt;version&gt;1)][index].table, BLOCK_TYPE_VLC_BITS, 1);
+    uint16_t *start= (uint16_t*)f-&gt;last_picture.data[0];
+    uint16_t *end= start + stride*(f-&gt;avctx-&gt;height-h+1) - (1&lt;&lt;log2w);
+
     assert(code&gt;=0 &amp;&amp; code&lt;=6);
 
     if(code == 0){
         src += f-&gt;mv[ *f-&gt;bytestream++ ];
+        if(start &gt; src || src &gt; end){
+            av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;mv out of pic\n&quot;);
+            return;
+        }
         mcdc(dst, src, log2w, h, stride, 1, 0);
     }else if(code == 1){
         log2h--;
@@ -301,8 +321,14 @@
         log2w--;
         decode_p_block(f, dst             , src             , log2w, log2h, stride);
         decode_p_block(f, dst + (1&lt;&lt;log2w), src + (1&lt;&lt;log2w), log2w, log2h, stride);
+    }else if(code == 3 &amp;&amp; f-&gt;version&lt;2){
+        mcdc(dst, src, log2w, h, stride, 1, 0);
     }else if(code == 4){
         src += f-&gt;mv[ *f-&gt;bytestream++ ];
+        if(start &gt; src || src &gt; end){
+            av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;mv out of pic\n&quot;);
+            return;
+        }
         mcdc(dst, src, log2w, h, stride, 1, le2me_16(*f-&gt;wordstream++));
     }else if(code == 5){
         mcdc(dst, src, log2w, h, stride, 0, le2me_16(*f-&gt;wordstream++));
@@ -317,55 +343,69 @@
     }
 }
 
-static int get32(void *p){
-    return le2me_32(*(uint32_t*)p);
-}
-
-static int decode_p_frame(FourXContext *f, uint8_t *buf, int length){
+static int decode_p_frame(FourXContext *f, const uint8_t *buf, int length){
     int x, y;
     const int width= f-&gt;avctx-&gt;width;
     const int height= f-&gt;avctx-&gt;height;
     uint16_t *src= (uint16_t*)f-&gt;last_picture.data[0];
     uint16_t *dst= (uint16_t*)f-&gt;current_picture.data[0];
     const int stride= f-&gt;current_picture.linesize[0]&gt;&gt;1;
-    const int bitstream_size= get32(buf+8);
-    const int bytestream_size= get32(buf+16);
-    const int wordstream_size= get32(buf+12);
-    
-    if(bitstream_size+ bytestream_size+ wordstream_size + 20 != length)
-        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;lengths %d %d %d %d\n&quot;, bitstream_size, bytestream_size, wordstream_size, 
+    unsigned int bitstream_size, bytestream_size, wordstream_size, extra;
+
+    if(f-&gt;version&gt;1){
+        extra=20;
+        bitstream_size= AV_RL32(buf+8);
+        wordstream_size= AV_RL32(buf+12);
+        bytestream_size= AV_RL32(buf+16);
+    }else{
+        extra=0;
+        bitstream_size = AV_RL16(buf-4);
+        wordstream_size= AV_RL16(buf-2);
+        bytestream_size= FFMAX(length - bitstream_size - wordstream_size, 0);
+    }
+
+    if(bitstream_size+ bytestream_size+ wordstream_size + extra != length
+       || bitstream_size  &gt; (1&lt;&lt;26)
+       || bytestream_size &gt; (1&lt;&lt;26)
+       || wordstream_size &gt; (1&lt;&lt;26)
+       ){
+        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;lengths %d %d %d %d\n&quot;, bitstream_size, bytestream_size, wordstream_size,
         bitstream_size+ bytestream_size+ wordstream_size - length);
-    
+        return -1;
+    }
+
     f-&gt;bitstream_buffer= av_fast_realloc(f-&gt;bitstream_buffer, &amp;f-&gt;bitstream_buffer_size, bitstream_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    f-&gt;dsp.bswap_buf((uint32_t*)f-&gt;bitstream_buffer, (uint32_t*)(buf + 20), bitstream_size/4);
+    f-&gt;dsp.bswap_buf((uint32_t*)f-&gt;bitstream_buffer, (const uint32_t*)(buf + extra), bitstream_size/4);
     init_get_bits(&amp;f-&gt;gb, f-&gt;bitstream_buffer, 8*bitstream_size);
 
-    f-&gt;wordstream= (uint16_t*)(buf + 20 + bitstream_size);
-    f-&gt;bytestream= buf + 20 + bitstream_size + wordstream_size;
-    
+    f-&gt;wordstream= (const uint16_t*)(buf + extra + bitstream_size);
+    f-&gt;bytestream= buf + extra + bitstream_size + wordstream_size;
+
     init_mv(f);
-    
+
     for(y=0; y&lt;height; y+=8){
         for(x=0; x&lt;width; x+=8){
             decode_p_block(f, dst + x, src + x, 3, 3, stride);
         }
-        src += 8*stride; 
-        dst += 8*stride; 
+        src += 8*stride;
+        dst += 8*stride;
     }
-    
-    if(bitstream_size != (get_bits_count(&amp;f-&gt;gb)+31)/32*4)
-        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot; %d %d %d bytes left\n&quot;, 
-            bitstream_size - (get_bits_count(&amp;f-&gt;gb)+31)/32*4, 
-            bytestream_size - (f-&gt;bytestream - (buf + 20 + bitstream_size + wordstream_size)),
-            wordstream_size - (((uint8_t*)f-&gt;wordstream) - (buf + 20 + bitstream_size))
+
+    if(   bitstream_size != (get_bits_count(&amp;f-&gt;gb)+31)/32*4
+       || (((const char*)f-&gt;wordstream - (const char*)buf + 2)&amp;~2) != extra + bitstream_size + wordstream_size
+       || (((const char*)f-&gt;bytestream - (const char*)buf + 3)&amp;~3) != extra + bitstream_size + wordstream_size + bytestream_size)
+        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot; %d %td %td bytes left\n&quot;,
+            bitstream_size - (get_bits_count(&amp;f-&gt;gb)+31)/32*4,
+            -(((const char*)f-&gt;bytestream - (const char*)buf + 3)&amp;~3) + (extra + bitstream_size + wordstream_size + bytestream_size),
+            -(((const char*)f-&gt;wordstream - (const char*)buf + 2)&amp;~2) + (extra + bitstream_size + wordstream_size)
         );
-    
+
     return 0;
 }
 
 /**
  * decode block and dequantize.
- * Note this is allmost identical to mjpeg
+ * Note this is almost identical to MJPEG.
  */
 static int decode_i_block(FourXContext *f, DCTELEM *block){
     int code, i, j, level, val;
@@ -386,7 +426,7 @@
     i = 1;
     for(;;) {
         code = get_vlc2(&amp;f-&gt;pre_gb, f-&gt;pre_vlc.table, ACDC_VLC_BITS, 3);
-        
+
         /* EOB */
         if (code == 0)
             break;
@@ -416,7 +456,7 @@
     int stride= f-&gt;current_picture.linesize[0]&gt;&gt;1;
     int i;
     uint16_t *dst = ((uint16_t*)f-&gt;current_picture.data[0]) + y * stride + x;
-    
+
     for(i=0; i&lt;4; i++){
         block[i][0] += 0x80*8*8;
         idct(block[i]);
@@ -430,7 +470,7 @@
 y= ( 1b + 4g + 2r)/14
 cb=( 3b - 2g - 1r)/14
 cr=(-1b - 4g + 5r)/14
-*/ 
+*/
     for(y=0; y&lt;8; y++){
         for(x=0; x&lt;8; x++){
             DCTELEM *temp= block[(x&gt;&gt;2) + 2*(y&gt;&gt;2)] + 2*(x&amp;3) + 2*8*(y&amp;3); //FIXME optimize
@@ -438,9 +478,9 @@
             int cr= block[5][x + 8*y];
             int cg= (cb + cr)&gt;&gt;1;
             int y;
-            
+
             cb+=cb;
-            
+
             y = temp[0];
             dst[0       ]= ((y+cb)&gt;&gt;3) + (((y-cg)&amp;0xFC)&lt;&lt;3) + (((y+cr)&amp;0xF8)&lt;&lt;8);
             y = temp[1];
@@ -457,27 +497,27 @@
 
 static int decode_i_mb(FourXContext *f){
     int i;
-    
+
     f-&gt;dsp.clear_blocks(f-&gt;block[0]);
-    
+
     for(i=0; i&lt;6; i++){
         if(decode_i_block(f, f-&gt;block[i]) &lt; 0)
             return -1;
     }
-    
+
     return 0;
 }
 
-static uint8_t *read_huffman_tables(FourXContext *f, uint8_t * const buf){
+static const uint8_t *read_huffman_tables(FourXContext *f, const uint8_t * const buf){
     int frequency[512];
     uint8_t flag[512];
     int up[512];
     uint8_t len_tab[257];
     int bits_tab[257];
     int start, end;
-    uint8_t *ptr= buf;
+    const uint8_t *ptr= buf;
     int j;
-    
+
     memset(frequency, 0, sizeof(frequency));
     memset(up, -1, sizeof(up));
 
@@ -485,23 +525,19 @@
     end= *ptr++;
     for(;;){
         int i;
-        
+
         for(i=start; i&lt;=end; i++){
             frequency[i]= *ptr++;
-//            printf(&quot;%d %d %d\n&quot;, start, end, frequency[i]);
         }
         start= *ptr++;
         if(start==0) break;
-        
+
         end= *ptr++;
     }
     frequency[256]=1;
 
-    while((ptr - buf)&amp;3) ptr++; // 4byte align 
+    while((ptr - buf)&amp;3) ptr++; // 4byte align
 
-//    for(j=0; j&lt;16; j++)
-//        printf(&quot;%2X&quot;, ptr[j]);
-    
     for(j=257; j&lt;512; j++){
         int min_freq[2]= {256*256, 256*256};
         int smallest[2]= {0, 0};
@@ -518,11 +554,11 @@
             }
         }
         if(min_freq[1] == 256*256) break;
-        
+
         frequency[j]= min_freq[0] + min_freq[1];
         flag[ smallest[0] ]= 0;
         flag[ smallest[1] ]= 1;
-        up[ smallest[0] ]= 
+        up[ smallest[0] ]=
         up[ smallest[1] ]= j;
         frequency[ smallest[0] ]= frequency[ smallest[1] ]= 0;
     }
@@ -537,32 +573,79 @@
             len++;
             if(len &gt; 31) av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;vlc length overflow\n&quot;); //can this happen at all ?
         }
-        
+
         bits_tab[j]= bits;
         len_tab[j]= len;
     }
-    
-    init_vlc(&amp;f-&gt;pre_vlc, ACDC_VLC_BITS, 257, 
+
+    init_vlc(&amp;f-&gt;pre_vlc, ACDC_VLC_BITS, 257,
              len_tab , 1, 1,
-             bits_tab, 4, 4);
-             
+             bits_tab, 4, 4, 0);
+
     return ptr;
 }
 
-static int decode_i_frame(FourXContext *f, uint8_t *buf, int length){
+static int mix(int c0, int c1){
+    int blue = 2*(c0&amp;0x001F) + (c1&amp;0x001F);
+    int green= (2*(c0&amp;0x03E0) + (c1&amp;0x03E0))&gt;&gt;5;
+    int red  = 2*(c0&gt;&gt;10) + (c1&gt;&gt;10);
+    return red/3*1024 + green/3*32 + blue/3;
+}
+
+static int decode_i2_frame(FourXContext *f, const uint8_t *buf, int length){
+    int x, y, x2, y2;
+    const int width= f-&gt;avctx-&gt;width;
+    const int height= f-&gt;avctx-&gt;height;
+    uint16_t *dst= (uint16_t*)f-&gt;current_picture.data[0];
+    const int stride= f-&gt;current_picture.linesize[0]&gt;&gt;1;
+
+    for(y=0; y&lt;height; y+=16){
+        for(x=0; x&lt;width; x+=16){
+            unsigned int color[4], bits;
+            memset(color, 0, sizeof(color));
+//warning following is purely guessed ...
+            color[0]= bytestream_get_le16(&amp;buf);
+            color[1]= bytestream_get_le16(&amp;buf);
+
+            if(color[0]&amp;0x8000) av_log(NULL, AV_LOG_ERROR, &quot;unk bit 1\n&quot;);
+            if(color[1]&amp;0x8000) av_log(NULL, AV_LOG_ERROR, &quot;unk bit 2\n&quot;);
+
+            color[2]= mix(color[0], color[1]);
+            color[3]= mix(color[1], color[0]);
+
+            bits= bytestream_get_le32(&amp;buf);
+            for(y2=0; y2&lt;16; y2++){
+                for(x2=0; x2&lt;16; x2++){
+                    int index= 2*(x2&gt;&gt;2) + 8*(y2&gt;&gt;2);
+                    dst[y2*stride+x2]= color[(bits&gt;&gt;index)&amp;3];
+                }
+            }
+            dst+=16;
+        }
+        dst += 16*stride - width;
+    }
+
+    return 0;
+}
+
+static int decode_i_frame(FourXContext *f, const uint8_t *buf, int length){
     int x, y;
     const int width= f-&gt;avctx-&gt;width;
     const int height= f-&gt;avctx-&gt;height;
     uint16_t *dst= (uint16_t*)f-&gt;current_picture.data[0];
     const int stride= f-&gt;current_picture.linesize[0]&gt;&gt;1;
-    const int bitstream_size= get32(buf);
-    const int token_count __attribute__((unused)) = get32(buf + bitstream_size + 8);
-    int prestream_size= 4*get32(buf + bitstream_size + 4);
-    uint8_t *prestream= buf + bitstream_size + 12;
-    
-    if(prestream_size + bitstream_size + 12 != length)
-        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;size missmatch %d %d %d\n&quot;, prestream_size, bitstream_size, length);
-   
+    const unsigned int bitstream_size= AV_RL32(buf);
+    const int token_count av_unused = AV_RL32(buf + bitstream_size + 8);
+    unsigned int prestream_size= 4*AV_RL32(buf + bitstream_size + 4);
+    const uint8_t *prestream= buf + bitstream_size + 12;
+
+    if(prestream_size + bitstream_size + 12 != length
+       || bitstream_size &gt; (1&lt;&lt;26)
+       || prestream_size &gt; (1&lt;&lt;26)){
+        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;size mismatch %d %d %d\n&quot;, prestream_size, bitstream_size, length);
+        return -1;
+    }
+
     prestream= read_huffman_tables(f, prestream);
 
     init_get_bits(&amp;f-&gt;gb, buf + 4, 8*bitstream_size);
@@ -570,11 +653,11 @@
     prestream_size= length + buf - prestream;
 
     f-&gt;bitstream_buffer= av_fast_realloc(f-&gt;bitstream_buffer, &amp;f-&gt;bitstream_buffer_size, prestream_size + FF_INPUT_BUFFER_PADDING_SIZE);
-    f-&gt;dsp.bswap_buf((uint32_t*)f-&gt;bitstream_buffer, (uint32_t*)prestream, prestream_size/4);
+    f-&gt;dsp.bswap_buf((uint32_t*)f-&gt;bitstream_buffer, (const uint32_t*)prestream, prestream_size/4);
     init_get_bits(&amp;f-&gt;pre_gb, f-&gt;bitstream_buffer, 8*prestream_size);
 
     f-&gt;last_dc= 0*128*8*8;
-    
+
     for(y=0; y&lt;height; y+=16){
         for(x=0; x&lt;width; x+=16){
             if(decode_i_mb(f) &lt; 0)
@@ -582,48 +665,41 @@
 
             idct_put(f, x, y);
         }
-        dst += 16*stride; 
+        dst += 16*stride;
     }
 
     if(get_vlc2(&amp;f-&gt;pre_gb, f-&gt;pre_vlc.table, ACDC_VLC_BITS, 3) != 256)
-        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;end missmatch\n&quot;);
-    
+        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;end mismatch\n&quot;);
+
     return 0;
 }
 
-static int decode_frame(AVCodecContext *avctx, 
+static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     FourXContext * const f = avctx-&gt;priv_data;
     AVFrame *picture = data;
     AVFrame *p, temp;
     int i, frame_4cc, frame_size;
 
-    *data_size = 0;
-
-    /* special case for last picture */
-    if (buf_size == 0) {
-        return 0;
+    frame_4cc= AV_RL32(buf);
+    if(buf_size != AV_RL32(buf+4)+8 || buf_size &lt; 20){
+        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;size mismatch %d %d\n&quot;, buf_size, AV_RL32(buf+4));
     }
 
-    frame_4cc= get32(buf);
-    if(buf_size != get32(buf+4)+8){
-        av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;size missmatch %d %d\n&quot;, buf_size, get32(buf+4));
-    }
-
     if(frame_4cc == ff_get_fourcc(&quot;cfrm&quot;)){
         int free_index=-1;
         const int data_size= buf_size - 20;
-        const int id= get32(buf+12);
-        const int whole_size= get32(buf+16);
+        const int id= AV_RL32(buf+12);
+        const int whole_size= AV_RL32(buf+16);
         CFrameBuffer *cfrm;
 
         for(i=0; i&lt;CFRAME_BUFFER_COUNT; i++){
             if(f-&gt;cfrm[i].id &amp;&amp; f-&gt;cfrm[i].id &lt; avctx-&gt;frame_number)
                 av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;lost c frame %d\n&quot;, f-&gt;cfrm[i].id);
         }
-        
+
         for(i=0; i&lt;CFRAME_BUFFER_COUNT; i++){
             if(f-&gt;cfrm[i].id   == id) break;
             if(f-&gt;cfrm[i].size == 0 ) free_index= i;
@@ -634,20 +710,24 @@
             f-&gt;cfrm[i].id= id;
         }
         cfrm= &amp;f-&gt;cfrm[i];
-        
+
         cfrm-&gt;data= av_fast_realloc(cfrm-&gt;data, &amp;cfrm-&gt;allocated_size, cfrm-&gt;size + data_size + FF_INPUT_BUFFER_PADDING_SIZE);
-        
+        if(!cfrm-&gt;data){ //explicit check needed as memcpy below might not catch a NULL
+            av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;realloc falure&quot;);
+            return -1;
+        }
+
         memcpy(cfrm-&gt;data + cfrm-&gt;size, buf+20, data_size);
         cfrm-&gt;size += data_size;
-        
+
         if(cfrm-&gt;size &gt;= whole_size){
             buf= cfrm-&gt;data;
             frame_size= cfrm-&gt;size;
-            
+
             if(id != avctx-&gt;frame_number){
-                av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;cframe id missmatch %d %d\n&quot;, id, avctx-&gt;frame_number);
+                av_log(f-&gt;avctx, AV_LOG_ERROR, &quot;cframe id mismatch %d %d\n&quot;, id, avctx-&gt;frame_number);
             }
-            
+
             cfrm-&gt;size= cfrm-&gt;id= 0;
             frame_4cc= ff_get_fourcc(&quot;pfrm&quot;);
         }else
@@ -655,7 +735,7 @@
     }else{
         buf= buf + 12;
         frame_size= buf_size - 12;
-    }    
+    }
 
     temp= f-&gt;current_picture;
     f-&gt;current_picture= f-&gt;last_picture;
@@ -675,12 +755,16 @@
         return -1;
     }
 
-    if(frame_4cc == ff_get_fourcc(&quot;ifrm&quot;)){
-        p-&gt;pict_type= I_TYPE;
+    if(frame_4cc == ff_get_fourcc(&quot;ifr2&quot;)){
+        p-&gt;pict_type= FF_I_TYPE;
+        if(decode_i2_frame(f, buf-4, frame_size) &lt; 0)
+            return -1;
+    }else if(frame_4cc == ff_get_fourcc(&quot;ifrm&quot;)){
+        p-&gt;pict_type= FF_I_TYPE;
         if(decode_i_frame(f, buf, frame_size) &lt; 0)
             return -1;
-    }else if(frame_4cc == ff_get_fourcc(&quot;pfrm&quot;)){
-        p-&gt;pict_type= P_TYPE;
+    }else if(frame_4cc == ff_get_fourcc(&quot;pfrm&quot;) || frame_4cc == ff_get_fourcc(&quot;pfr2&quot;)){
+        p-&gt;pict_type= FF_P_TYPE;
         if(decode_p_frame(f, buf, frame_size) &lt; 0)
             return -1;
     }else if(frame_4cc == ff_get_fourcc(&quot;snd_&quot;)){
@@ -689,19 +773,13 @@
         av_log(avctx, AV_LOG_ERROR, &quot;ignoring unknown chunk length:%d\n&quot;, buf_size);
     }
 
-#if 0
-for(i=0; i&lt;20; i++){
-    printf(&quot;%2X %c &quot;, buf[i], clip(buf[i],16,126));
-}
-#endif
+    p-&gt;key_frame= p-&gt;pict_type == FF_I_TYPE;
 
-    p-&gt;key_frame= p-&gt;pict_type == I_TYPE;
-
     *picture= *p;
     *data_size = sizeof(AVPicture);
 
     emms_c();
-    
+
     return buf_size;
 }
 
@@ -714,19 +792,26 @@
     f-&gt;avctx= avctx;
 }
 
-static int decode_init(AVCodecContext *avctx){
+static av_cold int decode_init(AVCodecContext *avctx){
     FourXContext * const f = avctx-&gt;priv_data;
- 
+
+    if(avctx-&gt;extradata_size != 4 || !avctx-&gt;extradata) {
+        av_log(avctx, AV_LOG_ERROR, &quot;extradata wrong or missing\n&quot;);
+        return 1;
+    }
+
+    f-&gt;version= AV_RL32(avctx-&gt;extradata)&gt;&gt;16;
     common_init(avctx);
     init_vlcs(f);
 
-    avctx-&gt;pix_fmt= PIX_FMT_RGB565;
+    if(f-&gt;version&gt;2) avctx-&gt;pix_fmt= PIX_FMT_RGB565;
+    else             avctx-&gt;pix_fmt= PIX_FMT_RGB555;
 
     return 0;
 }
 
 
-static int decode_end(AVCodecContext *avctx){
+static av_cold int decode_end(AVCodecContext *avctx){
     FourXContext * const f = avctx-&gt;priv_data;
     int i;
 
@@ -737,8 +822,6 @@
         f-&gt;cfrm[i].allocated_size= 0;
     }
     free_vlc(&amp;f-&gt;pre_vlc);
-    
-    avcodec_default_free_buffers(avctx);
 
     return 0;
 }
@@ -753,5 +836,6 @@
     decode_end,
     decode_frame,
     /*CODEC_CAP_DR1,*/
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;4X Movie&quot;),
 };
 

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/8bps.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/8bps.c	2008-09-15 14:14:13 UTC (rev 27566)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/8bps.c	2008-09-15 14:14:35 UTC (rev 27567)
@@ -2,53 +2,53 @@
  * Quicktime Planar RGB (8BPS) Video Decoder
  * Copyright (C) 2003 Roberto Togni
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file 8bps.c
- * QT 8BPS Video Decoder by Roberto Togni &lt;rtogni at bresciaonline dot it&gt;
+ * QT 8BPS Video Decoder by Roberto Togni
  * For more information about the 8BPS format, visit:
  *   <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
  *
  * Supports: PAL8 (RGB 8bpp, paletted)
- *         : BGR24 (RGB 24bpp) (can also output it as RGBA32)
- *         : RGBA32 (RGB 32bpp, 4th plane is probably alpha and it's ignored)
+ *         : BGR24 (RGB 24bpp) (can also output it as RGB32)
+ *         : RGB32 (RGB 32bpp, 4th plane is probably alpha and it's ignored)
  *
  */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 
-#include &quot;common.h&quot;
 #include &quot;avcodec.h&quot;
 
 
-const enum PixelFormat pixfmt_rgb24[] = {PIX_FMT_BGR24, PIX_FMT_RGBA32, -1};
+static const enum PixelFormat pixfmt_rgb24[] = {PIX_FMT_BGR24, PIX_FMT_RGB32, PIX_FMT_NONE};
 
 /*
  * Decoder context
  */
 typedef struct EightBpsContext {
 
-	AVCodecContext *avctx;
-	AVFrame pic;
+        AVCodecContext *avctx;
+        AVFrame pic;
 
-	unsigned char planes;
-	unsigned char planemap[4];
+        unsigned char planes;
+        unsigned char planemap[4];
 } EightBpsContext;
 
 
@@ -57,87 +57,89 @@
  * Decode a frame
  *
  */
-static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, uint8_t *buf, int buf_size)
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
 {
-	EightBpsContext * const c = (EightBpsContext *)avctx-&gt;priv_data;
-	unsigned char *encoded = (unsigned char *)buf;
-	unsigned char *pixptr;
-	unsigned int height = avctx-&gt;height; // Real image height
-	unsigned int dlen, p, row;
-	unsigned char *lp, *dp;
-	unsigned char count;
-	unsigned int px_inc;
-	unsigned int planes = c-&gt;planes;
-	unsigned char *planemap = c-&gt;planemap;
-  
-  
-	/* no supplementary picture */
-	if (buf_size == 0)
-		return 0;
+        EightBpsContext * const c = avctx-&gt;priv_data;
+        const unsigned char *encoded = buf;
+        unsigned char *pixptr, *pixptr_end;
+        unsigned int height = avctx-&gt;height; // Real image height
+        unsigned int dlen, p, row;
+        const unsigned char *lp, *dp;
+        unsigned char count;
+        unsigned int px_inc;
+        unsigned int planes = c-&gt;planes;
+        unsigned char *planemap = c-&gt;planemap;
 
-	if(c-&gt;pic.data[0])
-		avctx-&gt;release_buffer(avctx, &amp;c-&gt;pic);
+        if(c-&gt;pic.data[0])
+                avctx-&gt;release_buffer(avctx, &amp;c-&gt;pic);
 
-	c-&gt;pic.reference = 0;
-	c-&gt;pic.buffer_hints = FF_BUFFER_HINTS_VALID;
-	if(avctx-&gt;get_buffer(avctx, &amp;c-&gt;pic) &lt; 0){
-		av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
-		return -1;
-	}
+        c-&gt;pic.reference = 0;
+        c-&gt;pic.buffer_hints = FF_BUFFER_HINTS_VALID;
+        if(avctx-&gt;get_buffer(avctx, &amp;c-&gt;pic) &lt; 0){
+                av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+                return -1;
+        }
 
-	/* Set data pointer after line lengths */
-	dp = encoded + planes * (height &lt;&lt; 1);
+        /* Set data pointer after line lengths */
+        dp = encoded + planes * (height &lt;&lt; 1);
 
-	/* Ignore alpha plane, don't know what to do with it */
-	if (planes == 4)
-		planes--;
+        /* Ignore alpha plane, don't know what to do with it */
+        if (planes == 4)
+                planes--;
 
-	px_inc = planes + (avctx-&gt;pix_fmt == PIX_FMT_RGBA32);
+        px_inc = planes + (avctx-&gt;pix_fmt == PIX_FMT_RGB32);
 
-	for (p = 0; p &lt; planes; p++) {
-		/* Lines length pointer for this plane */
-		lp = encoded + p * (height &lt;&lt; 1);
+        for (p = 0; p &lt; planes; p++) {
+                /* Lines length pointer for this plane */
+                lp = encoded + p * (height &lt;&lt; 1);
 
-		/* Decode a plane */
-		for(row = 0; row &lt; height; row++) {
-			pixptr = c-&gt;pic.data[0] + row * c-&gt;pic.linesize[0] + planemap[p];
-			dlen = be2me_16(*(unsigned short *)(lp+row*2));
-			/* Decode a row of this plane */
-			while(dlen &gt; 0) {
-				if ((count = *dp++) &lt;= 127) {
-					count++;
-					dlen -= count + 1;
-					while(count--) {
-						*pixptr = *dp++;
-						pixptr += px_inc;
-					}
-				} else {
-					count = 257 - count;
-					while(count--) {
-						*pixptr = *dp;
-						pixptr += px_inc;
-					}
-					dp++;
-					dlen -= 2;
-				}
-			}
-		}
-	}
+                /* Decode a plane */
+                for(row = 0; row &lt; height; row++) {
+                        pixptr = c-&gt;pic.data[0] + row * c-&gt;pic.linesize[0] + planemap[p];
+                        pixptr_end = pixptr + c-&gt;pic.linesize[0];
+                        dlen = be2me_16(*(const unsigned short *)(lp+row*2));
+                        /* Decode a row of this plane */
+                        while(dlen &gt; 0) {
+                                if(dp + 1 &gt;= buf+buf_size) return -1;
+                                if ((count = *dp++) &lt;= 127) {
+                                        count++;
+                                        dlen -= count + 1;
+                                        if (pixptr + count * px_inc &gt; pixptr_end)
+                                            break;
+                                        if(dp + count &gt; buf+buf_size) return -1;
+                                        while(count--) {
+                                                *pixptr = *dp++;
+                                                pixptr += px_inc;
+                                        }
+                                } else {
+                                        count = 257 - count;
+                                        if (pixptr + count * px_inc &gt; pixptr_end)
+                                            break;
+                                        while(count--) {
+                                                *pixptr = *dp;
+                                                pixptr += px_inc;
+                                        }
+                                        dp++;
+                                        dlen -= 2;
+                                }
+                        }
+                }
+        }
 
-	if (avctx-&gt;palctrl) {
-		memcpy (c-&gt;pic.data[1], avctx-&gt;palctrl-&gt;palette, AVPALETTE_SIZE);
-		if (avctx-&gt;palctrl-&gt;palette_changed) {
-			c-&gt;pic.palette_has_changed = 1;
-			avctx-&gt;palctrl-&gt;palette_changed = 0;
-		} else
-			c-&gt;pic.palette_has_changed = 0;
-	}
+        if (avctx-&gt;palctrl) {
+                memcpy (c-&gt;pic.data[1], avctx-&gt;palctrl-&gt;palette, AVPALETTE_SIZE);
+                if (avctx-&gt;palctrl-&gt;palette_changed) {
+                        c-&gt;pic.palette_has_changed = 1;
+                        avctx-&gt;palctrl-&gt;palette_changed = 0;
+                } else
+                        c-&gt;pic.palette_has_changed = 0;
+        }
 
-	*data_size = sizeof(AVFrame);
-	*(AVFrame*)data = c-&gt;pic;
+        *data_size = sizeof(AVFrame);
+        *(AVFrame*)data = c-&gt;pic;
 
-	/* always report that the buffer was completely consumed */
-	return buf_size;
+        /* always report that the buffer was completely consumed */
+        return buf_size;
 }
 
 
@@ -146,51 +148,54 @@
  * Init 8BPS decoder
  *
  */
-static int decode_init(AVCodecContext *avctx)
+static av_cold int decode_init(AVCodecContext *avctx)
 {
-	EightBpsContext * const c = (EightBpsContext *)avctx-&gt;priv_data;
+        EightBpsContext * const c = avctx-&gt;priv_data;
 
-	c-&gt;avctx = avctx;
-	avctx-&gt;has_b_frames = 0;
+        c-&gt;avctx = avctx;
 
-	c-&gt;pic.data[0] = NULL;
+        c-&gt;pic.data[0] = NULL;
 
-	switch (avctx-&gt;bits_per_sample) {
-		case 8:
-			avctx-&gt;pix_fmt = PIX_FMT_PAL8;
-			c-&gt;planes = 1;
-			c-&gt;planemap[0] = 0; // 1st plane is palette indexes
-			if (avctx-&gt;palctrl == NULL) {
-				av_log(avctx, AV_LOG_ERROR, &quot;Error: PAL8 format but no palette from demuxer.\n&quot;);
-				return -1;
-			}
-			break;
-		case 24:
-			avctx-&gt;pix_fmt = avctx-&gt;get_format(avctx, pixfmt_rgb24);
-			c-&gt;planes = 3;
-			c-&gt;planemap[0] = 2; // 1st plane is red
-			c-&gt;planemap[1] = 1; // 2nd plane is green
-			c-&gt;planemap[2] = 0; // 3rd plane is blue
-			break;
-		case 32:
-			avctx-&gt;pix_fmt = PIX_FMT_RGBA32;
-			c-&gt;planes = 4;
+    if (avcodec_check_dimensions(avctx, avctx-&gt;width, avctx-&gt;height) &lt; 0) {
+        return 1;
+    }
+
+        switch (avctx-&gt;bits_per_sample) {
+                case 8:
+                        avctx-&gt;pix_fmt = PIX_FMT_PAL8;
+                        c-&gt;planes = 1;
+                        c-&gt;planemap[0] = 0; // 1st plane is palette indexes
+                        if (avctx-&gt;palctrl == NULL) {
+                                av_log(avctx, AV_LOG_ERROR, &quot;Error: PAL8 format but no palette from demuxer.\n&quot;);
+                                return -1;

[... truncated: 6618 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011998.html">[Haiku-commits] r27566 - haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011878.html">[Haiku-commits] r27568 -	haiku/trunk/src/add-ons/media/plugins/avcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11877">[ date ]</a>
              <a href="thread.html#11877">[ thread ]</a>
              <a href="subject.html#11877">[ subject ]</a>
              <a href="author.html#11877">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
