<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27562 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27562%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151412.m8FEC8bM001425%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011871.html">
   <LINK REL="Next"  HREF="011873.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27562 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27562%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151412.m8FEC8bM001425%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27562 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:12:08 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011871.html">[Haiku-commits] r27561 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011873.html">[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11872">[ date ]</a>
              <a href="thread.html#11872">[ thread ]</a>
              <a href="subject.html#11872">[ subject ]</a>
              <a href="author.html#11872">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:12:05 +0200 (Mon, 15 Sep 2008)
New Revision: 27562
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27562&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27562&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rangecoder.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rangecoder.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ratecontrol.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/raw.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rawdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rawenc.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra288.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra288.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ratecontrol.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/raw.c
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.c	2008-09-15 14:11:26 UTC (rev 27561)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.c	2008-09-15 14:12:05 UTC (rev 27562)
@@ -1,513 +1,356 @@
 /*
  * Real Audio 1.0 (14.4K)
- * Copyright (c) 2003 the ffmpeg project
  *
- * This library is free software; you can redistribute it and/or
+ * Copyright (c) 2008 Vitor Sessak
+ * Copyright (c) 2003 Nick Kurshev
+ *     Based on public domain decoder at <A HREF="http://www.honeypot.net/audio">http://www.honeypot.net/audio</A>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
 #include &quot;ra144.h&quot;
+#include &quot;acelp_filters.h&quot;
 
-#define DATABLOCK1	20			/* size of 14.4 input block in bytes */
-#define DATACHUNK1	1440			/* size of 14.4 input chunk in bytes */
-#define AUDIOBLOCK	160			/* size of output block in 16-bit words (320 bytes) */
-#define AUDIOBUFFER	12288			/* size of output buffer in 16-bit words (24576 bytes) */
-/* consts */
-#define NBLOCKS		4				/* number of segments within a block */
-#define BLOCKSIZE	40				/* (quarter) block size in 16-bit words (80 bytes) */
-#define HALFBLOCK	20				/* BLOCKSIZE/2 */
-#define BUFFERSIZE	146				/* for do_output */
+#define NBLOCKS         4       ///&lt; number of subblocks within a block
+#define BLOCKSIZE       40      ///&lt; subblock size in 16-bit words
+#define BUFFERSIZE      146     ///&lt; the size of the adaptive codebook
 
 
-/* internal globals */
 typedef struct {
-	unsigned int	 resetflag, val, oldval;
-	unsigned int	 unpacked[28];		/* buffer for unpacked input */
-	unsigned int	*iptr;				/* pointer to current input (from unpacked) */
-	unsigned int	 gval;
-	unsigned short	*gsp;
-	unsigned int	 gbuf1[8];
-	unsigned short	 gbuf2[120];
-	signed   short	 output_buffer[40];
-	unsigned int	*decptr;			/* decoder ptr */
-	signed   short	*decsp;
+    unsigned int     old_energy;        ///&lt; previous frame energy
 
-	/* the swapped buffers */
-	unsigned int	 swapb1a[10];
-	unsigned int	 swapb2a[10];
-	unsigned int	 swapb1b[10];
-	unsigned int	 swapb2b[10];
-	unsigned int	*swapbuf1;
-	unsigned int	*swapbuf2;
-	unsigned int	*swapbuf1alt;
-	unsigned int	*swapbuf2alt;
+    unsigned int     lpc_tables[2][10];
 
-	unsigned int buffer[5];
-	unsigned short int buffer_2[148];
-	unsigned short int buffer_a[40];
-	unsigned short int buffer_b[40];
-	unsigned short int buffer_c[40];
-	unsigned short int buffer_d[40];
+    /** LPC coefficients: lpc_coef[0] is the coefficients of the current frame
+     *  and lpc_coef[1] of the previous one */
+    unsigned int    *lpc_coef[2];
 
-	unsigned short int work[50];
-	unsigned short *sptr;
+    unsigned int     lpc_refl_rms[2];
 
-	int buffer1[10];
-	int buffer2[10];
+    /** the current subblock padded by the last 10 values of the previous one*/
+    int16_t curr_sblock[50];
 
-	signed short wavtable1[2304];
-	unsigned short wavtable2[2304];
-} Real144_internal;
+    /** adaptive codebook. Its size is two units bigger to avoid a
+     *  buffer overflow */
+    uint16_t adapt_cb[148];
+} RA144Context;
 
 static int ra144_decode_init(AVCodecContext * avctx)
 {
-	Real144_internal *glob=avctx-&gt;priv_data;
+    RA144Context *ractx = avctx-&gt;priv_data;
 
-	memset(glob,0,sizeof(Real144_internal));
-	glob-&gt;resetflag=1;
-	glob-&gt;swapbuf1=glob-&gt;swapb1a;
-	glob-&gt;swapbuf2=glob-&gt;swapb2a;
-	glob-&gt;swapbuf1alt=glob-&gt;swapb1b;
-	glob-&gt;swapbuf2alt=glob-&gt;swapb2b;
+    ractx-&gt;lpc_coef[0] = ractx-&gt;lpc_tables[0];
+    ractx-&gt;lpc_coef[1] = ractx-&gt;lpc_tables[1];
 
-	memcpy(glob-&gt;wavtable1,wavtable1,sizeof(wavtable1));
-	memcpy(glob-&gt;wavtable2,wavtable2,sizeof(wavtable2));
-
-	return 0;
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+    return 0;
 }
 
-static void final(Real144_internal *glob, short *i1, short *i2, void *out, int *statbuf, int len);
-static void add_wav(Real144_internal *glob, int n, int f, int m1, int m2, int m3, short *s1, short *s2, short *s3, short *dest);
-static int irms(short *data, int factor);
-static void rotate_block(short *source, short *target, int offset);
-/* lookup square roots in table */
+/**
+ * Evaluate sqrt(x &lt;&lt; 24). x must fit in 20 bits. This value is evaluated in an
+ * odd way to make the output identical to the binary decoder.
+ */
 static int t_sqrt(unsigned int x)
 {
-  int s=0;
-  while (x&gt;0xfff) { s++; x=x&gt;&gt;2; }
-  return (sqrt_table[x]&lt;&lt;s)&lt;&lt;2;
+    int s = 2;
+    while (x &gt; 0xfff) {
+        s++;
+        x &gt;&gt;= 2;
+    }
+
+    return ff_sqrt(x &lt;&lt; 20) &lt;&lt; s;
 }
 
-/* do 'voice' */
-static void do_voice(int *a1, int *a2)
+/**
+ * Evaluate the LPC filter coefficients from the reflection coefficients.
+ * Does the inverse of the eval_refl() function.
+ */
+static void eval_coefs(int *coefs, const int *refl)
 {
-  int buffer[10];
-  int *b1,*b2;
-  int x,y;
-  int *ptr,*tmp;
-  
-  b1=buffer;
-  b2=a2;
-  
-  for (x=0;x&lt;10;x++) {
-    b1[x]=(*a1)&lt;&lt;4;
+    int buffer[10];
+    int *b1 = buffer;
+    int *b2 = coefs;
+    int i, j;
 
-    if(x&gt;0) {
-      ptr=b2+x;
-      for (y=0;y&lt;=x-1;y++)
-        b1[y]=(((*a1)*(*(--ptr)))&gt;&gt;12)+b2[y];
-    }
-    tmp=b1;
-    b1=b2;
-    b2=tmp;
-    a1++;
-  }  
-  ptr=a2+10;
-  while (ptr&gt;a2) (*a2++)&gt;&gt;=4;
-}
+    for (i=0; i &lt; 10; i++) {
+        b1[i] = refl[i] &lt;&lt; 4;
 
+        for (j=0; j &lt; i; j++)
+            b1[j] = ((refl[i] * b2[i-j-1]) &gt;&gt; 12) + b2[j];
 
-/* do quarter-block output */
-static void do_output_subblock(Real144_internal *glob, int x)
-{
-  int a,b,c,d,e,f,g;
+        FFSWAP(int *, b1, b2);
+    }
 
-  if (x==1) memset(glob-&gt;buffer,0,20);
-  if ((*glob-&gt;iptr)==0) a=0;
-  else a=(*glob-&gt;iptr)+HALFBLOCK-1;
-  glob-&gt;iptr++;
-  b=*(glob-&gt;iptr++);
-  c=*(glob-&gt;iptr++);
-  d=*(glob-&gt;iptr++);
-  if (a) rotate_block(glob-&gt;buffer_2,glob-&gt;buffer_a,a);
-  memcpy(glob-&gt;buffer_b,etable1+b*BLOCKSIZE,BLOCKSIZE*2);
-  e=((ftable1[b]&gt;&gt;4)*glob-&gt;gval)&gt;&gt;8;
-  memcpy(glob-&gt;buffer_c,etable2+c*BLOCKSIZE,BLOCKSIZE*2);
-  f=((ftable2[c]&gt;&gt;4)*glob-&gt;gval)&gt;&gt;8;
-  if (a) g=irms(glob-&gt;buffer_a,glob-&gt;gval)&gt;&gt;12;
-  else g=0;
-  add_wav(glob,d,a,g,e,f,glob-&gt;buffer_a,glob-&gt;buffer_b,glob-&gt;buffer_c,glob-&gt;buffer_d);
-  memmove(glob-&gt;buffer_2,glob-&gt;buffer_2+BLOCKSIZE,(BUFFERSIZE-BLOCKSIZE)*2);
-  memcpy(glob-&gt;buffer_2+BUFFERSIZE-BLOCKSIZE,glob-&gt;buffer_d,BLOCKSIZE*2);
-  final(glob,glob-&gt;gsp,glob-&gt;buffer_d,glob-&gt;output_buffer,glob-&gt;buffer,BLOCKSIZE);
+    for (i=0; i &lt; 10; i++)
+        coefs[i] &gt;&gt;= 4;
 }
 
-/* rotate block */
-static void rotate_block(short *source, short *target, int offset)
+/**
+ * Copy the last offset values of *source to *target. If those values are not
+ * enough to fill the target buffer, fill it with another copy of those values.
+ */
+static void copy_and_dup(int16_t *target, const int16_t *source, int offset)
 {
-  short *end;
-  short *ptr1;
-  short *ptr2;
-  short *ptr3;
-  ptr2=source+BUFFERSIZE;
-  ptr3=ptr1=ptr2-offset;
-  end=target+BLOCKSIZE;
-  while (target&lt;end) {
-    *(target++)=*(ptr3++);
-    if (ptr3==ptr2) ptr3=ptr1;
-  }
-}
+    source += BUFFERSIZE - offset;
 
-/* inverse root mean square */
-static int irms(short *data, int factor)
-{
-  short *p1,*p2;
-  unsigned int sum;
-  p2=(p1=data)+BLOCKSIZE;
-  for (sum=0;p2&gt;p1;p1++) sum+=(*p1)*(*p1);
-  if (sum==0) return 0; /* OOPS - division by zero */
-  return (0x20000000/(t_sqrt(sum)&gt;&gt;8))*factor;
+    if (offset &gt; BLOCKSIZE) {
+        memcpy(target, source, BLOCKSIZE*sizeof(*target));
+    } else {
+        memcpy(target, source, offset*sizeof(*target));
+        memcpy(target + offset, source, (BLOCKSIZE - offset)*sizeof(*target));
+    }
 }
 
-/* multiply/add wavetable */
-static void add_wav(Real144_internal *glob, int n, int f, int m1, int m2, int m3, short *s1, short *s2, short *s3, short *dest)
+/** inverse root mean square */
+static int irms(const int16_t *data)
 {
-  int a,b,c;
-  short *ptr,*ptr2;
+    unsigned int i, sum = 0;
 
-  ptr=glob-&gt;wavtable1+n*9;
-  ptr2=glob-&gt;wavtable2+n*9;
-  if (f!=0) {
-    a=((*ptr)*m1)&gt;&gt;((*ptr2)+1); 
-  } else {
-    a=0;
-  }
-  ptr++;ptr2++;
-  b=((*ptr)*m2)&gt;&gt;((*ptr2)+1);
-  ptr++;ptr2++;
-  c=((*ptr)*m3)&gt;&gt;((*ptr2)+1);
-  ptr2=(ptr=dest)+BLOCKSIZE;
-  if (f!=0)
-    while (ptr&lt;ptr2)
-      *(ptr++)=((*(s1++))*a+(*(s2++))*b+(*(s3++))*c)&gt;&gt;12;
-  else
-    while (ptr&lt;ptr2)
-      *(ptr++)=((*(s2++))*b+(*(s3++))*c)&gt;&gt;12;
-}
+    for (i=0; i &lt; BLOCKSIZE; i++)
+        sum += data[i] * data[i];
 
+    if (sum == 0)
+        return 0; /* OOPS - division by zero */
 
-static void final(Real144_internal *glob, short *i1, short *i2, void *out, int *statbuf, int len)
+    return 0x20000000 / (t_sqrt(sum) &gt;&gt; 8);
+}
+
+static void add_wav(int16_t *dest, int n, int skip_first, int *m,
+                    const int16_t *s1, const int8_t *s2, const int8_t *s3)
 {
-  int x,sum;
-  int buffer[10];
-  short *ptr;
-  short *ptr2;
+    int i;
+    int v[3];
 
-  memcpy(glob-&gt;work,statbuf,20);
-  memcpy(glob-&gt;work+10,i2,len*2);
+    v[0] = 0;
+    for (i=!skip_first; i&lt;3; i++)
+        v[i] = (gain_val_tab[n][i] * m[i]) &gt;&gt; (gain_exp_tab[n][i] + 1);
 
-  buffer[9]=i1[0];
-  buffer[8]=i1[1];
-  buffer[7]=i1[2];
-  buffer[6]=i1[3];
-  buffer[5]=i1[4];
-  buffer[4]=i1[5];
-  buffer[3]=i1[6];
-  buffer[2]=i1[7];
-  buffer[1]=i1[8];
-  buffer[0]=i1[9];
+    for (i=0; i &lt; BLOCKSIZE; i++)
+        dest[i] = (s1[i]*v[0] + s2[i]*v[1] + s3[i]*v[2]) &gt;&gt; 12;
+}
 
-  ptr2=(ptr=glob-&gt;work)+len;
-  while (ptr&lt;ptr2) {
-    for(sum=0,x=0;x&lt;=9;x++)
-      sum+=buffer[x]*(ptr[x]);
-    sum=sum&gt;&gt;12;
-    x=ptr[10]-sum;
-    if (x&lt;-32768 || x&gt;32767)
-    {
-      memset(out,0,len*2);
-      memset(statbuf,0,20);
-      return;
-    }
-    ptr[10]=x;
-    ptr++;
-  }
-  memcpy(out,ptr+10-len,len*2);
-  memcpy(statbuf,ptr,20);
+static unsigned int rescale_rms(unsigned int rms, unsigned int energy)
+{
+    return (rms * energy) &gt;&gt; 10;
 }
 
-/* Decode 20-byte input */
-static void unpack_input(unsigned char *input, unsigned int *output)
+static unsigned int rms(const int *data)
 {
-  unsigned int outbuffer[28];
-  unsigned short inbuffer[10];
-  unsigned int x;
-  unsigned int *ptr;
+    int i;
+    unsigned int res = 0x10000;
+    int b = 10;
 
-  /* fix endianness */
-  for (x=0;x&lt;20;x+=2)
-    inbuffer[x/2]=(input[x]&lt;&lt;8)+input[x+1];
+    for (i=0; i &lt; 10; i++) {
+        res = (((0x1000000 - data[i]*data[i]) &gt;&gt; 12) * res) &gt;&gt; 12;
 
-  /* unpack */
-  ptr=outbuffer;
-  *(ptr++)=27;
-  *(ptr++)=(inbuffer[0]&gt;&gt;10)&amp;0x3f;
-  *(ptr++)=(inbuffer[0]&gt;&gt;5)&amp;0x1f;
-  *(ptr++)=inbuffer[0]&amp;0x1f;
-  *(ptr++)=(inbuffer[1]&gt;&gt;12)&amp;0xf;
-  *(ptr++)=(inbuffer[1]&gt;&gt;8)&amp;0xf;
-  *(ptr++)=(inbuffer[1]&gt;&gt;5)&amp;7;
-  *(ptr++)=(inbuffer[1]&gt;&gt;2)&amp;7;
-  *(ptr++)=((inbuffer[1]&lt;&lt;1)&amp;6)|((inbuffer[2]&gt;&gt;15)&amp;1);
-  *(ptr++)=(inbuffer[2]&gt;&gt;12)&amp;7;
-  *(ptr++)=(inbuffer[2]&gt;&gt;10)&amp;3;
-  *(ptr++)=(inbuffer[2]&gt;&gt;5)&amp;0x1f;
-  *(ptr++)=((inbuffer[2]&lt;&lt;2)&amp;0x7c)|((inbuffer[3]&gt;&gt;14)&amp;3);
-  *(ptr++)=(inbuffer[3]&gt;&gt;6)&amp;0xff;
-  *(ptr++)=((inbuffer[3]&lt;&lt;1)&amp;0x7e)|((inbuffer[4]&gt;&gt;15)&amp;1);
-  *(ptr++)=(inbuffer[4]&gt;&gt;8)&amp;0x7f;
-  *(ptr++)=(inbuffer[4]&gt;&gt;1)&amp;0x7f;
-  *(ptr++)=((inbuffer[4]&lt;&lt;7)&amp;0x80)|((inbuffer[5]&gt;&gt;9)&amp;0x7f);
-  *(ptr++)=(inbuffer[5]&gt;&gt;2)&amp;0x7f;
-  *(ptr++)=((inbuffer[5]&lt;&lt;5)&amp;0x60)|((inbuffer[6]&gt;&gt;11)&amp;0x1f);
-  *(ptr++)=(inbuffer[6]&gt;&gt;4)&amp;0x7f;
-  *(ptr++)=((inbuffer[6]&lt;&lt;4)&amp;0xf0)|((inbuffer[7]&gt;&gt;12)&amp;0xf);
-  *(ptr++)=(inbuffer[7]&gt;&gt;5)&amp;0x7f;
-  *(ptr++)=((inbuffer[7]&lt;&lt;2)&amp;0x7c)|((inbuffer[8]&gt;&gt;14)&amp;3);
-  *(ptr++)=(inbuffer[8]&gt;&gt;7)&amp;0x7f;
-  *(ptr++)=((inbuffer[8]&lt;&lt;1)&amp;0xfe)|((inbuffer[9]&gt;&gt;15)&amp;1);
-  *(ptr++)=(inbuffer[9]&gt;&gt;8)&amp;0x7f;
-  *(ptr++)=(inbuffer[9]&gt;&gt;1)&amp;0x7f;
+        if (res == 0)
+            return 0;
 
-  *(output++)=outbuffer[11];
-  for (x=1;x&lt;11;*(output++)=outbuffer[x++]);
-  ptr=outbuffer+12;
-  for (x=0;x&lt;16;x+=4)
-  {
-    *(output++)=ptr[x];
-    *(output++)=ptr[x+2];
-    *(output++)=ptr[x+3];
-    *(output++)=ptr[x+1];    
-  }
+        while (res &lt;= 0x3fff) {
+            b++;
+            res &lt;&lt;= 2;
+        }
+    }
+
+    return t_sqrt(res) &gt;&gt; b;
 }
 
-static unsigned int rms(int *data, int f)
+static void do_output_subblock(RA144Context *ractx, const uint16_t  *lpc_coefs,
+                               int gval, GetBitContext *gb)
 {
-  int *c;
-  int x;
-  unsigned int res;
-  int b;
+    uint16_t buffer_a[40];
+    uint16_t *block;
+    int cba_idx = get_bits(gb, 7); // index of the adaptive CB, 0 if none
+    int gain    = get_bits(gb, 8);
+    int cb1_idx = get_bits(gb, 7);
+    int cb2_idx = get_bits(gb, 7);
+    int m[3];
 
-  c=data;
-  b=0;
-  res=0x10000;
-  for (x=0;x&lt;10;x++)
-  {
-    res=(((0x1000000-(*c)*(*c))&gt;&gt;12)*res)&gt;&gt;12;
-    if (res==0) return 0;
-    if (res&lt;=0x3fff)
-    {
-      while (res&lt;=0x3fff)
-      {
-        b++;
-        res&lt;&lt;=2;
-      }
+    if (cba_idx) {
+        cba_idx += BLOCKSIZE/2 - 1;
+        copy_and_dup(buffer_a, ractx-&gt;adapt_cb, cba_idx);
+        m[0] = (irms(buffer_a) * gval) &gt;&gt; 12;
     } else {
-      if (res&gt;0x10000)
-        return 0; /* We're screwed, might as well go out with a bang. :P */
+        m[0] = 0;
     }
-    c++;
-  }
-  if (res&gt;0) res=t_sqrt(res);
 
-  res&gt;&gt;=(b+10);
-  res=(res*f)&gt;&gt;10;
-  return res;
+    m[1] = (cb1_base[cb1_idx] * gval) &gt;&gt; 8;
+    m[2] = (cb2_base[cb2_idx] * gval) &gt;&gt; 8;
+
+    memmove(ractx-&gt;adapt_cb, ractx-&gt;adapt_cb + BLOCKSIZE,
+            (BUFFERSIZE - BLOCKSIZE) * sizeof(*ractx-&gt;adapt_cb));
+
+    block = ractx-&gt;adapt_cb + BUFFERSIZE - BLOCKSIZE;
+
+    add_wav(block, gain, cba_idx, m, buffer_a,
+            cb1_vects[cb1_idx], cb2_vects[cb2_idx]);
+
+    memcpy(ractx-&gt;curr_sblock, ractx-&gt;curr_sblock + 40,
+           10*sizeof(*ractx-&gt;curr_sblock));
+
+    if (ff_acelp_lp_synthesis_filter(ractx-&gt;curr_sblock + 10, lpc_coefs,
+                                     block, BLOCKSIZE, 10, 1, 0xfff))
+        memset(ractx-&gt;curr_sblock, 0, 50*sizeof(*ractx-&gt;curr_sblock));
 }
 
-static void dec1(Real144_internal *glob, int *data, int *inp, int n, int f)
+static void int_to_int16(int16_t *out, const int *inp)
 {
-  short *ptr,*end;
+    int i;
 
-  *(glob-&gt;decptr++)=rms(data,f);
-  glob-&gt;decptr++;
-  end=(ptr=glob-&gt;decsp)+(n*10);
-  while (ptr&lt;end) *(ptr++)=*(inp++);
+    for (i=0; i &lt; 30; i++)
+        *(out++) = *(inp++);
 }
 
-static int eq(Real144_internal *glob, short *in, int *target)
+/**
+ * Evaluate the reflection coefficients from the filter coefficients.
+ * Does the inverse of the eval_coefs() function.
+ *
+ * @return 1 if one of the reflection coefficients is of magnitude greater than
+ *         4095, 0 if not.
+ */
+static int eval_refl(int *refl, const int16_t *coefs, RA144Context *ractx)
 {
-  int retval;
-  int a;
-  int b;
-  int c;
-  unsigned int u;
-  short *sptr;
-  int *ptr1,*ptr2,*ptr3;
-  int *bp1,*bp2,*temp;
+    int b, i, j;
+    int buffer1[10];
+    int buffer2[10];
+    int *bp1 = buffer1;
+    int *bp2 = buffer2;
 
-  retval=0;
-  bp1=glob-&gt;buffer1;
-  bp2=glob-&gt;buffer2;
-  ptr2=(ptr3=glob-&gt;buffer2)+9;
-  sptr=in;
-  while (ptr2&gt;=ptr3)
-    *(ptr3++)=*(sptr++);
+    for (i=0; i &lt; 10; i++)
+        buffer2[i] = coefs[i];
 
-  target+=9;
-  a=bp2[9];
-  *target=a;
-  if (a+0x1000&gt;0x1fff)
-    return 0; /* We're screwed, might as well go out with a bang. :P */
-  c=8;u=a;
-  while (c&gt;=0)
-  {
-    if (u==0x1000) u++;
-    if (u==0xfffff000) u--;
-    b=0x1000-((u*u)&gt;&gt;12);
-    if (b==0) b++;
-    ptr2=bp1;
-    ptr1=(ptr3=bp2)+c;
-    for (u=0;u&lt;=c;u++)
-      *(ptr2++)=((*(ptr3++)-(((*target)*(*(ptr1--)))&gt;&gt;12))*(0x1000000/b))&gt;&gt;12;
-    *(--target)=u=bp1[(c--)];
-    if ((u+0x1000)&gt;0x1fff) retval=1;
-    temp=bp2;
-    bp2=bp1;
-    bp1=temp;
-  }
-  return retval;
+    refl[9] = bp2[9];
+
+    if ((unsigned) bp2[9] + 0x1000 &gt; 0x1fff) {
+        av_log(ractx, AV_LOG_ERROR, &quot;Overflow. Broken sample?\n&quot;);
+        return 1;
+    }
+
+    for (i=8; i &gt;= 0; i--) {
+        b = 0x1000-((bp2[i+1] * bp2[i+1]) &gt;&gt; 12);
+
+        if (!b)
+            b = -2;
+
+        for (j=0; j &lt;= i; j++)
+            bp1[j] = ((bp2[j] - ((refl[i+1] * bp2[i-j]) &gt;&gt; 12)) * (0x1000000 / b)) &gt;&gt; 12;
+
+        refl[i] = bp1[i];
+
+        if ((unsigned) bp1[i] + 0x1000 &gt; 0x1fff)
+            return 1;
+
+        FFSWAP(int *, bp1, bp2);
+    }
+    return 0;
 }
 
-static void dec2(Real144_internal *glob, int *data, int *inp, int n, int f, int *inp2, int l)
+static int interp(RA144Context *ractx, int16_t *out, int block_num,
+                  int copyold, int energy)
 {
-  unsigned int *ptr1,*ptr2;
-  int work[10];
-  int a,b;
-  int x;
-  int result;
+    int work[10];
+    int a = block_num + 1;
+    int b = NBLOCKS - a;
+    int i;
 
-  if(l+1&lt;NBLOCKS/2) a=NBLOCKS-(l+1);
-  else a=l+1;
-  b=NBLOCKS-a;
-  if (l==0)
-  {
-    glob-&gt;decsp=glob-&gt;sptr=glob-&gt;gbuf2;
-    glob-&gt;decptr=glob-&gt;gbuf1;
-  }
-  ptr1=inp;
-  ptr2=inp2;
-  for (x=0;x&lt;10*n;x++)
-    *(glob-&gt;sptr++)=(a*(*ptr1++)+b*(*ptr2++))&gt;&gt;2;
-  result=eq(glob,glob-&gt;decsp,work);
-  if (result==1)
-  {
-    dec1(glob,data,inp,n,f);
-  } else {
-    *(glob-&gt;decptr++)=rms(work,f);
-    glob-&gt;decptr++;
-  }
-  glob-&gt;decsp+=n*10;
+    // Interpolate block coefficients from the this frame forth block and
+    // last frame forth block
+    for (i=0; i&lt;30; i++)
+        out[i] = (a * ractx-&gt;lpc_coef[0][i] + b * ractx-&gt;lpc_coef[1][i])&gt;&gt; 2;
+
+    if (eval_refl(work, out, ractx)) {
+        // The interpolated coefficients are unstable, copy either new or old
+        // coefficients
+        int_to_int16(out, ractx-&gt;lpc_coef[copyold]);
+        return rescale_rms(ractx-&gt;lpc_refl_rms[copyold], energy);
+    } else {
+        return rescale_rms(rms(work), energy);
+    }
 }
 
-/* Uncompress one block (20 bytes -&gt; 160*2 bytes) */
-static int ra144_decode_frame(AVCodecContext * avctx,
-            void *data, int *data_size,
-            uint8_t * buf, int buf_size)
+/** Uncompress one block (20 bytes -&gt; 160*2 bytes) */
+static int ra144_decode_frame(AVCodecContext * avctx, void *vdata,
+                              int *data_size, const uint8_t *buf, int buf_size)
 {
-  unsigned int a,b,c;
-  long s;
-  signed short *shptr;
-  unsigned int *lptr,*temp;
-  const short **dptr;
-  void *datao;
-  Real144_internal *glob=avctx-&gt;priv_data;
+    static const uint8_t sizes[10] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};
+    unsigned int refl_rms[4];    // RMS of the reflection coefficients
+    uint16_t block_coefs[4][30]; // LPC coefficients of each sub-block
+    unsigned int lpc_refl[10];   // LPC reflection coefficients of the frame
+    int i, j;
+    int16_t *data = vdata;
+    unsigned int energy;
 
-  datao = data;
-  unpack_input(buf,glob-&gt;unpacked);
-  
-  glob-&gt;iptr=glob-&gt;unpacked;
-  glob-&gt;val=decodetable[0][(*(glob-&gt;iptr++))&lt;&lt;1];
+    RA144Context *ractx = avctx-&gt;priv_data;
+    GetBitContext gb;
 
-  dptr=decodetable+1;
-  lptr=glob-&gt;swapbuf1;
-  while (lptr&lt;glob-&gt;swapbuf1+10)
-    *(lptr++)=(*(dptr++))[(*(glob-&gt;iptr++))&lt;&lt;1];
+    if (*data_size &lt; 2*160)
+        return -1;
 
-  do_voice(glob-&gt;swapbuf1,glob-&gt;swapbuf2);
+    if(buf_size &lt; 20) {
+        av_log(avctx, AV_LOG_ERROR,
+               &quot;Frame too small (%d bytes). Truncated file?\n&quot;, buf_size);
+        *data_size = 0;
+        return buf_size;
+    }
+    init_get_bits(&amp;gb, buf, 20 * 8);
 
-  a=t_sqrt(glob-&gt;val*glob-&gt;oldval)&gt;&gt;12;
+    for (i=0; i&lt;10; i++)
+        lpc_refl[i] = lpc_refl_cb[i][get_bits(&amp;gb, sizes[i])];
 
-  for (c=0;c&lt;NBLOCKS;c++) {
-    if (c==(NBLOCKS-1)) {
-      dec1(glob,glob-&gt;swapbuf1,glob-&gt;swapbuf2,3,glob-&gt;val);
-    } else {
-      if (c*2==(NBLOCKS-2)) {
-        if (glob-&gt;oldval&lt;glob-&gt;val) {
-          dec2(glob,glob-&gt;swapbuf1,glob-&gt;swapbuf2,3,a,glob-&gt;swapbuf2alt,c);
-        } else {
-          dec2(glob,glob-&gt;swapbuf1alt,glob-&gt;swapbuf2alt,3,a,glob-&gt;swapbuf2,c);
-        }
-      } else {
-        if (c*2&lt;(NBLOCKS-2)) {
-          dec2(glob,glob-&gt;swapbuf1alt,glob-&gt;swapbuf2alt,3,glob-&gt;oldval,glob-&gt;swapbuf2,c);
-        } else {
-          dec2(glob,glob-&gt;swapbuf1,glob-&gt;swapbuf2,3,glob-&gt;val,glob-&gt;swapbuf2alt,c);
-        }
-      }
-    }
-  }
+    eval_coefs(ractx-&gt;lpc_coef[0], lpc_refl);
+    ractx-&gt;lpc_refl_rms[0] = rms(lpc_refl);
 
-  /* do output */
-  for (b=0,c=0;c&lt;4;c++) {
-    glob-&gt;gval=glob-&gt;gbuf1[c*2];
-    glob-&gt;gsp=glob-&gt;gbuf2+b;
-    do_output_subblock(glob,glob-&gt;resetflag);
-    glob-&gt;resetflag=0;
+    energy = energy_tab[get_bits(&amp;gb, 5)];
 
-    shptr=glob-&gt;output_buffer;
-    while (shptr&lt;glob-&gt;output_buffer+BLOCKSIZE) {
-      s=*(shptr++)&lt;&lt;2;
-      *((int16_t *)data)=s;
-      if (s&gt;32767) *((int16_t *)data)=32767;
-      if (s&lt;-32767) *((int16_t *)data)=-32768;
-      data = (int16_t *)data + 1;
+    refl_rms[0] = interp(ractx, block_coefs[0], 0, 1, ractx-&gt;old_energy);
+    refl_rms[1] = interp(ractx, block_coefs[1], 1, energy &lt;= ractx-&gt;old_energy,
+                    t_sqrt(energy*ractx-&gt;old_energy) &gt;&gt; 12);
+    refl_rms[2] = interp(ractx, block_coefs[2], 2, 0, energy);
+    refl_rms[3] = rescale_rms(ractx-&gt;lpc_refl_rms[0], energy);
+
+    int_to_int16(block_coefs[3], ractx-&gt;lpc_coef[0]);
+
+    for (i=0; i &lt; 4; i++) {
+        do_output_subblock(ractx, block_coefs[i], refl_rms[i], &amp;gb);
+
+        for (j=0; j &lt; BLOCKSIZE; j++)
+            *data++ = av_clip_int16(ractx-&gt;curr_sblock[j + 10] &lt;&lt; 2);
     }
-    b+=30;
-  }
 
-  glob-&gt;oldval=glob-&gt;val;
-  temp=glob-&gt;swapbuf1alt;
-  glob-&gt;swapbuf1alt=glob-&gt;swapbuf1;
-  glob-&gt;swapbuf1=temp;
-  temp=glob-&gt;swapbuf2alt;
-  glob-&gt;swapbuf2alt=glob-&gt;swapbuf2;
-  glob-&gt;swapbuf2=temp;
-  *data_size=data-datao;
-  return 20;
-}
+    ractx-&gt;old_energy = energy;
+    ractx-&gt;lpc_refl_rms[1] = ractx-&gt;lpc_refl_rms[0];
 
+    FFSWAP(unsigned int *, ractx-&gt;lpc_coef[0], ractx-&gt;lpc_coef[1]);
 
+    *data_size = 2*160;
+    return 20;
+}
+
 AVCodec ra_144_decoder =
 {
     &quot;real_144&quot;,
     CODEC_TYPE_AUDIO,
     CODEC_ID_RA_144,
-    sizeof(Real144_internal),
+    sizeof(RA144Context),
     ra144_decode_init,
     NULL,
     NULL,
     ra144_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;RealAudio 1.0 (14.4K)&quot;),
 };

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.h	2008-09-15 14:11:26 UTC (rev 27561)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ra144.h	2008-09-15 14:12:05 UTC (rev 27562)
@@ -2,2425 +2,1554 @@
  * Real Audio 1.0 (14.4K)
  * Copyright (c) 2003 the ffmpeg project
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef RA144TABLES_H
-#define RA144TABLES_H
+#ifndef FFMPEG_RA144_H
+#define FFMPEG_RA144_H
 
+#include &lt;stdint.h&gt;
+
 /* 14.4 data tables */
-static const unsigned short sqrt_table[4096]={
-0x0000,0x0400,0x05a8,0x06ed,0x0800,0x08f1,0x09cc,0x0a95,
-0x0b50,0x0c00,0x0ca6,0x0d44,0x0ddb,0x0e6c,0x0ef7,0x0f7d,
-0x1000,0x107e,0x10f8,0x116f,0x11e3,0x1254,0x12c2,0x132e,
-0x1398,0x1400,0x1465,0x14c8,0x152a,0x158a,0x15e8,0x1645,
-0x16a0,0x16fa,0x1752,0x17aa,0x1800,0x1854,0x18a8,0x18fa,
-0x194c,0x199c,0x19ec,0x1a3a,0x1a88,0x1ad5,0x1b21,0x1b6c,
-0x1bb6,0x1c00,0x1c48,0x1c90,0x1cd8,0x1d1e,0x1d64,0x1daa,
-0x1dee,0x1e33,0x1e76,0x1eb9,0x1efb,0x1f3d,0x1f7e,0x1fbf,
-0x2000,0x203f,0x207f,0x20bd,0x20fc,0x2139,0x2177,0x21b4,
-0x21f0,0x222d,0x2268,0x22a4,0x22df,0x2319,0x2353,0x238d,
-0x23c6,0x2400,0x2438,0x2471,0x24a9,0x24e0,0x2518,0x254f,
-0x2585,0x25bc,0x25f2,0x2628,0x265d,0x2693,0x26c8,0x26fc,
-0x2731,0x2765,0x2799,0x27cc,0x2800,0x2833,0x2865,0x2898,
-0x28ca,0x28fc,0x292e,0x2960,0x2991,0x29c2,0x29f3,0x2a24,
-0x2a54,0x2a85,0x2ab5,0x2ae5,0x2b14,0x2b44,0x2b73,0x2ba2,
-0x2bd1,0x2c00,0x2c2e,0x2c5c,0x2c8a,0x2cb8,0x2ce6,0x2d13,
-0x2d41,0x2d6e,0x2d9b,0x2dc8,0x2df4,0x2e21,0x2e4d,0x2e79,
-0x2ea5,0x2ed1,0x2efd,0x2f28,0x2f54,0x2f7f,0x2faa,0x2fd5,
-0x3000,0x302a,0x3055,0x307f,0x30a9,0x30d3,0x30fd,0x3127,
-0x3150,0x317a,0x31a3,0x31cc,0x31f5,0x321e,0x3247,0x3270,
-0x3298,0x32c1,0x32e9,0x3311,0x3339,0x3361,0x3389,0x33b0,
-0x33d8,0x3400,0x3427,0x344e,0x3475,0x349c,0x34c3,0x34ea,
-0x3510,0x3537,0x355d,0x3584,0x35aa,0x35d0,0x35f6,0x361c,
-0x3642,0x3667,0x368d,0x36b2,0x36d8,0x36fd,0x3722,0x3747,
-0x376c,0x3791,0x37b6,0x37db,0x3800,0x3824,0x3848,0x386d,
-0x3891,0x38b5,0x38d9,0x38fd,0x3921,0x3945,0x3969,0x398c,
-0x39b0,0x39d3,0x39f7,0x3a1a,0x3a3d,0x3a60,0x3a83,0x3aa6,
-0x3ac9,0x3aec,0x3b0f,0x3b31,0x3b54,0x3b76,0x3b99,0x3bbb,
-0x3bdd,0x3c00,0x3c22,0x3c44,0x3c66,0x3c87,0x3ca9,0x3ccb,
-0x3ced,0x3d0e,0x3d30,0x3d51,0x3d72,0x3d94,0x3db5,0x3dd6,
-0x3df7,0x3e18,0x3e39,0x3e5a,0x3e7b,0x3e9c,0x3ebc,0x3edd,
-0x3efd,0x3f1e,0x3f3e,0x3f5f,0x3f7f,0x3f9f,0x3fbf,0x3fdf,
-0x4000,0x401f,0x403f,0x405f,0x407f,0x409f,0x40be,0x40de,
-0x40fe,0x411d,0x413c,0x415c,0x417b,0x419a,0x41ba,0x41d9,
-0x41f8,0x4217,0x4236,0x4255,0x4273,0x4292,0x42b1,0x42d0,
-0x42ee,0x430d,0x432b,0x434a,0x4368,0x4387,0x43a5,0x43c3,
-0x43e1,0x4400,0x441e,0x443c,0x445a,0x4478,0x4495,0x44b3,
-0x44d1,0x44ef,0x450c,0x452a,0x4548,0x4565,0x4583,0x45a0,
-0x45be,0x45db,0x45f8,0x4615,0x4633,0x4650,0x466d,0x468a,
-0x46a7,0x46c4,0x46e1,0x46fe,0x471b,0x4737,0x4754,0x4771,
-0x478d,0x47aa,0x47c7,0x47e3,0x4800,0x481c,0x4838,0x4855,
-0x4871,0x488d,0x48a9,0x48c6,0x48e2,0x48fe,0x491a,0x4936,
-0x4952,0x496e,0x498a,0x49a5,0x49c1,0x49dd,0x49f9,0x4a14,
-0x4a30,0x4a4b,0x4a67,0x4a83,0x4a9e,0x4ab9,0x4ad5,0x4af0,
-0x4b0b,0x4b27,0x4b42,0x4b5d,0x4b78,0x4b93,0x4bae,0x4bca,
-0x4be5,0x4c00,0x4c1a,0x4c35,0x4c50,0x4c6b,0x4c86,0x4ca1,
-0x4cbb,0x4cd6,0x4cf1,0x4d0b,0x4d26,0x4d40,0x4d5b,0x4d75,
-0x4d90,0x4daa,0x4dc4,0x4ddf,0x4df9,0x4e13,0x4e2d,0x4e48,
-0x4e62,0x4e7c,0x4e96,0x4eb0,0x4eca,0x4ee4,0x4efe,0x4f18,
-0x4f32,0x4f4c,0x4f65,0x4f7f,0x4f99,0x4fb3,0x4fcc,0x4fe6,
-0x5000,0x5019,0x5033,0x504c,0x5066,0x507f,0x5099,0x50b2,
-0x50cb,0x50e5,0x50fe,0x5117,0x5130,0x514a,0x5163,0x517c,
-0x5195,0x51ae,0x51c7,0x51e0,0x51f9,0x5212,0x522b,0x5244,
-0x525d,0x5276,0x528f,0x52a7,0x52c0,0x52d9,0x52f2,0x530a,
-0x5323,0x533c,0x5354,0x536d,0x5385,0x539e,0x53b6,0x53cf,
-0x53e7,0x5400,0x5418,0x5430,0x5449,0x5461,0x5479,0x5491,
-0x54a9,0x54c2,0x54da,0x54f2,0x550a,0x5522,0x553a,0x5552,
-0x556a,0x5582,0x559a,0x55b2,0x55ca,0x55e2,0x55fa,0x5611,
-0x5629,0x5641,0x5659,0x5670,0x5688,0x56a0,0x56b7,0x56cf,
-0x56e6,0x56fe,0x5716,0x572d,0x5745,0x575c,0x5773,0x578b,
-0x57a2,0x57ba,0x57d1,0x57e8,0x5800,0x5817,0x582e,0x5845,
-0x585c,0x5874,0x588b,0x58a2,0x58b9,0x58d0,0x58e7,0x58fe,
-0x5915,0x592c,0x5943,0x595a,0x5971,0x5988,0x599f,0x59b5,
-0x59cc,0x59e3,0x59fa,0x5a11,0x5a27,0x5a3e,0x5a55,0x5a6b,
-0x5a82,0x5a99,0x5aaf,0x5ac6,0x5adc,0x5af3,0x5b09,0x5b20,
-0x5b36,0x5b4d,0x5b63,0x5b7a,0x5b90,0x5ba6,0x5bbd,0x5bd3,
-0x5be9,0x5c00,0x5c16,0x5c2c,0x5c42,0x5c58,0x5c6f,0x5c85,
-0x5c9b,0x5cb1,0x5cc7,0x5cdd,0x5cf3,0x5d09,0x5d1f,0x5d35,
-0x5d4b,0x5d61,0x5d77,0x5d8d,0x5da3,0x5db9,0x5dce,0x5de4,
-0x5dfa,0x5e10,0x5e26,0x5e3b,0x5e51,0x5e67,0x5e7c,0x5e92,
-0x5ea8,0x5ebd,0x5ed3,0x5ee9,0x5efe,0x5f14,0x5f29,0x5f3f,
-0x5f54,0x5f6a,0x5f7f,0x5f95,0x5faa,0x5fbf,0x5fd5,0x5fea,
-0x6000,0x6015,0x602a,0x603f,0x6055,0x606a,0x607f,0x6094,
-0x60aa,0x60bf,0x60d4,0x60e9,0x60fe,0x6113,0x6128,0x613d,
-0x6152,0x6168,0x617d,0x6192,0x61a7,0x61bb,0x61d0,0x61e5,
-0x61fa,0x620f,0x6224,0x6239,0x624e,0x6263,0x6277,0x628c,
-0x62a1,0x62b6,0x62ca,0x62df,0x62f4,0x6309,0x631d,0x6332,
-0x6347,0x635b,0x6370,0x6384,0x6399,0x63ad,0x63c2,0x63d7,
-0x63eb,0x6400,0x6414,0x6428,0x643d,0x6451,0x6466,0x647a,
-0x648e,0x64a3,0x64b7,0x64cb,0x64e0,0x64f4,0x6508,0x651d,
-0x6531,0x6545,0x6559,0x656e,0x6582,0x6596,0x65aa,0x65be,
-0x65d2,0x65e6,0x65fa,0x660f,0x6623,0x6637,0x664b,0x665f,
-0x6673,0x6687,0x669b,0x66af,0x66c3,0x66d6,0x66ea,0x66fe,
-0x6712,0x6726,0x673a,0x674e,0x6761,0x6775,0x6789,0x679d,
-0x67b1,0x67c4,0x67d8,0x67ec,0x6800,0x6813,0x6827,0x683b,
-0x684e,0x6862,0x6875,0x6889,0x689d,0x68b0,0x68c4,0x68d7,
-0x68eb,0x68fe,0x6912,0x6925,0x6939,0x694c,0x6960,0x6973,
-0x6986,0x699a,0x69ad,0x69c1,0x69d4,0x69e7,0x69fb,0x6a0e,
-0x6a21,0x6a35,0x6a48,0x6a5b,0x6a6e,0x6a82,0x6a95,0x6aa8,
-0x6abb,0x6ace,0x6ae2,0x6af5,0x6b08,0x6b1b,0x6b2e,0x6b41,
-0x6b54,0x6b67,0x6b7a,0x6b8d,0x6ba1,0x6bb4,0x6bc7,0x6bda,
-0x6bed,0x6c00,0x6c12,0x6c25,0x6c38,0x6c4b,0x6c5e,0x6c71,
-0x6c84,0x6c97,0x6caa,0x6cbc,0x6ccf,0x6ce2,0x6cf5,0x6d08,
-0x6d1a,0x6d2d,0x6d40,0x6d53,0x6d65,0x6d78,0x6d8b,0x6d9e,
-0x6db0,0x6dc3,0x6dd6,0x6de8,0x6dfb,0x6e0d,0x6e20,0x6e33,
-0x6e45,0x6e58,0x6e6a,0x6e7d,0x6e8f,0x6ea2,0x6eb4,0x6ec7,
-0x6ed9,0x6eec,0x6efe,0x6f11,0x6f23,0x6f36,0x6f48,0x6f5a,
-0x6f6d,0x6f7f,0x6f92,0x6fa4,0x6fb6,0x6fc9,0x6fdb,0x6fed,
-0x7000,0x7012,0x7024,0x7036,0x7049,0x705b,0x706d,0x707f,
-0x7091,0x70a4,0x70b6,0x70c8,0x70da,0x70ec,0x70fe,0x7110,
-0x7123,0x7135,0x7147,0x7159,0x716b,0x717d,0x718f,0x71a1,
-0x71b3,0x71c5,0x71d7,0x71e9,0x71fb,0x720d,0x721f,0x7231,
-0x7243,0x7255,0x7267,0x7279,0x728a,0x729c,0x72ae,0x72c0,
-0x72d2,0x72e4,0x72f5,0x7307,0x7319,0x732b,0x733d,0x734e,
-0x7360,0x7372,0x7384,0x7395,0x73a7,0x73b9,0x73ca,0x73dc,
-0x73ee,0x7400,0x7411,0x7423,0x7434,0x7446,0x7458,0x7469,
-0x747b,0x748c,0x749e,0x74b0,0x74c1,0x74d3,0x74e4,0x74f6,
-0x7507,0x7519,0x752a,0x753c,0x754d,0x755f,0x7570,0x7581,
-0x7593,0x75a4,0x75b6,0x75c7,0x75d8,0x75ea,0x75fb,0x760d,
-0x761e,0x762f,0x7641,0x7652,0x7663,0x7674,0x7686,0x7697,
-0x76a8,0x76ba,0x76cb,0x76dc,0x76ed,0x76fe,0x7710,0x7721,
-0x7732,0x7743,0x7754,0x7766,0x7777,0x7788,0x7799,0x77aa,
-0x77bb,0x77cc,0x77dd,0x77ee,0x7800,0x7811,0x7822,0x7833,
-0x7844,0x7855,0x7866,0x7877,0x7888,0x7899,0x78aa,0x78bb,
-0x78cc,0x78dd,0x78ee,0x78fe,0x790f,0x7920,0x7931,0x7942,
-0x7953,0x7964,0x7975,0x7986,0x7996,0x79a7,0x79b8,0x79c9,
-0x79da,0x79eb,0x79fb,0x7a0c,0x7a1d,0x7a2e,0x7a3e,0x7a4f,
-0x7a60,0x7a71,0x7a81,0x7a92,0x7aa3,0x7ab3,0x7ac4,0x7ad5,
-0x7ae5,0x7af6,0x7b07,0x7b17,0x7b28,0x7b39,0x7b49,0x7b5a,
-0x7b6b,0x7b7b,0x7b8c,0x7b9c,0x7bad,0x7bbd,0x7bce,0x7bde,
-0x7bef,0x7c00,0x7c10,0x7c21,0x7c31,0x7c41,0x7c52,0x7c62,
-0x7c73,0x7c83,0x7c94,0x7ca4,0x7cb5,0x7cc5,0x7cd5,0x7ce6,
-0x7cf6,0x7d07,0x7d17,0x7d27,0x7d38,0x7d48,0x7d58,0x7d69,
-0x7d79,0x7d89,0x7d9a,0x7daa,0x7dba,0x7dcb,0x7ddb,0x7deb,
-0x7dfb,0x7e0c,0x7e1c,0x7e2c,0x7e3c,0x7e4d,0x7e5d,0x7e6d,
-0x7e7d,0x7e8d,0x7e9e,0x7eae,0x7ebe,0x7ece,0x7ede,0x7eee,
-0x7efe,0x7f0f,0x7f1f,0x7f2f,0x7f3f,0x7f4f,0x7f5f,0x7f6f,
-0x7f7f,0x7f8f,0x7f9f,0x7faf,0x7fbf,0x7fcf,0x7fdf,0x7fef,
-0x8000,0x800f,0x801f,0x802f,0x803f,0x804f,0x805f,0x806f,
-0x807f,0x808f,0x809f,0x80af,0x80bf,0x80cf,0x80df,0x80ef,
-0x80ff,0x810e,0x811e,0x812e,0x813e,0x814e,0x815e,0x816d,
-0x817d,0x818d,0x819d,0x81ad,0x81bc,0x81cc,0x81dc,0x81ec,
-0x81fc,0x820b,0x821b,0x822b,0x823b,0x824a,0x825a,0x826a,
-0x8279,0x8289,0x8299,0x82a8,0x82b8,0x82c8,0x82d7,0x82e7,
-0x82f7,0x8306,0x8316,0x8326,0x8335,0x8345,0x8354,0x8364,
-0x8374,0x8383,0x8393,0x83a2,0x83b2,0x83c1,0x83d1,0x83e0,
-0x83f0,0x8400,0x840f,0x841f,0x842e,0x843e,0x844d,0x845c,
-0x846c,0x847b,0x848b,0x849a,0x84aa,0x84b9,0x84c9,0x84d8,
-0x84e7,0x84f7,0x8506,0x8516,0x8525,0x8534,0x8544,0x8553,
-0x8562,0x8572,0x8581,0x8591,0x85a0,0x85af,0x85be,0x85ce,
-0x85dd,0x85ec,0x85fc,0x860b,0x861a,0x862a,0x8639,0x8648,
-0x8657,0x8667,0x8676,0x8685,0x8694,0x86a3,0x86b3,0x86c2,
-0x86d1,0x86e0,0x86ef,0x86ff,0x870e,0x871d,0x872c,0x873b,
-0x874a,0x8759,0x8769,0x8778,0x8787,0x8796,0x87a5,0x87b4,
-0x87c3,0x87d2,0x87e1,0x87f0,0x8800,0x880f,0x881e,0x882d,
-0x883c,0x884b,0x885a,0x8869,0x8878,0x8887,0x8896,0x88a5,
-0x88b4,0x88c3,0x88d2,0x88e1,0x88f0,0x88ff,0x890e,0x891c,
-0x892b,0x893a,0x8949,0x8958,0x8967,0x8976,0x8985,0x8994,
-0x89a3,0x89b2,0x89c0,0x89cf,0x89de,0x89ed,0x89fc,0x8a0b,
-0x8a19,0x8a28,0x8a37,0x8a46,0x8a55,0x8a64,0x8a72,0x8a81,
-0x8a90,0x8a9f,0x8aad,0x8abc,0x8acb,0x8ada,0x8ae8,0x8af7,
-0x8b06,0x8b15,0x8b23,0x8b32,0x8b41,0x8b50,0x8b5e,0x8b6d,
-0x8b7c,0x8b8a,0x8b99,0x8ba8,0x8bb6,0x8bc5,0x8bd4,0x8be2,
-0x8bf1,0x8c00,0x8c0e,0x8c1d,0x8c2b,0x8c3a,0x8c49,0x8c57,
-0x8c66,0x8c74,0x8c83,0x8c91,0x8ca0,0x8caf,0x8cbd,0x8ccc,
-0x8cda,0x8ce9,0x8cf7,0x8d06,0x8d14,0x8d23,0x8d31,0x8d40,
-0x8d4e,0x8d5d,0x8d6b,0x8d7a,0x8d88,0x8d97,0x8da5,0x8db4,
-0x8dc2,0x8dd1,0x8ddf,0x8ded,0x8dfc,0x8e0a,0x8e19,0x8e27,
-0x8e36,0x8e44,0x8e52,0x8e61,0x8e6f,0x8e7d,0x8e8c,0x8e9a,
-0x8ea9,0x8eb7,0x8ec5,0x8ed4,0x8ee2,0x8ef0,0x8eff,0x8f0d,
-0x8f1b,0x8f2a,0x8f38,0x8f46,0x8f54,0x8f63,0x8f71,0x8f7f,
-0x8f8e,0x8f9c,0x8faa,0x8fb8,0x8fc7,0x8fd5,0x8fe3,0x8ff1,
-0x9000,0x900e,0x901c,0x902a,0x9038,0x9047,0x9055,0x9063,
-0x9071,0x907f,0x908d,0x909c,0x90aa,0x90b8,0x90c6,0x90d4,
-0x90e2,0x90f0,0x90ff,0x910d,0x911b,0x9129,0x9137,0x9145,
-0x9153,0x9161,0x916f,0x917e,0x918c,0x919a,0x91a8,0x91b6,
-0x91c4,0x91d2,0x91e0,0x91ee,0x91fc,0x920a,0x9218,0x9226,
-0x9234,0x9242,0x9250,0x925e,0x926c,0x927a,0x9288,0x9296,
-0x92a4,0x92b2,0x92c0,0x92ce,0x92dc,0x92ea,0x92f8,0x9306,
-0x9314,0x9321,0x932f,0x933d,0x934b,0x9359,0x9367,0x9375,
-0x9383,0x9391,0x939f,0x93ac,0x93ba,0x93c8,0x93d6,0x93e4,
-0x93f2,0x9400,0x940d,0x941b,0x9429,0x9437,0x9445,0x9452,
-0x9460,0x946e,0x947c,0x948a,0x9497,0x94a5,0x94b3,0x94c1,
-0x94cf,0x94dc,0x94ea,0x94f8,0x9506,0x9513,0x9521,0x952f,
-0x953c,0x954a,0x9558,0x9566,0x9573,0x9581,0x958f,0x959c,
-0x95aa,0x95b8,0x95c5,0x95d3,0x95e1,0x95ee,0x95fc,0x960a,
-0x9617,0x9625,0x9633,0x9640,0x964e,0x965c,0x9669,0x9677,
-0x9684,0x9692,0x96a0,0x96ad,0x96bb,0x96c8,0x96d6,0x96e4,
-0x96f1,0x96ff,0x970c,0x971a,0x9727,0x9735,0x9742,0x9750,
-0x975d,0x976b,0x9779,0x9786,0x9794,0x97a1,0x97af,0x97bc,
-0x97ca,0x97d7,0x97e5,0x97f2,0x9800,0x980d,0x981a,0x9828,
-0x9835,0x9843,0x9850,0x985e,0x986b,0x9879,0x9886,0x9893,
-0x98a1,0x98ae,0x98bc,0x98c9,0x98d6,0x98e4,0x98f1,0x98ff,
-0x990c,0x9919,0x9927,0x9934,0x9942,0x994f,0x995c,0x996a,
-0x9977,0x9984,0x9992,0x999f,0x99ac,0x99ba,0x99c7,0x99d4,
-0x99e2,0x99ef,0x99fc,0x9a09,0x9a17,0x9a24,0x9a31,0x9a3f,
-0x9a4c,0x9a59,0x9a66,0x9a74,0x9a81,0x9a8e,0x9a9b,0x9aa9,
-0x9ab6,0x9ac3,0x9ad0,0x9ade,0x9aeb,0x9af8,0x9b05,0x9b12,
-0x9b20,0x9b2d,0x9b3a,0x9b47,0x9b54,0x9b62,0x9b6f,0x9b7c,
-0x9b89,0x9b96,0x9ba3,0x9bb1,0x9bbe,0x9bcb,0x9bd8,0x9be5,

[... truncated: 6497 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011871.html">[Haiku-commits] r27561 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011873.html">[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11872">[ date ]</a>
              <a href="thread.html#11872">[ thread ]</a>
              <a href="subject.html#11872">[ subject ]</a>
              <a href="author.html#11872">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
