<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27553 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27553%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151407.m8FE7LnM000614%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011862.html">
   <LINK REL="Next"  HREF="011864.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27553 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27553%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151407.m8FE7LnM000614%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27553 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:07:21 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011862.html">[Haiku-commits] r27552 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011864.html">[Haiku-commits] r27554 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11863">[ date ]</a>
              <a href="thread.html#11863">[ thread ]</a>
              <a href="subject.html#11863">[ subject ]</a>
              <a href="author.html#11863">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:07:20 +0200 (Mon, 15 Sep 2008)
New Revision: 27553
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27553&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27553&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xl.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xsubdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xvmc_render.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xan.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xvmcvideo.c
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xan.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xan.c	2008-09-15 14:07:05 UTC (rev 27552)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xan.c	2008-09-15 14:07:20 UTC (rev 27553)
@@ -2,30 +2,30 @@
  * Wing Commander/Xan Video Decoder
  * Copyright (C) 2003 the ffmpeg project
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file xan.c
- * Xan video decoder for Wing Commander III &amp; IV computer games
+ * Xan video decoder for Wing Commander III computer game
  * by Mario Brito (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">mbrito at student.dei.uc.pt</A>)
  * and Mike Melanson (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">melanson at pcisys.net</A>)
  *
- * The xan_wc3 decoder outputs the following colorspaces natively:
- *   PAL8 (default), RGB555, RGB565, RGB24, BGR24, RGBA32, YUV444P
+ * The xan_wc3 decoder outputs PAL8 data.
  */
 
 #include &lt;stdio.h&gt;
@@ -33,126 +33,61 @@
 #include &lt;string.h&gt;
 #include &lt;unistd.h&gt;
 
-#include &quot;common.h&quot;
 #include &quot;avcodec.h&quot;
-#include &quot;dsputil.h&quot;
 
-#define PALETTE_COUNT 256
-#define PALETTE_CONTROL_SIZE ((256 * 3) + 1)
-
 typedef struct XanContext {
 
     AVCodecContext *avctx;
-    DSPContext dsp;
     AVFrame last_frame;
     AVFrame current_frame;
 
-    unsigned char *buf;
+    const unsigned char *buf;
     int size;
 
-    unsigned char palette[PALETTE_COUNT * 4];
-
     /* scratch space */
     unsigned char *buffer1;
+    int buffer1_size;
     unsigned char *buffer2;
+    int buffer2_size;
 
+    int frame_size;
+
 } XanContext;
 
-#define BE_16(x)  ((((uint8_t*)(x))[0] &lt;&lt; 8) | ((uint8_t*)(x))[1])
-#define LE_16(x)  ((((uint8_t*)(x))[1] &lt;&lt; 8) | ((uint8_t*)(x))[0])
-#define LE_32(x)  ((((uint8_t*)(x))[3] &lt;&lt; 24) | \
-                   (((uint8_t*)(x))[2] &lt;&lt; 16) | \
-                   (((uint8_t*)(x))[1] &lt;&lt; 8) | \
-                    ((uint8_t*)(x))[0])
-
-/* RGB -&gt; YUV conversion stuff */
-#define SCALEFACTOR 65536
-#define CENTERSAMPLE 128
-
-#define COMPUTE_Y(r, g, b) \
-  (unsigned char) \
-  ((y_r_table[r] + y_g_table[g] + y_b_table[b]) / SCALEFACTOR)
-#define COMPUTE_U(r, g, b) \
-  (unsigned char) \
-  ((u_r_table[r] + u_g_table[g] + u_b_table[b]) / SCALEFACTOR + CENTERSAMPLE)
-#define COMPUTE_V(r, g, b) \
-  (unsigned char) \
-  ((v_r_table[r] + v_g_table[g] + v_b_table[b]) / SCALEFACTOR + CENTERSAMPLE)
-
-#define Y_R (SCALEFACTOR *  0.29900)
-#define Y_G (SCALEFACTOR *  0.58700)
-#define Y_B (SCALEFACTOR *  0.11400)
-
-#define U_R (SCALEFACTOR * -0.16874)
-#define U_G (SCALEFACTOR * -0.33126)
-#define U_B (SCALEFACTOR *  0.50000)
-
-#define V_R (SCALEFACTOR *  0.50000)
-#define V_G (SCALEFACTOR * -0.41869)
-#define V_B (SCALEFACTOR * -0.08131)
-
-/*
- * Precalculate all of the YUV tables since it requires fewer than
- * 10 kilobytes to store them.
- */
-static int y_r_table[256];
-static int y_g_table[256];
-static int y_b_table[256];
-
-static int u_r_table[256];
-static int u_g_table[256];
-static int u_b_table[256];
-
-static int v_r_table[256];
-static int v_g_table[256];
-static int v_b_table[256];
-
-static int xan_decode_init(AVCodecContext *avctx)
+static av_cold int xan_decode_init(AVCodecContext *avctx)
 {
     XanContext *s = avctx-&gt;priv_data;
-    int i;
 
     s-&gt;avctx = avctx;
+    s-&gt;frame_size = 0;
 
-    if ((avctx-&gt;codec-&gt;id == CODEC_ID_XAN_WC3) &amp;&amp; 
+    if ((avctx-&gt;codec-&gt;id == CODEC_ID_XAN_WC3) &amp;&amp;
         (s-&gt;avctx-&gt;palctrl == NULL)) {
         av_log(avctx, AV_LOG_ERROR, &quot; WC3 Xan video: palette expected.\n&quot;);
         return -1;
     }
 
     avctx-&gt;pix_fmt = PIX_FMT_PAL8;
-    avctx-&gt;has_b_frames = 0;
-    dsputil_init(&amp;s-&gt;dsp, avctx);
 
-    /* initialize the RGB -&gt; YUV tables */
-    for (i = 0; i &lt; 256; i++) {
-        y_r_table[i] = Y_R * i;
-        y_g_table[i] = Y_G * i;
-        y_b_table[i] = Y_B * i;
+    if(avcodec_check_dimensions(avctx, avctx-&gt;width, avctx-&gt;height))
+        return -1;
 
-        u_r_table[i] = U_R * i;
-        u_g_table[i] = U_G * i;
-        u_b_table[i] = U_B * i;
-
-        v_r_table[i] = V_R * i;
-        v_g_table[i] = V_G * i;
-        v_b_table[i] = V_B * i;
-    }
-
-    s-&gt;buffer1 = av_malloc(avctx-&gt;width * avctx-&gt;height);
-    s-&gt;buffer2 = av_malloc(avctx-&gt;width * avctx-&gt;height);
+    s-&gt;buffer1_size = avctx-&gt;width * avctx-&gt;height;
+    s-&gt;buffer1 = av_malloc(s-&gt;buffer1_size);
+    s-&gt;buffer2_size = avctx-&gt;width * avctx-&gt;height;
+    s-&gt;buffer2 = av_malloc(s-&gt;buffer2_size);
     if (!s-&gt;buffer1 || !s-&gt;buffer2)
         return -1;
 
     return 0;
 }
 
-/* This function is used in lieu of memcpy(). This decoder can not use 
+/* This function is used in lieu of memcpy(). This decoder cannot use
  * memcpy because the memory locations often overlap and
  * memcpy doesn't like that; it's not uncommon, for example, for
  * dest = src+1, to turn byte A into  pattern AAAAAAAA.
  * This was originally repz movsb in Intel x86 ASM. */
-static inline void bytecopy(unsigned char *dest, unsigned char *src, int count)
+static inline void bytecopy(unsigned char *dest, const unsigned char *src, int count)
 {
     int i;
 
@@ -160,13 +95,15 @@
         dest[i] = src[i];
 }
 
-static int xan_huffman_decode(unsigned char *dest, unsigned char *src)
+static int xan_huffman_decode(unsigned char *dest, const unsigned char *src,
+    int dest_len)
 {
     unsigned char byte = *src++;
     unsigned char ival = byte + 0x16;
-    unsigned char * ptr = src + byte*2;
+    const unsigned char * ptr = src + byte*2;
     unsigned char val = ival;
     int counter = 0;
+    unsigned char *dest_end = dest + dest_len;
 
     unsigned char bits = *ptr++;
 
@@ -177,6 +114,8 @@
             val = src[val - 0x17];
 
         if ( val &lt; 0x16 ) {
+            if (dest + 1 &gt; dest_end)
+                return 0;
             *dest++ = val;
             val = ival;
         }
@@ -190,12 +129,13 @@
     return 0;
 }
 
-static void xan_unpack(unsigned char *dest, unsigned char *src)
+static void xan_unpack(unsigned char *dest, const unsigned char *src, int dest_len)
 {
     unsigned char opcode;
     int size;
     int offset;
     int byte1, byte2, byte3;
+    unsigned char *dest_end = dest + dest_len;
 
     for (;;) {
         opcode = *src++;
@@ -205,9 +145,13 @@
             offset = *src++;
 
             size = opcode &amp; 3;
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy(dest, src, size);  dest += size;  src += size;
 
             size = ((opcode &amp; 0x1c) &gt;&gt; 2) + 3;
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest, dest - (((opcode &amp; 0x60) &lt;&lt; 3) + offset + 1), size);
             dest += size;
 
@@ -217,9 +161,13 @@
             byte2 = *src++;
 
             size = byte1 &gt;&gt; 6;
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest, src, size);  dest += size;  src += size;
 
             size = (opcode &amp; 0x3f) + 4;
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest, dest - (((byte1 &amp; 0x3f) &lt;&lt; 8) + byte2 + 1), size);
             dest += size;
 
@@ -230,9 +178,13 @@
             byte3 = *src++;
 
             size = opcode &amp; 3;
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest, src, size);  dest += size;  src += size;
 
             size = byte3 + 5 + ((opcode &amp; 0xc) &lt;&lt; 6);
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest,
                 dest - ((((opcode &amp; 0x10) &gt;&gt; 4) &lt;&lt; 0x10) + 1 + (byte1 &lt;&lt; 8) + byte2),
                 size);
@@ -243,6 +195,8 @@
             if (size &gt; 0x70)
                 break;
 
+            if (dest + size &gt; dest_end)
+                return;
             bytecopy (dest, src, size);  dest += size;  src += size;
         }
     }
@@ -251,232 +205,36 @@
     bytecopy(dest, src, size);  dest += size;  src += size;
 }
 
-static void inline xan_wc3_build_palette(XanContext *s, 
-    unsigned int *palette_data)
+static inline void xan_wc3_output_pixel_run(XanContext *s,
+    const unsigned char *pixel_buffer, int x, int y, int pixel_count)
 {
-    int i;
-    unsigned char r, g, b;
-    unsigned short *palette16;
-    unsigned int *palette32;
-    unsigned int pal_elem;
-
-    /* transform the palette passed through the palette control structure
-     * into the necessary internal format depending on colorspace */
-
-    switch (s-&gt;avctx-&gt;pix_fmt) {
-
-    case PIX_FMT_RGB555:
-        palette16 = (unsigned short *)s-&gt;palette;
-        for (i = 0; i &lt; PALETTE_COUNT; i++) {
-            pal_elem = palette_data[i];
-            r = (pal_elem &gt;&gt; 16) &amp; 0xff;
-            g = (pal_elem &gt;&gt; 8) &amp; 0xff;
-            b = pal_elem &amp; 0xff;
-            palette16[i] = 
-                ((r &gt;&gt; 3) &lt;&lt; 10) |
-                ((g &gt;&gt; 3) &lt;&lt;  5) |
-                ((b &gt;&gt; 3) &lt;&lt;  0);
-        }
-        break;
-
-    case PIX_FMT_RGB565:
-        palette16 = (unsigned short *)s-&gt;palette;
-        for (i = 0; i &lt; PALETTE_COUNT; i++) {
-            pal_elem = palette_data[i];
-            r = (pal_elem &gt;&gt; 16) &amp; 0xff;
-            g = (pal_elem &gt;&gt; 8) &amp; 0xff;
-            b = pal_elem &amp; 0xff;
-            palette16[i] = 
-                ((r &gt;&gt; 3) &lt;&lt; 11) |
-                ((g &gt;&gt; 2) &lt;&lt;  5) |
-                ((b &gt;&gt; 3) &lt;&lt;  0);
-        }
-        break;
-
-    case PIX_FMT_RGB24:
-        for (i = 0; i &lt; PALETTE_COUNT; i++) {
-            pal_elem = palette_data[i];
-            r = (pal_elem &gt;&gt; 16) &amp; 0xff;
-            g = (pal_elem &gt;&gt; 8) &amp; 0xff;
-            b = pal_elem &amp; 0xff;
-            s-&gt;palette[i * 4 + 0] = r;
-            s-&gt;palette[i * 4 + 1] = g;
-            s-&gt;palette[i * 4 + 2] = b;
-        }
-        break;
-
-    case PIX_FMT_BGR24:
-        for (i = 0; i &lt; PALETTE_COUNT; i++) {
-            pal_elem = palette_data[i];
-            r = (pal_elem &gt;&gt; 16) &amp; 0xff;
-            g = (pal_elem &gt;&gt; 8) &amp; 0xff;
-            b = pal_elem &amp; 0xff;
-            s-&gt;palette[i * 4 + 0] = b;
-            s-&gt;palette[i * 4 + 1] = g;
-            s-&gt;palette[i * 4 + 2] = r;
-        }
-        break;
-
-    case PIX_FMT_PAL8:
-    case PIX_FMT_RGBA32:
-        palette32 = (unsigned int *)s-&gt;palette;
-        memcpy (palette32, palette_data, PALETTE_COUNT * sizeof(unsigned int));
-        break;
-
-    case PIX_FMT_YUV444P:
-        for (i = 0; i &lt; PALETTE_COUNT; i++) {
-            pal_elem = palette_data[i];
-            r = (pal_elem &gt;&gt; 16) &amp; 0xff;
-            g = (pal_elem &gt;&gt; 8) &amp; 0xff;
-            b = pal_elem &amp; 0xff;
-            s-&gt;palette[i * 4 + 0] = COMPUTE_Y(r, g, b);
-            s-&gt;palette[i * 4 + 1] = COMPUTE_U(r, g, b);
-            s-&gt;palette[i * 4 + 2] = COMPUTE_V(r, g, b);
-        }
-        break;
-
-    default:
-        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot; Xan WC3: Unhandled colorspace\n&quot;);
-        break;
-    }
-}
-
-/* advance current_x variable; reset accounting variables if current_x
- * moves beyond width */
-#define ADVANCE_CURRENT_X() \
-    current_x++; \
-    if (current_x &gt;= width) { \
-        index += line_inc; \
-        current_x = 0; \
-    }
-
-static void inline xan_wc3_output_pixel_run(XanContext *s, 
-    unsigned char *pixel_buffer, int x, int y, int pixel_count)
-{
     int stride;
     int line_inc;
     int index;
     int current_x;
     int width = s-&gt;avctx-&gt;width;
-    unsigned char pix;
     unsigned char *palette_plane;
-    unsigned char *y_plane;
-    unsigned char *u_plane;
-    unsigned char *v_plane;
-    unsigned char *rgb_plane;
-    unsigned short *rgb16_plane;
-    unsigned short *palette16;
-    unsigned int *rgb32_plane;
-    unsigned int *palette32;
 
-    switch (s-&gt;avctx-&gt;pix_fmt) {
+    palette_plane = s-&gt;current_frame.data[0];
+    stride = s-&gt;current_frame.linesize[0];
+    line_inc = stride - width;
+    index = y * stride + x;
+    current_x = x;
+    while((pixel_count--) &amp;&amp; (index &lt; s-&gt;frame_size)) {
 
-    case PIX_FMT_PAL8:
-        palette_plane = s-&gt;current_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width;
-        index = y * stride + x;
-        current_x = x;
-        while(pixel_count--) {
+        /* don't do a memcpy() here; keyframes generally copy an entire
+         * frame of data and the stride needs to be accounted for */
+        palette_plane[index++] = *pixel_buffer++;
 
-            /* don't do a memcpy() here; keyframes generally copy an entire
-             * frame of data and the stride needs to be accounted for */
-            palette_plane[index++] = *pixel_buffer++;
-
-            ADVANCE_CURRENT_X();
+        current_x++;
+        if (current_x &gt;= width) {
+            index += line_inc;
+            current_x = 0;
         }
-        break;
-
-    case PIX_FMT_RGB555:
-    case PIX_FMT_RGB565:
-        rgb16_plane = (unsigned short *)s-&gt;current_frame.data[0];
-        palette16 = (unsigned short *)s-&gt;palette;
-        stride = s-&gt;current_frame.linesize[0] / 2;
-        line_inc = stride - width;
-        index = y * stride + x;
-        current_x = x;
-        while(pixel_count--) {
-
-            rgb16_plane[index++] = palette16[*pixel_buffer++];
-
-            ADVANCE_CURRENT_X();
-        }
-        break;
-
-    case PIX_FMT_RGB24:
-    case PIX_FMT_BGR24:
-        rgb_plane = s-&gt;current_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width * 3;
-        index = y * stride + x * 3;
-        current_x = x;
-        while(pixel_count--) {
-            pix = *pixel_buffer++;
-
-            rgb_plane[index++] = s-&gt;palette[pix * 4 + 0];
-            rgb_plane[index++] = s-&gt;palette[pix * 4 + 1];
-            rgb_plane[index++] = s-&gt;palette[pix * 4 + 2];
-
-            ADVANCE_CURRENT_X();
-        }
-        break;
-
-    case PIX_FMT_RGBA32:
-        rgb32_plane = (unsigned int *)s-&gt;current_frame.data[0];
-        palette32 = (unsigned int *)s-&gt;palette;
-        stride = s-&gt;current_frame.linesize[0] / 4;
-        line_inc = stride - width;
-        index = y * stride + x;
-        current_x = x;
-        while(pixel_count--) {
-
-            rgb32_plane[index++] = palette32[*pixel_buffer++];
-
-            ADVANCE_CURRENT_X();
-        }
-        break;
-
-    case PIX_FMT_YUV444P:
-        y_plane = s-&gt;current_frame.data[0];
-        u_plane = s-&gt;current_frame.data[1];
-        v_plane = s-&gt;current_frame.data[2];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width;
-        index = y * stride + x;
-        current_x = x;
-        while(pixel_count--) {
-            pix = *pixel_buffer++;
-
-            y_plane[index] = s-&gt;palette[pix * 4 + 0];
-            u_plane[index] = s-&gt;palette[pix * 4 + 1];
-            v_plane[index] = s-&gt;palette[pix * 4 + 2];
-
-            index++;
-            ADVANCE_CURRENT_X();
-        }
-        break;
-
-    default:
-        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot; Xan WC3: Unhandled colorspace\n&quot;);
-        break;
     }
 }
 
-#define ADVANCE_CURFRAME_X() \
-    curframe_x++; \
-    if (curframe_x &gt;= width) { \
-        curframe_index += line_inc; \
-        curframe_x = 0; \
-    }
-
-#define ADVANCE_PREVFRAME_X() \
-    prevframe_x++; \
-    if (prevframe_x &gt;= width) { \
-        prevframe_index += line_inc; \
-        prevframe_x = 0; \
-    }
-
-static void inline xan_wc3_copy_pixel_run(XanContext *s, 
+static inline void xan_wc3_copy_pixel_run(XanContext *s,
     int x, int y, int pixel_count, int motion_x, int motion_y)
 {
     int stride;
@@ -485,123 +243,31 @@
     int curframe_x, prevframe_x;
     int width = s-&gt;avctx-&gt;width;
     unsigned char *palette_plane, *prev_palette_plane;
-    unsigned char *y_plane, *u_plane, *v_plane;
-    unsigned char *prev_y_plane, *prev_u_plane, *prev_v_plane;
-    unsigned char *rgb_plane, *prev_rgb_plane;
-    unsigned short *rgb16_plane, *prev_rgb16_plane;
-    unsigned int *rgb32_plane, *prev_rgb32_plane;
 
-    switch (s-&gt;avctx-&gt;pix_fmt) {
+    palette_plane = s-&gt;current_frame.data[0];
+    prev_palette_plane = s-&gt;last_frame.data[0];
+    stride = s-&gt;current_frame.linesize[0];
+    line_inc = stride - width;
+    curframe_index = y * stride + x;
+    curframe_x = x;
+    prevframe_index = (y + motion_y) * stride + x + motion_x;
+    prevframe_x = x + motion_x;
+    while((pixel_count--) &amp;&amp; (curframe_index &lt; s-&gt;frame_size)) {
 
-    case PIX_FMT_PAL8:
-        palette_plane = s-&gt;current_frame.data[0];
-        prev_palette_plane = s-&gt;last_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width;
-        curframe_index = y * stride + x;
-        curframe_x = x;
-        prevframe_index = (y + motion_y) * stride + x + motion_x;
-        prevframe_x = x + motion_x;
-        while(pixel_count--) {
+        palette_plane[curframe_index++] =
+            prev_palette_plane[prevframe_index++];
 
-            palette_plane[curframe_index++] = 
-                prev_palette_plane[prevframe_index++];
-
-            ADVANCE_CURFRAME_X();
-            ADVANCE_PREVFRAME_X();
+        curframe_x++;
+        if (curframe_x &gt;= width) {
+            curframe_index += line_inc;
+            curframe_x = 0;
         }
-        break;
 
-    case PIX_FMT_RGB555:
-    case PIX_FMT_RGB565:
-        rgb16_plane = (unsigned short *)s-&gt;current_frame.data[0];
-        prev_rgb16_plane = (unsigned short *)s-&gt;last_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0] / 2;
-        line_inc = stride - width;
-        curframe_index = y * stride + x;
-        curframe_x = x;
-        prevframe_index = (y + motion_y) * stride + x + motion_x;
-        prevframe_x = x + motion_x;
-        while(pixel_count--) {
-
-            rgb16_plane[curframe_index++] = 
-                prev_rgb16_plane[prevframe_index++];
-
-            ADVANCE_CURFRAME_X();
-            ADVANCE_PREVFRAME_X();
+        prevframe_x++;
+        if (prevframe_x &gt;= width) {
+            prevframe_index += line_inc;
+            prevframe_x = 0;
         }
-        break;
-
-    case PIX_FMT_RGB24:
-    case PIX_FMT_BGR24:
-        rgb_plane = s-&gt;current_frame.data[0];
-        prev_rgb_plane = s-&gt;last_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width * 3;
-        curframe_index = y * stride + x * 3;
-        curframe_x = x;
-        prevframe_index = (y + motion_y) * stride + 
-            (3 * (x + motion_x));
-        prevframe_x = x + motion_x;
-        while(pixel_count--) {
-
-            rgb_plane[curframe_index++] = prev_rgb_plane[prevframe_index++];
-            rgb_plane[curframe_index++] = prev_rgb_plane[prevframe_index++];
-            rgb_plane[curframe_index++] = prev_rgb_plane[prevframe_index++];
-
-            ADVANCE_CURFRAME_X();
-            ADVANCE_PREVFRAME_X();
-        }
-        break;
-
-    case PIX_FMT_RGBA32:
-        rgb32_plane = (unsigned int *)s-&gt;current_frame.data[0];
-        prev_rgb32_plane = (unsigned int *)s-&gt;last_frame.data[0];
-        stride = s-&gt;current_frame.linesize[0] / 4;
-        line_inc = stride - width;
-        curframe_index = y * stride + x;
-        curframe_x = x;
-        prevframe_index = (y + motion_y) * stride + x + motion_x;
-        prevframe_x = x + motion_x;
-        while(pixel_count--) {
-
-            rgb32_plane[curframe_index++] = 
-                prev_rgb32_plane[prevframe_index++];
-
-            ADVANCE_CURFRAME_X();
-            ADVANCE_PREVFRAME_X();
-        }
-        break;
-
-    case PIX_FMT_YUV444P:
-        y_plane = s-&gt;current_frame.data[0];
-        u_plane = s-&gt;current_frame.data[1];
-        v_plane = s-&gt;current_frame.data[2];
-        prev_y_plane = s-&gt;last_frame.data[0];
-        prev_u_plane = s-&gt;last_frame.data[1];
-        prev_v_plane = s-&gt;last_frame.data[2];
-        stride = s-&gt;current_frame.linesize[0];
-        line_inc = stride - width;
-        curframe_index = y * stride + x;
-        curframe_x = x;
-        prevframe_index = (y + motion_y) * stride + x + motion_x;
-        prevframe_x = x + motion_x;
-        while(pixel_count--) {
-
-            y_plane[curframe_index] = prev_y_plane[prevframe_index];
-            u_plane[curframe_index] = prev_u_plane[prevframe_index];
-            v_plane[curframe_index] = prev_v_plane[prevframe_index];
-
-            curframe_index++;
-            ADVANCE_CURFRAME_X();
-            prevframe_index++;
-            ADVANCE_PREVFRAME_X();
-        }
-        break;
-
-    default:
-        av_log(s-&gt;avctx, AV_LOG_ERROR, &quot; Xan WC3: Unhandled colorspace\n&quot;);
-        break;
     }
 }
 
@@ -617,23 +283,24 @@
     int x, y;
 
     unsigned char *opcode_buffer = s-&gt;buffer1;
-    unsigned char *imagedata_buffer = s-&gt;buffer2;
+    int opcode_buffer_size = s-&gt;buffer1_size;
+    const unsigned char *imagedata_buffer = s-&gt;buffer2;
 
     /* pointers to segments inside the compressed chunk */
-    unsigned char *huffman_segment;
-    unsigned char *size_segment;
-    unsigned char *vector_segment;
-    unsigned char *imagedata_segment;
+    const unsigned char *huffman_segment;
+    const unsigned char *size_segment;
+    const unsigned char *vector_segment;
+    const unsigned char *imagedata_segment;
 
-    huffman_segment =   s-&gt;buf + LE_16(&amp;s-&gt;buf[0]);
-    size_segment =      s-&gt;buf + LE_16(&amp;s-&gt;buf[2]);
-    vector_segment =    s-&gt;buf + LE_16(&amp;s-&gt;buf[4]);
-    imagedata_segment = s-&gt;buf + LE_16(&amp;s-&gt;buf[6]);
+    huffman_segment =   s-&gt;buf + AV_RL16(&amp;s-&gt;buf[0]);
+    size_segment =      s-&gt;buf + AV_RL16(&amp;s-&gt;buf[2]);
+    vector_segment =    s-&gt;buf + AV_RL16(&amp;s-&gt;buf[4]);
+    imagedata_segment = s-&gt;buf + AV_RL16(&amp;s-&gt;buf[6]);
 
-    xan_huffman_decode(opcode_buffer, huffman_segment);
+    xan_huffman_decode(opcode_buffer, huffman_segment, opcode_buffer_size);
 
     if (imagedata_segment[0] == 2)
-        xan_unpack(imagedata_buffer, &amp;imagedata_segment[1]);
+        xan_unpack(s-&gt;buffer2, &amp;imagedata_segment[1], s-&gt;buffer2_size);
     else
         imagedata_buffer = &amp;imagedata_segment[1];
 
@@ -678,14 +345,13 @@
 
         case 10:
         case 20:
-            size = BE_16(&amp;size_segment[0]);
+            size = AV_RB16(&amp;size_segment[0]);
             size_segment += 2;
             break;
 
         case 11:
         case 21:
-            size = (size_segment[0] &lt;&lt; 16) | (size_segment[1] &lt;&lt; 8) |
-                size_segment[2];
+            size = AV_RB24(size_segment);
             size_segment += 3;
             break;
         }
@@ -731,13 +397,6 @@
             }
         }
     }
-
-    /* for PAL8, make the palette available on the way out */
-    if (s-&gt;avctx-&gt;pix_fmt == PIX_FMT_PAL8) {
-        memcpy(s-&gt;current_frame.data[1], s-&gt;palette, PALETTE_COUNT * 4);
-        s-&gt;current_frame.palette_has_changed = 1;
-        s-&gt;avctx-&gt;palctrl-&gt;palette_changed = 0;
-    }
 }
 
 static void xan_wc4_decode_frame(XanContext *s) {
@@ -745,27 +404,25 @@
 
 static int xan_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     XanContext *s = avctx-&gt;priv_data;
     AVPaletteControl *palette_control = avctx-&gt;palctrl;
-    int keyframe = 0;
 
-    if (palette_control-&gt;palette_changed) {
-        /* load the new palette and reset the palette control */
-        xan_wc3_build_palette(s, palette_control-&gt;palette);
-        /* If pal8 we clear flag when we copy palette */
-        if (s-&gt;avctx-&gt;pix_fmt != PIX_FMT_PAL8)
-            palette_control-&gt;palette_changed = 0;
-        keyframe = 1;
-    }
-
     if (avctx-&gt;get_buffer(avctx, &amp;s-&gt;current_frame)) {
         av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;  Xan Video: get_buffer() failed\n&quot;);
         return -1;
     }
     s-&gt;current_frame.reference = 3;
 
+    if (!s-&gt;frame_size)
+        s-&gt;frame_size = s-&gt;current_frame.linesize[0] * s-&gt;avctx-&gt;height;
+
+    palette_control-&gt;palette_changed = 0;
+    memcpy(s-&gt;current_frame.data[1], palette_control-&gt;palette,
+        AVPALETTE_SIZE);
+    s-&gt;current_frame.palette_has_changed = 1;
+
     s-&gt;buf = buf;
     s-&gt;size = buf_size;
 
@@ -778,22 +435,25 @@
     if (s-&gt;last_frame.data[0])
         avctx-&gt;release_buffer(avctx, &amp;s-&gt;last_frame);
 
-    /* shuffle frames */
-    s-&gt;last_frame = s-&gt;current_frame;
-
     *data_size = sizeof(AVFrame);
     *(AVFrame*)data = s-&gt;current_frame;
 
+    /* shuffle frames */
+    FFSWAP(AVFrame, s-&gt;current_frame, s-&gt;last_frame);
+
     /* always report that the buffer was completely consumed */
     return buf_size;
 }
 
-static int xan_decode_end(AVCodecContext *avctx)
+static av_cold int xan_decode_end(AVCodecContext *avctx)
 {
     XanContext *s = avctx-&gt;priv_data;
 
-    /* release the last frame */
-    avctx-&gt;release_buffer(avctx, &amp;s-&gt;last_frame);
+    /* release the frames */
+    if (s-&gt;last_frame.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;s-&gt;last_frame);
+    if (s-&gt;current_frame.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;s-&gt;current_frame);
 
     av_free(s-&gt;buffer1);
     av_free(s-&gt;buffer2);
@@ -811,6 +471,7 @@
     xan_decode_end,
     xan_decode_frame,
     CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;Wing Commander III / Xan&quot;),
 };
 
 /*

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.c	2008-09-15 14:07:05 UTC (rev 27552)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.c	2008-09-15 14:07:20 UTC (rev 27553)
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2007  FFmpeg Project
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;xiph.h&quot;
+
+int ff_split_xiph_headers(uint8_t *extradata, int extradata_size,
+                          int first_header_size, uint8_t *header_start[3],
+                          int header_len[3])
+{
+    int i;
+
+    if (extradata_size &gt;= 6 &amp;&amp; AV_RB16(extradata) == first_header_size) {
+        int overall_len = 6;
+        for (i=0; i&lt;3; i++) {
+            header_len[i] = AV_RB16(extradata);
+            extradata += 2;
+            header_start[i] = extradata;
+            extradata += header_len[i];
+            if (overall_len &gt; extradata_size - header_len[i])
+                return -1;
+            overall_len += header_len[i];
+        }
+    } else if (extradata_size &gt;= 3 &amp;&amp; extradata_size &lt; INT_MAX - 0x1ff &amp;&amp; extradata[0] == 2) {
+        int overall_len = 3;
+        extradata++;
+        for (i=0; i&lt;2; i++, extradata++) {
+            header_len[i] = 0;
+            for (; overall_len &lt; extradata_size &amp;&amp; *extradata==0xff; extradata++) {
+                header_len[i] += 0xff;
+                overall_len   += 0xff + 1;
+            }
+            header_len[i] += *extradata;
+            overall_len   += *extradata;
+            if (overall_len &gt; extradata_size)
+                return -1;
+        }
+        header_len[2] = extradata_size - overall_len;
+        header_start[0] = extradata;
+        header_start[1] = header_start[0] + header_len[0];
+        header_start[2] = header_start[1] + header_len[1];
+    } else {
+        return -1;
+    }
+    return 0;
+}

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.h	2008-09-15 14:07:05 UTC (rev 27552)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xiph.h	2008-09-15 14:07:20 UTC (rev 27553)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2007  FFmpeg Project
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_XIPH_H
+#define FFMPEG_XIPH_H
+
+#include &quot;common.h&quot;
+
+/**
+ * Splits a single extradata buffer into the three headers that most
+ * Xiph codecs use. (e.g. Theora and Vorbis)
+ * Works both with Matroska's packing and lavc's packing.
+ *
+ * @param[in] extradata The single chunk that combines all three headers
+ * @param[in] extradata_size The size of the extradata buffer
+ * @param[in] first_header_size The size of the first header, used to
+ * differentiate between the Matroska packing and lavc packing.
+ * @param[out] header_start Pointers to the start of the three separate headers.
+ * @param[out] header_len The sizes of each of the three headers.
+ * @return On error a negative value is returned, on success zero.
+ */
+int ff_split_xiph_headers(uint8_t *extradata, int extradata_size,
+                          int first_header_size, uint8_t *header_start[3],
+                          int header_len[3]);
+
+#endif /* FFMPEG_XIPH_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xl.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xl.c	2008-09-15 14:07:05 UTC (rev 27552)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/xl.c	2008-09-15 14:07:20 UTC (rev 27553)
@@ -0,0 +1,139 @@
+/*
+ * Miro VideoXL codec
+ * Copyright (c) 2004 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file xl.c
+ * Miro VideoXL codec.
+ */
+
+#include &quot;avcodec.h&quot;
+
+typedef struct VideoXLContext{
+    AVCodecContext *avctx;
+    AVFrame pic;
+} VideoXLContext;
+
+static const int xl_table[32] = {
+   0,   1,   2,   3,   4,   5,   6,   7,
+   8,   9,  12,  15,  20,  25,  34,  46,
+  64,  82,  94, 103, 108, 113, 116, 119,
+ 120, 121, 122, 123, 124, 125, 126, 127};
+
+static int decode_frame(AVCodecContext *avctx,
+                        void *data, int *data_size,
+                        const uint8_t *buf, int buf_size)
+{
+    VideoXLContext * const a = avctx-&gt;priv_data;
+    AVFrame * const p= (AVFrame*)&amp;a-&gt;pic;
+    uint8_t *Y, *U, *V;
+    int i, j;
+    int stride;
+    uint32_t val;
+    int y0, y1, y2, y3, c0, c1;
+
+    if(p-&gt;data[0])
+        avctx-&gt;release_buffer(avctx, p);
+
+    p-&gt;reference = 0;
+    if(avctx-&gt;get_buffer(avctx, p) &lt; 0){
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return -1;
+    }
+    p-&gt;pict_type= FF_I_TYPE;
+    p-&gt;key_frame= 1;

[... truncated: 561 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011862.html">[Haiku-commits] r27552 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011864.html">[Haiku-commits] r27554 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11863">[ date ]</a>
              <a href="thread.html#11863">[ thread ]</a>
              <a href="subject.html#11863">[ subject ]</a>
              <a href="author.html#11863">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
