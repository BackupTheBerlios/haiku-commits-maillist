<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27540 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27540%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151400.m8FE0R44032464%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011849.html">
   <LINK REL="Next"  HREF="011851.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27540 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27540%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151400.m8FE0R44032464%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27540 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:00:27 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011849.html">[Haiku-commits] r27539 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011851.html">[Haiku-commits] r27541 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11850">[ date ]</a>
              <a href="thread.html#11850">[ thread ]</a>
              <a href="subject.html#11850">[ subject ]</a>
              <a href="author.html#11850">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:00:22 +0200 (Mon, 15 Sep 2008)
New Revision: 27540
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27540&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27540&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac_ac3_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aacenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aacpsy.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aactab.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac.c	2008-09-15 13:57:54 UTC (rev 27539)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/aac.c	2008-09-15 14:00:22 UTC (rev 27540)
@@ -0,0 +1,1465 @@
+/*
+ * AAC decoder
+ * Copyright (c) 2005-2006 Oded Shimon ( ods15 ods15 dyndns org )
+ * Copyright (c) 2006-2007 Maxim Gavrilov ( maxim.gavrilov gmail com )
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file aac.c
+ * AAC decoder
+ * @author Oded Shimon  ( ods15 ods15 dyndns org )
+ * @author Maxim Gavrilov ( maxim.gavrilov gmail com )
+ */
+
+/*
+ * supported tools
+ *
+ * Support?             Name
+ * N (code in SoC repo) gain control
+ * Y                    block switching
+ * Y                    window shapes - standard
+ * N                    window shapes - Low Delay
+ * Y                    filterbank - standard
+ * N (code in SoC repo) filterbank - Scalable Sample Rate
+ * Y                    Temporal Noise Shaping
+ * N (code in SoC repo) Long Term Prediction
+ * Y                    intensity stereo
+ * Y                    channel coupling
+ * N                    frequency domain prediction
+ * Y                    Perceptual Noise Substitution
+ * Y                    Mid/Side stereo
+ * N                    Scalable Inverse AAC Quantization
+ * N                    Frequency Selective Switch
+ * N                    upsampling filter
+ * Y                    quantization &amp; coding - AAC
+ * N                    quantization &amp; coding - TwinVQ
+ * N                    quantization &amp; coding - BSAC
+ * N                    AAC Error Resilience tools
+ * N                    Error Resilience payload syntax
+ * N                    Error Protection tool
+ * N                    CELP
+ * N                    Silence Compression
+ * N                    HVXC
+ * N                    HVXC 4kbits/s VR
+ * N                    Structured Audio tools
+ * N                    Structured Audio Sample Bank Format
+ * N                    MIDI
+ * N                    Harmonic and Individual Lines plus Noise
+ * N                    Text-To-Speech Interface
+ * N (in progress)      Spectral Band Replication
+ * Y (not in this code) Layer-1
+ * Y (not in this code) Layer-2
+ * Y (not in this code) Layer-3
+ * N                    SinuSoidal Coding (Transient, Sinusoid, Noise)
+ * N (planned)          Parametric Stereo
+ * N                    Direct Stream Transfer
+ *
+ * Note: - HE AAC v1 comprises LC AAC with Spectral Band Replication.
+ *       - HE AAC v2 comprises LC AAC with Spectral Band Replication and
+           Parametric Stereo.
+ */
+
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#include &quot;aac.h&quot;
+#include &quot;aactab.h&quot;
+#include &quot;aacdectab.h&quot;
+#include &quot;mpeg4audio.h&quot;
+
+#include &lt;assert.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt;
+
+static VLC vlc_scalefactors;
+static VLC vlc_spectral[11];
+
+
+/**
+ * Configure output channel order based on the current program configuration element.
+ *
+ * @param   che_pos current channel position configuration
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int output_configure(AACContext *ac, enum ChannelPosition che_pos[4][MAX_ELEM_ID],
+        enum ChannelPosition new_che_pos[4][MAX_ELEM_ID]) {
+    AVCodecContext *avctx = ac-&gt;avccontext;
+    int i, type, channels = 0;
+
+    if(!memcmp(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0])))
+        return 0; /* no change */
+
+    memcpy(che_pos, new_che_pos, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+
+    /* Allocate or free elements depending on if they are in the
+     * current program configuration.
+     *
+     * Set up default 1:1 output mapping.
+     *
+     * For a 5.1 stream the output order will be:
+     *    [ Center ] [ Front Left ] [ Front Right ] [ LFE ] [ Surround Left ] [ Surround Right ]
+     */
+
+    for(i = 0; i &lt; MAX_ELEM_ID; i++) {
+        for(type = 0; type &lt; 4; type++) {
+            if(che_pos[type][i]) {
+                if(!ac-&gt;che[type][i] &amp;&amp; !(ac-&gt;che[type][i] = av_mallocz(sizeof(ChannelElement))))
+                    return AVERROR(ENOMEM);
+                if(type != TYPE_CCE) {
+                    ac-&gt;output_data[channels++] = ac-&gt;che[type][i]-&gt;ch[0].ret;
+                    if(type == TYPE_CPE) {
+                        ac-&gt;output_data[channels++] = ac-&gt;che[type][i]-&gt;ch[1].ret;
+                    }
+                }
+            } else
+                av_freep(&amp;ac-&gt;che[type][i]);
+        }
+    }
+
+    avctx-&gt;channels = channels;
+    return 0;
+}
+
+/**
+ * Decode an array of 4 bit element IDs, optionally interleaved with a stereo/mono switching bit.
+ *
+ * @param cpe_map Stereo (Channel Pair Element) map, NULL if stereo bit is not present.
+ * @param sce_map mono (Single Channel Element) map
+ * @param type speaker type/position for these channels
+ */
+static void decode_channel_map(enum ChannelPosition *cpe_map,
+        enum ChannelPosition *sce_map, enum ChannelPosition type, GetBitContext * gb, int n) {
+    while(n--) {
+        enum ChannelPosition *map = cpe_map &amp;&amp; get_bits1(gb) ? cpe_map : sce_map; // stereo or mono map
+        map[get_bits(gb, 4)] = type;
+    }
+}
+
+/**
+ * Decode program configuration element; reference: table 4.2.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_pce(AACContext * ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+        GetBitContext * gb) {
+    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc;
+
+    skip_bits(gb, 2);  // object_type
+
+    ac-&gt;m4ac.sampling_index = get_bits(gb, 4);
+    if(ac-&gt;m4ac.sampling_index &gt; 11) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
+        return -1;
+    }
+    ac-&gt;m4ac.sample_rate = ff_mpeg4audio_sample_rates[ac-&gt;m4ac.sampling_index];
+    num_front       = get_bits(gb, 4);
+    num_side        = get_bits(gb, 4);
+    num_back        = get_bits(gb, 4);
+    num_lfe         = get_bits(gb, 2);
+    num_assoc_data  = get_bits(gb, 3);
+    num_cc          = get_bits(gb, 4);
+
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // mono_mixdown_tag
+    if (get_bits1(gb))
+        skip_bits(gb, 4); // stereo_mixdown_tag
+
+    if (get_bits1(gb))
+        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround
+
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_FRONT, gb, num_front);
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_SIDE,  gb, num_side );
+    decode_channel_map(new_che_pos[TYPE_CPE], new_che_pos[TYPE_SCE], AAC_CHANNEL_BACK,  gb, num_back );
+    decode_channel_map(NULL,                  new_che_pos[TYPE_LFE], AAC_CHANNEL_LFE,   gb, num_lfe  );
+
+    skip_bits_long(gb, 4 * num_assoc_data);
+
+    decode_channel_map(new_che_pos[TYPE_CCE], new_che_pos[TYPE_CCE], AAC_CHANNEL_CC,    gb, num_cc   );
+
+    align_get_bits(gb);
+
+    /* comment field, first byte is length */
+    skip_bits_long(gb, 8 * get_bits(gb, 8));
+    return 0;
+}
+
+/**
+ * Set up channel positions based on a default channel configuration
+ * as specified in table 1.17.
+ *
+ * @param   new_che_pos New channel position configuration - we only do something if it differs from the current one.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int set_default_channel_config(AACContext *ac, enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],
+        int channel_config)
+{
+    if(channel_config &lt; 1 || channel_config &gt; 7) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid default channel configuration (%d)\n&quot;,
+               channel_config);
+        return -1;
+    }
+
+    /* default channel configurations:
+     *
+     * 1ch : front center (mono)
+     * 2ch : L + R (stereo)
+     * 3ch : front center + L + R
+     * 4ch : front center + L + R + back center
+     * 5ch : front center + L + R + back stereo
+     * 6ch : front center + L + R + back stereo + LFE
+     * 7ch : front center + L + R + outer front left + outer front right + back stereo + LFE
+     */
+
+    if(channel_config != 2)
+        new_che_pos[TYPE_SCE][0] = AAC_CHANNEL_FRONT; // front center (or mono)
+    if(channel_config &gt; 1)
+        new_che_pos[TYPE_CPE][0] = AAC_CHANNEL_FRONT; // L + R (or stereo)
+    if(channel_config == 4)
+        new_che_pos[TYPE_SCE][1] = AAC_CHANNEL_BACK;  // back center
+    if(channel_config &gt; 4)
+        new_che_pos[TYPE_CPE][(channel_config == 7) + 1]
+                                 = AAC_CHANNEL_BACK;  // back stereo
+    if(channel_config &gt; 5)
+        new_che_pos[TYPE_LFE][0] = AAC_CHANNEL_LFE;   // LFE
+    if(channel_config == 7)
+        new_che_pos[TYPE_CPE][1] = AAC_CHANNEL_FRONT; // outer front left + outer front right
+
+    return 0;
+}
+
+/**
+ * Decode GA &quot;General Audio&quot; specific configuration; reference: table 4.1.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ga_specific_config(AACContext * ac, GetBitContext * gb, int channel_config) {
+    enum ChannelPosition new_che_pos[4][MAX_ELEM_ID];
+    int extension_flag, ret;
+
+    if(get_bits1(gb)) {  // frameLengthFlag
+        av_log_missing_feature(ac-&gt;avccontext, &quot;960/120 MDCT window is&quot;, 1);
+        return -1;
+    }
+
+    if (get_bits1(gb))       // dependsOnCoreCoder
+        skip_bits(gb, 14);   // coreCoderDelay
+    extension_flag = get_bits1(gb);
+
+    if(ac-&gt;m4ac.object_type == AOT_AAC_SCALABLE ||
+       ac-&gt;m4ac.object_type == AOT_ER_AAC_SCALABLE)
+        skip_bits(gb, 3);     // layerNr
+
+    memset(new_che_pos, 0, 4 * MAX_ELEM_ID * sizeof(new_che_pos[0][0]));
+    if (channel_config == 0) {
+        skip_bits(gb, 4);  // element_instance_tag
+        if((ret = decode_pce(ac, new_che_pos, gb)))
+            return ret;
+    } else {
+        if((ret = set_default_channel_config(ac, new_che_pos, channel_config)))
+            return ret;
+    }
+    if((ret = output_configure(ac, ac-&gt;che_pos, new_che_pos)))
+        return ret;
+
+    if (extension_flag) {
+        switch (ac-&gt;m4ac.object_type) {
+            case AOT_ER_BSAC:
+                skip_bits(gb, 5);    // numOfSubFrame
+                skip_bits(gb, 11);   // layer_length
+                break;
+            case AOT_ER_AAC_LC:
+            case AOT_ER_AAC_LTP:
+            case AOT_ER_AAC_SCALABLE:
+            case AOT_ER_AAC_LD:
+                skip_bits(gb, 3);  /* aacSectionDataResilienceFlag
+                                    * aacScalefactorDataResilienceFlag
+                                    * aacSpectralDataResilienceFlag
+                                    */
+                break;
+        }
+        skip_bits1(gb);    // extensionFlag3 (TBD in version 3)
+    }
+    return 0;
+}
+
+/**
+ * Decode audio specific configuration; reference: table 1.13.
+ *
+ * @param   data        pointer to AVCodecContext extradata
+ * @param   data_size   size of AVCCodecContext extradata
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_audio_specific_config(AACContext * ac, void *data, int data_size) {
+    GetBitContext gb;
+    int i;
+
+    init_get_bits(&amp;gb, data, data_size * 8);
+
+    if((i = ff_mpeg4audio_get_config(&amp;ac-&gt;m4ac, data, data_size)) &lt; 0) {
+   	    av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;ff_mpeg4audio_get_config failed\n&quot;);
+        return -1;
+    }
+    
+    av_log(ac-&gt;avccontext, AV_LOG_DEBUG, &quot;Details decoded Sample Rate %d ext Sample Rate %d Channels %d\n&quot;,ac-&gt;m4ac.sample_rate, ac-&gt;m4ac.ext_sample_rate, ac-&gt;m4ac.chan_config);
+
+    if(ac-&gt;m4ac.sampling_index &gt; 11) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid sampling rate index %d\n&quot;, ac-&gt;m4ac.sampling_index);
+        return -1;
+    }
+
+    skip_bits_long(&amp;gb, i);
+
+    switch (ac-&gt;m4ac.object_type) {
+    case AOT_AAC_LC:
+        if (decode_ga_specific_config(ac, &amp;gb, ac-&gt;m4ac.chan_config)) {
+	   	    av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;decode_ga_specific_config failed\n&quot;);
+            return -1;
+        }
+        break;
+    default:
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Audio object type %s%d is not supported.\n&quot;,
+               ac-&gt;m4ac.sbr == 1? &quot;SBR+&quot; : &quot;&quot;, ac-&gt;m4ac.object_type);
+        return -1;
+    }
+    return 0;
+}
+
+/**
+ * linear congruential pseudorandom number generator
+ *
+ * @param   previous_val    pointer to the current state of the generator
+ *
+ * @return  Returns a 32-bit pseudorandom integer
+ */
+static av_always_inline int lcg_random(int previous_val) {
+    return previous_val * 1664525 + 1013904223;
+}
+
+static av_cold int aac_decode_init(AVCodecContext * avccontext) {
+    AACContext * ac = avccontext-&gt;priv_data;
+    int i;
+
+    ac-&gt;avccontext = avccontext;
+
+    if (avccontext-&gt;extradata_size &lt;= 0 ||
+        decode_audio_specific_config(ac, avccontext-&gt;extradata, avccontext-&gt;extradata_size)) {
+   	    av_log(avccontext, AV_LOG_ERROR, &quot;no audio config data supplied (%ld) or data invalid\n&quot;,avccontext-&gt;extradata_size);
+
+        return -1;
+    }
+
+    avccontext-&gt;sample_fmt  = SAMPLE_FMT_S16;
+    avccontext-&gt;sample_rate = ac-&gt;m4ac.sample_rate;
+    avccontext-&gt;frame_size  = 1024;
+
+    AAC_INIT_VLC_STATIC( 0, 144);
+    AAC_INIT_VLC_STATIC( 1, 114);
+    AAC_INIT_VLC_STATIC( 2, 188);
+    AAC_INIT_VLC_STATIC( 3, 180);
+    AAC_INIT_VLC_STATIC( 4, 172);
+    AAC_INIT_VLC_STATIC( 5, 140);
+    AAC_INIT_VLC_STATIC( 6, 168);
+    AAC_INIT_VLC_STATIC( 7, 114);
+    AAC_INIT_VLC_STATIC( 8, 262);
+    AAC_INIT_VLC_STATIC( 9, 248);
+    AAC_INIT_VLC_STATIC(10, 384);
+
+    dsputil_init(&amp;ac-&gt;dsp, avccontext);
+
+    ac-&gt;random_state = 0x1f2e3d4c;
+
+    // -1024 - Compensate wrong IMDCT method.
+    // 32768 - Required to scale values to the correct range for the bias method
+    //         for float to int16 conversion.
+
+    if(ac-&gt;dsp.float_to_int16 == ff_float_to_int16_c) {
+        ac-&gt;add_bias = 385.0f;
+        ac-&gt;sf_scale = 1. / (-1024. * 32768.);
+        ac-&gt;sf_offset = 0;
+    } else {
+        ac-&gt;add_bias = 0.0f;
+        ac-&gt;sf_scale = 1. / -1024.;
+        ac-&gt;sf_offset = 60;
+    }
+
+#ifndef CONFIG_HARDCODED_TABLES
+    for (i = 0; i &lt; 316; i++)
+        ff_aac_pow2sf_tab[i] = pow(2, (i - 200)/4.);
+#endif /* CONFIG_HARDCODED_TABLES */
+
+    INIT_VLC_STATIC(&amp;vlc_scalefactors, 7, sizeof(ff_aac_scalefactor_code)/sizeof(ff_aac_scalefactor_code[0]),
+        ff_aac_scalefactor_bits, sizeof(ff_aac_scalefactor_bits[0]), sizeof(ff_aac_scalefactor_bits[0]),
+        ff_aac_scalefactor_code, sizeof(ff_aac_scalefactor_code[0]), sizeof(ff_aac_scalefactor_code[0]),
+        352);
+
+    ff_mdct_init(&amp;ac-&gt;mdct, 11, 1);
+    ff_mdct_init(&amp;ac-&gt;mdct_small, 8, 1);
+    // window initialization
+    ff_kbd_window_init(ff_aac_kbd_long_1024, 4.0, 1024);
+    ff_kbd_window_init(ff_aac_kbd_short_128, 6.0, 128);
+    ff_sine_window_init(ff_sine_1024, 1024);
+    ff_sine_window_init(ff_sine_128, 128);
+
+    return 0;
+}
+
+/**
+ * Skip data_stream_element; reference: table 4.10.
+ */
+static void skip_data_stream_element(GetBitContext * gb) {
+    int byte_align = get_bits1(gb);
+    int count = get_bits(gb, 8);
+    if (count == 255)
+        count += get_bits(gb, 8);
+    if (byte_align)
+        align_get_bits(gb);
+    skip_bits_long(gb, 8 * count);
+}
+
+/**
+ * Decode Individual Channel Stream info; reference: table 4.6.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ */
+static int decode_ics_info(AACContext * ac, IndividualChannelStream * ics, GetBitContext * gb, int common_window) {
+    if (get_bits1(gb)) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Reserved bit set.\n&quot;);
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+    ics-&gt;window_sequence[1] = ics-&gt;window_sequence[0];
+    ics-&gt;window_sequence[0] = get_bits(gb, 2);
+    ics-&gt;use_kb_window[1] = ics-&gt;use_kb_window[0];
+    ics-&gt;use_kb_window[0] = get_bits1(gb);
+    ics-&gt;num_window_groups = 1;
+    ics-&gt;group_len[0] = 1;
+    if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+        int i;
+        ics-&gt;max_sfb = get_bits(gb, 4);
+        for (i = 0; i &lt; 7; i++) {
+            if (get_bits1(gb)) {
+                ics-&gt;group_len[ics-&gt;num_window_groups-1]++;
+            } else {
+                ics-&gt;num_window_groups++;
+                ics-&gt;group_len[ics-&gt;num_window_groups-1] = 1;
+            }
+        }
+        ics-&gt;num_windows   = 8;
+        ics-&gt;swb_offset    =      swb_offset_128[ac-&gt;m4ac.sampling_index];
+        ics-&gt;num_swb       =  ff_aac_num_swb_128[ac-&gt;m4ac.sampling_index];
+        ics-&gt;tns_max_bands =   tns_max_bands_128[ac-&gt;m4ac.sampling_index];
+    } else {
+        ics-&gt;max_sfb       = get_bits(gb, 6);
+        ics-&gt;num_windows   = 1;
+        ics-&gt;swb_offset    =     swb_offset_1024[ac-&gt;m4ac.sampling_index];
+        ics-&gt;num_swb       = ff_aac_num_swb_1024[ac-&gt;m4ac.sampling_index];
+        ics-&gt;tns_max_bands =  tns_max_bands_1024[ac-&gt;m4ac.sampling_index];
+        if (get_bits1(gb)) {
+            av_log_missing_feature(ac-&gt;avccontext, &quot;Predictor bit set but LTP is&quot;, 1);
+            memset(ics, 0, sizeof(IndividualChannelStream));
+            return -1;
+        }
+    }
+
+    if(ics-&gt;max_sfb &gt; ics-&gt;num_swb) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+            &quot;Number of scalefactor bands in group (%d) exceeds limit (%d).\n&quot;,
+            ics-&gt;max_sfb, ics-&gt;num_swb);
+        memset(ics, 0, sizeof(IndividualChannelStream));
+        return -1;
+    }
+
+    return 0;
+}
+
+/**
+ * Decode band types (section_data payload); reference: table 4.46.
+ *
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_band_types(AACContext * ac, enum BandType band_type[120],
+        int band_type_run_end[120], GetBitContext * gb, IndividualChannelStream * ics) {
+    int g, idx = 0;
+    const int bits = (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        int k = 0;
+        while (k &lt; ics-&gt;max_sfb) {
+            uint8_t sect_len = k;
+            int sect_len_incr;
+            int sect_band_type = get_bits(gb, 4);
+            if (sect_band_type == 12) {
+                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;invalid band type\n&quot;);
+                return -1;
+            }
+            while ((sect_len_incr = get_bits(gb, bits)) == (1 &lt;&lt; bits)-1)
+                sect_len += sect_len_incr;
+            sect_len += sect_len_incr;
+            if (sect_len &gt; ics-&gt;max_sfb) {
+                av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+                    &quot;Number of bands (%d) exceeds limit (%d).\n&quot;,
+                    sect_len, ics-&gt;max_sfb);
+                return -1;
+            }
+            for (; k &lt; sect_len; k++) {
+                band_type        [idx]   = sect_band_type;
+                band_type_run_end[idx++] = sect_len;
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode scalefactors; reference: table 4.47.
+ *
+ * @param   global_gain         first scalefactor value as scalefactors are differentially coded
+ * @param   band_type           array of the used band type
+ * @param   band_type_run_end   array of the last scalefactor band of a band type run
+ * @param   sf                  array of scalefactors or intensity stereo positions
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_scalefactors(AACContext * ac, float sf[120], GetBitContext * gb,
+        unsigned int global_gain, IndividualChannelStream * ics,
+        enum BandType band_type[120], int band_type_run_end[120]) {
+    const int sf_offset = ac-&gt;sf_offset + (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE ? 12 : 0);
+    int g, i, idx = 0;
+    int offset[3] = { global_gain, global_gain - 90, 100 };
+    int noise_flag = 1;
+    static const char *sf_str[3] = { &quot;Global gain&quot;, &quot;Noise gain&quot;, &quot;Intensity stereo position&quot; };
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb;) {
+            int run_end = band_type_run_end[idx];
+            if (band_type[idx] == ZERO_BT) {
+                for(; i &lt; run_end; i++, idx++)
+                    sf[idx] = 0.;
+            }else if((band_type[idx] == INTENSITY_BT) || (band_type[idx] == INTENSITY_BT2)) {
+                for(; i &lt; run_end; i++, idx++) {
+                    offset[2] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if(offset[2] &gt; 255U) {
+                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+                            &quot;%s (%d) out of range.\n&quot;, sf_str[2], offset[2]);
+                        return -1;
+                    }
+                    sf[idx]  = ff_aac_pow2sf_tab[-offset[2] + 300];
+                }
+            }else if(band_type[idx] == NOISE_BT) {
+                for(; i &lt; run_end; i++, idx++) {
+                    if(noise_flag-- &gt; 0)
+                        offset[1] += get_bits(gb, 9) - 256;
+                    else
+                        offset[1] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if(offset[1] &gt; 255U) {
+                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+                            &quot;%s (%d) out of range.\n&quot;, sf_str[1], offset[1]);
+                        return -1;
+                    }
+                    sf[idx]  = -ff_aac_pow2sf_tab[ offset[1] + sf_offset];
+                }
+            }else {
+                for(; i &lt; run_end; i++, idx++) {
+                    offset[0] += get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                    if(offset[0] &gt; 255U) {
+                        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+                            &quot;%s (%d) out of range.\n&quot;, sf_str[0], offset[0]);
+                        return -1;
+                    }
+                    sf[idx] = -ff_aac_pow2sf_tab[ offset[0] + sf_offset];
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode pulse data; reference: table 4.7.
+ */
+static void decode_pulses(Pulse * pulse, GetBitContext * gb, const uint16_t * swb_offset) {
+    int i;
+    pulse-&gt;num_pulse = get_bits(gb, 2) + 1;
+    pulse-&gt;pos[0]    = get_bits(gb, 5) + swb_offset[get_bits(gb, 6)];
+    pulse-&gt;amp[0]    = get_bits(gb, 4);
+    for (i = 1; i &lt; pulse-&gt;num_pulse; i++) {
+        pulse-&gt;pos[i] = get_bits(gb, 5) + pulse-&gt;pos[i-1];
+        pulse-&gt;amp[i] = get_bits(gb, 4);
+    }
+}
+
+/**
+ * Decode Temporal Noise Shaping data; reference: table 4.48.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_tns(AACContext * ac, TemporalNoiseShaping * tns,
+        GetBitContext * gb, const IndividualChannelStream * ics) {
+    int w, filt, i, coef_len, coef_res, coef_compress;
+    const int is8 = ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE;
+    const int tns_max_order = is8 ? 7 : ac-&gt;m4ac.object_type == AOT_AAC_MAIN ? 20 : 12;
+    for (w = 0; w &lt; ics-&gt;num_windows; w++) {
+        if ((tns-&gt;n_filt[w] = get_bits(gb, 2 - is8))) {
+            coef_res = get_bits1(gb);
+
+            for (filt = 0; filt &lt; tns-&gt;n_filt[w]; filt++) {
+                int tmp2_idx;
+                tns-&gt;length[w][filt] = get_bits(gb, 6 - 2*is8);
+
+                if ((tns-&gt;order[w][filt] = get_bits(gb, 5 - 2*is8)) &gt; tns_max_order) {
+                    av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;TNS filter order %d is greater than maximum %d.&quot;,
+                           tns-&gt;order[w][filt], tns_max_order);
+                    tns-&gt;order[w][filt] = 0;
+                    return -1;
+                }
+                tns-&gt;direction[w][filt] = get_bits1(gb);
+                coef_compress = get_bits1(gb);
+                coef_len = coef_res + 3 - coef_compress;
+                tmp2_idx = 2*coef_compress + coef_res;
+
+                for (i = 0; i &lt; tns-&gt;order[w][filt]; i++)
+                    tns-&gt;coef[w][filt][i] = tns_tmp2_map[tmp2_idx][get_bits(gb, coef_len)];
+            }
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode Mid/Side data; reference: table 4.54.
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void decode_mid_side_stereo(ChannelElement * cpe, GetBitContext * gb,
+        int ms_present) {
+    int idx;
+    if (ms_present == 1) {
+        for (idx = 0; idx &lt; cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb; idx++)
+            cpe-&gt;ms_mask[idx] = get_bits1(gb);
+    } else if (ms_present == 2) {
+        memset(cpe-&gt;ms_mask, 1, cpe-&gt;ch[0].ics.num_window_groups * cpe-&gt;ch[0].ics.max_sfb * sizeof(cpe-&gt;ms_mask[0]));
+    }
+}
+
+/**
+ * Decode spectral data; reference: table 4.50.
+ * Dequantize and scale spectral data; reference: 4.6.3.3.
+ *
+ * @param   coef            array of dequantized, scaled spectral data
+ * @param   sf              array of scalefactors or intensity stereo positions
+ * @param   pulse_present   set if pulses are present
+ * @param   pulse           pointer to pulse data struct
+ * @param   band_type       array of the used band type
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_spectrum_and_dequant(AACContext * ac, float coef[1024], GetBitContext * gb, float sf[120],
+        int pulse_present, const Pulse * pulse, const IndividualChannelStream * ics, enum BandType band_type[120]) {
+    int i, k, g, idx = 0;
+    const int c = 1024/ics-&gt;num_windows;
+    const uint16_t * offsets = ics-&gt;swb_offset;
+    float *coef_base = coef;
+
+    for (g = 0; g &lt; ics-&gt;num_windows; g++)
+        memset(coef + g * 128 + offsets[ics-&gt;max_sfb], 0, sizeof(float)*(c - offsets[ics-&gt;max_sfb]));
+
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
+            const int cur_band_type = band_type[idx];
+            const int dim = cur_band_type &gt;= FIRST_PAIR_BT ? 2 : 4;
+            const int is_cb_unsigned = IS_CODEBOOK_UNSIGNED(cur_band_type);
+            int group;
+            if (cur_band_type == ZERO_BT) {
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    memset(coef + group * 128 + offsets[i], 0, (offsets[i+1] - offsets[i])*sizeof(float));
+                }
+            }else if (cur_band_type == NOISE_BT) {
+                const float scale = sf[idx] / ((offsets[i+1] - offsets[i]) * PNS_MEAN_ENERGY);
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    for (k = offsets[i]; k &lt; offsets[i+1]; k++) {
+                        ac-&gt;random_state  = lcg_random(ac-&gt;random_state);
+                        coef[group*128+k] = ac-&gt;random_state * scale;
+                    }
+                }
+            }else if (cur_band_type != INTENSITY_BT2 &amp;&amp; cur_band_type != INTENSITY_BT) {
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    for (k = offsets[i]; k &lt; offsets[i+1]; k += dim) {
+                        const int index = get_vlc2(gb, vlc_spectral[cur_band_type - 1].table, 6, 3);
+                        const int coef_tmp_idx = (group &lt;&lt; 7) + k;
+                        const float *vq_ptr;
+                        int j;
+                        if(index &gt;= ff_aac_spectral_sizes[cur_band_type - 1]) {
+                            av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+                                &quot;Read beyond end of ff_aac_codebook_vectors[%d][]. index %d &gt;= %d\n&quot;,
+                                cur_band_type - 1, index, ff_aac_spectral_sizes[cur_band_type - 1]);
+                            return -1;
+                        }
+                        vq_ptr = &amp;ff_aac_codebook_vectors[cur_band_type - 1][index * dim];
+                        if (is_cb_unsigned) {
+                            for (j = 0; j &lt; dim; j++)
+                                if (vq_ptr[j])
+                                    coef[coef_tmp_idx + j] = 1 - 2*(int)get_bits1(gb);
+                        }else {
+                            for (j = 0; j &lt; dim; j++)
+                                coef[coef_tmp_idx + j] = 1.0f;
+                        }
+                        if (cur_band_type == ESC_BT) {
+                            for (j = 0; j &lt; 2; j++) {
+                                if (vq_ptr[j] == 64.0f) {
+                                    int n = 4;
+                                    /* The total length of escape_sequence must be &lt; 22 bits according
+                                       to the specification (i.e. max is 11111111110xxxxxxxxxx). */
+                                    while (get_bits1(gb) &amp;&amp; n &lt; 15) n++;
+                                    if(n == 15) {
+                                        av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;error in spectral data, ESC overflow\n&quot;);
+                                        return -1;
+                                    }
+                                    n = (1&lt;&lt;n) + get_bits(gb, n);
+                                    coef[coef_tmp_idx + j] *= cbrtf(fabsf(n)) * n;
+                                }else
+                                    coef[coef_tmp_idx + j] *= vq_ptr[j];
+                            }
+                        }else
+                            for (j = 0; j &lt; dim; j++)
+                                coef[coef_tmp_idx + j] *= vq_ptr[j];
+                        for (j = 0; j &lt; dim; j++)
+                            coef[coef_tmp_idx + j] *= sf[idx];
+                    }
+                }
+            }
+        }
+        coef += ics-&gt;group_len[g]&lt;&lt;7;
+    }
+
+    if (pulse_present) {
+        for(i = 0; i &lt; pulse-&gt;num_pulse; i++){
+            float co  = coef_base[ pulse-&gt;pos[i] ];
+            float ico = co / sqrtf(sqrtf(fabsf(co))) + pulse-&gt;amp[i];
+            coef_base[ pulse-&gt;pos[i] ] = cbrtf(fabsf(ico)) * ico;
+        }
+    }
+    return 0;
+}
+
+/**
+ * Decode an individual_channel_stream payload; reference: table 4.44.
+ *
+ * @param   common_window   Channels have independent [0], or shared [1], Individual Channel Stream information.
+ * @param   scale_flag      scalable [1] or non-scalable [0] AAC (Unused until scalable AAC is implemented.)
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {
+    Pulse pulse;
+    TemporalNoiseShaping * tns = &amp;sce-&gt;tns;
+    IndividualChannelStream * ics = &amp;sce-&gt;ics;
+    float * out = sce-&gt;coeffs;
+    int global_gain, pulse_present = 0;
+
+    /* This assignment is to silence a GCC warning about the variable being used
+     * uninitialized when in fact it always is.
+     */
+    pulse.num_pulse = 0;
+
+    global_gain = get_bits(gb, 8);
+
+    if (!common_window &amp;&amp; !scale_flag) {
+        if (decode_ics_info(ac, ics, gb, 0) &lt; 0)
+            return -1;
+    }
+
+    if (decode_band_types(ac, sce-&gt;band_type, sce-&gt;band_type_run_end, gb, ics) &lt; 0)
+        return -1;
+    if (decode_scalefactors(ac, sce-&gt;sf, gb, global_gain, ics, sce-&gt;band_type, sce-&gt;band_type_run_end) &lt; 0)
+        return -1;
+
+    pulse_present = 0;
+    if (!scale_flag) {
+        if ((pulse_present = get_bits1(gb))) {
+            if (ics-&gt;window_sequence[0] == EIGHT_SHORT_SEQUENCE) {
+                av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;Pulse tool not allowed in eight short sequence.\n&quot;);
+                return -1;
+            }
+            decode_pulses(&amp;pulse, gb, ics-&gt;swb_offset);
+        }
+        if ((tns-&gt;present = get_bits1(gb)) &amp;&amp; decode_tns(ac, tns, gb, ics))
+            return -1;
+        if (get_bits1(gb)) {
+            av_log_missing_feature(ac-&gt;avccontext, &quot;SSR&quot;, 1);
+            return -1;
+        }
+    }
+
+    if (decode_spectrum_and_dequant(ac, out, gb, sce-&gt;sf, pulse_present, &amp;pulse, ics, sce-&gt;band_type) &lt; 0)
+        return -1;
+    return 0;
+}
+
+/**
+ * Mid/Side stereo decoding; reference: 4.6.8.1.3.
+ */
+static void apply_mid_side_stereo(ChannelElement * cpe) {
+    const IndividualChannelStream * ics = &amp;cpe-&gt;ch[0].ics;
+    float *ch0 = cpe-&gt;ch[0].coeffs;
+    float *ch1 = cpe-&gt;ch[1].coeffs;
+    int g, i, k, group, idx = 0;
+    const uint16_t * offsets = ics-&gt;swb_offset;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb; i++, idx++) {
+            if (cpe-&gt;ms_mask[idx] &amp;&amp;
+                cpe-&gt;ch[0].band_type[idx] &lt; NOISE_BT &amp;&amp; cpe-&gt;ch[1].band_type[idx] &lt; NOISE_BT) {
+                for (group = 0; group &lt; ics-&gt;group_len[g]; group++) {
+                    for (k = offsets[i]; k &lt; offsets[i+1]; k++) {
+                        float tmp = ch0[group*128 + k] - ch1[group*128 + k];
+                        ch0[group*128 + k] += ch1[group*128 + k];
+                        ch1[group*128 + k] = tmp;
+                    }
+                }
+            }
+        }
+        ch0 += ics-&gt;group_len[g]*128;
+        ch1 += ics-&gt;group_len[g]*128;
+    }
+}
+
+/**
+ * intensity stereo decoding; reference: 4.6.8.2.3
+ *
+ * @param   ms_present  Indicates mid/side stereo presence. [0] mask is all 0s;
+ *                      [1] mask is decoded from bitstream; [2] mask is all 1s;
+ *                      [3] reserved for scalable AAC
+ */
+static void apply_intensity_stereo(ChannelElement * cpe, int ms_present) {
+    const IndividualChannelStream * ics = &amp;cpe-&gt;ch[1].ics;
+    SingleChannelElement * sce1 = &amp;cpe-&gt;ch[1];
+    float *coef0 = cpe-&gt;ch[0].coeffs, *coef1 = cpe-&gt;ch[1].coeffs;
+    const uint16_t * offsets = ics-&gt;swb_offset;
+    int g, group, i, k, idx = 0;
+    int c;
+    float scale;
+    for (g = 0; g &lt; ics-&gt;num_window_groups; g++) {
+        for (i = 0; i &lt; ics-&gt;max_sfb;) {
+            if (sce1-&gt;band_type[idx] == INTENSITY_BT || sce1-&gt;band_type[idx] == INTENSITY_BT2) {
+                const int bt_run_end = sce1-&gt;band_type_run_end[idx];
+                for (; i &lt; bt_run_end; i++, idx++) {
+                    c = -1 + 2 * (sce1-&gt;band_type[idx] - 14);
+                    if (ms_present)
+                        c *= 1 - 2 * cpe-&gt;ms_mask[idx];
+                    scale = c * sce1-&gt;sf[idx];
+                    for (group = 0; group &lt; ics-&gt;group_len[g]; group++)
+                        for (k = offsets[i]; k &lt; offsets[i+1]; k++)
+                            coef1[group*128 + k] = scale * coef0[group*128 + k];
+                }
+            } else {
+                int bt_run_end = sce1-&gt;band_type_run_end[idx];
+                idx += bt_run_end - i;
+                i    = bt_run_end;
+            }
+        }
+        coef0 += ics-&gt;group_len[g]*128;
+        coef1 += ics-&gt;group_len[g]*128;
+    }
+}
+
+/**
+ * Decode a channel_pair_element; reference: table 4.4.
+ *
+ * @param   elem_id Identifies the instance of a syntax element.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cpe(AACContext * ac, GetBitContext * gb, int elem_id) {
+    int i, ret, common_window, ms_present = 0;
+    ChannelElement * cpe;
+
+    cpe = ac-&gt;che[TYPE_CPE][elem_id];
+    common_window = get_bits1(gb);
+    if (common_window) {
+        if (decode_ics_info(ac, &amp;cpe-&gt;ch[0].ics, gb, 1))
+            return -1;
+        i = cpe-&gt;ch[1].ics.use_kb_window[0];
+        cpe-&gt;ch[1].ics = cpe-&gt;ch[0].ics;
+        cpe-&gt;ch[1].ics.use_kb_window[1] = i;
+        ms_present = get_bits(gb, 2);
+        if(ms_present == 3) {
+            av_log(ac-&gt;avccontext, AV_LOG_ERROR, &quot;ms_present = 3 is reserved.\n&quot;);
+            return -1;
+        } else if(ms_present)
+            decode_mid_side_stereo(cpe, gb, ms_present);
+    }
+    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[0], gb, common_window, 0)))
+        return ret;
+    if ((ret = decode_ics(ac, &amp;cpe-&gt;ch[1], gb, common_window, 0)))
+        return ret;
+
+    if (common_window &amp;&amp; ms_present)
+        apply_mid_side_stereo(cpe);
+
+    apply_intensity_stereo(cpe, ms_present);
+    return 0;
+}
+
+/**
+ * Decode coupling_channel_element; reference: table 4.8.
+ *
+ * @param   elem_id Identifies the instance of a syntax element.
+ *
+ * @return  Returns error status. 0 - OK, !0 - error
+ */
+static int decode_cce(AACContext * ac, GetBitContext * gb, ChannelElement * che) {
+    int num_gain = 0;
+    int c, g, sfb, ret, idx = 0;
+    int sign;
+    float scale;
+    SingleChannelElement * sce = &amp;che-&gt;ch[0];
+    ChannelCoupling * coup     = &amp;che-&gt;coup;
+
+    coup-&gt;coupling_point = 2*get_bits1(gb);
+    coup-&gt;num_coupled = get_bits(gb, 3);
+    for (c = 0; c &lt;= coup-&gt;num_coupled; c++) {
+        num_gain++;
+        coup-&gt;type[c] = get_bits1(gb) ? TYPE_CPE : TYPE_SCE;
+        coup-&gt;id_select[c] = get_bits(gb, 4);
+        if (coup-&gt;type[c] == TYPE_CPE) {
+            coup-&gt;ch_select[c] = get_bits(gb, 2);
+            if (coup-&gt;ch_select[c] == 3)
+                num_gain++;
+        } else
+            coup-&gt;ch_select[c] = 1;
+    }
+    coup-&gt;coupling_point += get_bits1(gb);
+
+    if (coup-&gt;coupling_point == 2) {
+        av_log(ac-&gt;avccontext, AV_LOG_ERROR,
+            &quot;Independently switched CCE with 'invalid' domain signalled.\n&quot;);
+        memset(coup, 0, sizeof(ChannelCoupling));
+        return -1;
+    }
+
+    sign = get_bits(gb, 1);
+    scale = pow(2., pow(2., get_bits(gb, 2) - 3));
+
+    if ((ret = decode_ics(ac, sce, gb, 0, 0)))
+        return ret;
+
+    for (c = 0; c &lt; num_gain; c++) {
+        int cge = 1;
+        int gain = 0;
+        float gain_cache = 1.;
+        if (c) {
+            cge = coup-&gt;coupling_point == AFTER_IMDCT ? 1 : get_bits1(gb);
+            gain = cge ? get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60: 0;
+            gain_cache = pow(scale, gain);
+        }
+        for (g = 0; g &lt; sce-&gt;ics.num_window_groups; g++)
+            for (sfb = 0; sfb &lt; sce-&gt;ics.max_sfb; sfb++, idx++)
+                if (sce-&gt;band_type[idx] != ZERO_BT) {
+                    if (!cge) {
+                        int t = get_vlc2(gb, vlc_scalefactors.table, 7, 3) - 60;
+                        if (t) {
+                            int s = 1;
+                            if (sign) {
+                                s  -= 2 * (t &amp; 0x1);
+                                t &gt;&gt;= 1;
+                            }
+                            gain += t;
+                            gain_cache = pow(scale, gain) * s;
+                        }

[... truncated: 2142 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011849.html">[Haiku-commits] r27539 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011851.html">[Haiku-commits] r27541 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11850">[ date ]</a>
              <a href="thread.html#11850">[ thread ]</a>
              <a href="subject.html#11850">[ subject ]</a>
              <a href="author.html#11850">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
