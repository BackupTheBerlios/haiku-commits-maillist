<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27555 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27555%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151408.m8FE8a54000807%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011864.html">
   <LINK REL="Next"  HREF="011866.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27555 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27555%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151408.m8FE8a54000807%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27555 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:08:36 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011864.html">[Haiku-commits] r27554 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011866.html">[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11865">[ date ]</a>
              <a href="thread.html#11865">[ thread ]</a>
              <a href="subject.html#11865">[ subject ]</a>
              <a href="author.html#11865">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:08:35 +0200 (Mon, 15 Sep 2008)
New Revision: 27555
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27555&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27555&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8huff.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpcdata.h
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.c	2008-09-15 14:07:34 UTC (rev 27554)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.c	2008-09-15 14:08:35 UTC (rev 27555)
@@ -0,0 +1,108 @@
+/*
+ * Musepack decoder core
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpc.c Musepack decoder core
+ * MPEG Audio Layer 1/2 -like codec with frames of 1152 samples
+ * divided into 32 subbands.
+ */
+
+#include &quot;random.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#ifdef CONFIG_MPEGAUDIO_HP
+#define USE_HIGHPRECISION
+#endif
+#include &quot;mpegaudio.h&quot;
+
+#include &quot;mpc.h&quot;
+#include &quot;mpcdata.h&quot;
+
+static DECLARE_ALIGNED_16(MPA_INT, mpa_window[512]);
+
+void ff_mpc_init()
+{
+    ff_mpa_synth_init(mpa_window);
+}
+
+/**
+ * Process decoded Musepack data and produce PCM
+ */
+static void mpc_synth(MPCContext *c, int16_t *out)
+{
+    int dither_state = 0;
+    int i, ch;
+    OUT_INT samples[MPA_MAX_CHANNELS * MPA_FRAME_SIZE], *samples_ptr;
+
+    for(ch = 0;  ch &lt; 2; ch++){
+        samples_ptr = samples + ch;
+        for(i = 0; i &lt; SAMPLES_PER_BAND; i++) {
+            ff_mpa_synth_filter(c-&gt;synth_buf[ch], &amp;(c-&gt;synth_buf_offset[ch]),
+                                mpa_window, &amp;dither_state,
+                                samples_ptr, 2,
+                                c-&gt;sb_samples[ch][i]);
+            samples_ptr += 64;
+        }
+    }
+    for(i = 0; i &lt; MPC_FRAME_SIZE*2; i++)
+        *out++=samples[i];
+}
+
+void ff_mpc_dequantize_and_synth(MPCContext * c, int maxband, void *data)
+{
+    int i, j, ch;
+    Band *bands = c-&gt;bands;
+    int off;
+    float mul;
+
+    /* dequantize */
+    memset(c-&gt;sb_samples, 0, sizeof(c-&gt;sb_samples));
+    off = 0;
+    for(i = 0; i &lt;= maxband; i++, off += SAMPLES_PER_BAND){
+        for(ch = 0; ch &lt; 2; ch++){
+            if(bands[i].res[ch]){
+                j = 0;
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][0]];
+                for(; j &lt; 12; j++)
+                    c-&gt;sb_samples[ch][j][i] = mul * c-&gt;Q[ch][j + off];
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][1]];
+                for(; j &lt; 24; j++)
+                    c-&gt;sb_samples[ch][j][i] = mul * c-&gt;Q[ch][j + off];
+                mul = mpc_CC[bands[i].res[ch]] * mpc_SCF[bands[i].scf_idx[ch][2]];
+                for(; j &lt; 36; j++)
+                    c-&gt;sb_samples[ch][j][i] = mul * c-&gt;Q[ch][j + off];
+            }
+        }
+        if(bands[i].msf){
+            int t1, t2;
+            for(j = 0; j &lt; SAMPLES_PER_BAND; j++){
+                t1 = c-&gt;sb_samples[0][j][i];
+                t2 = c-&gt;sb_samples[1][j][i];
+                c-&gt;sb_samples[0][j][i] = t1 + t2;
+                c-&gt;sb_samples[1][j][i] = t1 - t2;
+            }
+        }
+    }
+
+    mpc_synth(c, data);
+}

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.h	2008-09-15 14:07:34 UTC (rev 27554)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc.h	2008-09-15 14:08:35 UTC (rev 27555)
@@ -0,0 +1,80 @@
+/*
+ * Musepack decoder
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpc.h Musepack decoder
+ * MPEG Audio Layer 1/2 -like codec with frames of 1152 samples
+ * divided into 32 subbands.
+ */
+
+#ifndef FFMPEG_MPC_H
+#define FFMPEG_MPC_H
+
+#include &quot;random.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#ifdef CONFIG_MPEGAUDIO_HP
+#define USE_HIGHPRECISION
+#endif
+#include &quot;mpegaudio.h&quot;
+
+#include &quot;mpcdata.h&quot;
+
+#define BANDS            32
+#define SAMPLES_PER_BAND 36
+#define MPC_FRAME_SIZE   (BANDS * SAMPLES_PER_BAND)
+
+/** Subband structure - hold all variables for each subband */
+typedef struct {
+    int msf; ///&lt; mid-stereo flag
+    int res[2];
+    int scfi[2];
+    int scf_idx[2][3];
+    int Q[2];
+}Band;
+
+typedef struct {
+    DSPContext dsp;
+    GetBitContext gb;
+    int IS, MSS, gapless;
+    int lastframelen;
+    int maxbands, last_max_band;
+    int last_bits_used;
+    int oldDSCF[2][BANDS];
+    Band bands[BANDS];
+    int Q[2][MPC_FRAME_SIZE];
+    int cur_frame, frames;
+    uint8_t *bits;
+    int buf_size;
+    AVRandomState rnd;
+    int frames_to_skip;
+    /* for synthesis */
+    DECLARE_ALIGNED_16(MPA_INT, synth_buf[MPA_MAX_CHANNELS][512*2]);
+    int synth_buf_offset[MPA_MAX_CHANNELS];
+    DECLARE_ALIGNED_16(int32_t, sb_samples[MPA_MAX_CHANNELS][36][SBLIMIT]);
+} MPCContext;
+
+extern void ff_mpc_init();
+extern void ff_mpc_dequantize_and_synth(MPCContext *c, int maxband, void *dst);
+
+#endif /* FFMPEG_MPC_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7.c	2008-09-15 14:07:34 UTC (rev 27554)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7.c	2008-09-15 14:08:35 UTC (rev 27555)
@@ -0,0 +1,278 @@
+/*
+ * Musepack SV7 decoder
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpc7.c Musepack SV7 decoder
+ * MPEG Audio Layer 1/2 -like codec with frames of 1152 samples
+ * divided into 32 subbands.
+ */
+
+#include &quot;random.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#ifdef CONFIG_MPEGAUDIO_HP
+#define USE_HIGHPRECISION
+#endif
+#include &quot;mpegaudio.h&quot;
+
+#include &quot;mpc.h&quot;
+#include &quot;mpc7data.h&quot;
+
+#define BANDS            32
+#define SAMPLES_PER_BAND 36
+#define MPC_FRAME_SIZE   (BANDS * SAMPLES_PER_BAND)
+
+static VLC scfi_vlc, dscf_vlc, hdr_vlc, quant_vlc[MPC7_QUANT_VLC_TABLES][2];
+
+static av_cold int mpc7_decode_init(AVCodecContext * avctx)
+{
+    int i, j;
+    MPCContext *c = avctx-&gt;priv_data;
+    GetBitContext gb;
+    uint8_t buf[16];
+    static int vlc_initialized = 0;
+
+    if(avctx-&gt;extradata_size &lt; 16){
+        av_log(avctx, AV_LOG_ERROR, &quot;Too small extradata size (%i)!\n&quot;, avctx-&gt;extradata_size);
+        return -1;
+    }
+    memset(c-&gt;oldDSCF, 0, sizeof(c-&gt;oldDSCF));
+    av_init_random(0xDEADBEEF, &amp;c-&gt;rnd);
+    dsputil_init(&amp;c-&gt;dsp, avctx);
+    c-&gt;dsp.bswap_buf((uint32_t*)buf, (const uint32_t*)avctx-&gt;extradata, 4);
+    ff_mpc_init();
+    init_get_bits(&amp;gb, buf, 128);
+
+    c-&gt;IS = get_bits1(&amp;gb);
+    c-&gt;MSS = get_bits1(&amp;gb);
+    c-&gt;maxbands = get_bits(&amp;gb, 6);
+    if(c-&gt;maxbands &gt;= BANDS){
+        av_log(avctx, AV_LOG_ERROR, &quot;Too many bands: %i\n&quot;, c-&gt;maxbands);
+        return -1;
+    }
+    skip_bits(&amp;gb, 88);
+    c-&gt;gapless = get_bits1(&amp;gb);
+    c-&gt;lastframelen = get_bits(&amp;gb, 11);
+    av_log(avctx, AV_LOG_DEBUG, &quot;IS: %d, MSS: %d, TG: %d, LFL: %d, bands: %d\n&quot;,
+            c-&gt;IS, c-&gt;MSS, c-&gt;gapless, c-&gt;lastframelen, c-&gt;maxbands);
+    c-&gt;frames_to_skip = 0;
+
+    if(vlc_initialized) return 0;
+    av_log(avctx, AV_LOG_DEBUG, &quot;Initing VLC\n&quot;);
+    if(init_vlc(&amp;scfi_vlc, MPC7_SCFI_BITS, MPC7_SCFI_SIZE,
+                &amp;mpc7_scfi[1], 2, 1,
+                &amp;mpc7_scfi[0], 2, 1, INIT_VLC_USE_STATIC)){
+        av_log(avctx, AV_LOG_ERROR, &quot;Cannot init SCFI VLC\n&quot;);
+        return -1;
+    }
+    if(init_vlc(&amp;dscf_vlc, MPC7_DSCF_BITS, MPC7_DSCF_SIZE,
+                &amp;mpc7_dscf[1], 2, 1,
+                &amp;mpc7_dscf[0], 2, 1, INIT_VLC_USE_STATIC)){
+        av_log(avctx, AV_LOG_ERROR, &quot;Cannot init DSCF VLC\n&quot;);
+        return -1;
+    }
+    if(init_vlc(&amp;hdr_vlc, MPC7_HDR_BITS, MPC7_HDR_SIZE,
+                &amp;mpc7_hdr[1], 2, 1,
+                &amp;mpc7_hdr[0], 2, 1, INIT_VLC_USE_STATIC)){
+        av_log(avctx, AV_LOG_ERROR, &quot;Cannot init HDR VLC\n&quot;);
+        return -1;
+    }
+    for(i = 0; i &lt; MPC7_QUANT_VLC_TABLES; i++){
+        for(j = 0; j &lt; 2; j++){
+            if(init_vlc(&amp;quant_vlc[i][j], 9, mpc7_quant_vlc_sizes[i],
+                        &amp;mpc7_quant_vlc[i][j][1], 4, 2,
+                        &amp;mpc7_quant_vlc[i][j][0], 4, 2, INIT_VLC_USE_STATIC)){
+                av_log(avctx, AV_LOG_ERROR, &quot;Cannot init QUANT VLC %i,%i\n&quot;,i,j);
+                return -1;
+            }
+        }
+    }
+    vlc_initialized = 1;
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+    return 0;
+}
+
+/**
+ * Fill samples for given subband
+ */
+static inline void idx_to_quant(MPCContext *c, GetBitContext *gb, int idx, int *dst)
+{
+    int i, i1, t;
+    switch(idx){
+    case -1:
+        for(i = 0; i &lt; SAMPLES_PER_BAND; i++){
+            *dst++ = (av_random(&amp;c-&gt;rnd) &amp; 0x3FC) - 510;
+        }
+        break;
+    case 1:
+        i1 = get_bits1(gb);
+        for(i = 0; i &lt; SAMPLES_PER_BAND/3; i++){
+            t = get_vlc2(gb, quant_vlc[0][i1].table, 9, 2);
+            *dst++ = mpc7_idx30[t];
+            *dst++ = mpc7_idx31[t];
+            *dst++ = mpc7_idx32[t];
+        }
+        break;
+    case 2:
+        i1 = get_bits1(gb);
+        for(i = 0; i &lt; SAMPLES_PER_BAND/2; i++){
+            t = get_vlc2(gb, quant_vlc[1][i1].table, 9, 2);
+            *dst++ = mpc7_idx50[t];
+            *dst++ = mpc7_idx51[t];
+        }
+        break;
+    case  3: case  4: case  5: case  6: case  7:
+        i1 = get_bits1(gb);
+        for(i = 0; i &lt; SAMPLES_PER_BAND; i++)
+            *dst++ = get_vlc2(gb, quant_vlc[idx-1][i1].table, 9, 2) - mpc7_quant_vlc_off[idx-1];
+        break;
+    case  8: case  9: case 10: case 11: case 12:
+    case 13: case 14: case 15: case 16: case 17:
+        t = (1 &lt;&lt; (idx - 2)) - 1;
+        for(i = 0; i &lt; SAMPLES_PER_BAND; i++)
+            *dst++ = get_bits(gb, idx - 1) - t;
+        break;
+    default: // case 0 and -2..-17
+        return;
+    }
+}
+
+static int mpc7_decode_frame(AVCodecContext * avctx,
+                            void *data, int *data_size,
+                            const uint8_t * buf, int buf_size)
+{
+    MPCContext *c = avctx-&gt;priv_data;
+    GetBitContext gb;
+    uint8_t *bits;
+    int i, ch, t;
+    int mb = -1;
+    Band *bands = c-&gt;bands;
+    int off;
+    int bits_used, bits_avail;
+
+    memset(bands, 0, sizeof(bands));
+    if(buf_size &lt;= 4){
+        av_log(avctx, AV_LOG_ERROR, &quot;Too small buffer passed (%i bytes)\n&quot;, buf_size);
+    }
+
+    bits = av_malloc(((buf_size - 1) &amp; ~3) + FF_INPUT_BUFFER_PADDING_SIZE);
+    c-&gt;dsp.bswap_buf((uint32_t*)bits, (const uint32_t*)(buf + 4), (buf_size - 4) &gt;&gt; 2);
+    init_get_bits(&amp;gb, bits, (buf_size - 4)* 8);
+    skip_bits(&amp;gb, buf[0]);
+
+    /* read subband indexes */
+    for(i = 0; i &lt;= c-&gt;maxbands; i++){
+        for(ch = 0; ch &lt; 2; ch++){
+            if(i) t = get_vlc2(&amp;gb, hdr_vlc.table, MPC7_HDR_BITS, 1) - 5;
+            if(!i || (t == 4)) bands[i].res[ch] = get_bits(&amp;gb, 4);
+            else bands[i].res[ch] = bands[i-1].res[ch] + t;
+        }
+
+        if(bands[i].res[0] || bands[i].res[1]){
+            mb = i;
+            if(c-&gt;MSS) bands[i].msf = get_bits1(&amp;gb);
+        }
+    }
+    /* get scale indexes coding method */
+    for(i = 0; i &lt;= mb; i++)
+        for(ch = 0; ch &lt; 2; ch++)
+            if(bands[i].res[ch]) bands[i].scfi[ch] = get_vlc2(&amp;gb, scfi_vlc.table, MPC7_SCFI_BITS, 1);
+    /* get scale indexes */
+    for(i = 0; i &lt;= mb; i++){
+        for(ch = 0; ch &lt; 2; ch++){
+            if(bands[i].res[ch]){
+                bands[i].scf_idx[ch][2] = c-&gt;oldDSCF[ch][i];
+                t = get_vlc2(&amp;gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
+                bands[i].scf_idx[ch][0] = (t == 8) ? get_bits(&amp;gb, 6) : (bands[i].scf_idx[ch][2] + t);
+                switch(bands[i].scfi[ch]){
+                case 0:
+                    t = get_vlc2(&amp;gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
+                    bands[i].scf_idx[ch][1] = (t == 8) ? get_bits(&amp;gb, 6) : (bands[i].scf_idx[ch][0] + t);
+                    t = get_vlc2(&amp;gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
+                    bands[i].scf_idx[ch][2] = (t == 8) ? get_bits(&amp;gb, 6) : (bands[i].scf_idx[ch][1] + t);
+                    break;
+                case 1:
+                    t = get_vlc2(&amp;gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
+                    bands[i].scf_idx[ch][1] = (t == 8) ? get_bits(&amp;gb, 6) : (bands[i].scf_idx[ch][0] + t);
+                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1];
+                    break;
+                case 2:
+                    bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];
+                    t = get_vlc2(&amp;gb, dscf_vlc.table, MPC7_DSCF_BITS, 1) - 7;
+                    bands[i].scf_idx[ch][2] = (t == 8) ? get_bits(&amp;gb, 6) : (bands[i].scf_idx[ch][1] + t);
+                    break;
+                case 3:
+                    bands[i].scf_idx[ch][2] = bands[i].scf_idx[ch][1] = bands[i].scf_idx[ch][0];
+                    break;
+                }
+                c-&gt;oldDSCF[ch][i] = bands[i].scf_idx[ch][2];
+            }
+        }
+    }
+    /* get quantizers */
+    memset(c-&gt;Q, 0, sizeof(c-&gt;Q));
+    off = 0;
+    for(i = 0; i &lt; BANDS; i++, off += SAMPLES_PER_BAND)
+        for(ch = 0; ch &lt; 2; ch++)
+            idx_to_quant(c, &amp;gb, bands[i].res[ch], c-&gt;Q[ch] + off);
+
+    ff_mpc_dequantize_and_synth(c, mb, data);
+
+    av_free(bits);
+
+    bits_used = get_bits_count(&amp;gb);
+    bits_avail = (buf_size - 4) * 8;
+    if(!buf[1] &amp;&amp; ((bits_avail &lt; bits_used) || (bits_used + 32 &lt;= bits_avail))){
+        av_log(NULL,0, &quot;Error decoding frame: used %i of %i bits\n&quot;, bits_used, bits_avail);
+        return -1;
+    }
+    if(c-&gt;frames_to_skip){
+        c-&gt;frames_to_skip--;
+        *data_size = 0;
+        return buf_size;
+    }
+    *data_size = (buf[1] ? c-&gt;lastframelen : MPC_FRAME_SIZE) * 4;
+
+    return buf_size;
+}
+
+static void mpc7_decode_flush(AVCodecContext *avctx)
+{
+    MPCContext *c = avctx-&gt;priv_data;
+
+    memset(c-&gt;oldDSCF, 0, sizeof(c-&gt;oldDSCF));
+    c-&gt;frames_to_skip = 32;
+}
+
+AVCodec mpc7_decoder = {
+    &quot;mpc7&quot;,
+    CODEC_TYPE_AUDIO,
+    CODEC_ID_MUSEPACK7,
+    sizeof(MPCContext),
+    mpc7_decode_init,
+    NULL,
+    NULL,
+    mpc7_decode_frame,
+    .flush = mpc7_decode_flush,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;Musepack SV7&quot;),
+};

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7data.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7data.h	2008-09-15 14:07:34 UTC (rev 27554)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc7data.h	2008-09-15 14:08:35 UTC (rev 27555)
@@ -0,0 +1,171 @@
+/*
+ * Musepack decoder
+ * Copyright (c) 2006 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_MPC7DATA_H
+#define FFMPEG_MPC7DATA_H
+
+#include &lt;stdint.h&gt;
+
+static const int8_t mpc7_idx30[] = { -1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1};
+static const int8_t mpc7_idx31[] = { -1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1};
+static const int8_t mpc7_idx32[] = { -1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+static const int8_t mpc7_idx50[] = { -2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2,-2,-1, 0, 1, 2};
+static const int8_t mpc7_idx51[] = { -2,-2,-2,-2,-2,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2};
+
+#define MPC7_SCFI_SIZE  4
+#define MPC7_SCFI_BITS  3
+static const uint8_t mpc7_scfi[MPC7_SCFI_SIZE * 2] = {
+    0x2, 3, 0x1, 1, 0x3, 3, 0x0, 2
+};
+
+#define MPC7_DSCF_SIZE 16
+#define MPC7_DSCF_BITS  6
+static const uint8_t mpc7_dscf[MPC7_DSCF_SIZE * 2] = {
+    0x20, 6, 0x04, 5, 0x11, 5, 0x1E, 5, 0x0D, 4, 0x00, 3, 0x03, 3, 0x09, 4,
+    0x05, 3, 0x02, 3, 0x0E, 4, 0x03, 4, 0x1F, 5, 0x05, 5, 0x21, 6, 0x0C, 4
+};
+
+#define MPC7_HDR_SIZE  10
+#define MPC7_HDR_BITS   9
+static const uint8_t mpc7_hdr[MPC7_HDR_SIZE * 2] = {
+    0x5C, 8, 0x2F, 7, 0x0A, 5, 0x04, 4, 0x00, 2,
+    0x01, 1, 0x03, 3, 0x16, 6, 0xBB, 9, 0xBA, 9
+};
+
+#define MPC7_QUANT_VLC_TABLES 7
+static const uint8_t mpc7_quant_vlc_sizes[MPC7_QUANT_VLC_TABLES * 2] = {
+    27, 25, 7, 9, 15, 31, 63
+};
+
+static const uint8_t mpc7_quant_vlc_off[MPC7_QUANT_VLC_TABLES] = {
+    0, 0, 3, 4, 7, 15, 31
+};
+
+static const uint16_t mpc7_quant_vlc[MPC7_QUANT_VLC_TABLES][2][64 * 2] = {
+{
+    {
+        0x0036,  6, 0x0009,  5, 0x0020,  6, 0x0005,  5, 0x000A,  4, 0x0007,  5,
+        0x0034,  6, 0x0000,  5, 0x0023,  6, 0x000A,  5, 0x0006,  4, 0x0004,  5,
+        0x000B,  4, 0x0007,  3, 0x000C,  4, 0x0003,  5, 0x0007,  4, 0x000B,  5,
+        0x0022,  6, 0x0001,  5, 0x0035,  6, 0x0006,  5, 0x0009,  4, 0x0002,  5,
+        0x0021,  6, 0x0008,  5, 0x0037,  6
+    },
+    {
+        0x0067,  8, 0x003E,  7, 0x00E1,  9, 0x0037,  7, 0x0003,  4, 0x0034,  7,
+        0x0065,  8, 0x003C,  7, 0x00E3,  9, 0x0018,  6, 0x0000,  4, 0x003D,  7,
+        0x0004,  4, 0x0001,  1, 0x0005,  4, 0x003F,  7, 0x0001,  4, 0x003B,  7,
+        0x00E2,  9, 0x0039,  7, 0x0064,  8, 0x0035,  7, 0x0002,  4, 0x0036,  7,
+        0x00E0,  9, 0x003A,  7, 0x0066,  8
+    }
+},
+{
+    {
+        0x0059,  7, 0x002F,  6, 0x000F,  5, 0x0000,  5, 0x005B,  7, 0x0004,  5,
+        0x0006,  4, 0x000D,  4, 0x0004,  4, 0x0005,  5, 0x0014,  5, 0x000C,  4,
+        0x0004,  3, 0x000F,  4, 0x000E,  5, 0x0003,  5, 0x0003,  4, 0x000E,  4,
+        0x0005,  4, 0x0001,  5, 0x005A,  7, 0x0002,  5, 0x0015,  5, 0x002E,  6,
+        0x0058,  7
+    },
+    {
+        0x0399, 10, 0x0071,  7, 0x0033,  6, 0x00E7,  8, 0x039A, 10, 0x0068,  7,
+        0x001E,  5, 0x0000,  3, 0x001D,  5, 0x0069,  7, 0x0032,  6, 0x0001,  3,
+        0x0002,  2, 0x0003,  3, 0x0031,  6, 0x006B,  7, 0x001B,  5, 0x0002,  3,
+        0x001F,  5, 0x0070,  7, 0x0398, 10, 0x006A,  7, 0x0030,  6, 0x0072,  7,
+        0x039B, 10
+    }
+},
+{
+    {
+        0x000C,  4, 0x0004,  3, 0x0000,  2, 0x0001,  2, 0x0007,  3, 0x0005,  3, 0x000D,  4
+    },
+    {
+        0x0004,  5, 0x0003,  4, 0x0002,  2, 0x0003,  2, 0x0001,  2, 0x0000,  3, 0x0005,  5
+    }
+},
+{
+    {
+        0x0005,  4, 0x0000,  3, 0x0004,  3, 0x0006,  3, 0x0007,  3, 0x0005,  3, 0x0003,  3, 0x0001,  3, 0x0004,  4
+    },
+    {
+        0x0009,  5, 0x000C,  4, 0x0003,  3, 0x0000,  2, 0x0002,  2, 0x0007,  3, 0x000D,  4, 0x0005,  4, 0x0008,  5
+    }
+},
+{
+    {
+        0x0039,  6, 0x0017,  5, 0x0008,  4, 0x000A,  4, 0x000D,  4, 0x0000,  3,
+        0x0002,  3, 0x0003,  3, 0x0001,  3, 0x000F,  4, 0x000C,  4, 0x0009,  4,
+        0x001D,  5, 0x0016,  5, 0x0038,  6,
+    },
+    {
+        0x00E5,  8, 0x0038,  6, 0x0007,  5, 0x0002,  4, 0x0000,  3, 0x0003,  3,
+        0x0005,  3, 0x0006,  3, 0x0004,  3, 0x0002,  3, 0x000F,  4, 0x001D,  5,
+        0x0006,  5, 0x0073,  7, 0x00E4,  8,
+    },
+},
+{
+    {
+        0x0041,  7, 0x0006,  6, 0x002C,  6, 0x002D,  6, 0x003B,  6, 0x000D,  5,
+        0x0011,  5, 0x0013,  5, 0x0017,  5, 0x0015,  5, 0x001A,  5, 0x001E,  5,
+        0x0000,  4, 0x0002,  4, 0x0005,  4, 0x0007,  4, 0x0003,  4, 0x0004,  4,
+        0x001F,  5, 0x001C,  5, 0x0019,  5, 0x001B,  5, 0x0018,  5, 0x0014,  5,
+        0x0012,  5, 0x000C,  5, 0x0002,  5, 0x003A,  6, 0x0021,  6, 0x0007,  6,
+        0x0040,  7
+    },
+    {
+        0x1948, 13, 0x194A, 13, 0x0328, 10, 0x0195,  9, 0x00CB,  8, 0x0066,  7,
+        0x0031,  6, 0x0009,  5, 0x000F,  5, 0x001F,  5, 0x0002,  4, 0x0006,  4,
+        0x0008,  4, 0x000B,  4, 0x000D,  4, 0x0000,  3, 0x000E,  4, 0x000A,  4,
+        0x0009,  4, 0x0005,  4, 0x0003,  4, 0x001E,  5, 0x000E,  5, 0x0008,  5,
+        0x0030,  6, 0x0067,  7, 0x00C9,  8, 0x00C8,  8, 0x0653, 11, 0x1949, 13,
+        0x194B, 13
+    }
+},
+{
+    {
+        0x0067,  8, 0x0099,  8, 0x00B5,  8, 0x00E9,  8, 0x0040,  7, 0x0041,  7,
+        0x004D,  7, 0x0051,  7, 0x005B,  7, 0x0071,  7, 0x0070,  7, 0x0018,  6,
+        0x001D,  6, 0x0023,  6, 0x0025,  6, 0x0029,  6, 0x002C,  6, 0x002E,  6,
+        0x0033,  6, 0x0031,  6, 0x0036,  6, 0x0037,  6, 0x0039,  6, 0x003C,  6,
+        0x0000,  5, 0x0002,  5, 0x000A,  5, 0x0005,  5, 0x0009,  5, 0x0006,  5,
+        0x000D,  5, 0x0007,  5, 0x000B,  5, 0x000F,  5, 0x0008,  5, 0x0004,  5,
+        0x0003,  5, 0x0001,  5, 0x003F,  6, 0x003E,  6, 0x003D,  6, 0x0035,  6,
+        0x003B,  6, 0x0034,  6, 0x0030,  6, 0x002F,  6, 0x002B,  6, 0x002A,  6,
+        0x0027,  6, 0x0024,  6, 0x0021,  6, 0x001C,  6, 0x0075,  7, 0x0065,  7,
+        0x0064,  7, 0x0050,  7, 0x0045,  7, 0x0044,  7, 0x0032,  7, 0x00E8,  8,
+        0x00B4,  8, 0x0098,  8, 0x0066,  8
+    },
+    {
+        0x37A4, 14, 0x37AD, 14, 0x37A6, 14, 0x37AE, 14, 0x0DEA, 12, 0x02F0, 10,
+        0x02F1, 10, 0x00A0,  9, 0x00A2,  9, 0x01BC,  9, 0x007A,  8, 0x00DF,  8,
+        0x003C,  7, 0x0049,  7, 0x006E,  7, 0x000E,  6, 0x0018,  6, 0x0019,  6,
+        0x0022,  6, 0x0025,  6, 0x0036,  6, 0x0003,  5, 0x0009,  5, 0x000B,  5,
+        0x0010,  5, 0x0013,  5, 0x0015,  5, 0x0018,  5, 0x001A,  5, 0x001D,  5,
+        0x001F,  5, 0x0002,  4, 0x0000,  4, 0x001E,  5, 0x001C,  5, 0x0019,  5,
+        0x0016,  5, 0x0014,  5, 0x000E,  5, 0x000D,  5, 0x0008,  5, 0x0006,  5,
+        0x0002,  5, 0x002E,  6, 0x0023,  6, 0x001F,  6, 0x0015,  6, 0x000F,  6,
+        0x005F,  7, 0x0048,  7, 0x0029,  7, 0x00BD,  8, 0x007B,  8, 0x0179,  9,
+        0x00A1,  9, 0x037B, 10, 0x0147, 10, 0x0146, 10, 0x0DE8, 12, 0x37AF, 14,
+        0x37A7, 14, 0x37AC, 14, 0x37A5, 14
+    }
+}
+};
+
+#endif /* FFMPEG_MPC7DATA_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8.c	2008-09-15 14:07:34 UTC (rev 27554)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mpc8.c	2008-09-15 14:08:35 UTC (rev 27555)
@@ -0,0 +1,366 @@
+/*
+ * Musepack SV8 decoder
+ * Copyright (c) 2007 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file mpc8.c Musepack SV8 decoder
+ * MPEG Audio Layer 1/2 -like codec with frames of 1152 samples
+ * divided into 32 subbands.
+ */
+
+#include &quot;random.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#ifdef CONFIG_MPEGAUDIO_HP
+#define USE_HIGHPRECISION
+#endif
+#include &quot;mpegaudio.h&quot;
+
+#include &quot;mpc.h&quot;
+#include &quot;mpcdata.h&quot;
+#include &quot;mpc8data.h&quot;
+#include &quot;mpc8huff.h&quot;
+
+static VLC band_vlc, scfi_vlc[2], dscf_vlc[2], res_vlc[2];
+static VLC q1_vlc, q2_vlc[2], q3_vlc[2], quant_vlc[4][2], q9up_vlc;
+
+static const int q3_offsets[2] = { MPC8_Q3_OFFSET, MPC8_Q4_OFFSET };
+static const int quant_offsets[6] = { MPC8_Q5_OFFSET, MPC8_Q6_OFFSET, MPC8_Q7_OFFSET, MPC8_Q8_OFFSET };
+
+static inline int mpc8_dec_base(GetBitContext *gb, int k, int n)
+{
+    int code = get_bits(gb, mpc8_cnk_len[k-1][n-1] - 1);
+
+    if (code &gt;= mpc8_cnk_lost[k-1][n-1])
+        code = ((code &lt;&lt; 1) | get_bits1(gb)) - mpc8_cnk_lost[k-1][n-1];
+
+    return code;
+}
+
+static inline int mpc8_dec_enum(GetBitContext *gb, int k, int n)
+{
+    int bits = 0;
+    const uint32_t * C = mpc8_cnk[k-1];
+    int code = mpc8_dec_base(gb, k, n);
+
+    do {
+        n--;
+        if (code &gt;= C[n]) {
+            bits |= 1 &lt;&lt; n;
+            code -= C[n];
+            C -= 32;
+            k--;
+        }
+    } while(k &gt; 0);
+
+    return bits;
+}
+
+static inline int mpc8_get_mod_golomb(GetBitContext *gb, int m)
+{
+    if(mpc8_cnk_len[0][m] &lt; 1) return 0;
+    return mpc8_dec_base(gb, 1, m+1);
+}
+
+static int mpc8_get_mask(GetBitContext *gb, int size, int t)
+{
+    int mask = 0;
+
+    if(t &amp;&amp; t != size)
+         mask = mpc8_dec_enum(gb, FFMIN(t, size - t), size);
+    if((t &lt;&lt; 1) &gt; size) mask = ~mask;
+
+    return mask;
+}
+
+static av_cold int mpc8_decode_init(AVCodecContext * avctx)
+{
+    int i;
+    MPCContext *c = avctx-&gt;priv_data;
+    GetBitContext gb;
+    static int vlc_initialized = 0;
+
+    if(avctx-&gt;extradata_size &lt; 2){
+        av_log(avctx, AV_LOG_ERROR, &quot;Too small extradata size (%i)!\n&quot;, avctx-&gt;extradata_size);
+        return -1;
+    }
+    memset(c-&gt;oldDSCF, 0, sizeof(c-&gt;oldDSCF));
+    av_init_random(0xDEADBEEF, &amp;c-&gt;rnd);
+    dsputil_init(&amp;c-&gt;dsp, avctx);
+
+    ff_mpc_init();
+
+    init_get_bits(&amp;gb, avctx-&gt;extradata, 16);
+
+    skip_bits(&amp;gb, 3);//sample rate
+    c-&gt;maxbands = get_bits(&amp;gb, 5) + 1;
+    skip_bits(&amp;gb, 4);//channels
+    c-&gt;MSS = get_bits1(&amp;gb);
+    c-&gt;frames = 1 &lt;&lt; (get_bits(&amp;gb, 3) * 2);
+
+    if(vlc_initialized) return 0;
+    av_log(avctx, AV_LOG_DEBUG, &quot;Initing VLC\n&quot;);
+
+    init_vlc(&amp;band_vlc, MPC8_BANDS_BITS, MPC8_BANDS_SIZE,
+             mpc8_bands_bits,  1, 1,
+             mpc8_bands_codes, 1, 1, INIT_VLC_USE_STATIC);
+
+    init_vlc(&amp;q1_vlc, MPC8_Q1_BITS, MPC8_Q1_SIZE,
+             mpc8_q1_bits,  1, 1,
+             mpc8_q1_codes, 1, 1, INIT_VLC_USE_STATIC);
+    init_vlc(&amp;q9up_vlc, MPC8_Q9UP_BITS, MPC8_Q9UP_SIZE,
+             mpc8_q9up_bits,  1, 1,
+             mpc8_q9up_codes, 1, 1, INIT_VLC_USE_STATIC);
+
+    init_vlc(&amp;scfi_vlc[0], MPC8_SCFI0_BITS, MPC8_SCFI0_SIZE,
+             mpc8_scfi0_bits,  1, 1,
+             mpc8_scfi0_codes, 1, 1, INIT_VLC_USE_STATIC);
+    init_vlc(&amp;scfi_vlc[1], MPC8_SCFI1_BITS, MPC8_SCFI1_SIZE,
+             mpc8_scfi1_bits,  1, 1,
+             mpc8_scfi1_codes, 1, 1, INIT_VLC_USE_STATIC);
+
+    init_vlc(&amp;dscf_vlc[0], MPC8_DSCF0_BITS, MPC8_DSCF0_SIZE,
+             mpc8_dscf0_bits,  1, 1,
+             mpc8_dscf0_codes, 1, 1, INIT_VLC_USE_STATIC);
+    init_vlc(&amp;dscf_vlc[1], MPC8_DSCF1_BITS, MPC8_DSCF1_SIZE,
+             mpc8_dscf1_bits,  1, 1,
+             mpc8_dscf1_codes, 1, 1, INIT_VLC_USE_STATIC);
+
+    init_vlc_sparse(&amp;q3_vlc[0], MPC8_Q3_BITS, MPC8_Q3_SIZE,
+             mpc8_q3_bits,  1, 1,
+             mpc8_q3_codes, 1, 1,
+             mpc8_q3_syms,  1, 1, INIT_VLC_USE_STATIC);
+    init_vlc_sparse(&amp;q3_vlc[1], MPC8_Q4_BITS, MPC8_Q4_SIZE,
+             mpc8_q4_bits,  1, 1,
+             mpc8_q4_codes, 1, 1,
+             mpc8_q4_syms,  1, 1, INIT_VLC_USE_STATIC);
+
+    for(i = 0; i &lt; 2; i++){
+        init_vlc(&amp;res_vlc[i], MPC8_RES_BITS, MPC8_RES_SIZE,
+                 &amp;mpc8_res_bits[i],  1, 1,
+                 &amp;mpc8_res_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+
+        init_vlc(&amp;q2_vlc[i], MPC8_Q2_BITS, MPC8_Q2_SIZE,
+                 &amp;mpc8_q2_bits[i],  1, 1,
+                 &amp;mpc8_q2_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+
+        init_vlc(&amp;quant_vlc[0][i], MPC8_Q5_BITS, MPC8_Q5_SIZE,
+                 &amp;mpc8_q5_bits[i],  1, 1,
+                 &amp;mpc8_q5_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+        init_vlc(&amp;quant_vlc[1][i], MPC8_Q6_BITS, MPC8_Q6_SIZE,
+                 &amp;mpc8_q6_bits[i],  1, 1,
+                 &amp;mpc8_q6_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+        init_vlc(&amp;quant_vlc[2][i], MPC8_Q7_BITS, MPC8_Q7_SIZE,
+                 &amp;mpc8_q7_bits[i],  1, 1,
+                 &amp;mpc8_q7_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+        init_vlc(&amp;quant_vlc[3][i], MPC8_Q8_BITS, MPC8_Q8_SIZE,
+                 &amp;mpc8_q8_bits[i],  1, 1,
+                 &amp;mpc8_q8_codes[i], 1, 1, INIT_VLC_USE_STATIC);
+    }
+    vlc_initialized = 1;
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
+    return 0;
+}
+
+static int mpc8_decode_frame(AVCodecContext * avctx,
+                            void *data, int *data_size,
+                            const uint8_t * buf, int buf_size)
+{
+    MPCContext *c = avctx-&gt;priv_data;
+    GetBitContext gb2, *gb = &amp;gb2;
+    int i, j, k, ch, cnt, res, t;
+    Band *bands = c-&gt;bands;
+    int off;
+    int maxband, keyframe;
+    int last[2];
+
+    keyframe = c-&gt;cur_frame == 0;
+
+    if(keyframe){
+        memset(c-&gt;Q, 0, sizeof(c-&gt;Q));
+        c-&gt;last_bits_used = 0;
+    }
+    init_get_bits(gb, buf, buf_size * 8);
+    skip_bits(gb, c-&gt;last_bits_used &amp; 7);
+
+    if(keyframe)
+        maxband = mpc8_get_mod_golomb(gb, c-&gt;maxbands + 1);
+    else{
+        maxband = c-&gt;last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);
+        if(maxband &gt; 32) maxband -= 33;
+    }
+    c-&gt;last_max_band = maxband;
+
+    /* read subband indexes */
+    if(maxband){
+        last[0] = last[1] = 0;
+        for(i = maxband - 1; i &gt;= 0; i--){
+            for(ch = 0; ch &lt; 2; ch++){
+                last[ch] = get_vlc2(gb, res_vlc[last[ch] &gt; 2].table, MPC8_RES_BITS, 2) + last[ch];
+                if(last[ch] &gt; 15) last[ch] -= 17;
+                bands[i].res[ch] = last[ch];
+            }
+        }
+        if(c-&gt;MSS){
+            int mask;
+
+            cnt = 0;
+            for(i = 0; i &lt; maxband; i++)
+                if(bands[i].res[0] || bands[i].res[1])
+                    cnt++;
+            t = mpc8_get_mod_golomb(gb, cnt);
+            mask = mpc8_get_mask(gb, cnt, t);
+            for(i = maxband - 1; i &gt;= 0; i--)
+                if(bands[i].res[0] || bands[i].res[1]){
+                    bands[i].msf = mask &amp; 1;
+                    mask &gt;&gt;= 1;
+                }
+        }
+    }
+    for(i = maxband; i &lt; c-&gt;maxbands; i++)
+        bands[i].res[0] = bands[i].res[1] = 0;
+
+    if(keyframe){
+        for(i = 0; i &lt; 32; i++)
+            c-&gt;oldDSCF[0][i] = c-&gt;oldDSCF[1][i] = 1;
+    }
+
+    for(i = 0; i &lt; maxband; i++){
+        if(bands[i].res[0] || bands[i].res[1]){
+            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;
+            if(cnt &gt;= 0){
+                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);
+                if(bands[i].res[0]) bands[i].scfi[0] = t &gt;&gt; (2 * cnt);
+                if(bands[i].res[1]) bands[i].scfi[1] = t &amp; 3;
+            }
+        }
+    }
+
+    for(i = 0; i &lt; maxband; i++){
+        for(ch = 0; ch &lt; 2; ch++){
+            if(!bands[i].res[ch]) continue;
+
+            if(c-&gt;oldDSCF[ch][i]){
+                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;
+                c-&gt;oldDSCF[ch][i] = 0;
+            }else{
+                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);
+                if(t == 64)
+                    t += get_bits(gb, 6);
+                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) &amp; 0x7F) - 6;
+            }
+            for(j = 0; j &lt; 2; j++){
+                if((bands[i].scfi[ch] &lt;&lt; j) &amp; 2)
+                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];
+                else{
+                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);
+                    if(t == 31)
+                        t = 64 + get_bits(gb, 6);
+                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) &amp; 0x7F) - 6;
+                }
+            }
+        }
+    }
+
+    for(i = 0, off = 0; i &lt; maxband; i++, off += SAMPLES_PER_BAND){
+        for(ch = 0; ch &lt; 2; ch++){
+            res = bands[i].res[ch];
+            switch(res){
+            case -1:
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j++)
+                    c-&gt;Q[ch][off + j] = (av_random(&amp;c-&gt;rnd) &amp; 0x3FC) - 510;
+                break;
+            case 0:
+                break;
+            case 1:
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){
+                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);
+                    t = mpc8_get_mask(gb, 18, cnt);
+                    for(k = 0; k &lt; SAMPLES_PER_BAND / 2; k++, t &lt;&lt;= 1)
+                        c-&gt;Q[ch][off + j + k] = (t &amp; 0x20000) ? (get_bits1(gb) &lt;&lt; 1) - 1 : 0;
+                }
+                break;
+            case 2:
+                cnt = 6;//2*mpc8_thres[res]
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j += 3){
+                    t = get_vlc2(gb, q2_vlc[cnt &gt; 3].table, MPC8_Q2_BITS, 2);
+                    c-&gt;Q[ch][off + j + 0] = mpc8_idx50[t];
+                    c-&gt;Q[ch][off + j + 1] = mpc8_idx51[t];
+                    c-&gt;Q[ch][off + j + 2] = mpc8_idx52[t];
+                    cnt = (cnt &gt;&gt; 1) + mpc8_huffq2[t];
+                }
+                break;
+            case 3:
+            case 4:
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j += 2){
+                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];
+                    c-&gt;Q[ch][off + j + 1] = t &gt;&gt; 4;
+                    c-&gt;Q[ch][off + j + 0] = (t &amp; 8) ? (t &amp; 0xF) - 16 : (t &amp; 0xF);
+                }
+                break;
+            case 5:
+            case 6:
+            case 7:
+            case 8:
+                cnt = 2 * mpc8_thres[res];
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j++){
+                    t = get_vlc2(gb, quant_vlc[res - 5][cnt &gt; mpc8_thres[res]].table, quant_vlc[res - 5][cnt &gt; mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];
+                    c-&gt;Q[ch][off + j] = t;
+                    cnt = (cnt &gt;&gt; 1) + FFABS(c-&gt;Q[ch][off + j]);
+                }
+                break;
+            default:
+                for(j = 0; j &lt; SAMPLES_PER_BAND; j++){
+                    c-&gt;Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);
+                    if(res != 9){

[... truncated: 818 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011864.html">[Haiku-commits] r27554 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011866.html">[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11865">[ date ]</a>
              <a href="thread.html#11865">[ thread ]</a>
              <a href="subject.html#11865">[ subject ]</a>
              <a href="author.html#11865">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
