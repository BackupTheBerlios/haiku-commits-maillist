<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27566 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27566%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151414.m8FEEGJL001861%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011875.html">
   <LINK REL="Next"  HREF="011879.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27566 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27566%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151414.m8FEEGJL001861%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27566 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:14:16 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011875.html">[Haiku-commits] r27565 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011879.html">[Haiku-commits] r27566 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11876">[ date ]</a>
              <a href="thread.html#11876">[ thread ]</a>
              <a href="subject.html#11876">[ subject ]</a>
              <a href="author.html#11876">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:14:13 +0200 (Mon, 15 Sep 2008)
New Revision: 27566
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27566&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27566&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcl.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcldec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lclenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/liba52.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libamr.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libdirac.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libdirac_libschro.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libdirac_libschro.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libdiracdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libdiracenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libfaac.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libfaad.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libgsm.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libmp3lame.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libschroedinger.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libschroedinger.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libschroedingerdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libschroedingerenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libtheoraenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libvorbis.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libx264.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libxvid_internal.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libxvid_rc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/libxvidff.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ljpegenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/loco.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lowpass.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lowpass.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lpc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lpc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lsp.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lsp.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lzw.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lzw.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lzwenc.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcl.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcl.h	2008-09-15 14:13:44 UTC (rev 27565)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcl.h	2008-09-15 14:14:13 UTC (rev 27566)
@@ -0,0 +1,49 @@
+/*
+ * LCL (LossLess Codec Library) Codec
+ * Copyright (c) 2002-2004 Roberto Togni
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_LCL_H
+#define FFMPEG_LCL_H
+
+#define BMPTYPE_YUV 1
+#define BMPTYPE_RGB 2
+
+#define IMGTYPE_YUV111 0
+#define IMGTYPE_YUV422 1
+#define IMGTYPE_RGB24 2
+#define IMGTYPE_YUV411 3
+#define IMGTYPE_YUV211 4
+#define IMGTYPE_YUV420 5
+
+#define COMP_MSZH 0
+#define COMP_MSZH_NOCOMP 1
+#define COMP_ZLIB_HISPEED 1
+#define COMP_ZLIB_HICOMP 9
+#define COMP_ZLIB_NORMAL -1
+
+#define FLAG_MULTITHREAD 1
+#define FLAG_NULLFRAME 2
+#define FLAG_PNGFILTER 4
+#define FLAGMASK_UNUSED 0xf8
+
+#define CODEC_MSZH 1
+#define CODEC_ZLIB 3
+
+#endif /* FFMPEG_LCL_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcldec.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcldec.c	2008-09-15 14:13:44 UTC (rev 27565)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lcldec.c	2008-09-15 14:14:13 UTC (rev 27566)
@@ -0,0 +1,717 @@
+/*
+ * LCL (LossLess Codec Library) Codec
+ * Copyright (c) 2002-2004 Roberto Togni
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file lcl.c
+ * LCL (LossLess Codec Library) Video Codec
+ * Decoder for MSZH and ZLIB codecs
+ * Experimental encoder for ZLIB RGB24
+ *
+ * Fourcc: MSZH, ZLIB
+ *
+ * Original Win32 dll:
+ * Ver2.23 By Kenji Oshima 2000.09.20
+ * avimszh.dll, avizlib.dll
+ *
+ * A description of the decoding algorithm can be found here:
+ *   <A HREF="http://www.pcisys.net/~melanson/codecs">http://www.pcisys.net/~melanson/codecs</A>
+ *
+ * Supports: BGR24 (RGB 24bpp)
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;lcl.h&quot;
+
+#ifdef CONFIG_ZLIB
+#include &lt;zlib.h&gt;
+#endif
+
+/*
+ * Decoder context
+ */
+typedef struct LclDecContext {
+    AVFrame pic;
+
+    // Image type
+    int imgtype;
+    // Compression type
+    int compression;
+    // Flags
+    int flags;
+    // Decompressed data size
+    unsigned int decomp_size;
+    // Decompression buffer
+    unsigned char* decomp_buf;
+#ifdef CONFIG_ZLIB
+    z_stream zstream;
+#endif
+} LclDecContext;
+
+
+/*
+ *
+ * Helper functions
+ *
+ */
+static inline unsigned char fix (int pix14)
+{
+    int tmp;
+
+    tmp = (pix14 + 0x80000) &gt;&gt; 20;
+    if (tmp &lt; 0)
+        return 0;
+    if (tmp &gt; 255)
+        return 255;
+    return tmp;
+}
+
+
+
+static inline unsigned char get_b (unsigned char yq, signed char bq)
+{
+    return fix((yq &lt;&lt; 20) + bq * 1858076);
+}
+
+
+
+static inline unsigned char get_g (unsigned char yq, signed char bq, signed char rq)
+{
+    return fix((yq &lt;&lt; 20) - bq * 360857 - rq * 748830);
+}
+
+
+
+static inline unsigned char get_r (unsigned char yq, signed char rq)
+{
+    return fix((yq &lt;&lt; 20) + rq * 1470103);
+}
+
+
+
+static unsigned int mszh_decomp(unsigned char * srcptr, int srclen, unsigned char * destptr, unsigned int destsize)
+{
+    unsigned char *destptr_bak = destptr;
+    unsigned char *destptr_end = destptr + destsize;
+    unsigned char mask = 0;
+    unsigned char maskbit = 0;
+    unsigned int ofs, cnt;
+
+    while ((srclen &gt; 0) &amp;&amp; (destptr &lt; destptr_end)) {
+        if (maskbit == 0) {
+            mask = *(srcptr++);
+            maskbit = 8;
+            srclen--;
+            continue;
+        }
+        if ((mask &amp; (1 &lt;&lt; (--maskbit))) == 0) {
+            if (destptr + 4 &gt; destptr_end)
+                break;
+            *(int*)destptr = *(int*)srcptr;
+            srclen -= 4;
+            destptr += 4;
+            srcptr += 4;
+        } else {
+            ofs = *(srcptr++);
+            cnt = *(srcptr++);
+            ofs += cnt * 256;
+            cnt = ((cnt &gt;&gt; 3) &amp; 0x1f) + 1;
+            ofs &amp;= 0x7ff;
+            srclen -= 2;
+            cnt *= 4;
+            if (destptr + cnt &gt; destptr_end) {
+                cnt =  destptr_end - destptr;
+            }
+            for (; cnt &gt; 0; cnt--) {
+                *(destptr) = *(destptr - ofs);
+                destptr++;
+            }
+        }
+    }
+
+    return (destptr - destptr_bak);
+}
+
+
+
+/*
+ *
+ * Decode a frame
+ *
+ */
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
+{
+    LclDecContext * const c = avctx-&gt;priv_data;
+    unsigned char *encoded = (unsigned char *)buf;
+    unsigned int pixel_ptr;
+    int row, col;
+    unsigned char *outptr;
+    unsigned int width = avctx-&gt;width; // Real image width
+    unsigned int height = avctx-&gt;height; // Real image height
+    unsigned int mszh_dlen;
+    unsigned char yq, y1q, uq, vq;
+    int uqvq;
+    unsigned int mthread_inlen, mthread_outlen;
+#ifdef CONFIG_ZLIB
+    int zret; // Zlib return code
+#endif
+    unsigned int len = buf_size;
+
+    if(c-&gt;pic.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;c-&gt;pic);
+
+    c-&gt;pic.reference = 0;
+    c-&gt;pic.buffer_hints = FF_BUFFER_HINTS_VALID;
+    if(avctx-&gt;get_buffer(avctx, &amp;c-&gt;pic) &lt; 0){
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return -1;
+    }
+
+    outptr = c-&gt;pic.data[0]; // Output image pointer
+
+    /* Decompress frame */
+    switch (avctx-&gt;codec_id) {
+    case CODEC_ID_MSZH:
+        switch (c-&gt;compression) {
+        case COMP_MSZH:
+            if (c-&gt;flags &amp; FLAG_MULTITHREAD) {
+                mthread_inlen = *((unsigned int*)encoded);
+                mthread_outlen = *((unsigned int*)(encoded+4));
+                if (mthread_outlen &gt; c-&gt;decomp_size) // this should not happen
+                    mthread_outlen = c-&gt;decomp_size;
+                mszh_dlen = mszh_decomp(encoded + 8, mthread_inlen, c-&gt;decomp_buf, c-&gt;decomp_size);
+                if (mthread_outlen != mszh_dlen) {
+                    av_log(avctx, AV_LOG_ERROR, &quot;Mthread1 decoded size differs (%d != %d)\n&quot;,
+                           mthread_outlen, mszh_dlen);
+                    return -1;
+                }
+                mszh_dlen = mszh_decomp(encoded + 8 + mthread_inlen, len - mthread_inlen,
+                                        c-&gt;decomp_buf + mthread_outlen, c-&gt;decomp_size - mthread_outlen);
+                if (mthread_outlen != mszh_dlen) {
+                    av_log(avctx, AV_LOG_ERROR, &quot;Mthread2 decoded size differs (%d != %d)\n&quot;,
+                           mthread_outlen, mszh_dlen);
+                    return -1;
+                }
+                encoded = c-&gt;decomp_buf;
+                len = c-&gt;decomp_size;
+            } else {
+                mszh_dlen = mszh_decomp(encoded, len, c-&gt;decomp_buf, c-&gt;decomp_size);
+                if (c-&gt;decomp_size != mszh_dlen) {
+                    av_log(avctx, AV_LOG_ERROR, &quot;Decoded size differs (%d != %d)\n&quot;,
+                           c-&gt;decomp_size, mszh_dlen);
+                    return -1;
+                }
+                encoded = c-&gt;decomp_buf;
+                len = mszh_dlen;
+            }
+            break;
+        case COMP_MSZH_NOCOMP:
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, &quot;BUG! Unknown MSZH compression in frame decoder.\n&quot;);
+            return -1;
+        }
+        break;
+    case CODEC_ID_ZLIB:
+#ifdef CONFIG_ZLIB
+        /* Using the original dll with normal compression (-1) and RGB format
+         * gives a file with ZLIB fourcc, but frame is really uncompressed.
+         * To be sure that's true check also frame size */
+        if ((c-&gt;compression == COMP_ZLIB_NORMAL) &amp;&amp; (c-&gt;imgtype == IMGTYPE_RGB24) &amp;&amp;
+            (len == width * height * 3))
+            break;
+        zret = inflateReset(&amp;(c-&gt;zstream));
+        if (zret != Z_OK) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Inflate reset error: %d\n&quot;, zret);
+            return -1;
+        }
+        if (c-&gt;flags &amp; FLAG_MULTITHREAD) {
+            mthread_inlen = *((unsigned int*)encoded);
+            mthread_outlen = *((unsigned int*)(encoded+4));
+            if (mthread_outlen &gt; c-&gt;decomp_size)
+                mthread_outlen = c-&gt;decomp_size;
+            c-&gt;zstream.next_in = encoded + 8;
+            c-&gt;zstream.avail_in = mthread_inlen;
+            c-&gt;zstream.next_out = c-&gt;decomp_buf;
+            c-&gt;zstream.avail_out = c-&gt;decomp_size;
+            zret = inflate(&amp;(c-&gt;zstream), Z_FINISH);
+            if ((zret != Z_OK) &amp;&amp; (zret != Z_STREAM_END)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Mthread1 inflate error: %d\n&quot;, zret);
+                return -1;
+            }
+            if (mthread_outlen != (unsigned int)(c-&gt;zstream.total_out)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Mthread1 decoded size differs (%u != %lu)\n&quot;,
+                       mthread_outlen, c-&gt;zstream.total_out);
+                return -1;
+            }
+            zret = inflateReset(&amp;(c-&gt;zstream));
+            if (zret != Z_OK) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Mthread2 inflate reset error: %d\n&quot;, zret);
+                return -1;
+            }
+            c-&gt;zstream.next_in = encoded + 8 + mthread_inlen;
+            c-&gt;zstream.avail_in = len - mthread_inlen;
+            c-&gt;zstream.next_out = c-&gt;decomp_buf + mthread_outlen;
+            c-&gt;zstream.avail_out = c-&gt;decomp_size - mthread_outlen;
+            zret = inflate(&amp;(c-&gt;zstream), Z_FINISH);
+            if ((zret != Z_OK) &amp;&amp; (zret != Z_STREAM_END)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Mthread2 inflate error: %d\n&quot;, zret);
+                return -1;
+            }
+            if (mthread_outlen != (unsigned int)(c-&gt;zstream.total_out)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Mthread2 decoded size differs (%d != %lu)\n&quot;,
+                       mthread_outlen, c-&gt;zstream.total_out);
+                return -1;
+            }
+        } else {
+            c-&gt;zstream.next_in = encoded;
+            c-&gt;zstream.avail_in = len;
+            c-&gt;zstream.next_out = c-&gt;decomp_buf;
+            c-&gt;zstream.avail_out = c-&gt;decomp_size;
+            zret = inflate(&amp;(c-&gt;zstream), Z_FINISH);
+            if ((zret != Z_OK) &amp;&amp; (zret != Z_STREAM_END)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Inflate error: %d\n&quot;, zret);
+                return -1;
+            }
+            if (c-&gt;decomp_size != (unsigned int)(c-&gt;zstream.total_out)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Decoded size differs (%d != %lu)\n&quot;,
+                       c-&gt;decomp_size, c-&gt;zstream.total_out);
+                return -1;
+            }
+        }
+        encoded = c-&gt;decomp_buf;
+        len = c-&gt;decomp_size;
+#else
+        av_log(avctx, AV_LOG_ERROR, &quot;BUG! Zlib support not compiled in frame decoder.\n&quot;);
+        return -1;
+#endif
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, &quot;BUG! Unknown codec in frame decoder compression switch.\n&quot;);
+        return -1;
+    }
+
+
+    /* Apply PNG filter */
+    if ((avctx-&gt;codec_id == CODEC_ID_ZLIB) &amp;&amp; (c-&gt;flags &amp; FLAG_PNGFILTER)) {
+        switch (c-&gt;imgtype) {
+        case IMGTYPE_YUV111:
+        case IMGTYPE_RGB24:
+            for (row = 0; row &lt; height; row++) {
+                pixel_ptr = row * width * 3;
+                yq = encoded[pixel_ptr++];
+                uqvq = AV_RL16(encoded+pixel_ptr);
+                pixel_ptr += 2;
+                for (col = 1; col &lt; width; col++) {
+                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];
+                    uqvq -= AV_RL16(encoded+pixel_ptr+1);
+                    AV_WL16(encoded+pixel_ptr+1, uqvq);
+                    pixel_ptr += 3;
+                }
+            }
+            break;
+        case IMGTYPE_YUV422:
+            for (row = 0; row &lt; height; row++) {
+                pixel_ptr = row * width * 2;
+                yq = uq = vq =0;
+                for (col = 0; col &lt; width/4; col++) {
+                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];
+                    encoded[pixel_ptr+1] = yq -= encoded[pixel_ptr+1];
+                    encoded[pixel_ptr+2] = yq -= encoded[pixel_ptr+2];
+                    encoded[pixel_ptr+3] = yq -= encoded[pixel_ptr+3];
+                    encoded[pixel_ptr+4] = uq -= encoded[pixel_ptr+4];
+                    encoded[pixel_ptr+5] = uq -= encoded[pixel_ptr+5];
+                    encoded[pixel_ptr+6] = vq -= encoded[pixel_ptr+6];
+                    encoded[pixel_ptr+7] = vq -= encoded[pixel_ptr+7];
+                    pixel_ptr += 8;
+                }
+            }
+            break;
+        case IMGTYPE_YUV411:
+            for (row = 0; row &lt; height; row++) {
+                pixel_ptr = row * width / 2 * 3;
+                yq = uq = vq =0;
+                for (col = 0; col &lt; width/4; col++) {
+                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];
+                    encoded[pixel_ptr+1] = yq -= encoded[pixel_ptr+1];
+                    encoded[pixel_ptr+2] = yq -= encoded[pixel_ptr+2];
+                    encoded[pixel_ptr+3] = yq -= encoded[pixel_ptr+3];
+                    encoded[pixel_ptr+4] = uq -= encoded[pixel_ptr+4];
+                    encoded[pixel_ptr+5] = vq -= encoded[pixel_ptr+5];
+                    pixel_ptr += 6;
+                }
+            }
+            break;
+        case IMGTYPE_YUV211:
+            for (row = 0; row &lt; height; row++) {
+                pixel_ptr = row * width * 2;
+                yq = uq = vq =0;
+                for (col = 0; col &lt; width/2; col++) {
+                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];
+                    encoded[pixel_ptr+1] = yq -= encoded[pixel_ptr+1];
+                    encoded[pixel_ptr+2] = uq -= encoded[pixel_ptr+2];
+                    encoded[pixel_ptr+3] = vq -= encoded[pixel_ptr+3];
+                    pixel_ptr += 4;
+                }
+            }
+            break;
+        case IMGTYPE_YUV420:
+            for (row = 0; row &lt; height/2; row++) {
+                pixel_ptr = row * width * 3;
+                yq = y1q = uq = vq =0;
+                for (col = 0; col &lt; width/2; col++) {
+                    encoded[pixel_ptr] = yq -= encoded[pixel_ptr];
+                    encoded[pixel_ptr+1] = yq -= encoded[pixel_ptr+1];
+                    encoded[pixel_ptr+2] = y1q -= encoded[pixel_ptr+2];
+                    encoded[pixel_ptr+3] = y1q -= encoded[pixel_ptr+3];
+                    encoded[pixel_ptr+4] = uq -= encoded[pixel_ptr+4];
+                    encoded[pixel_ptr+5] = vq -= encoded[pixel_ptr+5];
+                    pixel_ptr += 6;
+                }
+            }
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, &quot;BUG! Unknown imagetype in pngfilter switch.\n&quot;);
+            return -1;
+        }
+    }
+
+    /* Convert colorspace */
+    switch (c-&gt;imgtype) {
+    case IMGTYPE_YUV111:
+        for (row = height - 1; row &gt;= 0; row--) {
+            pixel_ptr = row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width; col++) {
+                outptr[pixel_ptr++] = get_b(encoded[0], encoded[1]);
+                outptr[pixel_ptr++] = get_g(encoded[0], encoded[1], encoded[2]);
+                outptr[pixel_ptr++] = get_r(encoded[0], encoded[2]);
+                encoded += 3;
+            }
+        }
+        break;
+    case IMGTYPE_YUV422:
+        for (row = height - 1; row &gt;= 0; row--) {
+            pixel_ptr = row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width/4; col++) {
+                outptr[pixel_ptr++] = get_b(encoded[0], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[0], encoded[4], encoded[6]);
+                outptr[pixel_ptr++] = get_r(encoded[0], encoded[6]);
+                outptr[pixel_ptr++] = get_b(encoded[1], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[1], encoded[4], encoded[6]);
+                outptr[pixel_ptr++] = get_r(encoded[1], encoded[6]);
+                outptr[pixel_ptr++] = get_b(encoded[2], encoded[5]);
+                outptr[pixel_ptr++] = get_g(encoded[2], encoded[5], encoded[7]);
+                outptr[pixel_ptr++] = get_r(encoded[2], encoded[7]);
+                outptr[pixel_ptr++] = get_b(encoded[3], encoded[5]);
+                outptr[pixel_ptr++] = get_g(encoded[3], encoded[5], encoded[7]);
+                outptr[pixel_ptr++] = get_r(encoded[3], encoded[7]);
+                encoded += 8;
+            }
+        }
+        break;
+    case IMGTYPE_RGB24:
+        for (row = height - 1; row &gt;= 0; row--) {
+            pixel_ptr = row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width; col++) {
+                outptr[pixel_ptr++] = encoded[0];
+                outptr[pixel_ptr++] = encoded[1];
+                outptr[pixel_ptr++] = encoded[2];
+                encoded += 3;
+            }
+        }
+        break;
+    case IMGTYPE_YUV411:
+        for (row = height - 1; row &gt;= 0; row--) {
+            pixel_ptr = row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width/4; col++) {
+                outptr[pixel_ptr++] = get_b(encoded[0], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[0], encoded[4], encoded[5]);
+                outptr[pixel_ptr++] = get_r(encoded[0], encoded[5]);
+                outptr[pixel_ptr++] = get_b(encoded[1], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[1], encoded[4], encoded[5]);
+                outptr[pixel_ptr++] = get_r(encoded[1], encoded[5]);
+                outptr[pixel_ptr++] = get_b(encoded[2], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[2], encoded[4], encoded[5]);
+                outptr[pixel_ptr++] = get_r(encoded[2], encoded[5]);
+                outptr[pixel_ptr++] = get_b(encoded[3], encoded[4]);
+                outptr[pixel_ptr++] = get_g(encoded[3], encoded[4], encoded[5]);
+                outptr[pixel_ptr++] = get_r(encoded[3], encoded[5]);
+                encoded += 6;
+            }
+        }
+        break;
+    case IMGTYPE_YUV211:
+        for (row = height - 1; row &gt;= 0; row--) {
+            pixel_ptr = row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width/2; col++) {
+                outptr[pixel_ptr++] = get_b(encoded[0], encoded[2]);
+                outptr[pixel_ptr++] = get_g(encoded[0], encoded[2], encoded[3]);
+                outptr[pixel_ptr++] = get_r(encoded[0], encoded[3]);
+                outptr[pixel_ptr++] = get_b(encoded[1], encoded[2]);
+                outptr[pixel_ptr++] = get_g(encoded[1], encoded[2], encoded[3]);
+                outptr[pixel_ptr++] = get_r(encoded[1], encoded[3]);
+                encoded += 4;
+            }
+        }
+        break;
+    case IMGTYPE_YUV420:
+        for (row = height / 2 - 1; row &gt;= 0; row--) {
+            pixel_ptr = 2 * row * c-&gt;pic.linesize[0];
+            for (col = 0; col &lt; width/2; col++) {
+                outptr[pixel_ptr] = get_b(encoded[0], encoded[4]);
+                outptr[pixel_ptr+1] = get_g(encoded[0], encoded[4], encoded[5]);
+                outptr[pixel_ptr+2] = get_r(encoded[0], encoded[5]);
+                outptr[pixel_ptr+3] = get_b(encoded[1], encoded[4]);
+                outptr[pixel_ptr+4] = get_g(encoded[1], encoded[4], encoded[5]);
+                outptr[pixel_ptr+5] = get_r(encoded[1], encoded[5]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]] = get_b(encoded[2], encoded[4]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]+1] = get_g(encoded[2], encoded[4], encoded[5]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]+2] = get_r(encoded[2], encoded[5]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]+3] = get_b(encoded[3], encoded[4]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]+4] = get_g(encoded[3], encoded[4], encoded[5]);
+                outptr[pixel_ptr-c-&gt;pic.linesize[0]+5] = get_r(encoded[3], encoded[5]);
+                pixel_ptr += 6;
+                encoded += 6;
+            }
+        }
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, &quot;BUG! Unknown imagetype in image decoder.\n&quot;);
+        return -1;
+    }
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = c-&gt;pic;
+
+    /* always report that the buffer was completely consumed */
+    return buf_size;
+}
+
+/*
+ *
+ * Init lcl decoder
+ *
+ */
+static av_cold int decode_init(AVCodecContext *avctx)
+{
+    LclDecContext * const c = avctx-&gt;priv_data;
+    unsigned int basesize = avctx-&gt;width * avctx-&gt;height;
+    unsigned int max_basesize = ((avctx-&gt;width + 3) &amp; ~3) * ((avctx-&gt;height + 3) &amp; ~3);
+    unsigned int max_decomp_size;
+    int zret; // Zlib return code
+
+    c-&gt;pic.data[0] = NULL;
+
+#ifdef CONFIG_ZLIB
+    // Needed if zlib unused or init aborted before inflateInit
+    memset(&amp;(c-&gt;zstream), 0, sizeof(z_stream));
+#endif
+
+    if (avctx-&gt;extradata_size &lt; 8) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Extradata size too small.\n&quot;);
+        return 1;
+    }
+
+    if (avcodec_check_dimensions(avctx, avctx-&gt;width, avctx-&gt;height) &lt; 0) {
+        return 1;
+    }
+
+    /* Check codec type */
+    if (((avctx-&gt;codec_id == CODEC_ID_MSZH)  &amp;&amp; (*((char *)avctx-&gt;extradata + 7) != CODEC_MSZH)) ||
+        ((avctx-&gt;codec_id == CODEC_ID_ZLIB)  &amp;&amp; (*((char *)avctx-&gt;extradata + 7) != CODEC_ZLIB))) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Codec id and codec type mismatch. This should not happen.\n&quot;);
+    }
+
+    /* Detect image type */
+    switch (c-&gt;imgtype = *((char *)avctx-&gt;extradata + 4)) {
+    case IMGTYPE_YUV111:
+        c-&gt;decomp_size = basesize * 3;
+        max_decomp_size = max_basesize * 3;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is YUV 1:1:1.\n&quot;);
+        break;
+    case IMGTYPE_YUV422:
+        c-&gt;decomp_size = basesize * 2;
+        max_decomp_size = max_basesize * 2;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is YUV 4:2:2.\n&quot;);
+        break;
+    case IMGTYPE_RGB24:
+        c-&gt;decomp_size = basesize * 3;
+        max_decomp_size = max_basesize * 3;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is RGB 24.\n&quot;);
+        break;
+    case IMGTYPE_YUV411:
+        c-&gt;decomp_size = basesize / 2 * 3;
+        max_decomp_size = max_basesize / 2 * 3;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is YUV 4:1:1.\n&quot;);
+        break;
+    case IMGTYPE_YUV211:
+        c-&gt;decomp_size = basesize * 2;
+        max_decomp_size = max_basesize * 2;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is YUV 2:1:1.\n&quot;);
+        break;
+    case IMGTYPE_YUV420:
+        c-&gt;decomp_size = basesize / 2 * 3;
+        max_decomp_size = max_basesize / 2 * 3;
+        av_log(avctx, AV_LOG_INFO, &quot;Image type is YUV 4:2:0.\n&quot;);
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, &quot;Unsupported image format %d.\n&quot;, c-&gt;imgtype);
+        return 1;
+    }
+
+    /* Detect compression method */
+    c-&gt;compression = *((char *)avctx-&gt;extradata + 5);
+    switch (avctx-&gt;codec_id) {
+    case CODEC_ID_MSZH:
+        switch (c-&gt;compression) {
+        case COMP_MSZH:
+            av_log(avctx, AV_LOG_INFO, &quot;Compression enabled.\n&quot;);
+            break;
+        case COMP_MSZH_NOCOMP:
+            c-&gt;decomp_size = 0;
+            av_log(avctx, AV_LOG_INFO, &quot;No compression.\n&quot;);
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, &quot;Unsupported compression format for MSZH (%d).\n&quot;, c-&gt;compression);
+            return 1;
+        }
+        break;
+    case CODEC_ID_ZLIB:
+#ifdef CONFIG_ZLIB
+        switch (c-&gt;compression) {
+        case COMP_ZLIB_HISPEED:
+            av_log(avctx, AV_LOG_INFO, &quot;High speed compression.\n&quot;);
+            break;
+        case COMP_ZLIB_HICOMP:
+            av_log(avctx, AV_LOG_INFO, &quot;High compression.\n&quot;);
+            break;
+        case COMP_ZLIB_NORMAL:
+            av_log(avctx, AV_LOG_INFO, &quot;Normal compression.\n&quot;);
+            break;
+        default:
+            if ((c-&gt;compression &lt; Z_NO_COMPRESSION) || (c-&gt;compression &gt; Z_BEST_COMPRESSION)) {
+                av_log(avctx, AV_LOG_ERROR, &quot;Unsupported compression level for ZLIB: (%d).\n&quot;, c-&gt;compression);
+                return 1;
+            }
+            av_log(avctx, AV_LOG_INFO, &quot;Compression level for ZLIB: (%d).\n&quot;, c-&gt;compression);
+        }
+#else
+        av_log(avctx, AV_LOG_ERROR, &quot;Zlib support not compiled.\n&quot;);
+        return 1;
+#endif
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, &quot;BUG! Unknown codec in compression switch.\n&quot;);
+        return 1;
+    }
+
+    /* Allocate decompression buffer */
+    if (c-&gt;decomp_size) {
+        if ((c-&gt;decomp_buf = av_malloc(max_decomp_size)) == NULL) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Can't allocate decompression buffer.\n&quot;);
+            return 1;
+        }
+    }
+
+    /* Detect flags */
+    c-&gt;flags = *((char *)avctx-&gt;extradata + 6);
+    if (c-&gt;flags &amp; FLAG_MULTITHREAD)
+        av_log(avctx, AV_LOG_INFO, &quot;Multithread encoder flag set.\n&quot;);
+    if (c-&gt;flags &amp; FLAG_NULLFRAME)
+        av_log(avctx, AV_LOG_INFO, &quot;Nullframe insertion flag set.\n&quot;);
+    if ((avctx-&gt;codec_id == CODEC_ID_ZLIB) &amp;&amp; (c-&gt;flags &amp; FLAG_PNGFILTER))
+        av_log(avctx, AV_LOG_INFO, &quot;PNG filter flag set.\n&quot;);
+    if (c-&gt;flags &amp; FLAGMASK_UNUSED)
+        av_log(avctx, AV_LOG_ERROR, &quot;Unknown flag set (%d).\n&quot;, c-&gt;flags);
+
+    /* If needed init zlib */
+    if (avctx-&gt;codec_id == CODEC_ID_ZLIB) {
+#ifdef CONFIG_ZLIB
+        c-&gt;zstream.zalloc = Z_NULL;
+        c-&gt;zstream.zfree = Z_NULL;
+        c-&gt;zstream.opaque = Z_NULL;
+        zret = inflateInit(&amp;(c-&gt;zstream));
+        if (zret != Z_OK) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Inflate init error: %d\n&quot;, zret);
+            return 1;
+        }
+#else
+        av_log(avctx, AV_LOG_ERROR, &quot;Zlib support not compiled.\n&quot;);
+        return 1;
+#endif
+    }
+
+    avctx-&gt;pix_fmt = PIX_FMT_BGR24;
+
+    return 0;
+}
+
+/*
+ *
+ * Uninit lcl decoder
+ *
+ */
+static av_cold int decode_end(AVCodecContext *avctx)
+{
+    LclDecContext * const c = avctx-&gt;priv_data;
+
+    if (c-&gt;pic.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;c-&gt;pic);
+#ifdef CONFIG_ZLIB
+    inflateEnd(&amp;(c-&gt;zstream));
+#endif
+
+    return 0;
+}
+
+#ifdef CONFIG_MSZH_DECODER
+AVCodec mszh_decoder = {
+    &quot;mszh&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MSZH,
+    sizeof(LclDecContext),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;LCL (LossLess Codec Library) MSZH&quot;),
+};
+#endif
+
+#ifdef CONFIG_ZLIB_DECODER
+AVCodec zlib_decoder = {
+    &quot;zlib&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_ZLIB,
+    sizeof(LclDecContext),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_frame,
+    CODEC_CAP_DR1,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;LCL (LossLess Codec Library) ZLIB&quot;),
+};
+#endif

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lclenc.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lclenc.c	2008-09-15 14:13:44 UTC (rev 27565)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/lclenc.c	2008-09-15 14:14:13 UTC (rev 27566)
@@ -0,0 +1,232 @@
+/*
+ * LCL (LossLess Codec Library) Codec
+ * Copyright (c) 2002-2004 Roberto Togni
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file lcl.c
+ * LCL (LossLess Codec Library) Video Codec
+ * Decoder for MSZH and ZLIB codecs
+ * Experimental encoder for ZLIB RGB24
+ *
+ * Fourcc: MSZH, ZLIB
+ *
+ * Original Win32 dll:
+ * Ver2.23 By Kenji Oshima 2000.09.20
+ * avimszh.dll, avizlib.dll
+ *
+ * A description of the decoding algorithm can be found here:
+ *   <A HREF="http://www.pcisys.net/~melanson/codecs">http://www.pcisys.net/~melanson/codecs</A>
+ *
+ * Supports: BGR24 (RGB 24bpp)
+ *
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;lcl.h&quot;
+
+#ifdef CONFIG_ZLIB
+#include &lt;zlib.h&gt;
+#endif
+
+/*
+ * Decoder context
+ */
+typedef struct LclEncContext {
+
+        AVCodecContext *avctx;
+        AVFrame pic;
+    PutBitContext pb;
+
+    // Image type
+    int imgtype;
+    // Compression type
+    int compression;
+    // Flags
+    int flags;
+    // Decompressed data size
+    unsigned int decomp_size;
+    // Maximum compressed data size
+    unsigned int max_comp_size;
+    // Compression buffer
+    unsigned char* comp_buf;
+#ifdef CONFIG_ZLIB
+    z_stream zstream;
+#endif
+} LclEncContext;
+
+/*
+ *
+ * Encode a frame
+ *
+ */
+static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){
+    LclEncContext *c = avctx-&gt;priv_data;
+    AVFrame *pict = data;
+    AVFrame * const p = &amp;c-&gt;pic;
+    int i;
+    int zret; // Zlib return code
+
+#ifndef CONFIG_ZLIB
+    av_log(avctx, AV_LOG_ERROR, &quot;Zlib support not compiled in.\n&quot;);
+    return -1;
+#else
+
+    init_put_bits(&amp;c-&gt;pb, buf, buf_size);
+
+    *p = *pict;
+    p-&gt;pict_type= FF_I_TYPE;
+    p-&gt;key_frame= 1;
+
+    if(avctx-&gt;pix_fmt != PIX_FMT_BGR24){
+        av_log(avctx, AV_LOG_ERROR, &quot;Format not supported!\n&quot;);
+        return -1;
+    }
+
+    zret = deflateReset(&amp;(c-&gt;zstream));
+    if (zret != Z_OK) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Deflate reset error: %d\n&quot;, zret);
+        return -1;
+    }
+    c-&gt;zstream.next_out = c-&gt;comp_buf;
+    c-&gt;zstream.avail_out = c-&gt;max_comp_size;
+
+    for(i = avctx-&gt;height - 1; i &gt;= 0; i--) {
+        c-&gt;zstream.next_in = p-&gt;data[0]+p-&gt;linesize[0]*i;
+        c-&gt;zstream.avail_in = avctx-&gt;width*3;
+        zret = deflate(&amp;(c-&gt;zstream), Z_NO_FLUSH);
+        if (zret != Z_OK) {
+            av_log(avctx, AV_LOG_ERROR, &quot;Deflate error: %d\n&quot;, zret);
+            return -1;
+        }
+    }
+    zret = deflate(&amp;(c-&gt;zstream), Z_FINISH);
+    if (zret != Z_STREAM_END) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Deflate error: %d\n&quot;, zret);
+        return -1;
+    }
+
+    for (i = 0; i &lt; c-&gt;zstream.total_out; i++)
+        put_bits(&amp;c-&gt;pb, 8, c-&gt;comp_buf[i]);
+    flush_put_bits(&amp;c-&gt;pb);
+
+    return c-&gt;zstream.total_out;
+#endif
+}
+
+/*
+ *
+ * Init lcl encoder
+ *
+ */
+static av_cold int encode_init(AVCodecContext *avctx)
+{
+    LclEncContext *c = avctx-&gt;priv_data;
+    int zret; // Zlib return code
+
+#ifndef CONFIG_ZLIB
+    av_log(avctx, AV_LOG_ERROR, &quot;Zlib support not compiled.\n&quot;);
+    return 1;
+#else
+
+    c-&gt;avctx= avctx;
+
+    assert(avctx-&gt;width &amp;&amp; avctx-&gt;height);
+
+    avctx-&gt;extradata= av_mallocz(8);
+    avctx-&gt;coded_frame= &amp;c-&gt;pic;
+
+    // Will be user settable someday
+    c-&gt;compression = 6;
+    c-&gt;flags = 0;
+
+    switch(avctx-&gt;pix_fmt){
+        case PIX_FMT_BGR24:
+            c-&gt;imgtype = IMGTYPE_RGB24;
+            c-&gt;decomp_size = avctx-&gt;width * avctx-&gt;height * 3;
+            avctx-&gt;bits_per_sample= 24;
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, &quot;Input pixel format %s not supported\n&quot;, avcodec_get_pix_fmt_name(avctx-&gt;pix_fmt));
+            return -1;
+    }
+
+    ((uint8_t*)avctx-&gt;extradata)[0]= 4;
+    ((uint8_t*)avctx-&gt;extradata)[1]= 0;
+    ((uint8_t*)avctx-&gt;extradata)[2]= 0;
+    ((uint8_t*)avctx-&gt;extradata)[3]= 0;
+    ((uint8_t*)avctx-&gt;extradata)[4]= c-&gt;imgtype;
+    ((uint8_t*)avctx-&gt;extradata)[5]= c-&gt;compression;
+    ((uint8_t*)avctx-&gt;extradata)[6]= c-&gt;flags;
+    ((uint8_t*)avctx-&gt;extradata)[7]= CODEC_ZLIB;
+    c-&gt;avctx-&gt;extradata_size= 8;
+
+    c-&gt;zstream.zalloc = Z_NULL;
+    c-&gt;zstream.zfree = Z_NULL;
+    c-&gt;zstream.opaque = Z_NULL;
+    zret = deflateInit(&amp;(c-&gt;zstream), c-&gt;compression);
+    if (zret != Z_OK) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Deflate init error: %d\n&quot;, zret);
+        return 1;
+    }
+
+        /* Conservative upper bound taken from zlib v1.2.1 source */
+        c-&gt;max_comp_size = c-&gt;decomp_size + ((c-&gt;decomp_size + 7) &gt;&gt; 3) +
+                           ((c-&gt;decomp_size + 63) &gt;&gt; 6) + 11;
+    if ((c-&gt;comp_buf = av_malloc(c-&gt;max_comp_size)) == NULL) {
+        av_log(avctx, AV_LOG_ERROR, &quot;Can't allocate compression buffer.\n&quot;);
+        return 1;
+    }
+
+    return 0;
+#endif
+}
+
+/*
+ *
+ * Uninit lcl encoder
+ *
+ */
+static av_cold int encode_end(AVCodecContext *avctx)
+{
+    LclEncContext *c = avctx-&gt;priv_data;
+
+    av_freep(&amp;avctx-&gt;extradata);
+    av_freep(&amp;c-&gt;comp_buf);
+#ifdef CONFIG_ZLIB
+    deflateEnd(&amp;(c-&gt;zstream));

[... truncated: 7360 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011875.html">[Haiku-commits] r27565 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011879.html">[Haiku-commits] r27566 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11876">[ date ]</a>
              <a href="thread.html#11876">[ thread ]</a>
              <a href="subject.html#11876">[ subject ]</a>
              <a href="author.html#11876">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
