<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27564 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27564%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151413.m8FED7NR001610%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011873.html">
   <LINK REL="Next"  HREF="011875.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27564 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27564%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151413.m8FED7NR001610%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27564 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:13:07 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011873.html">[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011875.html">[Haiku-commits] r27565 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11874">[ date ]</a>
              <a href="thread.html#11874">[ thread ]</a>
              <a href="subject.html#11874">[ subject ]</a>
              <a href="author.html#11874">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:13:04 +0200 (Mon, 15 Sep 2008)
New Revision: 27564
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27564&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27564&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rectangle.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/remove_extradata_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample2.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl2.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rle.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rle.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/roqaudioenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/roqvideo.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/roqvideodec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/roqvideoenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rtjpeg.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rtjpeg.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/roqvideo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rpza.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rectangle.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rectangle.h	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rectangle.h	2008-09-15 14:13:04 UTC (rev 27564)
@@ -0,0 +1,121 @@
+/*
+ * rectangle filling function
+ * Copyright (c) 2003 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rectangle.h
+ * useful rectangle filling function
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ */
+
+#ifndef FFMPEG_RECTANGLE_H
+#define FFMPEG_RECTANGLE_H
+
+#include &quot;common.h&quot;
+
+/**
+ * fill a rectangle.
+ * @param h height of the rectangle, should be a constant
+ * @param w width of the rectangle, should be a constant
+ * @param size the size of val (1 or 4), should be a constant
+ */
+static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
+    uint8_t *p= (uint8_t*)vp;
+    assert(size==1 || size==4);
+    assert(w&lt;=4);
+
+    w      *= size;
+    stride *= size;
+
+    assert((((long)vp)&amp;(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
+    assert((stride&amp;(w-1))==0);
+    if(w==2){
+        const uint16_t v= size==4 ? val : val*0x0101;
+        *(uint16_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint16_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint16_t*)(p + 2*stride)= v;
+        *(uint16_t*)(p + 3*stride)= v;
+    }else if(w==4){
+        const uint32_t v= size==4 ? val : val*0x01010101;
+        *(uint32_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint32_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint32_t*)(p + 2*stride)= v;
+        *(uint32_t*)(p + 3*stride)= v;
+    }else if(w==8){
+    //gcc can't optimize 64bit math on x86_32
+#ifdef HAVE_FAST_64BIT
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint64_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 2*stride)= v;
+        *(uint64_t*)(p + 3*stride)= v;
+    }else if(w==16){
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0+0*stride)= v;
+        *(uint64_t*)(p + 8+0*stride)= v;
+        *(uint64_t*)(p + 0+1*stride)= v;
+        *(uint64_t*)(p + 8+1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 0+2*stride)= v;
+        *(uint64_t*)(p + 8+2*stride)= v;
+        *(uint64_t*)(p + 0+3*stride)= v;
+        *(uint64_t*)(p + 8+3*stride)= v;
+#else
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        if(h==1) return;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+    }else if(w==16){
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        *(uint32_t*)(p + 8+0*stride)= val;
+        *(uint32_t*)(p +12+0*stride)= val;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        *(uint32_t*)(p + 8+1*stride)= val;
+        *(uint32_t*)(p +12+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 8+2*stride)= val;
+        *(uint32_t*)(p +12+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+        *(uint32_t*)(p + 8+3*stride)= val;
+        *(uint32_t*)(p +12+3*stride)= val;
+#endif
+    }else
+        assert(0);
+    assert(h==4);
+}
+
+#endif /* FFMPEG_RECTANGLE_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/remove_extradata_bsf.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/remove_extradata_bsf.c	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/remove_extradata_bsf.c	2008-09-15 14:13:04 UTC (rev 27564)
@@ -0,0 +1,55 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avcodec.h&quot;
+
+
+static int remove_extradata(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,
+                     uint8_t **poutbuf, int *poutbuf_size,
+                     const uint8_t *buf, int buf_size, int keyframe){
+    int cmd= args ? *args : 0;
+    AVCodecParserContext *s;
+
+    if(!bsfc-&gt;parser){
+        bsfc-&gt;parser= av_parser_init(avctx-&gt;codec_id);
+    }
+    s= bsfc-&gt;parser;
+
+    if(s &amp;&amp; s-&gt;parser-&gt;split){
+        if(  (((avctx-&gt;flags &amp; CODEC_FLAG_GLOBAL_HEADER) || (avctx-&gt;flags2 &amp; CODEC_FLAG2_LOCAL_HEADER)) &amp;&amp; cmd=='a')
+           ||(!keyframe &amp;&amp; cmd=='k')
+           ||(cmd=='e' || !cmd)
+          ){
+            int i= s-&gt;parser-&gt;split(avctx, buf, buf_size);
+            buf += i;
+            buf_size -= i;
+        }
+    }
+    *poutbuf= (uint8_t *) buf;
+    *poutbuf_size= buf_size;
+
+    return 0;
+}
+
+AVBitStreamFilter remove_extradata_bsf={
+    &quot;remove_extra&quot;,
+    0,
+    remove_extradata,
+};

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample.c	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample.c	2008-09-15 14:13:04 UTC (rev 27564)
@@ -1,126 +1,42 @@
 /*
- * Sample rate convertion for both audio and video
+ * samplerate conversion for both audio and video
  * Copyright (c) 2000 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file resample.c
- * Sample rate convertion for both audio and video.
+ * samplerate conversion for both audio and video
  */
 
 #include &quot;avcodec.h&quot;
 
-typedef struct {
-    /* fractional resampling */
-    uint32_t incr; /* fractional increment */
-    uint32_t frac;
-    int last_sample;
-    /* integer down sample */
-    int iratio;  /* integer divison ratio */
-    int icount, isum;
-    int inv;
-} ReSampleChannelContext;
+struct AVResampleContext;
 
 struct ReSampleContext {
-    ReSampleChannelContext channel_ctx[2];
+    struct AVResampleContext *resample_context;
+    short *temp[2];
+    int temp_len;
     float ratio;
     /* channel convert */
     int input_channels, output_channels, filter_channels;
 };
 
-
-#define FRAC_BITS 16
-#define FRAC (1 &lt;&lt; FRAC_BITS)
-
-static void init_mono_resample(ReSampleChannelContext *s, float ratio)
-{
-    ratio = 1.0 / ratio;
-    s-&gt;iratio = (int)floorf(ratio);
-    if (s-&gt;iratio == 0)
-        s-&gt;iratio = 1;
-    s-&gt;incr = (int)((ratio / s-&gt;iratio) * FRAC);
-    s-&gt;frac = FRAC;
-    s-&gt;last_sample = 0;
-    s-&gt;icount = s-&gt;iratio;
-    s-&gt;isum = 0;
-    s-&gt;inv = (FRAC / s-&gt;iratio);
-}
-
-/* fractional audio resampling */
-static int fractional_resample(ReSampleChannelContext *s, short *output, short *input, int nb_samples)
-{
-    unsigned int frac, incr;
-    int l0, l1;
-    short *q, *p, *pend;
-
-    l0 = s-&gt;last_sample;
-    incr = s-&gt;incr;
-    frac = s-&gt;frac;
-
-    p = input;
-    pend = input + nb_samples;
-    q = output;
-
-    l1 = *p++;
-    for(;;) {
-        /* interpolate */
-        *q++ = (l0 * (FRAC - frac) + l1 * frac) &gt;&gt; FRAC_BITS;
-        frac = frac + s-&gt;incr;
-        while (frac &gt;= FRAC) {
-            frac -= FRAC;
-            if (p &gt;= pend)
-                goto the_end;
-            l0 = l1;
-            l1 = *p++;
-        }
-    }
- the_end:
-    s-&gt;last_sample = l1;
-    s-&gt;frac = frac;
-    return q - output;
-}
-
-static int integer_downsample(ReSampleChannelContext *s, short *output, short *input, int nb_samples)
-{
-    short *q, *p, *pend;
-    int c, sum;
-
-    p = input;
-    pend = input + nb_samples;
-    q = output;
-
-    c = s-&gt;icount;
-    sum = s-&gt;isum;
-
-    for(;;) {
-        sum += *p++;
-        if (--c == 0) {
-            *q++ = (sum * s-&gt;inv) &gt;&gt; FRAC_BITS;
-            c = s-&gt;iratio;
-            sum = 0;
-        }
-        if (p &gt;= pend)
-            break;
-    }
-    s-&gt;isum = sum;
-    s-&gt;icount = c;
-    return q - output;
-}
-
 /* n1: number of samples */
 static void stereo_to_mono(short *output, short *input, int n1)
 {
@@ -210,77 +126,49 @@
     }
 }
 
-static int mono_resample(ReSampleChannelContext *s, short *output, short *input, int nb_samples)
-{
-    short *buf1;
-    short *buftmp;
-
-    buf1= (short*)av_malloc( nb_samples * sizeof(short) );
-
-    /* first downsample by an integer factor with averaging filter */
-    if (s-&gt;iratio &gt; 1) {
-        buftmp = buf1;
-        nb_samples = integer_downsample(s, buftmp, input, nb_samples);
-    } else {
-        buftmp = input;
-    }
-
-    /* then do a fractional resampling with linear interpolation */
-    if (s-&gt;incr != FRAC) {
-        nb_samples = fractional_resample(s, output, buftmp, nb_samples);
-    } else {
-        memcpy(output, buftmp, nb_samples * sizeof(short));
-    }
-    av_free(buf1);
-    return nb_samples;
-}
-
-ReSampleContext *audio_resample_init(int output_channels, int input_channels, 
+ReSampleContext *audio_resample_init(int output_channels, int input_channels,
                                       int output_rate, int input_rate)
 {
     ReSampleContext *s;
-    int i;
-    
+
     if ( input_channels &gt; 2)
       {
-	av_log(NULL, AV_LOG_ERROR, &quot;Resampling with input channels greater than 2 unsupported.&quot;);
-	return NULL;
+        av_log(NULL, AV_LOG_ERROR, &quot;Resampling with input channels greater than 2 unsupported.\n&quot;);
+        return NULL;
       }
 
     s = av_mallocz(sizeof(ReSampleContext));
     if (!s)
       {
-	av_log(NULL, AV_LOG_ERROR, &quot;Can't allocate memory for resample context.&quot;);
-	return NULL;
+        av_log(NULL, AV_LOG_ERROR, &quot;Can't allocate memory for resample context.\n&quot;);
+        return NULL;
       }
 
     s-&gt;ratio = (float)output_rate / (float)input_rate;
-    
+
     s-&gt;input_channels = input_channels;
     s-&gt;output_channels = output_channels;
-    
+
     s-&gt;filter_channels = s-&gt;input_channels;
     if (s-&gt;output_channels &lt; s-&gt;filter_channels)
         s-&gt;filter_channels = s-&gt;output_channels;
 
 /*
- * ac3 output is the only case where filter_channels could be greater than 2.
+ * AC-3 output is the only case where filter_channels could be greater than 2.
  * input channels can't be greater than 2, so resample the 2 channels and then
  * expand to 6 channels after the resampling.
  */
     if(s-&gt;filter_channels&gt;2)
       s-&gt;filter_channels = 2;
 
-    for(i=0;i&lt;s-&gt;filter_channels;i++) {
-        init_mono_resample(&amp;s-&gt;channel_ctx[i], s-&gt;ratio);
-    }
+#define TAPS 16
+    s-&gt;resample_context= av_resample_init(output_rate, input_rate, TAPS, 10, 0, 0.8);
+
     return s;
 }
 
 /* resample audio. 'nb_samples' is the number of input samples */
 /* XXX: optimize it ! */
-/* XXX: do it with polyphase filters, since the quality here is
-   HORRIBLE. Return the number of samples available in output */
 int audio_resample(ReSampleContext *s, short *output, short *input, int nb_samples)
 {
     int i, nb_samples1;
@@ -289,44 +177,52 @@
     short *buftmp2[2], *buftmp3[2];
     int lenout;
 
-    if (s-&gt;input_channels == s-&gt;output_channels &amp;&amp; s-&gt;ratio == 1.0) {
+    if (s-&gt;input_channels == s-&gt;output_channels &amp;&amp; s-&gt;ratio == 1.0 &amp;&amp; 0) {
         /* nothing to do */
         memcpy(output, input, nb_samples * s-&gt;input_channels * sizeof(short));
         return nb_samples;
     }
 
     /* XXX: move those malloc to resample init code */
-    bufin[0]= (short*) av_malloc( nb_samples * sizeof(short) );
-    bufin[1]= (short*) av_malloc( nb_samples * sizeof(short) );
-    
+    for(i=0; i&lt;s-&gt;filter_channels; i++){
+        bufin[i]= av_malloc( (nb_samples + s-&gt;temp_len) * sizeof(short) );
+        memcpy(bufin[i], s-&gt;temp[i], s-&gt;temp_len * sizeof(short));
+        buftmp2[i] = bufin[i] + s-&gt;temp_len;
+    }
+
     /* make some zoom to avoid round pb */
-    lenout= (int)(nb_samples * s-&gt;ratio) + 16;
-    bufout[0]= (short*) av_malloc( lenout * sizeof(short) );
-    bufout[1]= (short*) av_malloc( lenout * sizeof(short) );
+    lenout= 4*nb_samples * s-&gt;ratio + 16;
+    bufout[0]= av_malloc( lenout * sizeof(short) );
+    bufout[1]= av_malloc( lenout * sizeof(short) );
 
     if (s-&gt;input_channels == 2 &amp;&amp;
         s-&gt;output_channels == 1) {
-        buftmp2[0] = bufin[0];
         buftmp3[0] = output;
         stereo_to_mono(buftmp2[0], input, nb_samples);
     } else if (s-&gt;output_channels &gt;= 2 &amp;&amp; s-&gt;input_channels == 1) {
-        buftmp2[0] = input;
         buftmp3[0] = bufout[0];
+        memcpy(buftmp2[0], input, nb_samples*sizeof(short));
     } else if (s-&gt;output_channels &gt;= 2) {
-        buftmp2[0] = bufin[0];
-        buftmp2[1] = bufin[1];
         buftmp3[0] = bufout[0];
         buftmp3[1] = bufout[1];
         stereo_split(buftmp2[0], buftmp2[1], input, nb_samples);
     } else {
-        buftmp2[0] = input;
         buftmp3[0] = output;
+        memcpy(buftmp2[0], input, nb_samples*sizeof(short));
     }
 
+    nb_samples += s-&gt;temp_len;
+
     /* resample each channel */
     nb_samples1 = 0; /* avoid warning */
     for(i=0;i&lt;s-&gt;filter_channels;i++) {
-        nb_samples1 = mono_resample(&amp;s-&gt;channel_ctx[i], buftmp3[i], buftmp2[i], nb_samples);
+        int consumed;
+        int is_last= i+1 == s-&gt;filter_channels;
+
+        nb_samples1 = av_resample(s-&gt;resample_context, buftmp3[i], bufin[i], &amp;consumed, nb_samples, lenout, is_last);
+        s-&gt;temp_len= nb_samples - consumed;
+        s-&gt;temp[i]= av_realloc(s-&gt;temp[i], s-&gt;temp_len*sizeof(short));
+        memcpy(s-&gt;temp[i], bufin[i] + consumed, s-&gt;temp_len*sizeof(short));
     }
 
     if (s-&gt;output_channels == 2 &amp;&amp; s-&gt;input_channels == 1) {
@@ -337,8 +233,8 @@
         ac3_5p1_mux(output, buftmp3[0], buftmp3[1], nb_samples1);
     }
 
-    av_free(bufin[0]);
-    av_free(bufin[1]);
+    for(i=0; i&lt;s-&gt;filter_channels; i++)
+        av_free(bufin[i]);
 
     av_free(bufout[0]);
     av_free(bufout[1]);
@@ -347,5 +243,8 @@
 
 void audio_resample_close(ReSampleContext *s)
 {
+    av_resample_close(s-&gt;resample_context);
+    av_freep(&amp;s-&gt;temp[0]);
+    av_freep(&amp;s-&gt;temp[1]);
     av_free(s);
 }

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample2.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample2.c	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/resample2.c	2008-09-15 14:13:04 UTC (rev 27564)
@@ -0,0 +1,324 @@
+/*
+ * audio resampling
+ * Copyright (c) 2004 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file resample2.c
+ * audio resampling
+ * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt;
+ */
+
+#include &quot;avcodec.h&quot;
+#include &quot;dsputil.h&quot;
+
+#ifndef CONFIG_RESAMPLE_HP
+#define FILTER_SHIFT 15
+
+#define FELEM int16_t
+#define FELEM2 int32_t
+#define FELEML int64_t
+#define FELEM_MAX INT16_MAX
+#define FELEM_MIN INT16_MIN
+#define WINDOW_TYPE 9
+#elif !defined(CONFIG_RESAMPLE_AUDIOPHILE_KIDDY_MODE)
+#define FILTER_SHIFT 30
+
+#define FELEM int32_t
+#define FELEM2 int64_t
+#define FELEML int64_t
+#define FELEM_MAX INT32_MAX
+#define FELEM_MIN INT32_MIN
+#define WINDOW_TYPE 12
+#else
+#define FILTER_SHIFT 0
+
+#define FELEM double
+#define FELEM2 double
+#define FELEML double
+#define WINDOW_TYPE 24
+#endif
+
+
+typedef struct AVResampleContext{
+    FELEM *filter_bank;
+    int filter_length;
+    int ideal_dst_incr;
+    int dst_incr;
+    int index;
+    int frac;
+    int src_incr;
+    int compensation_distance;
+    int phase_shift;
+    int phase_mask;
+    int linear;
+}AVResampleContext;
+
+/**
+ * 0th order modified bessel function of the first kind.
+ */
+static double bessel(double x){
+    double v=1;
+    double t=1;
+    int i;
+
+    x= x*x/4;
+    for(i=1; i&lt;50; i++){
+        t *= x/(i*i);
+        v += t;
+    }
+    return v;
+}
+
+/**
+ * builds a polyphase filterbank.
+ * @param factor resampling factor
+ * @param scale wanted sum of coefficients for each filter
+ * @param type 0-&gt;cubic, 1-&gt;blackman nuttall windowed sinc, 2..16-&gt;kaiser windowed sinc beta=2..16
+ */
+void av_build_filter(FELEM *filter, double factor, int tap_count, int phase_count, int scale, int type){
+    int ph, i;
+    double x, y, w, tab[tap_count];
+    const int center= (tap_count-1)/2;
+
+    /* if upsampling, only need to interpolate, no filter */
+    if (factor &gt; 1.0)
+        factor = 1.0;
+
+    for(ph=0;ph&lt;phase_count;ph++) {
+        double norm = 0;
+        for(i=0;i&lt;tap_count;i++) {
+            x = M_PI * ((double)(i - center) - (double)ph / phase_count) * factor;
+            if (x == 0) y = 1.0;
+            else        y = sin(x) / x;
+            switch(type){
+            case 0:{
+                const float d= -0.5; //first order derivative = -0.5
+                x = fabs(((double)(i - center) - (double)ph / phase_count) * factor);
+                if(x&lt;1.0) y= 1 - 3*x*x + 2*x*x*x + d*(            -x*x + x*x*x);
+                else      y=                       d*(-4 + 8*x - 5*x*x + x*x*x);
+                break;}
+            case 1:
+                w = 2.0*x / (factor*tap_count) + M_PI;
+                y *= 0.3635819 - 0.4891775 * cos(w) + 0.1365995 * cos(2*w) - 0.0106411 * cos(3*w);
+                break;
+            default:
+                w = 2.0*x / (factor*tap_count*M_PI);
+                y *= bessel(type*sqrt(FFMAX(1-w*w, 0)));
+                break;
+            }
+
+            tab[i] = y;
+            norm += y;
+        }
+
+        /* normalize so that an uniform color remains the same */
+        for(i=0;i&lt;tap_count;i++) {
+#ifdef CONFIG_RESAMPLE_AUDIOPHILE_KIDDY_MODE
+            filter[ph * tap_count + i] = tab[i] / norm;
+#else
+            filter[ph * tap_count + i] = av_clip(lrintf(tab[i] * scale / norm), FELEM_MIN, FELEM_MAX);
+#endif
+        }
+    }
+#if 0
+    {
+#define LEN 1024
+        int j,k;
+        double sine[LEN + tap_count];
+        double filtered[LEN];
+        double maxff=-2, minff=2, maxsf=-2, minsf=2;
+        for(i=0; i&lt;LEN; i++){
+            double ss=0, sf=0, ff=0;
+            for(j=0; j&lt;LEN+tap_count; j++)
+                sine[j]= cos(i*j*M_PI/LEN);
+            for(j=0; j&lt;LEN; j++){
+                double sum=0;
+                ph=0;
+                for(k=0; k&lt;tap_count; k++)
+                    sum += filter[ph * tap_count + k] * sine[k+j];
+                filtered[j]= sum / (1&lt;&lt;FILTER_SHIFT);
+                ss+= sine[j + center] * sine[j + center];
+                ff+= filtered[j] * filtered[j];
+                sf+= sine[j + center] * filtered[j];
+            }
+            ss= sqrt(2*ss/LEN);
+            ff= sqrt(2*ff/LEN);
+            sf= 2*sf/LEN;
+            maxff= FFMAX(maxff, ff);
+            minff= FFMIN(minff, ff);
+            maxsf= FFMAX(maxsf, sf);
+            minsf= FFMIN(minsf, sf);
+            if(i%11==0){
+                av_log(NULL, AV_LOG_ERROR, &quot;i:%4d ss:%f ff:%13.6e-%13.6e sf:%13.6e-%13.6e\n&quot;, i, ss, maxff, minff, maxsf, minsf);
+                minff=minsf= 2;
+                maxff=maxsf= -2;
+            }
+        }
+    }
+#endif
+}
+
+/**
+ * Initializes an audio resampler.
+ * Note, if either rate is not an integer then simply scale both rates up so they are.
+ */
+AVResampleContext *av_resample_init(int out_rate, int in_rate, int filter_size, int phase_shift, int linear, double cutoff){
+    AVResampleContext *c= av_mallocz(sizeof(AVResampleContext));
+    double factor= FFMIN(out_rate * cutoff / in_rate, 1.0);
+    int phase_count= 1&lt;&lt;phase_shift;
+
+    c-&gt;phase_shift= phase_shift;
+    c-&gt;phase_mask= phase_count-1;
+    c-&gt;linear= linear;
+
+    c-&gt;filter_length= FFMAX((int)ceil(filter_size/factor), 1);
+    c-&gt;filter_bank= av_mallocz(c-&gt;filter_length*(phase_count+1)*sizeof(FELEM));
+    av_build_filter(c-&gt;filter_bank, factor, c-&gt;filter_length, phase_count, 1&lt;&lt;FILTER_SHIFT, WINDOW_TYPE);
+    memcpy(&amp;c-&gt;filter_bank[c-&gt;filter_length*phase_count+1], c-&gt;filter_bank, (c-&gt;filter_length-1)*sizeof(FELEM));
+    c-&gt;filter_bank[c-&gt;filter_length*phase_count]= c-&gt;filter_bank[c-&gt;filter_length - 1];
+
+    c-&gt;src_incr= out_rate;
+    c-&gt;ideal_dst_incr= c-&gt;dst_incr= in_rate * phase_count;
+    c-&gt;index= -phase_count*((c-&gt;filter_length-1)/2);
+
+    return c;
+}
+
+void av_resample_close(AVResampleContext *c){
+    av_freep(&amp;c-&gt;filter_bank);
+    av_freep(&amp;c);
+}
+
+/**
+ * Compensates samplerate/timestamp drift. The compensation is done by changing
+ * the resampler parameters, so no audible clicks or similar distortions occur
+ * @param compensation_distance distance in output samples over which the compensation should be performed
+ * @param sample_delta number of output samples which should be output less
+ *
+ * example: av_resample_compensate(c, 10, 500)
+ * here instead of 510 samples only 500 samples would be output
+ *
+ * note, due to rounding the actual compensation might be slightly different,
+ * especially if the compensation_distance is large and the in_rate used during init is small
+ */
+void av_resample_compensate(AVResampleContext *c, int sample_delta, int compensation_distance){
+//    sample_delta += (c-&gt;ideal_dst_incr - c-&gt;dst_incr)*(int64_t)c-&gt;compensation_distance / c-&gt;ideal_dst_incr;
+    c-&gt;compensation_distance= compensation_distance;
+    c-&gt;dst_incr = c-&gt;ideal_dst_incr - c-&gt;ideal_dst_incr * (int64_t)sample_delta / compensation_distance;
+}
+
+/**
+ * resamples.
+ * @param src an array of unconsumed samples
+ * @param consumed the number of samples of src which have been consumed are returned here
+ * @param src_size the number of unconsumed samples available
+ * @param dst_size the amount of space in samples available in dst
+ * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.
+ * @return the number of samples written in dst or -1 if an error occurred
+ */
+int av_resample(AVResampleContext *c, short *dst, short *src, int *consumed, int src_size, int dst_size, int update_ctx){
+    int dst_index, i;
+    int index= c-&gt;index;
+    int frac= c-&gt;frac;
+    int dst_incr_frac= c-&gt;dst_incr % c-&gt;src_incr;
+    int dst_incr=      c-&gt;dst_incr / c-&gt;src_incr;
+    int compensation_distance= c-&gt;compensation_distance;
+
+  if(compensation_distance == 0 &amp;&amp; c-&gt;filter_length == 1 &amp;&amp; c-&gt;phase_shift==0){
+        int64_t index2= ((int64_t)index)&lt;&lt;32;
+        int64_t incr= (1LL&lt;&lt;32) * c-&gt;dst_incr / c-&gt;src_incr;
+        dst_size= FFMIN(dst_size, (src_size-1-index) * (int64_t)c-&gt;src_incr / c-&gt;dst_incr);
+
+        for(dst_index=0; dst_index &lt; dst_size; dst_index++){
+            dst[dst_index] = src[index2&gt;&gt;32];
+            index2 += incr;
+        }
+        frac += dst_index * dst_incr_frac;
+        index += dst_index * dst_incr;
+        index += frac / c-&gt;src_incr;
+        frac %= c-&gt;src_incr;
+  }else{
+    for(dst_index=0; dst_index &lt; dst_size; dst_index++){
+        FELEM *filter= c-&gt;filter_bank + c-&gt;filter_length*(index &amp; c-&gt;phase_mask);
+        int sample_index= index &gt;&gt; c-&gt;phase_shift;
+        FELEM2 val=0;
+
+        if(sample_index &lt; 0){
+            for(i=0; i&lt;c-&gt;filter_length; i++)
+                val += src[FFABS(sample_index + i) % src_size] * filter[i];
+        }else if(sample_index + c-&gt;filter_length &gt; src_size){
+            break;
+        }else if(c-&gt;linear){
+            FELEM2 v2=0;
+            for(i=0; i&lt;c-&gt;filter_length; i++){
+                val += src[sample_index + i] * (FELEM2)filter[i];
+                v2  += src[sample_index + i] * (FELEM2)filter[i + c-&gt;filter_length];
+            }
+            val+=(v2-val)*(FELEML)frac / c-&gt;src_incr;
+        }else{
+            for(i=0; i&lt;c-&gt;filter_length; i++){
+                val += src[sample_index + i] * (FELEM2)filter[i];
+            }
+        }
+
+#ifdef CONFIG_RESAMPLE_AUDIOPHILE_KIDDY_MODE
+        dst[dst_index] = av_clip_int16(lrintf(val));
+#else
+        val = (val + (1&lt;&lt;(FILTER_SHIFT-1)))&gt;&gt;FILTER_SHIFT;
+        dst[dst_index] = (unsigned)(val + 32768) &gt; 65535 ? (val&gt;&gt;31) ^ 32767 : val;
+#endif
+
+        frac += dst_incr_frac;
+        index += dst_incr;
+        if(frac &gt;= c-&gt;src_incr){
+            frac -= c-&gt;src_incr;
+            index++;
+        }
+
+        if(dst_index + 1 == compensation_distance){
+            compensation_distance= 0;
+            dst_incr_frac= c-&gt;ideal_dst_incr % c-&gt;src_incr;
+            dst_incr=      c-&gt;ideal_dst_incr / c-&gt;src_incr;
+        }
+    }
+  }
+    *consumed= FFMAX(index, 0) &gt;&gt; c-&gt;phase_shift;
+    if(index&gt;=0) index &amp;= c-&gt;phase_mask;
+
+    if(compensation_distance){
+        compensation_distance -= dst_index;
+        assert(compensation_distance &gt; 0);
+    }
+    if(update_ctx){
+        c-&gt;frac= frac;
+        c-&gt;index= index;
+        c-&gt;dst_incr= dst_incr_frac + c-&gt;src_incr*dst_incr;
+        c-&gt;compensation_distance= compensation_distance;
+    }
+#if 0
+    if(update_ctx &amp;&amp; !c-&gt;compensation_distance){
+#undef rand
+        av_resample_compensate(c, rand() % (8000*2) - 8000, 8000*2);
+av_log(NULL, AV_LOG_DEBUG, &quot;%d %d %d\n&quot;, c-&gt;dst_incr, c-&gt;ideal_dst_incr, c-&gt;compensation_distance);
+    }
+#endif
+
+    return dst_index;
+}

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl.h	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl.h	2008-09-15 14:13:04 UTC (rev 27564)
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2000-2002 Fabrice Bellard
+ * Copyright (c) 2002-2004 Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rl.h
+ * rl header.
+ */
+
+#ifndef FFMPEG_RL_H
+#define FFMPEG_RL_H
+
+#include &lt;stdint.h&gt;
+#include &quot;bitstream.h&quot;
+
+/* run length table */
+#define MAX_RUN    64
+#define MAX_LEVEL  64
+
+/** RLTable. */
+typedef struct RLTable {
+    int n;                         ///&lt; number of entries of table_vlc minus 1
+    int last;                      ///&lt; number of values for last = 0
+    const uint16_t (*table_vlc)[2];
+    const int8_t *table_run;
+    const int8_t *table_level;
+    uint8_t *index_run[2];         ///&lt; encoding only
+    int8_t *max_level[2];          ///&lt; encoding &amp; decoding
+    int8_t *max_run[2];            ///&lt; encoding &amp; decoding
+    VLC vlc;                       ///&lt; decoding only deprecated FIXME remove
+    RL_VLC_ELEM *rl_vlc[32];       ///&lt; decoding only
+} RLTable;
+
+/**
+ *
+ * @param static_store static uint8_t array[2][2*MAX_RUN + MAX_LEVEL + 3] which will hold
+ *                     the level and run tables, if this is NULL av_malloc() will be used
+ */
+void init_rl(RLTable *rl, uint8_t static_store[2][2*MAX_RUN + MAX_LEVEL + 3]);
+void init_vlc_rl(RLTable *rl);
+
+#define INIT_VLC_RL(rl, static_size)\
+{\
+    int q;\
+    static RL_VLC_ELEM rl_vlc_table[32][static_size];\
+    INIT_VLC_STATIC(&amp;rl.vlc, 9, rl.n + 1,\
+             &amp;rl.table_vlc[0][1], 4, 2,\
+             &amp;rl.table_vlc[0][0], 4, 2, static_size);\
+\
+    if(!rl.rl_vlc[0]){\
+        for(q=0; q&lt;32; q++)\
+            rl.rl_vlc[q]= rl_vlc_table[q];\
+\
+        init_vlc_rl(&amp;rl);\
+    }\
+}
+
+static inline int get_rl_index(const RLTable *rl, int last, int run, int level)
+{
+    int index;
+    index = rl-&gt;index_run[last][run];
+    if (index &gt;= rl-&gt;n)
+        return rl-&gt;n;
+    if (level &gt; rl-&gt;max_level[last][run])
+        return rl-&gt;n;
+    return index + level - 1;
+}
+
+#endif /* FFMPEG_RL_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl2.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl2.c	2008-09-15 14:12:50 UTC (rev 27563)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/rl2.c	2008-09-15 14:13:04 UTC (rev 27564)
@@ -0,0 +1,241 @@
+/*
+ * RL2 Video Decoder
+ * Copyright (C) 2008 Sascha Sommer (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">saschasommer at freenet.de</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * RL2 Video Decoder
+ * @file rl2.c
+ * @author Sascha Sommer (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">saschasommer at freenet.de</A>)
+ * For more information about the RL2 format, visit:
+ *   <A HREF="http://wiki.multimedia.cx/index.php?title=RL2">http://wiki.multimedia.cx/index.php?title=RL2</A>
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &quot;avcodec.h&quot;
+
+
+#define EXTRADATA1_SIZE (6 + 256 * 3) ///&lt; video base, clr count, palette
+
+typedef struct Rl2Context {
+    AVCodecContext *avctx;
+    AVFrame frame;
+
+    unsigned short video_base; ///&lt; initial drawing offset
+    unsigned int clr_count;    ///&lt; number of used colors (currently unused)
+    unsigned char* back_frame; ///&lt; background frame
+    unsigned int palette[AVPALETTE_COUNT];
+} Rl2Context;
+
+/**
+ * Run Length Decode a single 320x200 frame
+ * @param s rl2 context
+ * @param buf input buffer
+ * @param size input buffer size
+ * @param out ouput buffer
+ * @param stride stride of the output buffer
+ * @param video_base offset of the rle data inside the frame
+ */
+static void rl2_rle_decode(Rl2Context *s,const unsigned char* in,int size,
+                               unsigned char* out,int stride,int video_base){
+    int base_x = video_base % s-&gt;avctx-&gt;width;
+    int base_y = video_base / s-&gt;avctx-&gt;width;
+    int stride_adj = stride - s-&gt;avctx-&gt;width;
+    int i;

[... truncated: 2900 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011873.html">[Haiku-commits] r27563 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011875.html">[Haiku-commits] r27565 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11874">[ date ]</a>
              <a href="thread.html#11874">[ thread ]</a>
              <a href="subject.html#11874">[ subject ]</a>
              <a href="author.html#11874">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
