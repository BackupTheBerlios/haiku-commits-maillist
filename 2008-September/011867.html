<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27557%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151409.m8FE9oTE001020%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011866.html">
   <LINK REL="Next"  HREF="011868.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27557%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151409.m8FE9oTE001020%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:09:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011866.html">[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011868.html">[Haiku-commits] r27558 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11867">[ date ]</a>
              <a href="thread.html#11867">[ thread ]</a>
              <a href="subject.html#11867">[ subject ]</a>
              <a href="author.html#11867">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:09:46 +0200 (Mon, 15 Sep 2008)
New Revision: 27557
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27557&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27557&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mathops.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mimic.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpeg.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpeg_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpega_dump_header_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpegbdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpegdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpegdec.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpegenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpegenc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mlp.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mlp.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mlp_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mlp_parser.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mlpdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mmvideo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/motion-test.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/motionpixels.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/movsub_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mp3_header_compress_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mp3_header_decompress_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msmpeg4.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msmpeg4data.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mace.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdct.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mjpeg.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/motion_est.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/motion_est_template.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msmpeg4.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msmpeg4data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msrle.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/msvideo1.c
Log:
Update avcodec to 20080825

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mace.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mace.c	2008-09-15 14:09:14 UTC (rev 27556)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mace.c	2008-09-15 14:09:46 UTC (rev 27557)
@@ -2,26 +2,28 @@
  * MACE decoder
  * Copyright (c) 2002 Laszlo Torok &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">torokl at alpha.dfmk.hu</A>&gt;
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 /**
  * @file mace.c
  * MACE decoder.
  */
- 
+
 #include &quot;avcodec.h&quot;
 
 /*
@@ -242,7 +244,8 @@
 static void chomp3(MACEContext *ctx,
             uint8_t val,
             const uint16_t tab1[],
-            const uint16_t tab2[][8])
+            const uint16_t tab2[][8],
+            uint32_t numChannels)
 {
   short current;
 
@@ -252,14 +255,15 @@
   else current+=ctx-&gt;lev;
   ctx-&gt;lev=current-(current &gt;&gt; 3);
 //  *ctx-&gt;outPtr++=current &gt;&gt; 8;
-  *ctx-&gt;outPtr++=current;
+  *ctx-&gt;outPtr=current;
+  ctx-&gt;outPtr+=numChannels;
   if ( ( ctx-&gt;index += tab1[val]-(ctx-&gt;index&gt;&gt;5) ) &lt; 0 ) ctx-&gt;index = 0;
 }
 /* \\\ */
 
 /* /// &quot;Exp1to3()&quot; */
 static void Exp1to3(MACEContext *ctx,
-             uint8_t *inBuffer,
+             const uint8_t *inBuffer,
              void *outBuffer,
              uint32_t cnt,
              uint32_t numChannels,
@@ -281,13 +285,13 @@
 
    while (cnt&gt;0) {
      pkt=inBuffer[0];
-     chomp3(ctx, pkt       &amp; 7, MACEtab1, MACEtab2);
-     chomp3(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4);
-     chomp3(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2);
+     chomp3(ctx, pkt       &amp; 7, MACEtab1, MACEtab2, numChannels);
+     chomp3(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4, numChannels);
+     chomp3(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2, numChannels);
      pkt=inBuffer[1];
-     chomp3(ctx, pkt       &amp; 7, MACEtab1, MACEtab2);
-     chomp3(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4);
-     chomp3(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2);
+     chomp3(ctx, pkt       &amp; 7, MACEtab1, MACEtab2, numChannels);
+     chomp3(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4, numChannels);
+     chomp3(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2, numChannels);
 
      inBuffer+=numChannels*2;
      --cnt;
@@ -306,7 +310,8 @@
 static void chomp6(MACEContext *ctx,
             uint8_t val,
             const uint16_t tab1[],
-            const uint16_t tab2[][8])
+            const uint16_t tab2[][8],
+            uint32_t numChannels)
 {
   short current;
 
@@ -329,9 +334,10 @@
 
 //  *ctx-&gt;outPtr++=(ctx-&gt;previous+ctx-&gt;prev2-((ctx-&gt;prev2-current) &gt;&gt; 2)) &gt;&gt; 8;
 //  *ctx-&gt;outPtr++=(ctx-&gt;previous+current+((ctx-&gt;prev2-current) &gt;&gt; 2)) &gt;&gt; 8;
-  *ctx-&gt;outPtr++=(ctx-&gt;previous+ctx-&gt;prev2-((ctx-&gt;prev2-current) &gt;&gt; 2));
-  *ctx-&gt;outPtr++=(ctx-&gt;previous+current+((ctx-&gt;prev2-current) &gt;&gt; 2));
-
+  *ctx-&gt;outPtr=(ctx-&gt;previous+ctx-&gt;prev2-((ctx-&gt;prev2-current) &gt;&gt; 2));
+  ctx-&gt;outPtr+=numChannels;
+  *ctx-&gt;outPtr=(ctx-&gt;previous+current+((ctx-&gt;prev2-current) &gt;&gt; 2));
+  ctx-&gt;outPtr+=numChannels;
   ctx-&gt;prev2=ctx-&gt;previous;
   ctx-&gt;previous=current;
 
@@ -341,7 +347,7 @@
 
 /* /// &quot;Exp1to6()&quot; */
 static void Exp1to6(MACEContext *ctx,
-             uint8_t *inBuffer,
+             const uint8_t *inBuffer,
              void *outBuffer,
              uint32_t cnt,
              uint32_t numChannels,
@@ -366,9 +372,9 @@
    while (cnt&gt;0) {
      pkt=*inBuffer;
 
-     chomp6(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2);
-     chomp6(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4);
-     chomp6(ctx, pkt       &amp; 7, MACEtab1, MACEtab2);
+     chomp6(ctx, pkt &gt;&gt; 5     , MACEtab1, MACEtab2, numChannels);
+     chomp6(ctx,(pkt &gt;&gt; 3) &amp; 3, MACEtab3, MACEtab4, numChannels);
+     chomp6(ctx, pkt       &amp; 7, MACEtab1, MACEtab2, numChannels);
 
      inBuffer+=numChannels;
      --cnt;
@@ -386,16 +392,17 @@
 }
 /* \\\ */
 
-static int mace_decode_init(AVCodecContext * avctx)
+static av_cold int mace_decode_init(AVCodecContext * avctx)
 {
     if (avctx-&gt;channels &gt; 2)
         return -1;
+    avctx-&gt;sample_fmt = SAMPLE_FMT_S16;
     return 0;
 }
 
 static int mace_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
-                            uint8_t *buf, int buf_size)
+                            const uint8_t *buf, int buf_size)
 {
     short *samples;
     MACEContext *c = avctx-&gt;priv_data;
@@ -403,25 +410,20 @@
     samples = (short *)data;
     switch (avctx-&gt;codec-&gt;id) {
     case CODEC_ID_MACE3:
-#ifdef DEBUG
-puts(&quot;mace_decode_frame[3]()&quot;);
-#endif
-        Exp1to3(c, buf, samples, buf_size / 2, avctx-&gt;channels, 1);
+        dprintf(avctx, &quot;mace_decode_frame[3]()&quot;);
+        Exp1to3(c, buf, samples, buf_size / 2 / avctx-&gt;channels, avctx-&gt;channels, 1);
         if (avctx-&gt;channels == 2)
-            Exp1to3(c, buf, samples+1, buf_size / 2, 2, 2);
+            Exp1to3(c, buf, samples+1, buf_size / 2 / 2, 2, 2);
         *data_size = 2 * 3 * buf_size;
         break;
     case CODEC_ID_MACE6:
-#ifdef DEBUG
-puts(&quot;mace_decode_frame[6]()&quot;);
-#endif
-        Exp1to6(c, buf, samples, buf_size, avctx-&gt;channels, 1);
+        dprintf(avctx, &quot;mace_decode_frame[6]()&quot;);
+        Exp1to6(c, buf, samples, buf_size / avctx-&gt;channels, avctx-&gt;channels, 1);
         if (avctx-&gt;channels == 2)
-            Exp1to6(c, buf, samples+1, buf_size, 2, 2);
+            Exp1to6(c, buf, samples+1, buf_size / 2, 2, 2);
         *data_size = 2 * 6 * buf_size;
         break;
     default:
-        *data_size = 0;
         return -1;
     }
     return buf_size;
@@ -436,6 +438,7 @@
     NULL,
     NULL,
     mace_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;MACE (Macintosh Audio Compression/Expansion) 3:1&quot;),
 };
 
 AVCodec mace6_decoder = {
@@ -447,5 +450,6 @@
     NULL,
     NULL,
     mace_decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;MACE (Macintosh Audio Compression/Expansion) 6:1&quot;),
 };
 

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mathops.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mathops.h	2008-09-15 14:09:14 UTC (rev 27556)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mathops.h	2008-09-15 14:09:46 UTC (rev 27557)
@@ -0,0 +1,87 @@
+/*
+ * simple math operations
+ * Copyright (c) 2001, 2002 Fabrice Bellard.
+ * Copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michaelni at gmx.at</A>&gt; et al
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef FFMPEG_MATHOPS_H
+#define FFMPEG_MATHOPS_H
+
+#include &quot;common.h&quot;
+
+#ifdef ARCH_X86_32
+
+#include &quot;i386/mathops.h&quot;
+
+#elif defined(ARCH_ARMV4L)
+
+#include &quot;armv4l/mathops.h&quot;
+
+#elif defined(ARCH_POWERPC)
+
+#include &quot;ppc/mathops.h&quot;
+
+#elif defined(ARCH_BFIN)
+
+#include &quot;bfin/mathops.h&quot;
+
+#endif
+
+/* generic implementation */
+
+#ifndef MULL
+#   define MULL(a,b) (((int64_t)(a) * (int64_t)(b)) &gt;&gt; FRAC_BITS)
+#endif
+
+#ifndef MULH
+//gcc 3.4 creates an incredibly bloated mess out of this
+//#    define MULH(a,b) (((int64_t)(a) * (int64_t)(b))&gt;&gt;32)
+
+static av_always_inline int MULH(int a, int b){
+    return ((int64_t)(a) * (int64_t)(b))&gt;&gt;32;
+}
+#endif
+
+#ifndef MUL64
+#   define MUL64(a,b) ((int64_t)(a) * (int64_t)(b))
+#endif
+
+#ifndef MAC64
+#   define MAC64(d, a, b) ((d) += MUL64(a, b))
+#endif
+
+#ifndef MLS64
+#   define MLS64(d, a, b) ((d) -= MUL64(a, b))
+#endif
+
+/* signed 16x16 -&gt; 32 multiply add accumulate */
+#ifndef MAC16
+#   define MAC16(rt, ra, rb) rt += (ra) * (rb)
+#endif
+
+/* signed 16x16 -&gt; 32 multiply */
+#ifndef MUL16
+#   define MUL16(ra, rb) ((ra) * (rb))
+#endif
+
+#ifndef MLS16
+#   define MLS16(rt, ra, rb) ((rt) -= (ra) * (rb))
+#endif
+
+#endif /* FFMPEG_MATHOPS_H */
+

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdct.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdct.c	2008-09-15 14:09:14 UTC (rev 27556)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdct.c	2008-09-15 14:09:46 UTC (rev 27557)
@@ -2,19 +2,21 @@
  * MDCT/IMDCT transforms
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;dsputil.h&quot;
 
@@ -23,13 +25,52 @@
  * MDCT/IMDCT transforms.
  */
 
+// Generate a Kaiser-Bessel Derived Window.
+#define BESSEL_I0_ITER 50 // default: 50 iterations of Bessel I0 approximation
+void ff_kbd_window_init(float *window, float alpha, int n)
+{
+   int i, j;
+   double sum = 0.0, bessel, tmp;
+   double local_window[n];
+   double alpha2 = (alpha * M_PI / n) * (alpha * M_PI / n);
+
+   for (i = 0; i &lt; n; i++) {
+       tmp = i * (n - i) * alpha2;
+       bessel = 1.0;
+       for (j = BESSEL_I0_ITER; j &gt; 0; j--)
+           bessel = bessel * tmp / (j * j) + 1;
+       sum += bessel;
+       local_window[i] = sum;
+   }
+
+   sum++;
+   for (i = 0; i &lt; n; i++)
+       window[i] = sqrt(local_window[i] / sum);
+}
+
+DECLARE_ALIGNED(16, float, ff_sine_128 [ 128]);
+DECLARE_ALIGNED(16, float, ff_sine_256 [ 256]);
+DECLARE_ALIGNED(16, float, ff_sine_512 [ 512]);
+DECLARE_ALIGNED(16, float, ff_sine_1024[1024]);
+DECLARE_ALIGNED(16, float, ff_sine_2048[2048]);
+float *ff_sine_windows[5] = {
+    ff_sine_128, ff_sine_256, ff_sine_512, ff_sine_1024, ff_sine_2048,
+};
+
+// Generate a sine window.
+void ff_sine_window_init(float *window, int n) {
+    int i;
+    for(i = 0; i &lt; n; i++)
+        window[i] = sin((i + 0.5) / (2 * n) * M_PI);
+}
+
 /**
  * init MDCT or IMDCT computation.
  */
 int ff_mdct_init(MDCTContext *s, int nbits, int inverse)
 {
     int n, n4, i;
-    float alpha;
+    double alpha;
 
     memset(s, 0, sizeof(*s));
     n = 1 &lt;&lt; nbits;
@@ -48,7 +89,7 @@
         s-&gt;tcos[i] = -cos(alpha);
         s-&gt;tsin[i] = -sin(alpha);
     }
-    if (fft_init(&amp;s-&gt;fft, s-&gt;nbits - 2, inverse) &lt; 0)
+    if (ff_fft_init(&amp;s-&gt;fft, s-&gt;nbits - 2, inverse) &lt; 0)
         goto fail;
     return 0;
  fail:
@@ -60,29 +101,28 @@
 /* complex multiplication: p = a * b */
 #define CMUL(pre, pim, are, aim, bre, bim) \
 {\
-    float _are = (are);\
-    float _aim = (aim);\
-    float _bre = (bre);\
-    float _bim = (bim);\
+    FFTSample _are = (are);\
+    FFTSample _aim = (aim);\
+    FFTSample _bre = (bre);\
+    FFTSample _bim = (bim);\
     (pre) = _are * _bre - _aim * _bim;\
     (pim) = _are * _bim + _aim * _bre;\
 }
 
 /**
- * Compute inverse MDCT of size N = 2^nbits
- * @param output N samples
+ * Compute the middle half of the inverse MDCT of size N = 2^nbits,
+ * thus excluding the parts that can be derived by symmetry
+ * @param output N/2 samples
  * @param input N/2 samples
- * @param tmp N/2 samples
  */
-void ff_imdct_calc(MDCTContext *s, FFTSample *output, 
-                   const FFTSample *input, FFTSample *tmp)
+void ff_imdct_half_c(MDCTContext *s, FFTSample *output, const FFTSample *input)
 {
     int k, n8, n4, n2, n, j;
     const uint16_t *revtab = s-&gt;fft.revtab;
     const FFTSample *tcos = s-&gt;tcos;
     const FFTSample *tsin = s-&gt;tsin;
     const FFTSample *in1, *in2;
-    FFTComplex *z = (FFTComplex *)tmp;
+    FFTComplex *z = (FFTComplex *)output;
 
     n = 1 &lt;&lt; s-&gt;nbits;
     n2 = n &gt;&gt; 1;
@@ -98,25 +138,39 @@
         in1 += 2;
         in2 -= 2;
     }
-    fft_calc(&amp;s-&gt;fft, z);
+    ff_fft_calc(&amp;s-&gt;fft, z);
 
     /* post rotation + reordering */
-    /* XXX: optimize */
-    for(k = 0; k &lt; n4; k++) {
-        CMUL(z[k].re, z[k].im, z[k].re, z[k].im, tcos[k], tsin[k]);
+    output += n4;
+    for(k = 0; k &lt; n8; k++) {
+        FFTSample r0, i0, r1, i1;
+        CMUL(r0, i1, z[n8-k-1].im, z[n8-k-1].re, tsin[n8-k-1], tcos[n8-k-1]);
+        CMUL(r1, i0, z[n8+k  ].im, z[n8+k  ].re, tsin[n8+k  ], tcos[n8+k  ]);
+        z[n8-k-1].re = r0;
+        z[n8-k-1].im = i0;
+        z[n8+k  ].re = r1;
+        z[n8+k  ].im = i1;
     }
-    for(k = 0; k &lt; n8; k++) {
-        output[2*k] = -z[n8 + k].im;
-        output[n2-1-2*k] = z[n8 + k].im;
+}
 
-        output[2*k+1] = z[n8-1-k].re;
-        output[n2-1-2*k-1] = -z[n8-1-k].re;
+/**
+ * Compute inverse MDCT of size N = 2^nbits
+ * @param output N samples
+ * @param input N/2 samples
+ * @param tmp N/2 samples
+ */
+void ff_imdct_calc_c(MDCTContext *s, FFTSample *output, const FFTSample *input)
+{
+    int k;
+    int n = 1 &lt;&lt; s-&gt;nbits;
+    int n2 = n &gt;&gt; 1;
+    int n4 = n &gt;&gt; 2;
 
-        output[n2 + 2*k]=-z[k+n8].re;
-        output[n-1- 2*k]=-z[k+n8].re;
+    ff_imdct_half_c(s, output+n4, input);
 
-        output[n2 + 2*k+1]=z[n8-k-1].im;
-        output[n-2 - 2 * k] = z[n8-k-1].im;
+    for(k = 0; k &lt; n4; k++) {
+        output[k] = -output[n2-k-1];
+        output[n-k-1] = output[n2+k];
     }
 }
 
@@ -126,15 +180,14 @@
  * @param out N/2 samples
  * @param tmp temporary storage of N/2 samples
  */
-void ff_mdct_calc(MDCTContext *s, FFTSample *out, 
-                  const FFTSample *input, FFTSample *tmp)
+void ff_mdct_calc(MDCTContext *s, FFTSample *out, const FFTSample *input)
 {
     int i, j, n, n8, n4, n2, n3;
-    FFTSample re, im, re1, im1;
+    FFTSample re, im;
     const uint16_t *revtab = s-&gt;fft.revtab;
     const FFTSample *tcos = s-&gt;tcos;
     const FFTSample *tsin = s-&gt;tsin;
-    FFTComplex *x = (FFTComplex *)tmp;
+    FFTComplex *x = (FFTComplex *)out;
 
     n = 1 &lt;&lt; s-&gt;nbits;
     n2 = n &gt;&gt; 1;
@@ -155,15 +208,17 @@
         CMUL(x[j].re, x[j].im, re, im, -tcos[n8 + i], tsin[n8 + i]);
     }
 
-    fft_calc(&amp;s-&gt;fft, x);
-  
+    ff_fft_calc(&amp;s-&gt;fft, x);
+
     /* post rotation */
-    for(i=0;i&lt;n4;i++) {
-        re = x[i].re;
-        im = x[i].im;
-        CMUL(re1, im1, re, im, -tsin[i], -tcos[i]);
-        out[2*i] = im1;
-        out[n2-1-2*i] = re1;
+    for(i=0;i&lt;n8;i++) {
+        FFTSample r0, i0, r1, i1;
+        CMUL(i1, r0, x[n8-i-1].re, x[n8-i-1].im, -tsin[n8-i-1], -tcos[n8-i-1]);
+        CMUL(i0, r1, x[n8+i  ].re, x[n8+i  ].im, -tsin[n8+i  ], -tcos[n8+i  ]);
+        x[n8-i-1].re = r0;
+        x[n8-i-1].im = i0;
+        x[n8+i  ].re = r1;
+        x[n8+i  ].im = i1;
     }
 }
 
@@ -171,5 +226,5 @@
 {
     av_freep(&amp;s-&gt;tcos);
     av_freep(&amp;s-&gt;tsin);
-    fft_end(&amp;s-&gt;fft);
+    ff_fft_end(&amp;s-&gt;fft);
 }

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdec.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdec.c	2008-09-15 14:09:14 UTC (rev 27556)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mdec.c	2008-09-15 14:09:46 UTC (rev 27557)
@@ -1,42 +1,41 @@
 /*
- * PSX MDEC codec
+ * Sony PlayStation MDEC (Motion DECoder)
  * Copyright (c) 2003 Michael Niedermayer
  *
- * This library is free software; you can redistribute it and/or
+ * based upon code from Sebastian Jedruszkiewicz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">elf at frogger.rules.pl</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * based upon code from Sebastian Jedruszkiewicz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">elf at frogger.rules.pl</A>&gt;
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
- 
+
 /**
  * @file mdec.c
- * PSX MDEC codec.
- * This is very similar to intra only MPEG1.
+ * Sony PlayStation MDEC (Motion DECoder)
+ * This is very similar to intra-only MPEG-1.
  */
- 
+
 #include &quot;avcodec.h&quot;
 #include &quot;dsputil.h&quot;
 #include &quot;mpegvideo.h&quot;
+#include &quot;mpeg12.h&quot;
 
-//#undef NDEBUG
-//#include &lt;assert.h&gt;
-
 typedef struct MDECContext{
     AVCodecContext *avctx;
     DSPContext dsp;
     AVFrame picture;
-    PutBitContext pb;
     GetBitContext gb;
     ScanTable scantable;
     int version;
@@ -45,25 +44,25 @@
     int mb_width;
     int mb_height;
     int mb_x, mb_y;
-    DCTELEM __align8 block[6][64];
-    uint16_t __align8 intra_matrix[64];
-    int __align8 q_intra_matrix[64];
+    DECLARE_ALIGNED_16(DCTELEM, block[6][64]);
+    DECLARE_ALIGNED_8(uint16_t, intra_matrix[64]);
+    DECLARE_ALIGNED_8(int, q_intra_matrix[64]);
     uint8_t *bitstream_buffer;
-    int bitstream_buffer_size;
+    unsigned int bitstream_buffer_size;
     int block_last_index[6];
 } MDECContext;
 
-//very similar to mpeg1
+//very similar to MPEG-1
 static inline int mdec_decode_block_intra(MDECContext *a, DCTELEM *block, int n)
 {
     int level, diff, i, j, run;
     int component;
-    RLTable *rl = &amp;rl_mpeg1;
+    RLTable *rl = &amp;ff_rl_mpeg1;
     uint8_t * const scantable= a-&gt;scantable.permutated;
     const uint16_t *quant_matrix= ff_mpeg1_default_intra_matrix;
     const int qscale= a-&gt;qscale;
 
-    /* DC coef */
+    /* DC coefficient */
     if(a-&gt;version==2){
         block[0]= 2*get_sbits(&amp;a-&gt;gb, 10) + 1024;
     }else{
@@ -74,22 +73,21 @@
         a-&gt;last_dc[component]+= diff;
         block[0] = a-&gt;last_dc[component]&lt;&lt;3;
     }
-    
+
     i = 0;
     {
-        OPEN_READER(re, &amp;a-&gt;gb);    
-        /* now quantify &amp; encode AC coefs */
+        OPEN_READER(re, &amp;a-&gt;gb);
+        /* now quantify &amp; encode AC coefficients */
         for(;;) {
             UPDATE_CACHE(re, &amp;a-&gt;gb);
-            GET_RL_VLC(level, run, re, &amp;a-&gt;gb, rl-&gt;rl_vlc[0], TEX_VLC_BITS, 2);
-            
+            GET_RL_VLC(level, run, re, &amp;a-&gt;gb, rl-&gt;rl_vlc[0], TEX_VLC_BITS, 2, 0);
+
             if(level == 127){
                 break;
             } else if(level != 0) {
                 i += run;
                 j = scantable[i];
                 level= (level*qscale*quant_matrix[j])&gt;&gt;3;
-//                level= (level-1)|1;
                 level = (level ^ SHOW_SBITS(re, &amp;a-&gt;gb, 1)) - SHOW_SBITS(re, &amp;a-&gt;gb, 1);
                 LAST_SKIP_BITS(re, &amp;a-&gt;gb, 1);
             } else {
@@ -127,9 +125,9 @@
     const int block_index[6]= {5,4,0,1,2,3};
 
     a-&gt;dsp.clear_blocks(block[0]);
-    
+
     for(i=0; i&lt;6; i++){
-        if( mdec_decode_block_intra(a, block[ block_index[i] ], block_index[i]) &lt; 0) 
+        if( mdec_decode_block_intra(a, block[ block_index[i] ], block_index[i]) &lt; 0)
             return -1;
     }
     return 0;
@@ -138,7 +136,7 @@
 static inline void idct_put(MDECContext *a, int mb_x, int mb_y){
     DCTELEM (*block)[64]= a-&gt;block;
     int linesize= a-&gt;picture.linesize[0];
-    
+
     uint8_t *dest_y  = a-&gt;picture.data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
     uint8_t *dest_cb = a-&gt;picture.data[1] + (mb_y * 8 * a-&gt;picture.linesize[1]) + mb_x * 8;
     uint8_t *dest_cr = a-&gt;picture.data[2] + (mb_y * 8 * a-&gt;picture.linesize[2]) + mb_x * 8;
@@ -154,22 +152,15 @@
     }
 }
 
-static int decode_frame(AVCodecContext *avctx, 
+static int decode_frame(AVCodecContext *avctx,
                         void *data, int *data_size,
-                        uint8_t *buf, int buf_size)
+                        const uint8_t *buf, int buf_size)
 {
     MDECContext * const a = avctx-&gt;priv_data;
     AVFrame *picture = data;
-    AVFrame * const p= (AVFrame*)&amp;a-&gt;picture;
+    AVFrame * const p= &amp;a-&gt;picture;
     int i;
 
-    *data_size = 0;
-
-    /* special case for last picture */
-    if (buf_size == 0) {
-        return 0;
-    }
-
     if(p-&gt;data[0])
         avctx-&gt;release_buffer(avctx, p);
 
@@ -178,11 +169,8 @@
         av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
         return -1;
     }
-    p-&gt;pict_type= I_TYPE;
+    p-&gt;pict_type= FF_I_TYPE;
     p-&gt;key_frame= 1;
-    a-&gt;last_dc[0]=
-    a-&gt;last_dc[1]=
-    a-&gt;last_dc[2]= 0;
 
     a-&gt;bitstream_buffer= av_fast_realloc(a-&gt;bitstream_buffer, &amp;a-&gt;bitstream_buffer_size, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
     for(i=0; i&lt;buf_size; i+=2){
@@ -190,74 +178,68 @@
         a-&gt;bitstream_buffer[i+1]= buf[i  ];
     }
     init_get_bits(&amp;a-&gt;gb, a-&gt;bitstream_buffer, buf_size*8);
-    
+
     /* skip over 4 preamble bytes in stream (typically 0xXX 0xXX 0x00 0x38) */
     skip_bits(&amp;a-&gt;gb, 32);
 
     a-&gt;qscale=  get_bits(&amp;a-&gt;gb, 16);
     a-&gt;version= get_bits(&amp;a-&gt;gb, 16);
-    
-//    printf(&quot;qscale:%d (0x%X), version:%d (0x%X)\n&quot;, a-&gt;qscale, a-&gt;qscale, a-&gt;version, a-&gt;version);
-    
+
+    a-&gt;last_dc[0]=
+    a-&gt;last_dc[1]=
+    a-&gt;last_dc[2]= 128;
+
     for(a-&gt;mb_x=0; a-&gt;mb_x&lt;a-&gt;mb_width; a-&gt;mb_x++){
         for(a-&gt;mb_y=0; a-&gt;mb_y&lt;a-&gt;mb_height; a-&gt;mb_y++){
             if( decode_mb(a, a-&gt;block) &lt;0)
                 return -1;
-             
+
             idct_put(a, a-&gt;mb_x, a-&gt;mb_y);
         }
     }
 
-//    p-&gt;quality= (32 + a-&gt;inv_qscale/2)/a-&gt;inv_qscale;
-//    memset(p-&gt;qscale_table, p-&gt;quality, p-&gt;qstride*a-&gt;mb_height);
-    
-    *picture= *(AVFrame*)&amp;a-&gt;picture;
+    p-&gt;quality= a-&gt;qscale * FF_QP2LAMBDA;
+    memset(p-&gt;qscale_table, a-&gt;qscale, p-&gt;qstride*a-&gt;mb_height);
+
+    *picture   = a-&gt;picture;
     *data_size = sizeof(AVPicture);
 
-    emms_c();
-    
     return (get_bits_count(&amp;a-&gt;gb)+31)/32*4;
 }
 
-static void mdec_common_init(AVCodecContext *avctx){
+static av_cold void mdec_common_init(AVCodecContext *avctx){
     MDECContext * const a = avctx-&gt;priv_data;
 
     dsputil_init(&amp;a-&gt;dsp, avctx);
 
-    a-&gt;mb_width   = (avctx-&gt;width  + 15) / 16;
-    a-&gt;mb_height  = (avctx-&gt;height + 15) / 16;
+    a-&gt;mb_width   = (avctx-&gt;coded_width  + 15) / 16;
+    a-&gt;mb_height  = (avctx-&gt;coded_height + 15) / 16;
 
-    avctx-&gt;coded_frame= (AVFrame*)&amp;a-&gt;picture;
+    avctx-&gt;coded_frame= &amp;a-&gt;picture;
     a-&gt;avctx= avctx;
 }
 
-static int decode_init(AVCodecContext *avctx){
+static av_cold int decode_init(AVCodecContext *avctx){
     MDECContext * const a = avctx-&gt;priv_data;
-    AVFrame *p= (AVFrame*)&amp;a-&gt;picture;
- 
+    AVFrame *p= &amp;a-&gt;picture;
+
     mdec_common_init(avctx);
-    init_vlcs();
+    ff_mpeg12_init_vlcs();
     ff_init_scantable(a-&gt;dsp.idct_permutation, &amp;a-&gt;scantable, ff_zigzag_direct);
-/*
-    for(i=0; i&lt;64; i++){
-        int index= ff_zigzag_direct[i];
-        a-&gt;intra_matrix[i]= 64*ff_mpeg1_default_intra_matrix[index] / a-&gt;inv_qscale;
-    }
-*/
+
     p-&gt;qstride= a-&gt;mb_width;
     p-&gt;qscale_table= av_mallocz( p-&gt;qstride * a-&gt;mb_height);
+    avctx-&gt;pix_fmt= PIX_FMT_YUV420P;
 
     return 0;
 }
 
-static int decode_end(AVCodecContext *avctx){
+static av_cold int decode_end(AVCodecContext *avctx){
     MDECContext * const a = avctx-&gt;priv_data;
 
     av_freep(&amp;a-&gt;bitstream_buffer);
     av_freep(&amp;a-&gt;picture.qscale_table);
     a-&gt;bitstream_buffer_size=0;
-    
-    avcodec_default_free_buffers(avctx);
 
     return 0;
 }
@@ -272,5 +254,6 @@
     decode_end,
     decode_frame,
     CODEC_CAP_DR1,
+    .long_name= NULL_IF_CONFIG_SMALL(&quot;Sony PlayStation MDEC (Motion DECoder)&quot;),
 };
 

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mimic.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mimic.c	2008-09-15 14:09:14 UTC (rev 27556)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/mimic.c	2008-09-15 14:09:46 UTC (rev 27557)
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2005  Ole Andr&#233; Vadla Ravn&#229;s &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">oleavr at gmail.com</A>&gt;
+ * Copyright (C) 2008  Ramiro Polla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ramiro at lisha.ufsc.br</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdint.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;bytestream.h&quot;
+#include &quot;dsputil.h&quot;
+
+#define MIMIC_HEADER_SIZE   20
+
+typedef struct {
+    AVCodecContext *avctx;
+
+    int             num_vblocks[3];
+    int             num_hblocks[3];
+
+    uint8_t        *swap_buf;
+    int             swap_buf_size;
+
+    int             cur_index;
+    int             prev_index;
+
+    AVFrame         buf_ptrs    [16];
+    AVPicture       flipped_ptrs[16];
+
+    DECLARE_ALIGNED_16(DCTELEM, dct_block[64]);
+
+    GetBitContext   gb;
+    ScanTable       scantable;
+    DSPContext      dsp;
+    VLC             vlc;
+} MimicContext;
+
+static const uint32_t huffcodes[] = {
+    0x0000000a, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000000b,
+    0x0000001b, 0x00000038, 0x00000078, 0x00000079, 0x0000007a, 0x000000f9,
+    0x000000fa, 0x000003fb, 0x000007f8, 0x000007f9, 0x000007fa, 0x000007fb,
+    0x00000ff8, 0x00000ff9, 0x00000001, 0x00000039, 0x0000007b, 0x000000fb,
+    0x000001f8, 0x000001f9, 0x00000ffa, 0x00000ffb, 0x00001ff8, 0x00001ff9,
+    0x00001ffa, 0x00001ffb, 0x00003ff8, 0x00003ff9, 0x00003ffa, 0x00000000,
+    0x00000004, 0x0000003a, 0x000001fa, 0x00003ffb, 0x00007ff8, 0x00007ff9,
+    0x00007ffa, 0x00007ffb, 0x0000fff8, 0x0000fff9, 0x0000fffa, 0x0000fffb,
+    0x0001fff8, 0x0001fff9, 0x0001fffa, 0x00000000, 0x0000000c, 0x000000f8,
+    0x000001fb, 0x0001fffb, 0x0003fff8, 0x0003fff9, 0x0003fffa, 0x0003fffb,
+    0x0007fff8, 0x0007fff9, 0x0007fffa, 0x0007fffb, 0x000ffff8, 0x000ffff9,
+    0x000ffffa, 0x00000000, 0x0000001a, 0x000003f8, 0x000ffffb, 0x001ffff8,
+    0x001ffff9, 0x001ffffa, 0x001ffffb, 0x003ffff8, 0x003ffff9, 0x003ffffa,
+    0x003ffffb, 0x007ffff8, 0x007ffff9, 0x007ffffa, 0x007ffffb, 0x00000000,
+    0x0000003b, 0x000003f9, 0x00fffff8, 0x00fffff9, 0x00fffffa, 0x00fffffb,
+    0x01fffff8, 0x01fffff9, 0x01fffffa, 0x01fffffb, 0x03fffff8, 0x03fffff9,
+    0x03fffffa, 0x03fffffb, 0x07fffff8, 0x00000000, 0x000003fa, 0x07fffff9,
+    0x07fffffa, 0x07fffffb, 0x0ffffff8, 0x0ffffff9, 0x0ffffffa, 0x0ffffffb,
+    0x1ffffff8, 0x1ffffff9, 0x1ffffffa, 0x1ffffffb, 0x3ffffff8, 0x3ffffff9,
+    0x3ffffffa,
+};
+
+static const uint8_t huffbits[] = {
+     4,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
+     0,  0,  0,  0,  2,  4,  5,  6,  7,  7,  7,  8,
+     8, 10, 11, 11, 11, 11, 12, 12,  2,  6,  7,  8,
+     9,  9, 12, 12, 13, 13, 13, 13, 14, 14, 14,  0,
+     3,  6,  9, 14, 15, 15, 15, 15, 16, 16, 16, 16,
+    17, 17, 17,  0,  4,  8,  9, 17, 18, 18, 18, 18,
+    19, 19, 19, 19, 20, 20, 20,  0,  5, 10, 20, 21,
+    21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,  0,
+     6, 10, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26,
+    26, 26, 27,  0, 10, 27, 27, 27, 28, 28, 28, 28,
+    29, 29, 29, 29, 30, 30, 30,
+};
+
+static const uint8_t col_zag[64] = {
+     0,  8,  1,  2,  9, 16, 24, 17,
+    10,  3,  4, 11, 18, 25, 32, 40,
+    33, 26, 19, 12,  5,  6, 13, 20,
+    27, 34, 41, 48, 56, 49, 42, 35,
+    28, 21, 14,  7, 15, 22, 29, 36,
+    43, 50, 57, 58, 51, 44, 37, 30,
+    23, 31, 38, 45, 52, 59, 39, 46,
+    53, 60, 61, 54, 47, 55, 62, 63,
+};
+
+static av_cold int mimic_decode_init(AVCodecContext *avctx)
+{
+    MimicContext *ctx = avctx-&gt;priv_data;
+
+    ctx-&gt;prev_index = 0;
+    ctx-&gt;cur_index = 15;
+
+    if(init_vlc(&amp;ctx-&gt;vlc, 11, sizeof(huffbits)/sizeof(huffbits[0]),
+                 huffbits, 1, 1, huffcodes, 4, 4, 0)) {
+        av_log(avctx, AV_LOG_ERROR, &quot;error initializing vlc table\n&quot;);
+        return -1;
+    }
+    dsputil_init(&amp;ctx-&gt;dsp, avctx);
+    ff_init_scantable(ctx-&gt;dsp.idct_permutation, &amp;ctx-&gt;scantable, col_zag);
+
+    return 0;
+}
+
+const static int8_t vlcdec_lookup[9][64] = {
+    {    0, },
+    {   -1,   1, },
+    {   -3,   3,   -2,   2, },
+    {   -7,   7,   -6,   6,   -5,   5,   -4,   4, },
+    {  -15,  15,  -14,  14,  -13,  13,  -12,  12,
+       -11,  11,  -10,  10,   -9,   9,   -8,   8, },
+    {  -31,  31,  -30,  30,  -29,  29,  -28,  28,
+       -27,  27,  -26,  26,  -25,  25,  -24,  24,
+       -23,  23,  -22,  22,  -21,  21,  -20,  20,
+       -19,  19,  -18,  18,  -17,  17,  -16,  16, },
+    {  -63,  63,  -62,  62,  -61,  61,  -60,  60,
+       -59,  59,  -58,  58,  -57,  57,  -56,  56,
+       -55,  55,  -54,  54,  -53,  53,  -52,  52,
+       -51,  51,  -50,  50,  -49,  49,  -48,  48,
+       -47,  47,  -46,  46,  -45,  45,  -44,  44,
+       -43,  43,  -42,  42,  -41,  41,  -40,  40,
+       -39,  39,  -38,  38,  -37,  37,  -36,  36,
+       -35,  35,  -34,  34,  -33,  33,  -32,  32, },
+    { -127, 127, -126, 126, -125, 125, -124, 124,
+      -123, 123, -122, 122, -121, 121, -120, 120,
+      -119, 119, -118, 118, -117, 117, -116, 116,
+      -115, 115, -114, 114, -113, 113, -112, 112,
+      -111, 111, -110, 110, -109, 109, -108, 108,
+      -107, 107, -106, 106, -105, 105, -104, 104,
+      -103, 103, -102, 102, -101, 101, -100, 100,
+       -99,  99,  -98,  98,  -97,  97,  -96,  96, },
+    {  -95,  95,  -94,  94,  -93,  93,  -92,  92,
+       -91,  91,  -90,  90,  -89,  89,  -88,  88,
+       -87,  87,  -86,  86,  -85,  85,  -84,  84,
+       -83,  83,  -82,  82,  -81,  81,  -80,  80,
+       -79,  79,  -78,  78,  -77,  77,  -76,  76,
+       -75,  75,  -74,  74,  -73,  73,  -72,  72,
+       -71,  71,  -70,  70,  -69,  69,  -68,  68,
+       -67,  67,  -66,  66,  -65,  65,  -64,  64, },
+};
+
+static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)
+{
+    DCTELEM *block = ctx-&gt;dct_block;
+    unsigned int pos;
+
+    memset(block, 0, 64 * sizeof(DCTELEM));
+
+    block[0] = get_bits(&amp;ctx-&gt;gb, 8) &lt;&lt; 3;
+
+    for(pos = 1; pos &lt; num_coeffs; pos++) {
+        uint32_t vlc, num_bits;
+        int value;
+        int coeff;
+

[... truncated: 18039 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011866.html">[Haiku-commits] r27556 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011868.html">[Haiku-commits] r27558 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11867">[ date ]</a>
              <a href="thread.html#11867">[ thread ]</a>
              <a href="subject.html#11867">[ subject ]</a>
              <a href="author.html#11867">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
