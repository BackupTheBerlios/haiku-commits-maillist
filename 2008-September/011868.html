<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27558 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27558%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151410.m8FEAaSO001225%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011867.html">
   <LINK REL="Next"  HREF="011869.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27558 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27558%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151410.m8FEAaSO001225%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27558 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:10:36 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011867.html">[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011869.html">[Haiku-commits] r27559 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11868">[ date ]</a>
              <a href="thread.html#11868">[ thread ]</a>
              <a href="subject.html#11868">[ subject ]</a>
              <a href="author.html#11868">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:10:29 +0200 (Mon, 15 Sep 2008)
New Revision: 27558
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27558&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27558&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vb.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1acdata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1data.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1dsp.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vmnc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis_data.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis_dec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis_enc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vorbis_enc_data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp3_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp3dsp.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp5.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp56.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp56.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp56data.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp56data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp5data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp6.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp6data.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vcr1.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vmdav.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp3.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vp3data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vqavideo.c
Log:
Update avcodec to 20080825

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vb.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vb.c	2008-09-15 14:09:46 UTC (rev 27557)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vb.c	2008-09-15 14:10:29 UTC (rev 27558)
@@ -0,0 +1,283 @@
+/*
+ * Beam Software VB decoder
+ * Copyright (c) 2007 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file vb.c
+ * VB Video decoder
+ */
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;bytestream.h&quot;
+
+enum VBFlags{
+    VB_HAS_GMC     = 0x01,
+    VB_HAS_AUDIO   = 0x04,
+    VB_HAS_VIDEO   = 0x08,
+    VB_HAS_PALETTE = 0x10,
+    VB_HAS_LENGTH  = 0x20
+};
+
+typedef struct VBDecContext {
+    AVCodecContext *avctx;
+    AVFrame pic;
+
+    uint8_t *frame, *prev_frame;
+    uint32_t pal[256];
+    const uint8_t *stream;
+} VBDecContext;
+
+static const uint16_t vb_patterns[64] = {
+    0x0660, 0xFF00, 0xCCCC, 0xF000, 0x8888, 0x000F, 0x1111, 0xFEC8,
+    0x8CEF, 0x137F, 0xF731, 0xC800, 0x008C, 0x0013, 0x3100, 0xCC00,
+    0x00CC, 0x0033, 0x3300, 0x0FF0, 0x6666, 0x00F0, 0x0F00, 0x2222,
+    0x4444, 0xF600, 0x8CC8, 0x006F, 0x1331, 0x318C, 0xC813, 0x33CC,
+    0x6600, 0x0CC0, 0x0066, 0x0330, 0xF900, 0xC88C, 0x009F, 0x3113,
+    0x6000, 0x0880, 0x0006, 0x0110, 0xCC88, 0xFC00, 0x00CF, 0x88CC,
+    0x003F, 0x1133, 0x3311, 0xF300, 0x6FF6, 0x0603, 0x08C6, 0x8C63,
+    0xC631, 0x6310, 0xC060, 0x0136, 0x136C, 0x36C8, 0x6C80, 0x324C
+};
+
+static void vb_decode_palette(VBDecContext *c)
+{
+    int start, size, i;
+
+    start = bytestream_get_byte(&amp;c-&gt;stream);
+    size = (bytestream_get_byte(&amp;c-&gt;stream) - 1) &amp; 0xFF;
+    if(start + size &gt; 255){
+        av_log(c-&gt;avctx, AV_LOG_ERROR, &quot;Palette change runs beyond entry 256\n&quot;);
+        return;
+    }
+    for(i = start; i &lt;= start + size; i++)
+        c-&gt;pal[i] = bytestream_get_be24(&amp;c-&gt;stream);
+}
+
+static inline int check_pixel(uint8_t *buf, uint8_t *start, uint8_t *end)
+{
+    return buf &gt;= start &amp;&amp; buf &lt; end;
+}
+
+static inline int check_line(uint8_t *buf, uint8_t *start, uint8_t *end)
+{
+    return buf &gt;= start &amp;&amp; (buf + 4) &lt;= end;
+}
+
+static int vb_decode_framedata(VBDecContext *c, const uint8_t *buf, int offset)
+{
+    uint8_t *prev, *cur;
+    int blk, blocks, t, blk2;
+    int blocktypes = 0;
+    int x, y, a, b;
+    int pattype, pattern;
+    const int width = c-&gt;avctx-&gt;width;
+    uint8_t *pstart = c-&gt;prev_frame;
+    uint8_t *pend = c-&gt;prev_frame + width*c-&gt;avctx-&gt;height;
+
+    prev = c-&gt;prev_frame + offset;
+    cur = c-&gt;frame;
+
+    blocks = (c-&gt;avctx-&gt;width &gt;&gt; 2) * (c-&gt;avctx-&gt;height &gt;&gt; 2);
+    blk2 = 0;
+    for(blk = 0; blk &lt; blocks; blk++){
+        if(!(blk &amp; 3))
+            blocktypes = bytestream_get_byte(&amp;buf);
+        switch(blocktypes &amp; 0xC0){
+        case 0x00: //skip
+            for(y = 0; y &lt; 4; y++)
+                if(check_line(prev + y*width, pstart, pend))
+                    memcpy(cur + y*width, prev + y*width, 4);
+                else
+                    memset(cur + y*width, 0, 4);
+            break;
+        case 0x40:
+            t = bytestream_get_byte(&amp;buf);
+            if(!t){ //raw block
+                for(y = 0; y &lt; 4; y++)
+                    memcpy(cur + y*width, buf + y*4, 4);
+                buf += 16;
+            }else{ // motion compensation
+                x = ((t &amp; 0xF)^8) - 8;
+                y = ((t &gt;&gt; 4) ^8) - 8;
+                t = x + y*width;
+                for(y = 0; y &lt; 4; y++)
+                    if(check_line(prev + t + y*width, pstart, pend))
+                        memcpy(cur + y*width, prev + t + y*width, 4);
+                    else
+                        memset(cur + y*width, 0, 4);
+            }
+            break;
+        case 0x80: // fill
+            t = bytestream_get_byte(&amp;buf);
+            for(y = 0; y &lt; 4; y++)
+                memset(cur + y*width, t, 4);
+            break;
+        case 0xC0: // pattern fill
+            t = bytestream_get_byte(&amp;buf);
+            pattype = t &gt;&gt; 6;
+            pattern = vb_patterns[t &amp; 0x3F];
+            switch(pattype){
+            case 0:
+                a = bytestream_get_byte(&amp;buf);
+                b = bytestream_get_byte(&amp;buf);
+                for(y = 0; y &lt; 4; y++)
+                    for(x = 0; x &lt; 4; x++, pattern &gt;&gt;= 1)
+                        cur[x + y*width] = (pattern &amp; 1) ? b : a;
+                break;
+            case 1:
+                pattern = ~pattern;
+            case 2:
+                a = bytestream_get_byte(&amp;buf);
+                for(y = 0; y &lt; 4; y++)
+                    for(x = 0; x &lt; 4; x++, pattern &gt;&gt;= 1)
+                        if(pattern &amp; 1 &amp;&amp; check_pixel(prev + x + y*width, pstart, pend))
+                            cur[x + y*width] = prev[x + y*width];
+                        else
+                            cur[x + y*width] = a;
+                break;
+            case 3:
+                av_log(c-&gt;avctx, AV_LOG_ERROR, &quot;Invalid opcode seen @%d\n&quot;,blk);
+                return -1;
+            }
+            break;
+        }
+        blocktypes &lt;&lt;= 2;
+        cur  += 4;
+        prev += 4;
+        blk2++;
+        if(blk2 == (width &gt;&gt; 2)){
+            blk2 = 0;
+            cur  += width * 3;
+            prev += width * 3;
+        }
+    }
+    return 0;
+}
+
+static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, const uint8_t *buf, int buf_size)
+{
+    VBDecContext * const c = avctx-&gt;priv_data;
+    uint8_t *outptr, *srcptr;
+    int i, j;
+    int flags;
+    uint32_t size;
+    int rest = buf_size;
+    int offset = 0;
+
+    c-&gt;stream = buf;
+    flags = bytestream_get_le16(&amp;c-&gt;stream);
+    rest -= 2;
+
+    if(flags &amp; VB_HAS_GMC){
+        i = (int16_t)bytestream_get_le16(&amp;c-&gt;stream);
+        j = (int16_t)bytestream_get_le16(&amp;c-&gt;stream);
+        offset = i + j * avctx-&gt;width;
+        rest -= 4;
+    }
+    if(flags &amp; VB_HAS_VIDEO){
+        size = bytestream_get_le32(&amp;c-&gt;stream);
+        if(size &gt; rest){
+            av_log(avctx, AV_LOG_ERROR, &quot;Frame size is too big\n&quot;);
+            return -1;
+        }
+        vb_decode_framedata(c, c-&gt;stream, offset);
+        c-&gt;stream += size - 4;
+        rest -= size;
+    }
+    if(flags &amp; VB_HAS_PALETTE){
+        size = bytestream_get_le32(&amp;c-&gt;stream);
+        if(size &gt; rest){
+            av_log(avctx, AV_LOG_ERROR, &quot;Palette size is too big\n&quot;);
+            return -1;
+        }
+        vb_decode_palette(c);
+        rest -= size;
+    }
+
+    memcpy(c-&gt;pic.data[1], c-&gt;pal, AVPALETTE_SIZE);
+    c-&gt;pic.palette_has_changed = flags &amp; VB_HAS_PALETTE;
+
+    outptr = c-&gt;pic.data[0];
+    srcptr = c-&gt;frame;
+
+    for(i = 0; i &lt; avctx-&gt;height; i++){
+        memcpy(outptr, srcptr, avctx-&gt;width);
+        srcptr += avctx-&gt;width;
+        outptr += c-&gt;pic.linesize[0];
+    }
+
+    FFSWAP(uint8_t*, c-&gt;frame, c-&gt;prev_frame);
+
+    *data_size = sizeof(AVFrame);
+    *(AVFrame*)data = c-&gt;pic;
+
+    /* always report that the buffer was completely consumed */
+    return buf_size;
+}
+
+static av_cold int decode_init(AVCodecContext *avctx)
+{
+    VBDecContext * const c = avctx-&gt;priv_data;
+
+    c-&gt;avctx = avctx;
+    avctx-&gt;pix_fmt = PIX_FMT_PAL8;
+
+    if (avcodec_check_dimensions(avctx, avctx-&gt;width, avctx-&gt;height) &lt; 0) {
+        return -1;
+    }
+
+    c-&gt;pic.reference = 1;
+    if(avctx-&gt;get_buffer(avctx, &amp;c-&gt;pic) &lt; 0){
+        av_log(avctx, AV_LOG_ERROR, &quot;get_buffer() failed\n&quot;);
+        return -1;
+    }
+
+    c-&gt;frame      = av_malloc( avctx-&gt;width * avctx-&gt;height);
+    c-&gt;prev_frame = av_malloc( avctx-&gt;width * avctx-&gt;height);
+
+    return 0;
+}
+
+static av_cold int decode_end(AVCodecContext *avctx)
+{
+    VBDecContext *c = avctx-&gt;priv_data;
+
+    av_freep(&amp;c-&gt;frame);
+    av_freep(&amp;c-&gt;prev_frame);
+    if(c-&gt;pic.data[0])
+        avctx-&gt;release_buffer(avctx, &amp;c-&gt;pic);
+
+    return 0;
+}
+
+AVCodec vb_decoder = {
+    &quot;vb&quot;,
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VB,
+    sizeof(VBDecContext),
+    decode_init,
+    NULL,
+    decode_end,
+    decode_frame,
+    .long_name = NULL_IF_CONFIG_SMALL(&quot;Beam Software VB&quot;),
+};
+

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1.c	2008-09-15 14:09:46 UTC (rev 27557)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/vc1.c	2008-09-15 14:10:29 UTC (rev 27558)
@@ -0,0 +1,4317 @@
+/*
+ * VC-1 and WMV3 decoder
+ * Copyright (c) 2006-2007 Konstantin Shishkov
+ * Partly based on vc9.c (c) 2005 Anonymous, Alex Beregszaszi, Michael Niedermayer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file vc1.c
+ * VC-1 and WMV3 decoder
+ *
+ */
+#include &quot;dsputil.h&quot;
+#include &quot;avcodec.h&quot;
+#include &quot;mpegvideo.h&quot;
+#include &quot;vc1.h&quot;
+#include &quot;vc1data.h&quot;
+#include &quot;vc1acdata.h&quot;
+#include &quot;msmpeg4data.h&quot;
+#include &quot;unary.h&quot;
+#include &quot;simple_idct.h&quot;
+
+#undef NDEBUG
+#include &lt;assert.h&gt;
+
+#define MB_INTRA_VLC_BITS 9
+#define DC_VLC_BITS 9
+#define AC_VLC_BITS 9
+static const uint16_t table_mb_intra[64][2];
+
+
+/**
+ * Init VC-1 specific tables and VC1Context members
+ * @param v The VC1Context to initialize
+ * @return Status
+ */
+static int vc1_init_common(VC1Context *v)
+{
+    static int done = 0;
+    int i = 0;
+
+    v-&gt;hrd_rate = v-&gt;hrd_buffer = NULL;
+
+    /* VLC tables */
+    if(!done)
+    {
+        done = 1;
+        init_vlc(&amp;ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,
+                 ff_vc1_bfraction_bits, 1, 1,
+                 ff_vc1_bfraction_codes, 1, 1, 1);
+        init_vlc(&amp;ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,
+                 ff_vc1_norm2_bits, 1, 1,
+                 ff_vc1_norm2_codes, 1, 1, 1);
+        init_vlc(&amp;ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,
+                 ff_vc1_norm6_bits, 1, 1,
+                 ff_vc1_norm6_codes, 2, 2, 1);
+        init_vlc(&amp;ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,
+                 ff_vc1_imode_bits, 1, 1,
+                 ff_vc1_imode_codes, 1, 1, 1);
+        for (i=0; i&lt;3; i++)
+        {
+            init_vlc(&amp;ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,
+                     ff_vc1_ttmb_bits[i], 1, 1,
+                     ff_vc1_ttmb_codes[i], 2, 2, 1);
+            init_vlc(&amp;ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,
+                     ff_vc1_ttblk_bits[i], 1, 1,
+                     ff_vc1_ttblk_codes[i], 1, 1, 1);
+            init_vlc(&amp;ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,
+                     ff_vc1_subblkpat_bits[i], 1, 1,
+                     ff_vc1_subblkpat_codes[i], 1, 1, 1);
+        }
+        for(i=0; i&lt;4; i++)
+        {
+            init_vlc(&amp;ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,
+                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,
+                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, 1);
+            init_vlc(&amp;ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,
+                     ff_vc1_cbpcy_p_bits[i], 1, 1,
+                     ff_vc1_cbpcy_p_codes[i], 2, 2, 1);
+            init_vlc(&amp;ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,
+                     ff_vc1_mv_diff_bits[i], 1, 1,
+                     ff_vc1_mv_diff_codes[i], 2, 2, 1);
+        }
+        for(i=0; i&lt;8; i++)
+            init_vlc(&amp;ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],
+                     &amp;vc1_ac_tables[i][0][1], 8, 4,
+                     &amp;vc1_ac_tables[i][0][0], 8, 4, 1);
+        init_vlc(&amp;ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,
+                 &amp;ff_msmp4_mb_i_table[0][1], 4, 2,
+                 &amp;ff_msmp4_mb_i_table[0][0], 4, 2, 1);
+    }
+
+    /* Other defaults */
+    v-&gt;pq = -1;
+    v-&gt;mvrange = 0; /* 7.1.1.18, p80 */
+
+    return 0;
+}
+
+/***********************************************************************/
+/**
+ * @defgroup bitplane VC9 Bitplane decoding
+ * @see 8.7, p56
+ * @{
+ */
+
+/** @addtogroup bitplane
+ * Imode types
+ * @{
+ */
+enum Imode {
+    IMODE_RAW,
+    IMODE_NORM2,
+    IMODE_DIFF2,
+    IMODE_NORM6,
+    IMODE_DIFF6,
+    IMODE_ROWSKIP,
+    IMODE_COLSKIP
+};
+/** @} */ //imode defines
+
+/** Decode rows by checking if they are skipped
+ * @param plane Buffer to store decoded bits
+ * @param[in] width Width of this buffer
+ * @param[in] height Height of this buffer
+ * @param[in] stride of this buffer
+ */
+static void decode_rowskip(uint8_t* plane, int width, int height, int stride, GetBitContext *gb){
+    int x, y;
+
+    for (y=0; y&lt;height; y++){
+        if (!get_bits1(gb)) //rowskip
+            memset(plane, 0, width);
+        else
+            for (x=0; x&lt;width; x++)
+                plane[x] = get_bits1(gb);
+        plane += stride;
+    }
+}
+
+/** Decode columns by checking if they are skipped
+ * @param plane Buffer to store decoded bits
+ * @param[in] width Width of this buffer
+ * @param[in] height Height of this buffer
+ * @param[in] stride of this buffer
+ * @todo FIXME: Optimize
+ */
+static void decode_colskip(uint8_t* plane, int width, int height, int stride, GetBitContext *gb){
+    int x, y;
+
+    for (x=0; x&lt;width; x++){
+        if (!get_bits1(gb)) //colskip
+            for (y=0; y&lt;height; y++)
+                plane[y*stride] = 0;
+        else
+            for (y=0; y&lt;height; y++)
+                plane[y*stride] = get_bits1(gb);
+        plane ++;
+    }
+}
+
+/** Decode a bitplane's bits
+ * @param bp Bitplane where to store the decode bits
+ * @param v VC-1 context for bit reading and logging
+ * @return Status
+ * @todo FIXME: Optimize
+ */
+static int bitplane_decoding(uint8_t* data, int *raw_flag, VC1Context *v)
+{
+    GetBitContext *gb = &amp;v-&gt;s.gb;
+
+    int imode, x, y, code, offset;
+    uint8_t invert, *planep = data;
+    int width, height, stride;
+
+    width = v-&gt;s.mb_width;
+    height = v-&gt;s.mb_height;
+    stride = v-&gt;s.mb_stride;
+    invert = get_bits1(gb);
+    imode = get_vlc2(gb, ff_vc1_imode_vlc.table, VC1_IMODE_VLC_BITS, 1);
+
+    *raw_flag = 0;
+    switch (imode)
+    {
+    case IMODE_RAW:
+        //Data is actually read in the MB layer (same for all tests == &quot;raw&quot;)
+        *raw_flag = 1; //invert ignored
+        return invert;
+    case IMODE_DIFF2:
+    case IMODE_NORM2:
+        if ((height * width) &amp; 1)
+        {
+            *planep++ = get_bits1(gb);
+            offset = 1;
+        }
+        else offset = 0;
+        // decode bitplane as one long line
+        for (y = offset; y &lt; height * width; y += 2) {
+            code = get_vlc2(gb, ff_vc1_norm2_vlc.table, VC1_NORM2_VLC_BITS, 1);
+            *planep++ = code &amp; 1;
+            offset++;
+            if(offset == width) {
+                offset = 0;
+                planep += stride - width;
+            }
+            *planep++ = code &gt;&gt; 1;
+            offset++;
+            if(offset == width) {
+                offset = 0;
+                planep += stride - width;
+            }
+        }
+        break;
+    case IMODE_DIFF6:
+    case IMODE_NORM6:
+        if(!(height % 3) &amp;&amp; (width % 3)) { // use 2x3 decoding
+            for(y = 0; y &lt; height; y+= 3) {
+                for(x = width &amp; 1; x &lt; width; x += 2) {
+                    code = get_vlc2(gb, ff_vc1_norm6_vlc.table, VC1_NORM6_VLC_BITS, 2);
+                    if(code &lt; 0){
+                        av_log(v-&gt;s.avctx, AV_LOG_DEBUG, &quot;invalid NORM-6 VLC\n&quot;);
+                        return -1;
+                    }
+                    planep[x + 0] = (code &gt;&gt; 0) &amp; 1;
+                    planep[x + 1] = (code &gt;&gt; 1) &amp; 1;
+                    planep[x + 0 + stride] = (code &gt;&gt; 2) &amp; 1;
+                    planep[x + 1 + stride] = (code &gt;&gt; 3) &amp; 1;
+                    planep[x + 0 + stride * 2] = (code &gt;&gt; 4) &amp; 1;
+                    planep[x + 1 + stride * 2] = (code &gt;&gt; 5) &amp; 1;
+                }
+                planep += stride * 3;
+            }
+            if(width &amp; 1) decode_colskip(data, 1, height, stride, &amp;v-&gt;s.gb);
+        } else { // 3x2
+            planep += (height &amp; 1) * stride;
+            for(y = height &amp; 1; y &lt; height; y += 2) {
+                for(x = width % 3; x &lt; width; x += 3) {
+                    code = get_vlc2(gb, ff_vc1_norm6_vlc.table, VC1_NORM6_VLC_BITS, 2);
+                    if(code &lt; 0){
+                        av_log(v-&gt;s.avctx, AV_LOG_DEBUG, &quot;invalid NORM-6 VLC\n&quot;);
+                        return -1;
+                    }
+                    planep[x + 0] = (code &gt;&gt; 0) &amp; 1;
+                    planep[x + 1] = (code &gt;&gt; 1) &amp; 1;
+                    planep[x + 2] = (code &gt;&gt; 2) &amp; 1;
+                    planep[x + 0 + stride] = (code &gt;&gt; 3) &amp; 1;
+                    planep[x + 1 + stride] = (code &gt;&gt; 4) &amp; 1;
+                    planep[x + 2 + stride] = (code &gt;&gt; 5) &amp; 1;
+                }
+                planep += stride * 2;
+            }
+            x = width % 3;
+            if(x) decode_colskip(data  ,             x, height    , stride, &amp;v-&gt;s.gb);
+            if(height &amp; 1) decode_rowskip(data+x, width - x, 1, stride, &amp;v-&gt;s.gb);
+        }
+        break;
+    case IMODE_ROWSKIP:
+        decode_rowskip(data, width, height, stride, &amp;v-&gt;s.gb);
+        break;
+    case IMODE_COLSKIP:
+        decode_colskip(data, width, height, stride, &amp;v-&gt;s.gb);
+        break;
+    default: break;
+    }
+
+    /* Applying diff operator */
+    if (imode == IMODE_DIFF2 || imode == IMODE_DIFF6)
+    {
+        planep = data;
+        planep[0] ^= invert;
+        for (x=1; x&lt;width; x++)
+            planep[x] ^= planep[x-1];
+        for (y=1; y&lt;height; y++)
+        {
+            planep += stride;
+            planep[0] ^= planep[-stride];
+            for (x=1; x&lt;width; x++)
+            {
+                if (planep[x-1] != planep[x-stride]) planep[x] ^= invert;
+                else                                 planep[x] ^= planep[x-1];
+            }
+        }
+    }
+    else if (invert)
+    {
+        planep = data;
+        for (x=0; x&lt;stride*height; x++) planep[x] = !planep[x]; //FIXME stride
+    }
+    return (imode&lt;&lt;1) + invert;
+}
+
+/** @} */ //Bitplane group
+
+#define FILTSIGN(a) ((a) &gt;= 0 ? 1 : -1)
+/**
+ * VC-1 in-loop deblocking filter for one line
+ * @param src source block type
+ * @param pq block quantizer
+ * @return whether other 3 pairs should be filtered or not
+ * @see 8.6
+ */
+static int vc1_filter_line(uint8_t* src, int stride, int pq){
+    int a0, a1, a2, a3, d, clip, filt3 = 0;
+    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+
+    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) &gt;&gt; 3;
+    if(FFABS(a0) &lt; pq){
+        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) &gt;&gt; 3;
+        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) &gt;&gt; 3;
+        a3 = FFMIN(FFABS(a1), FFABS(a2));
+        if(a3 &lt; FFABS(a0)){
+            d = 5 * ((a0 &gt;=0 ? a3 : -a3) - a0) / 8;
+            clip = (src[-1*stride] - src[ 0*stride])/2;
+            if(clip){
+                filt3 = 1;
+                if(clip &gt; 0)
+                    d = av_clip(d, 0, clip);
+                else
+                    d = av_clip(d, clip, 0);
+                src[-1*stride] = cm[src[-1*stride] - d];
+                src[ 0*stride] = cm[src[ 0*stride] + d];
+            }
+        }
+    }
+    return filt3;
+}
+
+/**
+ * VC-1 in-loop deblocking filter
+ * @param src source block type
+ * @param len edge length to filter (4 or 8 pixels)
+ * @param pq block quantizer
+ * @see 8.6
+ */
+static void vc1_loop_filter(uint8_t* src, int step, int stride, int len, int pq)
+{
+    int i;
+    int filt3;
+
+    for(i = 0; i &lt; len; i += 4){
+        filt3 = vc1_filter_line(src + 2*step, stride, pq);
+        if(filt3){
+            vc1_filter_line(src + 0*step, stride, pq);
+            vc1_filter_line(src + 1*step, stride, pq);
+            vc1_filter_line(src + 3*step, stride, pq);
+        }
+        src += step * 4;
+    }
+}
+
+static void vc1_loop_filter_iblk(MpegEncContext *s, int pq)
+{
+    int i, j;
+    if(!s-&gt;first_slice_line)
+        vc1_loop_filter(s-&gt;dest[0], 1, s-&gt;linesize, 16, pq);
+    vc1_loop_filter(s-&gt;dest[0] + 8*s-&gt;linesize, 1, s-&gt;linesize, 16, pq);
+    for(i = !s-&gt;mb_x*8; i &lt; 16; i += 8)
+        vc1_loop_filter(s-&gt;dest[0] + i, s-&gt;linesize, 1, 16, pq);
+    for(j = 0; j &lt; 2; j++){
+        if(!s-&gt;first_slice_line)
+            vc1_loop_filter(s-&gt;dest[j+1], 1, s-&gt;uvlinesize, 8, pq);
+        if(s-&gt;mb_x)
+            vc1_loop_filter(s-&gt;dest[j+1], s-&gt;uvlinesize, 1, 8, pq);
+    }
+}
+
+/***********************************************************************/
+/** VOP Dquant decoding
+ * @param v VC-1 Context
+ */
+static int vop_dquant_decoding(VC1Context *v)
+{
+    GetBitContext *gb = &amp;v-&gt;s.gb;
+    int pqdiff;
+
+    //variable size
+    if (v-&gt;dquant == 2)
+    {
+        pqdiff = get_bits(gb, 3);
+        if (pqdiff == 7) v-&gt;altpq = get_bits(gb, 5);
+        else v-&gt;altpq = v-&gt;pq + pqdiff + 1;
+    }
+    else
+    {
+        v-&gt;dquantfrm = get_bits1(gb);
+        if ( v-&gt;dquantfrm )
+        {
+            v-&gt;dqprofile = get_bits(gb, 2);
+            switch (v-&gt;dqprofile)
+            {
+            case DQPROFILE_SINGLE_EDGE:
+            case DQPROFILE_DOUBLE_EDGES:
+                v-&gt;dqsbedge = get_bits(gb, 2);
+                break;
+            case DQPROFILE_ALL_MBS:
+                v-&gt;dqbilevel = get_bits1(gb);
+                if(!v-&gt;dqbilevel)
+                    v-&gt;halfpq = 0;
+            default: break; //Forbidden ?
+            }
+            if (v-&gt;dqbilevel || v-&gt;dqprofile != DQPROFILE_ALL_MBS)
+            {
+                pqdiff = get_bits(gb, 3);
+                if (pqdiff == 7) v-&gt;altpq = get_bits(gb, 5);
+                else v-&gt;altpq = v-&gt;pq + pqdiff + 1;
+            }
+        }
+    }
+    return 0;
+}
+
+/** Put block onto picture
+ */
+static void vc1_put_block(VC1Context *v, DCTELEM block[6][64])
+{
+    uint8_t *Y;
+    int ys, us, vs;
+    DSPContext *dsp = &amp;v-&gt;s.dsp;
+
+    if(v-&gt;rangeredfrm) {
+        int i, j, k;
+        for(k = 0; k &lt; 6; k++)
+            for(j = 0; j &lt; 8; j++)
+                for(i = 0; i &lt; 8; i++)
+                    block[k][i + j*8] = ((block[k][i + j*8] - 128) &lt;&lt; 1) + 128;
+
+    }
+    ys = v-&gt;s.current_picture.linesize[0];
+    us = v-&gt;s.current_picture.linesize[1];
+    vs = v-&gt;s.current_picture.linesize[2];
+    Y = v-&gt;s.dest[0];
+
+    dsp-&gt;put_pixels_clamped(block[0], Y, ys);
+    dsp-&gt;put_pixels_clamped(block[1], Y + 8, ys);
+    Y += ys * 8;
+    dsp-&gt;put_pixels_clamped(block[2], Y, ys);
+    dsp-&gt;put_pixels_clamped(block[3], Y + 8, ys);
+
+    if(!(v-&gt;s.flags &amp; CODEC_FLAG_GRAY)) {
+        dsp-&gt;put_pixels_clamped(block[4], v-&gt;s.dest[1], us);
+        dsp-&gt;put_pixels_clamped(block[5], v-&gt;s.dest[2], vs);
+    }
+}
+
+/** Do motion compensation over 1 macroblock
+ * Mostly adapted hpel_motion and qpel_motion from mpegvideo.c
+ */
+static void vc1_mc_1mv(VC1Context *v, int dir)
+{
+    MpegEncContext *s = &amp;v-&gt;s;
+    DSPContext *dsp = &amp;v-&gt;s.dsp;
+    uint8_t *srcY, *srcU, *srcV;
+    int dxy, uvdxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;
+
+    if(!v-&gt;s.last_picture.data[0])return;
+
+    mx = s-&gt;mv[dir][0][0];
+    my = s-&gt;mv[dir][0][1];
+
+    // store motion vectors for further use in B frames
+    if(s-&gt;pict_type == FF_P_TYPE) {
+        s-&gt;current_picture.motion_val[1][s-&gt;block_index[0]][0] = mx;
+        s-&gt;current_picture.motion_val[1][s-&gt;block_index[0]][1] = my;
+    }
+    uvmx = (mx + ((mx &amp; 3) == 3)) &gt;&gt; 1;
+    uvmy = (my + ((my &amp; 3) == 3)) &gt;&gt; 1;
+    if(v-&gt;fastuvmc) {
+        uvmx = uvmx + ((uvmx&lt;0)?(uvmx&amp;1):-(uvmx&amp;1));
+        uvmy = uvmy + ((uvmy&lt;0)?(uvmy&amp;1):-(uvmy&amp;1));
+    }
+    if(!dir) {
+        srcY = s-&gt;last_picture.data[0];
+        srcU = s-&gt;last_picture.data[1];
+        srcV = s-&gt;last_picture.data[2];
+    } else {
+        srcY = s-&gt;next_picture.data[0];
+        srcU = s-&gt;next_picture.data[1];
+        srcV = s-&gt;next_picture.data[2];
+    }
+
+    src_x = s-&gt;mb_x * 16 + (mx &gt;&gt; 2);
+    src_y = s-&gt;mb_y * 16 + (my &gt;&gt; 2);
+    uvsrc_x = s-&gt;mb_x * 8 + (uvmx &gt;&gt; 2);
+    uvsrc_y = s-&gt;mb_y * 8 + (uvmy &gt;&gt; 2);
+
+    if(v-&gt;profile != PROFILE_ADVANCED){
+        src_x   = av_clip(  src_x, -16, s-&gt;mb_width  * 16);
+        src_y   = av_clip(  src_y, -16, s-&gt;mb_height * 16);
+        uvsrc_x = av_clip(uvsrc_x,  -8, s-&gt;mb_width  *  8);
+        uvsrc_y = av_clip(uvsrc_y,  -8, s-&gt;mb_height *  8);
+    }else{
+        src_x   = av_clip(  src_x, -17, s-&gt;avctx-&gt;coded_width);
+        src_y   = av_clip(  src_y, -18, s-&gt;avctx-&gt;coded_height + 1);
+        uvsrc_x = av_clip(uvsrc_x,  -8, s-&gt;avctx-&gt;coded_width  &gt;&gt; 1);
+        uvsrc_y = av_clip(uvsrc_y,  -8, s-&gt;avctx-&gt;coded_height &gt;&gt; 1);
+    }
+
+    srcY += src_y * s-&gt;linesize + src_x;
+    srcU += uvsrc_y * s-&gt;uvlinesize + uvsrc_x;
+    srcV += uvsrc_y * s-&gt;uvlinesize + uvsrc_x;
+
+    /* for grayscale we should not try to read from unknown area */
+    if(s-&gt;flags &amp; CODEC_FLAG_GRAY) {
+        srcU = s-&gt;edge_emu_buffer + 18 * s-&gt;linesize;
+        srcV = s-&gt;edge_emu_buffer + 18 * s-&gt;linesize;
+    }
+
+    if(v-&gt;rangeredfrm || (v-&gt;mv_mode == MV_PMODE_INTENSITY_COMP)
+       || (unsigned)(src_x - s-&gt;mspel) &gt; s-&gt;h_edge_pos - (mx&amp;3) - 16 - s-&gt;mspel*3
+       || (unsigned)(src_y - s-&gt;mspel) &gt; s-&gt;v_edge_pos - (my&amp;3) - 16 - s-&gt;mspel*3){
+        uint8_t *uvbuf= s-&gt;edge_emu_buffer + 19 * s-&gt;linesize;
+
+        srcY -= s-&gt;mspel * (1 + s-&gt;linesize);
+        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, srcY, s-&gt;linesize, 17+s-&gt;mspel*2, 17+s-&gt;mspel*2,
+                            src_x - s-&gt;mspel, src_y - s-&gt;mspel, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+        srcY = s-&gt;edge_emu_buffer;
+        ff_emulated_edge_mc(uvbuf     , srcU, s-&gt;uvlinesize, 8+1, 8+1,
+                            uvsrc_x, uvsrc_y, s-&gt;h_edge_pos &gt;&gt; 1, s-&gt;v_edge_pos &gt;&gt; 1);
+        ff_emulated_edge_mc(uvbuf + 16, srcV, s-&gt;uvlinesize, 8+1, 8+1,
+                            uvsrc_x, uvsrc_y, s-&gt;h_edge_pos &gt;&gt; 1, s-&gt;v_edge_pos &gt;&gt; 1);
+        srcU = uvbuf;
+        srcV = uvbuf + 16;
+        /* if we deal with range reduction we need to scale source blocks */
+        if(v-&gt;rangeredfrm) {
+            int i, j;
+            uint8_t *src, *src2;
+
+            src = srcY;
+            for(j = 0; j &lt; 17 + s-&gt;mspel*2; j++) {
+                for(i = 0; i &lt; 17 + s-&gt;mspel*2; i++) src[i] = ((src[i] - 128) &gt;&gt; 1) + 128;
+                src += s-&gt;linesize;
+            }
+            src = srcU; src2 = srcV;
+            for(j = 0; j &lt; 9; j++) {
+                for(i = 0; i &lt; 9; i++) {
+                    src[i] = ((src[i] - 128) &gt;&gt; 1) + 128;
+                    src2[i] = ((src2[i] - 128) &gt;&gt; 1) + 128;
+                }
+                src += s-&gt;uvlinesize;
+                src2 += s-&gt;uvlinesize;
+            }
+        }
+        /* if we deal with intensity compensation we need to scale source blocks */
+        if(v-&gt;mv_mode == MV_PMODE_INTENSITY_COMP) {
+            int i, j;
+            uint8_t *src, *src2;
+
+            src = srcY;
+            for(j = 0; j &lt; 17 + s-&gt;mspel*2; j++) {
+                for(i = 0; i &lt; 17 + s-&gt;mspel*2; i++) src[i] = v-&gt;luty[src[i]];
+                src += s-&gt;linesize;
+            }
+            src = srcU; src2 = srcV;
+            for(j = 0; j &lt; 9; j++) {
+                for(i = 0; i &lt; 9; i++) {
+                    src[i] = v-&gt;lutuv[src[i]];
+                    src2[i] = v-&gt;lutuv[src2[i]];
+                }
+                src += s-&gt;uvlinesize;
+                src2 += s-&gt;uvlinesize;
+            }
+        }
+        srcY += s-&gt;mspel * (1 + s-&gt;linesize);
+    }
+
+    if(s-&gt;mspel) {
+        dxy = ((my &amp; 3) &lt;&lt; 2) | (mx &amp; 3);
+        dsp-&gt;put_vc1_mspel_pixels_tab[dxy](s-&gt;dest[0]    , srcY    , s-&gt;linesize, v-&gt;rnd);
+        dsp-&gt;put_vc1_mspel_pixels_tab[dxy](s-&gt;dest[0] + 8, srcY + 8, s-&gt;linesize, v-&gt;rnd);
+        srcY += s-&gt;linesize * 8;
+        dsp-&gt;put_vc1_mspel_pixels_tab[dxy](s-&gt;dest[0] + 8 * s-&gt;linesize    , srcY    , s-&gt;linesize, v-&gt;rnd);
+        dsp-&gt;put_vc1_mspel_pixels_tab[dxy](s-&gt;dest[0] + 8 * s-&gt;linesize + 8, srcY + 8, s-&gt;linesize, v-&gt;rnd);
+    } else { // hpel mc - always used for luma
+        dxy = (my &amp; 2) | ((mx &amp; 2) &gt;&gt; 1);
+
+        if(!v-&gt;rnd)
+            dsp-&gt;put_pixels_tab[0][dxy](s-&gt;dest[0], srcY, s-&gt;linesize, 16);
+        else
+            dsp-&gt;put_no_rnd_pixels_tab[0][dxy](s-&gt;dest[0], srcY, s-&gt;linesize, 16);
+    }
+
+    if(s-&gt;flags &amp; CODEC_FLAG_GRAY) return;
+    /* Chroma MC always uses qpel bilinear */
+    uvdxy = ((uvmy &amp; 3) &lt;&lt; 2) | (uvmx &amp; 3);
+    uvmx = (uvmx&amp;3)&lt;&lt;1;
+    uvmy = (uvmy&amp;3)&lt;&lt;1;
+    if(!v-&gt;rnd){
+        dsp-&gt;put_h264_chroma_pixels_tab[0](s-&gt;dest[1], srcU, s-&gt;uvlinesize, 8, uvmx, uvmy);
+        dsp-&gt;put_h264_chroma_pixels_tab[0](s-&gt;dest[2], srcV, s-&gt;uvlinesize, 8, uvmx, uvmy);
+    }else{
+        dsp-&gt;put_no_rnd_h264_chroma_pixels_tab[0](s-&gt;dest[1], srcU, s-&gt;uvlinesize, 8, uvmx, uvmy);
+        dsp-&gt;put_no_rnd_h264_chroma_pixels_tab[0](s-&gt;dest[2], srcV, s-&gt;uvlinesize, 8, uvmx, uvmy);
+    }
+}
+
+/** Do motion compensation for 4-MV macroblock - luminance block
+ */
+static void vc1_mc_4mv_luma(VC1Context *v, int n)
+{
+    MpegEncContext *s = &amp;v-&gt;s;
+    DSPContext *dsp = &amp;v-&gt;s.dsp;
+    uint8_t *srcY;
+    int dxy, mx, my, src_x, src_y;
+    int off;
+
+    if(!v-&gt;s.last_picture.data[0])return;
+    mx = s-&gt;mv[0][n][0];
+    my = s-&gt;mv[0][n][1];
+    srcY = s-&gt;last_picture.data[0];
+
+    off = s-&gt;linesize * 4 * (n&amp;2) + (n&amp;1) * 8;
+
+    src_x = s-&gt;mb_x * 16 + (n&amp;1) * 8 + (mx &gt;&gt; 2);
+    src_y = s-&gt;mb_y * 16 + (n&amp;2) * 4 + (my &gt;&gt; 2);
+
+    if(v-&gt;profile != PROFILE_ADVANCED){
+        src_x   = av_clip(  src_x, -16, s-&gt;mb_width  * 16);
+        src_y   = av_clip(  src_y, -16, s-&gt;mb_height * 16);
+    }else{
+        src_x   = av_clip(  src_x, -17, s-&gt;avctx-&gt;coded_width);
+        src_y   = av_clip(  src_y, -18, s-&gt;avctx-&gt;coded_height + 1);
+    }
+
+    srcY += src_y * s-&gt;linesize + src_x;
+
+    if(v-&gt;rangeredfrm || (v-&gt;mv_mode == MV_PMODE_INTENSITY_COMP)
+       || (unsigned)(src_x - s-&gt;mspel) &gt; s-&gt;h_edge_pos - (mx&amp;3) - 8 - s-&gt;mspel*2
+       || (unsigned)(src_y - s-&gt;mspel) &gt; s-&gt;v_edge_pos - (my&amp;3) - 8 - s-&gt;mspel*2){
+        srcY -= s-&gt;mspel * (1 + s-&gt;linesize);
+        ff_emulated_edge_mc(s-&gt;edge_emu_buffer, srcY, s-&gt;linesize, 9+s-&gt;mspel*2, 9+s-&gt;mspel*2,
+                            src_x - s-&gt;mspel, src_y - s-&gt;mspel, s-&gt;h_edge_pos, s-&gt;v_edge_pos);
+        srcY = s-&gt;edge_emu_buffer;
+        /* if we deal with range reduction we need to scale source blocks */
+        if(v-&gt;rangeredfrm) {
+            int i, j;
+            uint8_t *src;
+
+            src = srcY;
+            for(j = 0; j &lt; 9 + s-&gt;mspel*2; j++) {
+                for(i = 0; i &lt; 9 + s-&gt;mspel*2; i++) src[i] = ((src[i] - 128) &gt;&gt; 1) + 128;
+                src += s-&gt;linesize;
+            }
+        }
+        /* if we deal with intensity compensation we need to scale source blocks */
+        if(v-&gt;mv_mode == MV_PMODE_INTENSITY_COMP) {
+            int i, j;
+            uint8_t *src;
+
+            src = srcY;
+            for(j = 0; j &lt; 9 + s-&gt;mspel*2; j++) {
+                for(i = 0; i &lt; 9 + s-&gt;mspel*2; i++) src[i] = v-&gt;luty[src[i]];
+                src += s-&gt;linesize;
+            }
+        }
+        srcY += s-&gt;mspel * (1 + s-&gt;linesize);
+    }
+
+    if(s-&gt;mspel) {
+        dxy = ((my &amp; 3) &lt;&lt; 2) | (mx &amp; 3);
+        dsp-&gt;put_vc1_mspel_pixels_tab[dxy](s-&gt;dest[0] + off, srcY, s-&gt;linesize, v-&gt;rnd);
+    } else { // hpel mc - always used for luma
+        dxy = (my &amp; 2) | ((mx &amp; 2) &gt;&gt; 1);
+        if(!v-&gt;rnd)
+            dsp-&gt;put_pixels_tab[1][dxy](s-&gt;dest[0] + off, srcY, s-&gt;linesize, 8);
+        else
+            dsp-&gt;put_no_rnd_pixels_tab[1][dxy](s-&gt;dest[0] + off, srcY, s-&gt;linesize, 8);
+    }
+}
+
+static inline int median4(int a, int b, int c, int d)
+{
+    if(a &lt; b) {
+        if(c &lt; d) return (FFMIN(b, d) + FFMAX(a, c)) / 2;
+        else      return (FFMIN(b, c) + FFMAX(a, d)) / 2;
+    } else {
+        if(c &lt; d) return (FFMIN(a, d) + FFMAX(b, c)) / 2;
+        else      return (FFMIN(a, c) + FFMAX(b, d)) / 2;
+    }
+}
+
+
+/** Do motion compensation for 4-MV macroblock - both chroma blocks
+ */
+static void vc1_mc_4mv_chroma(VC1Context *v)
+{
+    MpegEncContext *s = &amp;v-&gt;s;
+    DSPContext *dsp = &amp;v-&gt;s.dsp;
+    uint8_t *srcU, *srcV;
+    int uvdxy, uvmx, uvmy, uvsrc_x, uvsrc_y;
+    int i, idx, tx = 0, ty = 0;
+    int mvx[4], mvy[4], intra[4];

[... truncated: 20431 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011867.html">[Haiku-commits] r27557 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011869.html">[Haiku-commits] r27559 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11868">[ date ]</a>
              <a href="thread.html#11868">[ thread ]</a>
              <a href="subject.html#11868">[ subject ]</a>
              <a href="author.html#11868">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
