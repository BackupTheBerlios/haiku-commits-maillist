<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27545 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27545%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151402.m8FE2vrQ000057%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="011854.html">
   <LINK REL="Next"  HREF="011856.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27545 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27545%20-%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec&In-Reply-To=%3C200809151402.m8FE2vrQ000057%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27545 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Sep 15 16:02:57 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="011854.html">[Haiku-commits] r27544 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
        <LI>Next message: <A HREF="011856.html">[Haiku-commits] r27546 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11855">[ date ]</a>
              <a href="thread.html#11855">[ thread ]</a>
              <a href="subject.html#11855">[ subject ]</a>
              <a href="author.html#11855">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-09-15 16:02:50 +0200 (Mon, 15 Sep 2008)
New Revision: 27545
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27545&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27545&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dcadata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dcahuff.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dct-test.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dirac_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dnxhddata.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dnxhddata.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dnxhddec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dnxhdenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dsicinav.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dump_extradata_bsf.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvbsub.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvbsub_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvbsubdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvdsub_parser.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvdsubdec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvdsubenc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dxa.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dpcm.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dsputil.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dsputil.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dv.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dvdata.h
Log:
Update avcodec to 20080825 (sorry for the spam, needed to break this up)

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca.c	2008-09-15 14:02:19 UTC (rev 27544)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/dca.c	2008-09-15 14:02:50 UTC (rev 27545)
@@ -0,0 +1,1269 @@
+/*
+ * DCA compatible decoder
+ * Copyright (C) 2004 Gildas Bazin
+ * Copyright (C) 2004 Benjamin Zores
+ * Copyright (C) 2006 Benjamin Larsson
+ * Copyright (C) 2007 Konstantin Shishkov
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file dca.c
+ */
+
+#include &lt;math.h&gt;
+#include &lt;stddef.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;avcodec.h&quot;
+#include &quot;dsputil.h&quot;
+#include &quot;bitstream.h&quot;
+#include &quot;dcadata.h&quot;
+#include &quot;dcahuff.h&quot;
+#include &quot;dca.h&quot;
+
+//#define TRACE
+
+#define DCA_PRIM_CHANNELS_MAX (5)
+#define DCA_SUBBANDS (32)
+#define DCA_ABITS_MAX (32)      /* Should be 28 */
+#define DCA_SUBSUBFAMES_MAX (4)
+#define DCA_LFE_MAX (3)
+
+enum DCAMode {
+    DCA_MONO = 0,
+    DCA_CHANNEL,
+    DCA_STEREO,
+    DCA_STEREO_SUMDIFF,
+    DCA_STEREO_TOTAL,
+    DCA_3F,
+    DCA_2F1R,
+    DCA_3F1R,
+    DCA_2F2R,
+    DCA_3F2R,
+    DCA_4F2R
+};
+
+#define DCA_DOLBY 101           /* FIXME */
+
+#define DCA_CHANNEL_BITS 6
+#define DCA_CHANNEL_MASK 0x3F
+
+#define DCA_LFE 0x80
+
+#define HEADER_SIZE 14
+#define CONVERT_BIAS 384
+
+#define DCA_MAX_FRAME_SIZE 16384
+
+/** Bit allocation */
+typedef struct {
+    int offset;                 ///&lt; code values offset
+    int maxbits[8];             ///&lt; max bits in VLC
+    int wrap;                   ///&lt; wrap for get_vlc2()
+    VLC vlc[8];                 ///&lt; actual codes
+} BitAlloc;
+
+static BitAlloc dca_bitalloc_index;    ///&lt; indexes for samples VLC select
+static BitAlloc dca_tmode;             ///&lt; transition mode VLCs
+static BitAlloc dca_scalefactor;       ///&lt; scalefactor VLCs
+static BitAlloc dca_smpl_bitalloc[11]; ///&lt; samples VLCs
+
+/** Pre-calculated cosine modulation coefs for the QMF */
+static float cos_mod[544];
+
+static av_always_inline int get_bitalloc(GetBitContext *gb, BitAlloc *ba, int idx)
+{
+    return get_vlc2(gb, ba-&gt;vlc[idx].table, ba-&gt;vlc[idx].bits, ba-&gt;wrap) + ba-&gt;offset;
+}
+
+typedef struct {
+    AVCodecContext *avctx;
+    /* Frame header */
+    int frame_type;             ///&lt; type of the current frame
+    int samples_deficit;        ///&lt; deficit sample count
+    int crc_present;            ///&lt; crc is present in the bitstream
+    int sample_blocks;          ///&lt; number of PCM sample blocks
+    int frame_size;             ///&lt; primary frame byte size
+    int amode;                  ///&lt; audio channels arrangement
+    int sample_rate;            ///&lt; audio sampling rate
+    int bit_rate;               ///&lt; transmission bit rate
+
+    int downmix;                ///&lt; embedded downmix enabled
+    int dynrange;               ///&lt; embedded dynamic range flag
+    int timestamp;              ///&lt; embedded time stamp flag
+    int aux_data;               ///&lt; auxiliary data flag
+    int hdcd;                   ///&lt; source material is mastered in HDCD
+    int ext_descr;              ///&lt; extension audio descriptor flag
+    int ext_coding;             ///&lt; extended coding flag
+    int aspf;                   ///&lt; audio sync word insertion flag
+    int lfe;                    ///&lt; low frequency effects flag
+    int predictor_history;      ///&lt; predictor history flag
+    int header_crc;             ///&lt; header crc check bytes
+    int multirate_inter;        ///&lt; multirate interpolator switch
+    int version;                ///&lt; encoder software revision
+    int copy_history;           ///&lt; copy history
+    int source_pcm_res;         ///&lt; source pcm resolution
+    int front_sum;              ///&lt; front sum/difference flag
+    int surround_sum;           ///&lt; surround sum/difference flag
+    int dialog_norm;            ///&lt; dialog normalisation parameter
+
+    /* Primary audio coding header */
+    int subframes;              ///&lt; number of subframes
+    int total_channels;         ///&lt; number of channels including extensions
+    int prim_channels;          ///&lt; number of primary audio channels
+    int subband_activity[DCA_PRIM_CHANNELS_MAX];    ///&lt; subband activity count
+    int vq_start_subband[DCA_PRIM_CHANNELS_MAX];    ///&lt; high frequency vq start subband
+    int joint_intensity[DCA_PRIM_CHANNELS_MAX];     ///&lt; joint intensity coding index
+    int transient_huffman[DCA_PRIM_CHANNELS_MAX];   ///&lt; transient mode code book
+    int scalefactor_huffman[DCA_PRIM_CHANNELS_MAX]; ///&lt; scale factor code book
+    int bitalloc_huffman[DCA_PRIM_CHANNELS_MAX];    ///&lt; bit allocation quantizer select
+    int quant_index_huffman[DCA_PRIM_CHANNELS_MAX][DCA_ABITS_MAX]; ///&lt; quantization index codebook select
+    float scalefactor_adj[DCA_PRIM_CHANNELS_MAX][DCA_ABITS_MAX];   ///&lt; scale factor adjustment
+
+    /* Primary audio coding side information */
+    int subsubframes;           ///&lt; number of subsubframes
+    int partial_samples;        ///&lt; partial subsubframe samples count
+    int prediction_mode[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS];    ///&lt; prediction mode (ADPCM used or not)
+    int prediction_vq[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS];      ///&lt; prediction VQ coefs
+    int bitalloc[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS];           ///&lt; bit allocation index
+    int transition_mode[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS];    ///&lt; transition mode (transients)
+    int scale_factor[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS][2];    ///&lt; scale factors (2 if transient)
+    int joint_huff[DCA_PRIM_CHANNELS_MAX];                       ///&lt; joint subband scale factors codebook
+    int joint_scale_factor[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS]; ///&lt; joint subband scale factors
+    int downmix_coef[DCA_PRIM_CHANNELS_MAX][2];                  ///&lt; stereo downmix coefficients
+    int dynrange_coef;                                           ///&lt; dynamic range coefficient
+
+    int high_freq_vq[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS];       ///&lt; VQ encoded high frequency subbands
+
+    float lfe_data[2 * DCA_SUBSUBFAMES_MAX * DCA_LFE_MAX *
+                   2 /*history */ ];    ///&lt; Low frequency effect data
+    int lfe_scale_factor;
+
+    /* Subband samples history (for ADPCM) */
+    float subband_samples_hist[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS][4];
+    float subband_fir_hist[DCA_PRIM_CHANNELS_MAX][512];
+    float subband_fir_noidea[DCA_PRIM_CHANNELS_MAX][64];
+
+    int output;                 ///&lt; type of output
+    int bias;                   ///&lt; output bias
+
+    DECLARE_ALIGNED_16(float, samples[1536]);  /* 6 * 256 = 1536, might only need 5 */
+    DECLARE_ALIGNED_16(int16_t, tsamples[1536]);
+
+    uint8_t dca_buffer[DCA_MAX_FRAME_SIZE];
+    int dca_buffer_size;        ///&lt; how much data is in the dca_buffer
+
+    GetBitContext gb;
+    /* Current position in DCA frame */
+    int current_subframe;
+    int current_subsubframe;
+
+    int debug_flag;             ///&lt; used for suppressing repeated error messages output
+    DSPContext dsp;
+} DCAContext;
+
+static av_cold void dca_init_vlcs(void)
+{
+    static int vlcs_initialized = 0;
+    int i, j;
+
+    if (vlcs_initialized)
+        return;
+
+    dca_bitalloc_index.offset = 1;
+    dca_bitalloc_index.wrap = 2;
+    for (i = 0; i &lt; 5; i++)
+        init_vlc(&amp;dca_bitalloc_index.vlc[i], bitalloc_12_vlc_bits[i], 12,
+                 bitalloc_12_bits[i], 1, 1,
+                 bitalloc_12_codes[i], 2, 2, 1);
+    dca_scalefactor.offset = -64;
+    dca_scalefactor.wrap = 2;
+    for (i = 0; i &lt; 5; i++)
+        init_vlc(&amp;dca_scalefactor.vlc[i], SCALES_VLC_BITS, 129,
+                 scales_bits[i], 1, 1,
+                 scales_codes[i], 2, 2, 1);
+    dca_tmode.offset = 0;
+    dca_tmode.wrap = 1;
+    for (i = 0; i &lt; 4; i++)
+        init_vlc(&amp;dca_tmode.vlc[i], tmode_vlc_bits[i], 4,
+                 tmode_bits[i], 1, 1,
+                 tmode_codes[i], 2, 2, 1);
+
+    for(i = 0; i &lt; 10; i++)
+        for(j = 0; j &lt; 7; j++){
+            if(!bitalloc_codes[i][j]) break;
+            dca_smpl_bitalloc[i+1].offset = bitalloc_offsets[i];
+            dca_smpl_bitalloc[i+1].wrap = 1 + (j &gt; 4);
+            init_vlc(&amp;dca_smpl_bitalloc[i+1].vlc[j], bitalloc_maxbits[i][j],
+                     bitalloc_sizes[i],
+                     bitalloc_bits[i][j], 1, 1,
+                     bitalloc_codes[i][j], 2, 2, 1);
+        }
+    vlcs_initialized = 1;
+}
+
+static inline void get_array(GetBitContext *gb, int *dst, int len, int bits)
+{
+    while(len--)
+        *dst++ = get_bits(gb, bits);
+}
+
+static int dca_parse_frame_header(DCAContext * s)
+{
+    int i, j;
+    static const float adj_table[4] = { 1.0, 1.1250, 1.2500, 1.4375 };
+    static const int bitlen[11] = { 0, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3 };
+    static const int thr[11] = { 0, 1, 3, 3, 3, 3, 7, 7, 7, 7, 7 };
+
+    s-&gt;bias = CONVERT_BIAS;
+
+    init_get_bits(&amp;s-&gt;gb, s-&gt;dca_buffer, s-&gt;dca_buffer_size * 8);
+
+    /* Sync code */
+    get_bits(&amp;s-&gt;gb, 32);
+
+    /* Frame header */
+    s-&gt;frame_type        = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;samples_deficit   = get_bits(&amp;s-&gt;gb, 5) + 1;
+    s-&gt;crc_present       = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;sample_blocks     = get_bits(&amp;s-&gt;gb, 7) + 1;
+    s-&gt;frame_size        = get_bits(&amp;s-&gt;gb, 14) + 1;
+    if (s-&gt;frame_size &lt; 95)
+        return -1;
+    s-&gt;amode             = get_bits(&amp;s-&gt;gb, 6);
+    s-&gt;sample_rate       = dca_sample_rates[get_bits(&amp;s-&gt;gb, 4)];
+    if (!s-&gt;sample_rate)
+        return -1;
+    s-&gt;bit_rate          = dca_bit_rates[get_bits(&amp;s-&gt;gb, 5)];
+    if (!s-&gt;bit_rate)
+        return -1;
+
+    s-&gt;downmix           = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;dynrange          = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;timestamp         = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;aux_data          = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;hdcd              = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;ext_descr         = get_bits(&amp;s-&gt;gb, 3);
+    s-&gt;ext_coding        = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;aspf              = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;lfe               = get_bits(&amp;s-&gt;gb, 2);
+    s-&gt;predictor_history = get_bits(&amp;s-&gt;gb, 1);
+
+    /* TODO: check CRC */
+    if (s-&gt;crc_present)
+        s-&gt;header_crc    = get_bits(&amp;s-&gt;gb, 16);
+
+    s-&gt;multirate_inter   = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;version           = get_bits(&amp;s-&gt;gb, 4);
+    s-&gt;copy_history      = get_bits(&amp;s-&gt;gb, 2);
+    s-&gt;source_pcm_res    = get_bits(&amp;s-&gt;gb, 3);
+    s-&gt;front_sum         = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;surround_sum      = get_bits(&amp;s-&gt;gb, 1);
+    s-&gt;dialog_norm       = get_bits(&amp;s-&gt;gb, 4);
+
+    /* FIXME: channels mixing levels */
+    s-&gt;output = s-&gt;amode;
+    if(s-&gt;lfe) s-&gt;output |= DCA_LFE;
+
+#ifdef TRACE
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;frame type: %i\n&quot;, s-&gt;frame_type);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;samples deficit: %i\n&quot;, s-&gt;samples_deficit);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;crc present: %i\n&quot;, s-&gt;crc_present);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;sample blocks: %i (%i samples)\n&quot;,
+           s-&gt;sample_blocks, s-&gt;sample_blocks * 32);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;frame size: %i bytes\n&quot;, s-&gt;frame_size);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;amode: %i (%i channels)\n&quot;,
+           s-&gt;amode, dca_channels[s-&gt;amode]);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;sample rate: %i (%i Hz)\n&quot;,
+           s-&gt;sample_rate, dca_sample_rates[s-&gt;sample_rate]);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;bit rate: %i (%i bits/s)\n&quot;,
+           s-&gt;bit_rate, dca_bit_rates[s-&gt;bit_rate]);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;downmix: %i\n&quot;, s-&gt;downmix);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;dynrange: %i\n&quot;, s-&gt;dynrange);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;timestamp: %i\n&quot;, s-&gt;timestamp);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;aux_data: %i\n&quot;, s-&gt;aux_data);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;hdcd: %i\n&quot;, s-&gt;hdcd);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;ext descr: %i\n&quot;, s-&gt;ext_descr);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;ext coding: %i\n&quot;, s-&gt;ext_coding);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;aspf: %i\n&quot;, s-&gt;aspf);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;lfe: %i\n&quot;, s-&gt;lfe);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;predictor history: %i\n&quot;,
+           s-&gt;predictor_history);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;header crc: %i\n&quot;, s-&gt;header_crc);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;multirate inter: %i\n&quot;,
+           s-&gt;multirate_inter);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;version number: %i\n&quot;, s-&gt;version);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;copy history: %i\n&quot;, s-&gt;copy_history);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG,
+           &quot;source pcm resolution: %i (%i bits/sample)\n&quot;,
+           s-&gt;source_pcm_res, dca_bits_per_sample[s-&gt;source_pcm_res]);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;front sum: %i\n&quot;, s-&gt;front_sum);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;surround sum: %i\n&quot;, s-&gt;surround_sum);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;dialog norm: %i\n&quot;, s-&gt;dialog_norm);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+#endif
+
+    /* Primary audio coding header */
+    s-&gt;subframes         = get_bits(&amp;s-&gt;gb, 4) + 1;
+    s-&gt;total_channels    = get_bits(&amp;s-&gt;gb, 3) + 1;
+    s-&gt;prim_channels     = s-&gt;total_channels;
+    if (s-&gt;prim_channels &gt; DCA_PRIM_CHANNELS_MAX)
+        s-&gt;prim_channels = DCA_PRIM_CHANNELS_MAX;   /* We only support DTS core */
+
+
+    for (i = 0; i &lt; s-&gt;prim_channels; i++) {
+        s-&gt;subband_activity[i] = get_bits(&amp;s-&gt;gb, 5) + 2;
+        if (s-&gt;subband_activity[i] &gt; DCA_SUBBANDS)
+            s-&gt;subband_activity[i] = DCA_SUBBANDS;
+    }
+    for (i = 0; i &lt; s-&gt;prim_channels; i++) {
+        s-&gt;vq_start_subband[i] = get_bits(&amp;s-&gt;gb, 5) + 1;
+        if (s-&gt;vq_start_subband[i] &gt; DCA_SUBBANDS)
+            s-&gt;vq_start_subband[i] = DCA_SUBBANDS;
+    }
+    get_array(&amp;s-&gt;gb, s-&gt;joint_intensity,     s-&gt;prim_channels, 3);
+    get_array(&amp;s-&gt;gb, s-&gt;transient_huffman,   s-&gt;prim_channels, 2);
+    get_array(&amp;s-&gt;gb, s-&gt;scalefactor_huffman, s-&gt;prim_channels, 3);
+    get_array(&amp;s-&gt;gb, s-&gt;bitalloc_huffman,    s-&gt;prim_channels, 3);
+
+    /* Get codebooks quantization indexes */
+    memset(s-&gt;quant_index_huffman, 0, sizeof(s-&gt;quant_index_huffman));
+    for (j = 1; j &lt; 11; j++)
+        for (i = 0; i &lt; s-&gt;prim_channels; i++)
+            s-&gt;quant_index_huffman[i][j] = get_bits(&amp;s-&gt;gb, bitlen[j]);
+
+    /* Get scale factor adjustment */
+    for (j = 0; j &lt; 11; j++)
+        for (i = 0; i &lt; s-&gt;prim_channels; i++)
+            s-&gt;scalefactor_adj[i][j] = 1;
+
+    for (j = 1; j &lt; 11; j++)
+        for (i = 0; i &lt; s-&gt;prim_channels; i++)
+            if (s-&gt;quant_index_huffman[i][j] &lt; thr[j])
+                s-&gt;scalefactor_adj[i][j] = adj_table[get_bits(&amp;s-&gt;gb, 2)];
+
+    if (s-&gt;crc_present) {
+        /* Audio header CRC check */
+        get_bits(&amp;s-&gt;gb, 16);
+    }
+
+    s-&gt;current_subframe = 0;
+    s-&gt;current_subsubframe = 0;
+
+#ifdef TRACE
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;subframes: %i\n&quot;, s-&gt;subframes);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;prim channels: %i\n&quot;, s-&gt;prim_channels);
+    for(i = 0; i &lt; s-&gt;prim_channels; i++){
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;subband activity: %i\n&quot;, s-&gt;subband_activity[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;vq start subband: %i\n&quot;, s-&gt;vq_start_subband[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;joint intensity: %i\n&quot;, s-&gt;joint_intensity[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;transient mode codebook: %i\n&quot;, s-&gt;transient_huffman[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;scale factor codebook: %i\n&quot;, s-&gt;scalefactor_huffman[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;bit allocation quantizer: %i\n&quot;, s-&gt;bitalloc_huffman[i]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;quant index huff:&quot;);
+        for (j = 0; j &lt; 11; j++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i&quot;,
+                   s-&gt;quant_index_huffman[i][j]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;scalefac adj:&quot;);
+        for (j = 0; j &lt; 11; j++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %1.3f&quot;, s-&gt;scalefactor_adj[i][j]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+#endif
+
+    return 0;
+}
+
+
+static inline int get_scale(GetBitContext *gb, int level, int value)
+{
+   if (level &lt; 5) {
+       /* huffman encoded */
+       value += get_bitalloc(gb, &amp;dca_scalefactor, level);
+   } else if(level &lt; 8)
+       value = get_bits(gb, level + 1);
+   return value;
+}
+
+static int dca_subframe_header(DCAContext * s)
+{
+    /* Primary audio coding side information */
+    int j, k;
+
+    s-&gt;subsubframes = get_bits(&amp;s-&gt;gb, 2) + 1;
+    s-&gt;partial_samples = get_bits(&amp;s-&gt;gb, 3);
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++)
+            s-&gt;prediction_mode[j][k] = get_bits(&amp;s-&gt;gb, 1);
+    }
+
+    /* Get prediction codebook */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++) {
+            if (s-&gt;prediction_mode[j][k] &gt; 0) {
+                /* (Prediction coefficient VQ address) */
+                s-&gt;prediction_vq[j][k] = get_bits(&amp;s-&gt;gb, 12);
+            }
+        }
+    }
+
+    /* Bit allocation index */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        for (k = 0; k &lt; s-&gt;vq_start_subband[j]; k++) {
+            if (s-&gt;bitalloc_huffman[j] == 6)
+                s-&gt;bitalloc[j][k] = get_bits(&amp;s-&gt;gb, 5);
+            else if (s-&gt;bitalloc_huffman[j] == 5)
+                s-&gt;bitalloc[j][k] = get_bits(&amp;s-&gt;gb, 4);
+            else if (s-&gt;bitalloc_huffman[j] == 7) {
+                av_log(s-&gt;avctx, AV_LOG_ERROR,
+                       &quot;Invalid bit allocation index\n&quot;);
+                return -1;
+            } else {
+                s-&gt;bitalloc[j][k] =
+                    get_bitalloc(&amp;s-&gt;gb, &amp;dca_bitalloc_index, s-&gt;bitalloc_huffman[j]);
+            }
+
+            if (s-&gt;bitalloc[j][k] &gt; 26) {
+//                 av_log(s-&gt;avctx,AV_LOG_DEBUG,&quot;bitalloc index [%i][%i] too big (%i)\n&quot;,
+//                          j, k, s-&gt;bitalloc[j][k]);
+                return -1;
+            }
+        }
+    }
+
+    /* Transition mode */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++) {
+            s-&gt;transition_mode[j][k] = 0;
+            if (s-&gt;subsubframes &gt; 1 &amp;&amp;
+                k &lt; s-&gt;vq_start_subband[j] &amp;&amp; s-&gt;bitalloc[j][k] &gt; 0) {
+                s-&gt;transition_mode[j][k] =
+                    get_bitalloc(&amp;s-&gt;gb, &amp;dca_tmode, s-&gt;transient_huffman[j]);
+            }
+        }
+    }
+
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        const uint32_t *scale_table;
+        int scale_sum;
+
+        memset(s-&gt;scale_factor[j], 0, s-&gt;subband_activity[j] * sizeof(s-&gt;scale_factor[0][0][0]) * 2);
+
+        if (s-&gt;scalefactor_huffman[j] == 6)
+            scale_table = scale_factor_quant7;
+        else
+            scale_table = scale_factor_quant6;
+
+        /* When huffman coded, only the difference is encoded */
+        scale_sum = 0;
+
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++) {
+            if (k &gt;= s-&gt;vq_start_subband[j] || s-&gt;bitalloc[j][k] &gt; 0) {
+                scale_sum = get_scale(&amp;s-&gt;gb, s-&gt;scalefactor_huffman[j], scale_sum);
+                s-&gt;scale_factor[j][k][0] = scale_table[scale_sum];
+            }
+
+            if (k &lt; s-&gt;vq_start_subband[j] &amp;&amp; s-&gt;transition_mode[j][k]) {
+                /* Get second scale factor */
+                scale_sum = get_scale(&amp;s-&gt;gb, s-&gt;scalefactor_huffman[j], scale_sum);
+                s-&gt;scale_factor[j][k][1] = scale_table[scale_sum];
+            }
+        }
+    }
+
+    /* Joint subband scale factor codebook select */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        /* Transmitted only if joint subband coding enabled */
+        if (s-&gt;joint_intensity[j] &gt; 0)
+            s-&gt;joint_huff[j] = get_bits(&amp;s-&gt;gb, 3);
+    }
+
+    /* Scale factors for joint subband coding */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        int source_channel;
+
+        /* Transmitted only if joint subband coding enabled */
+        if (s-&gt;joint_intensity[j] &gt; 0) {
+            int scale = 0;
+            source_channel = s-&gt;joint_intensity[j] - 1;
+
+            /* When huffman coded, only the difference is encoded
+             * (is this valid as well for joint scales ???) */
+
+            for (k = s-&gt;subband_activity[j]; k &lt; s-&gt;subband_activity[source_channel]; k++) {
+                scale = get_scale(&amp;s-&gt;gb, s-&gt;joint_huff[j], 0);
+                scale += 64;    /* bias */
+                s-&gt;joint_scale_factor[j][k] = scale;    /*joint_scale_table[scale]; */
+            }
+
+            if (!s-&gt;debug_flag &amp; 0x02) {
+                av_log(s-&gt;avctx, AV_LOG_DEBUG,
+                       &quot;Joint stereo coding not supported\n&quot;);
+                s-&gt;debug_flag |= 0x02;
+            }
+        }
+    }
+
+    /* Stereo downmix coefficients */
+    if (s-&gt;prim_channels &gt; 2) {
+        if(s-&gt;downmix) {
+            for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+                s-&gt;downmix_coef[j][0] = get_bits(&amp;s-&gt;gb, 7);
+                s-&gt;downmix_coef[j][1] = get_bits(&amp;s-&gt;gb, 7);
+            }
+        } else {
+            int am = s-&gt;amode &amp; DCA_CHANNEL_MASK;
+            for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+                s-&gt;downmix_coef[j][0] = dca_default_coeffs[am][j][0];
+                s-&gt;downmix_coef[j][1] = dca_default_coeffs[am][j][1];
+            }
+        }
+    }
+
+    /* Dynamic range coefficient */
+    if (s-&gt;dynrange)
+        s-&gt;dynrange_coef = get_bits(&amp;s-&gt;gb, 8);
+
+    /* Side information CRC check word */
+    if (s-&gt;crc_present) {
+        get_bits(&amp;s-&gt;gb, 16);
+    }
+
+    /*
+     * Primary audio data arrays
+     */
+
+    /* VQ encoded high frequency subbands */
+    for (j = 0; j &lt; s-&gt;prim_channels; j++)
+        for (k = s-&gt;vq_start_subband[j]; k &lt; s-&gt;subband_activity[j]; k++)
+            /* 1 vector -&gt; 32 samples */
+            s-&gt;high_freq_vq[j][k] = get_bits(&amp;s-&gt;gb, 10);
+
+    /* Low frequency effect data */
+    if (s-&gt;lfe) {
+        /* LFE samples */
+        int lfe_samples = 2 * s-&gt;lfe * s-&gt;subsubframes;
+        float lfe_scale;
+
+        for (j = lfe_samples; j &lt; lfe_samples * 2; j++) {
+            /* Signed 8 bits int */
+            s-&gt;lfe_data[j] = get_sbits(&amp;s-&gt;gb, 8);
+        }
+
+        /* Scale factor index */
+        s-&gt;lfe_scale_factor = scale_factor_quant7[get_bits(&amp;s-&gt;gb, 8)];
+
+        /* Quantization step size * scale factor */
+        lfe_scale = 0.035 * s-&gt;lfe_scale_factor;
+
+        for (j = lfe_samples; j &lt; lfe_samples * 2; j++)
+            s-&gt;lfe_data[j] *= lfe_scale;
+    }
+
+#ifdef TRACE
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;subsubframes: %i\n&quot;, s-&gt;subsubframes);
+    av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;partial samples: %i\n&quot;,
+           s-&gt;partial_samples);
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;prediction mode:&quot;);
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i&quot;, s-&gt;prediction_mode[j][k]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++)
+                av_log(s-&gt;avctx, AV_LOG_DEBUG,
+                       &quot;prediction coefs: %f, %f, %f, %f\n&quot;,
+                       (float) adpcm_vb[s-&gt;prediction_vq[j][k]][0] / 8192,
+                       (float) adpcm_vb[s-&gt;prediction_vq[j][k]][1] / 8192,
+                       (float) adpcm_vb[s-&gt;prediction_vq[j][k]][2] / 8192,
+                       (float) adpcm_vb[s-&gt;prediction_vq[j][k]][3] / 8192);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;bitalloc index: &quot;);
+        for (k = 0; k &lt; s-&gt;vq_start_subband[j]; k++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;%2.2i &quot;, s-&gt;bitalloc[j][k]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Transition mode:&quot;);
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i&quot;, s-&gt;transition_mode[j][k]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Scale factor:&quot;);
+        for (k = 0; k &lt; s-&gt;subband_activity[j]; k++) {
+            if (k &gt;= s-&gt;vq_start_subband[j] || s-&gt;bitalloc[j][k] &gt; 0)
+                av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i&quot;, s-&gt;scale_factor[j][k][0]);
+            if (k &lt; s-&gt;vq_start_subband[j] &amp;&amp; s-&gt;transition_mode[j][k])
+                av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i(t)&quot;, s-&gt;scale_factor[j][k][1]);
+        }
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+        if (s-&gt;joint_intensity[j] &gt; 0) {
+            int source_channel = s-&gt;joint_intensity[j] - 1;
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Joint scale factor index:\n&quot;);
+            for (k = s-&gt;subband_activity[j]; k &lt; s-&gt;subband_activity[source_channel]; k++)
+                av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %i&quot;, s-&gt;joint_scale_factor[j][k]);
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+        }
+    }
+    if (s-&gt;prim_channels &gt; 2 &amp;&amp; s-&gt;downmix) {
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Downmix coeffs:\n&quot;);
+        for (j = 0; j &lt; s-&gt;prim_channels; j++) {
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Channel 0,%d = %f\n&quot;, j, dca_downmix_coeffs[s-&gt;downmix_coef[j][0]]);
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Channel 1,%d = %f\n&quot;, j, dca_downmix_coeffs[s-&gt;downmix_coef[j][1]]);
+        }
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+    for (j = 0; j &lt; s-&gt;prim_channels; j++)
+        for (k = s-&gt;vq_start_subband[j]; k &lt; s-&gt;subband_activity[j]; k++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;VQ index: %i\n&quot;, s-&gt;high_freq_vq[j][k]);
+    if(s-&gt;lfe){
+        int lfe_samples = 2 * s-&gt;lfe * s-&gt;subsubframes;
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;LFE samples:\n&quot;);
+        for (j = lfe_samples; j &lt; lfe_samples * 2; j++)
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot; %f&quot;, s-&gt;lfe_data[j]);
+        av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;\n&quot;);
+    }
+#endif
+
+    return 0;
+}
+
+static void qmf_32_subbands(DCAContext * s, int chans,
+                            float samples_in[32][8], float *samples_out,
+                            float scale, float bias)
+{
+    const float *prCoeff;
+    int i, j, k;
+    float praXin[33], *raXin = &amp;praXin[1];
+
+    float *subband_fir_hist = s-&gt;subband_fir_hist[chans];
+    float *subband_fir_hist2 = s-&gt;subband_fir_noidea[chans];
+
+    int chindex = 0, subindex;
+
+    praXin[0] = 0.0;
+
+    /* Select filter */
+    if (!s-&gt;multirate_inter)    /* Non-perfect reconstruction */
+        prCoeff = fir_32bands_nonperfect;
+    else                        /* Perfect reconstruction */
+        prCoeff = fir_32bands_perfect;
+
+    /* Reconstructed channel sample index */
+    for (subindex = 0; subindex &lt; 8; subindex++) {
+        float t1, t2, sum[16], diff[16];
+
+        /* Load in one sample from each subband and clear inactive subbands */
+        for (i = 0; i &lt; s-&gt;subband_activity[chans]; i++)
+            raXin[i] = samples_in[i][subindex];
+        for (; i &lt; 32; i++)
+            raXin[i] = 0.0;
+
+        /* Multiply by cosine modulation coefficients and
+         * create temporary arrays SUM and DIFF */
+        for (j = 0, k = 0; k &lt; 16; k++) {
+            t1 = 0.0;
+            t2 = 0.0;
+            for (i = 0; i &lt; 16; i++, j++){
+                t1 += (raXin[2 * i] + raXin[2 * i + 1]) * cos_mod[j];
+                t2 += (raXin[2 * i] + raXin[2 * i - 1]) * cos_mod[j + 256];
+            }
+            sum[k] = t1 + t2;
+            diff[k] = t1 - t2;
+        }
+
+        j = 512;
+        /* Store history */
+        for (k = 0; k &lt; 16; k++)
+            subband_fir_hist[k] = cos_mod[j++] * sum[k];
+        for (k = 0; k &lt; 16; k++)
+            subband_fir_hist[32-k-1] = cos_mod[j++] * diff[k];
+
+        /* Multiply by filter coefficients */
+        for (k = 31, i = 0; i &lt; 32; i++, k--)
+            for (j = 0; j &lt; 512; j += 64){
+                subband_fir_hist2[i]    += prCoeff[i+j]  * ( subband_fir_hist[i+j] - subband_fir_hist[j+k]);
+                subband_fir_hist2[i+32] += prCoeff[i+j+32]*(-subband_fir_hist[i+j] - subband_fir_hist[j+k]);
+            }
+
+        /* Create 32 PCM output samples */
+        for (i = 0; i &lt; 32; i++)
+            samples_out[chindex++] = subband_fir_hist2[i] * scale + bias;
+
+        /* Update working arrays */
+        memmove(&amp;subband_fir_hist[32], &amp;subband_fir_hist[0], (512 - 32) * sizeof(float));
+        memmove(&amp;subband_fir_hist2[0], &amp;subband_fir_hist2[32], 32 * sizeof(float));
+        memset(&amp;subband_fir_hist2[32], 0, 32 * sizeof(float));
+    }
+}
+
+static void lfe_interpolation_fir(int decimation_select,
+                                  int num_deci_sample, float *samples_in,
+                                  float *samples_out, float scale,
+                                  float bias)
+{
+    /* samples_in: An array holding decimated samples.
+     *   Samples in current subframe starts from samples_in[0],
+     *   while samples_in[-1], samples_in[-2], ..., stores samples
+     *   from last subframe as history.
+     *
+     * samples_out: An array holding interpolated samples
+     */
+
+    int decifactor, k, j;
+    const float *prCoeff;
+
+    int interp_index = 0;       /* Index to the interpolated samples */
+    int deciindex;
+
+    /* Select decimation filter */
+    if (decimation_select == 1) {
+        decifactor = 128;
+        prCoeff = lfe_fir_128;
+    } else {
+        decifactor = 64;
+        prCoeff = lfe_fir_64;
+    }
+    /* Interpolation */
+    for (deciindex = 0; deciindex &lt; num_deci_sample; deciindex++) {
+        /* One decimated sample generates decifactor interpolated ones */
+        for (k = 0; k &lt; decifactor; k++) {
+            float rTmp = 0.0;
+            //FIXME the coeffs are symetric, fix that
+            for (j = 0; j &lt; 512 / decifactor; j++)
+                rTmp += samples_in[deciindex - j] * prCoeff[k + j * decifactor];
+            samples_out[interp_index++] = rTmp / scale + bias;
+        }
+    }
+}
+
+/* downmixing routines */
+#define MIX_REAR1(samples, si1, rs, coef) \
+     samples[i]     += samples[si1] * coef[rs][0]; \
+     samples[i+256] += samples[si1] * coef[rs][1];
+
+#define MIX_REAR2(samples, si1, si2, rs, coef) \
+     samples[i]     += samples[si1] * coef[rs][0] + samples[si2] * coef[rs+1][0]; \
+     samples[i+256] += samples[si1] * coef[rs][1] + samples[si2] * coef[rs+1][1];
+
+#define MIX_FRONT3(samples, coef) \
+    t = samples[i]; \
+    samples[i]     = t * coef[0][0] + samples[i+256] * coef[1][0] + samples[i+512] * coef[2][0]; \
+    samples[i+256] = t * coef[0][1] + samples[i+256] * coef[1][1] + samples[i+512] * coef[2][1];
+
+#define DOWNMIX_TO_STEREO(op1, op2) \
+    for(i = 0; i &lt; 256; i++){ \
+        op1 \
+        op2 \
+    }
+
+static void dca_downmix(float *samples, int srcfmt,
+                        int downmix_coef[DCA_PRIM_CHANNELS_MAX][2])
+{
+    int i;
+    float t;
+    float coef[DCA_PRIM_CHANNELS_MAX][2];
+
+    for(i=0; i&lt;DCA_PRIM_CHANNELS_MAX; i++) {
+        coef[i][0] = dca_downmix_coeffs[downmix_coef[i][0]];
+        coef[i][1] = dca_downmix_coeffs[downmix_coef[i][1]];
+    }
+
+    switch (srcfmt) {
+    case DCA_MONO:
+    case DCA_CHANNEL:
+    case DCA_STEREO_TOTAL:
+    case DCA_STEREO_SUMDIFF:
+    case DCA_4F2R:
+        av_log(NULL, 0, &quot;Not implemented!\n&quot;);
+        break;
+    case DCA_STEREO:
+        break;
+    case DCA_3F:
+        DOWNMIX_TO_STEREO(MIX_FRONT3(samples, coef),);
+        break;
+    case DCA_2F1R:
+        DOWNMIX_TO_STEREO(MIX_REAR1(samples, i + 512, 2, coef),);
+        break;
+    case DCA_3F1R:
+        DOWNMIX_TO_STEREO(MIX_FRONT3(samples, coef),
+                          MIX_REAR1(samples, i + 768, 3, coef));
+        break;
+    case DCA_2F2R:
+        DOWNMIX_TO_STEREO(MIX_REAR2(samples, i + 512, i + 768, 2, coef),);
+        break;
+    case DCA_3F2R:
+        DOWNMIX_TO_STEREO(MIX_FRONT3(samples, coef),
+                          MIX_REAR2(samples, i + 768, i + 1024, 3, coef));
+        break;
+    }
+}
+
+
+/* Very compact version of the block code decoder that does not use table
+ * look-up but is slightly slower */
+static int decode_blockcode(int code, int levels, int *values)
+{
+    int i;
+    int offset = (levels - 1) &gt;&gt; 1;
+
+    for (i = 0; i &lt; 4; i++) {
+        values[i] = (code % levels) - offset;
+        code /= levels;
+    }
+
+    if (code == 0)
+        return 0;
+    else {
+        av_log(NULL, AV_LOG_ERROR, &quot;ERROR: block code look-up failed\n&quot;);
+        return -1;
+    }
+}
+
+static const uint8_t abits_sizes[7] = { 7, 10, 12, 13, 15, 17, 19 };
+static const uint8_t abits_levels[7] = { 3, 5, 7, 9, 13, 17, 25 };
+
+static int dca_subsubframe(DCAContext * s)
+{
+    int k, l;
+    int subsubframe = s-&gt;current_subsubframe;
+
+    const float *quant_step_table;
+
+    /* FIXME */
+    float subband_samples[DCA_PRIM_CHANNELS_MAX][DCA_SUBBANDS][8];
+
+    /*
+     * Audio data
+     */
+
+    /* Select quantization step size table */
+    if (s-&gt;bit_rate == 0x1f)
+        quant_step_table = lossless_quant_d;
+    else
+        quant_step_table = lossy_quant_d;
+
+    for (k = 0; k &lt; s-&gt;prim_channels; k++) {
+        for (l = 0; l &lt; s-&gt;vq_start_subband[k]; l++) {
+            int m;
+
+            /* Select the mid-tread linear quantizer */
+            int abits = s-&gt;bitalloc[k][l];
+
+            float quant_step_size = quant_step_table[abits];
+            float rscale;
+
+            /*
+             * Determine quantization index code book and its type
+             */
+
+            /* Select quantization index code book */
+            int sel = s-&gt;quant_index_huffman[k][abits];
+
+            /*
+             * Extract bits from the bit stream
+             */
+            if(!abits){
+                memset(subband_samples[k][l], 0, 8 * sizeof(subband_samples[0][0][0]));
+            }else if(abits &gt;= 11 || !dca_smpl_bitalloc[abits].vlc[sel].table){
+                if(abits &lt;= 7){
+                    /* Block code */
+                    int block_code1, block_code2, size, levels;
+                    int block[8];
+
+                    size = abits_sizes[abits-1];
+                    levels = abits_levels[abits-1];
+
+                    block_code1 = get_bits(&amp;s-&gt;gb, size);
+                    /* FIXME Should test return value */
+                    decode_blockcode(block_code1, levels, block);
+                    block_code2 = get_bits(&amp;s-&gt;gb, size);
+                    decode_blockcode(block_code2, levels, &amp;block[4]);
+                    for (m = 0; m &lt; 8; m++)
+                        subband_samples[k][l][m] = block[m];
+                }else{
+                    /* no coding */
+                    for (m = 0; m &lt; 8; m++)
+                        subband_samples[k][l][m] = get_sbits(&amp;s-&gt;gb, abits - 3);
+                }
+            }else{
+                /* Huffman coded */
+                for (m = 0; m &lt; 8; m++)
+                    subband_samples[k][l][m] = get_bitalloc(&amp;s-&gt;gb, &amp;dca_smpl_bitalloc[abits], sel);
+            }
+
+            /* Deal with transients */
+            if (s-&gt;transition_mode[k][l] &amp;&amp;
+                subsubframe &gt;= s-&gt;transition_mode[k][l])
+                rscale = quant_step_size * s-&gt;scale_factor[k][l][1];
+            else
+                rscale = quant_step_size * s-&gt;scale_factor[k][l][0];
+
+            rscale *= s-&gt;scalefactor_adj[k][sel];
+
+            for (m = 0; m &lt; 8; m++)
+                subband_samples[k][l][m] *= rscale;
+
+            /*
+             * Inverse ADPCM if in prediction mode
+             */
+            if (s-&gt;prediction_mode[k][l]) {
+                int n;
+                for (m = 0; m &lt; 8; m++) {
+                    for (n = 1; n &lt;= 4; n++)
+                        if (m &gt;= n)
+                            subband_samples[k][l][m] +=
+                                (adpcm_vb[s-&gt;prediction_vq[k][l]][n - 1] *
+                                 subband_samples[k][l][m - n] / 8192);
+                        else if (s-&gt;predictor_history)
+                            subband_samples[k][l][m] +=
+                                (adpcm_vb[s-&gt;prediction_vq[k][l]][n - 1] *
+                                 s-&gt;subband_samples_hist[k][l][m - n +
+                                                               4] / 8192);
+                }
+            }
+        }
+
+        /*
+         * Decode VQ encoded high frequencies
+         */
+        for (l = s-&gt;vq_start_subband[k]; l &lt; s-&gt;subband_activity[k]; l++) {
+            /* 1 vector -&gt; 32 samples but we only need the 8 samples
+             * for this subsubframe. */
+            int m;
+
+            if (!s-&gt;debug_flag &amp; 0x01) {
+                av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Stream with high frequencies VQ coding\n&quot;);
+                s-&gt;debug_flag |= 0x01;
+            }
+
+            for (m = 0; m &lt; 8; m++) {
+                subband_samples[k][l][m] =
+                    high_freq_vq[s-&gt;high_freq_vq[k][l]][subsubframe * 8 +
+                                                        m]
+                    * (float) s-&gt;scale_factor[k][l][0] / 16.0;
+            }
+        }
+    }
+
+    /* Check for DSYNC after subsubframe */
+    if (s-&gt;aspf || subsubframe == s-&gt;subsubframes - 1) {
+        if (0xFFFF == get_bits(&amp;s-&gt;gb, 16)) {   /* 0xFFFF */
+#ifdef TRACE
+            av_log(s-&gt;avctx, AV_LOG_DEBUG, &quot;Got subframe DSYNC\n&quot;);
+#endif
+        } else {
+            av_log(s-&gt;avctx, AV_LOG_ERROR, &quot;Didn't get subframe DSYNC\n&quot;);
+        }
+    }
+
+    /* Backup predictor history for adpcm */
+    for (k = 0; k &lt; s-&gt;prim_channels; k++)
+        for (l = 0; l &lt; s-&gt;vq_start_subband[k]; l++)
+            memcpy(s-&gt;subband_samples_hist[k][l], &amp;subband_samples[k][l][4],
+                        4 * sizeof(subband_samples[0][0][0]));
+
+    /* 32 subbands QMF */
+    for (k = 0; k &lt; s-&gt;prim_channels; k++) {
+/*        static float pcm_to_double[8] =
+            {32768.0, 32768.0, 524288.0, 524288.0, 0, 8388608.0, 8388608.0};*/
+         qmf_32_subbands(s, k, subband_samples[k], &amp;s-&gt;samples[256 * k],
+                            M_SQRT1_2 /*pcm_to_double[s-&gt;source_pcm_res] */ ,
+                            0 /*s-&gt;bias */ );
+    }

[... truncated: 24749 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="011854.html">[Haiku-commits] r27544 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
	<LI>Next message: <A HREF="011856.html">[Haiku-commits] r27546 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#11855">[ date ]</a>
              <a href="thread.html#11855">[ thread ]</a>
              <a href="subject.html#11855">[ subject ]</a>
              <a href="author.html#11855">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
