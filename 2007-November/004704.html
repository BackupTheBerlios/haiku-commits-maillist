<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22886 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/fs	src/system/kernel/vm src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22886%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/system/kernel/cache%20src/system/kernel/fs%0A%09src/system/kernel/vm%20src/tools/fs_shell&In-Reply-To=%3C200711102119.lAALJvHS011598%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004703.html">
   <LINK REL="Next"  HREF="004705.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22886 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/fs	src/system/kernel/vm src/tools/fs_shell</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22886%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/system/kernel/cache%20src/system/kernel/fs%0A%09src/system/kernel/vm%20src/tools/fs_shell&In-Reply-To=%3C200711102119.lAALJvHS011598%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22886 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/fs	src/system/kernel/vm src/tools/fs_shell">axeld at mail.berlios.de
       </A><BR>
    <I>Sat Nov 10 22:19:57 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004703.html">[Haiku-commits] r22885 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="004705.html">[Haiku-commits] r22887 - in haiku/trunk: headers/os/interface	src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4704">[ date ]</a>
              <a href="thread.html#4704">[ thread ]</a>
              <a href="subject.html#4704">[ subject ]</a>
              <a href="author.html#4704">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-11-10 22:19:52 +0100 (Sat, 10 Nov 2007)
New Revision: 22886
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22886&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22886&amp;view=rev</A>

Added:
   haiku/trunk/src/tools/fs_shell/file_map.cpp
Modified:
   haiku/trunk/headers/os/drivers/fs_cache.h
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_cache.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/headers/private/kernel/vfs.h
   haiku/trunk/headers/private/kernel/vm_types.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Debug.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Lock.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/file.h
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
   haiku/trunk/src/system/kernel/cache/Jamfile
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/cache/file_map.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.cpp
   haiku/trunk/src/system/kernel/fs/devfs.cpp
   haiku/trunk/src/system/kernel/fs/pipefs.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/vm/vm.cpp
   haiku/trunk/src/system/kernel/vm/vm_page.cpp
   haiku/trunk/src/system/kernel/vm/vm_store_anonymous_noswap.cpp
   haiku/trunk/src/system/kernel/vm/vm_store_device.c
   haiku/trunk/src/system/kernel/vm/vm_store_null.c
   haiku/trunk/src/tools/fs_shell/Jamfile
   haiku/trunk/src/tools/fs_shell/file_cache.cpp
   haiku/trunk/src/tools/fs_shell/vfs.cpp
   haiku/trunk/src/tools/fs_shell/vfs.h
Log:
* Extracted file_map API out of the file cache - it's now an optional service
  that can be used by file systems.
* Changed the way the file cache works: instead of reading/writing to the
  underlying device directly, it can now be used for any data source, ie.
  also network file systems.
* As a result, the former pages_io() moved to the VFS layer, and can now be
  called by a file system via {read|write}_file_io_vec_pages() (naming
  suggestions are always welcomed :-)). It now gets an FD, and uses that to
  communicate with the device (via its fs_{read|write}_pages() hooks).
* The file_cache_{read|write}() functions must now be called without holding
  an I/O relevant file system lock. That allows the file cache to prepare the
  pages without colliding with the page writer, IOW the &quot;mayBlock&quot; flag can
  go into the attic again (yay!).
* This also results in a much better performance when the system does I/O and
  is low on memory, as the page writer can now finally write back some pages,
  and that even without maxing out the CPU :)
* The API changes put slightly more burden on the fs_{read|write}_pages()
  hooks, but in combination with the file_map it's still pretty straight
  forward. It just will have to dispatch the call to the underlying device
  directly, usually it will just call its fs_{read|write}_pages() hooks
  via the above mentioned calls.
* Ported BFS and FAT to the new API, the latter has not been tested, though.
* Also ported the API changes to the fs_shell. I also completely removed its
  file cache level page handling - the downside is that device access is no
  longer cached (ie. depends on the host OS now), the upside is that the code
  is greatly simplified.


Modified: haiku/trunk/headers/os/drivers/fs_cache.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_cache.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/os/drivers/fs_cache.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -56,23 +56,24 @@
 extern void block_cache_put(void *_cache, off_t blockNumber);
 
 /* file cache */
-extern void *file_cache_create(dev_t mountID, ino_t vnodeID, off_t size,
-					int fd);
+extern void *file_cache_create(dev_t mountID, ino_t vnodeID, off_t size);
 extern void file_cache_delete(void *_cacheRef);
 extern status_t file_cache_set_size(void *_cacheRef, off_t size);
 extern status_t file_cache_sync(void *_cache);
-extern status_t file_cache_invalidate_file_map(void *_cacheRef, off_t offset,
-					off_t size);
 
-extern status_t file_cache_read_pages(void *_cacheRef, off_t offset,
-					const iovec *vecs, size_t count, size_t *_numBytes);
-extern status_t file_cache_write_pages(void *_cacheRef, off_t offset,
-					const iovec *vecs, size_t count, size_t *_numBytes);
-extern status_t file_cache_read(void *_cacheRef, off_t offset, void *bufferBase,
-					size_t *_size);
-extern status_t file_cache_write(void *_cacheRef, off_t offset,
+extern status_t file_cache_read(void *_cacheRef, void *cookie, off_t offset,
+					void *bufferBase, size_t *_size);
+extern status_t file_cache_write(void *_cacheRef, void *cookie, off_t offset,
 					const void *buffer, size_t *_size);
 
+/* file map */
+extern void *file_map_create(dev_t mountID, ino_t vnodeID);
+extern void file_map_delete(void *_map);
+extern void file_map_set_size(void *_map, off_t size);
+extern void file_map_invalidate(void *_map, off_t offset, off_t size);
+extern status_t file_map_translate(void *_map, off_t offset, size_t size,
+					struct file_io_vec *vecs, size_t *_count);
+
 #ifdef __cplusplus
 }
 #endif 

Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -92,10 +92,10 @@
 	bool (*can_page)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
 	status_t (*read_pages)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
 				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes,
-				bool mayBlock, bool reenter);
+				bool reenter);
 	status_t (*write_pages)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
 				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes,
-				bool mayBlock, bool reenter);
+				bool reenter);
 
 	/* cache file access */
 	status_t (*get_file_map)(fs_volume fs, fs_vnode vnode, off_t offset,
@@ -251,6 +251,18 @@
 extern status_t unremove_vnode(dev_t mountID, ino_t vnodeID);
 extern status_t get_vnode_removed(dev_t mountID, ino_t vnodeID,
 					bool* removed);
+extern status_t read_pages(int fd, off_t pos, const struct iovec *vecs,
+					size_t count, size_t *_numBytes, bool fsReenter);
+extern status_t write_pages(int fd, off_t pos, const struct iovec *vecs,
+					size_t count, size_t *_numBytes, bool fsReenter);
+extern status_t read_file_io_vec_pages(int fd,
+					const struct file_io_vec *fileVecs, size_t fileVecCount,
+					const struct iovec *vecs, size_t vecCount,
+					uint32 *_vecIndex, size_t *_vecOffset, size_t *_bytes);
+extern status_t write_file_io_vec_pages(int fd,
+					const struct file_io_vec *fileVecs, size_t fileVecCount,
+					const struct iovec *vecs, size_t vecCount,
+					uint32 *_vecIndex, size_t *_vecOffset, size_t *_bytes);
 
 // Deprecated! Will disappear soon!
 extern status_t notify_listener(int op, dev_t device, ino_t parentNode,

Modified: haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -820,13 +820,16 @@
 #define file_cache_delete				fssh_file_cache_delete
 #define file_cache_set_size				fssh_file_cache_set_size
 #define file_cache_sync					fssh_file_cache_sync
-#define file_cache_invalidate_file_map	fssh_file_cache_invalidate_file_map
 
-#define file_cache_read_pages			fssh_file_cache_read_pages
-#define file_cache_write_pages			fssh_file_cache_write_pages
 #define file_cache_read					fssh_file_cache_read
 #define file_cache_write				fssh_file_cache_write
 
+/* file map */
+#define file_map_create					fssh_file_map_create
+#define file_map_delete					fssh_file_map_delete
+#define file_map_set_size				fssh_file_map_set_size
+#define file_map_invalidate				fssh_file_map_invalidate
+#define file_map_translate				fssh_file_map_translate
 
 ////////////////////////////////////////////////////////////////////////////////
 // #pragma mark - fssh_fs_index.h
@@ -893,6 +896,10 @@
 #define remove_vnode				fssh_remove_vnode
 #define unremove_vnode				fssh_unremove_vnode
 #define get_vnode_removed			fssh_get_vnode_removed
+#define read_pages					fssh_read_pages
+#define write_pages					fssh_write_pages
+#define read_file_io_vec_pages		fssh_read_file_io_vec_pages
+#define write_file_io_vec_pages		fssh_write_file_io_vec_pages
 
 #define notify_entry_created		fssh_notify_entry_created
 #define notify_entry_removed		fssh_notify_entry_removed

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_cache.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_cache.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_cache.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -69,26 +69,30 @@
 
 /* file cache */
 extern void *			fssh_file_cache_create(fssh_mount_id mountID,
-							fssh_vnode_id vnodeID, fssh_off_t size, int fd);
+							fssh_vnode_id vnodeID, fssh_off_t size);
 extern void				fssh_file_cache_delete(void *_cacheRef);
 extern fssh_status_t	fssh_file_cache_set_size(void *_cacheRef,
 							fssh_off_t size);
 extern fssh_status_t	fssh_file_cache_sync(void *_cache);
-extern fssh_status_t	fssh_file_cache_invalidate_file_map(void *_cacheRef,
-							fssh_off_t offset, fssh_off_t size);
 
-extern fssh_status_t	fssh_file_cache_read_pages(void *_cacheRef,
-							fssh_off_t offset, const fssh_iovec *vecs,
-							fssh_size_t count, fssh_size_t *_numBytes);
-extern fssh_status_t	fssh_file_cache_write_pages(void *_cacheRef,
-							fssh_off_t offset, const fssh_iovec *vecs,
-							fssh_size_t count, fssh_size_t *_numBytes);
-extern fssh_status_t	fssh_file_cache_read(void *_cacheRef, fssh_off_t offset,
-							void *bufferBase, fssh_size_t *_size);
-extern fssh_status_t	fssh_file_cache_write(void *_cacheRef,
+extern fssh_status_t	fssh_file_cache_read(void *_cacheRef, void *cookie,
+							fssh_off_t offset, void *bufferBase,
+							fssh_size_t *_size);
+extern fssh_status_t	fssh_file_cache_write(void *_cacheRef, void *cookie,
 							fssh_off_t offset, const void *buffer,
 							fssh_size_t *_size);
 
+/* file map */
+extern void *			fssh_file_map_create(fssh_mount_id mountID,
+							fssh_vnode_id vnodeID);
+extern void				fssh_file_map_delete(void *_map);
+extern void				fssh_file_map_set_size(void *_map, fssh_off_t size);
+extern void				fssh_file_map_invalidate(void *_map, fssh_off_t offset,
+							fssh_off_t size);
+extern fssh_status_t	fssh_file_map_translate(void *_map, fssh_off_t offset,
+							fssh_size_t size, struct fssh_file_io_vec *vecs,
+							fssh_size_t *_count);
+
 #ifdef __cplusplus
 }
 #endif 

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -96,12 +96,10 @@
 				fssh_fs_cookie cookie);
 	fssh_status_t (*read_pages)(fssh_fs_volume fs, fssh_fs_vnode vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
-				fssh_size_t count, fssh_size_t *_numBytes, bool mayBlock,
-				bool reenter);
+				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
 	fssh_status_t (*write_pages)(fssh_fs_volume fs, fssh_fs_vnode vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
-				fssh_size_t count, fssh_size_t *_numBytes, bool mayBlock,
-				bool reenter);
+				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
 
 	/* cache file access */
 	fssh_status_t (*get_file_map)(fssh_fs_volume fs, fssh_fs_vnode vnode,
@@ -293,6 +291,22 @@
 				fssh_vnode_id vnodeID);
 extern fssh_status_t fssh_get_vnode_removed(fssh_mount_id mountID,
 				fssh_vnode_id vnodeID, bool* removed);
+extern fssh_status_t fssh_read_pages(int fd, fssh_off_t pos,
+				const struct fssh_iovec *vecs, fssh_size_t count,
+				fssh_size_t *_numBytes, bool fsReenter);
+extern fssh_status_t fssh_write_pages(int fd, fssh_off_t pos,
+				const struct fssh_iovec *vecs, fssh_size_t count,
+				fssh_size_t *_numBytes, bool fsReenter);
+extern fssh_status_t fssh_read_file_io_vec_pages(int fd,
+				const struct fssh_file_io_vec *fileVecs,
+				fssh_size_t fileVecCount, const struct fssh_iovec *vecs,
+				fssh_size_t vecCount, uint32_t *_vecIndex,
+				fssh_size_t *_vecOffset, fssh_size_t *_bytes);
+extern fssh_status_t fssh_write_file_io_vec_pages(int fd,
+				const struct fssh_file_io_vec *fileVecs,
+				fssh_size_t fileVecCount, const struct fssh_iovec *vecs,
+				fssh_size_t vecCount, uint32_t *_vecIndex,
+				fssh_size_t *_vecOffset, fssh_size_t *_bytes);
 
 extern fssh_status_t fssh_notify_entry_created(fssh_mount_id device,
 				fssh_vnode_id directory, const char *name, fssh_vnode_id node);

Modified: haiku/trunk/headers/private/kernel/vfs.h
===================================================================
--- haiku/trunk/headers/private/kernel/vfs.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/private/kernel/vfs.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -94,11 +94,9 @@
 status_t vfs_get_cookie_from_fd(int fd, void **_cookie);
 bool vfs_can_page(struct vnode *vnode, void *cookie);
 status_t vfs_read_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-			bool fsReenter);
+			const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
 status_t vfs_write_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-			bool fsReenter);
+			const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
 status_t vfs_get_vnode_cache(struct vnode *vnode, struct vm_cache **_cache,
 			bool allocate);
 status_t vfs_get_file_map(struct vnode *vnode, off_t offset, size_t size,

Modified: haiku/trunk/headers/private/kernel/vm_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm_types.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/headers/private/kernel/vm_types.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -223,11 +223,9 @@
 	status_t (*commit)(struct vm_store *backingStore, off_t size);
 	bool (*has_page)(struct vm_store *backingStore, off_t offset);
 	status_t (*read)(struct vm_store *backingStore, off_t offset,
-		const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-		bool fsReenter);
+		const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
 	status_t (*write)(struct vm_store *backingStore, off_t offset,
-		const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-		bool fsReenter);
+		const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
 	status_t (*fault)(struct vm_store *backingStore,
 		struct vm_address_space *aspace, off_t offset);
 	status_t (*acquire_unreferenced_ref)(struct vm_store *backingStore);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Debug.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Debug.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Debug.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -47,7 +47,7 @@
 //	D()
 //		the statements in D() are only included if DEBUG is defined
 
-#ifdef DEBUG
+#if 0//DEBUG
 	#define PRINT(x) { __out(&quot;bfs: &quot;); __out x; }
 	#define REPORT_ERROR(status) \
 		__out(&quot;bfs: %s:%d: %s\n&quot;, __FUNCTION__, __LINE__, strerror(status));

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-11-10 21:19:52 UTC (rev 22886)
@@ -171,7 +171,8 @@
 	fID(id),
 	fTree(NULL),
 	fAttributes(NULL),
-	fCache(NULL)
+	fCache(NULL),
+	fMap(NULL)
 {
 	PRINT((&quot;Inode::Inode(volume = %p, id = %Ld) @ %p\n&quot;, volume, id, this));
 
@@ -189,8 +190,10 @@
 
 	if (IsContainer())
 		fTree = new BPlusTree(this);
-	if (IsFile() || IsAttribute())
-		SetFileCache(file_cache_create(fVolume-&gt;ID(), ID(), Size(), fVolume-&gt;Device()));
+	if (IsFile() || IsAttribute()) {
+		SetFileCache(file_cache_create(fVolume-&gt;ID(), ID(), Size()));
+		SetMap(file_map_create(volume-&gt;ID(), ID()));
+	}
 }
 
 
@@ -201,7 +204,8 @@
 	fID(id),
 	fTree(NULL),
 	fAttributes(NULL),
-	fCache(NULL)
+	fCache(NULL),
+	fMap(NULL)
 {
 	PRINT((&quot;Inode::Inode(volume = %p, transaction = %p, id = %Ld) @ %p\n&quot;,
 		volume, &amp;transaction, id, this));
@@ -242,6 +246,7 @@
 	PRINT((&quot;Inode::~Inode() @ %p\n&quot;, this));
 
 	file_cache_delete(FileCache());
+	file_map_delete(Map());
 	delete fTree;
 }
 
@@ -384,8 +389,8 @@
 		// Luckily, this doesn't cause any index updates
 
 		Inode *attribute;
-		status_t status = CreateAttribute(transaction, item-&gt;Name(), item-&gt;Type(),
-			&amp;attribute);
+		status_t status = CreateAttribute(transaction, item-&gt;Name(),
+			item-&gt;Type(), &amp;attribute);
 		if (status &lt; B_OK)
 			RETURN_ERROR(status);
 
@@ -1233,12 +1238,16 @@
 	if (pos &lt; 0)
 		return B_BAD_VALUE;
 
+	ReadLocked locker(Lock());
+
 	if (pos &gt;= Size() || length == 0) {
 		*_length = 0;
 		return B_NO_ERROR;
 	}
 
-	return file_cache_read(FileCache(), pos, buffer, _length);
+	locker.Unlock();
+
+	return file_cache_read(FileCache(), NULL, pos, buffer, _length);
 }
 
 
@@ -1246,6 +1255,10 @@
 Inode::WriteAt(Transaction &amp;transaction, off_t pos, const uint8 *buffer,
 	size_t *_length)
 {
+	WriteLocked locker(Lock());
+	if (locker.IsLocked() &lt; B_OK)
+		RETURN_ERROR(B_ERROR);
+
 	// update the last modification time in memory, it will be written
 	// back to the inode, and the index when the file is closed
 	// ToDo: should update the internal last modified time only at this point!
@@ -1298,7 +1311,9 @@
 	if (length == 0)
 		return B_OK;
 
-	return file_cache_write(FileCache(), pos, buffer, _length);
+	locker.Unlock();
+
+	return file_cache_write(FileCache(), NULL, pos, buffer, _length);
 }
 
 
@@ -1945,6 +1960,8 @@
 		return status;
 
 	file_cache_set_size(FileCache(), size);
+	file_map_set_size(Map(), size);
+
 	return WriteBack(transaction);
 }
 
@@ -2400,7 +2417,8 @@
 
 	if (inode-&gt;IsFile() || inode-&gt;IsAttribute()) {
 		inode-&gt;SetFileCache(file_cache_create(volume-&gt;ID(), inode-&gt;ID(),
-			inode-&gt;Size(), volume-&gt;Device()));
+			inode-&gt;Size()));
+		inode-&gt;SetMap(file_map_create(volume-&gt;ID(), inode-&gt;ID()));
 	}
 
 	if (_created)

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -156,6 +156,8 @@
 		// file cache
 		void *FileCache() const { return fCache; }
 		void SetFileCache(void *cache) { fCache = cache; }
+		void *Map() const { return fMap; }
+		void SetMap(void *map) { fMap = map; }
 
 	private:
 		Inode(const Inode &amp;);
@@ -198,6 +200,7 @@
 		BPlusTree		*fTree;
 		Inode			*fAttributes;
 		void			*fCache;
+		void			*fMap;
 		bfs_inode		fNode;
 
 		off_t			fOldSize;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Lock.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Lock.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Lock.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -440,18 +440,26 @@
 		{
 			fStatus = lock.Lock();
 		}
-		
+
 		~ReadLocked()
 		{
 			if (fStatus == B_OK)
 				fLock.Unlock();
 		}
-	
-		status_t IsLocked()
+
+		status_t
+		IsLocked()
 		{
 			return fStatus;
 		}
 
+		void
+		Unlock()
+		{
+			fLock.Unlock();
+			fStatus = B_NO_INIT;
+		}
+
 	private:
 		ReadWriteLock	&fLock;
 		status_t		fStatus;
@@ -480,11 +488,19 @@
 				fLock-&gt;UnlockWrite();
 		}
 
-		status_t IsLocked()
+		status_t
+		IsLocked()
 		{
 			return fStatus;
 		}
 
+		void
+		Unlock()
+		{
+			fLock-&gt;UnlockWrite();
+			fStatus = B_NO_INIT;
+		}
+
 	private:
 		ReadWriteLock	*fLock;
 		status_t		fStatus;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-11-10 21:19:52 UTC (rev 22886)
@@ -331,24 +331,43 @@
 
 static status_t
 bfs_read_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
+	Volume *volume = (Volume *)_fs;
 	Inode *inode = (Inode *)_node;
 
 	if (inode-&gt;FileCache() == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
-	if (!reenter) {
-		if (mayBlock)
-			inode-&gt;Lock().Lock();
-		else if (inode-&gt;Lock().TryLock() &lt; B_OK)
-			return B_WOULD_BLOCK;
+	if (!reenter)
+		inode-&gt;Lock().Lock();
+
+	uint32 vecIndex = 0;
+	size_t vecOffset = 0;
+	size_t bytesLeft = *_numBytes;
+	status_t status;
+
+	while (true) {
+		file_io_vec fileVecs[8];
+		uint32 fileVecCount = 8;
+
+		status = file_map_translate(inode-&gt;Map(), pos, bytesLeft, fileVecs,
+			&amp;fileVecCount);
+		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)
+			break;
+
+		bool bufferOverflow = status == B_BUFFER_OVERFLOW;
+
+		size_t bytes;
+		status = read_file_io_vec_pages(volume-&gt;Device(), fileVecs,
+			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);
+		if (status != B_OK || !bufferOverflow)
+			break;
+
+		pos += bytes;
+		bytesLeft -= bytes;
 	}
 
-	status_t status = file_cache_read_pages(inode-&gt;FileCache(), pos, vecs,
-		count, _numBytes);
-
 	if (!reenter)
 		inode-&gt;Lock().Unlock();
 
@@ -358,24 +377,43 @@
 
 static status_t
 bfs_write_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
+	Volume *volume = (Volume *)_fs;
 	Inode *inode = (Inode *)_node;
 
 	if (inode-&gt;FileCache() == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
-	if (!reenter) {
-		if (mayBlock)
-			inode-&gt;Lock().Lock();
-		else if (inode-&gt;Lock().TryLock() &lt; B_OK)
-			return B_WOULD_BLOCK;
+	if (!reenter)
+		inode-&gt;Lock().Lock();
+
+	uint32 vecIndex = 0;
+	size_t vecOffset = 0;
+	size_t bytesLeft = *_numBytes;
+	status_t status;
+
+	while (true) {
+		file_io_vec fileVecs[8];
+		uint32 fileVecCount = 8;
+
+		status = file_map_translate(inode-&gt;Map(), pos, bytesLeft, fileVecs,
+			&amp;fileVecCount);
+		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)
+			break;
+
+		bool bufferOverflow = status == B_BUFFER_OVERFLOW;
+
+		size_t bytes;
+		status = write_file_io_vec_pages(volume-&gt;Device(), fileVecs,
+			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);
+		if (status != B_OK || !bufferOverflow)
+			break;
+
+		pos += bytes;
+		bytesLeft -= bytes;
 	}
 
-	status_t status = file_cache_write_pages(inode-&gt;FileCache(), pos, vecs,
-		count, _numBytes);
-
 	if (!reenter)
 		inode-&gt;Lock().Unlock();
 
@@ -818,8 +856,8 @@
 			| INODE_LOGGED);
 
 		// links usually don't have a file cache attached - but we now need one
-		link-&gt;SetFileCache(file_cache_create(volume-&gt;ID(), link-&gt;ID(), 0,
-			volume-&gt;Device()));
+		link-&gt;SetFileCache(file_cache_create(volume-&gt;ID(), link-&gt;ID(), 0));
+		link-&gt;SetMap(file_map_create(volume-&gt;ID(), link-&gt;ID()));
 
 		// The following call will have to write the inode back, so
 		// we don't have to do that here...
@@ -1067,9 +1105,6 @@
 }
 
 
-/**	Opens the file with the specified mode.
- */
-
 static status_t
 bfs_open(void *_fs, void *_node, int openMode, void **_cookie)
 {
@@ -1133,12 +1168,9 @@
 }
 
 
-/**	Read a file specified by node, using information in cookie
- *	and at offset specified by pos. read len bytes into buffer buf.
- */
-
 static status_t
-bfs_read(void *_ns, void *_node, void *_cookie, off_t pos, void *buffer, size_t *_length)
+bfs_read(void *_ns, void *_node, void *_cookie, off_t pos, void *buffer,
+	size_t *_length)
 {
 	//FUNCTION();
 	Inode *inode = (Inode *)_node;
@@ -1148,19 +1180,15 @@
 		RETURN_ERROR(B_BAD_VALUE);
 	}
 
-	ReadLocked locked(inode-&gt;Lock());
 	return inode-&gt;ReadAt(pos, (uint8 *)buffer, _length);
 }
 
 
 static status_t
-bfs_write(void *_ns, void *_node, void *_cookie, off_t pos, const void *buffer, size_t *_length)
+bfs_write(void *_ns, void *_node, void *_cookie, off_t pos, const void *buffer,
+	size_t *_length)
 {
 	//FUNCTION();
-	// uncomment to be more robust against a buggy vnode layer ;-)
-	//if (_ns == NULL || _node == NULL || _cookie == NULL)
-	//	return B_BAD_VALUE;
-
 	Volume *volume = (Volume *)_ns;
 	Inode *inode = (Inode *)_node;
 
@@ -1174,21 +1202,20 @@
 	if (cookie-&gt;open_mode &amp; O_APPEND)
 		pos = inode-&gt;Size();
 
-	WriteLocked locked(inode-&gt;Lock());
-	if (locked.IsLocked() &lt; B_OK)
-		RETURN_ERROR(B_ERROR);
-
 	Transaction transaction;
 		// We are not starting the transaction here, since
 		// it might not be needed at all (the contents of
 		// regular files aren't logged)
 
-	status_t status = inode-&gt;WriteAt(transaction, pos, (const uint8 *)buffer, _length);
+	status_t status = inode-&gt;WriteAt(transaction, pos, (const uint8 *)buffer,
+		_length);
 
 	if (status == B_OK)
 		transaction.Done();
 
 	if (status == B_OK) {
+		ReadLocked locker(inode-&gt;Lock());
+
 		// periodically notify if the file size has changed
 		// ToDo: should we better test for a change in the last_modified time only?
 		if (!inode-&gt;IsDeleted() &amp;&amp; cookie-&gt;last_size != inode-&gt;Size()

Modified: haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2007-11-10 21:19:52 UTC (rev 22886)
@@ -1574,8 +1574,7 @@
 
 static status_t
 cdda_read_pages(fs_volume _volume, fs_vnode _v, fs_cookie cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
 	return B_NOT_ALLOWED;
 }
@@ -1583,8 +1582,7 @@
 
 static status_t
 cdda_write_pages(fs_volume _volume, fs_vnode _v, fs_cookie cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
 	return B_NOT_ALLOWED;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2007-11-10 21:19:52 UTC (rev 22886)
@@ -1038,8 +1038,9 @@
 	entry-&gt;filename = malloc(sizeof(filename) + 1);
 	if (entry-&gt;filename) strcpy(entry-&gt;filename, filename);
 #endif
-	entry-&gt;cache = file_cache_create(vol-&gt;id, vnid, entry-&gt;st_size, vol-&gt;fd);
-	if(!(entry-&gt;mode &amp; FAT_SUBDIR))
+	entry-&gt;cache = file_cache_create(vol-&gt;id, vnid, entry-&gt;st_size);
+	entry-&gt;file_map = file_map_create(vol-&gt;id, vnid);
+	if (!(entry-&gt;mode &amp; FAT_SUBDIR))
 		set_mime_type(entry, filename);
 
 	*_node = entry;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -65,12 +65,12 @@
 
 #define VNODE_MAGIC 'treB'
 
-typedef struct vnode
-{
+typedef struct vnode {
 	uint32		magic;
 	ino_t		vnid; 			// self id
 	ino_t	 	dir_vnid;		// parent vnode id (directory containing entry)
-	void		*cache;			// for file cache
+	void		*cache;
+	void		*file_map;
 
 	uint32		disk_image;		// 0 = no, 1 = BEOS, 2 = IMAGE.BE
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2007-11-10 21:19:52 UTC (rev 22886)
@@ -141,8 +141,8 @@
 		
 		if (node-&gt;vnid != vol-&gt;root_vnode.vnid) {
 			node-&gt;magic = ~VNODE_MAGIC; // munge magic number to be safe
-			if (node-&gt;cache != NULL)
-				file_cache_delete(node-&gt;cache);
+			file_cache_delete(node-&gt;cache);
+			file_map_delete(node-&gt;file_map);
 			free(node);
 		}
 	}
@@ -245,6 +245,7 @@
 				node-&gt;iteration++;
 				dirty = true;
 				file_cache_set_size(node-&gt;cache, node-&gt;st_size);
+				file_map_set_size(node-&gt;file_map, node-&gt;st_size);
 			}
 		}
 	}
@@ -393,7 +394,7 @@
 	if (pos + *len &gt;= node-&gt;st_size)
 		*len = node-&gt;st_size - pos;
 		
-	result = file_cache_read(node-&gt;cache, pos, buf, len);
+	result = file_cache_read(node-&gt;cache, cookie, pos, buf, len);
 
 #if 0
 
@@ -595,9 +596,10 @@
 		DPRINTF(0, (&quot;setting file size to %Lx (%lx clusters)\n&quot;, node-&gt;st_size, clusters));
 		node-&gt;dirty = true;
 		file_cache_set_size(node-&gt;cache, node-&gt;st_size);
+		file_map_set_size(node-&gt;file_map, node-&gt;st_size);
 	}
 	
-	result = file_cache_write(node-&gt;cache, pos, buf, len);
+	result = file_cache_write(node-&gt;cache, cookie, pos, buf, len);
 	
 #if 0
 	if (cluster1 == 0xffffffff) {
@@ -1479,11 +1481,13 @@
 
 status_t
 dosfs_read_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
 	nspace *vol = (nspace *)_fs;
 	vnode *node = (vnode *)_node;
+	uint32 vecIndex = 0;
+	size_t vecOffset = 0;
+	size_t bytesLeft = *_numBytes;
 	status_t status;
 
 	if (check_nspace_magic(vol, &quot;dosfs_read_pages&quot;)
@@ -1493,23 +1497,49 @@
 	if (node-&gt;cache == NULL)
 		return(B_BAD_VALUE);
 
-	// TODO: respect &quot;mayBlock&quot;!
-	LOCK_VOL(vol);
-	status = file_cache_read_pages(node-&gt;cache, pos, vecs, count,
-		_numBytes);
-	UNLOCK_VOL(vol);
+	if (!reenter) {
+		LOCK_VOL(vol);
+	}
 
-	return status;
+	while (true) {
+		struct file_io_vec fileVecs[8];
+		uint32 fileVecCount = 8;
+		bool bufferOverflow;
+		size_t bytes;
+
+		status = file_map_translate(node-&gt;file_map, pos, bytesLeft, fileVecs,
+			&amp;fileVecCount);
+		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)
+			break;
+
+		bufferOverflow = status == B_BUFFER_OVERFLOW;
+
+		status = read_file_io_vec_pages(vol-&gt;fd, fileVecs,
+			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);
+		if (status != B_OK || !bufferOverflow)
+			break;
+
+		pos += bytes;
+		bytesLeft -= bytes;
+	}
+
+	if (!reenter) {
+		UNLOCK_VOL(vol);
+	}
+
+	return B_ERROR;
 }
 
 
 status_t
 dosfs_write_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock,
-	bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
 {
 	nspace *vol = (nspace *)_fs;
 	vnode *node = (vnode *)_node;
+	uint32 vecIndex = 0;
+	size_t vecOffset = 0;
+	size_t bytesLeft = *_numBytes;
 	status_t status;
 
 	if (check_nspace_magic(vol, &quot;dosfs_write_pages&quot;)
@@ -1519,19 +1549,43 @@
 	if (node-&gt;cache == NULL)
 		return B_BAD_VALUE;
 
-	// TODO: respect &quot;mayBlock&quot;!
-	LOCK_VOL(vol);
-	status = file_cache_write_pages(node-&gt;cache, pos, vecs, count,
-		_numBytes);
-	UNLOCK_VOL(vol);
+	if (!reenter) {
+		LOCK_VOL(vol);
+	}
 
-	return status;
+	while (true) {
+		struct file_io_vec fileVecs[8];
+		uint32 fileVecCount = 8;
+		bool bufferOverflow;
+		size_t bytes;
+
+		status = file_map_translate(node-&gt;file_map, pos, bytesLeft, fileVecs,
+			&amp;fileVecCount);
+		if (status != B_OK &amp;&amp; status != B_BUFFER_OVERFLOW)
+			break;
+
+		bufferOverflow = status == B_BUFFER_OVERFLOW;
+
+		status = write_file_io_vec_pages(vol-&gt;fd, fileVecs,
+			fileVecCount, vecs, count, &amp;vecIndex, &amp;vecOffset, &amp;bytes);
+		if (status != B_OK || !bufferOverflow)
+			break;
+
+		pos += bytes;
+		bytesLeft -= bytes;
+	}
+
+	if (!reenter) {
+		UNLOCK_VOL(vol);
+	}
+
+	return B_ERROR;
 }
 
 
 status_t
 dosfs_get_file_map(void *_fs, void *_node, off_t pos, size_t len,
-						struct file_io_vec *vecs, size_t *_count)
+	struct file_io_vec *vecs, size_t *_count)
 {
 	nspace	*vol = (nspace *)_fs;
 	vnode	*node = (vnode *)_node;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/file.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/file.h	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/file.h	2007-11-10 21:19:52 UTC (rev 22886)
@@ -31,8 +31,8 @@
 				struct file_io_vec *vecs, size_t *_count);
 bool		dosfs_can_page(fs_volume _fs, fs_vnode _v, fs_cookie _cookie);
 status_t	dosfs_read_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-				const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock, bool reenter);
+				const iovec *vecs, size_t count, size_t *_numBytes, bool reenter);
 status_t	dosfs_write_pages(fs_volume _fs, fs_vnode _node, fs_cookie _cookie, off_t pos,
-				const iovec *vecs, size_t count, size_t *_numBytes, bool mayBlock, bool reenter);
+				const iovec *vecs, size_t count, size_t *_numBytes, bool reenter);
 
 #endif

Modified: haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2007-11-10 21:19:52 UTC (rev 22886)
@@ -462,7 +462,8 @@
 		result = ENOMEM;
 
 	if (result == B_OK &amp;&amp; !(newNode-&gt;flags &amp; ISO_ISDIR)) {
-		newNode-&gt;cache = file_cache_create(ns-&gt;id, vnid, newNode-&gt;dataLen[FS_DATA_FORMAT], ns-&gt;fdOfSession);
+		newNode-&gt;cache = file_cache_create(ns-&gt;id, vnid,
+			newNode-&gt;dataLen[FS_DATA_FORMAT]);
 	}
 
 	TRACE((&quot;fs_read_vnode - EXIT, result is %s\n&quot;, strerror(result)));
@@ -567,7 +568,7 @@
 
 	// Read in the middle blocks.
 	if (numBlocks &gt; 0) {
-		for (int32 i=startBlock; i&lt;startBlock+numBlocks; i++) {
+		for (int32 i = startBlock; i &lt; startBlock + numBlocks; i++) {
 			vecs[index].offset = i * blockSize;
 			vecs[index].length = blockSize;
 			index++;
@@ -762,8 +763,8 @@
 		// If pos &gt;= file length, return length of 0.
 		*len = 0;
 		return B_OK;
-        }
-	return file_cache_read(node-&gt;cache, pos, buf, len);
+	}
+	return file_cache_read(node-&gt;cache, NULL, pos, buf, len);
 #endif
 }
 

Modified: haiku/trunk/src/system/kernel/cache/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/cache/Jamfile	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/system/kernel/cache/Jamfile	2007-11-10 21:19:52 UTC (rev 22886)
@@ -4,6 +4,7 @@
 	block_allocator.cpp
 	block_cache.cpp
 	file_cache.cpp
+	file_map.cpp
 	vnode_store.cpp
 
 	: $(TARGET_KERNEL_PIC_CCFLAGS) -Wno-unused

Modified: haiku/trunk/src/system/kernel/cache/file_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/file_cache.cpp	2007-11-10 20:43:00 UTC (rev 22885)
+++ haiku/trunk/src/system/kernel/cache/file_cache.cpp	2007-11-10 21:19:52 UTC (rev 22886)
@@ -35,42 +35,13 @@
 // maximum number of iovecs per request
 #define MAX_IO_VECS			32	// 128 kB
 #define MAX_FILE_IO_VECS	32
-#define MAX_TEMP_IO_VECS	8
 
-#define CACHED_FILE_EXTENTS	2
-	// must be smaller than MAX_FILE_IO_VECS
-	// ToDo: find out how much of these are typically used
-
 #define BYPASS_IO_SIZE		65536
 #define LAST_ACCESSES		3
 
-struct file_extent {
-	off_t			offset;
-	file_io_vec		disk;
-};
-
-struct file_map {
-	file_map();
-	~file_map();
-
-	file_extent *operator[](uint32 index);
-	file_extent *ExtentAt(uint32 index);
-	status_t Add(file_io_vec *vecs, size_t vecCount, off_t &amp;lastOffset);
-	void Free();
-
-	union {
-		file_extent	direct[CACHED_FILE_EXTENTS];
-		file_extent	*array;
-	};
-	size_t			count;
-};
-
 struct file_cache_ref {
 	vm_cache		*cache;
 	struct vnode	*vnode;
-	struct vnode	*device;
-	void			*cookie;
-	file_map		map;
 	off_t			last_access[LAST_ACCESSES];
 		// TODO: it would probably be enough to only store the least
 		//	significant 31 bits, and make this uint32 (one bit for
@@ -79,7 +50,7 @@
 	bool			last_access_was_write;
 };
 
-typedef status_t (*cache_func)(file_cache_ref *ref, off_t offset,
+typedef status_t (*cache_func)(file_cache_ref *ref, void *cookie, off_t offset,
 	int32 pageOffset, addr_t buffer, size_t bufferSize,
 	size_t lastReservedPages, size_t reservePages);

[... truncated: 3950 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004703.html">[Haiku-commits] r22885 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="004705.html">[Haiku-commits] r22887 - in haiku/trunk: headers/os/interface	src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4704">[ date ]</a>
              <a href="thread.html#4704">[ thread ]</a>
              <a href="subject.html#4704">[ subject ]</a>
              <a href="author.html#4704">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
