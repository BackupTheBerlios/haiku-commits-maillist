<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23019 - in haiku/trunk/src:	add-ons/kernel/drivers/network/3com/dev/mii	add-ons/kernel/drivers/network/3com/pci	add-ons/kernel/drivers/network/marvell_yukon/dev/mii	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	add-ons/kernel/drivers/network/rtl8139/pci	add-ons/kernel/drivers/network/via_rhine/dev/mii	add-ons/kernel/drivers/network/via_rhine/pci	libs/compat/freebsd_network libs/compat/freebsd_network/compat/net	libs/compat/freebsd_network/compat/sys
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23019%20-%20in%20haiku/trunk/src%3A%0A%09add-ons/kernel/drivers/network/3com/dev/mii%0A%09add-ons/kernel/drivers/network/3com/pci%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/mii%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/msk%0A%09add-ons/kernel/drivers/network/rtl8139/pci%0A%09add-ons/kernel/drivers/network/via_rhine/dev/mii%0A%09add-ons/kernel/drivers/network/via_rhine/pci%0A%09libs/compat/freebsd_network%20libs/compat/freebsd_network/compat/net%0A%09libs/compat/freebsd_network/compat/sys&In-Reply-To=%3C200711291856.lATIu6SQ014216%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004880.html">
   <LINK REL="Next"  HREF="004884.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23019 - in haiku/trunk/src:	add-ons/kernel/drivers/network/3com/dev/mii	add-ons/kernel/drivers/network/3com/pci	add-ons/kernel/drivers/network/marvell_yukon/dev/mii	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	add-ons/kernel/drivers/network/rtl8139/pci	add-ons/kernel/drivers/network/via_rhine/dev/mii	add-ons/kernel/drivers/network/via_rhine/pci	libs/compat/freebsd_network libs/compat/freebsd_network/compat/net	libs/compat/freebsd_network/compat/sys</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23019%20-%20in%20haiku/trunk/src%3A%0A%09add-ons/kernel/drivers/network/3com/dev/mii%0A%09add-ons/kernel/drivers/network/3com/pci%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/mii%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/msk%0A%09add-ons/kernel/drivers/network/rtl8139/pci%0A%09add-ons/kernel/drivers/network/via_rhine/dev/mii%0A%09add-ons/kernel/drivers/network/via_rhine/pci%0A%09libs/compat/freebsd_network%20libs/compat/freebsd_network/compat/net%0A%09libs/compat/freebsd_network/compat/sys&In-Reply-To=%3C200711291856.lATIu6SQ014216%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23019 - in haiku/trunk/src:	add-ons/kernel/drivers/network/3com/dev/mii	add-ons/kernel/drivers/network/3com/pci	add-ons/kernel/drivers/network/marvell_yukon/dev/mii	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	add-ons/kernel/drivers/network/rtl8139/pci	add-ons/kernel/drivers/network/via_rhine/dev/mii	add-ons/kernel/drivers/network/via_rhine/pci	libs/compat/freebsd_network libs/compat/freebsd_network/compat/net	libs/compat/freebsd_network/compat/sys">axeld at mail.berlios.de
       </A><BR>
    <I>Thu Nov 29 19:56:06 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004880.html">[Haiku-commits] r23018 - haiku/trunk/src/kits/interface
</A></li>
        <LI>Next message: <A HREF="004884.html">[Haiku-commits] r23020 -	haiku/trunk/src/add-ons/kernel/drivers/network/ipro100/dev/fxp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4883">[ date ]</a>
              <a href="thread.html#4883">[ thread ]</a>
              <a href="subject.html#4883">[ subject ]</a>
              <a href="author.html#4883">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-11-29 19:56:03 +0100 (Thu, 29 Nov 2007)
New Revision: 23019
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23019&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23019&amp;view=rev</A>

Added:
   haiku/trunk/src/libs/compat/freebsd_network/driver.c
   haiku/trunk/src/libs/compat/freebsd_network/pci.c
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/3com/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/3com/pci/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/rtl8139/pci/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/pci/glue.c
   haiku/trunk/src/libs/compat/freebsd_network/Jamfile
   haiku/trunk/src/libs/compat/freebsd_network/bus.c
   haiku/trunk/src/libs/compat/freebsd_network/compat.c
   haiku/trunk/src/libs/compat/freebsd_network/compat/net/if_var.h
   haiku/trunk/src/libs/compat/freebsd_network/compat/sys/bus.h
   haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h
   haiku/trunk/src/libs/compat/freebsd_network/device.c
   haiku/trunk/src/libs/compat/freebsd_network/device.h
   haiku/trunk/src/libs/compat/freebsd_network/fbsd_mii.c
   haiku/trunk/src/libs/compat/freebsd_network/if.c
Log:
Completely renovated the FreeBSD compatibility layer:
* Removed NETDEV() and DEVNET() macros and functionality.
* The exported devices are now attached to ifnet objects only, therefore, the
  ifnet object now has the receive queue, and everything else a device could
  need.
* There is now a root device where everything else is attached, it currently
  only holds the pci_info structure, so it's more or less a PCI child.
* This simplified the device handling a bit everywhere.
* We now attach drivers already in init_driver() - this is needed as drivers
  may publish more than one interface when being attached.
* Implemented device_delete_child(), device_attach() (which bus_generic_attach()
  now uses), device_is_attached(), and device_is_alive().
* Therefore, if_initname() does now the actual job of registering the devices.
* On open, if_init() is called which comes pretty close to what our open()
  is supposed to do.
* Updated ukphy.c to the one from FreeBSD 7 where used (we should probably
  move that into the compat layer, anyway).
* The MII driver array must now be NULL terminated; therefore you don't need
  to specify the count anymore.
* Moved PCI code from compat.c to bus.c.
* Moved the driver code from device.c to driver.c.
* Removed superfluous init_compat_layer() function.
* Fixed a few bugs, a few things weren't brought down correctly.
* The rtl8139 interrupt routine now checks if it really was the cause of the
  interrupt - this code is not tested, either, it may not work (which would
  then require a work-around like I did for the 3com driver).
* The HAIKU_PROTECT_INTR_REGISTER in the rtl8139 driver was pretty much useless
  which is why I removed it.
* Probably introduced a lot of new bugs, though - I haven't tested this code
  at all yet. It will probably just crash :-)


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/3com/dev/mii/ukphy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/3com/dev/mii/ukphy.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/3com/dev/mii/ukphy.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -67,7 +67,7 @@
  */
 
 #include &lt;sys/cdefs.h&gt;
-__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.17 2005/01/06 01:42:56 imp Exp $&quot;);
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.20 2007/01/20 00:52:29 marius Exp $&quot;);
 
 /*
  * driver for generic unknown PHYs
@@ -114,34 +114,27 @@
 static int	ukphy_service(struct mii_softc *, struct mii_data *, int);
 
 static int
-ukphy_probe(dev)
-	device_t		dev;
+ukphy_probe(device_t dev)
 {
 
 	/*
 	 * We know something is here, so always match at a low priority.
 	 */
 	device_set_desc(dev, &quot;Generic IEEE 802.3u media interface&quot;);
-	return (-100);
+	return (BUS_PROBE_GENERIC);
 }
 
 static int
-ukphy_attach(dev)
-	device_t		dev;
+ukphy_attach(device_t dev)
 {
 	struct mii_softc *sc;
 	struct mii_attach_args *ma;
 	struct mii_data *mii;
 
-static int ppp;
-if (ppp++ &gt; 0)
-	panic(&quot;oops&quot;);
 	sc = device_get_softc(dev);
 	ma = device_get_ivars(dev);
 	sc-&gt;mii_dev = device_get_parent(dev);
 	mii = device_get_softc(sc-&gt;mii_dev);
-device_printf(dev, &quot;insert into %p\n&quot;, mii);
-device_printf(sc-&gt;mii_dev, &quot;this is the parent\n&quot;);
 	LIST_INSERT_HEAD(&amp;mii-&gt;mii_phys, sc, mii_list);
 
 	if (bootverbose)
@@ -156,8 +149,6 @@
 
 	mii-&gt;mii_instance++;
 
-	sc-&gt;mii_flags |= MIIF_NOISOLATE;
-
 	mii_phy_reset(sc);
 
 	sc-&gt;mii_capabilities =
@@ -171,14 +162,11 @@
 	MIIBUS_MEDIAINIT(sc-&gt;mii_dev);
 	mii_phy_setmedia(sc);
 
-	return(0);
+	return (0);
 }
 
 static int
-ukphy_service(sc, mii, cmd)
-	struct mii_softc *sc;
-	struct mii_data *mii;
-	int cmd;
+ukphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
 {
 	struct ifmedia_entry *ife = mii-&gt;mii_media.ifm_cur;
 	int reg;

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/3com/pci/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/3com/pci/glue.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/3com/pci/glue.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -23,10 +23,11 @@
 	driver_t *drivers[] = {
 		DRIVER_MODULE_NAME(bmtphy, miibus),
 		DRIVER_MODULE_NAME(xlphy, miibus),
-		DRIVER_MODULE_NAME(ukphy, miibus)
+		DRIVER_MODULE_NAME(ukphy, miibus),
+		NULL
 	};
 
-	return __haiku_probe_miibus(dev, drivers, 3);
+	return __haiku_probe_miibus(dev, drivers);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/mii/ukphy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/mii/ukphy.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/mii/ukphy.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -67,7 +67,7 @@
  */
 
 #include &lt;sys/cdefs.h&gt;
-__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.17 2005/01/06 01:42:56 imp Exp $&quot;);
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.20 2007/01/20 00:52:29 marius Exp $&quot;);
 
 /*
  * driver for generic unknown PHYs
@@ -114,34 +114,27 @@
 static int	ukphy_service(struct mii_softc *, struct mii_data *, int);
 
 static int
-ukphy_probe(dev)
-	device_t		dev;
+ukphy_probe(device_t dev)
 {
 
 	/*
 	 * We know something is here, so always match at a low priority.
 	 */
 	device_set_desc(dev, &quot;Generic IEEE 802.3u media interface&quot;);
-	return (-100);
+	return (BUS_PROBE_GENERIC);
 }
 
 static int
-ukphy_attach(dev)
-	device_t		dev;
+ukphy_attach(device_t dev)
 {
 	struct mii_softc *sc;
 	struct mii_attach_args *ma;
 	struct mii_data *mii;
 
-static int ppp;
-if (ppp++ &gt; 0)
-	panic(&quot;oops&quot;);
 	sc = device_get_softc(dev);
 	ma = device_get_ivars(dev);
 	sc-&gt;mii_dev = device_get_parent(dev);
 	mii = device_get_softc(sc-&gt;mii_dev);
-device_printf(dev, &quot;insert into %p\n&quot;, mii);
-device_printf(sc-&gt;mii_dev, &quot;this is the parent\n&quot;);
 	LIST_INSERT_HEAD(&amp;mii-&gt;mii_phys, sc, mii_list);
 
 	if (bootverbose)
@@ -156,8 +149,6 @@
 
 	mii-&gt;mii_instance++;
 
-	sc-&gt;mii_flags |= MIIF_NOISOLATE;
-
 	mii_phy_reset(sc);
 
 	sc-&gt;mii_capabilities =
@@ -171,14 +162,11 @@
 	MIIBUS_MEDIAINIT(sc-&gt;mii_dev);
 	mii_phy_setmedia(sc);
 
-	return(0);
+	return (0);
 }
 
 static int
-ukphy_service(sc, mii, cmd)
-	struct mii_softc *sc;
-	struct mii_data *mii;
-	int cmd;
+ukphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
 {
 	struct ifmedia_entry *ife = mii-&gt;mii_media.ifm_cur;
 	int reg;

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/glue.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/glue.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -19,10 +19,11 @@
 {
 	driver_t *drivers[] = {
 		DRIVER_MODULE_NAME(e1000phy, miibus),
-		DRIVER_MODULE_NAME(ukphy, miibus)
+		DRIVER_MODULE_NAME(ukphy, miibus),
+		NULL
 	};
 
-	return __haiku_probe_miibus(dev, drivers, 2);
+	return __haiku_probe_miibus(dev, drivers);
 }
 
 NO_HAIKU_CHECK_DISABLE_INTERRUPTS();

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/rtl8139/pci/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/rtl8139/pci/glue.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/rtl8139/pci/glue.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -6,21 +6,33 @@
 HAIKU_FBSD_MII_DRIVER(rlphy);
 HAIKU_DRIVER_REQUIREMENTS(0);
 
+
 int
-HAIKU_CHECK_DISABLE_INTERRUPTS(device_t dev) {
+HAIKU_CHECK_DISABLE_INTERRUPTS(device_t dev)
+{
 	struct rl_softc *sc = device_get_softc(dev);
+	uint16_t status;
 
-	HAIKU_PROTECT_INTR_REGISTER(CSR_WRITE_2(sc, RL_IMR, 0));
+	status = CSR_READ_2(sc, RL_ISR);
+	if (status == 0xffff)
+		return 0;
+	if (status != 0 &amp;&amp; (status &amp; RL_INTRS) == 0) {
+		CSR_WRITE_2(sc, RL_ISR, status);
+		return 0;
+	}
+	if ((status &amp; RL_INTRS) == 0)
+		return 0;
 
-	/* we don't read the status register, so we just assume it was for us. */
+	CSR_WRITE_2(sc, RL_IMR, 0);
 	return 1;
 }
 
+
 void
 HAIKU_REENABLE_INTERRUPTS(device_t dev)
 {
 	struct rl_softc *sc = device_get_softc(dev);
 	RL_LOCK(sc);
-	HAIKU_PROTECT_INTR_REGISTER(CSR_WRITE_2(sc, RL_IMR, RL_INTRS));
+	CSR_WRITE_2(sc, RL_IMR, RL_INTRS);
 	RL_UNLOCK(sc);
 }

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/dev/mii/ukphy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/dev/mii/ukphy.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/dev/mii/ukphy.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -67,7 +67,7 @@
  */
 
 #include &lt;sys/cdefs.h&gt;
-__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.17 2005/01/06 01:42:56 imp Exp $&quot;);
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.20 2007/01/20 00:52:29 marius Exp $&quot;);
 
 /*
  * driver for generic unknown PHYs
@@ -114,20 +114,18 @@
 static int	ukphy_service(struct mii_softc *, struct mii_data *, int);
 
 static int
-ukphy_probe(dev)
-	device_t		dev;
+ukphy_probe(device_t dev)
 {
 
 	/*
 	 * We know something is here, so always match at a low priority.
 	 */
 	device_set_desc(dev, &quot;Generic IEEE 802.3u media interface&quot;);
-	return (-100);
+	return (BUS_PROBE_GENERIC);
 }
 
 static int
-ukphy_attach(dev)
-	device_t		dev;
+ukphy_attach(device_t dev)
 {
 	struct mii_softc *sc;
 	struct mii_attach_args *ma;
@@ -151,8 +149,6 @@
 
 	mii-&gt;mii_instance++;
 
-	sc-&gt;mii_flags |= MIIF_NOISOLATE;
-
 	mii_phy_reset(sc);
 
 	sc-&gt;mii_capabilities =
@@ -166,14 +162,11 @@
 	MIIBUS_MEDIAINIT(sc-&gt;mii_dev);
 	mii_phy_setmedia(sc);
 
-	return(0);
+	return (0);
 }
 
 static int
-ukphy_service(sc, mii, cmd)
-	struct mii_softc *sc;
-	struct mii_data *mii;
-	int cmd;
+ukphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
 {
 	struct ifmedia_entry *ife = mii-&gt;mii_media.ifm_cur;
 	int reg;

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/pci/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/pci/glue.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via_rhine/pci/glue.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -20,9 +20,10 @@
 {
 	driver_t *drivers[] = {
 		DRIVER_MODULE_NAME(ciphy, miibus),
-		DRIVER_MODULE_NAME(ukphy, miibus)
+		DRIVER_MODULE_NAME(ukphy, miibus),
+		NULL
 	};
 
-	return __haiku_probe_miibus(dev, drivers, 2);
+	return __haiku_probe_miibus(dev, drivers);
 }
 

Modified: haiku/trunk/src/libs/compat/freebsd_network/Jamfile
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/Jamfile	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/Jamfile	2007-11-29 18:56:03 UTC (rev 23019)
@@ -13,6 +13,7 @@
 	callout.c
 	compat.c
 	device.c
+	driver.c
 	fbsd_busdma_x86.c
 	fbsd_ether.c
 	fbsd_if_media.c
@@ -23,5 +24,6 @@
 	mbuf.c
 	mii.c
 	mutex.c
+	pci.c
 	taskqueue.c
 	;

Modified: haiku/trunk/src/libs/compat/freebsd_network/bus.c
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/bus.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/bus.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -11,6 +11,7 @@
 
 #include &lt;arch/cpu.h&gt;
 
+#include &lt;compat/dev/pci/pcireg.h&gt;
 #include &lt;compat/dev/pci/pcivar.h&gt;
 #include &lt;compat/machine/resource.h&gt;
 #include &lt;compat/sys/bus.h&gt;
@@ -24,6 +25,14 @@
 #	define TRACE_BUS_SPACE_RW(x)
 #endif
 
+//#define DEBUG_PCI
+#ifdef DEBUG_PCI
+#	define TRACE_PCI(dev, format, args...) device_printf(dev, format , ##args)
+#else
+#	define TRACE_PCI(dev, format, args...) do { } while (0)
+#endif
+
+
 #define ROUNDUP(a, b) (((a) + ((b)-1)) &amp; ~((b)-1))
 
 // TODO: x86 specific!
@@ -306,7 +315,7 @@
 		status = install_io_interrupt_handler(intr-&gt;irq,
 			intr_fast_wrapper, intr, 0);
 	} else {
-		snprintf(semName, sizeof(semName), &quot;%s intr&quot;, dev-&gt;dev_name);
+		snprintf(semName, sizeof(semName), &quot;%s intr&quot;, dev-&gt;device_name);
 
 		intr-&gt;sem = create_sem(0, semName);
 		if (intr-&gt;sem &lt; B_OK) {
@@ -314,7 +323,7 @@
 			return B_NO_MEMORY;
 		}
 
-		snprintf(semName, sizeof(semName), &quot;%s intr handler&quot;, dev-&gt;dev_name);
+		snprintf(semName, sizeof(semName), &quot;%s intr handler&quot;, dev-&gt;device_name);
 
 		intr-&gt;thread = spawn_kernel_thread(intr_handler, semName,
 			B_REAL_TIME_DISPLAY_PRIORITY, intr);
@@ -450,3 +459,184 @@
 BUS_SPACE_WRITE(1, uint8_t, out8)
 BUS_SPACE_WRITE(2, uint16_t, out16)
 BUS_SPACE_WRITE(4, uint32_t, out32)
+
+
+//	#pragma mark - PCI functions
+
+
+uint32_t
+pci_read_config(device_t dev, int offset, int size)
+{
+	pci_info *info = &amp;((struct root_device_softc *)dev-&gt;root-&gt;softc)-&gt;pci_info;
+
+	uint32_t value = gPci-&gt;read_pci_config(info-&gt;bus, info-&gt;device,
+		info-&gt;function, offset, size);
+	TRACE_PCI(dev, &quot;pci_read_config(%i, %i) = 0x%x\n&quot;, offset, size, value);
+	return value;
+}
+
+
+void
+pci_write_config(device_t dev, int offset, uint32_t value, int size)
+{
+	pci_info *info = &amp;((struct root_device_softc *)dev-&gt;root-&gt;softc)-&gt;pci_info;
+
+	TRACE_PCI(dev, &quot;pci_write_config(%i, 0x%x, %i)\n&quot;, offset, value, size);
+
+	gPci-&gt;write_pci_config(info-&gt;bus, info-&gt;device, info-&gt;function, offset,
+		size, value);
+}
+
+
+uint16_t
+pci_get_vendor(device_t dev)
+{
+	return pci_read_config(dev, PCI_vendor_id, 2);
+}
+
+
+uint16_t
+pci_get_device(device_t dev)
+{
+	return pci_read_config(dev, PCI_device_id, 2);
+}
+
+
+uint16_t
+pci_get_subvendor(device_t dev)
+{
+	return pci_read_config(dev, PCI_subsystem_vendor_id, 2);
+}
+
+
+uint16_t
+pci_get_subdevice(device_t dev)
+{
+	return pci_read_config(dev, PCI_subsystem_id, 2);
+}
+
+
+uint8_t
+pci_get_revid(device_t dev)
+{
+	return pci_read_config(dev, PCI_revision, 1);
+}
+
+
+static void
+pci_set_command_bit(device_t dev, uint16_t bit)
+{
+	uint16_t command = pci_read_config(dev, PCI_command, 2);
+	pci_write_config(dev, PCI_command, command | bit, 2);
+}
+
+
+int
+pci_enable_busmaster(device_t dev)
+{
+	pci_set_command_bit(dev, PCI_command_master);
+	return 0;
+}
+
+
+int
+pci_enable_io(device_t dev, int space)
+{
+	/* adapted from FreeBSD's pci_enable_io_method */
+	int bit = 0;
+
+	switch (space) {
+		case SYS_RES_IOPORT:
+			bit = PCI_command_io;
+			break;
+		case SYS_RES_MEMORY:
+			bit = PCI_command_memory;
+			break;
+		default:
+			return EINVAL;
+	}
+
+	pci_set_command_bit(dev, bit);
+	if (pci_read_config(dev, PCI_command, 2) &amp; bit)
+		return 0;
+
+	device_printf(dev, &quot;pci_enable_io(%d) failed.\n&quot;, space);
+
+	return ENXIO;
+}
+
+
+int
+pci_find_extcap(device_t child, int capability, int *_capabilityRegister)
+{
+	uint8 capabilityPointer;
+	uint8 headerType;
+	uint16 status;
+
+	status = pci_read_config(child, PCIR_STATUS, 2);
+	if ((status &amp; PCIM_STATUS_CAPPRESENT) == 0)
+		return ENXIO;
+
+	headerType = pci_read_config(child, PCI_header_type, 1);
+	switch (headerType &amp; PCIM_HDRTYPE) {
+		case 0:
+		case 1:
+			capabilityPointer = PCIR_CAP_PTR;
+			break;
+		case 2:
+			capabilityPointer = PCIR_CAP_PTR_2;
+			break;
+		default:
+			return ENXIO;
+	}
+	capabilityPointer = pci_read_config(child, capabilityPointer, 1);
+
+	while (capabilityPointer != 0) {
+		if (pci_read_config(child, capabilityPointer + PCICAP_ID, 1)
+				== capability) {
+			if (_capabilityRegister != NULL)
+				*_capabilityRegister = capabilityPointer;
+			return 0;
+		}
+		capabilityPointer = pci_read_config(child,
+			capabilityPointer + PCICAP_NEXTPTR, 1);
+	}
+
+	return ENOENT;
+}
+
+
+int
+pci_msi_count(device_t dev)
+{
+	return 0;
+}
+
+
+int
+pci_alloc_msi(device_t dev, int *count)
+{
+    return ENODEV;
+}
+
+
+int
+pci_release_msi(device_t dev)
+{
+    return ENODEV;
+}
+
+
+int
+pci_msix_count(device_t dev)
+{
+	return 0;
+}
+
+
+int
+pci_alloc_msix(device_t dev, int *count)
+{
+    return ENODEV;
+}
+

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat/net/if_var.h
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat/net/if_var.h	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat/net/if_var.h	2007-11-29 18:56:03 UTC (rev 23019)
@@ -186,8 +186,14 @@
 	struct	mtx if_addr_mtx;	/* mutex to protect address lists */
 
 	/* Haiku additions */
-	struct sockaddr_dl if_lladdr;
-	struct device *if_dev;
+	struct sockaddr_dl	if_lladdr;
+	char				device_name[128];
+	struct device		*root_device;
+	struct ifqueue		receive_queue;
+	sem_id				receive_sem;
+	sem_id				link_state_sem;
+	int32				open_count;
+	int32				flags;
 };
 
 typedef void if_init_f_t(void *);

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat/sys/bus.h
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat/sys/bus.h	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat/sys/bus.h	2007-11-29 18:56:03 UTC (rev 23019)
@@ -88,6 +88,13 @@
 #define	FILTER_HANDLED			B_HANDLED_INTERRUPT
 #define	FILTER_SCHEDULE_THREAD	B_INVOKE_SCHEDULER
 
+/* Note that we reversed the original order, so whenever actual (negative)
+   numbers are used in a driver, we have to change it. */
+#define BUS_PROBE_SPECIFIC		0
+#define BUS_PROBE_LOW_PRIORITY	10
+#define BUS_PROBE_DEFAULT		20
+#define BUS_PROBE_GENERIC		100
+
 int bus_generic_detach(device_t dev);
 int bus_generic_suspend(device_t dev);
 int bus_generic_resume(device_t dev);
@@ -136,6 +143,7 @@
 device_t device_add_child(device_t dev, const char *name, int unit);
 int device_delete_child(device_t dev, device_t child);
 int device_is_attached(device_t dev);
+int device_attach(device_t dev);
 int bus_generic_print_child(device_t dev, device_t child);
 void bus_generic_driver_added(device_t dev, driver_t *driver);
 int bus_generic_attach(device_t dev);

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat/sys/haiku-module.h	2007-11-29 18:56:03 UTC (rev 23019)
@@ -41,19 +41,16 @@
 	size_t softc_size;
 } driver_t;
 
-#define BUS_PROBE_LOW_PRIORITY	10
-#define BUS_PROBE_DEFAULT		20
-
 #define DRIVER_MODULE_NAME(name, busname) \
-	__fbsd_##name##busname
+	__fbsd_ ## name ## _ ## busname
 
-status_t _fbsd_init_hardware(driver_t *);
-status_t _fbsd_init_driver(driver_t *);
-void _fbsd_uninit_driver(driver_t *);
+status_t _fbsd_init_hardware(driver_t *driver);
+status_t _fbsd_init_driver(driver_t *driver);
+void _fbsd_uninit_driver(driver_t *driver);
 
-extern const char gDriverName[];
+extern const char *gDriverName;
 driver_t *__haiku_select_miibus_driver(device_t dev);
-driver_t *__haiku_probe_miibus(device_t dev, driver_t *drivers[], int count);
+driver_t *__haiku_probe_miibus(device_t dev, driver_t *drivers[]);
 
 /* we define the driver methods with HAIKU_FBSD_DRIVER_GLUE to
  * force the rest of the stuff to be linked back with the driver.
@@ -61,10 +58,10 @@
  * the final binary, gcc 4.x rightfuly doesn't. */
 
 #define HAIKU_FBSD_DRIVER_GLUE(publicname, name, busname)				\
-	extern const char *gDevNameList[];									\
+	extern const char *gDeviceNameList[];								\
 	extern device_hooks gDeviceHooks;									\
 	extern driver_t *DRIVER_MODULE_NAME(name, busname);					\
-	const char gDriverName[] = #publicname;								\
+	const char *gDriverName = #publicname;								\
 	int32 api_version = B_CUR_DRIVER_API_VERSION;						\
 	status_t init_hardware()											\
 	{																	\
@@ -77,14 +74,14 @@
 	void uninit_driver()												\
 		{ _fbsd_uninit_driver(DRIVER_MODULE_NAME(name, busname)); }		\
 	const char **publish_devices()										\
-		{ return gDevNameList; }										\
+		{ return gDeviceNameList; }										\
 	device_hooks *find_device(const char *name)							\
 		{ return &gDeviceHooks; }
 
-#define HAIKU_FBSD_RETURN_MII_DRIVER(drivers, count)			\
+#define HAIKU_FBSD_RETURN_MII_DRIVER(drivers)					\
 	driver_t *__haiku_select_miibus_driver(device_t dev)		\
 	{															\
-		return __haiku_probe_miibus(dev, drivers, count);		\
+		return __haiku_probe_miibus(dev, drivers);				\
 	}
 
 #define HAIKU_FBSD_MII_DRIVER(name)								\
@@ -92,13 +89,14 @@
 	driver_t *__haiku_select_miibus_driver(device_t dev)		\
 	{															\
 		driver_t *drivers[] = {									\
-			DRIVER_MODULE_NAME(name, miibus)					\
+			DRIVER_MODULE_NAME(name, miibus),					\
+			NULL												\
 		};														\
-		return __haiku_probe_miibus(dev, drivers, 1);			\
+		return __haiku_probe_miibus(dev, drivers);				\
 	}
 
 #define NO_HAIKU_FBSD_MII_DRIVER()								\
-	HAIKU_FBSD_RETURN_MII_DRIVER(NULL, 0)
+	HAIKU_FBSD_RETURN_MII_DRIVER(NULL)
 
 extern spinlock __haiku_intr_spinlock;
 extern int __haiku_disable_interrupts(device_t dev);

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat.c
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat.c	2007-11-28 22:19:24 UTC (rev 23018)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat.c	2007-11-29 18:56:03 UTC (rev 23019)
@@ -14,204 +14,88 @@
 #include &lt;image.h&gt;
 
 #include &lt;compat/machine/resource.h&gt;
-#include &lt;compat/dev/pci/pcireg.h&gt;
-#include &lt;compat/dev/pci/pcivar.h&gt;
+#include &lt;compat/dev/mii/mii.h&gt;
 #include &lt;compat/sys/bus.h&gt;
 
 #include &lt;compat/dev/mii/miivar.h&gt;
 
-//#define DEBUG_PCI
-#ifdef DEBUG_PCI
-#	define TRACE_PCI(dev, format, args...) device_printf(dev, format , ##args)
-#else
-#	define TRACE_PCI(dev, format, args...) do { } while (0)
-#endif
 
-
 spinlock __haiku_intr_spinlock;
 
 struct net_stack_module_info *gStack;
 pci_module_info *gPci;
 
+static struct list sRootDevices;
+static int sNextUnit;
 
-//	#pragma mark - PCI
 
+//	#pragma mark - private functions
 
-uint32_t
-pci_read_config(device_t dev, int offset, int size)
-{
-	uint32_t value = gPci-&gt;read_pci_config(NETDEV(dev)-&gt;pci_info.bus,
-		NETDEV(dev)-&gt;pci_info.device, NETDEV(dev)-&gt;pci_info.function,
-		offset, size);
-	TRACE_PCI(dev, &quot;pci_read_config(%i, %i) = 0x%x\n&quot;, offset, size, value);
-	return value;
-}
 
-
-void
-pci_write_config(device_t dev, int offset, uint32_t value, int size)
+static device_t
+init_device(device_t device, driver_t *driver)
 {
-	TRACE_PCI(dev, &quot;pci_write_config(%i, 0x%x, %i)\n&quot;, offset, value, size);
+	list_init_etc(&amp;device-&gt;children, offsetof(struct device, link));
+	device-&gt;unit = sNextUnit++;
 
-	gPci-&gt;write_pci_config(NETDEV(dev)-&gt;pci_info.bus,
-		NETDEV(dev)-&gt;pci_info.device, NETDEV(dev)-&gt;pci_info.function,
-		offset, size, value);
-}
+	if (driver != NULL &amp;&amp; device_set_driver(device, driver) &lt; 0)
+		return NULL;
 
-
-uint16_t
-pci_get_vendor(device_t dev)
-{
-	return pci_read_config(dev, PCI_vendor_id, 2);
+	return device;
 }
 
 
-uint16_t
-pci_get_device(device_t dev)
+static device_t
+new_device(driver_t *driver)
 {
-	return pci_read_config(dev, PCI_device_id, 2);
-}
+	device_t dev = malloc(sizeof(struct device));
+	if (dev == NULL)
+		return NULL;
 
+	memset(dev, 0, sizeof(struct device));
 
-uint16_t
-pci_get_subvendor(device_t dev)
-{
-	return pci_read_config(dev, PCI_subsystem_vendor_id, 2);
-}
-
-
-uint16_t
-pci_get_subdevice(device_t dev)
-{
-	return pci_read_config(dev, PCI_subsystem_id, 2);
-}
-
-
-uint8_t
-pci_get_revid(device_t dev)
-{
-	return pci_read_config(dev, PCI_revision, 1);
-}
-
-
-static void
-pci_set_command_bit(device_t dev, uint16_t bit)
-{
-	uint16_t command = pci_read_config(dev, PCI_command, 2);
-	pci_write_config(dev, PCI_command, command | bit, 2);
-}
-
-
-int
-pci_enable_busmaster(device_t dev)
-{
-	pci_set_command_bit(dev, PCI_command_master);
-	return 0;
-}
-
-
-int
-pci_enable_io(device_t dev, int space)
-{
-	/* adapted from FreeBSD's pci_enable_io_method */
-	int bit = 0;
-
-	switch (space) {
-		case SYS_RES_IOPORT:
-			bit = PCI_command_io;
-			break;
-		case SYS_RES_MEMORY:
-			bit = PCI_command_memory;
-			break;
-		default:
-			return EINVAL;
+	if (init_device(dev, driver) == NULL) {
+		free(dev);
+		return NULL;
 	}
 
-	pci_set_command_bit(dev, bit);
-	if (pci_read_config(dev, PCI_command, 2) &amp; bit)
-		return 0;
-
-	device_printf(dev, &quot;pci_enable_io(%d) failed.\n&quot;, space);
-
-	return ENXIO;
+	return dev;
 }
 
 
-int
-pci_find_extcap(device_t child, int capability, int *_capabilityRegister)
+static image_id
+find_own_image()
 {
-	uint8 capabilityPointer;
-	uint8 headerType;
-	uint16 status;
-
-	status = pci_read_config(child, PCIR_STATUS, 2);
-	if ((status &amp; PCIM_STATUS_CAPPRESENT) == 0)
-		return ENXIO;
-
-	headerType = pci_read_config(child, PCI_header_type, 1);
-	switch (headerType &amp; PCIM_HDRTYPE) {
-		case 0:
-		case 1:
-			capabilityPointer = PCIR_CAP_PTR;
-			break;
-		case 2:
-			capabilityPointer = PCIR_CAP_PTR_2;
-			break;
-		default:
-			return ENXIO;
-	}
-	capabilityPointer = pci_read_config(child, capabilityPointer, 1);
-
-	while (capabilityPointer != 0) {
-		if (pci_read_config(child, capabilityPointer + PCICAP_ID, 1)
-				== capability) {
-			if (_capabilityRegister != NULL)
-				*_capabilityRegister = capabilityPointer;
-			return 0;
+	int32 cookie = 0;
+	image_info info;
+	while (get_next_image_info(B_SYSTEM_TEAM, &amp;cookie, &amp;info) == B_OK) {
+		if (((uint32)info.text &lt;= (uint32)find_own_image
+			&amp;&amp; (uint32)info.text + (uint32)info.text_size
+					&gt; (uint32)find_own_image)) {
+			// found our own image
+			return info.id;
 		}
-		capabilityPointer = pci_read_config(child,
-			capabilityPointer + PCICAP_NEXTPTR, 1);
 	}
 
-	return ENOENT;
+	return B_ENTRY_NOT_FOUND;
 }
 
 
-int
-pci_msi_count(device_t dev)
+static device_method_signature_t
+resolve_method(driver_t *driver, const char *name)
 {
-	return 0;
-}
+	device_method_signature_t method = NULL;
+	int i;
 
+	for (i = 0; method == NULL &amp;&amp; driver-&gt;methods[i].name != NULL; i++) {
+		if (strcmp(driver-&gt;methods[i].name, name) == 0)
+			method = driver-&gt;methods[i].method;
+	}
 
-int
-pci_alloc_msi(device_t dev, int *count)
-{
-    return ENODEV;
+	return method;
 }
 
 
-int
-pci_release_msi(device_t dev)
-{
-    return ENODEV;
-}
-
-
-int
-pci_msix_count(device_t dev)
-{
-	return 0;
-}
-
-
-int
-pci_alloc_msix(device_t dev, int *count)
-{
-    return ENODEV;
-}
-
-
 //	#pragma mark - Device
 
 
@@ -251,7 +135,7 @@
 	va_list vl;
 
 	va_start(vl, format);
-	driver_vprintf_etc(dev-&gt;dev_name, format, vl);
+	driver_vprintf_etc(dev-&gt;device_name, format, vl);
 	va_end(vl);
 	return 0;
 }
@@ -300,22 +184,13 @@
 }
 
 
-void
-device_sprintf_name(device_t dev, const char *format, ...)
-{
-	va_list vl;
-	va_start(vl, format);
-	vsnprintf(dev-&gt;dev_name, sizeof(dev-&gt;dev_name), format, vl);
-	va_end(vl);
-}
-
-
 const char *
 device_get_name(device_t dev)
 {
-	if (dev)
-		return dev-&gt;dev_name;
-	return NULL;
+	if (dev == NULL)
+		return NULL;
+
+	return dev-&gt;device_name;
 }
 
 
@@ -340,18 +215,6 @@
 }
 
 
-device_t
-init_device(device_t dev, driver_t *driver)
-{
-	list_init_etc(&amp;dev-&gt;children, offsetof(struct device, link));
-
-	if (driver != NULL &amp;&amp; device_set_driver(dev, driver) &lt; 0)
-		return NULL;
-
-	return dev;
-}
-

[... truncated: 1550 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004880.html">[Haiku-commits] r23018 - haiku/trunk/src/kits/interface
</A></li>
	<LI>Next message: <A HREF="004884.html">[Haiku-commits] r23020 -	haiku/trunk/src/add-ons/kernel/drivers/network/ipro100/dev/fxp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4883">[ date ]</a>
              <a href="thread.html#4883">[ thread ]</a>
              <a href="subject.html#4883">[ subject ]</a>
              <a href="author.html#4883">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
