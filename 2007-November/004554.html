<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22782 - haiku/trunk/src/bin/zip
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22782%20-%20haiku/trunk/src/bin/zip&In-Reply-To=%3C200711010127.lA11RYdf001822%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="004555.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22782 - haiku/trunk/src/bin/zip</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22782%20-%20haiku/trunk/src/bin/zip&In-Reply-To=%3C200711010127.lA11RYdf001822%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22782 - haiku/trunk/src/bin/zip">korli at mail.berlios.de
       </A><BR>
    <I>Thu Nov  1 02:27:34 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="004555.html">[Haiku-commits] r22783 - haiku/trunk/src/system/libroot/os/arch/m68k
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4554">[ date ]</a>
              <a href="thread.html#4554">[ thread ]</a>
              <a href="subject.html#4554">[ subject ]</a>
              <a href="author.html#4554">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2007-11-01 02:27:31 +0100 (Thu, 01 Nov 2007)
New Revision: 22782
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22782&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22782&amp;view=rev</A>

Added:
   haiku/trunk/src/bin/zip/beos_.c
   haiku/trunk/src/bin/zip/crypt_.c
   haiku/trunk/src/bin/zip/fileio_.c
   haiku/trunk/src/bin/zip/util_.c
   haiku/trunk/src/bin/zip/zipfile_.c
Removed:
   haiku/trunk/src/bin/zip/bedefs.c
Modified:
   haiku/trunk/src/bin/zip/Jamfile
   haiku/trunk/src/bin/zip/api.c
   haiku/trunk/src/bin/zip/api.h
   haiku/trunk/src/bin/zip/beos.c
   haiku/trunk/src/bin/zip/crc32.c
   haiku/trunk/src/bin/zip/crctab.c
   haiku/trunk/src/bin/zip/crypt.c
   haiku/trunk/src/bin/zip/crypt.h
   haiku/trunk/src/bin/zip/deflate.c
   haiku/trunk/src/bin/zip/ebcdic.h
   haiku/trunk/src/bin/zip/fileio.c
   haiku/trunk/src/bin/zip/globals.c
   haiku/trunk/src/bin/zip/revision.h
   haiku/trunk/src/bin/zip/tailor.h
   haiku/trunk/src/bin/zip/trees.c
   haiku/trunk/src/bin/zip/ttyio.c
   haiku/trunk/src/bin/zip/ttyio.h
   haiku/trunk/src/bin/zip/util.c
   haiku/trunk/src/bin/zip/zip.c
   haiku/trunk/src/bin/zip/zip.h
   haiku/trunk/src/bin/zip/zipcloak.c
   haiku/trunk/src/bin/zip/ziperr.h
   haiku/trunk/src/bin/zip/zipfile.c
   haiku/trunk/src/bin/zip/zipnote.c
   haiku/trunk/src/bin/zip/zipsplit.c
   haiku/trunk/src/bin/zip/zipup.c
Log:
updated zip to version 2.32


Modified: haiku/trunk/src/bin/zip/Jamfile
===================================================================
--- haiku/trunk/src/bin/zip/Jamfile	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/Jamfile	2007-11-01 01:27:31 UTC (rev 22782)
@@ -3,40 +3,54 @@
 local zip_rsrc = [ FGristFiles zip.rsrc ] ;
 ResComp $(zip_rsrc) : [ FGristFiles zip.rdef ] ;
 
-StaticLibrary libzip.a : 
-	zipup.c
-	crypt.c
+local common_files =
+	globals.c
+	;
+
+local common_files2 = 
+	crctab.c
 	ttyio.c
+	;
+
+local util_files =
+	beos_.c
+	fileio_.c
+	util_.c
+	zipfile_.c
+	;
+
+Objects $(common_files) $(common_files2) $(util_files) ;
+
+BinCommand zip :
+	[ FGristFiles $(common_files:S=.o) $(common_files2:S=.o) ]
 	beos.c
-	globals.c
+	crc32.c
+	crypt.c
 	deflate.c
 	fileio.c
+	trees.c
 	util.c
-	crc32.c
+	zip.c
 	zipfile.c
-	trees.c
-	crctab.c
+	zipup.c
+	: be : zip.rsrc
 ;
 
-BinCommand zip :
-	zip.c
-	: libzip.a be : zip.rsrc
-;
-
 BinCommand zipcloak :
+	crypt_.c
 	zipcloak.c
-	bedefs.c
-	: libzip.a : zip.rsrc
+	[ FGristFiles $(common_files:S=.o) $(common_files2:S=.o) $(util_files:S=.o) ]
+	: be : zip.rsrc
 ;
 
 BinCommand zipnote :
 	zipnote.c
-	bedefs.c
-	: libzip.a be : zip.rsrc
+	[ FGristFiles $(common_files:S=.o) $(util_files:S=.o) ]
+	: be : zip.rsrc
 ;
 
 BinCommand zipsplit :
 	zipsplit.c
-	bedefs.c
-	: libzip.a be : zip.rsrc
+	[ FGristFiles $(common_files:S=.o) $(util_files:S=.o) ]
+	: be : zip.rsrc
 ;

Modified: haiku/trunk/src/bin/zip/api.c
===================================================================
--- haiku/trunk/src/bin/zip/api.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/api.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,10 +1,10 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2005 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
+  See the accompanying file LICENSE, version 2004-May-22 or later
   (the contents of which are also included in zip.h) for terms of use.
   If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /*---------------------------------------------------------------------------
 
@@ -58,6 +58,31 @@
 
 int ZipRet;
 
+/* ------------------------------------------------- */
+/* Visual Basic converts strings from VB native Unicode to
+   byte strings when passing to dlls.  It seems that any
+   strings pointed to in structures are converted and the
+   conversion passed to the dll, but when the dll call
+   returns the converted strings are garbage collected
+   unless the debugger prevents it.  This leaves the
+   pointers going to memory that may have been reused
+   by the time the following dll call is made.  This
+   affects the strings in the Options stucture.
+
+   The following kluge stores the strings locally in
+   the dll between calls.  A better fix is to redesign
+   the api interface so that strings in structures are
+   removed or are passed in the same call they are used.  EG
+
+/* oversized to be sure */
+#define MAX_ZIP_DATE_LEN 50
+#define MAX_ZIP_DIR_PATH_LEN 4098
+
+char szDate[MAX_ZIP_DATE_LEN + 1];
+char szRootDir[MAX_ZIP_DIR_PATH_LEN + 1];
+char szTempDir[MAX_ZIP_DIR_PATH_LEN + 1];   
+/* ------------------------------------------------- */
+
 /* Local forward declarations */
 extern int  zipmain OF((int, char **));
 int AllocMemory(int, char *, char *);
@@ -106,7 +131,27 @@
 
 BOOL EXPENTRY ZpSetOptions(LPZPOPT Opts)
 {
+/* copy the structure including pointers to strings */
 Options = *Opts;
+
+/* fix for calling dll from VB - 2002-11-25 */
+/* make copies of strings in structure if not NULL passed for empty string */
+if (Options.Date) {
+  szDate[0] = '\0';
+  strncat(szDate, Options.Date, MAX_ZIP_DATE_LEN);
+  Options.Date = szDate;
+}
+if (Options.szRootDir) {
+  szRootDir[0] = '\0';
+  strncat(szRootDir, Options.szRootDir, MAX_ZIP_DIR_PATH_LEN);
+  Options.szRootDir = szRootDir;
+}
+if (Options.szTempDir) {
+  szTempDir[0] = '\0';
+  strncat(szTempDir, Options.szTempDir, MAX_ZIP_DIR_PATH_LEN);
+  Options.szTempDir = szTempDir;
+}
+
 return TRUE;
 }
 
@@ -258,18 +303,6 @@
       return ZE_MEM;
    argCee++;
    }
-if (Options.fRecurse == 1) /* recurse into subdirectories -r */
-   {
-   if (AllocMemory(argCee, &quot;-r&quot;, &quot;Recurse -r&quot;) != ZE_OK)
-      return ZE_MEM;
-   argCee++;
-   }
-else if (Options.fRecurse == 2) /* recurse into subdirectories -R */
-   {
-   if (AllocMemory(argCee, &quot;-R&quot;, &quot;Recurse -R&quot;) != ZE_OK)
-      return ZE_MEM;
-   argCee++;
-   }
 if (Options.fSystem)  /* include system and hidden files -S */
    {
    if (AllocMemory(argCee, &quot;-S&quot;, &quot;System&quot;) != ZE_OK)
@@ -320,7 +353,7 @@
       return ZE_MEM;
    argCee++;
    }
-#ifdef WIN32
+#ifdef NTSD_EAS /* was WIN32 1/22/2005 EG */
 if (Options.fPrivilege)  /* Use privileges -! */
    {
    if (AllocMemory(argCee, &quot;-!&quot;, &quot;Privileges&quot;) != ZE_OK)
@@ -344,6 +377,19 @@
       return ZE_MEM;
    argCee++;
    }
+/* -r and -R moved down here to avoid VB problem 1/31/2005 EG */
+if (Options.fRecurse == 1) /* recurse into subdirectories -r */
+   {
+   if (AllocMemory(argCee, &quot;-r&quot;, &quot;Recurse -r&quot;) != ZE_OK)
+      return ZE_MEM;
+   argCee++;
+   }
+else if (Options.fRecurse == 2) /* recurse into subdirectories -R */
+   {
+   if (AllocMemory(argCee, &quot;-R&quot;, &quot;Recurse -R&quot;) != ZE_OK)
+      return ZE_MEM;
+   argCee++;
+   }
 if (AllocMemory(argCee, C.lpszZipFN, &quot;Zip file name&quot;) != ZE_OK)
    return ZE_MEM;
 argCee++;

Modified: haiku/trunk/src/bin/zip/api.h
===================================================================
--- haiku/trunk/src/bin/zip/api.h	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/api.h	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,10 +1,10 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2005 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
+  See the accompanying file LICENSE, version 2004-May-22 or later
   (the contents of which are also included in zip.h) for terms of use.
   If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /* Only the Windows DLL is currently supported */
 #ifndef _ZIPAPI_H

Deleted: haiku/trunk/src/bin/zip/bedefs.c

Modified: haiku/trunk/src/bin/zip/beos.c
===================================================================
--- haiku/trunk/src/bin/zip/beos.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/beos.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,10 +1,10 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2005 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
+  See the accompanying file LICENSE, version 2004-May-22 or later
   (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  If, for some reason, all these files are missing, the Info-ZIP license
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /*
 
@@ -283,8 +283,8 @@
    a file size of -1 */
 {
   struct stat s;        /* results of stat() */
-  char name[FNMAX];
-  int len = strlen(f);
+  char *name;
+  unsigned int len = strlen(f);
 
   if (f == label) {
     if (a != NULL)
@@ -295,18 +295,26 @@
       t-&gt;atime = t-&gt;mtime = t-&gt;ctime = label_utim;
     return label_time;
   }
+
+  if ((name = malloc(len + 1)) == NULL) {
+    ZIPERR(ZE_MEM, &quot;filetime&quot;);
+  }
   strcpy(name, f);
   if (name[len - 1] == '/')
     name[len - 1] = '\0';
   /* not all systems allow stat'ing a file with / appended */
   if (strcmp(f, &quot;-&quot;) == 0) {
-    if (fstat(fileno(stdin), &amp;s) != 0)
+    if (fstat(fileno(stdin), &amp;s) != 0) {
+      free(name);
       error(&quot;fstat(stdin)&quot;);
-  } else if (LSSTAT(name, &amp;s) != 0)
+    }
+  } else if (LSSTAT(name, &amp;s) != 0) {
              /* Accept about any file kind including directories
               * (stored with trailing / with -r option)
               */
+    free(name);
     return 0;
+  }
 
   if (a != NULL) {
     *a = ((ulg)s.st_mode &lt;&lt; 16) | !(s.st_mode &amp; S_IWRITE);
@@ -322,6 +330,8 @@
     t-&gt;ctime = s.st_mtime;   /* best guess (s.st_ctime: last status change!) */
   }
 
+  free(name);
+
   return unix2dostime(&amp;s.st_mtime);
 }
 
@@ -663,9 +673,11 @@
 #define EB_L_BE_SIZE    (EB_HEADSIZE + EB_L_BE_LEN) /* + attr size */
 #define EB_C_BE_SIZE    (EB_HEADSIZE + EB_C_BE_LEN)
 
-#define MEMCOMPRESS_HEADER      6   /* ush compression type, ulg CRC */
-#define DEFLAT_WORSTCASE_ADD    5   /* byte blocktype, 2 * ush blocklength */
-#define MEMCOMPRESS_OVERHEAD    (MEMCOMPRESS_HEADER + DEFLAT_WORSTCASE_ADD)
+/* maximum memcompress overhead is the sum of the compression header length */
+/* (6 = ush compression type, ulg CRC) and the worstcase deflate overhead   */
+/* when uncompressible data are kept in 2 &quot;stored&quot; blocks (5 per block =    */
+/* byte blocktype + 2 * ush blocklength) */
+#define MEMCOMPRESS_OVERHEAD    (EB_MEMCMPR_HSIZ + EB_DEFLAT_EXTRA)
 
 local int add_Be_ef( struct zlist far *z )
 {

Added: haiku/trunk/src/bin/zip/beos_.c
===================================================================
--- haiku/trunk/src/bin/zip/beos_.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/beos_.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -0,0 +1,2 @@
+#define UTIL
+#include &quot;beos.c&quot;

Modified: haiku/trunk/src/bin/zip/crc32.c
===================================================================
--- haiku/trunk/src/bin/zip/crc32.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/crc32.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,17 +1,17 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2005 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
+  See the accompanying file LICENSE, version 2004-May-22 or later
   (the contents of which are also included in zip.h) for terms of use.
   If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /* crc32.c -- compute the CRC-32 of a data stream
  * Copyright (C) 1995 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* $Id: crc32.c,v 1.1 2002/09/21 16:08:49 darkwyrm Exp $ */
+/* $Id$ */
 
 #define __CRC32_C       /* identifies this source module */
 

Modified: haiku/trunk/src/bin/zip/crctab.c
===================================================================
--- haiku/trunk/src/bin/zip/crctab.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/crctab.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,17 +1,17 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2005 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
+  See the accompanying file LICENSE, version 2004-May-22 or later
   (the contents of which are also included in zip.h) for terms of use.
   If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /* crctab.c -- supply the CRC table needed for CRC-32 calculations.
  * Copyright (C) 1995 Mark Adler
  * For conditions of distribution and use, see copyright notice in zlib.h
  */
 
-/* $Id: crctab.c,v 1.1 2002/09/21 16:08:49 darkwyrm Exp $ */
+/* $Id$ */
 
 /*
   Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:

Modified: haiku/trunk/src/bin/zip/crypt.c
===================================================================
--- haiku/trunk/src/bin/zip/crypt.c	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/crypt.c	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,20 +1,598 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2006 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>
+  See the accompanying file LICENSE, version 2005-Feb-10 or later
+  (the contents of which are also included in (un)zip.h) for terms of use.
+  If, for some reason, all these files are missing, the Info-ZIP license
+  also may be found at:  <A HREF="ftp://ftp.info-zip.org/pub/infozip/license.html">ftp://ftp.info-zip.org/pub/infozip/license.html</A>
 */
 /*
-   crypt.c (dummy version) by Info-ZIP.      Last revised: 15 Aug 98
+  crypt.c (full version) by Info-ZIP.      Last revised:  [see crypt.h]
 
-   This is a non-functional version of Info-ZIP's crypt.c encryption/
-   decryption code for Zip, ZipCloak, UnZip and fUnZip.  This file is
-   not copyrighted and may be distributed freely. :-)  See the &quot;WHERE&quot;
-   file for sites from which to obtain the full encryption/decryption
-   sources (zcrypt28.zip or later).
+  The main encryption/decryption source code for Info-Zip software was
+  originally written in Europe.  To the best of our knowledge, it can
+  be freely distributed in both source and object forms from any country,
+  including the USA under License Exception TSU of the U.S. Export
+  Administration Regulations (section 740.13(e)) of 6 June 2002.
+
+  NOTE on copyright history:
+  Previous versions of this source package (up to version 2.8) were
+  not copyrighted and put in the public domain.  If you cannot comply
+  with the Info-Zip LICENSE, you may want to look for one of those
+  public domain versions.
  */
 
+/*
+  This encryption code is a direct transcription of the algorithm from
+  Roger Schlafly, described by Phil Katz in the file appnote.txt.  This
+  file (appnote.txt) is distributed with the PKZIP program (even in the
+  version without encryption capabilities).
+ */
+
+#define ZCRYPT_INTERNAL
+#include &quot;zip.h&quot;
+#include &quot;crypt.h&quot;
+#include &quot;ttyio.h&quot;
+
+#if CRYPT
+
+#ifndef FALSE
+#  define FALSE 0
+#endif
+
+#ifdef ZIP
+   /* For the encoding task used in Zip (and ZipCloak), we want to initialize
+      the crypt algorithm with some reasonably unpredictable bytes, see
+      the crypthead() function. The standard rand() library function is
+      used to supply these `random' bytes, which in turn is initialized by
+      a srand() call. The srand() function takes an &quot;unsigned&quot; (at least 16bit)
+      seed value as argument to determine the starting point of the rand()
+      pseudo-random number generator.
+      This seed number is constructed as &quot;Seed = Seed1 .XOR. Seed2&quot; with
+      Seed1 supplied by the current time (= &quot;(unsigned)time()&quot;) and Seed2
+      as some (hopefully) nondeterministic bitmask. On many (most) systems,
+      we use some &quot;process specific&quot; number, as the PID or something similar,
+      but when nothing unpredictable is available, a fixed number may be
+      sufficient.
+      NOTE:
+      1.) This implementation requires the availability of the following
+          standard UNIX C runtime library functions: time(), rand(), srand().
+          On systems where some of them are missing, the environment that
+          incorporates the crypt routines must supply suitable replacement
+          functions.
+      2.) It is a very bad idea to use a second call to time() to set the
+          &quot;Seed2&quot; number! In this case, both &quot;Seed1&quot; and &quot;Seed2&quot; would be
+          (almost) identical, resulting in a (mostly) &quot;zero&quot; constant seed
+          number passed to srand().
+
+      The implementation environment defined in the &quot;zip.h&quot; header should
+      supply a reasonable definition for ZCR_SEED2 (an unsigned number; for
+      most implementations of rand() and srand(), only the lower 16 bits are
+      significant!). An example that works on many systems would be
+           &quot;#define ZCR_SEED2  (unsigned)getpid()&quot;.
+      The default definition for ZCR_SEED2 supplied below should be regarded
+      as a fallback to allow successful compilation in &quot;beta state&quot;
+      environments.
+    */
+#  include &lt;time.h&gt;     /* time() function supplies first part of crypt seed */
+   /* &quot;last resort&quot; source for second part of crypt seed pattern */
+#  ifndef ZCR_SEED2
+#    define ZCR_SEED2 (unsigned)3141592654L     /* use PI as default pattern */
+#  endif
+#  ifdef GLOBAL         /* used in Amiga system headers, maybe others too */
+#    undef GLOBAL
+#  endif
+#  define GLOBAL(g) g
+#else /* !ZIP */
+#  define GLOBAL(g) G.g
+#endif /* ?ZIP */
+
+
+#ifdef UNZIP
+   /* char *key = (char *)NULL; moved to globals.h */
+#  ifndef FUNZIP
+     local int testp OF((__GPRO__ ZCONST uch *h));
+     local int testkey OF((__GPRO__ ZCONST uch *h, ZCONST char *key));
+#  endif
+#endif /* UNZIP */
+
+#ifndef UNZIP             /* moved to globals.h for UnZip */
+   local ulg keys[3];     /* keys defining the pseudo-random sequence */
+#endif /* !UNZIP */
+
+#ifndef Trace
+#  ifdef CRYPT_DEBUG
+#    define Trace(x) fprintf x
+#  else
+#    define Trace(x)
+#  endif
+#endif
+
+#ifndef CRC_32_TAB
+#  define CRC_32_TAB     crc_32_tab
+#endif
+
+#define CRC32(c, b) (CRC_32_TAB[((int)(c) ^ (b)) &amp; 0xff] ^ ((c) &gt;&gt; 8))
+
+/***********************************************************************
+ * Return the next byte in the pseudo-random sequence
+ */
+int decrypt_byte(__G)
+    __GDEF
+{
+    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
+                     * unpredictable manner on 16-bit systems; not a problem
+                     * with any known compiler so far, though */
+
+    temp = ((unsigned)GLOBAL(keys[2]) &amp; 0xffff) | 2;
+    return (int)(((temp * (temp ^ 1)) &gt;&gt; 8) &amp; 0xff);
+}
+
+/***********************************************************************
+ * Update the encryption keys with the next byte of plain text
+ */
+int update_keys(__G__ c)
+    __GDEF
+    int c;                      /* byte of plain text */
+{
+    GLOBAL(keys[0]) = CRC32(GLOBAL(keys[0]), c);
+    GLOBAL(keys[1]) += GLOBAL(keys[0]) &amp; 0xff;
+    GLOBAL(keys[1]) = GLOBAL(keys[1]) * 134775813L + 1;
+    {
+      register int keyshift = (int)(GLOBAL(keys[1]) &gt;&gt; 24);
+      GLOBAL(keys[2]) = CRC32(GLOBAL(keys[2]), keyshift);
+    }
+    return c;
+}
+
+
+/***********************************************************************
+ * Initialize the encryption keys and the random header according to
+ * the given password.
+ */
+void init_keys(__G__ passwd)
+    __GDEF
+    ZCONST char *passwd;        /* password string with which to modify keys */
+{
+    GLOBAL(keys[0]) = 305419896L;
+    GLOBAL(keys[1]) = 591751049L;
+    GLOBAL(keys[2]) = 878082192L;
+    while (*passwd != '\0') {
+        update_keys(__G__ (int)*passwd);
+        passwd++;
+    }
+}
+
+
+#ifdef ZIP
+
+/***********************************************************************
+ * Write encryption header to file zfile using the password passwd
+ * and the cyclic redundancy check crc.
+ */
+void crypthead(passwd, crc, zfile)
+    ZCONST char *passwd;         /* password string */
+    ulg crc;                     /* crc of file being encrypted */
+    FILE *zfile;                 /* where to write header */
+{
+    int n;                       /* index in random header */
+    int t;                       /* temporary */
+    int c;                       /* random byte */
+    int ztemp;                   /* temporary for zencoded value */
+    uch header[RAND_HEAD_LEN-2]; /* random header */
+    static unsigned calls = 0;   /* ensure different random header each time */
+
+    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
+     * output of rand() to get less predictability, since rand() is
+     * often poorly implemented.
+     */
+    if (++calls == 1) {
+        srand((unsigned)time(NULL) ^ ZCR_SEED2);
+    }
+    init_keys(passwd);
+    for (n = 0; n &lt; RAND_HEAD_LEN-2; n++) {
+        c = (rand() &gt;&gt; 7) &amp; 0xff;
+        header[n] = (uch)zencode(c, t);
+    }
+    /* Encrypt random header (last two bytes is high word of crc) */
+    init_keys(passwd);
+    for (n = 0; n &lt; RAND_HEAD_LEN-2; n++) {
+        ztemp = zencode(header[n], t);
+        putc(ztemp, zfile);
+    }
+    ztemp = zencode((int)(crc &gt;&gt; 16) &amp; 0xff, t);
+    putc(ztemp, zfile);
+    ztemp = zencode((int)(crc &gt;&gt; 24) &amp; 0xff, t);
+    putc(ztemp, zfile);
+}
+
+
+#ifdef UTIL
+
+/***********************************************************************
+ * Encrypt the zip entry described by z from file source to file dest
+ * using the password passwd.  Return an error code in the ZE_ class.
+ */
+int zipcloak(z, source, dest, passwd)
+    struct zlist far *z;    /* zip entry to encrypt */
+    FILE *source, *dest;    /* source and destination files */
+    ZCONST char *passwd;    /* password string */
+{
+    int c;                  /* input byte */
+    int res;                /* result code */
+    ulg n;                  /* holds offset and counts size */
+    ush flag;               /* previous flags */
+    int t;                  /* temporary */
+    int ztemp;              /* temporary storage for zencode value */
+
+    /* Set encrypted bit, clear extended local header bit and write local
+       header to output file */
+    if ((n = (ulg)ftell(dest)) == (ulg)-1L) return ZE_TEMP;
+    z-&gt;off = n;
+    flag = z-&gt;flg;
+    z-&gt;flg |= 1,  z-&gt;flg &amp;= ~8;
+    z-&gt;lflg |= 1, z-&gt;lflg &amp;= ~8;
+    z-&gt;siz += RAND_HEAD_LEN;
+    if ((res = putlocal(z, dest)) != ZE_OK) return res;
+
+    /* Initialize keys with password and write random header */
+    crypthead(passwd, z-&gt;crc, dest);
+
+    /* Skip local header in input file */
+    if (fseek(source, (long)((4 + LOCHEAD) + (ulg)z-&gt;nam + (ulg)z-&gt;ext),
+              SEEK_CUR)) {
+        return ferror(source) ? ZE_READ : ZE_EOF;
+    }
+
+    /* Encrypt data */
+    for (n = z-&gt;siz - RAND_HEAD_LEN; n; n--) {
+        if ((c = getc(source)) == EOF) {
+            return ferror(source) ? ZE_READ : ZE_EOF;
+        }
+        ztemp = zencode(c, t);
+        putc(ztemp, dest);
+    }
+    /* Skip extended local header in input file if there is one */
+    if ((flag &amp; 8) != 0 &amp;&amp; fseek(source, 16L, SEEK_CUR)) {
+        return ferror(source) ? ZE_READ : ZE_EOF;
+    }
+    if (fflush(dest) == EOF) return ZE_TEMP;
+
+    /* Update number of bytes written to output file */
+    tempzn += (4 + LOCHEAD) + z-&gt;nam + z-&gt;ext + z-&gt;siz;
+
+    return ZE_OK;
+}
+
+/***********************************************************************
+ * Decrypt the zip entry described by z from file source to file dest
+ * using the password passwd.  Return an error code in the ZE_ class.
+ */
+int zipbare(z, source, dest, passwd)
+    struct zlist far *z;  /* zip entry to encrypt */
+    FILE *source, *dest;  /* source and destination files */
+    ZCONST char *passwd;  /* password string */
+{
+#ifdef ZIP10
+    int c0                /* byte preceding the last input byte */
+#endif
+    int c1;               /* last input byte */
+    ulg offset;           /* used for file offsets */
+    ulg size;             /* size of input data */
+    int r;                /* size of encryption header */
+    int res;              /* return code */
+    ush flag;             /* previous flags */
+
+    /* Save position and skip local header in input file */
+    if ((offset = (ulg)ftell(source)) == (ulg)-1L ||
+        fseek(source, (long)((4 + LOCHEAD) + (ulg)z-&gt;nam + (ulg)z-&gt;ext),
+              SEEK_CUR)) {
+        return ferror(source) ? ZE_READ : ZE_EOF;
+    }
+    /* Initialize keys with password */
+    init_keys(passwd);
+
+    /* Decrypt encryption header, save last two bytes */
+    c1 = 0;
+    for (r = RAND_HEAD_LEN; r; r--) {
+#ifdef ZIP10
+        c0 = c1;
+#endif
+        if ((c1 = getc(source)) == EOF) {
+            return ferror(source) ? ZE_READ : ZE_EOF;
+        }
+        Trace((stdout, &quot; (%02x)&quot;, c1));
+        zdecode(c1);
+        Trace((stdout, &quot; %02x&quot;, c1));
+    }
+    Trace((stdout, &quot;\n&quot;));
+
+    /* If last two bytes of header don't match crc (or file time in the
+     * case of an extended local header), back up and just copy. For
+     * pkzip 2.0, the check has been reduced to one byte only.
+     */
+#ifdef ZIP10
+    if ((ush)(c0 | (c1&lt;&lt;8)) !=
+        (z-&gt;flg &amp; 8 ? (ush) z-&gt;tim &amp; 0xffff : (ush)(z-&gt;crc &gt;&gt; 16))) {
+#else
+    if ((ush)c1 != (z-&gt;flg &amp; 8 ? (ush) z-&gt;tim &gt;&gt; 8 : (ush)(z-&gt;crc &gt;&gt; 24))) {
+#endif
+        if (fseek(source, offset, SEEK_SET)) {
+            return ferror(source) ? ZE_READ : ZE_EOF;
+        }
+        if ((res = zipcopy(z, source, dest)) != ZE_OK) return res;
+        return ZE_MISS;
+    }
+
+    /* Clear encrypted bit and local header bit, and write local header to
+       output file */
+    if ((offset = (ulg)ftell(dest)) == (ulg)-1L) return ZE_TEMP;
+    z-&gt;off = offset;
+    flag = z-&gt;flg;
+    z-&gt;flg &amp;= ~9;
+    z-&gt;lflg &amp;= ~9;
+    z-&gt;siz -= RAND_HEAD_LEN;
+    if ((res = putlocal(z, dest)) != ZE_OK) return res;
+
+    /* Decrypt data */
+    for (size = z-&gt;siz; size; size--) {
+        if ((c1 = getc(source)) == EOF) {
+            return ferror(source) ? ZE_READ : ZE_EOF;
+        }
+        zdecode(c1);
+        putc(c1, dest);
+    }
+    /* Skip extended local header in input file if there is one */
+    if ((flag &amp; 8) != 0 &amp;&amp; fseek(source, 16L, SEEK_CUR)) {
+        return ferror(source) ? ZE_READ : ZE_EOF;
+    }
+    if (fflush(dest) == EOF) return ZE_TEMP;
+
+    /* Update number of bytes written to output file */
+    tempzn += (4 + LOCHEAD) + z-&gt;nam + z-&gt;ext + z-&gt;siz;
+
+    return ZE_OK;
+}
+
+
+#else /* !UTIL */
+
+/***********************************************************************
+ * If requested, encrypt the data in buf, and in any case call fwrite()
+ * with the arguments to zfwrite().  Return what fwrite() returns.
+ *
+ * A bug has been found when encrypting large files.  See trees.c
+ * for details and the fix.
+ */
+unsigned zfwrite(buf, item_size, nb, f)
+    zvoid *buf;                 /* data buffer */
+    extent item_size;           /* size of each item in bytes */
+    extent nb;                  /* number of items */
+    FILE *f;                    /* file to write to */
+{
+    int t;                      /* temporary */
+
+    if (key != (char *)NULL) {  /* key is the global password pointer */
+        ulg size;               /* buffer size */
+        char *p = (char*)buf;   /* steps through buffer */
+
+        /* Encrypt data in buffer */
+        for (size = item_size*(ulg)nb; size != 0; p++, size--) {
+            *p = (char)zencode(*p, t);
+        }
+    }
+    /* Write the buffer out */
+    return fwrite(buf, item_size, nb, f);
+}
+
+#endif /* ?UTIL */
+#endif /* ZIP */
+
+
+#if (defined(UNZIP) &amp;&amp; !defined(FUNZIP))
+
+/***********************************************************************
+ * Get the password and set up keys for current zipfile member.
+ * Return PK_ class error.
+ */
+int decrypt(__G__ passwrd)
+    __GDEF
+    ZCONST char *passwrd;
+{
+    ush b;
+    int n, r;
+    uch h[RAND_HEAD_LEN];
+
+    Trace((stdout, &quot;\n[incnt = %d]: &quot;, GLOBAL(incnt)));
+
+    /* get header once (turn off &quot;encrypted&quot; flag temporarily so we don't
+     * try to decrypt the same data twice) */
+    GLOBAL(pInfo-&gt;encrypted) = FALSE;
+    defer_leftover_input(__G);
+    for (n = 0; n &lt; RAND_HEAD_LEN; n++) {
+        b = NEXTBYTE;
+        h[n] = (uch)b;
+        Trace((stdout, &quot; (%02x)&quot;, h[n]));
+    }
+    undefer_input(__G);
+    GLOBAL(pInfo-&gt;encrypted) = TRUE;
+
+    if (GLOBAL(newzip)) { /* this is first encrypted member in this zipfile */
+        GLOBAL(newzip) = FALSE;
+        if (passwrd != (char *)NULL) { /* user gave password on command line */
+            if (!GLOBAL(key)) {
+                if ((GLOBAL(key) = (char *)malloc(strlen(passwrd)+1)) ==
+                    (char *)NULL)
+                    return PK_MEM2;
+                strcpy(GLOBAL(key), passwrd);
+                GLOBAL(nopwd) = TRUE;  /* inhibit password prompting! */
+            }
+        } else if (GLOBAL(key)) { /* get rid of previous zipfile's key */
+            free(GLOBAL(key));
+            GLOBAL(key) = (char *)NULL;
+        }
+    }
+
+    /* if have key already, test it; else allocate memory for it */
+    if (GLOBAL(key)) {
+        if (!testp(__G__ h))
+            return PK_COOL;   /* existing password OK (else prompt for new) */
+        else if (GLOBAL(nopwd))
+            return PK_WARN;   /* user indicated no more prompting */
+    } else if ((GLOBAL(key) = (char *)malloc(IZ_PWLEN+1)) == (char *)NULL)
+        return PK_MEM2;
+
+    /* try a few keys */
+    n = 0;
+    do {
+        r = (*G.decr_passwd)((zvoid *)&amp;G, &amp;n, GLOBAL(key), IZ_PWLEN+1,
+                             GLOBAL(zipfn), GLOBAL(filename));
+        if (r == IZ_PW_ERROR) {         /* internal error in fetch of PW */
+            free (GLOBAL(key));
+            GLOBAL(key) = NULL;
+            return PK_MEM2;
+        }
+        if (r != IZ_PW_ENTERED) {       /* user replied &quot;skip&quot; or &quot;skip all&quot; */
+            *GLOBAL(key) = '\0';        /*   We try the NIL password, ... */
+            n = 0;                      /*   and cancel fetch for this item. */
+        }
+        if (!testp(__G__ h))
+            return PK_COOL;
+        if (r == IZ_PW_CANCELALL)       /* User replied &quot;Skip all&quot; */
+            GLOBAL(nopwd) = TRUE;       /*   inhibit any further PW prompt! */
+    } while (n &gt; 0);
+
+    return PK_WARN;
+
+} /* end function decrypt() */
+
+
+
+/***********************************************************************
+ * Test the password.  Return -1 if bad, 0 if OK.
+ */
+local int testp(__G__ h)
+    __GDEF
+    ZCONST uch *h;
+{
+    int r;
+    char *key_translated;
+
+    /* On systems with &quot;obscure&quot; native character coding (e.g., EBCDIC),
+     * the first test translates the password to the &quot;main standard&quot;
+     * character coding. */
+
+#ifdef STR_TO_CP1
+    /* allocate buffer for translated password */
+    if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
+        return -1;
+    /* first try, test password translated &quot;standard&quot; charset */
+    r = testkey(__G__ h, STR_TO_CP1(key_translated, GLOBAL(key)));
+#else /* !STR_TO_CP1 */
+    /* first try, test password as supplied on the extractor's host */
+    r = testkey(__G__ h, GLOBAL(key));
+#endif /* ?STR_TO_CP1 */
+
+#ifdef STR_TO_CP2
+    if (r != 0) {
+#ifndef STR_TO_CP1
+        /* now prepare for second (and maybe third) test with translated pwd */
+        if ((key_translated = malloc(strlen(GLOBAL(key)) + 1)) == (char *)NULL)
+            return -1;
+#endif
+        /* second try, password translated to alternate (&quot;standard&quot;) charset */
+        r = testkey(__G__ h, STR_TO_CP2(key_translated, GLOBAL(key)));
+#ifdef STR_TO_CP3
+        if (r != 0)
+            /* third try, password translated to another &quot;standard&quot; charset */
+            r = testkey(__G__ h, STR_TO_CP3(key_translated, GLOBAL(key)));
+#endif
+#ifndef STR_TO_CP1
+        free(key_translated);
+#endif
+    }
+#endif /* STR_TO_CP2 */
+
+#ifdef STR_TO_CP1
+    free(key_translated);
+    if (r != 0) {
+        /* last resort, test password as supplied on the extractor's host */
+        r = testkey(__G__ h, GLOBAL(key));
+    }
+#endif /* STR_TO_CP1 */
+
+    return r;
+
+} /* end function testp() */
+
+
+local int testkey(__G__ h, key)
+    __GDEF
+    ZCONST uch *h;      /* decrypted header */
+    ZCONST char *key;   /* decryption password to test */
+{
+    ush b;
+#ifdef ZIP10
+    ush c;
+#endif
+    int n;
+    uch *p;
+    uch hh[RAND_HEAD_LEN]; /* decrypted header */
+
+    /* set keys and save the encrypted header */
+    init_keys(__G__ key);
+    memcpy(hh, h, RAND_HEAD_LEN);
+
+    /* check password */
+    for (n = 0; n &lt; RAND_HEAD_LEN; n++) {
+        zdecode(hh[n]);
+        Trace((stdout, &quot; %02x&quot;, hh[n]));
+    }
+
+    Trace((stdout,
+      &quot;\n  lrec.crc= %08lx  crec.crc= %08lx  pInfo-&gt;ExtLocHdr= %s\n&quot;,
+      GLOBAL(lrec.crc32), GLOBAL(pInfo-&gt;crc),
+      GLOBAL(pInfo-&gt;ExtLocHdr) ? &quot;true&quot;:&quot;false&quot;));
+    Trace((stdout, &quot;  incnt = %d  unzip offset into zipfile = %ld\n&quot;,
+      GLOBAL(incnt),
+      GLOBAL(cur_zipfile_bufstart)+(GLOBAL(inptr)-GLOBAL(inbuf))));
+
+    /* same test as in zipbare(): */
+
+#ifdef ZIP10 /* check two bytes */
+    c = hh[RAND_HEAD_LEN-2], b = hh[RAND_HEAD_LEN-1];
+    Trace((stdout,
+      &quot;  (c | (b&lt;&lt;8)) = %04x  (crc &gt;&gt; 16) = %04x  lrec.time = %04x\n&quot;,
+      (ush)(c | (b&lt;&lt;8)), (ush)(GLOBAL(lrec.crc32) &gt;&gt; 16),
+      ((ush)GLOBAL(lrec.last_mod_dos_datetime) &amp; 0xffff))));
+    if ((ush)(c | (b&lt;&lt;8)) != (GLOBAL(pInfo-&gt;ExtLocHdr) ?
+                           ((ush)GLOBAL(lrec.last_mod_dos_datetime) &amp; 0xffff) :
+                           (ush)(GLOBAL(lrec.crc32) &gt;&gt; 16)))
+        return -1;  /* bad */
+#else
+    b = hh[RAND_HEAD_LEN-1];
+    Trace((stdout, &quot;  b = %02x  (crc &gt;&gt; 24) = %02x  (lrec.time &gt;&gt; 8) = %02x\n&quot;,
+      b, (ush)(GLOBAL(lrec.crc32) &gt;&gt; 24),
+      ((ush)GLOBAL(lrec.last_mod_dos_datetime) &gt;&gt; 8) &amp; 0xff));
+    if (b != (GLOBAL(pInfo-&gt;ExtLocHdr) ?
+        ((ush)GLOBAL(lrec.last_mod_dos_datetime) &gt;&gt; 8) &amp; 0xff :
+        (ush)(GLOBAL(lrec.crc32) &gt;&gt; 24)))
+        return -1;  /* bad */
+#endif
+    /* password OK:  decrypt current buffer contents before leaving */
+    for (n = (long)GLOBAL(incnt) &gt; GLOBAL(csize) ?
+             (int)GLOBAL(csize) : GLOBAL(incnt),
+         p = GLOBAL(inptr); n--; p++)
+        zdecode(*p);
+    return 0;       /* OK */
+
+} /* end function testkey() */
+
+#endif /* UNZIP &amp;&amp; !FUNZIP */
+
+#else /* !CRYPT */
+
 /* something &quot;externally visible&quot; to shut up compiler/linker warnings */
 int zcr_dummy;
+
+#endif /* ?CRYPT */

Modified: haiku/trunk/src/bin/zip/crypt.h
===================================================================
--- haiku/trunk/src/bin/zip/crypt.h	2007-10-31 21:16:22 UTC (rev 22781)
+++ haiku/trunk/src/bin/zip/crypt.h	2007-11-01 01:27:31 UTC (rev 22782)
@@ -1,19 +1,25 @@
 /*
-  Copyright (c) 1990-1999 Info-ZIP.  All rights reserved.
+  Copyright (c) 1990-2006 Info-ZIP.  All rights reserved.
 
-  See the accompanying file LICENSE, version 1999-Oct-05 or later
-  (the contents of which are also included in zip.h) for terms of use.
-  If, for some reason, both of these files are missing, the Info-ZIP license
-  also may be found at:  <A HREF="ftp://ftp.cdrom.com/pub/infozip/license.html">ftp://ftp.cdrom.com/pub/infozip/license.html</A>

[... truncated: 3345 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="004555.html">[Haiku-commits] r22783 - haiku/trunk/src/system/libroot/os/arch/m68k
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4554">[ date ]</a>
              <a href="thread.html#4554">[ thread ]</a>
              <a href="subject.html#4554">[ subject ]</a>
              <a href="author.html#4554">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
