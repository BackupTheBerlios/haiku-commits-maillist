<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22811 - in	haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine: .	dev dev/mii pci
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22811%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine%3A%20.%0A%09dev%20dev/mii%20pci&In-Reply-To=%3C200711031207.lA3C7SoI027795%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004593.html">
   <LINK REL="Next"  HREF="004595.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22811 - in	haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine: .	dev dev/mii pci</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22811%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine%3A%20.%0A%09dev%20dev/mii%20pci&In-Reply-To=%3C200711031207.lA3C7SoI027795%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22811 - in	haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine: .	dev dev/mii pci">axeld at mail.berlios.de
       </A><BR>
    <I>Sat Nov  3 13:07:28 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004593.html">[Haiku-commits] r22810 - haiku/trunk
</A></li>
        <LI>Next message: <A HREF="004595.html">[Haiku-commits] r22812 - in	haiku/trunk/src/libs/compat/freebsd_network: . compat/sys
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4594">[ date ]</a>
              <a href="thread.html#4594">[ thread ]</a>
              <a href="subject.html#4594">[ subject ]</a>
              <a href="author.html#4594">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-11-03 13:07:26 +0100 (Sat, 03 Nov 2007)
New Revision: 22811
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22811&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22811&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/miidevs.h
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ukphy_subr.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/pci/
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/pci/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/pci/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/pci/if_vr.c
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/pci/if_vrreg.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/Jamfile
Log:
Added VIA Rhine driver from FreeBSD 6.2 unchanged. It does not work yet, though, because of problems 
with the MII bus support in the compatibility layer.


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/Jamfile	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/Jamfile	2007-11-03 12:07:26 UTC (rev 22811)
@@ -43,3 +43,5 @@
 	installed-symlink 
 ;
 
+SubInclude HAIKU_TOP src add-ons kernel drivers network via-rhine dev ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network via-rhine pci ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/Jamfile	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/Jamfile	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network via-rhine dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network via-rhine dev mii ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/Jamfile	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/Jamfile	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,16 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network via-rhine dev mii ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 ] ;
+
+KernelStaticLibrary via_rhine_mii.a
+	:
+	ciphy.c
+	ukphy.c
+	ukphy_subr.c
+	;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphy.c	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphy.c	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,435 @@
+/*-
+ * Copyright (c) 2004
+ *	Bill Paul &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wpaul at windriver.com</A>&gt;.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Bill Paul.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/dev/mii/ciphy.c,v 1.2 2005/01/06 01:42:55 imp Exp $
+ */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ciphy.c,v 1.2 2005/01/06 01:42:55 imp Exp $&quot;);
+
+/*
+ * Driver for the Cicada CS8201 10/100/1000 copper PHY.
+ */
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/bus.h&gt;
+
+#include &lt;machine/clock.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;net/if_arp.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+#include &quot;miidevs.h&quot;
+
+#include &lt;dev/mii/ciphyreg.h&gt;
+
+#include &quot;miibus_if.h&quot;
+
+#include &lt;machine/bus.h&gt;
+/*
+#include &lt;dev/vge/if_vgereg.h&gt;
+*/
+static int ciphy_probe(device_t);
+static int ciphy_attach(device_t);
+
+static device_method_t ciphy_methods[] = {
+	/* device interface */
+	DEVMETHOD(device_probe,		ciphy_probe),
+	DEVMETHOD(device_attach,	ciphy_attach),
+	DEVMETHOD(device_detach,	mii_phy_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	{ 0, 0 }
+};
+
+static devclass_t ciphy_devclass;
+
+static driver_t ciphy_driver = {
+	&quot;ciphy&quot;,
+	ciphy_methods,
+	sizeof(struct mii_softc)
+};
+
+DRIVER_MODULE(ciphy, miibus, ciphy_driver, ciphy_devclass, 0, 0);
+
+static int	ciphy_service(struct mii_softc *, struct mii_data *, int);
+static void	ciphy_status(struct mii_softc *);
+static void	ciphy_reset(struct mii_softc *);
+static void	ciphy_fixup(struct mii_softc *);
+
+static int
+ciphy_probe(dev)
+	device_t		dev;
+{
+	struct mii_attach_args *ma;
+
+	ma = device_get_ivars(dev);
+
+device_printf(dev, &quot;OUI: %x\n&quot;, MII_OUI(ma-&gt;mii_id1, ma-&gt;mii_id2));
+device_printf(dev, &quot;MODEL: %x\n&quot;, MII_MODEL(ma-&gt;mii_id2));
+	if (MII_OUI(ma-&gt;mii_id1, ma-&gt;mii_id2) == MII_OUI_CICADA &amp;&amp;
+	    MII_MODEL(ma-&gt;mii_id2) == MII_MODEL_CICADA_CS8201) {
+		device_set_desc(dev, MII_STR_CICADA_CS8201);
+		return(0);
+	}
+
+	if (MII_OUI(ma-&gt;mii_id1, ma-&gt;mii_id2) == MII_OUI_CICADA &amp;&amp;
+	    MII_MODEL(ma-&gt;mii_id2) == MII_MODEL_CICADA_CS8201A) {
+		device_set_desc(dev, MII_STR_CICADA_CS8201A);
+		return(0);
+	}
+
+	if (MII_OUI(ma-&gt;mii_id1, ma-&gt;mii_id2) == MII_OUI_CICADA &amp;&amp;
+	    MII_MODEL(ma-&gt;mii_id2) == MII_MODEL_CICADA_CS8201B) {
+		device_set_desc(dev, MII_STR_CICADA_CS8201B);
+		return(0);
+	}
+
+	return(ENXIO);
+}
+
+static int
+ciphy_attach(dev)
+	device_t		dev;
+{
+	struct mii_softc *sc;
+	struct mii_attach_args *ma;
+	struct mii_data *mii;
+
+	sc = device_get_softc(dev);
+	ma = device_get_ivars(dev);
+	sc-&gt;mii_dev = device_get_parent(dev);
+	mii = device_get_softc(sc-&gt;mii_dev);
+	LIST_INSERT_HEAD(&amp;mii-&gt;mii_phys, sc, mii_list);
+
+	sc-&gt;mii_inst = mii-&gt;mii_instance;
+	sc-&gt;mii_phy = ma-&gt;mii_phyno;
+	sc-&gt;mii_service = ciphy_service;
+	sc-&gt;mii_pdata = mii;
+
+	sc-&gt;mii_flags |= MIIF_NOISOLATE;
+	mii-&gt;mii_instance++;
+
+	ciphy_reset(sc);
+
+	sc-&gt;mii_capabilities =
+	    PHY_READ(sc, MII_BMSR) &amp; ma-&gt;mii_capmask;
+	if (sc-&gt;mii_capabilities &amp; BMSR_EXTSTAT)
+		sc-&gt;mii_extcapabilities = PHY_READ(sc, MII_EXTSR);
+	device_printf(dev, &quot; &quot;);
+	mii_phy_add_media(sc);
+	printf(&quot;\n&quot;);
+
+	MIIBUS_MEDIAINIT(sc-&gt;mii_dev);
+	return(0);
+}
+
+static int
+ciphy_service(sc, mii, cmd)
+	struct mii_softc *sc;
+	struct mii_data *mii;
+	int cmd;
+{
+	struct ifmedia_entry *ife = mii-&gt;mii_media.ifm_cur;
+	int reg, speed, gig;
+
+	switch (cmd) {
+	case MII_POLLSTAT:
+		/*
+		 * If we're not polling our PHY instance, just return.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst)
+			return (0);
+		break;
+
+	case MII_MEDIACHG:
+		/*
+		 * If the media indicates a different PHY instance,
+		 * isolate ourselves.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst) {
+			reg = PHY_READ(sc, MII_BMCR);
+			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
+			return (0);
+		}
+
+		/*
+		 * If the interface is not up, don't do anything.
+		 */
+		if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_UP) == 0)
+			break;
+
+		ciphy_fixup(sc);	/* XXX hardware bug work-around */
+
+		switch (IFM_SUBTYPE(ife-&gt;ifm_media)) {
+		case IFM_AUTO:
+#ifdef foo
+			/*
+			 * If we're already in auto mode, just return.
+			 */
+			if (PHY_READ(sc, CIPHY_MII_BMCR) &amp; CIPHY_BMCR_AUTOEN)
+				return (0);
+#endif
+			(void) mii_phy_auto(sc);
+			break;
+		case IFM_1000_T:
+			speed = CIPHY_S1000;
+			goto setit;
+		case IFM_100_TX:
+			speed = CIPHY_S100;
+			goto setit;
+		case IFM_10_T:
+			speed = CIPHY_S10;
+setit:
+			if ((ife-&gt;ifm_media &amp; IFM_GMASK) == IFM_FDX) {
+				speed |= CIPHY_BMCR_FDX;
+				gig = CIPHY_1000CTL_AFD;
+			} else {
+				gig = CIPHY_1000CTL_AHD;
+			}
+
+			PHY_WRITE(sc, CIPHY_MII_1000CTL, 0);
+			PHY_WRITE(sc, CIPHY_MII_BMCR, speed);
+			PHY_WRITE(sc, CIPHY_MII_ANAR, CIPHY_SEL_TYPE);
+
+			if (IFM_SUBTYPE(ife-&gt;ifm_media) != IFM_1000_T) 
+				break;
+
+			PHY_WRITE(sc, CIPHY_MII_1000CTL, gig);
+			PHY_WRITE(sc, CIPHY_MII_BMCR,
+			    speed|CIPHY_BMCR_AUTOEN|CIPHY_BMCR_STARTNEG);
+
+			/*
+			 * When setting the link manually, one side must
+			 * be the master and the other the slave. However
+			 * ifmedia doesn't give us a good way to specify
+			 * this, so we fake it by using one of the LINK
+			 * flags. If LINK0 is set, we program the PHY to
+			 * be a master, otherwise it's a slave.
+			 */
+			if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_LINK0)) {
+				PHY_WRITE(sc, CIPHY_MII_1000CTL,
+				    gig|CIPHY_1000CTL_MSE|CIPHY_1000CTL_MSC);
+			} else {
+				PHY_WRITE(sc, CIPHY_MII_1000CTL,
+				    gig|CIPHY_1000CTL_MSE);
+			}
+			break;
+		case IFM_NONE:
+			PHY_WRITE(sc, MII_BMCR, BMCR_ISO|BMCR_PDOWN);
+			break;
+		case IFM_100_T4:
+		default:
+			return (EINVAL);
+		}
+		break;
+
+	case MII_TICK:
+		/*
+		 * If we're not currently selected, just return.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst)
+			return (0);
+
+		/*
+		 * Is the interface even up?
+		 */
+		if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_UP) == 0)
+			return (0);
+
+		/*
+		 * Only used for autonegotiation.
+		 */
+		if (IFM_SUBTYPE(ife-&gt;ifm_media) != IFM_AUTO)
+			break;
+
+		/*
+		 * Check to see if we have link.  If we do, we don't
+		 * need to restart the autonegotiation process.  Read
+		 * the BMSR twice in case it's latched.
+		 */
+		reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
+		if (reg &amp; BMSR_LINK)
+			break;
+
+		/*
+		 * Only retry autonegotiation every 5 seconds.
+		 */
+		if (++sc-&gt;mii_ticks &lt;= 5/*10*/)
+			break;
+		
+		sc-&gt;mii_ticks = 0;
+		mii_phy_auto(sc);
+		return (0);
+	}
+
+	/* Update the media status. */
+	ciphy_status(sc);
+
+	/*
+	 * Callback if something changed. Note that we need to poke
+	 * apply fixups for certain PHY revs.
+	 */
+	if (sc-&gt;mii_media_active != mii-&gt;mii_media_active || 
+	    sc-&gt;mii_media_status != mii-&gt;mii_media_status ||
+	    cmd == MII_MEDIACHG) {
+		ciphy_fixup(sc);
+	}
+	mii_phy_update(sc, cmd);
+	return (0);
+}
+
+static void
+ciphy_status(sc)
+	struct mii_softc *sc;
+{
+	struct mii_data *mii = sc-&gt;mii_pdata;
+	int bmsr, bmcr;
+
+	mii-&gt;mii_media_status = IFM_AVALID;
+	mii-&gt;mii_media_active = IFM_ETHER;
+
+	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
+
+	if (bmsr &amp; BMSR_LINK)
+		mii-&gt;mii_media_status |= IFM_ACTIVE;
+
+	bmcr = PHY_READ(sc, CIPHY_MII_BMCR);
+
+	if (bmcr &amp; CIPHY_BMCR_LOOP)
+		mii-&gt;mii_media_active |= IFM_LOOP;
+
+	if (bmcr &amp; CIPHY_BMCR_AUTOEN) {
+		if ((bmsr &amp; CIPHY_BMSR_ACOMP) == 0) {
+			/* Erg, still trying, I guess... */
+			mii-&gt;mii_media_active |= IFM_NONE;
+			return;
+		}
+	}
+
+	bmsr = PHY_READ(sc, CIPHY_MII_AUXCSR);
+	switch (bmsr &amp; CIPHY_AUXCSR_SPEED) {
+	case CIPHY_SPEED10:
+		mii-&gt;mii_media_active |= IFM_10_T;
+		break;
+	case CIPHY_SPEED100:
+		mii-&gt;mii_media_active |= IFM_100_TX;
+		break;
+	case CIPHY_SPEED1000:
+		mii-&gt;mii_media_active |= IFM_1000_T;
+		break;
+	default:
+		device_printf(sc-&gt;mii_dev, &quot;unknown PHY speed %x\n&quot;,
+		    bmsr &amp; CIPHY_AUXCSR_SPEED);
+		break;
+	}
+
+	if (bmsr &amp; CIPHY_AUXCSR_FDX)
+		mii-&gt;mii_media_active |= IFM_FDX;
+
+	return;
+}
+
+static void
+ciphy_reset(struct mii_softc *sc)
+{
+	mii_phy_reset(sc);
+	DELAY(1000);
+
+	return;
+}
+
+#define PHY_SETBIT(x, y, z) \
+	PHY_WRITE(x, y, (PHY_READ(x, y) | (z)))
+#define PHY_CLRBIT(x, y, z) \
+	PHY_WRITE(x, y, (PHY_READ(x, y) &amp; ~(z)))
+
+static void
+ciphy_fixup(struct mii_softc *sc)
+{
+	uint16_t		model;
+	uint16_t		status, speed;
+
+	model = MII_MODEL(PHY_READ(sc, CIPHY_MII_PHYIDR2));
+	status = PHY_READ(sc, CIPHY_MII_AUXCSR);
+	speed = status &amp; CIPHY_AUXCSR_SPEED;
+
+	switch (model) {
+	case MII_MODEL_CICADA_CS8201:
+
+		/* Turn off &quot;aux mode&quot; (whatever that means) */
+		PHY_SETBIT(sc, CIPHY_MII_AUXCSR, CIPHY_AUXCSR_MDPPS);
+
+		/*
+		 * Work around speed polling bug in VT3119/VT3216
+		 * when using MII in full duplex mode.
+		 */
+		if ((speed == CIPHY_SPEED10 || speed == CIPHY_SPEED100) &amp;&amp;
+		    (status &amp; CIPHY_AUXCSR_FDX)) {
+			PHY_SETBIT(sc, CIPHY_MII_10BTCSR, CIPHY_10BTCSR_ECHO);
+		} else {
+			PHY_CLRBIT(sc, CIPHY_MII_10BTCSR, CIPHY_10BTCSR_ECHO);
+		}
+
+		/* Enable link/activity LED blink. */
+		PHY_SETBIT(sc, CIPHY_MII_LED, CIPHY_LED_LINKACTBLINK);
+
+		break;
+
+	case MII_MODEL_CICADA_CS8201A:
+	case MII_MODEL_CICADA_CS8201B:
+
+		/*
+		 * Work around speed polling bug in VT3119/VT3216
+		 * when using MII in full duplex mode.
+		 */
+		if ((speed == CIPHY_SPEED10 || speed == CIPHY_SPEED100) &amp;&amp;
+		    (status &amp; CIPHY_AUXCSR_FDX)) {
+			PHY_SETBIT(sc, CIPHY_MII_10BTCSR, CIPHY_10BTCSR_ECHO);
+		} else {
+			PHY_CLRBIT(sc, CIPHY_MII_10BTCSR, CIPHY_10BTCSR_ECHO);
+		}
+
+		break;
+	default:
+		device_printf(sc-&gt;mii_dev, &quot;unknown CICADA PHY model %x\n&quot;,
+		    model);
+		break;
+	}
+
+	return;
+}

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphyreg.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphyreg.h	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ciphyreg.h	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,351 @@
+/*-
+ * Copyright (c) 2004
+ *	Bill Paul &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wpaul at windriver.com</A>&gt;.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Bill Paul.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/dev/mii/ciphyreg.h,v 1.2 2005/01/06 01:42:55 imp Exp $
+ */
+
+#ifndef _DEV_MII_CIPHYREG_H_
+#define	_DEV_MII_CIPHYREG_H_
+
+/*
+ * Register definitions for the Cicada CS8201 10/100/1000 gigE copper
+ * PHY, embedded within the VIA Networks VT6122 controller.
+ */
+
+/* Command register */
+#define CIPHY_MII_BMCR		0x00
+#define CIPHY_BMCR_RESET	0x8000
+#define CIPHY_BMCR_LOOP		0x4000
+#define CIPHY_BMCR_SPD0		0x2000	/* speed select, lower bit */
+#define CIPHY_BMCR_AUTOEN	0x1000	/* Autoneg enabled */
+#define CIPHY_BMCR_PDOWN	0x0800	/* Power down */
+#define CIPHY_BMCR_STARTNEG	0x0200	/* Restart autoneg */
+#define CIPHY_BMCR_FDX		0x0100	/* Duplex mode */
+#define CIPHY_BMCR_CTEST	0x0080	/* Collision test enable */
+#define CIPHY_BMCR_SPD1		0x0040	/* Speed select, upper bit */
+
+#define CIPHY_S1000		CIPHY_BMCR_SPD1	/* 1000mbps */
+#define CIPHY_S100		CIPHY_BMCR_SPD0	/* 100mpbs */
+#define CIPHY_S10		0		/* 10mbps */
+
+/* Status register */
+#define CIPHY_MII_BMSR		0x01
+#define CIPHY_BMSR_100T4	0x8000	/* 100 base T4 capable */
+#define CIPHY_BMSR_100TXFDX	0x4000	/* 100 base Tx full duplex capable */
+#define CIPHY_BMSR_100TXHDX	0x2000	/* 100 base Tx half duplex capable */
+#define CIPHY_BMSR_10TFDX	0x1000	/* 10 base T full duplex capable */
+#define CIPHY_BMSR_10THDX	0x0800	/* 10 base T half duplex capable */
+#define CIPHY_BMSR_100T2FDX	0x0400	/* 100 base T2 full duplex capable */
+#define CIPHY_BMSR_100T2HDX	0x0200	/* 100 base T2 half duplex capable */
+#define CIPHY_BMSR_EXTSTS	0x0100	/* Extended status present */
+#define CIPHY_BMSR_PRESUB	0x0040	/* Preamble surpression */
+#define CIPHY_BMSR_ACOMP	0x0020	/* Autoneg complete */
+#define CIPHY_BMSR_RFAULT	0x0010	/* Remote fault condition occured */
+#define CIPHY_BMSR_ANEG		0x0008	/* Autoneg capable */
+#define CIPHY_BMSR_LINK		0x0004	/* Link status */
+#define CIPHY_BMSR_JABBER	0x0002	/* Jabber detected */
+#define CIPHY_BMSR_EXT		0x0001	/* Extended capability */
+
+/* PHY ID registers */
+#define CIPHY_MII_PHYIDR1	0x02
+#define CIPHY_MII_PHYIDR2	0x03
+
+/* Autoneg advertisement */
+#define CIPHY_MII_ANAR		0x04
+#define CIPHY_ANAR_NP		0x8000	/* Next page */
+#define CIPHY_ANAR_RF		0x2000	/* Remote fault */
+#define CIPHY_ANAR_ASP		0x0800	/* Asymmetric Pause */
+#define CIPHY_ANAR_PC		0x0400	/* Pause capable */
+#define CIPHY_ANAR_T4		0x0200	/* local device supports 100bT4 */
+#define CIPHY_ANAR_TX_FD	0x0100	/* local device supports 100bTx FD */
+#define CIPHY_ANAR_TX		0x0080	/* local device supports 100bTx */
+#define CIPHY_ANAR_10_FD	0x0040	/* local device supports 10bT FD */
+#define CIPHY_ANAR_10		0x0020	/* local device supports 10bT */
+#define CIPHY_ANAR_SEL		0x001F	/* selector field, 00001=Ethernet */
+
+/* Autoneg link partner ability */
+#define CIPHY_MII_ANLPAR	0x05
+#define CIPHY_ANLPAR_NP		0x8000	/* Next page */
+#define CIPHY_ANLPAR_ACK	0x4000	/* link partner acknowledge */
+#define CIPHY_ANLPAR_RF		0x2000	/* Remote fault */
+#define CIPHY_ANLPAR_ASP	0x0800	/* Asymmetric Pause */
+#define CIPHY_ANLPAR_PC		0x0400	/* Pause capable */
+#define CIPHY_ANLPAR_T4		0x0200	/* link partner supports 100bT4 */
+#define CIPHY_ANLPAR_TX_FD	0x0100	/* link partner supports 100bTx FD */
+#define CIPHY_ANLPAR_TX		0x0080	/* link partner supports 100bTx */
+#define CIPHY_ANLPAR_10_FD	0x0040	/* link partner supports 10bT FD */
+#define CIPHY_ANLPAR_10		0x0020	/* link partner supports 10bT */
+#define CIPHY_ANLPAR_SEL	0x001F	/* selector field, 00001=Ethernet */
+
+#define CIPHY_SEL_TYPE		0x0001	/* ethernet */
+
+/* Antoneg expansion register */
+#define CIPHY_MII_ANER		0x06
+#define CIPHY_ANER_PDF		0x0010	/* Parallel detection fault */
+#define CIPHY_ANER_LPNP		0x0008	/* Link partner can next page */
+#define CIPHY_ANER_NP		0x0004	/* Local PHY can next page */
+#define CIPHY_ANER_RX		0x0002	/* Next page received */
+#define CIPHY_ANER_LPAN		0x0001 	/* Link partner autoneg capable */
+
+/* Autoneg next page transmit regisyer */
+#define CIPHY_MII_NEXTP		0x07
+#define CIPHY_NEXTP_MOREP	0x8000	/* More pages to follow */
+#define CIPHY_NEXTP_MESS	0x2000	/* 1 = message page, 0 = unformatted */
+#define CIPHY_NEXTP_ACK2	0x1000	/* MAC acknowledge */
+#define CIPHY_NEXTP_TOGGLE	0x0800	/* Toggle */
+#define CIPHY_NEXTP_CODE	0x07FF	/* Code bits */
+
+/* Autoneg link partner next page receive register */
+#define CIPHY_MII_NEXTP_LP	0x08
+#define CIPHY_NEXTPLP_MOREP	0x8000	/* More pages to follow */
+#define CIPHY_NEXTPLP_MESS	0x2000	/* 1 = message page, 0 = unformatted */
+#define CIPHY_NEXTPLP_ACK2	0x1000	/* MAC acknowledge */
+#define CIPHY_NEXTPLP_TOGGLE	0x0800	/* Toggle */
+#define CIPHY_NEXTPLP_CODE	0x07FF	/* Code bits */
+
+/* 1000BT control register */
+#define CIPHY_MII_1000CTL	0x09
+#define CIPHY_1000CTL_TST	0xE000	/* test modes */
+#define CIPHY_1000CTL_MSE	0x1000	/* Master/Slave manual enable */
+#define CIPHY_1000CTL_MSC	0x0800	/* Master/Slave select */
+#define CIPHY_1000CTL_RD	0x0400	/* Repeater/DTE */
+#define CIPHY_1000CTL_AFD	0x0200	/* Advertise full duplex */
+#define CIPHY_1000CTL_AHD	0x0100	/* Advertise half duplex */
+
+#define CIPHY_TEST_TX_JITTER			0x2000
+#define CIPHY_TEST_TX_JITTER_MASTER_MODE	0x4000
+#define CIPHY_TEST_TX_JITTER_SLAVE_MODE		0x6000
+#define CIPHY_TEST_TX_DISTORTION		0x8000
+
+/* 1000BT status register */
+#define CIPHY_MII_1000STS	0x0A
+#define CIPHY_1000STS_MSF	0x8000	/* Master/slave fault */
+#define CIPHY_1000STS_MSR	0x4000	/* Master/slave result */
+#define CIPHY_1000STS_LRS	0x2000	/* Local receiver status */
+#define CIPHY_1000STS_RRS	0x1000	/* Remote receiver status */
+#define CIPHY_1000STS_LPFD	0x0800	/* Link partner can FD */
+#define CIPHY_1000STS_LPHD	0x0400	/* Link partner can HD */
+#define CIPHY_1000STS_IEC	0x00FF	/* Idle error count */
+
+#define CIPHY_MII_EXTSTS	0x0F	/* Extended status */
+#define CIPHY_EXTSTS_X_FD_CAP	0x8000	/* 1000base-X FD capable */
+#define CIPHY_EXTSTS_X_HD_CAP	0x4000	/* 1000base-X HD capable */
+#define CIPHY_EXTSTS_T_FD_CAP	0x2000	/* 1000base-T FD capable */
+#define CIPHY_EXTSTS_T_HD_CAP	0x1000	/* 1000base-T HD capable */
+
+/* 1000BT status extension register #1 */
+#define CIPHY_MII_1000STS1	0x0F
+#define CIPHY_1000STS1_1000XFDX	0x8000	/* 1000baseX FDX capable */
+#define CIPHY_1000STS1_1000XHDX	0x4000	/* 1000baseX HDX capable */
+#define CIPHY_1000STS1_1000TFDX	0x2000	/* 1000baseT FDX capable */
+#define CIPHY_1000STS1_1000THDX	0x1000	/* 1000baseT HDX capable */
+
+/* Vendor-specific PHY registers */
+
+/* 100baseTX status extention register */
+#define CIPHY_MII_100STS	0x10
+#define CIPHY_100STS_DESLCK	0x8000	/* descrambler locked */
+#define CIPHY_100STS_LKCERR	0x4000	/* lock error detected/lock lost */
+#define CIPHY_100STS_DISC	0x2000	/* disconnect state */
+#define CIPHY_100STS_LINK	0x1000	/* current link state */
+#define CIPHY_100STS_RXERR	0x0800	/* receive error detected */
+#define CIPHY_100STS_TXERR	0x0400	/* transmit error detected */
+#define CIPHY_100STS_SSDERR	0x0200	/* false carrier error detected */
+#define CIPHY_100STS_ESDERR	0x0100	/* premature end of stream error */
+
+/* 1000BT status extention register #2 */
+#define CIPHY_MII_1000STS2	0x11
+#define CIPHY_1000STS2_DESLCK	0x8000	/* descrambler locked */
+#define CIPHY_1000STS2_LKCERR	0x4000	/* lock error detected/lock lost */
+#define CIPHY_1000STS2_DISC	0x2000	/* disconnect state */
+#define CIPHY_1000STS2_LINK	0x1000	/* current link state */
+#define CIPHY_1000STS2_RXERR	0x0800	/* receive error detected */
+#define CIPHY_1000STS2_TXERR	0x0400	/* transmit error detected */
+#define CIPHY_1000STS2_SSDERR	0x0200	/* false carrier error detected */
+#define CIPHY_1000STS2_ESDERR	0x0100	/* premature end of stream error */
+#define CIPHY_1000STS2_CARREXT	0x0080	/* carrier extention err detected */
+#define CIPHY_1000STS2_BCM5400	0x0040	/* non-complient BCM5400 detected */
+
+/* Bypass control register */
+#define CIPHY_MII_BYPASS	0x12
+#define CIPHY_BYPASS_TX		0x8000	/* transmit disable */
+#define CIPHY_BYPASS_4B5B	0x4000	/* bypass the 4B5B encoder */
+#define CIPHY_BYPASS_SCRAM	0x2000	/* bypass scrambler */
+#define CIPHY_BYPASS_DSCAM	0x1000	/* bypass descrambler */
+#define CIPHY_BYPASS_PCSRX	0x0800	/* bypass PCS receive */
+#define CIPHY_BYPASS_PCSTX	0x0400	/* bypass PCS transmit */
+#define CIPHY_BYPASS_LFI	0x0200	/* bypass LFI timer */
+#define CIPHY_BYPASS_TXCLK	0x0100	/* enable transmit clock on LED4 pin */
+#define CIPHY_BYPASS_BCM5400_F	0x0080	/* force BCM5400 detect */
+#define CIPHY_BYPASS_BCM5400	0x0040	/* bypass BCM5400 detect */
+#define CIPHY_BYPASS_PAIRSWAP	0x0020	/* disable automatic pair swap */
+#define CIPHY_BYPASS_POLARITY	0x0010	/* disable polarity correction */
+#define CIPHY_BYPASS_PARALLEL	0x0008	/* parallel detect enable */
+#define CIPHY_BYPASS_PULSE	0x0004	/* disable pulse shaping filter */
+#define CIPHY_BYPASS_1000BNP	0x0002	/* disable 1000BT next page exchange */
+
+/* RX error count register */
+#define CIPHY_MII_RXERR		0x13
+
+/* False carrier sense count register */
+#define CIPHY_MII_FCSERR	0x14
+
+/* Ddisconnect error counter */
+#define CIPHY_MII_DISCERR	0x15
+
+/* 10baseT control/status register */
+#define CIPHY_MII_10BTCSR	0x16
+#define CIPHY_10BTCSR_DLIT	0x8000	/* Disable data link integrity test */
+#define CIPHY_10BTCSR_JABBER	0x4000	/* Disable jabber detect */
+#define CIPHY_10BTCSR_ECHO	0x2000	/* Disable echo mode */
+#define CIPHY_10BTCSR_SQE	0x1000	/* Disable signal quality error */
+#define CIPHY_10BTCSR_SQUENCH	0x0C00	/* Squelch control */
+#define CIPHY_10BTCSR_EOFERR	0x0100	/* End of Frame error */
+#define CIPHY_10BTCSR_DISC	0x0080	/* Disconnect status */
+#define CIPHY_10BTCSR_LINK	0x0040	/* current link state */
+#define CIPHY_10BTCSR_ITRIM	0x0038	/* current reference trim */
+#define CIPHY_10BTCSR_CSR	0x0006	/* CSR behavior control */
+
+#define CIPHY_SQUELCH_300MV	0x0000
+#define CIPHY_SQUELCH_197MV	0x0400
+#define CIPHY_SQUELCH_450MV	0x0800
+#define CIPHY_SQUELCH_RSVD	0x0C00
+
+#define CIPHY_ITRIM_PLUS2	0x0000
+#define CIPHY_ITRIM_PLUS4	0x0008
+#define CIPHY_ITRIM_PLUS6	0x0010
+#define CIPHY_ITRIM_PLUS6_	0x0018
+#define CIPHY_ITRIM_MINUS4	0x0020
+#define CIPHY_ITRIM_MINUS4_	0x0028
+#define CIPHY_ITRIM_MINUS2	0x0030
+#define CIPHY_ITRIM_ZERO	0x0038
+
+/* Extended PHY control register #1 */
+#define CIPHY_MII_ECTL1		0x17
+#define CIPHY_ECTL1_ACTIPHY	0x0020	/* Enable ActiPHY power saving */
+
+/* Extended PHY control register #2 */
+#define CIPHY_MII_ECTL2		0x18
+#define CIPHY_ECTL2_ERATE	0xE000	/* 10/1000 edge rate control */
+#define CIPHY_ECTL2_VTRIM	0x1C00	/* voltage reference trim */
+#define CIPHY_ECTL2_CABLELEN	0x000E	/* Cable quality/length */
+#define CIPHY_ECTL2_ANALOGLOOP	0x0001	/* 1000BT analog loopback */
+
+#define CIPHY_CABLELEN_0TO10M		0x0000
+#define CIPHY_CABLELEN_10TO20M		0x0002
+#define CIPHY_CABLELEN_20TO40M		0x0004
+#define CIPHY_CABLELEN_40TO80M		0x0006
+#define CIPHY_CABLELEN_80TO100M		0x0008
+#define CIPHY_CABLELEN_100TO140M	0x000A
+#define CIPHY_CABLELEN_140TO180M	0x000C
+#define CIPHY_CABLELEN_OVER180M		0x000E
+
+/* Interrupt mask register */
+#define CIPHY_MII_IMR		0x19
+#define CIPHY_IMR_PINENABLE	0x8000	/* Interrupt pin enable */
+#define CIPHY_IMR_SPEED		0x4000	/* speed changed event */
+#define CIPHY_IMR_LINK		0x2000	/* link change/ActiPHY event */
+#define CIPHY_IMR_DPX		0x1000	/* duplex change event */
+#define CIPHY_IMR_ANEGERR	0x0800	/* autoneg error event */
+#define CIPHY_IMR_ANEGDONE	0x0400	/* autoneg done event */
+#define CIPHY_IMR_NPRX		0x0200	/* page received event */
+#define CIPHY_IMR_SYMERR	0x0100	/* symbol error event */
+#define CIPHY_IMR_LOCKERR	0x0080	/* descrambler lock lost event */
+#define CIPHY_IMR_XOVER		0x0040	/* MDI crossover change event */
+#define CIPHY_IMR_POLARITY	0x0020	/* polarity change event */
+#define CIPHY_IMR_JABBER	0x0010	/* jabber detect event */
+#define CIPHY_IMR_SSDERR	0x0008	/* false carrier detect event */
+#define CIPHY_IMR_ESDERR	0x0004	/* parallel detect error event */
+#define CIPHY_IMR_MASTERSLAVE	0x0002	/* master/slave resolve done event */
+#define CIPHY_IMR_RXERR		0x0001	/* RX error event */
+
+/* Interrupt status register */
+#define CIPHY_MII_ISR		0x1A
+#define CIPHY_ISR_IPENDING	0x8000	/* Interrupt is pending */
+#define CIPHY_ISR_SPEED		0x4000	/* speed changed event */
+#define CIPHY_ISR_LINK		0x2000	/* link change/ActiPHY event */
+#define CIPHY_ISR_DPX		0x1000	/* duplex change event */
+#define CIPHY_ISR_ANEGERR	0x0800	/* autoneg error event */
+#define CIPHY_ISR_ANEGDONE	0x0400	/* autoneg done event */
+#define CIPHY_ISR_NPRX		0x0200	/* page received event */
+#define CIPHY_ISR_SYMERR	0x0100	/* symbol error event */
+#define CIPHY_ISR_LOCKERR	0x0080	/* descrambler lock lost event */
+#define CIPHY_ISR_XOVER		0x0040	/* MDI crossover change event */
+#define CIPHY_ISR_POLARITY	0x0020	/* polarity change event */
+#define CIPHY_ISR_JABBER	0x0010	/* jabber detect event */
+#define CIPHY_ISR_SSDERR	0x0008	/* false carrier detect event */
+#define CIPHY_ISR_ESDERR	0x0004	/* parallel detect error event */
+#define CIPHY_ISR_MASTERSLAVE	0x0002	/* master/slave resolve done event */
+#define CIPHY_ISR_RXERR		0x0001	/* RX error event */
+
+/* LED control register */
+#define CIPHY_MII_LED		0x1B
+#define CIPHY_LED_LINK10FORCE	0x8000	/* Force on link10 LED */
+#define CIPHY_LED_LINK10DIS	0x4000	/* Disable link10 LED */
+#define CIPHY_LED_LINK100FORCE	0x2000	/* Force on link10 LED */
+#define CIPHY_LED_LINK100DIS	0x1000	/* Disable link100 LED */
+#define CIPHY_LED_LINK1000FORCE	0x0800	/* Force on link1000 LED */
+#define CIPHY_LED_LINK1000DIS	0x0400	/* Disable link1000 LED */
+#define CIPHY_LED_FDXFORCE	0x0200	/* Force on duplex LED */
+#define CIPHY_LED_FDXDIS	0x0100	/* Disable duplex LED */
+#define CIPHY_LED_ACTFORCE	0x0080	/* Force on activity LED */
+#define CIPHY_LED_ACTDIS	0x0040	/* Disable activity LED */
+#define CIPHY_LED_PULSE		0x0008	/* LED pulse enable */
+#define CIPHY_LED_LINKACTBLINK	0x0004	/* enable link/activity LED blink */
+#define CIPHY_LED_BLINKRATE	0x0002	/* blink rate 0=10hz, 1=5hz */
+
+/* Auxilliary control and status register */
+#define CIPHY_MII_AUXCSR	0x1C
+#define CIPHY_AUXCSR_ANEGDONE	0x8000	/* Autoneg complete */
+#define CIPHY_AUXCSR_ANEGOFF	0x4000	/* Autoneg disabled */
+#define CIPHY_AUXCSR_XOVER	0x2000	/* MDI/MDI-X crossover indication */
+#define CIPHY_AUXCSR_PAIRSWAP	0x1000	/* pair swap indication */
+#define CIPHY_AUXCSR_APOLARITY	0x0800	/* polarity inversion pair A */
+#define CIPHY_AUXCSR_BPOLARITY	0x0400	/* polarity inversion pair B */
+#define CIPHY_AUXCSR_CPOLARITY	0x0200	/* polarity inversion pair C */
+#define CIPHY_AUXCSR_DPOLARITY	0x0100	/* polarity inversion pair D */
+#define CIPHY_AUXCSR_FDX	0x0020	/* duplex 1=full, 0=half */
+#define CIPHY_AUXCSR_SPEED	0x0018	/* speed */
+#define CIPHY_AUXCSR_MDPPS	0x0004	/* No idea, not documented */
+#define CIPHY_AUXCSR_STICKYREST 0x0002	/* reset clears sticky bits */
+
+#define CIPHY_SPEED10		0x0000
+#define CIPHY_SPEED100		0x0008
+#define CIPHY_SPEED1000		0x0010
+
+/* Delay skew status register */
+#define CIPHY_MII_DSKEW		0x1D
+#define CIPHY_DSKEW_PAIRA	0x7000	/* Pair A skew in symbol times */
+#define CIPHY_DSKEW_PAIRB	0x0700	/* Pair B skew in symbol times */
+#define CIPHY_DSKEW_PAIRC	0x0070	/* Pair C skew in symbol times */
+#define CIPHY_DSKEW_PAIRD	0x0007	/* Pair D skew in symbol times */
+
+#endif /* _DEV_CIPHY_MIIREG_H_ */

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/miidevs.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/miidevs.h	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/miidevs.h	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _FBSD_MII_DEVS_H
+#define _FBSD_MII_DEVS_H
+
+#define MII_OUI_CICADA				0x0003f1
+
+#define MII_MODEL_CICADA_CS8201		0x0001
+#define MII_MODEL_CICADA_CS8201A	0x0020
+#define MII_MODEL_CICADA_CS8201B	0x0021
+
+#define MII_STR_CICADA_CS8201		&quot;Cicada CS8201 10/100/1000TX PHY&quot;
+#define MII_STR_CICADA_CS8201A		MII_STR_CICADA_CS8201
+#define MII_STR_CICADA_CS8201B		MII_STR_CICADA_CS8201
+
+#endif	/* _FBSD_MII_DEVS_H */

Added: haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ukphy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ukphy.c	2007-11-03 11:55:57 UTC (rev 22810)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/via-rhine/dev/mii/ukphy.c	2007-11-03 12:07:26 UTC (rev 22811)
@@ -0,0 +1,227 @@
+/*	$NetBSD: ukphy.c,v 1.2 1999/04/23 04:24:32 thorpej Exp $	*/
+
+/*-
+ * Copyright (c) 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center, and by Frank van der Linden.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1997 Manuel Bouyer.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Manuel Bouyer.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/ukphy.c,v 1.17 2005/01/06 01:42:56 imp Exp $&quot;);
+
+/*
+ * driver for generic unknown PHYs
+ */
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/errno.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/bus.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+
+#include &quot;miibus_if.h&quot;
+
+static int ukphy_probe(device_t);
+static int ukphy_attach(device_t);
+
+static device_method_t ukphy_methods[] = {
+	/* device interface */
+	DEVMETHOD(device_probe,		ukphy_probe),
+	DEVMETHOD(device_attach,	ukphy_attach),
+	DEVMETHOD(device_detach,	mii_phy_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	{ 0, 0 }
+};
+
+static devclass_t ukphy_devclass;
+
+static driver_t ukphy_driver = {
+	&quot;ukphy&quot;,
+	ukphy_methods,
+	sizeof(struct mii_softc)
+};
+
+DRIVER_MODULE(ukphy, miibus, ukphy_driver, ukphy_devclass, 0, 0);
+
+static int	ukphy_service(struct mii_softc *, struct mii_data *, int);
+
+static int
+ukphy_probe(dev)
+	device_t		dev;
+{
+
+	/*
+	 * We know something is here, so always match at a low priority.
+	 */
+	device_set_desc(dev, &quot;Generic IEEE 802.3u media interface&quot;);
+	return (-100);
+}
+
+static int
+ukphy_attach(dev)
+	device_t		dev;
+{

[... truncated: 2630 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004593.html">[Haiku-commits] r22810 - haiku/trunk
</A></li>
	<LI>Next message: <A HREF="004595.html">[Haiku-commits] r22812 - in	haiku/trunk/src/libs/compat/freebsd_network: . compat/sys
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4594">[ date ]</a>
              <a href="thread.html#4594">[ thread ]</a>
              <a href="subject.html#4594">[ subject ]</a>
              <a href="author.html#4594">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
