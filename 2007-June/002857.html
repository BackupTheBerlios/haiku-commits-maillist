<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21485 - in haiku/trunk: headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/dos	src/add-ons/kernel/file_systems/googlefs	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/file_systems/ramfs	src/add-ons/kernel/file_systems/reiserfs	src/add-ons/kernel/file_systems/udf	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/system/kernel src/system/kernel/cache src/system/kernel/fs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21485%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/userlandfs/private%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/dos%0A%09src/add-ons/kernel/file_systems/googlefs%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/ntfs%0A%09src/add-ons/kernel/file_systems/ramfs%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/add-ons/kernel/file_systems/udf%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/system/kernel%20src/system/kernel/cache%20src/system/kernel/fs&In-Reply-To=%3C200706211951.l5LJp823019617%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002875.html">
   <LINK REL="Next"  HREF="002858.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21485 - in haiku/trunk: headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/dos	src/add-ons/kernel/file_systems/googlefs	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/file_systems/ramfs	src/add-ons/kernel/file_systems/reiserfs	src/add-ons/kernel/file_systems/udf	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/system/kernel src/system/kernel/cache src/system/kernel/fs</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21485%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/userlandfs/private%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/dos%0A%09src/add-ons/kernel/file_systems/googlefs%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/ntfs%0A%09src/add-ons/kernel/file_systems/ramfs%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/add-ons/kernel/file_systems/udf%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/system/kernel%20src/system/kernel/cache%20src/system/kernel/fs&In-Reply-To=%3C200706211951.l5LJp823019617%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21485 - in haiku/trunk: headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/dos	src/add-ons/kernel/file_systems/googlefs	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/ntfs	src/add-ons/kernel/file_systems/ramfs	src/add-ons/kernel/file_systems/reiserfs	src/add-ons/kernel/file_systems/udf	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/system/kernel src/system/kernel/cache src/system/kernel/fs">axeld at mail.berlios.de
       </A><BR>
    <I>Thu Jun 21 21:51:08 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002875.html">[Haiku-commits] r21484 - haiku/trunk/src/bin
</A></li>
        <LI>Next message: <A HREF="002858.html">[Haiku-commits] r21486 - haiku/trunk/src/kits/game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2857">[ date ]</a>
              <a href="thread.html#2857">[ thread ]</a>
              <a href="subject.html#2857">[ subject ]</a>
              <a href="author.html#2857">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-06-21 21:50:57 +0200 (Thu, 21 Jun 2007)
New Revision: 21485
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21485&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21485&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/kernel/file_cache.h
   haiku/trunk/headers/private/kernel/fs/node_monitor.h
   haiku/trunk/headers/private/kernel/vfs.h
   haiku/trunk/headers/private/userlandfs/private/Requests.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/bfs_control.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.h
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dlist.c
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dlist.h
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dosfs.c
   haiku/trunk/src/add-ons/kernel/file_systems/dos/dosfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/dos/file.c
   haiku/trunk/src/add-ons/kernel/file_systems/dos/file.h
   haiku/trunk/src/add-ons/kernel/file_systems/dos/vcache.c
   haiku/trunk/src/add-ons/kernel/file_systems/dos/vcache.h
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/fsproto.h
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/googlefs.c
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/googlefs.h
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/vnidpool.c
   haiku/trunk/src/add-ons/kernel/file_systems/googlefs/vnidpool.h
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/iso.c
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/iso.h
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/nfs/fsproto.h
   haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c
   haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fsproto.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/ntfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/Node.h
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/NodeChildTable.h
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/NodeTable.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/NodeTable.h
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/ramfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/VNode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/VNode.h
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/udf/DirectoryIterator.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/udf/DirectoryIterator.h
   haiku/trunk/src/add-ons/kernel/file_systems/udf/Icb.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/udf/Icb.h
   haiku/trunk/src/add-ons/kernel/file_systems/udf/Utils.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/udf/Utils.h
   haiku/trunk/src/add-ons/kernel/file_systems/udf/fsproto.h
   haiku/trunk/src/add-ons/kernel/file_systems/udf/udf.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelFileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelFileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/FileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelFileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelFileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_fs_interface.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_file_cache.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_fs_cache.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/fs/devfs.cpp
   haiku/trunk/src/system/kernel/fs/node_monitor.cpp
   haiku/trunk/src/system/kernel/fs/pipefs.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.c
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/main.c
Log:
Got rid of vnode_id and mount_id, replaced with ino_t and dev_t.


Modified: haiku/trunk/headers/private/kernel/file_cache.h
===================================================================
--- haiku/trunk/headers/private/kernel/file_cache.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/headers/private/kernel/file_cache.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2005, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+ * Copyright 2004-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
  * Distributed under the terms of the MIT License.
  */
 #ifndef _KERNEL_FILE_CACHE_H
@@ -26,9 +26,9 @@
 struct cache_module_info {
 	module_info	info;
 
-	void (*node_opened)(void *vnode, int32 fdType, mount_id mountID, vnode_id parentID,
-				vnode_id vnodeID, const char *name, off_t size);
-	void (*node_closed)(void *vnode, int32 fdType, mount_id mountID, vnode_id vnodeID,
+	void (*node_opened)(void *vnode, int32 fdType, dev_t mountID, ino_t parentID,
+				ino_t vnodeID, const char *name, off_t size);
+	void (*node_closed)(void *vnode, int32 fdType, dev_t mountID, ino_t vnodeID,
 				int32 accessType);
 	void (*node_launched)(size_t argCount, char * const *args);
 };
@@ -38,12 +38,12 @@
 #endif
 
 extern void cache_node_opened(void *vnode, int32 fdType, vm_cache_ref *cache,
-				mount_id mountID, vnode_id parentID, vnode_id vnodeID, const char *name);
+				dev_t mountID, ino_t parentID, ino_t vnodeID, const char *name);
 extern void cache_node_closed(void *vnode, int32 fdType, vm_cache_ref *cache,
-				mount_id mountID, vnode_id vnodeID);
+				dev_t mountID, ino_t vnodeID);
 extern void cache_node_launched(size_t argCount, char * const *args);
 extern void cache_prefetch_vnode(void *vnode, off_t offset, size_t size);
-extern void cache_prefetch(mount_id mountID, vnode_id vnodeID, off_t offset, size_t size);
+extern void cache_prefetch(dev_t mountID, ino_t vnodeID, off_t offset, size_t size);
 extern status_t file_cache_init_post_boot_device(void);
 extern status_t file_cache_init(void);
 

Modified: haiku/trunk/headers/private/kernel/fs/node_monitor.h
===================================================================
--- haiku/trunk/headers/private/kernel/fs/node_monitor.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/headers/private/kernel/fs/node_monitor.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
+ * Copyright 2003-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
  * Distributed under the terms of the MIT License.
  */
 #ifndef _KERNEL_NODE_MONITOR_H
@@ -18,9 +18,9 @@
 // private kernel API
 extern status_t remove_node_monitors(struct io_context *context);
 extern status_t node_monitor_init(void);
-extern status_t notify_unmount(mount_id device);
-extern status_t notify_mount(mount_id device, mount_id parentDevice,
-					vnode_id parentDirectory);
+extern status_t notify_unmount(dev_t device);
+extern status_t notify_mount(dev_t device, dev_t parentDevice,
+					ino_t parentDirectory);
 
 // user-space exported calls
 extern status_t _user_stop_notifying(port_id port, uint32 token);

Modified: haiku/trunk/headers/private/kernel/vfs.h
===================================================================
--- haiku/trunk/headers/private/kernel/vfs.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/headers/private/kernel/vfs.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2002-2006, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
+ * Copyright 2002-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
  * Distributed under the terms of the MIT License.
  *
  * Copyright 2001-2002, Travis Geiselbrecht. All rights reserved.
@@ -21,10 +21,9 @@
 #include &lt;sys/select.h&gt;
 
 
-/* R5 figures, but we don't use a table for monitors anyway */
-#define DEFAULT_FD_TABLE_SIZE	128
+#define DEFAULT_FD_TABLE_SIZE	256
 #define MAX_FD_TABLE_SIZE		8192
-#define DEFAULT_NODE_MONITORS		4096 
+#define DEFAULT_NODE_MONITORS	4096 
 #define MAX_NODE_MONITORS		65536
 
 struct kernel_args;
@@ -78,12 +77,12 @@
 /* calls needed by the VM for paging and by the file cache */
 int vfs_get_vnode_from_fd(int fd, bool kernel, void **vnode);
 status_t vfs_get_vnode_from_path(const char *path, bool kernel, void **vnode);
-status_t vfs_get_vnode(mount_id mountID, vnode_id vnodeID, void **_vnode);
-status_t vfs_entry_ref_to_vnode(mount_id mountID, vnode_id directoryID,
+status_t vfs_get_vnode(dev_t mountID, ino_t vnodeID, void **_vnode);
+status_t vfs_entry_ref_to_vnode(dev_t mountID, ino_t directoryID,
 			const char *name, void **_vnode);
-void vfs_vnode_to_node_ref(void *_vnode, mount_id *_mountID, vnode_id *_vnodeID);
+void vfs_vnode_to_node_ref(void *_vnode, dev_t *_mountID, ino_t *_vnodeID);
 
-status_t vfs_lookup_vnode(mount_id mountID, vnode_id vnodeID, void **_vnode);
+status_t vfs_lookup_vnode(dev_t mountID, ino_t vnodeID, void **_vnode);
 void vfs_put_vnode(void *vnode);
 void vfs_acquire_vnode(void *vnode);
 status_t vfs_get_cookie_from_fd(int fd, void **_cookie);
@@ -95,13 +94,13 @@
 status_t vfs_get_vnode_cache(void *vnode, struct vm_cache_ref **_cache, bool allocate);
 status_t vfs_get_file_map( void *_vnode, off_t offset, size_t size,
 			struct file_io_vec *vecs, size_t *_count);
-status_t vfs_get_fs_node_from_path(mount_id mountID, const char *path,
+status_t vfs_get_fs_node_from_path(dev_t mountID, const char *path,
 			bool kernel, void **_node);
 status_t vfs_stat_vnode(void *_vnode, struct stat *stat);
 status_t vfs_get_vnode_name(void *vnode, char *name, size_t nameSize);
-status_t vfs_get_cwd(mount_id *_mountID, vnode_id *_vnodeID);
+status_t vfs_get_cwd(dev_t *_mountID, ino_t *_vnodeID);
 void vfs_unlock_vnode_if_locked(struct file_descriptor *descriptor);
-status_t vfs_disconnect_vnode(mount_id mountID, vnode_id vnodeID);
+status_t vfs_disconnect_vnode(dev_t mountID, ino_t vnodeID);
 void vfs_free_unused_vnodes(int32 level);
 
 /* special module convenience call */
@@ -113,8 +112,8 @@
 			bool kernel);
 
 /* service call for the node monitor */
-status_t resolve_mount_point_to_volume_root(mount_id mountID, vnode_id nodeID,
-			mount_id *resolvedMountID, vnode_id *resolvedNodeID);
+status_t resolve_mount_point_to_volume_root(dev_t mountID, ino_t nodeID,
+			dev_t *resolvedMountID, ino_t *resolvedNodeID);
 
 /* calls the syscall dispatcher should use for user file I/O */
 dev_t _user_mount(const char *path, const char *device, const char *fs_name,

Modified: haiku/trunk/headers/private/userlandfs/private/Requests.h
===================================================================
--- haiku/trunk/headers/private/userlandfs/private/Requests.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/headers/private/userlandfs/private/Requests.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -326,7 +326,7 @@
 	MountVolumeRequest() : Request(MOUNT_VOLUME_REQUEST) {}
 	status_t GetAddressInfos(AddressInfo* infos, int32* count);
 
-	mount_id	nsid;
+	dev_t		nsid;
 	Address		cwd;			// current working dir of the mount() caller
 	Address		device;
 	uint32		flags;
@@ -338,7 +338,7 @@
 public:
 	MountVolumeReply() : ReplyRequest(MOUNT_VOLUME_REPLY) {}
 
-	vnode_id	rootID;
+	ino_t		rootID;
 	fs_volume	volume;
 };
 
@@ -430,7 +430,7 @@
 public:
 	LookupReply() : ReplyRequest(LOOKUP_REPLY) {}
 
-	vnode_id	vnid;
+	ino_t		vnid;
 	int			type;
 };
 
@@ -456,7 +456,7 @@
 public:
 	ReadVNodeRequest() : VolumeRequest(READ_VNODE_REQUEST) {}
 
-	vnode_id	vnid;
+	ino_t		vnid;
 	bool		reenter;
 };
 
@@ -731,7 +731,7 @@
 public:
 	CreateReply() : ReplyRequest(CREATE_REPLY) {}
 
-	vnode_id	vnid;
+	ino_t		vnid;
 	fs_cookie	fileCookie;
 };
 
@@ -831,7 +831,7 @@
 public:
 	CreateDirReply() : ReplyRequest(CREATE_DIR_REPLY) {}
 
-	vnode_id	newDir;
+	ino_t		newDir;
 };
 
 // RemoveDirRequest
@@ -1374,10 +1374,10 @@
 	int32		operation;
 	uint32		details;			// for B_STAT_CHANGED:statFields
 									// and B_ATTRIBUTE_CHANGED:cause
-	mount_id	device;
-	vnode_id	oldDirectory;
-	vnode_id	directory;
-	vnode_id	node;
+	dev_t		device;
+	ino_t		oldDirectory;
+	ino_t		directory;
+	ino_t		node;
 	Address		oldName;
 	Address		name;
 };
@@ -1414,9 +1414,9 @@
 	port_id		port;
 	int32		token;
 	int32		operation;			// B_ENTRY_{CREATED,REMOVED}
-	mount_id	device;
-	vnode_id	directory;
-	vnode_id	node;
+	dev_t		device;
+	ino_t		directory;
+	ino_t		node;
 	Address		name;
 };
 
@@ -1435,8 +1435,8 @@
 public:
 	GetVNodeRequest() : Request(GET_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 };
 
 // GetVNodeReply
@@ -1452,8 +1452,8 @@
 public:
 	PutVNodeRequest() : Request(PUT_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 };
 
 // PutVNodeReply
@@ -1467,8 +1467,8 @@
 public:
 	NewVNodeRequest() : Request(NEW_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 	fs_vnode	node;
 };
 
@@ -1483,8 +1483,8 @@
 public:
 	PublishVNodeRequest() : Request(PUBLISH_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 	fs_vnode	node;
 };
 
@@ -1499,8 +1499,8 @@
 public:
 	RemoveVNodeRequest() : Request(REMOVE_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 };
 
 // RemoveVNodeReply
@@ -1514,8 +1514,8 @@
 public:
 	UnremoveVNodeRequest() : Request(UNREMOVE_VNODE_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 };
 
 // UnremoveVNodeReply
@@ -1529,8 +1529,8 @@
 public:
 	GetVNodeRemovedRequest() : Request(GET_VNODE_REMOVED_REQUEST) {}
 
-	mount_id	nsid;
-	vnode_id	vnid;
+	dev_t		nsid;
+	ino_t		vnid;
 };
 
 // GetVNodeRemovedReply

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -977,7 +977,7 @@
 
 		char name[B_FILE_NAME_LENGTH];
 		uint16 length;
-		vnode_id id;
+		ino_t id;
 
 		status_t status = cookie-&gt;iterator-&gt;GetNextEntry(name, &amp;length, B_FILE_NAME_LENGTH, &amp;id);
 		if (status == B_ENTRY_NOT_FOUND) {

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -79,7 +79,7 @@
 	if (indices-&gt;GetTree(&amp;tree) != B_OK)
 		return B_BAD_VALUE;
 
-	vnode_id id;
+	ino_t id;
 	status_t status = tree-&gt;Find((uint8 *)name, (uint16)strlen(name), &amp;id);
 	if (status != B_OK)
 		return status;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -165,7 +165,7 @@
 //	#pragma mark - Inode
 
 
-Inode::Inode(Volume *volume, vnode_id id)
+Inode::Inode(Volume *volume, ino_t id)
 	:
 	fVolume(volume),
 	fID(id),
@@ -194,7 +194,8 @@
 }
 
 
-Inode::Inode(Volume *volume, Transaction &amp;transaction, vnode_id id, mode_t mode, block_run &amp;run)
+Inode::Inode(Volume *volume, Transaction &amp;transaction, ino_t id, mode_t mode,
+		block_run &amp;run)
 	:
 	fVolume(volume),
 	fID(id),
@@ -1002,7 +1003,7 @@
 	BPlusTree *tree;
 	status_t status = attributes-&gt;GetTree(&amp;tree);
 	if (status == B_OK) {
-		vnode_id id;
+		ino_t id;
 		status = tree-&gt;Find((uint8 *)name, (uint16)strlen(name), &amp;id);
 		if (status == B_OK) {
 			Vnode vnode(fVolume, id);
@@ -1090,7 +1091,7 @@
 	uint32 count = 0;
 	char name[BPLUSTREE_MAX_KEY_LENGTH];
 	uint16 length;
-	vnode_id id;
+	ino_t id;
 	while (iterator.GetNextEntry(name, &amp;length, B_FILE_NAME_LENGTH,
 			&amp;id) == B_OK) {
 		if (Mode() &amp; (S_ATTR_DIR | S_INDEX_DIR))
@@ -2011,7 +2012,7 @@
 		char name[B_FILE_NAME_LENGTH];
 		uint32 type;
 		size_t length;
-		vnode_id id;
+		ino_t id;
 		while ((status = iterator.GetNext(name, &amp;length, &amp;type, &amp;id)) == B_OK) {
 			RemoveAttribute(transaction, name);
 		}
@@ -2123,7 +2124,7 @@
 
 
 status_t
-Inode::Remove(Transaction &amp;transaction, const char *name, vnode_id *_id,
+Inode::Remove(Transaction &amp;transaction, const char *name, ino_t *_id,
 	bool isDirectory)
 {
 	BPlusTree *tree;
@@ -2220,7 +2221,7 @@
 */
 status_t
 Inode::Create(Transaction &amp;transaction, Inode *parent, const char *name,
-	int32 mode, int openMode, uint32 type, bool *_created, vnode_id *_id,
+	int32 mode, int openMode, uint32 type, bool *_created, ino_t *_id,
 	Inode **_inode)
 {
 	FUNCTION_START((&quot;name = %s, mode = %ld\n&quot;, name, mode));
@@ -2456,7 +2457,7 @@
 
 status_t
 AttributeIterator::GetNext(char *name, size_t *_length, uint32 *_type,
-	vnode_id *_id)
+	ino_t *_id)
 {
 	// read attributes out of the small data section
 
@@ -2484,7 +2485,7 @@
 			strncpy(name, item-&gt;Name(), B_FILE_NAME_LENGTH);
 			*_type = item-&gt;Type();
 			*_length = item-&gt;NameSize();
-			*_id = (vnode_id)fCurrentSmallData;
+			*_id = (ino_t)fCurrentSmallData;
 
 			fCurrentSmallData = i;
 		}
@@ -2510,7 +2511,7 @@
 	if (fAttributes == NULL) {
 		if (get_vnode(volume-&gt;ID(), volume-&gt;ToVnode(fInode-&gt;Attributes()),
 				(void **)&amp;fAttributes) != B_OK) {
-			FATAL((&quot;get_vnode() failed in AttributeIterator::GetNext(vnode_id&quot;
+			FATAL((&quot;get_vnode() failed in AttributeIterator::GetNext(ino_t&quot;
 				&quot; = %Ld,name = \&quot;%s\&quot;)\n&quot;,fInode-&gt;ID(),name));
 			return B_ENTRY_NOT_FOUND;
 		}
@@ -2518,14 +2519,14 @@
 		BPlusTree *tree;
 		if (fAttributes-&gt;GetTree(&amp;tree) &lt; B_OK
 			|| (fIterator = new TreeIterator(tree)) == NULL) {
-			FATAL((&quot;could not get tree in AttributeIterator::GetNext(vnode_id&quot;
+			FATAL((&quot;could not get tree in AttributeIterator::GetNext(ino_t&quot;
 				&quot; = %Ld,name = \&quot;%s\&quot;)\n&quot;,fInode-&gt;ID(),name));
 			return B_ENTRY_NOT_FOUND;
 		}
 	}
 
 	uint16 length;
-	vnode_id id;
+	ino_t id;
 	status_t status = fIterator-&gt;GetNextEntry(name, &amp;length,
 		B_FILE_NAME_LENGTH, &amp;id);
 	if (status &lt; B_OK)

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -35,14 +35,14 @@
 
 class Inode {
 	public:
-		Inode(Volume *volume, vnode_id id);
-		Inode(Volume *volume, Transaction &amp;transaction, vnode_id id,
+		Inode(Volume *volume, ino_t id);
+		Inode(Volume *volume, Transaction &amp;transaction, ino_t id,
 			mode_t mode, block_run &amp;run);
 		//Inode(CachedBlock *cached);
 		~Inode();
 
 		//bfs_inode *Node() const { return (bfs_inode *)fBlock; }
-		vnode_id ID() const { return fID; }
+		ino_t ID() const { return fID; }
 		off_t BlockNumber() const { return fVolume-&gt;VnodeToBlock(fID); }
 
 		ReadWriteLock &amp;Lock() { return fLock; }
@@ -138,10 +138,10 @@
 
 		// create/remove inodes
 		status_t Remove(Transaction &amp;transaction, const char *name,
-			vnode_id *_id = NULL, bool isDirectory = false);
+			ino_t *_id = NULL, bool isDirectory = false);
 		static status_t Create(Transaction &amp;transaction, Inode *parent,
 			const char *name, int32 mode, int openMode, uint32 type,
-			bool *_created = NULL, vnode_id *_id = NULL, Inode **_inode = NULL);
+			bool *_created = NULL, ino_t *_id = NULL, Inode **_inode = NULL);
 
 		// index maintaining helper
 		void UpdateOldSize()
@@ -194,7 +194,7 @@
 	private:
 		ReadWriteLock	fLock;
 		Volume			*fVolume;
-		vnode_id		fID;
+		ino_t			fID;
 		BPlusTree		*fTree;
 		Inode			*fAttributes;
 		void			*fCache;
@@ -251,7 +251,7 @@
 
 class Vnode {
 	public:
-		Vnode(Volume *volume, vnode_id id)
+		Vnode(Volume *volume, ino_t id)
 			:
 			fVolume(volume),
 			fID(id)
@@ -290,7 +290,7 @@
 
 	private:
 		Volume		*fVolume;
-		vnode_id	fID;
+		ino_t		fID;
 };
 
 
@@ -300,7 +300,7 @@
 		~AttributeIterator();
 		
 		status_t Rewind();
-		status_t GetNext(char *name, size_t *length, uint32 *type, vnode_id *id);
+		status_t GetNext(char *name, size_t *length, uint32 *type, ino_t *id);
 
 	private:
 		friend class Chain&lt;AttributeIterator&gt;;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -242,7 +242,7 @@
 //	#pragma mark -
 
 
-Volume::Volume(mount_id id)
+Volume::Volume(dev_t id)
 	:
 	fID(id),
 	fBlockAllocator(this),

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -1,6 +1,5 @@
-/* Volume - BFS super block, mounting, etc.
- *
- * Copyright 2001-2004, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+/*
+ * Copyright 2001-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
  * This file may be used under the terms of the MIT License.
  */
 #ifndef VOLUME_H
@@ -27,7 +26,7 @@
 
 class Volume {
 	public:
-		Volume(mount_id id);
+		Volume(dev_t id);
 		~Volume();
 
 		status_t			Mount(const char *device, uint32 flags);
@@ -49,7 +48,7 @@
 		vint32				&amp;LogEnd() { return fLogEnd; }
 		int					Device() const { return fDevice; }
 
-		mount_id			ID() const { return fID; }
+		dev_t				ID() const { return fID; }
 		const char			*Name() const { return fSuperBlock.name; }
 
 		off_t				NumBlocks() const { return fSuperBlock.NumBlocks(); }
@@ -70,7 +69,7 @@
 
 		off_t				ToVnode(block_run run) const { return ToBlock(run); }
 		off_t				ToVnode(off_t block) const { return block; }
-		off_t				VnodeToBlock(vnode_id id) const { return (off_t)id; }
+		off_t				VnodeToBlock(ino_t id) const { return (off_t)id; }
 
 		status_t			CreateIndicesRoot(Transaction &amp;transaction);
 
@@ -106,7 +105,7 @@
 		static status_t		Identify(int fd, disk_super_block *superBlock);
 
 	protected:
-		mount_id			fID;
+		dev_t				fID;
 		int					fDevice;
 		disk_super_block	fSuperBlock;
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/bfs_control.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/bfs_control.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/bfs_control.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -1,12 +1,13 @@
+/*
+ * Copyright 2001-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de</A>
+ * This file may be used under the terms of the MIT License.
+ */
 #ifndef BFS_CONTROL_H
 #define BFS_CONTROL_H
-/* bfs_control - additional functionality exported via ioctl()
-**
-** Copyright 2001-2004, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de</A>
-** This file may be used under the terms of the OpenBeOS License.
-*/
 
+//! additional functionality exported via ioctl()
 
+
 #include &quot;system_dependencies.h&quot;
 
 
@@ -29,7 +30,7 @@
 	uint32		magic;
 	uint32		flags;
 	char		name[B_FILE_NAME_LENGTH];
-	vnode_id	inode;
+	ino_t		inode;
 	uint32		mode;
 	uint32		errors;
 	struct {

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -104,8 +104,8 @@
 
 
 static status_t
-bfs_mount(mount_id mountID, const char *device, uint32 flags, const char *args,
-	void **_data, vnode_id *_rootID)
+bfs_mount(dev_t mountID, const char *device, uint32 flags, const char *args,
+	void **_data, ino_t *_rootID)
 {
 	FUNCTION();
 
@@ -229,9 +229,9 @@
  */
 
 static status_t
-bfs_read_vnode(void *_ns, vnode_id id, void **_node, bool reenter)
+bfs_read_vnode(void *_ns, ino_t id, void **_node, bool reenter)
 {
-	//FUNCTION_START((&quot;vnode_id = %Ld\n&quot;, id));
+	//FUNCTION_START((&quot;ino_t = %Ld\n&quot;, id));
 	Volume *volume = (Volume *)_ns;
 
 	// first inode may be after the log area, we don't go through
@@ -444,7 +444,7 @@
 
 
 static status_t
-bfs_lookup(void *_ns, void *_directory, const char *file, vnode_id *_vnodeID, int *_type)
+bfs_lookup(void *_ns, void *_directory, const char *file, ino_t *_vnodeID, int *_type)
 {
 	//FUNCTION_START((&quot;file = %s\n&quot;, file));
 	if (_ns == NULL || _directory == NULL || file == NULL || _vnodeID == NULL)
@@ -740,7 +740,7 @@
 
 status_t 
 bfs_create(void *_ns, void *_directory, const char *name, int openMode, int mode,
-	void **_cookie, vnode_id *_vnodeID)
+	void **_cookie, ino_t *_vnodeID)
 {
 	FUNCTION_START((&quot;name = \&quot;%s\&quot;, perms = %d, openMode = %d\n&quot;, name, mode, openMode));
 
@@ -942,8 +942,8 @@
 	// If we meet our inode on that way, we have to bail out.
 
 	if (oldDirectory != newDirectory) {
-		vnode_id parent = volume-&gt;ToVnode(newDirectory-&gt;Parent());
-		vnode_id root = volume-&gt;RootNode()-&gt;ID();
+		ino_t parent = volume-&gt;ToVnode(newDirectory-&gt;Parent());
+		ino_t root = volume-&gt;RootNode()-&gt;ID();
 
 		while (true) {
 			if (parent == id)
@@ -1357,7 +1357,7 @@
 
 static status_t
 bfs_create_dir(void *_ns, void *_directory, const char *name, int mode,
-	vnode_id *_newVnodeID)
+	ino_t *_newVnodeID)
 {
 	FUNCTION_START((&quot;name = \&quot;%s\&quot;, perms = %d\n&quot;, name, mode));
 
@@ -1466,7 +1466,7 @@
 		RETURN_ERROR(B_BAD_VALUE);
 
 	uint16 length;
-	vnode_id id;
+	ino_t id;
 	status_t status = iterator-&gt;GetNextEntry(dirent-&gt;d_name, &amp;length, bufferSize, &amp;id);
 	if (status == B_ENTRY_NOT_FOUND) {
 		*_num = 0;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2007-06-21 19:50:57 UTC (rev 21485)
@@ -76,24 +76,24 @@
 
 class Volume {
 	public:
-		Volume(mount_id id);
+		Volume(dev_t id);
 		~Volume();
 
 		status_t	InitCheck();
-		mount_id	ID() const { return fID; }
+		dev_t		ID() const { return fID; }
 		uint32		DiscID() const { return fDiscID; }
 		Inode		&amp;RootNode() const { return *fRootNode; }
 
 		status_t	Mount(const char* device);
 		int			Device() const { return fDevice; }
-		vnode_id	GetNextNodeID() { return fNextID++; }
+		ino_t		GetNextNodeID() { return fNextID++; }
 
 		const char	*Name() const { return fName; }
 		status_t	SetName(const char *name);
 
 		Semaphore	&amp;Lock();
 
-		Inode		*Find(vnode_id id);
+		Inode		*Find(ino_t id);
 		Inode		*Find(const char *name);
 
 		Inode		*FirstEntry() const { return fFirstEntry; }
@@ -116,10 +116,10 @@
 
 		Semaphore	fLock;
 		int			fDevice;
-		mount_id	fID;
+		dev_t		fID;
 		uint32		fDiscID;
 		Inode 		*fRootNode;
-		vnode_id	fNextID;
+		ino_t		fNextID;
 		char		*fName;
 		off_t		fNumBlocks;
 
@@ -160,7 +160,7 @@
 		~Inode();
 
 		status_t	InitCheck();
-		vnode_id	ID() const { return fID; }
+		ino_t		ID() const { return fID; }
 
 		const char	*Name() const { return fName; }
 		status_t	SetName(const char* name);
@@ -206,7 +206,7 @@
 
 	private:
 		Inode		*fNext;
-		vnode_id	fID;
+		ino_t		fID;
 		int32		fType;
 		char		*fName;
 		gid_t		fGroupID;
@@ -447,7 +447,7 @@
 //	#pragma mark - Volume class
 
 
-Volume::Volume(mount_id id)
+Volume::Volume(dev_t id)
 	:
 	fLock(&quot;cdda&quot;),
 	fDevice(-1),
@@ -655,7 +655,7 @@
 
 
 Inode *
-Volume::Find(vnode_id id)
+Volume::Find(ino_t id)
 {
 	for (Inode *inode = fFirstEntry; inode != NULL; inode = inode-&gt;Next()) {
 		if (inode-&gt;ID() == id)
@@ -1268,8 +1268,8 @@
 
 
 static status_t
-cdda_mount(mount_id id, const char *device, uint32 flags, const char *args,
-	fs_volume *_volume, vnode_id *_rootVnodeID)
+cdda_mount(dev_t id, const char *device, uint32 flags, const char *args,
+	fs_volume *_volume, ino_t *_rootVnodeID)
 {
 	TRACE((&quot;cdda_mount: entry\n&quot;));
 
@@ -1355,7 +1355,7 @@
 
 
 static status_t
-cdda_lookup(fs_volume _volume, fs_vnode _dir, const char *name, vnode_id *_id, int *_type)
+cdda_lookup(fs_volume _volume, fs_vnode _dir, const char *name, ino_t *_id, int *_type)
 {
 	Volume *volume = (Volume *)_volume;
 	status_t status;
@@ -1398,7 +1398,7 @@
 
 
 static status_t
-cdda_get_vnode(fs_volume _volume, vnode_id id, fs_vnode *_inode, bool reenter)
+cdda_get_vnode(fs_volume _volume, ino_t id, fs_vnode *_inode, bool reenter)
 {
 	Volume *volume = (Volume *)_volume;
 	Inode *inode;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.c	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.c	2007-06-21 19:50:57 UTC (rev 21485)
@@ -39,7 +39,7 @@
 
 static CHECK_MAGIC(dircookie,struct dircookie, DIRCOOKIE_MAGIC)
 static status_t	findfile(nspace *vol, vnode *dir, const char *file,
-				vnode_id *vnid, vnode **node, bool check_case,
+				ino_t *vnid, vnode **node, bool check_case,
 				bool check_dups, bool *dups_exist);
 
 // private structure for returning data from _next_dirent_()
@@ -205,7 +205,7 @@
 
 
 static status_t
-get_next_dirent(nspace *vol, vnode *dir, struct diri *iter, vnode_id *vnid,
+get_next_dirent(nspace *vol, vnode *dir, struct diri *iter, ino_t *vnid,
 	char *filename, int len)
 {
 	struct _dirent_info_ info;
@@ -229,7 +229,7 @@
 		if (vnid) *vnid = dir-&gt;dir_vnid;
 	} else {
 		if (vnid) {
-			vnode_id loc = (IS_DATA_CLUSTER(info.cluster))
+			ino_t loc = (IS_DATA_CLUSTER(info.cluster))
 				? GENERATE_DIR_CLUSTER_VNID(dir-&gt;vnid, info.cluster)
 				: GENERATE_DIR_INDEX_VNID(dir-&gt;vnid, info.sindex);
 			bool added_to_vcache = false;
@@ -320,7 +320,7 @@
 
 
 status_t
-findfile_case(nspace *vol, vnode *dir, const char *file, vnode_id *vnid,
+findfile_case(nspace *vol, vnode *dir, const char *file, ino_t *vnid,
 	vnode **node)
 {
 	return findfile(vol, dir, file, vnid, node, true, false, NULL);
@@ -328,7 +328,7 @@
 
 
 status_t
-findfile_nocase(nspace *vol, vnode *dir, const char *file, vnode_id *vnid,
+findfile_nocase(nspace *vol, vnode *dir, const char *file, ino_t *vnid,
 	vnode **node)
 {
 	return findfile(vol, dir, file, vnid, node, false, false, NULL);
@@ -337,7 +337,7 @@
 
 status_t
 findfile_nocase_duplicates(nspace *vol, vnode *dir, const char *file,
-	vnode_id *vnid, vnode **node, bool *dups_exist)
+	ino_t *vnid, vnode **node, bool *dups_exist)
 {
 	return findfile(vol, dir, file, vnid, node, false, true, dups_exist);
 }
@@ -345,14 +345,14 @@
 
 status_t
 findfile_case_duplicates(nspace *vol, vnode *dir, const char *file,
-	vnode_id *vnid, vnode **node, bool *dups_exist)
+	ino_t *vnid, vnode **node, bool *dups_exist)
 {
 	return findfile(vol, dir, file, vnid, node, true, true, dups_exist);
 }
 
 
 static status_t
-findfile(nspace *vol, vnode *dir, const char *file, vnode_id *vnid,
+findfile(nspace *vol, vnode *dir, const char *file, ino_t *vnid,
 	vnode **node, bool check_case, bool check_dups, bool *dups_exist)
 {
 	/* Starting at the base, find the file in the subdir
@@ -366,7 +366,7 @@
 	   any other case-insensitive matches. If there are, the
 	   dups_exist flag is set to true. */
 	int		result = 0;
-	vnode_id	found_vnid = 0;
+	ino_t	found_vnid = 0;
 	bool found_file = false;
 
 //	dprintf(&quot;findfile: %s in %Lx, case %d dups %d\n&quot;, file, dir-&gt;vnid, check_case, check_dups);
@@ -400,7 +400,7 @@
 
 		while (1) {
 			char filename[512];
-			vnode_id _vnid;
+			ino_t _vnid;
 
 			result = get_next_dirent(vol, dir, &amp;diri, &amp;_vnid, filename, 512);
 			if (result != B_NO_ERROR)
@@ -922,11 +922,11 @@
 
 
 status_t 
-dosfs_read_vnode(void *_vol, vnode_id vnid, void **_node, bool reenter)
+dosfs_read_vnode(void *_vol, ino_t vnid, void **_node, bool reenter)
 {
 	nspace *vol = (nspace*)_vol;
 	int result = B_NO_ERROR;
-	vnode_id loc, dir_vnid;
+	ino_t loc, dir_vnid;
 	vnode *entry;
 	struct _dirent_info_ info;
 	struct diri iter;
@@ -1027,11 +1027,11 @@
 		entry-&gt;st_size = count_clusters(vol,entry-&gt;cluster)
 			* vol-&gt;sectors_per_cluster * vol-&gt;bytes_per_sector;
 	}
-	if (entry-&gt;cluster)
+	if (entry-&gt;cluster) {
 		entry-&gt;end_cluster = get_nth_fat_entry(vol, info.cluster, 
-				(entry-&gt;st_size + vol-&gt;bytes_per_sector * vol-&gt;sectors_per_cluster - 1) /
-				vol-&gt;bytes_per_sector / vol-&gt;sectors_per_cluster - 1);
-	else
+			(entry-&gt;st_size + vol-&gt;bytes_per_sector * vol-&gt;sectors_per_cluster - 1) /
+			vol-&gt;bytes_per_sector / vol-&gt;sectors_per_cluster - 1);
+	} else
 		entry-&gt;end_cluster = 0;
 	entry-&gt;st_time = dos2time_t(info.time);
 #if TRACK_FILENAME
@@ -1044,17 +1044,21 @@
 
 	*_node = entry;
 
-bi2:diri_free(&amp;iter);
-bi:	if (!reenter) UNLOCK_VOL(vol);
+bi2:
+	diri_free(&amp;iter);
+bi:
+	if (!reenter)
+		UNLOCK_VOL(vol);
 
-	if (result != B_OK) DPRINTF(0, (&quot;dosfs_read_vnode (%s)\n&quot;, strerror(result)));
+	if (result != B_OK)
+		DPRINTF(0, (&quot;dosfs_read_vnode (%s)\n&quot;, strerror(result)));
 
 	return result;
 }
 
 
 status_t 
-dosfs_walk(void *_vol, void *_dir, const char *file, vnode_id *_vnid, int *_type)
+dosfs_walk(void *_vol, void *_dir, const char *file, ino_t *_vnid, int *_type)
 {
 	/* Starting at the base, find file in the subdir, and return path
 		string and vnode id of file. */

Modified: haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.h	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/dos/dir.h	2007-06-21 19:50:57 UTC (rev 21485)
@@ -8,29 +8,29 @@
 bool is_filename_legal(const char *name);
 status_t	check_dir_empty(nspace *vol, vnode *dir);
 status_t 	findfile_case(nspace *vol, vnode *dir, const char *file,
-				vnode_id *vnid, vnode **node);
+				ino_t *vnid, vnode **node);
 status_t 	findfile_nocase(nspace *vol, vnode *dir, const char *file,
-				vnode_id *vnid, vnode **node);
+				ino_t *vnid, vnode **node);
 status_t 	findfile_nocase_duplicates(nspace *vol, vnode *dir, const char *file,
-				vnode_id *vnid, vnode **node, bool *dups_exist);				
+				ino_t *vnid, vnode **node, bool *dups_exist);				
 status_t 	findfile_case_duplicates(nspace *vol, vnode *dir, const char *file,
-				vnode_id *vnid, vnode **node, bool *dups_exist);				
+				ino_t *vnid, vnode **node, bool *dups_exist);				
 status_t	erase_dir_entry(nspace *vol, vnode *node);
 status_t	compact_directory(nspace *vol, vnode *dir);
 status_t	create_volume_label(nspace *vol, const char name[11], uint32 *index);
 status_t	create_dir_entry(nspace *vol, vnode *dir, vnode *node, 
 				const char *name, uint32 *ns, uint32 *ne);
 
-status_t		dosfs_read_vnode(void *_vol, vnode_id vnid, void **node, bool reenter);
-status_t		dosfs_walk(void *_vol, void *_dir, const char *file,
-				vnode_id *_vnid, int *_type);
-status_t		dosfs_access(void *_vol, void *_node, int mode);
-status_t		dosfs_readlink(void *_vol, void *_node, char *buf, size_t *bufsize);
-status_t		dosfs_opendir(void *_vol, void *_node, void **cookie);
-status_t		dosfs_readdir(void *_vol, void *_node, void *cookie,
+status_t	dosfs_read_vnode(void *_vol, ino_t vnid, void **node, bool reenter);
+status_t	dosfs_walk(void *_vol, void *_dir, const char *file,
+				ino_t *_vnid, int *_type);
+status_t	dosfs_access(void *_vol, void *_node, int mode);
+status_t	dosfs_readlink(void *_vol, void *_node, char *buf, size_t *bufsize);
+status_t	dosfs_opendir(void *_vol, void *_node, void **cookie);
+status_t	dosfs_readdir(void *_vol, void *_node, void *cookie,
 				struct dirent *buf, size_t bufsize, uint32 *num);
-status_t		dosfs_rewinddir(void *_vol, void *_node, void *cookie);
-status_t		dosfs_closedir(void *_vol, void *_node, void *cookie);
-status_t		dosfs_free_dircookie(void *_vol, void *_node, void *cookie);
+status_t	dosfs_rewinddir(void *_vol, void *_node, void *cookie);
+status_t	dosfs_closedir(void *_vol, void *_node, void *cookie);
+status_t	dosfs_free_dircookie(void *_vol, void *_node, void *cookie);
 
 #endif

Modified: haiku/trunk/src/add-ons/kernel/file_systems/dos/dlist.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/dos/dlist.c	2007-06-21 18:40:33 UTC (rev 21484)
+++ haiku/trunk/src/add-ons/kernel/file_systems/dos/dlist.c	2007-06-21 19:50:57 UTC (rev 21485)

[... truncated: 5196 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002875.html">[Haiku-commits] r21484 - haiku/trunk/src/bin
</A></li>
	<LI>Next message: <A HREF="002858.html">[Haiku-commits] r21486 - haiku/trunk/src/kits/game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2857">[ date ]</a>
              <a href="thread.html#2857">[ thread ]</a>
              <a href="subject.html#2857">[ subject ]</a>
              <a href="author.html#2857">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
