<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26199 - haiku/trunk/src/servers/bluetooth
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26199%20-%20haiku/trunk/src/servers/bluetooth&In-Reply-To=%3C200807011943.m61Jhk08015514%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009939.html">
   <LINK REL="Next"  HREF="009942.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26199 - haiku/trunk/src/servers/bluetooth</H1>
    <B>oruizdorantes at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26199%20-%20haiku/trunk/src/servers/bluetooth&In-Reply-To=%3C200807011943.m61Jhk08015514%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26199 - haiku/trunk/src/servers/bluetooth">oruizdorantes at mail.berlios.de
       </A><BR>
    <I>Tue Jul  1 21:43:46 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009939.html">[Haiku-commits] r26198 - haiku/trunk/src/servers/bluetooth
</A></li>
        <LI>Next message: <A HREF="009942.html">[Haiku-commits] r26200 - haiku/trunk/src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9940">[ date ]</a>
              <a href="thread.html#9940">[ thread ]</a>
              <a href="subject.html#9940">[ subject ]</a>
              <a href="author.html#9940">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: oruizdorantes
Date: 2008-07-01 21:43:37 +0200 (Tue, 01 Jul 2008)
New Revision: 26199
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26199&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26199&amp;view=rev</A>

Modified:
   haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.cpp
   haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.h
   haiku/trunk/src/servers/bluetooth/HCIDelegate.h
   haiku/trunk/src/servers/bluetooth/HCITransportAccessor.h
   haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp
   haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp
Log:
Fix EOL



Modified: haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.cpp	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.cpp	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,26 +1,26 @@
-/*
- * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-
-#include &quot;HCIControllerAccessor.h&quot;
-
-HCIControllerAccessor::HCIControllerAccessor(BPath* path) : HCIDelegate(path)
-{
-
-
-}
-
-status_t
-HCIControllerAccessor::IssueCommand(raw_command* rc, size_t size)
-{
-
-	if (GetID() &lt; 0)
-		return B_ERROR;
-
-
-	return B_ERROR;
-}
+/*
+ * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ *
+ */
+
+
+#include &quot;HCIControllerAccessor.h&quot;
+
+HCIControllerAccessor::HCIControllerAccessor(BPath* path) : HCIDelegate(path)
+{
+
+
+}
+
+status_t
+HCIControllerAccessor::IssueCommand(raw_command* rc, size_t size)
+{
+
+	if (GetID() &lt; 0)
+		return B_ERROR;
+
+
+	return B_ERROR;
+}

Modified: haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.h
===================================================================
--- haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.h	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/HCIControllerAccessor.h	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,23 +1,23 @@
-/*
- * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-
-
-#ifndef _HCICONTROLLER_ACCESSOR_H_
-#define _HCICONTROLLER_ACCESSOR_H_
-
-#include &quot;HCIDelegate.h&quot;
-
-
-class HCIControllerAccessor : public HCIDelegate {
-
-	public:
-		HCIControllerAccessor(BPath* path);
-		status_t IssueCommand(raw_command* rc,  size_t size);
-};
-
-#endif
+/*
+ * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ *
+ */
+
+
+
+#ifndef _HCICONTROLLER_ACCESSOR_H_
+#define _HCICONTROLLER_ACCESSOR_H_
+
+#include &quot;HCIDelegate.h&quot;
+
+
+class HCIControllerAccessor : public HCIDelegate {
+
+	public:
+		HCIControllerAccessor(BPath* path);
+		status_t IssueCommand(raw_command* rc,  size_t size);
+};
+
+#endif

Modified: haiku/trunk/src/servers/bluetooth/HCIDelegate.h
===================================================================
--- haiku/trunk/src/servers/bluetooth/HCIDelegate.h	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/HCIDelegate.h	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,65 +1,65 @@
-/*
- * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-#ifndef _HCIDELEGATE_H_
-#define _HCIDELEGATE_H_
-
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;Path.h&gt;
-
-#include &lt;bluetooth/HCI/btHCI_transport.h&gt;
-
-
-typedef void* raw_command;
-
-
-class HCIDelegate {
-
-	public:
-		HCIDelegate(BPath* path)
-		{
-			status_t status;
-				
-			fFD = open (path-&gt;Path(), O_RDWR);
-			if (fFD &gt; 0) {
-				// find out which ID was assigned
-				status = ioctl(fFD, GET_HCI_ID, &amp;fHID, 0);
-				printf(&quot;%s: hid retrieved %ld status=%ld\n&quot;, __FUNCTION__, fHID, status);
-			}
-			else {
-				printf(&quot;%s: Device driver could not be opened %ld\n&quot;, __FUNCTION__, fHID);
-				fHID = B_ERROR;
-			}
-	    
-					
-
-		}
-						
-		hci_id GetID(void)
-		{
-			return fHID;
-		}
-				
-		virtual status_t IssueCommand(raw_command rc, size_t size)
-		{
-			return B_ERROR;
-		}
-	
-	protected:
-		
-
-		hci_id fHID;
-		int fFD;
-	
-	private:
-
-
-};
-
-#endif
+/*
+ * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ *
+ */
+
+#ifndef _HCIDELEGATE_H_
+#define _HCIDELEGATE_H_
+
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;Path.h&gt;
+
+#include &lt;bluetooth/HCI/btHCI_transport.h&gt;
+
+
+typedef void* raw_command;
+
+
+class HCIDelegate {
+
+	public:
+		HCIDelegate(BPath* path)
+		{
+			status_t status;
+				
+			fFD = open (path-&gt;Path(), O_RDWR);
+			if (fFD &gt; 0) {
+				// find out which ID was assigned
+				status = ioctl(fFD, GET_HCI_ID, &amp;fHID, 0);
+				printf(&quot;%s: hid retrieved %ld status=%ld\n&quot;, __FUNCTION__, fHID, status);
+			}
+			else {
+				printf(&quot;%s: Device driver could not be opened %ld\n&quot;, __FUNCTION__, fHID);
+				fHID = B_ERROR;
+			}
+	    
+					
+
+		}
+						
+		hci_id GetID(void)
+		{
+			return fHID;
+		}
+				
+		virtual status_t IssueCommand(raw_command rc, size_t size)
+		{
+			return B_ERROR;
+		}
+	
+	protected:
+		
+
+		hci_id fHID;
+		int fFD;
+	
+	private:
+
+
+};
+
+#endif

Modified: haiku/trunk/src/servers/bluetooth/HCITransportAccessor.h
===================================================================
--- haiku/trunk/src/servers/bluetooth/HCITransportAccessor.h	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/HCITransportAccessor.h	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,22 +1,22 @@
-/*
- * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-
-#ifndef _HCITRANSPORT_ACCESSOR_H_
-#define _HCITRANSPORT_ACCESSOR_H_
-
-#include &quot;HCIDelegate.h&quot;
-
-
-class HCITransportAccessor : public HCIDelegate {
-
-	public:
-		HCITransportAccessor(BPath* path);
-		status_t IssueCommand(raw_command rc, size_t size);
-};
-
-#endif
+/*
+ * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ *
+ */
+
+
+#ifndef _HCITRANSPORT_ACCESSOR_H_
+#define _HCITRANSPORT_ACCESSOR_H_
+
+#include &quot;HCIDelegate.h&quot;
+
+
+class HCITransportAccessor : public HCIDelegate {
+
+	public:
+		HCITransportAccessor(BPath* path);
+		status_t IssueCommand(raw_command rc, size_t size);
+};
+
+#endif

Modified: haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,170 +1,170 @@
-/*
- * Copyright 2007 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-
-#include &quot;LocalDeviceHandler.h&quot;
-
-    
-    
-LocalDeviceHandler::LocalDeviceHandler(HCIDelegate* hd)
-{
-	fHCIDelegate = hd;
-	fProperties = new BMessage();
-	
-}
-
-LocalDeviceHandler::~LocalDeviceHandler() 
-{
-
-}
-
-
-hci_id
-LocalDeviceHandler::GetID()
-{
-    return fHCIDelegate-&gt;GetID();
-}
-
-
-bool 
-LocalDeviceHandler::Available() {
-
-	return true;
-}
-
-
-void
-LocalDeviceHandler::Acquire(void) {
-
-}
-
-
-bool
-LocalDeviceHandler::IsPropertyAvailable(const BString&amp; property) {
-	
-	type_code typeFound;
-	int32     countFound;
-
-	return (fProperties-&gt;GetInfo(property.String(), &amp;typeFound, &amp;countFound) == B_OK );
-
-}
-
-
-void
-LocalDeviceHandler::AddWantedEvent(BMessage* msg) 
-{
-    fEventsWanted.Lock();
-    // TODO: review why it is neede to replicate the msg
-    fEventsWanted.AddMessage(msg);
-    fEventsWanted.Unlock();
-}
-
-void 
-LocalDeviceHandler::ClearWantedEvent(BMessage* msg)
-{
-    fEventsWanted.Lock();
-    fEventsWanted.RemoveMessage(msg);    
-    fEventsWanted.Unlock();
-
-}
-
-
-void 
-LocalDeviceHandler::ClearWantedEvent(BMessage* msg, uint16 event, uint16 opcode)
-{  
-    // Remove the whole petition from queue
-    fEventsWanted.Lock();
-
-    int16 eventFound;
-    int16 opcodeFound;
-	int32 eventIndex = 0;
-
-    // for each Event    
-    while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
-
-   		printf(&quot;@ Event expected found @%ld\n&quot;, eventIndex);
-
-        if (eventFound == event) {
-
-     		printf(&quot;@ Event matches %ld\n&quot;, eventIndex);
-            // there is an opcode specified
-            if (opcode != 0) {
-
-              	// The opcode matches
-               	if ( (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) &amp;&amp;
-               	     ((uint16)opcodeFound == opcode) ) {
-
-               	    // this should remove only the entry
-               	    printf(&quot;@ Removed event %d and opcoce %d from message %p\n&quot;, event, opcode, msg); 
-               		(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
-              		(void)msg-&gt;RemoveData(&quot;opcodeExpected&quot;, eventIndex);
-               		goto bail;
-               	}
-            }  else {
-               	// Event matches so far
-               	printf(&quot;@ Removed event %d from message %p\n&quot;, event, msg); 
-           		(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
-           		goto bail;
-            }
-
-        } 
-        eventIndex++;
-    }
-
-bail:
-
-    fEventsWanted.Unlock();
-
-}
-
-
-BMessage*
-LocalDeviceHandler::FindPetition(uint16 event, uint16 opcode, int32* indexFound)
-{
-    int16 eventFound;
-    int16 opcodeFound;
-	int32 eventIndex;
-
-    fEventsWanted.Lock();
-    // for each Petition
-    for (int32 index = 0 ; index &lt; fEventsWanted.CountMessages() ; index++) {
-        BMessage* msg = fEventsWanted.FindMessage(index);
-		
-		printf(&quot;Petition %ld ... of %ld msg #%p\n&quot;, index, fEventsWanted.CountMessages(), msg);
-		msg-&gt;PrintToStream();
-       	eventIndex = 0;
-
-        // for each Event
-        while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
-            if (eventFound == event) {
-
-        		printf(&quot;Event found %ld\n&quot;, eventIndex);
-                // there is an opcode specified.. 
-                if (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) {
-
-                	// ensure the opcode
-                	if ((uint16)opcodeFound != opcode) {
-		        		printf(&quot;opcode does not match %d\n&quot;, opcode);
-    	                break;
-    	            }
-              		printf(&quot;Opcdodes match %d %d \n&quot;, opcode , opcodeFound);
-                } 
-
-	            fEventsWanted.Unlock();
-				if (indexFound != NULL)
-					*indexFound = eventIndex;
-    	        return msg;
-
-
-            } 
-            eventIndex++;
-        }
-    }
-
-    fEventsWanted.Unlock();
-    return NULL;
-}
+/*
+ * Copyright 2007 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ *
+ * All rights reserved. Distributed under the terms of the MIT License.
+ *
+ */
+
+
+#include &quot;LocalDeviceHandler.h&quot;
+
+    
+    
+LocalDeviceHandler::LocalDeviceHandler(HCIDelegate* hd)
+{
+	fHCIDelegate = hd;
+	fProperties = new BMessage();
+	
+}
+
+LocalDeviceHandler::~LocalDeviceHandler() 
+{
+
+}
+
+
+hci_id
+LocalDeviceHandler::GetID()
+{
+    return fHCIDelegate-&gt;GetID();
+}
+
+
+bool 
+LocalDeviceHandler::Available() {
+
+	return true;
+}
+
+
+void
+LocalDeviceHandler::Acquire(void) {
+
+}
+
+
+bool
+LocalDeviceHandler::IsPropertyAvailable(const BString&amp; property) {
+	
+	type_code typeFound;
+	int32     countFound;
+
+	return (fProperties-&gt;GetInfo(property.String(), &amp;typeFound, &amp;countFound) == B_OK );
+
+}
+
+
+void
+LocalDeviceHandler::AddWantedEvent(BMessage* msg) 
+{
+    fEventsWanted.Lock();
+    // TODO: review why it is neede to replicate the msg
+    fEventsWanted.AddMessage(msg);
+    fEventsWanted.Unlock();
+}
+
+void 
+LocalDeviceHandler::ClearWantedEvent(BMessage* msg)
+{
+    fEventsWanted.Lock();
+    fEventsWanted.RemoveMessage(msg);    
+    fEventsWanted.Unlock();
+
+}
+
+
+void 
+LocalDeviceHandler::ClearWantedEvent(BMessage* msg, uint16 event, uint16 opcode)
+{  
+    // Remove the whole petition from queue
+    fEventsWanted.Lock();
+
+    int16 eventFound;
+    int16 opcodeFound;
+	int32 eventIndex = 0;
+
+    // for each Event    
+    while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
+
+   		printf(&quot;@ Event expected found @%ld\n&quot;, eventIndex);
+
+        if (eventFound == event) {
+
+     		printf(&quot;@ Event matches %ld\n&quot;, eventIndex);
+            // there is an opcode specified
+            if (opcode != 0) {
+
+              	// The opcode matches
+               	if ( (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) &amp;&amp;
+               	     ((uint16)opcodeFound == opcode) ) {
+
+               	    // this should remove only the entry
+               	    printf(&quot;@ Removed event %d and opcoce %d from message %p\n&quot;, event, opcode, msg); 
+               		(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
+              		(void)msg-&gt;RemoveData(&quot;opcodeExpected&quot;, eventIndex);
+               		goto bail;
+               	}
+            }  else {
+               	// Event matches so far
+               	printf(&quot;@ Removed event %d from message %p\n&quot;, event, msg); 
+           		(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
+           		goto bail;
+            }
+
+        } 
+        eventIndex++;
+    }
+
+bail:
+
+    fEventsWanted.Unlock();
+
+}
+
+
+BMessage*
+LocalDeviceHandler::FindPetition(uint16 event, uint16 opcode, int32* indexFound)
+{
+    int16 eventFound;
+    int16 opcodeFound;
+	int32 eventIndex;
+
+    fEventsWanted.Lock();
+    // for each Petition
+    for (int32 index = 0 ; index &lt; fEventsWanted.CountMessages() ; index++) {
+        BMessage* msg = fEventsWanted.FindMessage(index);
+		
+		printf(&quot;Petition %ld ... of %ld msg #%p\n&quot;, index, fEventsWanted.CountMessages(), msg);
+		msg-&gt;PrintToStream();
+       	eventIndex = 0;
+
+        // for each Event
+        while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
+            if (eventFound == event) {
+
+        		printf(&quot;Event found %ld\n&quot;, eventIndex);
+                // there is an opcode specified.. 
+                if (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) {
+
+                	// ensure the opcode
+                	if ((uint16)opcodeFound != opcode) {
+		        		printf(&quot;opcode does not match %d\n&quot;, opcode);
+    	                break;
+    	            }
+              		printf(&quot;Opcdodes match %d %d \n&quot;, opcode , opcodeFound);
+                } 
+
+	            fEventsWanted.Unlock();
+				if (indexFound != NULL)
+					*indexFound = eventIndex;
+    	        return msg;
+
+
+            } 
+            eventIndex++;
+        }
+    }
+
+    fEventsWanted.Unlock();
+    return NULL;
+}

Modified: haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp	2008-07-01 19:35:10 UTC (rev 26198)
+++ haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp	2008-07-01 19:43:37 UTC (rev 26199)
@@ -1,551 +1,551 @@
-/*
- * Copyright 2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
- * All rights reserved. Distributed under the terms of the MIT License.
- *
- */
-
-
-#include &quot;BluetoothServer.h&quot;
-
-#include &quot;LocalDeviceImpl.h&quot;
-#include &quot;CommandManager.h&quot;
-#include &quot;Output.h&quot;
-
-#include &lt;bluetooth/bluetooth_error.h&gt;
-#include &lt;bluetooth/HCI/btHCI_event.h&gt;
-
-#include &lt;bluetoothserver_p.h&gt;
-#include &lt;ConnectionIncoming.h&gt;
-#include &lt;PincodeWindow.h&gt;
-
-#include &lt;stdio.h&gt;
-
-
-#if 0
-#pragma mark - Class methods -
-#endif
-
-
-// Factory methods
-LocalDeviceImpl* 
-LocalDeviceImpl::CreateControllerAccessor(BPath* path)
-{
-    HCIDelegate* hd = new HCIControllerAccessor(path);
-    
-    if ( hd != NULL)
-        return new LocalDeviceImpl(hd);
-    else
-        return NULL;
-}
-
-
-LocalDeviceImpl* 
-LocalDeviceImpl::CreateTransportAccessor(BPath* path)
-{
-    HCIDelegate* hd = new HCITransportAccessor(path);
-    
-    if ( hd != NULL)
-        return new LocalDeviceImpl(hd);    
-    else
-        return NULL;        
-}
-
-
-LocalDeviceImpl::LocalDeviceImpl(HCIDelegate* hd) : LocalDeviceHandler(hd)
-{
-
-}
-
-#if 0
-#pragma mark - Event handling methods -
-#endif
-
-void 
-LocalDeviceImpl::HandleEvent(struct hci_event_header* event)
-{
-
-printf(&quot;### Event comming: len = %d\n&quot;, event-&gt;elen);
-for (int16 index = 0 ; index &lt; event-&gt;elen + 2; index++ ) {
-	printf(&quot;%x:&quot;,((uint8*)event)[index]);
-}
-printf(&quot;### \n&quot;);
-
-	// Events here might have not been initated by us
-    switch (event-&gt;ecode) {
-	        case HCI_EVENT_HARDWARE_ERROR:
-   				//HardwareError(event);    	
-   			return;
-			case HCI_EVENT_CONN_REQUEST:
-	
-			break;
-
-			case HCI_EVENT_CONN_COMPLETE:
-				ConnectionComplete((struct hci_ev_conn_complete*)(event+1), NULL); // should belong to a request?
-	
-			break;
-
-			case HCI_EVENT_PIN_CODE_REQ:
-				PinCodeRequest((struct hci_ev_pin_code_req*)(event+1), NULL);
-			break;
-
-
-   			default:
-   				// lets go on
-   			break;        
-	}
-
-	
-
-	BMessage* request = NULL;
-	int32 	  eventIndexLocation;
-	
-	// Check if its a requested one
-	if ( event-&gt;ecode == HCI_EVENT_CMD_COMPLETE ) {
-	
-		(Output::Instance()-&gt;Post(&quot;Incoming Command Complete\n&quot;, BLACKBOARD_EVENTS));
-		request = FindPetition(event-&gt;ecode, ((struct hci_ev_cmd_complete*)(event+1))-&gt;opcode, &amp;eventIndexLocation );
-	
-	} else if ( event-&gt;ecode == HCI_EVENT_CMD_STATUS ) {
-
-		(Output::Instance()-&gt;Post(&quot;Incoming Command Status\n&quot;, BLACKBOARD_EVENTS));
-		request = FindPetition(event-&gt;ecode, ((struct hci_ev_cmd_status*)(event+1))-&gt;opcode, &amp;eventIndexLocation );
-
-	} else 
-	{	
-		request = FindPetition(event-&gt;ecode);
-	}
-	
-	if ( request == NULL) {
-		(Output::Instance()-&gt;Post(&quot;Event could not be understood or delivered\n&quot;, BLACKBOARD_EVENTS));
-		return;
-	}
-
-	// we are waiting for a reply
-	switch (event-&gt;ecode) {
-		case HCI_EVENT_INQUIRY_COMPLETE:
-    		InquiryComplete((uint8*)(event+1), request);
-    	break;
-    	
-    	case HCI_EVENT_INQUIRY_RESULT:
-    		InquiryResult((uint8*)(event+1), request);
-		break;
-
-		case HCI_EVENT_DISCONNECTION_COMPLETE:
-
-		break;
- 	
-		case HCI_EVENT_AUTH_COMPLETE:
-		break;
- 			
-		case HCI_EVENT_REMOTE_NAME_REQUEST_COMPLETE:
-			RemoteNameRequestComplete((struct hci_remote_name_request_complete_reply*)(event+1), request);		
-		break;
- 	
-		case HCI_EVENT_ENCRYPT_CHANGE:
-		break;
- 	
-		case HCI_EVENT_CHANGE_CONN_LINK_KEY_COMPLETE:
-		break;
- 	
-		case HCI_EVENT_MASTER_LINK_KEY_COMPL:
-		break;
- 	
-		case HCI_EVENT_RMT_FEATURES:
-		break;
- 	
-		case HCI_EVENT_RMT_VERSION:
-		break;
- 	
-		case HCI_EVENT_QOS_SETUP_COMPLETE:
-		break;
-
-		case HCI_EVENT_CMD_COMPLETE:    				
-			CommandComplete((struct hci_ev_cmd_complete*)(event+1), request, eventIndexLocation);
- 		break;
-
- 		case HCI_EVENT_CMD_STATUS:
- 			CommandStatus((struct hci_ev_cmd_status*)(event+1), request, eventIndexLocation);
-		break;
-
-		case HCI_EVENT_FLUSH_OCCUR:
-		break;
- 	
-		case HCI_EVENT_ROLE_CHANGE:
-		break;
- 	
-		case HCI_EVENT_NUM_COMP_PKTS:
-		break;
- 	
-		case HCI_EVENT_MODE_CHANGE:
-		break;
- 	
-		case HCI_EVENT_RETURN_LINK_KEYS:
-		break;
-
-		case HCI_EVENT_LINK_KEY_REQ:
-		break;
- 	
-		case HCI_EVENT_LINK_KEY_NOTIFY:
-		break;
- 		
-		case HCI_EVENT_LOOPBACK_COMMAND:
-		break;
- 	
-		case HCI_EVENT_DATA_BUFFER_OVERFLOW:
-		break;
-		
-		case HCI_EVENT_MAX_SLOT_CHANGE:
-		break;
- 	
-		case HCI_EVENT_READ_CLOCK_OFFSET_COMPL:
-		break;
- 	
-		case HCI_EVENT_CON_PKT_TYPE_CHANGED:
-		break;
- 		
-		case HCI_EVENT_QOS_VIOLATION:
-		break;
- 	
-		case HCI_EVENT_PAGE_SCAN_REP_MODE_CHANGE:
-		break;
- 	
-		case HCI_EVENT_FLOW_SPECIFICATION:
-		break;
- 				
-		case HCI_EVENT_INQUIRY_RESULT_WITH_RSSI:
-		break;
- 	
-		case HCI_EVENT_REMOTE_EXTENDED_FEATURES:
-		break;
- 	
-		case HCI_EVENT_SYNCHRONOUS_CONNECTION_COMPLETED:
-		break;
- 	
-		case HCI_EVENT_SYNCHRONOUS_CONNECTION_CHANGED:
- 	
-		break;
-	}
-
-}
-
-
-void 
-LocalDeviceImpl::CommandComplete(struct hci_ev_cmd_complete* event, BMessage* request, int32 index) {
-    
-	int16   opcodeExpected;
-	BMessage reply;
-	
-    Output::Instance()-&gt;Post(__FUNCTION__, BLACKBOARD_LD_OFFSET + GetID());
-    Output::Instance()-&gt;Post(&quot;\n&quot;, BLACKBOARD_LD_OFFSET + GetID());
-	
-	// Handle command complete information
-	// FIX ME! the expected code might me in another 
-	// index as is relative to the event not the request
-    request-&gt;FindInt16(&quot;opcodeExpected&quot;, index, &amp;opcodeExpected);
-
-
-	if (request-&gt;IsSourceWaiting() == false)
-		Output::Instance()-&gt;Post(&quot;Nobody waiting for the event\n&quot;, BLACKBOARD_KIT);
- 
-    switch (opcodeExpected) {
-
-        case PACK_OPCODE(OGF_INFORMATIONAL_PARAM, OCF_READ_BD_ADDR):
-        {
-        	struct hci_rp_read_bd_addr* readbdaddr = (struct hci_rp_read_bd_addr*)(event+1);
-
-            if (readbdaddr-&gt;status == BT_OK) {
-
-                reply.AddData(&quot;bdaddr&quot;, B_ANY_TYPE, &amp;readbdaddr-&gt;bdaddr, sizeof(bdaddr_t));
-                reply.AddInt32(&quot;status&quot;, readbdaddr-&gt;status);
-
-                printf(&quot;Sending reply ... %ld\n&quot;,request-&gt;SendReply(&amp;reply));
-                reply.PrintToStream();
-
-			    Output::Instance()-&gt;Post(&quot;Positive reply for getAdress\n&quot;, BLACKBOARD_KIT);
-
-            } else {
-                reply.AddInt8(&quot;status&quot;, readbdaddr-&gt;status); 
-                request-&gt;SendReply(&amp;reply);
-			    Output::Instance()-&gt;Post(&quot;Negative reply for getAdress\n&quot;, BLACKBOARD_KIT);
-            }
-
- 			// This request is not genna be used anymore
-            ClearWantedEvent(request);
-     	}
-        break;
-
-        case PACK_OPCODE(OGF_CONTROL_BASEBAND, OCF_READ_LOCAL_NAME):
-        {
-        	struct hci_rp_read_local_name* readLocalName = (struct hci_rp_read_local_name*)(event+1);
-
-        	reply.AddInt8(&quot;status&quot;, readLocalName-&gt;status);
-
-            if (readLocalName-&gt;status == BT_OK) {
-
-                reply.AddString(&quot;friendlyname&quot;, (const char*)readLocalName-&gt;local_name );
-			    Output::Instance()-&gt;Post(&quot;Positive reply for friendly name\n&quot;, BLACKBOARD_KIT);
-
-            } else {
-
-			    Output::Instance()-&gt;Post(&quot;Negative reply for friendly name\n&quot;, BLACKBOARD_KIT);
-
-            }
-
-            printf(&quot;Sending reply ... %ld\n&quot;,request-&gt;SendReply(&amp;reply));
-            reply.PrintToStream();
-
- 			// This request is not genna be used anymore
-            ClearWantedEvent(request);
-     	}
-        break;
-
-        case PACK_OPCODE(OGF_CONTROL_BASEBAND, OCF_WRITE_SCAN_ENABLE):
-        {
-        	uint8* statusReply = (uint8*)(event+1);
-
-        	reply.AddInt8(&quot;status&quot;, *statusReply);
-
-            if (*statusReply == BT_OK) {
-
-                Output::Instance()-&gt;Post(&quot;Positive reply for scanmode\n&quot;, BLACKBOARD_KIT);
-
-            } else {
-
-                Output::Instance()-&gt;Post(&quot;Negative reply for scanmode\n&quot;, BLACKBOARD_KIT);
-
-            }
-
-            printf(&quot;Sending reply ... %ld\n&quot;,request-&gt;SendReply(&amp;reply));
-            reply.PrintToStream();
-
- 			// This request is not genna be used anymore
-            ClearWantedEvent(request);
-     	}
-        break;
-		
-		default:
-		    Output::Instance()-&gt;Post(&quot;Command Complete not handled\n&quot;, BLACKBOARD_KIT);
-		break;
-
-    }
-}
-
-
-void 
-LocalDeviceImpl::CommandStatus(struct hci_ev_cmd_status* event, BMessage* request, int32 index) {
-
-	int16   opcodeExpected;
-	BMessage reply;
-	
-    Output::Instance()-&gt;Post(__FUNCTION__, BLACKBOARD_LD_OFFSET + GetID());
-    Output::Instance()-&gt;Post(&quot;\n&quot;, BLACKBOARD_LD_OFFSET + GetID());
-	
-	// Handle command complete information
-    request-&gt;FindInt16(&quot;opcodeExpected&quot;, index, &amp;opcodeExpected);
-
-
-	if (request-&gt;IsSourceWaiting() == false)
-		Output::Instance()-&gt;Post(&quot;Nobody waiting for the event\n&quot;, BLACKBOARD_KIT);
-
-    switch (opcodeExpected) {
-
-        case PACK_OPCODE(OGF_LINK_CONTROL, OCF_INQUIRY):

[... truncated: 750 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009939.html">[Haiku-commits] r26198 - haiku/trunk/src/servers/bluetooth
</A></li>
	<LI>Next message: <A HREF="009942.html">[Haiku-commits] r26200 - haiku/trunk/src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9940">[ date ]</a>
              <a href="thread.html#9940">[ thread ]</a>
              <a href="subject.html#9940">[ subject ]</a>
              <a href="author.html#9940">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
