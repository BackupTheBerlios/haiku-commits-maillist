<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26591 - haiku/trunk/src/build/libbe/support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26591%20-%20haiku/trunk/src/build/libbe/support&In-Reply-To=%3C200807232222.m6NMMTKR018049%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010527.html">
   <LINK REL="Next"  HREF="010518.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26591 - haiku/trunk/src/build/libbe/support</H1>
    <B>mauricek at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26591%20-%20haiku/trunk/src/build/libbe/support&In-Reply-To=%3C200807232222.m6NMMTKR018049%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26591 - haiku/trunk/src/build/libbe/support">mauricek at mail.berlios.de
       </A><BR>
    <I>Thu Jul 24 00:22:29 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010527.html">[Haiku-commits] r26590 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="010518.html">[Haiku-commits] r26592 -	haiku/trunk/src/system/kernel/device_manager
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10516">[ date ]</a>
              <a href="thread.html#10516">[ thread ]</a>
              <a href="subject.html#10516">[ subject ]</a>
              <a href="author.html#10516">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mauricek
Date: 2008-07-24 00:22:26 +0200 (Thu, 24 Jul 2008)
New Revision: 26591
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26591&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26591&amp;view=rev</A>

Modified:
   haiku/trunk/src/build/libbe/support/String.cpp
Log:
   * whitespace cleanup, no functional change

Modified: haiku/trunk/src/build/libbe/support/String.cpp
===================================================================
--- haiku/trunk/src/build/libbe/support/String.cpp	2008-07-23 22:20:37 UTC (rev 26590)
+++ haiku/trunk/src/build/libbe/support/String.cpp	2008-07-23 22:22:26 UTC (rev 26591)
@@ -24,7 +24,7 @@
 //                Stefano Ceccherini (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">burton666 at libero.it</A>)
 //                Oliver Tappe (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">openbeos at hirschkaefer.de</A>)
 //
-//	Description:   String class supporting common string operations.  
+//	Description:   String class supporting common string operations.
 //------------------------------------------------------------------------------
 
 // Standard Includes -----------------------------------------------------------
@@ -51,8 +51,8 @@
 
 // helper function, returns minimum of two given values (but clamps to 0):
 static inline int32
-min_clamp0(int32 num1, int32 num2) 
-{ 
+min_clamp0(int32 num1, int32 num2)
+{
 	if (num1&lt;num2)
 		return num1 &gt; 0 ? num1 : 0;
 	else
@@ -62,7 +62,7 @@
 
 // helper function, returns length of given string (but clamps to given maximum):
 static inline int32
-strlen_clamp(const char* str, int32 max) 
+strlen_clamp(const char* str, int32 max)
 {	// this should yield 0 for max&lt;0:
 	int32 len=0;
 	while( len&lt;max &amp;&amp; *str++)
@@ -72,8 +72,8 @@
 
 
 // helper function, massages given pointer into a legal c-string:
-static inline const char * 
-safestr(const char* str) 
+static inline const char *
+safestr(const char* str)
 {
 	return str ? str : &quot;&quot;;
 }
@@ -82,19 +82,19 @@
 // helper class for BString::_ReplaceAtPositions():
 struct
 BString::PosVect {
-	PosVect() 
+	PosVect()
 		:
 		size(0),
 		bufSize(20),
 		buf(NULL)
 	{
 	}
-	
+
 	~PosVect()
 	{
 		free(buf);
 	}
-	
+
 	bool Add(int32 pos)
 	{
 		if (!buf || size == bufSize) {
@@ -108,17 +108,17 @@
 		buf[size++] = pos;
 		return true;
 	}
-	
+
 	inline int32 ItemAt(int32 idx) const
 	{
 		return buf[idx];
 	}
-	
+
 	inline int32 CountItems() const
 	{
 		return size;
 	}
-	
+
 private:
 	int32 size;
 	int32 bufSize;
@@ -148,7 +148,7 @@
 	if (!(expr)) \
 		return (retval);
 
-	#define CHECK_PARAM_VOID( expr, msg) 
+	#define CHECK_PARAM_VOID( expr, msg)
 #endif
 
 // -----------------------------------------------------------------------------
@@ -156,15 +156,15 @@
 /*!
 	\class BString
 	\brief String class supporting common string operations
-	
+
 	BString is a string allocation and manipulation class. The object
 	takes care to allocate and free memory for you, so it will always be
 	&quot;big enough&quot; to store your strings.
-	
+
 	\author &lt;a href='mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">mflerackers at androme.be</A>&gt;Marc Flerackers&lt;/a&gt;
 	\author &lt;a href='mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">burton666 at freemail.it</A>&gt;Stefano Ceccherini&lt;/a&gt;
 	\author &lt;a href='mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">openbeos at hirschaefer.de</A>&gt;Oliver Tappe&lt;/a&gt;
-*/	
+*/
 
 /*!	\var char* BString::_privateData
 	\brief BString's storage for data
@@ -174,7 +174,7 @@
 /*!	\brief Creates an uninitialized BString.
 */
 BString::BString()
-	:_privateData(NULL)	
+	:_privateData(NULL)
 {
 }
 
@@ -196,7 +196,7 @@
 	\param string the BString object to be copied.
 */
 BString::BString(const BString &amp;string)
-	:_privateData(NULL)			
+	:_privateData(NULL)
 {
 	_Init(string.String(), string.Length());
 }
@@ -209,7 +209,7 @@
 		string.
 */
 BString::BString(const char *str, int32 maxLength)
-	:_privateData(NULL)		
+	:_privateData(NULL)
 {
 	if (str != NULL) {
 		int32 len = strlen_clamp(str, maxLength);
@@ -220,7 +220,7 @@
 
 // destructor
 /*! \brief Frees all resources associated with the object.
-	
+
 	Frees the memory allocated by the BString object.
 */
 BString::~BString()
@@ -234,12 +234,12 @@
 // String, implemented inline in the header
 /*! \fn const char* BString::String() const
 	\brief Returns a pointer to the object string, NULL terminated.
-	
+
 	Returns a pointer to the object string, guaranteed to be NULL
 	terminated. You can't modify or free the pointer. Once the BString
 	object is deleted, the pointer becomes invalid.
-	
-	\return A pointer to the object string. 
+
+	\return A pointer to the object string.
 */
 
 
@@ -249,24 +249,24 @@
 	\return The length of the string, measured in bytes.
 */
 
-		
+
 // CountChars
 /*! \brief Returns the length of the object measured in characters.
 	\return An integer which is the number of characters in the string.
-	
+
 	Counts the number of UTF8 characters contained in the string.
 */
 int32
 BString::CountChars() const
 {
 	int32 count = 0;
-	
+
 	const char *start = _privateData;
-	
+
 	/* String's end. This way we don't have to check for '\0' */
-	/* but just compare two pointers (which should be faster) */  
+	/* but just compare two pointers (which should be faster) */
 	const char *end = _privateData + Length();
-	
+
 #if 0
 	// ejaesler: Left in memoriam of one man's foolish disregard for the
 	// maxim &quot;Premature optimization is the root of all evil&quot;
@@ -315,10 +315,10 @@
 BString::operator=(const char *str)
 {
 	if (str != NULL)
-		_DoAssign(str, strlen(str));	
+		_DoAssign(str, strlen(str));
 	else
 		_GrowBy(-Length()); // Empties the string
-	
+
 	return *this;
 }
 
@@ -351,9 +351,9 @@
 		int32 len = strlen_clamp(str, length);
 		_DoAssign(str, len);
 	}
-	else 
+	else
 		_GrowBy(-Length()); // Empties the string
-	
+
 	return *this;
 }
 
@@ -384,7 +384,7 @@
 {
 	if (&amp;from == this) // Avoid auto-adoption
 		return *this;
-		
+
 	if (_privateData)
 		free(_privateData - sizeof(int32));
 
@@ -433,7 +433,7 @@
 	/* &quot;steal&quot; the data from the given BString */
 	_privateData = from._privateData;
 	from._privateData = NULL;
-	
+
 	if (len &lt; Length())
 		_GrowBy(len - Length()); // Negative, we truncate
 
@@ -454,10 +454,10 @@
 	if (count &lt; 0)
 		count = 0;
 	int32 curLen = Length();
-	
-	if (curLen == count || _GrowBy(count - curLen)) 
+
+	if (curLen == count || _GrowBy(count - curLen))
 		memset(_privateData, c, count);
-	return *this;	
+	return *this;
 }
 
 
@@ -474,9 +474,9 @@
 BString::CopyInto(BString &amp;into, int32 fromOffset, int32 length) const
 {
 	if (&amp;into != this) {
-		CHECK_PARAM_RET(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;, 
+		CHECK_PARAM_RET(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;,
 						into);
-		CHECK_PARAM_RET(fromOffset &lt;= Length(), &quot;'fromOffset' exceeds length!&quot;, 
+		CHECK_PARAM_RET(fromOffset &lt;= Length(), &quot;'fromOffset' exceeds length!&quot;,
 						into);
 		into.SetTo(String() + fromOffset, length);
 	}
@@ -556,7 +556,7 @@
 	if (str != NULL) {
 		int32 len = strlen_clamp(str, length);
 		_DoAppend(str, len);
-	}	
+	}
 	return *this;
 }
 
@@ -650,7 +650,7 @@
 {
 	if (count &gt; 0 &amp;&amp; _OpenAtBy(0, count))
 		memset(_privateData, c, count);
-	
+
 	return *this;
 }
 
@@ -685,7 +685,7 @@
 // Insert
 /*! \brief Inserts the given string at the given position into the object's data.
 	\param str A pointer to the string to insert.
-	\param length The amount of bytes to insert.	
+	\param length The amount of bytes to insert.
 	\param pos The offset into the BString's data where to insert the string.
 	\return This function always returns *this .
 */
@@ -713,7 +713,7 @@
 /*! \brief Inserts the given string at the given position into the object's data.
 	\param str A pointer to the string to insert.
 	\param fromOffset
-	\param length The amount of bytes to insert.	
+	\param length The amount of bytes to insert.
 	\param pos The offset into the BString's data where to insert the string.
 	\return This function always returns *this .
 */
@@ -736,7 +736,7 @@
 {
 	if (&amp;string != this)
 		Insert(string.String(), pos); //TODO: Optimize
-	return *this;				  
+	return *this;
 }
 
 
@@ -791,10 +791,10 @@
 		pos = 0;
 	} else
 		pos = min_clamp0(pos, Length());
-	
+
 	if (count &gt; 0 &amp;&amp; _OpenAtBy(pos, count))
 		memset(_privateData + pos, c, count);
-	
+
 	return *this;
 }
 
@@ -811,9 +811,9 @@
 {
 	if (newLength &lt; 0)
 		newLength = 0;
-	
+
 	int32 curLen = Length();
-		
+
 	if (newLength &lt; curLen) {
 		if (lazy) {
 			// don't free memory yet, just set new length:
@@ -822,7 +822,7 @@
 			_SetLength(newLength);
 			_privateData[newLength] = '\0';
 		} else
-			_GrowBy(newLength - curLen); //Negative	
+			_GrowBy(newLength - curLen); //Negative
 	}
 	return *this;
 }
@@ -858,10 +858,10 @@
 BString::RemoveFirst(const BString &amp;string)
 {
 	int32 pos = _ShortFindAfter(string.String(), string.Length());
-	
+
 	if (pos &gt;= 0)
 		_ShrinkAtBy(pos, string.Length());
-	
+
 	return *this;
 }
 
@@ -875,10 +875,10 @@
 BString::RemoveLast(const BString &amp;string)
 {
 	int32 pos = _FindBefore(string.String(), Length(), string.Length());
-	
+
 	if (pos &gt;= 0)
 		_ShrinkAtBy(pos, string.Length());
-		
+
 	return *this;
 }
 
@@ -1170,18 +1170,18 @@
 */
 int32
 BString::FindFirst(char c) const
-{	
+{
 	const char *start = String();
 	const char *end = String() + Length(); /* String's end */
-	
+
 	/* Scans the string until we find the character, */
 	/* or we hit the string's end */
 	while(start != end &amp;&amp; *start != c)
 		start++;
-	
+
 	if (start == end)
 		return B_ERROR;
-			
+
 	return start - String();
 }
 
@@ -1199,18 +1199,18 @@
 {
 	if (fromOffset &lt; 0)
 		return B_ERROR;
-		
+
 	const char *start = String() + min_clamp0(fromOffset, Length());
 	const char *end = String() + Length(); /* String's end */
-	
+
 	/* Scans the string until we found the character, */
 	/* or we hit the string's end */
 	while(start &lt; end &amp;&amp; *start != c)
 		start++;
-	
+
 	if (start &gt;= end)
 		return B_ERROR;
-			
+
 	return start - String();
 }
 
@@ -1256,8 +1256,8 @@
 {
 	if (beforeOffset &lt; 0)
 		return B_ERROR;
-	return _FindBefore(string.String(), min_clamp0(beforeOffset, Length()), 
-							 string.Length()); 
+	return _FindBefore(string.String(), min_clamp0(beforeOffset, Length()),
+							 string.Length());
 }
 
 
@@ -1290,15 +1290,15 @@
 {
 	const char *start = String();
 	const char *end = String() + Length(); /* String's end */
-	
+
 	/* Scans the string backwards until we found the character, */
 	/* or we reach the string's start */
 	while(end != start &amp;&amp; *end != c)
 		end--;
-	
+
 	if (end == start)
 		return B_ERROR;
-			
+
 	return end - String();
 }
 
@@ -1316,18 +1316,18 @@
 {
 	if (beforeOffset &lt; 0)
 		return B_ERROR;
-		
+
 	const char *start = String();
 	const char *end = String() + Length() - beforeOffset;
-	
+
 	/* Scans the string backwards until we found the character, */
 	/* or we reach the string's start */
 	while(end &gt; start &amp;&amp; *end != c)
 		end--;
-	
+
 	if (end &lt;= start)
 		return B_ERROR;
-			
+
 	return end - String();
 }
 
@@ -1353,7 +1353,7 @@
 {
 	if (fromOffset &lt; 0)
 		return B_ERROR;
-	return _IFindAfter(string.String(), min_clamp0(fromOffset, Length()), 
+	return _IFindAfter(string.String(), min_clamp0(fromOffset, Length()),
 						    string.Length());
 }
 
@@ -1390,7 +1390,7 @@
 {
 	if (beforeOffset &lt; 0)
 		return B_ERROR;
-	return _IFindBefore(string.String(), min_clamp0(beforeOffset, Length()), 
+	return _IFindBefore(string.String(), min_clamp0(beforeOffset, Length()),
 							  string.Length());
 }
 
@@ -1402,7 +1402,7 @@
 		return B_BAD_VALUE;
 	if (beforeOffset &lt; 0)
 		return B_ERROR;
-	return _IFindBefore(string, min_clamp0(beforeOffset,Length()), 
+	return _IFindBefore(string, min_clamp0(beforeOffset,Length()),
 							  strlen(string));
 }
 
@@ -1412,10 +1412,10 @@
 BString::ReplaceFirst(char replaceThis, char withThis)
 {
 	int32 pos = FindFirst(replaceThis);
-	
+
 	if (pos &gt;= 0)
 		_privateData[pos] = withThis;
-	
+
 	return *this;
 }
 
@@ -1424,10 +1424,10 @@
 BString::ReplaceLast(char replaceThis, char withThis)
 {
 	int32 pos = FindLast(replaceThis);
-	
+
 	if (pos &gt;= 0)
 		_privateData[pos] = withThis;
-	
+
 	return *this;
 }
 
@@ -1442,7 +1442,7 @@
 			break;
 		_privateData[pos] = withThis;
 	}
-	
+
 	return *this;
 }
 
@@ -1452,7 +1452,7 @@
 {
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
 	if (maxReplaceCount &gt; 0) {
-		for (int32 pos = min_clamp0(fromOffset, Length()); 
+		for (int32 pos = min_clamp0(fromOffset, Length());
 			  		maxReplaceCount &gt; 0; maxReplaceCount--) {
 			pos = FindFirst(replaceThis, pos);
 			if (pos &lt; 0)
@@ -1476,14 +1476,14 @@
 {
 	if (replaceThis == NULL)
 		return *this;
-		
-	int32 firstStringLength = strlen(replaceThis);	
+
+	int32 firstStringLength = strlen(replaceThis);
 	int32 pos = _FindBefore(replaceThis, Length(), firstStringLength);
-	
+
 	if (pos &gt;= 0) {
 		int32 len = (withThis ? strlen(withThis) : 0);
 		int32 difference = len - firstStringLength;
-		
+
 		if (difference &gt; 0) {
 			if (!_OpenAtBy(pos, difference))
 				return *this;
@@ -1493,7 +1493,7 @@
 		}
 		memcpy(_privateData + pos, withThis, len);
 	}
-		
+
 	return *this;
 }
 
@@ -1502,7 +1502,7 @@
 BString::ReplaceAll(const char *replaceThis, const char *withThis, int32 fromOffset)
 {
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
-	return _DoReplace(replaceThis, withThis, REPLACE_ALL, 
+	return _DoReplace(replaceThis, withThis, REPLACE_ALL,
 							 min_clamp0(fromOffset,Length()), KEEP_CASE);
 }
 
@@ -1511,7 +1511,7 @@
 BString::Replace(const char *replaceThis, const char *withThis, int32 maxReplaceCount, int32 fromOffset)
 {
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
-	return _DoReplace(replaceThis, withThis, maxReplaceCount, 
+	return _DoReplace(replaceThis, withThis, maxReplaceCount,
 							 min_clamp0(fromOffset,Length()), KEEP_CASE);
 }
 
@@ -1521,7 +1521,7 @@
 {
 	char tmp[2] = { replaceThis, '\0' };
 	int32 pos = _IFindAfter(tmp, 0, 1);
-	
+
 	if (pos &gt;= 0)
 		_privateData[pos] = withThis;
 
@@ -1532,12 +1532,12 @@
 BString&amp;
 BString::IReplaceLast(char replaceThis, char withThis)
 {
-	char tmp[2] = { replaceThis, '\0' };	
+	char tmp[2] = { replaceThis, '\0' };
 	int32 pos = _IFindBefore(tmp, Length(), 1);
-	
+
 	if (pos &gt;= 0)
 		_privateData[pos] = withThis;
-	
+
 	return *this;
 }
 
@@ -1565,12 +1565,12 @@
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
 
 	char tmp[2] = { replaceThis, '\0' };
-	
+
 	if (_privateData == NULL)
 		return *this;
-		
-	for (int32 pos = min_clamp0(fromOffset,Length()); 
-		  	maxReplaceCount &gt; 0;   maxReplaceCount--) {	
+
+	for (int32 pos = min_clamp0(fromOffset,Length());
+			maxReplaceCount &gt; 0;   maxReplaceCount--) {
 		pos = _IFindAfter(tmp, pos, 1);
 		if (pos &lt; 0)
 			break;
@@ -1592,14 +1592,14 @@
 {
 	if (replaceThis == NULL)
 		return *this;
-		
-	int32 firstStringLength = strlen(replaceThis);		
+
+	int32 firstStringLength = strlen(replaceThis);
 	int32 pos = _IFindBefore(replaceThis, Length(), firstStringLength);
-	
+
 	if (pos &gt;= 0) {
 		int32 len = (withThis ? strlen(withThis) : 0);
 		int32 difference = len - firstStringLength;
-		
+
 		if (difference &gt; 0) {
 			if (!_OpenAtBy(pos, difference))
 				return *this;
@@ -1608,9 +1608,9 @@
 				return *this;
 		}
 		memcpy(_privateData + pos, withThis, len);
-		
+
 	}
-		
+
 	return *this;
 }
 
@@ -1619,7 +1619,7 @@
 BString::IReplaceAll(const char *replaceThis, const char *withThis, int32 fromOffset)
 {
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
-	return _DoReplace(replaceThis, withThis, REPLACE_ALL, 
+	return _DoReplace(replaceThis, withThis, REPLACE_ALL,
 							 min_clamp0(fromOffset, Length()), IGNORE_CASE);
 }
 
@@ -1628,7 +1628,7 @@
 BString::IReplace(const char *replaceThis, const char *withThis, int32 maxReplaceCount, int32 fromOffset)
 {
 	CHECK_PARAM(fromOffset &gt;= 0, &quot;'fromOffset' must not be negative!&quot;);
-	return _DoReplace(replaceThis, withThis, maxReplaceCount, 
+	return _DoReplace(replaceThis, withThis, maxReplaceCount,
 							 min_clamp0(fromOffset, Length()), IGNORE_CASE);
 }
 
@@ -1641,7 +1641,7 @@
 
 	int32 offset = 0;
 	int32 length = Length();
-	
+
 	for (int32 pos;;) {
 		pos = strcspn(String() + offset, setOfChars);
 
@@ -1666,13 +1666,13 @@
 
 	if (setOfChars == NULL || _privateData == NULL)
 		return *this;
-	
+
 	PosVect positions;
 
 	int32 searchLen = 1;
 	int32 len = Length();
 	int32 pos = 0;
-	for (int32 offset = 0; offset &lt; len; offset += (pos+searchLen)) 
+	for (int32 offset = 0; offset &lt; len; offset += (pos+searchLen))
 	{
 		pos = strcspn(_privateData + offset, setOfChars);
 		if (pos + offset &gt;= len)
@@ -1681,7 +1681,7 @@
 			return *this;
 	}
 
-	_ReplaceAtPositions(&amp;positions, searchLen, with, withLen);	
+	_ReplaceAtPositions(&amp;positions, searchLen, with, withLen);
 	return *this;
 }
 
@@ -1690,7 +1690,7 @@
 
 // operator[]
 /*! \brief Returns a reference to the data at the given offset.
-	
+
 	This function can be used to read a byte or to change its value.
 	\param index The index (zero based) of the byte to get.
 	\return Returns a reference to the specified byte.
@@ -1707,9 +1707,9 @@
 BString::LockBuffer(int32 maxLength)
 {
 	_SetUsingAsCString(true); //debug
-	
+
 	int32 len = Length();
-	
+
 	if (maxLength &gt; len) {
 		if (!_GrowBy(maxLength - len))
 			return NULL;
@@ -1730,7 +1730,7 @@
 BString::UnlockBuffer(int32 length)
 {
 	_SetUsingAsCString(false); //debug
-	
+
 	if (length &lt; 0)
 		length = (_privateData == NULL) ? 0 : strlen(_privateData);
 
@@ -1752,7 +1752,7 @@
 	int32 length = Length();
 	for (int32 count = 0; count &lt; length; count++)
 			_privateData[count] = tolower(_privateData[count]);
-	
+
 	return *this;
 }
 
@@ -1763,11 +1763,11 @@
 */
 BString&amp;
 BString::ToUpper()
-{			
+{
 	int32 length = Length();
 	for (int32 count = 0; count &lt; length; count++)
 			_privateData[count] = toupper(_privateData[count]);
-	
+
 	return *this;
 }
 
@@ -1781,10 +1781,10 @@
 {
 	if (_privateData == NULL)
 		return *this;
-		
+
 	_privateData[0] = toupper(_privateData[0]);
 	int32 length = Length();
-		
+
 	for (int32 count = 1; count &lt; length; count++)
 			_privateData[count] = tolower(_privateData[count]);
 
@@ -1794,7 +1794,7 @@
 
 // CapitalizeEachWord
 /*! \brief Converts the first character of every word to uppercase, rest to lowercase.
-	
+
 	Converts the first character of every &quot;word&quot; (series of alpabetical characters
 	separated by non alphabetical characters) to uppercase, and the rest to lowercase.
 	\return This function always returns *this .
@@ -1804,10 +1804,10 @@
 {
 	if (_privateData == NULL)
 		return *this;
-		
+
 	int32 count = 0;
 	int32 length = Length();
-		
+
 	do {
 		// Find the first alphabetical character...
 		for(; count &lt; length; count++) {
@@ -1827,7 +1827,7 @@
 				break;
 		}
 	} while (count &lt; length);
-				
+
 	return *this;
 }
 
@@ -1838,7 +1838,7 @@
 {
 	SetTo(original);
 	CharacterEscape(setOfCharsToEscape, escapeWith);
-	
+
 	return *this;
 }
 
@@ -1848,7 +1848,7 @@
 {
 	if (setOfCharsToEscape == NULL || _privateData == NULL)
 		return *this;
-	
+
 	PosVect positions;
 	int32 len = Length();
 	int32 pos = 0;
@@ -1899,9 +1899,9 @@
 BString&amp;
 BString::CharacterDeescape(const char *original, char escapeChar)
 {
-	SetTo(original);	
+	SetTo(original);
 	CharacterDeescape(escapeChar);
-		
+
 	return *this;
 }
 
@@ -1921,7 +1921,7 @@
 {
 	if (str != NULL)
 		_DoAppend(str, strlen(str));
-	return *this;	
+	return *this;
 }
 
 
@@ -1936,7 +1936,7 @@
 BString&amp;
 BString::operator&lt;&lt;(char c)
 {
-	_DoAppend(&amp;c, 1);	
+	_DoAppend(&amp;c, 1);
 	return *this;
 }
 
@@ -1946,7 +1946,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%d&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -1956,7 +1956,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%u&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -1966,7 +1966,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%lu&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -1976,7 +1976,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%ld&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -1986,7 +1986,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%llu&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -1996,7 +1996,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%lld&quot;, i);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -2006,7 +2006,7 @@
 {
 	char num[64];
 	sprintf(num, &quot;%.2f&quot;, f);
-	
+
 	return *this &lt;&lt; num;
 }
 
@@ -2031,7 +2031,7 @@
 		_privateData[dataLen] = '\0';
 	}
 	return dataPtr;
-}	
+}
 
 void
 BString::_Init(const char *str, int32 len)
@@ -2048,7 +2048,7 @@
 BString::_DoAssign(const char *str, int32 len)
 {
 	int32 curLen = Length();
-	
+
 	if (len == curLen || _GrowBy(len - curLen))
 		memcpy(_privateData, str, len);
 }
@@ -2068,8 +2068,8 @@
 
 char*
 BString::_GrowBy(int32 size)
-{		
-	int32 newLen = Length() + size; 	
+{
+	int32 newLen = Length() + size;
 	return _Alloc(newLen);
 }
 
@@ -2078,19 +2078,19 @@
 BString::_OpenAtBy(int32 offset, int32 length)
 {
 	int32 oldLength = Length();
-	
+
 	char* newData = _Alloc(oldLength + length);
 	if (newData != NULL)
 		memmove(_privateData + offset + length, _privateData + offset,
 				  oldLength - offset);
-	
+
 	return newData;
 }
 
 
 char*
 BString::_ShrinkAtBy(int32 offset, int32 length)
-{	
+{
 	if (!_privateData)
 		return NULL;
 	int32 oldLength = Length();
@@ -2117,12 +2117,12 @@
 /* XXX: These could be inlined too, if they are too slow */
 int32
 BString::_FindAfter(const char *str, int32 offset, int32 strlen) const
-{	
+{
 	char *ptr = strstr(String() + offset, str);
 
 	if (ptr != NULL)
 		return ptr - String();
-	
+
 	return B_ERROR;
 }
 
@@ -2143,10 +2143,10 @@
 BString::_ShortFindAfter(const char *str, int32 len) const
 {
 	char *ptr = strstr(String(), str);
-	
+
 	if (ptr != NULL)
 		return ptr - String();
-		
+
 	return B_ERROR;

[... truncated: 76 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010527.html">[Haiku-commits] r26590 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="010518.html">[Haiku-commits] r26592 -	haiku/trunk/src/system/kernel/device_manager
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10516">[ date ]</a>
              <a href="thread.html#10516">[ thread ]</a>
              <a href="subject.html#10516">[ subject ]</a>
              <a href="author.html#10516">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
