<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26692 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs src/system/kernel/cache	src/system/kernel/device_manager src/system/kernel/fs	src/tests/system/kernel/device_manager
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26692%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%20src/system/kernel/cache%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tests/system/kernel/device_manager&In-Reply-To=%3C200807302334.m6UNYOoT030064%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010665.html">
   <LINK REL="Next"  HREF="010668.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26692 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs src/system/kernel/cache	src/system/kernel/device_manager src/system/kernel/fs	src/tests/system/kernel/device_manager</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26692%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%20src/system/kernel/cache%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tests/system/kernel/device_manager&In-Reply-To=%3C200807302334.m6UNYOoT030064%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26692 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs src/system/kernel/cache	src/system/kernel/device_manager src/system/kernel/fs	src/tests/system/kernel/device_manager">bonefish at mail.berlios.de
       </A><BR>
    <I>Thu Jul 31 01:34:24 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010665.html">[Haiku-commits] r26691 - in haiku/trunk: headers/libs/print/libprint	src/add-ons/print/drivers/pdf/source	src/add-ons/print/drivers/preview src/libs/print/libprint
</A></li>
        <LI>Next message: <A HREF="010668.html">[Haiku-commits] r26693 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10667">[ date ]</a>
              <a href="thread.html#10667">[ thread ]</a>
              <a href="subject.html#10667">[ subject ]</a>
              <a href="author.html#10667">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-07-31 01:34:10 +0200 (Thu, 31 Jul 2008)
New Revision: 26692
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26692&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26692&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/headers/private/kernel/vfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/system/kernel/cache/Jamfile
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.cpp
   haiku/trunk/src/system/kernel/device_manager/IOScheduler.cpp
   haiku/trunk/src/system/kernel/device_manager/IOScheduler.h
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/device_manager/dma_resources.cpp
   haiku/trunk/src/system/kernel/device_manager/io_requests.cpp
   haiku/trunk/src/system/kernel/device_manager/io_requests.h
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp
   haiku/trunk/src/tests/system/kernel/device_manager/dma_resource_test.cpp
Log:
* It is now supported that I/O operations and requests are only handled
  partially (e.g. due to hitting the end of file). The respective
  classes have grown new methods and attributes to deal with that. The
  &quot;finished&quot; callbacks have got additional parameters to indicate
  whether the transfer was only partial and how much has been
  transferred. Other callbacks and functions have a size_t* in/out
  parameter instead of a simple size_t, now.
* vfs_{read,write}_pages() do now use the I/O request framework instead
  of the underlying FS's {read,write}_pages() hooks (those should be
  unused now). Furthermore they've got an additional &quot;flags&quot; parameter,
  which is passed to IORequest::Init(), i.e. it allows to specify that
  the given vecs refer to physical addresses.
* The file cache's read_into_cache() reads directly into physical
  pages, now.
* Fixed bug in DoIO::IO(): The offset was not adjusted, so that all
  pages were incorrectly transferred from/to the same location.
* Fixed broken subrequest scheduling loop head in
  do_iterative_fd_io_iterate().
* Adjusted the test driver and implemented its io() hook. Using this
  driver I/O requests are passed all the way from the VFS/VM to the
  driver and through the I/O scheduler. It even seems to work. :-)
* Added missing const to the iovec* parameter of the IORequest::Init()
  methods.
* Disabled some debug output by default. Added new optional debug
  output.


Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2008-07-30 23:34:10 UTC (rev 26692)
@@ -299,7 +299,7 @@
 				off_t offset, size_t size, struct file_io_vec *vecs,
 				size_t *_count);
 typedef status_t (*iterative_io_finished)(void* cookie, io_request* request,
-				status_t status);
+				status_t status, bool partialTransfer, size_t bytesTransferred);
 
 extern status_t new_vnode(fs_volume *volume, ino_t vnodeID, void *privateNode,
 					fs_vnode_ops *ops);

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-07-30 23:34:10 UTC (rev 26692)
@@ -334,7 +334,8 @@
 				fssh_io_request* request, fssh_off_t offset, fssh_size_t size,
 				struct fssh_file_io_vec *vecs, fssh_size_t *_count);
 typedef fssh_status_t (*fssh_iterative_io_finished)(void* cookie,
-				fssh_io_request* request, fssh_status_t status);
+				fssh_io_request* request, fssh_status_t status,
+				bool partialTransfer, fssh_size_t bytesTransferred);
 
 extern fssh_status_t fssh_new_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID, void *privateNode,

Modified: haiku/trunk/headers/private/kernel/vfs.h
===================================================================
--- haiku/trunk/headers/private/kernel/vfs.h	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/headers/private/kernel/vfs.h	2008-07-30 23:34:10 UTC (rev 26692)
@@ -94,13 +94,13 @@
 status_t vfs_get_cookie_from_fd(int fd, void **_cookie);
 bool vfs_can_page(struct vnode *vnode, void *cookie);
 status_t vfs_read_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes);
+			const iovec *vecs, size_t count, uint32 flags, size_t *_numBytes);
 status_t vfs_write_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes);
+			const iovec *vecs, size_t count, uint32 flags, size_t *_numBytes);
 status_t vfs_vnode_io(struct vnode* vnode, void* cookie, io_request* request);
 status_t vfs_synchronous_io(io_request* request,
 			status_t (*doIO)(void* cookie, off_t offset, void* buffer,
-				size_t length),
+				size_t* length),
 			void* cookie);
 status_t vfs_get_vnode_cache(struct vnode *vnode, struct VMCache **_cache,
 			bool allocate);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -454,7 +454,8 @@
 
 
 static status_t
-bfs_iterative_io_finished(void *cookie, io_request *request, status_t status)
+bfs_iterative_io_finished(void *cookie, io_request *request, status_t status,
+	bool partialTransfer, size_t bytesTransferred)
 {
 	Inode *inode = (Inode*)cookie;
 

Modified: haiku/trunk/src/system/kernel/cache/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/cache/Jamfile	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/cache/Jamfile	2008-07-30 23:34:10 UTC (rev 26692)
@@ -1,5 +1,7 @@
 SubDir HAIKU_TOP src system kernel cache ;
 
+UseHeaders [ FDirName $(SUBDIR) $(DOTDOT) device_manager ] ;
+
 KernelMergeObject kernel_cache.o :
 	block_cache.cpp
 	file_cache.cpp

Modified: haiku/trunk/src/system/kernel/cache/file_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -24,7 +24,9 @@
 #include &lt;vm_page.h&gt;
 #include &lt;vm_cache.h&gt;
 
+#include &quot;io_requests.h&quot;
 
+
 //#define TRACE_FILE_CACHE
 #ifdef TRACE_FILE_CACHE
 #	define TRACE(x) dprintf x
@@ -196,12 +198,8 @@
 
 		cache-&gt;InsertPage(page, offset + pos);
 
-		addr_t virtualAddress;
-		if (vm_get_physical_page(page-&gt;physical_page_number * B_PAGE_SIZE,
-				&amp;virtualAddress, PHYSICAL_PAGE_CAN_WAIT) &lt; B_OK)
-			panic(&quot;could not get physical page&quot;);
-
-		add_to_iovec(vecs, vecCount, MAX_IO_VECS, virtualAddress, B_PAGE_SIZE);
+		add_to_iovec(vecs, vecCount, MAX_IO_VECS,
+			page-&gt;physical_page_number * B_PAGE_SIZE, B_PAGE_SIZE);
 			// TODO: check if the array is large enough (currently panics)!
 	}
 
@@ -211,22 +209,12 @@
 
 	// read file into reserved pages
 	status_t status = vfs_read_pages(ref-&gt;vnode, cookie, offset, vecs,
-		vecCount, &amp;numBytes);
+		vecCount, B_PHYSICAL_IO_REQUEST, &amp;numBytes);
 	if (status &lt; B_OK) {
 		// reading failed, free allocated pages
 
 		dprintf(&quot;file_cache: read pages failed: %s\n&quot;, strerror(status));
 
-		for (int32 i = 0; i &lt; vecCount; i++) {
-			addr_t base = (addr_t)vecs[i].iov_base;
-			size_t size = vecs[i].iov_len;
-
-			for (size_t pos = 0; pos &lt; size;
-					pos += B_PAGE_SIZE, base += B_PAGE_SIZE) {
-				vm_put_physical_page(base);
-			}
-		}
-
 		cache-&gt;Lock();
 
 		for (int32 i = 0; i &lt; pageIndex; i++) {
@@ -240,23 +228,24 @@
 
 	// copy the pages if needed and unmap them again
 
-	for (int32 i = 0; i &lt; vecCount; i++) {
-		addr_t base = (addr_t)vecs[i].iov_base;
-		size_t size = vecs[i].iov_len;
-
-		// copy to user buffer if necessary
+	for (int32 i = 0; i &lt; pageIndex; i++) {
 		if (useBuffer &amp;&amp; bufferSize != 0) {
-			size_t bytes = min_c(bufferSize, size - pageOffset);
+			addr_t virtualAddress;
+			if (vm_get_physical_page(
+					pages[i]-&gt;physical_page_number * B_PAGE_SIZE,
+					&amp;virtualAddress, PHYSICAL_PAGE_CAN_WAIT) &lt; B_OK) {
+				panic(&quot;could not get physical page&quot;);
+			}
 
-			user_memcpy((void *)buffer, (void *)(base + pageOffset), bytes);
+			size_t bytes = min_c(bufferSize, (size_t)B_PAGE_SIZE - pageOffset);
+
+			user_memcpy((void*)buffer, (void*)(virtualAddress + pageOffset),
+				bytes);
 			buffer += bytes;
 			bufferSize -= bytes;
 			pageOffset = 0;
-		}
 
-		for (size_t pos = 0; pos &lt; size; pos += B_PAGE_SIZE,
-				base += B_PAGE_SIZE) {
-			vm_put_physical_page(base);
+			vm_put_physical_page(virtualAddress);
 		}
 	}
 
@@ -294,7 +283,8 @@
 	vm_page_unreserve_pages(lastReservedPages);
 
 	status_t status = vfs_read_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-		&amp;vec, 1, &amp;bufferSize);
+		&amp;vec, 1, 0, &amp;bufferSize);
+
 	if (status == B_OK)
 		reserve_pages(ref, reservePages, false);
 
@@ -360,7 +350,7 @@
 		iovec readVec = { vecs[0].iov_base, B_PAGE_SIZE };
 		size_t bytesRead = B_PAGE_SIZE;
 
-		status = vfs_read_pages(ref-&gt;vnode, cookie, offset, &amp;readVec, 1,
+		status = vfs_read_pages(ref-&gt;vnode, cookie, offset, &amp;readVec, 1, 0,
 			&amp;bytesRead);
 		// ToDo: handle errors for real!
 		if (status &lt; B_OK)
@@ -385,7 +375,7 @@
 
 			status = vfs_read_pages(ref-&gt;vnode, cookie,
 				PAGE_ALIGN(offset + pageOffset + bufferSize) - B_PAGE_SIZE,
-				&amp;readVec, 1, &amp;bytesRead);
+				&amp;readVec, 1, 0, &amp;bytesRead);
 			// ToDo: handle errors for real!
 			if (status &lt; B_OK)
 				panic(&quot;vfs_read_pages() failed: %s!\n&quot;, strerror(status));
@@ -420,7 +410,7 @@
 	if (writeThrough) {
 		// write cached pages back to the file if we were asked to do that
 		status_t status = vfs_write_pages(ref-&gt;vnode, cookie, offset, vecs,
-			vecCount, &amp;numBytes);
+			vecCount, 0, &amp;numBytes);
 		if (status &lt; B_OK) {
 			// ToDo: remove allocated pages, ...?
 			panic(&quot;file_cache: remove allocated pages! write pages failed: %s\n&quot;,
@@ -463,7 +453,7 @@
 	addr_t buffer, size_t bufferSize, bool useBuffer, size_t lastReservedPages,
 	size_t reservePages)
 {
-	size_t chunkSize;
+	size_t chunkSize = 0;
 	if (!useBuffer) {
 		// we need to allocate a zero buffer
 		// TODO: use smaller buffers if this fails
@@ -491,7 +481,7 @@
 				chunkSize = bufferSize;
 
 			status = vfs_write_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-				&amp;vec, 1, &amp;chunkSize);
+				&amp;vec, 1, 0, &amp;chunkSize);
 			if (status &lt; B_OK)
 				break;
 
@@ -502,7 +492,7 @@
 		free((void*)buffer);
 	} else {
 		status = vfs_write_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-			&amp;vec, 1, &amp;bufferSize);
+			&amp;vec, 1, 0, &amp;bufferSize);
 	}
 
 	if (status == B_OK)

Modified: haiku/trunk/src/system/kernel/cache/vnode_store.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -46,7 +46,7 @@
 	size_t bytesUntouched = *_numBytes;
 
 	status_t status = vfs_read_pages(fVnode, NULL, offset, vecs, count,
-		_numBytes);
+		0, _numBytes);
 
 	bytesUntouched -= *_numBytes;
 
@@ -75,7 +75,7 @@
 VMVnodeCache::Write(off_t offset, const iovec *vecs, size_t count,
 	size_t *_numBytes)
 {
-	return vfs_write_pages(fVnode, NULL, offset, vecs, count, _numBytes);
+	return vfs_write_pages(fVnode, NULL, offset, vecs, count, 0, _numBytes);
 }
 
 

Modified: haiku/trunk/src/system/kernel/device_manager/IOScheduler.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/IOScheduler.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/IOScheduler.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -138,7 +138,8 @@
 
 
 void
-IOScheduler::OperationCompleted(IOOperation* operation, status_t status)
+IOScheduler::OperationCompleted(IOOperation* operation, status_t status,
+	size_t transferredBytes)
 {
 	InterruptsSpinLocker _(fFinisherLock);
 
@@ -148,6 +149,11 @@
 
 	operation-&gt;SetStatus(status);
 
+	// set the bytes transferred (of the net data)
+	size_t partialBegin = operation-&gt;OriginalOffset() - operation-&gt;Offset();
+	operation-&gt;SetTransferredBytes(
+		transferredBytes &gt; partialBegin ? transferredBytes - partialBegin : 0);
+
 	fCompletedOperations.Add(operation);
 	fFinishedOperationCondition.NotifyAll();
 
@@ -175,6 +181,7 @@
 
 		if (!operation-&gt;Finish()) {
 			TRACE(&quot;  operation: %p not finished yet\n&quot;, operation);
+			operation-&gt;SetTransferredBytes(0);
 			// TODO: This must be done differently once the scheduler implements
 			// an actual scheduling policy (other than no-op).
 			fIOCallback(fIOCallbackData, operation);
@@ -183,8 +190,15 @@
 
 		// notify request and remove operation
 		IORequest* request = operation-&gt;Parent();
-		if (request != NULL)
-			request-&gt;OperationFinished(operation, operation-&gt;Status());
+		if (request != NULL) {
+			size_t operationOffset = operation-&gt;OriginalOffset()
+				- request-&gt;Offset();
+			request-&gt;OperationFinished(operation, operation-&gt;Status(),
+				operation-&gt;TransferredBytes() &lt; operation-&gt;OriginalLength(),
+				operation-&gt;Status() == B_OK
+					? operationOffset + operation-&gt;OriginalLength()
+					: operationOffset);
+		}
 
 		// recycle the operation
 		MutexLocker _(fLock);

Modified: haiku/trunk/src/system/kernel/device_manager/IOScheduler.h
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/IOScheduler.h	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/IOScheduler.h	2008-07-30 23:34:10 UTC (rev 26692)
@@ -39,7 +39,7 @@
 			void				AbortRequest(IORequest* request,
 									status_t status = B_CANCELED);
 			void				OperationCompleted(IOOperation* operation,
-									status_t status);
+									status_t status, size_t transferredBytes);
 									// called by the driver when the operation
 									// has been completed successfully or failed
 									// for some reason

Modified: haiku/trunk/src/system/kernel/device_manager/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -756,26 +756,18 @@
 
 
 static status_t
-device_read(void* _cookie, off_t offset, void* buffer, size_t length)
+device_read(void* _cookie, off_t offset, void* buffer, size_t* length)
 {
 	synchronous_io_cookie* cookie = (synchronous_io_cookie*)_cookie;
-
-	size_t transferred = length;
-	status_t error = cookie-&gt;device-&gt;Read(cookie-&gt;cookie, offset, buffer,
-		&amp;transferred);
-	return error == B_OK &amp;&amp; transferred != length ? B_FILE_ERROR : error;
+	return cookie-&gt;device-&gt;Read(cookie-&gt;cookie, offset, buffer, length);
 }
 
 
 static status_t
-device_write(void* _cookie, off_t offset, void* buffer, size_t length)
+device_write(void* _cookie, off_t offset, void* buffer, size_t* length)
 {
 	synchronous_io_cookie* cookie = (synchronous_io_cookie*)_cookie;
-
-	size_t transferred = length;
-	status_t error = cookie-&gt;device-&gt;Write(cookie-&gt;cookie, offset, buffer,
-		&amp;transferred);
-	return error == B_OK &amp;&amp; transferred != length ? B_FILE_ERROR : error;
+	return cookie-&gt;device-&gt;Write(cookie-&gt;cookie, offset, buffer, length);
 }
 
 
@@ -1753,6 +1745,8 @@
 devfs_io(fs_volume *volume, fs_vnode *_vnode, void *_cookie,
 	io_request *request)
 {
+	TRACE((&quot;[%ld] devfs_io(request: %p)\n&quot;, find_thread(NULL), request));
+
 	devfs_vnode* vnode = (devfs_vnode*)_vnode-&gt;private_node;
 	devfs_cookie* cookie = (devfs_cookie*)_cookie;
 

Modified: haiku/trunk/src/system/kernel/device_manager/dma_resources.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/dma_resources.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/dma_resources.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -12,7 +12,7 @@
 #include &quot;io_requests.h&quot;
 
 
-#define TRACE_DMA_RESOURCE
+//#define TRACE_DMA_RESOURCE
 #ifdef TRACE_DMA_RESOURCE
 #	define TRACE(x...) dprintf(x)
 #else

Modified: haiku/trunk/src/system/kernel/device_manager/io_requests.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/io_requests.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/io_requests.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -16,7 +16,7 @@
 #include &quot;dma_resources.h&quot;
 
 
-#define TRACE_IO_REQUEST
+//#define TRACE_IO_REQUEST
 #ifdef TRACE_IO_REQUEST
 #	define TRACE(x...) dprintf(x)
 #else
@@ -237,6 +237,8 @@
 
 	fParent = request;
 
+	fTransferredBytes = 0;
+
 	// set initial phase
 	fPhase = PHASE_DO_ALL;
 	if (fParent-&gt;IsWrite()) {
@@ -522,8 +524,8 @@
 
 
 status_t
-IORequest::Init(off_t offset, size_t firstVecOffset, iovec* vecs, size_t count,
-	size_t length, bool write, uint32 flags)
+IORequest::Init(off_t offset, size_t firstVecOffset, const iovec* vecs,
+	size_t count, size_t length, bool write, uint32 flags)
 {
 	fBuffer = IOBuffer::Create(count);
 	if (fBuffer == NULL)
@@ -533,9 +535,12 @@
 
 	fOffset = offset;
 	fLength = length;
+	fRelativeParentOffset = 0;
+	fTransferSize = 0;
 	fFlags = flags;
 	fTeam = team_get_current_team_id();
 	fIsWrite = write;
+	fPartialTransfer = 0;
 
 	// these are for iteration
 	fVecIndex = 0;
@@ -596,6 +601,8 @@
 		return error;
 	}
 
+	subRequest-&gt;fRelativeParentOffset = parentOffset - fOffset;
+
 	_subRequest = subRequest;
 	subRequest-&gt;SetParent(this);
 
@@ -671,20 +678,23 @@
 
 	MutexLocker locker(fLock);
 
-	if (fStatus == B_OK &amp;&amp; RemainingBytes() &gt; 0) {
+	if (fStatus == B_OK &amp;&amp; !fPartialTransfer &amp;&amp; RemainingBytes() &gt; 0) {
 		// The request is not really done yet. If it has an iteration callback,
 		// call it.
 		if (fIterationCallback != NULL) {
 			ResetStatus();
 			locker.Unlock();
-			status_t error = fIterationCallback(fIterationCookie, this);
-			if (error == B_OK)
+			bool partialTransfer = false;
+			status_t error = fIterationCallback(fIterationCookie, this,
+				&amp;partialTransfer);
+			if (error == B_OK &amp;&amp; !partialTransfer)
 				return;
 
 			// Iteration failed, which means we're responsible for notifying the
 			// requests finished.
 			locker.Lock();
 			fStatus = error;
+			fPartialTransfer = true;
 		}
 	}
 
@@ -695,6 +705,8 @@
 	io_request_finished_callback finishedCallback = fFinishedCallback;
 	void* finishedCookie = fFinishedCookie;
 	status_t status = fStatus;
+	size_t lastTransferredOffset = fRelativeParentOffset + fTransferSize;
+	bool partialTransfer = status != B_OK || fPartialTransfer;
 
 	// unblock waiters
 	fFinishedCondition.NotifyAll();
@@ -702,12 +714,16 @@
 	locker.Unlock();
 
 	// notify callback
-	if (finishedCallback != NULL)
-		finishedCallback(finishedCookie, this, status);
+	if (finishedCallback != NULL) {
+		finishedCallback(finishedCookie, this, status, partialTransfer,
+			lastTransferredOffset);
+	}
 
 	// notify parent
-	if (parent != NULL)
-		parent-&gt;SubRequestFinished(this, status);
+	if (parent != NULL) {
+		parent-&gt;SubRequestFinished(this, status, partialTransfer,
+			lastTransferredOffset);
+	}
 }
 
 
@@ -742,7 +758,8 @@
 
 
 void
-IORequest::OperationFinished(IOOperation* operation, status_t status)
+IORequest::OperationFinished(IOOperation* operation, status_t status,
+	bool partialTransfer, size_t transferEndOffset)
 {
 	TRACE(&quot;IORequest::OperationFinished(%p, %#lx): request: %p\n&quot;, operation,
 		status, this);
@@ -752,6 +769,12 @@
 	fChildren.Remove(operation);
 	operation-&gt;SetParent(NULL);
 
+	if (status != B_OK || partialTransfer) {
+		if (fTransferSize &gt; transferEndOffset)
+			fTransferSize = transferEndOffset;
+		fPartialTransfer = true;
+	}
+
 	if (status != B_OK &amp;&amp; fStatus == 1)
 		fStatus = status;
 
@@ -773,13 +796,20 @@
 
 
 void
-IORequest::SubRequestFinished(IORequest* request, status_t status)
+IORequest::SubRequestFinished(IORequest* request, status_t status,
+	bool partialTransfer, size_t transferEndOffset)
 {
-	TRACE(&quot;IORequest::SubrequestFinished(%p, %#lx): request: %p\n&quot;, request,
-		status, this);
+	TRACE(&quot;IORequest::SubrequestFinished(%p, %#lx, %d, %lu): request: %p\n&quot;,
+		request, status, partialTransfer, transferEndOffset, this);
 
 	MutexLocker locker(fLock);
 
+	if (status != B_OK || partialTransfer) {
+		if (fTransferSize &gt; transferEndOffset)
+			fTransferSize = transferEndOffset;
+		fPartialTransfer = true;
+	}
+
 	if (status != B_OK &amp;&amp; fStatus == 1)
 		fStatus = status;
 
@@ -799,11 +829,25 @@
 
 
 void
+IORequest::SetTransferredBytes(bool partialTransfer, size_t transferredBytes)
+{
+	TRACE(&quot;%p-&gt;IORequest::SetTransferredBytes(%d, %lu)\n&quot;, this,
+		partialTransfer, transferredBytes);
+
+	MutexLocker _(fLock);
+
+	fPartialTransfer = partialTransfer;
+	fTransferSize = transferredBytes;
+}
+
+
+void
 IORequest::Advance(size_t bySize)
 {
 	TRACE(&quot;IORequest::Advance(%lu): remaining: %lu -&gt; %lu\n&quot;, bySize,
 		fRemainingBytes, fRemainingBytes - bySize);
 	fRemainingBytes -= bySize;
+	fTransferSize += bySize;
 
 	iovec* vecs = fBuffer-&gt;Vecs();
 	while (vecs[fVecIndex].iov_len - fVecOffset &lt;= bySize) {

Modified: haiku/trunk/src/system/kernel/device_manager/io_requests.h
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/io_requests.h	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/device_manager/io_requests.h	2008-07-30 23:34:10 UTC (rev 26692)
@@ -125,6 +125,11 @@
 			size_t				OriginalLength() const
 									{ return fOriginalLength; }
 
+			size_t				TransferredBytes() const
+									{ return fTransferredBytes; }
+			void				SetTransferredBytes(size_t bytes)
+									{ fTransferredBytes = bytes; }
+
 			iovec*				Vecs() const;
 			uint32				VecCount() const;
 
@@ -159,6 +164,7 @@
 			off_t				fOriginalOffset;
 			size_t				fLength;
 			size_t				fOriginalLength;
+			size_t				fTransferredBytes;
 			size_t				fBlockSize;
 			uint16				fSavedVecIndex;
 			uint16				fSavedVecLength;
@@ -174,9 +180,10 @@
 
 typedef struct IORequest io_request;
 typedef status_t (*io_request_finished_callback)(void* data,
-			io_request* request, status_t status);
+			io_request* request, status_t status, bool partialTransfer,
+			size_t transferEndOffset);
 typedef status_t (*io_request_iterate_callback)(void* data,
-			io_request* request);
+			io_request* request, bool* _partialTransfer);
 
 
 struct IORequest : IORequestChunk, DoublyLinkedListLinkImpl&lt;IORequest&gt; {
@@ -185,13 +192,14 @@
 
 			status_t			Init(off_t offset, void* buffer, size_t length,
 									bool write, uint32 flags);
-			status_t			Init(off_t offset, iovec* vecs, size_t count,
-									size_t length, bool write, uint32 flags)
+			status_t			Init(off_t offset, const iovec* vecs,
+									size_t count, size_t length, bool write,
+									uint32 flags)
 									{ return Init(offset, 0, vecs, count,
 										length, write, flags); }
 			status_t			Init(off_t offset, size_t firstVecOffset,
-									iovec* vecs, size_t count, size_t length,
-									bool write, uint32 flags);
+									const iovec* vecs, size_t count,
+									size_t length, bool write, uint32 flags);
 
 			status_t			CreateSubRequest(off_t parentOffset,
 									off_t offset, size_t length,
@@ -217,12 +225,20 @@
 			void				SetStatusAndNotify(status_t status);
 
 			void				OperationFinished(IOOperation* operation,
-									status_t status);
+									status_t status, bool partialTransfer,
+									size_t transferEndOffset);
 			void				SubRequestFinished(IORequest* request,
-									status_t status);
+									status_t status, bool partialTransfer,
+									size_t transferEndOffset);
 
 			size_t				RemainingBytes() const
 									{ return fRemainingBytes; }
+			size_t				TransferredBytes() const
+									{ return fTransferSize; }
+			bool				IsPartialTransfer() const
+									{ return fPartialTransfer; }
+			void				SetTransferredBytes(bool partialTransfer,
+									size_t transferredBytes);
 
 			bool				IsWrite() const	{ return fIsWrite; }
 			bool				IsRead() const	{ return !fIsWrite; }
@@ -265,11 +281,20 @@
 			IOBuffer*			fBuffer;
 			off_t				fOffset;
 			size_t				fLength;
+			size_t				fTransferSize;
+									// After all subrequests/operations have
+									// finished, number of contiguous bytes at
+									// the beginning of the request that have
+									// actually been transferred.
+			size_t				fRelativeParentOffset;
+									// offset of this request relative to its
+									// parent
 			IORequestChunkList	fChildren;
 			int32				fPendingChildren;
 			uint32				fFlags;
 			team_id				fTeam;
 			bool				fIsWrite;
+			bool				fPartialTransfer;
 
 			io_request_finished_callback	fFinishedCallback;
 			void*				fFinishedCookie;

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -50,6 +50,7 @@
 #include &lt;vm_cache.h&gt;
 
 #include &quot;fifo.h&quot;
+#include &quot;io_requests.h&quot;
 
 
 //#define TRACE_VFS
@@ -3899,21 +3900,41 @@
 
 extern &quot;C&quot; status_t
 vfs_read_pages(struct vnode *vnode, void *cookie, off_t pos, const iovec *vecs,
-	size_t count, size_t *_numBytes)
+	size_t count, uint32 flags, size_t *_numBytes)
 {
-	FUNCTION((&quot;vfs_read_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs, pos));
+	FUNCTION((&quot;vfs_read_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs,
+		pos));
 
-	return FS_CALL(vnode, read_pages, cookie, pos, vecs, count, _numBytes);
+	IORequest request;
+	status_t status = request.Init(pos, vecs, count, *_numBytes, false, flags);
+	if (status == B_OK) {
+		status = vfs_vnode_io(vnode, cookie, &amp;request);
+		if (status == B_OK)
+			status = request.Wait();
+		*_numBytes = request.TransferredBytes();
+	}
+
+	return status;
 }
 
 
 extern &quot;C&quot; status_t
 vfs_write_pages(struct vnode *vnode, void *cookie, off_t pos, const iovec *vecs,
-	size_t count, size_t *_numBytes)
+	size_t count, uint32 flags, size_t *_numBytes)
 {
-	FUNCTION((&quot;vfs_write_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs, pos));
+	FUNCTION((&quot;vfs_write_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs,
+		pos));
 
-	return FS_CALL(vnode, write_pages, cookie, pos, vecs, count, _numBytes);
+	IORequest request;
+	status_t status = request.Init(pos, vecs, count, *_numBytes, true, flags);
+	if (status == B_OK) {
+		status = vfs_vnode_io(vnode, cookie, &amp;request);
+		if (status == B_OK)
+			status = request.Wait();
+		*_numBytes = request.TransferredBytes();
+	}
+
+	return status;
 }
 
 

Modified: haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp	2008-07-30 21:24:19 UTC (rev 26691)
+++ haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp	2008-07-30 23:34:10 UTC (rev 26692)
@@ -5,9 +5,15 @@
 
 // included by vfs.cpp
 
-#include &quot;io_requests.h&quot;
 
+//#define TRACE_VFS_REQUEST_IO
+#ifdef TRACE_VFS_REQUEST_IO
+#	define TRACE_RIO(x...) dprintf(x)
+#else
+#	define TRACE_RIO(x...) do {} while (false)
+#endif
 
+
 struct iterative_io_cookie {
 	struct vnode*					vnode;
 	file_descriptor*				descriptor;
@@ -33,13 +39,14 @@
 	{
 	}
 
-	status_t IO(off_t offset, void* _buffer, size_t length)
+	status_t IO(off_t offset, void* _buffer, size_t* _length)
 	{
 		if (!fIsPhysical)
-			return InternalIO(offset, _buffer, length);
+			return InternalIO(offset, _buffer, _length);
 
 		// buffer points to physical address -- map pages
 		addr_t buffer = (addr_t)_buffer;
+		size_t length = *_length;
 
 		while (length &gt; 0) {
 			addr_t pageOffset = buffer % B_PAGE_SIZE;
@@ -50,23 +57,29 @@
 				return error;
 
 			size_t toTransfer = min_c(length, B_PAGE_SIZE - pageOffset);
+			size_t transferred = toTransfer;
 			error = InternalIO(offset, (void*)(virtualAddress + pageOffset),
-				toTransfer);
+				&amp;transferred);
 
 			vm_put_physical_page(virtualAddress);
 
 			if (error != B_OK)
 				return error;
 
-			buffer += toTransfer;
-			length -= toTransfer;
+			offset += transferred;
+			buffer += transferred;
+			length -= transferred;
+
+			if (transferred != toTransfer)
+				break;
 		}
 
+		*_length -= length;
 		return B_OK;
 	}
 
 protected:
-	virtual status_t InternalIO(off_t offset, void* buffer, size_t length) = 0;
+	virtual status_t InternalIO(off_t offset, void* buffer, size_t* length) = 0;
 
 protected:
 	bool	fWrite;
@@ -78,7 +91,7 @@
 public:
 	CallbackIO(bool write, bool isPhysical,
 			status_t (*doIO)(void* cookie, off_t offset, void* buffer,
-				size_t length),
+				size_t* length),
 			void* cookie)
 		:
 		DoIO(write, isPhysical),
@@ -88,13 +101,13 @@
 	}
 
 protected:
-	virtual status_t InternalIO(off_t offset, void* buffer, size_t length)
+	virtual status_t InternalIO(off_t offset, void* buffer, size_t* length)
 	{
 		return fDoIO(fCookie, offset, buffer, length);
 	}
 
 private:
-	status_t (*fDoIO)(void*, off_t, void*, size_t);
+	status_t (*fDoIO)(void*, off_t, void*, size_t*);
 	void*		fCookie;
 };
 
@@ -110,20 +123,12 @@
 	}
 
 protected:
-	virtual status_t InternalIO(off_t offset, void* buffer, size_t length)
+	virtual status_t InternalIO(off_t offset, void* buffer, size_t* length)
 	{
-		size_t bytesTransferred = length;
-		status_t error;
-		if (fWrite) {
-			error = FS_CALL(fVnode, write, fCookie, offset, buffer,
-				&amp;bytesTransferred);
-		} else {
-			error = FS_CALL(fVnode, read, fCookie, offset, buffer,
-				&amp;bytesTransferred);
-		}
+		if (fWrite)
+			return FS_CALL(fVnode, write, fCookie, offset, buffer, length);
 
-		return error == B_OK &amp;&amp; bytesTransferred != length
-			? B_FILE_ERROR : error;
+		return FS_CALL(fVnode, read, fCookie, offset, buffer, length);
 	}
 
 private:
@@ -133,8 +138,12 @@
 
 
 static status_t
-do_iterative_fd_io_iterate(void* _cookie, io_request* request)
+do_iterative_fd_io_iterate(void* _cookie, io_request* request,
+	bool* _partialTransfer)
 {
+	TRACE_RIO(&quot;[%ld] do_iterative_fd_io_iterate(request: %p)\n&quot;,
+		find_thread(NULL), request);
+
 	static const int32 kMaxSubRequests = 8;
 
 	iterative_io_cookie* cookie = (iterative_io_cookie*)_cookie;
@@ -152,16 +161,23 @@
 		requestLength, vecs, &amp;vecCount);
 	if (error != B_OK)
 		return error;
-	if (vecCount == 0)
-		return B_FILE_ERROR;
+	if (vecCount == 0) {
+		*_partialTransfer = true;
+		return B_OK;
+	}
+	TRACE_RIO(&quot;[%ld]  got %lu file vecs\n&quot;, find_thread(NULL), vecCount);
 
 	// create subrequests for the file vecs we've got
 	int32 subRequestCount = 0;
 	for (uint32 i = 0; i &lt; vecCount &amp;&amp; subRequestCount &lt; kMaxSubRequests; i++) {
 		off_t vecOffset = vecs[i].offset;
-		off_t vecLength = vecs[i].length;
+		off_t vecLength = min_c(vecs[i].length, requestLength);
+		TRACE_RIO(&quot;[%ld]    vec %lu offset: %lld, length: %lld\n&quot;,
+			find_thread(NULL), i, vecOffset, vecLength);
 
 		while (vecLength &gt; 0 &amp;&amp; subRequestCount &lt; kMaxSubRequests) {
+			TRACE_RIO(&quot;[%ld]    creating subrequest: offset: %lld, length: &quot;
+				&quot;%lld\n&quot;, find_thread(NULL), vecOffset, vecLength);
 			IORequest* subRequest;
 			error = request-&gt;CreateSubRequest(requestOffset, vecOffset,
 				vecLength, subRequest);
@@ -186,9 +202,14 @@
 	cookie-&gt;request_offset = requestOffset;
 
 	// Schedule the subrequests.
-	for (IORequest* subRequest = request-&gt;FirstSubRequest();
-			(subRequest = request-&gt;NextSubRequest(subRequest)) != NULL;) {
+	IORequest* nextSubRequest = request-&gt;FirstSubRequest();
+	while (nextSubRequest != NULL) {
+		IORequest* subRequest = nextSubRequest;
+		nextSubRequest = request-&gt;NextSubRequest(subRequest);
+
 		if (error == B_OK) {
+			TRACE_RIO(&quot;[%ld]  scheduling subrequest: %p\n&quot;, find_thread(NULL),
+				subRequest);
 			error = FS_CALL(cookie-&gt;vnode, io, cookie-&gt;descriptor-&gt;cookie,
 				subRequest);
 		} else {
@@ -205,18 +226,21 @@
 
 
 static status_t
-do_iterative_fd_io_finish(void* _cookie, io_request* request, status_t status)
+do_iterative_fd_io_finish(void* _cookie, io_request* request, status_t status,
+	bool partialTransfer, size_t transferEndOffset)
 {
 	iterative_io_cookie* cookie = (iterative_io_cookie*)_cookie;
 
-	if (cookie-&gt;finished != NULL)
-		cookie-&gt;finished(cookie-&gt;cookie, request, status);
+	if (cookie-&gt;finished != NULL) {
+		cookie-&gt;finished(cookie-&gt;cookie, request, status, partialTransfer,
+			transferEndOffset);
+	}
 
 	put_fd(cookie-&gt;descriptor);
 
 	if (cookie-&gt;next_finished_callback != NULL) {
 		cookie-&gt;next_finished_callback(cookie-&gt;next_finished_cookie, request,
-			status);
+			status, partialTransfer, transferEndOffset);
 	}
 
 	delete cookie;
@@ -242,35 +266,39 @@
 
 	for (int32 i = 0; error == B_OK &amp;&amp; length &gt; 0 &amp;&amp; i &lt; vecCount; i++) {
 		uint8* vecBase = (uint8*)vecs[i].iov_base;
-		size_t vecLength = vecs[i].iov_len;
-		if (vecLength &gt; length)
-			vecLength = length;
+		size_t vecLength = min_c(vecs[i].iov_len, length);
 
 		while (error == B_OK &amp;&amp; vecLength &gt; 0) {
 			file_io_vec fileVecs[8];
 			uint32 fileVecCount = 8;
 			error = getVecs(cookie, request, offset, vecLength, fileVecs,
 				&amp;fileVecCount);
-			if (error == B_OK &amp;&amp; fileVecCount == 0)
-				error = B_FILE_ERROR;
-			if (error != B_OK)
+			if (error != B_OK || fileVecCount == 0)
 				break;
 
 			for (uint32 k = 0; k &lt; fileVecCount; k++) {
 				const file_io_vec&amp; fileVec = fileVecs[i];
-				error = io.IO(fileVec.offset, vecBase, fileVec.length);
+				size_t toTransfer = min_c(fileVec.length, length);
+				size_t transferred = toTransfer;
+				error = io.IO(fileVec.offset, vecBase, &amp;transferred);
 				if (error != B_OK)
 					break;
 
-				offset += fileVec.length;
-				length -= fileVec.length;
-				vecBase += fileVec.length;
-				vecLength -= fileVec.length;
+				offset += transferred;
+				length -= transferred;
+				vecBase += transferred;
+				vecLength -= transferred;
+
+				if (transferred != toTransfer)
+					break;
 			}
 		}
 	}
 
-	finished(cookie, request, error);
+	bool partial = length &gt; 0;
+	size_t bytesTransferred = request-&gt;Length() - length;
+	request-&gt;SetTransferredBytes(partial, bytesTransferred);
+	finished(cookie, request, error, partial, bytesTransferred);
 	request-&gt;SetStatusAndNotify(error);
 	return error;
 }
@@ -279,6 +307,9 @@
 static status_t
 synchronous_io(io_request* request, DoIO&amp; io)
 {
+	TRACE_RIO(&quot;[%ld] synchronous_io(request: %p (offset: %lld, length: %lu))\n&quot;,
+		find_thread(NULL), request, request-&gt;Offset(), request-&gt;Length());
+
 	IOBuffer* buffer = request-&gt;Buffer();
 
 	iovec* vecs = buffer-&gt;Vecs();
@@ -288,20 +319,29 @@
 

[... truncated: 257 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010665.html">[Haiku-commits] r26691 - in haiku/trunk: headers/libs/print/libprint	src/add-ons/print/drivers/pdf/source	src/add-ons/print/drivers/preview src/libs/print/libprint
</A></li>
	<LI>Next message: <A HREF="010668.html">[Haiku-commits] r26693 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10667">[ date ]</a>
              <a href="thread.html#10667">[ thread ]</a>
              <a href="subject.html#10667">[ subject ]</a>
              <a href="author.html#10667">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
