<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26499 - in	haiku/trunk/src/add-ons/kernel/bus_managers/acpi: common	compiler debugger events executer hardware include	include/platform namespace tables utilities
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26499%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/bus_managers/acpi%3A%20common%0A%09compiler%20debugger%20events%20executer%20hardware%20include%0A%09include/platform%20namespace%20tables%20utilities&In-Reply-To=%3C200807191109.m6JB9Xt1011610%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010366.html">
   <LINK REL="Next"  HREF="010368.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26499 - in	haiku/trunk/src/add-ons/kernel/bus_managers/acpi: common	compiler debugger events executer hardware include	include/platform namespace tables utilities</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26499%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/bus_managers/acpi%3A%20common%0A%09compiler%20debugger%20events%20executer%20hardware%20include%0A%09include/platform%20namespace%20tables%20utilities&In-Reply-To=%3C200807191109.m6JB9Xt1011610%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26499 - in	haiku/trunk/src/add-ons/kernel/bus_managers/acpi: common	compiler debugger events executer hardware include	include/platform namespace tables utilities">korli at mail.berlios.de
       </A><BR>
    <I>Sat Jul 19 13:09:33 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010366.html">[Haiku-commits] r26498 - haiku/vendor/acpica
</A></li>
        <LI>Next message: <A HREF="010368.html">[Haiku-commits] r26500 - haiku/trunk/src/preferences/devices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10367">[ date ]</a>
              <a href="thread.html#10367">[ thread ]</a>
              <a href="subject.html#10367">[ subject ]</a>
              <a href="author.html#10367">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2008-07-19 13:09:30 +0200 (Sat, 19 Jul 2008)
New Revision: 26499
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26499&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26499&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/common/a16utils.obj
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslanalyze.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslmap.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbcmds.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbexec.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/events/evgpe.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/executer/exconfig.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwgpe.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwregs.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acconfig.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acglobal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/achware.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/aclocal.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acmacros.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/actypes.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/platform/acfreebsd.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/namespace/nsxfname.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/tables/tbinstal.c
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/utilities/utdelete.c
Log:
merging acpica-20080701 into trunk


Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/common/a16utils.obj
===================================================================
(Binary files differ)

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslanalyze.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslanalyze.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslanalyze.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -2078,6 +2078,7 @@
             {
             case PARSEOP_ACQUIRE:
             case PARSEOP_WAIT:
+            case PARSEOP_LOADTABLE:
                 break;
 
             default:

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslmap.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslmap.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/compiler/aslmap.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -266,6 +266,7 @@
     {&quot;_ALR&quot;,     0,      ASL_RSVD_RETURN_VALUE},    /* Acpi 3.0 */
     {&quot;_ALT&quot;,     0,      ASL_RSVD_RETURN_VALUE},    /* Acpi 3.0 */
     {&quot;_ASI&quot;,     0,      ASL_RSVD_RESOURCE_NAME},
+    {&quot;_ASZ&quot;,     0,      ASL_RSVD_RESOURCE_NAME},
     {&quot;_BAS&quot;,     0,      ASL_RSVD_RESOURCE_NAME},
     {&quot;_BBN&quot;,     0,      ASL_RSVD_RETURN_VALUE},
     {&quot;_BCL&quot;,     0,      ASL_RSVD_RETURN_VALUE},
@@ -343,6 +344,7 @@
     {&quot;_MIN&quot;,     0,      ASL_RSVD_RESOURCE_NAME},
     {&quot;_MLS&quot;,     0,      ASL_RSVD_RETURN_VALUE},    /* Acpi 3.0 */
     {&quot;_MSG&quot;,     1,      0},
+    {&quot;_MTP&quot;,     0,      ASL_RSVD_RESOURCE_NAME},
     {&quot;_OFF&quot;,     0,      0},
     {&quot;_ON_&quot;,     0,      0},
     {&quot;_OS_&quot;,     0,      ASL_RSVD_RETURN_VALUE},

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbcmds.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbcmds.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbcmds.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -123,8 +123,7 @@
 #include &quot;acdebug.h&quot;
 #include &quot;acresrc.h&quot;
 #include &quot;acdisasm.h&quot;
-
-
+#include &quot;actables.h&quot;
 #include &quot;acparser.h&quot;
 
 #ifdef ACPI_DEBUGGER
@@ -437,24 +436,30 @@
     ACPI_TABLE_DESC         *TableDesc;
 
 
-    /*
-     * Walk the root table list
-     */
+    /* Walk the entire root table list */
+
     for (i = 0; i &lt; AcpiGbl_RootTableList.Count; i++)
     {
         TableDesc = &amp;AcpiGbl_RootTableList.Tables[i];
-        AcpiOsPrintf ( &quot;%.4s at %p length %.5X&quot;,
-                TableDesc-&gt;Signature.Ascii, TableDesc-&gt;Pointer,
-                (UINT32) TableDesc-&gt;Length);
+        AcpiOsPrintf (&quot;%d &quot;, i);
 
-        if (TableDesc-&gt;Pointer &amp;&amp; (i != ACPI_TABLE_INDEX_FACS))
+        /* Make sure that the table is mapped */
+
+        AcpiTbVerifyTable (TableDesc);
+
+        /* Dump the table header */
+
+        if (TableDesc-&gt;Pointer)
         {
-            AcpiOsPrintf (&quot; OemId=\&quot;%.6s\&quot; OemTableId=\&quot;%.8s\&quot; OemRevision=%8.8X&quot;,
-                    TableDesc-&gt;Pointer-&gt;OemId,
-                    TableDesc-&gt;Pointer-&gt;OemTableId,
-                    TableDesc-&gt;Pointer-&gt;OemRevision);
+            AcpiTbPrintTableHeader (TableDesc-&gt;Address, TableDesc-&gt;Pointer);
         }
-        AcpiOsPrintf (&quot;\n&quot;);
+        else
+        {
+            /* If the pointer is null, the table has been unloaded */
+
+            ACPI_INFO ((AE_INFO, &quot;%4.4s - Table has been unloaded&quot;,
+                TableDesc-&gt;Signature.Ascii));
+        }
     }
 }
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbexec.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbexec.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/debugger/dbexec.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -175,7 +175,10 @@
     ACPI_STATUS             Status;
     ACPI_OBJECT_LIST        ParamObjects;
     ACPI_OBJECT             Params[ACPI_METHOD_NUM_ARGS];
+    ACPI_HANDLE             Handle;
+    ACPI_BUFFER             Buffer;
     UINT32                  i;
+    ACPI_DEVICE_INFO        *ObjInfo;
 
 
     if (AcpiGbl_DbOutputToFile &amp;&amp; !AcpiDbgLevel)
@@ -183,34 +186,75 @@
         AcpiOsPrintf (&quot;Warning: debug output is not enabled!\n&quot;);
     }
 
-    /* Are there arguments to the method? */
+    /* Get the NS node, determines existence also */
 
-    if (Info-&gt;Args &amp;&amp; Info-&gt;Args[0])
+    Status = AcpiGetHandle (NULL, Info-&gt;Pathname, &amp;Handle);
+    if (ACPI_FAILURE (Status))
     {
-        for (i = 0; Info-&gt;Args[i] &amp;&amp; i &lt; ACPI_METHOD_NUM_ARGS; i++)
-        {
-            Params[i].Type          = ACPI_TYPE_INTEGER;
-            Params[i].Integer.Value = ACPI_STRTOUL (Info-&gt;Args[i], NULL, 16);
-        }
+        return (Status);
+    }
 
-        ParamObjects.Pointer = Params;
-        ParamObjects.Count   = i;
+    /* Get the object info for number of method parameters */
+
+    Buffer.Length = ACPI_ALLOCATE_LOCAL_BUFFER;
+    Status = AcpiGetObjectInfo (Handle, &amp;Buffer);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
     }
-    else
+
+    ObjInfo = Buffer.Pointer;
+    if (ObjInfo-&gt;Type == ACPI_TYPE_METHOD)
     {
-        /* Setup default parameters */
+        /* Are there arguments to the method? */
 
-        Params[0].Type           = ACPI_TYPE_INTEGER;
-        Params[0].Integer.Value  = 0x01020304;
+        if (Info-&gt;Args &amp;&amp; Info-&gt;Args[0])
+        {
+            for (i = 0; Info-&gt;Args[i] &amp;&amp; i &lt; ACPI_METHOD_NUM_ARGS; i++)
+            {
+                Params[i].Type          = ACPI_TYPE_INTEGER;
+                Params[i].Integer.Value = ACPI_STRTOUL (Info-&gt;Args[i], NULL, 16);
+            }
 
-        Params[1].Type           = ACPI_TYPE_STRING;
-        Params[1].String.Length  = 12;
-        Params[1].String.Pointer = &quot;AML Debugger&quot;;
+            ParamObjects.Pointer = Params;
+            ParamObjects.Count   = i;
+        }
+        else
+        {
+            /* Setup default parameters */
 
-        ParamObjects.Pointer     = Params;
-        ParamObjects.Count       = 2;
+            for (i = 0; i &lt; ObjInfo-&gt;ParamCount; i++)
+            {
+                switch (i)
+                {
+                case 0:
+
+                    Params[0].Type           = ACPI_TYPE_INTEGER;
+                    Params[0].Integer.Value  = 0x01020304;
+                    break;
+
+                case 1:
+
+                    Params[1].Type           = ACPI_TYPE_STRING;
+                    Params[1].String.Length  = 12;
+                    Params[1].String.Pointer = &quot;AML Debugger&quot;;
+                    break;
+
+                default:
+
+                    Params[i].Type           = ACPI_TYPE_INTEGER;
+                    Params[i].Integer.Value  = i * (ACPI_INTEGER) 0x1000;
+                    break;
+                }
+            }
+
+            ParamObjects.Pointer     = Params;
+            ParamObjects.Count       = ObjInfo-&gt;ParamCount;
+        }
     }
 
+    ACPI_FREE (Buffer.Pointer);
+
     /* Prepare for a return object of arbitrary size */
 
     ReturnObj-&gt;Pointer = AcpiGbl_DbBuffer;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/events/evgpe.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/events/evgpe.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/events/evgpe.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -363,15 +363,17 @@
         return_ACPI_STATUS (Status);
     }
 
-    /* Mark wake-disabled or HW disable, or both */
+    /* Clear the appropriate enabled flags for this GPE */
 
     switch (GpeEventInfo-&gt;Flags &amp; ACPI_GPE_TYPE_MASK)
     {
     case ACPI_GPE_TYPE_WAKE:
+
         ACPI_CLEAR_BIT (GpeEventInfo-&gt;Flags, ACPI_GPE_WAKE_ENABLED);
         break;
 
     case ACPI_GPE_TYPE_WAKE_RUN:
+
         ACPI_CLEAR_BIT (GpeEventInfo-&gt;Flags, ACPI_GPE_WAKE_ENABLED);
 
         /*lint -fallthrough */
@@ -381,21 +383,22 @@
         /* Disable the requested runtime GPE */
 
         ACPI_CLEAR_BIT (GpeEventInfo-&gt;Flags, ACPI_GPE_RUN_ENABLED);
+        break;
 
-        /*lint -fallthrough */
-
     default:
-        /*
-         * If we don't know the GPE type, make sure that we always
-         * disable it. This can prevent a certain type of GPE flood, where
-         * the GPE has no _Lxx/_Exx method, and it cannot be determined
-         * whether the GPE is wake, run, or wake/run.
-         */
-        Status = AcpiHwWriteGpeEnableReg (GpeEventInfo);
         break;
     }
 
-    return_ACPI_STATUS (AE_OK);
+    /*
+     * Always H/W disable this GPE, even if we don't know the GPE type.
+     * Simply clear the enable bit for this particular GPE, but do not
+     * write out the current GPE enable mask since this may inadvertently
+     * enable GPEs too early. An example is a rogue GPE that has arrived
+     * during ACPICA initialization - possibly because AML or other code
+     * has enabled the GPE.
+     */
+    Status = AcpiHwLowDisableGpe (GpeEventInfo);
+    return_ACPI_STATUS (Status);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/executer/exconfig.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/executer/exconfig.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/executer/exconfig.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -180,7 +180,7 @@
 
     /* Install the new table into the local data structures */
 
-    ObjDesc-&gt;Reference.Object = ACPI_CAST_PTR (void, TableIndex);
+    ObjDesc-&gt;Reference.Object = ACPI_TO_POINTER (TableIndex);
 
     /* Add the table to the namespace */
 
@@ -379,6 +379,7 @@
     ACPI_WALK_STATE         *WalkState)
 {
     ACPI_OPERAND_OBJECT     *DdbHandle;
+    ACPI_TABLE_HEADER       *Table;
     ACPI_TABLE_DESC         TableDesc;
     UINT32                  TableIndex;
     ACPI_STATUS             Status;
@@ -396,8 +397,8 @@
     {
     case ACPI_TYPE_REGION:
 
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, &quot;Load from Region %p %s\n&quot;,
-            ObjDesc, AcpiUtGetObjectTypeName (ObjDesc)));
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            &quot;Load table from Region %p\n&quot;, ObjDesc));
 
         /* Region must be SystemMemory (from ACPI spec) */
 
@@ -420,41 +421,88 @@
         }
 
         /*
-         * We will simply map the memory region for the table. However, the
-         * memory region is technically not guaranteed to remain stable and
-         * we may eventually have to copy the table to a local buffer.
+         * Map the table header and get the actual table length. The region
+         * length is not guaranteed to be the same as the table length.
          */
+        Table = AcpiOsMapMemory (ObjDesc-&gt;Region.Address,
+                    sizeof (ACPI_TABLE_HEADER));
+        if (!Table)
+        {
+            return_ACPI_STATUS (AE_NO_MEMORY);
+        }
+
+        Length = Table-&gt;Length;
+        AcpiOsUnmapMemory (Table, sizeof (ACPI_TABLE_HEADER));
+
+        /* Must have at least an ACPI table header */
+
+        if (Length &lt; sizeof (ACPI_TABLE_HEADER))
+        {
+            return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
+        }
+
+        /*
+         * The memory region is not guaranteed to remain stable and we must
+         * copy the table to a local buffer. For example, the memory region
+         * is corrupted after suspend on some machines. Dynamically loaded
+         * tables are usually small, so this overhead is minimal.
+         */
+
+        /* Allocate a buffer for the table */
+
+        TableDesc.Pointer = ACPI_ALLOCATE (Length);
+        if (!TableDesc.Pointer)
+        {
+            return_ACPI_STATUS (AE_NO_MEMORY);
+        }
+
+        /* Map the entire table and copy it */
+
+        Table = AcpiOsMapMemory (ObjDesc-&gt;Region.Address, Length);
+        if (!Table)
+        {
+            ACPI_FREE (TableDesc.Pointer);
+            return_ACPI_STATUS (AE_NO_MEMORY);
+        }
+
+        ACPI_MEMCPY (TableDesc.Pointer, Table, Length);
+        AcpiOsUnmapMemory (Table, Length);
+
         TableDesc.Address = ObjDesc-&gt;Region.Address;
-        TableDesc.Length = ObjDesc-&gt;Region.Length;
-        TableDesc.Flags = ACPI_TABLE_ORIGIN_MAPPED;
         break;
 
+
     case ACPI_TYPE_BUFFER: /* Buffer or resolved RegionField */
 
-        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, &quot;Load from Buffer or Field %p %s\n&quot;,
-            ObjDesc, AcpiUtGetObjectTypeName (ObjDesc)));
+        ACPI_DEBUG_PRINT ((ACPI_DB_EXEC,
+            &quot;Load table from Buffer or Field %p\n&quot;, ObjDesc));
 
-        Length = ObjDesc-&gt;Buffer.Length;
-
         /* Must have at least an ACPI table header */
 
-        if (Length &lt; sizeof (ACPI_TABLE_HEADER))
+        if (ObjDesc-&gt;Buffer.Length &lt; sizeof (ACPI_TABLE_HEADER))
         {
             return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
         }
 
-        /* Validate checksum here. It won't get validated in TbAddTable */
+        /* Get the actual table length from the table header */
 
-        Status = AcpiTbVerifyChecksum (
-                    ACPI_CAST_PTR (ACPI_TABLE_HEADER, ObjDesc-&gt;Buffer.Pointer), Length);
-        if (ACPI_FAILURE (Status))
+        Table = ACPI_CAST_PTR (ACPI_TABLE_HEADER, ObjDesc-&gt;Buffer.Pointer);
+        Length = Table-&gt;Length;
+
+        /* Table cannot extend beyond the buffer */
+
+        if (Length &gt; ObjDesc-&gt;Buffer.Length)
         {
-            return_ACPI_STATUS (Status);
+            return_ACPI_STATUS (AE_AML_BUFFER_LIMIT);
         }
+        if (Length &lt; sizeof (ACPI_TABLE_HEADER))
+        {
+            return_ACPI_STATUS (AE_INVALID_TABLE_LENGTH);
+        }
 
         /*
-         * We need to copy the buffer since the original buffer could be
-         * changed or deleted in the future
+         * Copy the table from the buffer because the buffer could be modified
+         * or even deleted in the future
          */
         TableDesc.Pointer = ACPI_ALLOCATE (Length);
         if (!TableDesc.Pointer)
@@ -462,18 +510,31 @@
             return_ACPI_STATUS (AE_NO_MEMORY);
         }
 
-        ACPI_MEMCPY (TableDesc.Pointer, ObjDesc-&gt;Buffer.Pointer, Length);
-        TableDesc.Length = Length;
-        TableDesc.Flags = ACPI_TABLE_ORIGIN_ALLOCATED;
+        ACPI_MEMCPY (TableDesc.Pointer, Table, Length);
+        TableDesc.Address = ACPI_TO_INTEGER (TableDesc.Pointer);
         break;
 
+
     default:
         return_ACPI_STATUS (AE_AML_OPERAND_TYPE);
     }
 
-    /*
-     * Install the new table into the local data structures
-     */
+    /* Validate table checksum (will not get validated in TbAddTable) */
+
+    Status = AcpiTbVerifyChecksum (TableDesc.Pointer, Length);
+    if (ACPI_FAILURE (Status))
+    {
+        ACPI_FREE (TableDesc.Pointer);
+        return_ACPI_STATUS (Status);
+    }
+
+    /* Complete the table descriptor */
+
+    TableDesc.Length = Length;
+    TableDesc.Flags = ACPI_TABLE_ORIGIN_ALLOCATED;
+
+    /* Install the new table into the local data structures */
+
     Status = AcpiTbAddTable (&amp;TableDesc, &amp;TableIndex);
     if (ACPI_FAILURE (Status))
     {
@@ -483,7 +544,7 @@
     /*
      * Add the table to the namespace.
      *
-     * Note: We load the table objects relative to the root of the namespace.
+     * Note: Load the table objects relative to the root of the namespace.
      * This appears to go against the ACPI specification, but we do it for
      * compatibility with other ACPI implementations.
      */
@@ -519,7 +580,7 @@
 Cleanup:
     if (ACPI_FAILURE (Status))
     {
-        /* Delete allocated buffer or mapping */
+        /* Delete allocated table buffer */
 
         AcpiTbDeleteTable (&amp;TableDesc);
     }
@@ -590,6 +651,9 @@
 
     AcpiTbSetTableLoadedFlag (TableIndex, FALSE);
 
+    /* Table unloaded, remove a reference to the DdbHandle object */
+
+    AcpiUtRemoveReference (DdbHandle);
     return_ACPI_STATUS (AE_OK);
 }
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwgpe.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwgpe.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwgpe.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -129,8 +129,62 @@
     ACPI_GPE_BLOCK_INFO     *GpeBlock);
 
 
+
 /******************************************************************************
  *
+ * FUNCTION:    AcpiHwLowDisableGpe
+ *
+ * PARAMETERS:  GpeEventInfo        - Info block for the GPE to be disabled
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Disable a single GPE in the enable register.
+ *
+ ******************************************************************************/
+
+ACPI_STATUS
+AcpiHwLowDisableGpe (
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo)
+{
+    ACPI_GPE_REGISTER_INFO  *GpeRegisterInfo;
+    ACPI_STATUS             Status;
+    UINT32                  EnableMask;
+
+
+    /* Get the info block for the entire GPE register */
+
+    GpeRegisterInfo = GpeEventInfo-&gt;RegisterInfo;
+    if (!GpeRegisterInfo)
+    {
+        return (AE_NOT_EXIST);
+    }
+
+    /* Get current value of the enable register that contains this GPE */
+
+    Status = AcpiHwLowLevelRead (ACPI_GPE_REGISTER_WIDTH, &amp;EnableMask,
+                &amp;GpeRegisterInfo-&gt;EnableAddress);
+    if (ACPI_FAILURE (Status))
+    {
+        return (Status);
+    }
+
+    /* Clear just the bit that corresponds to this GPE */
+
+    ACPI_CLEAR_BIT (EnableMask,
+        ((UINT32) 1 &lt;&lt; (GpeEventInfo-&gt;GpeNumber - GpeRegisterInfo-&gt;BaseGpeNumber)));
+
+
+    /* Write the updated enable mask */
+
+    Status = AcpiHwLowLevelWrite (ACPI_GPE_REGISTER_WIDTH, EnableMask,
+                &amp;GpeRegisterInfo-&gt;EnableAddress);
+
+    return (Status);
+}
+
+
+/******************************************************************************
+ *
  * FUNCTION:    AcpiHwWriteGpeEnableReg
  *
  * PARAMETERS:  GpeEventInfo        - Info block for the GPE to be enabled

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwregs.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwregs.c	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/hardware/hwregs.c	2008-07-19 11:09:30 UTC (rev 26499)
@@ -354,7 +354,7 @@
  * RETURN:      Status and the value read from specified Register. Value
  *              returned is normalized to bit0 (is shifted all the way right)
  *
- * DESCRIPTION: ACPI BitRegister read function.
+ * DESCRIPTION: ACPI BitRegister read function. Does not acquire the HW lock.
  *
  ******************************************************************************/
 
@@ -428,7 +428,7 @@
     Status = AcpiGetRegisterUnlocked (RegisterId, ReturnValue);
     AcpiOsReleaseLock (AcpiGbl_HardwareLock, Flags);
 
-    return Status;
+    return (Status);
 }
 
 ACPI_EXPORT_SYMBOL (AcpiGetRegister)

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acconfig.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acconfig.h	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acconfig.h	2008-07-19 11:09:30 UTC (rev 26499)
@@ -137,7 +137,7 @@
 
 /* Current ACPICA subsystem version in YYYYMMDD format */
 
-#define ACPI_CA_VERSION                 0x20080609
+#define ACPI_CA_VERSION                 0x20080701
 
 /*
  * OS name, used for the _OS object.  The _OS object is essentially obsolete,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acglobal.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acglobal.h	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acglobal.h	2008-07-19 11:09:30 UTC (rev 26499)
@@ -440,8 +440,8 @@
 ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_tables;
 ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_stats;
 ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_ini_methods;
+ACPI_EXTERN BOOLEAN                     AcpiGbl_DbOpt_NoRegionSupport;
 
-
 ACPI_EXTERN char                       *AcpiGbl_DbArgs[ACPI_DEBUGGER_MAX_ARGS];
 ACPI_EXTERN char                        AcpiGbl_DbLineBuf[80];
 ACPI_EXTERN char                        AcpiGbl_DbParsedBuf[80];

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/achware.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/achware.h	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/achware.h	2008-07-19 11:09:30 UTC (rev 26499)
@@ -184,6 +184,10 @@
  * hwgpe - GPE support
  */
 ACPI_STATUS
+AcpiHwLowDisableGpe (
+    ACPI_GPE_EVENT_INFO     *GpeEventInfo);
+
+ACPI_STATUS
 AcpiHwWriteGpeEnableReg (
     ACPI_GPE_EVENT_INFO     *GpeEventInfo);
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/aclocal.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/aclocal.h	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/aclocal.h	2008-07-19 11:09:30 UTC (rev 26499)
@@ -175,8 +175,8 @@
 static char                 *AcpiGbl_MutexNames[ACPI_NUM_MUTEX] =
 {
     &quot;ACPI_MTX_Interpreter&quot;,
+    &quot;ACPI_MTX_Namespace&quot;,
     &quot;ACPI_MTX_Tables&quot;,
-    &quot;ACPI_MTX_Namespace&quot;,
     &quot;ACPI_MTX_Events&quot;,
     &quot;ACPI_MTX_Caches&quot;,
     &quot;ACPI_MTX_Memory&quot;,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acmacros.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acmacros.h	2008-07-19 11:06:33 UTC (rev 26498)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/include/acmacros.h	2008-07-19 11:09:30 UTC (rev 26499)
@@ -137,7 +137,7 @@
 
 
 /*
- * Extract data using a pointer.  Any more than a byte and we
+ * Extract data using a pointer. Any more than a byte and we
  * get into potential aligment issues -- see the STORE macros below.
  * Use with care.
  */
@@ -155,21 +155,21 @@
  */
 #define ACPI_CAST_PTR(t, p)             ((t *) (ACPI_UINTPTR_T) (p))
 #define ACPI_CAST_INDIRECT_PTR(t, p)    ((t **) (ACPI_UINTPTR_T) (p))
-#define ACPI_ADD_PTR(t,a,b)             ACPI_CAST_PTR (t, (ACPI_CAST_PTR (UINT8,(a)) + (ACPI_SIZE)(b)))
-#define ACPI_PTR_DIFF(a,b)              (ACPI_SIZE) (ACPI_CAST_PTR (UINT8,(a)) - ACPI_CAST_PTR (UINT8,(b)))
+#define ACPI_ADD_PTR(t, a, b)           ACPI_CAST_PTR (t, (ACPI_CAST_PTR (UINT8, (a)) + (ACPI_SIZE)(b)))
+#define ACPI_PTR_DIFF(a, b)             (ACPI_SIZE) (ACPI_CAST_PTR (UINT8, (a)) - ACPI_CAST_PTR (UINT8, (b)))
 
 /* Pointer/Integer type conversions */
 
-#define ACPI_TO_POINTER(i)              ACPI_ADD_PTR (void,(void *) NULL,(ACPI_SIZE) i)
-#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p,(void *) NULL)
-#define ACPI_OFFSET(d,f)                (ACPI_SIZE) ACPI_PTR_DIFF (&amp;(((d *)0)-&gt;f),(void *) NULL)
+#define ACPI_TO_POINTER(i)              ACPI_ADD_PTR (void, (void *) NULL,(ACPI_SIZE) i)
+#define ACPI_TO_INTEGER(p)              ACPI_PTR_DIFF (p, (void *) NULL)
+#define ACPI_OFFSET(d, f)               (ACPI_SIZE) ACPI_PTR_DIFF (&amp;(((d *)0)-&gt;f), (void *) NULL)
 #define ACPI_PHYSADDR_TO_PTR(i)         ACPI_TO_POINTER(i)
 #define ACPI_PTR_TO_PHYSADDR(i)         ACPI_TO_INTEGER(i)
 
 #ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
-#define ACPI_COMPARE_NAME(a,b)          (*ACPI_CAST_PTR (UINT32,(a)) == *ACPI_CAST_PTR (UINT32,(b)))
+#define ACPI_COMPARE_NAME(a,b)          (*ACPI_CAST_PTR (UINT32, (a)) == *ACPI_CAST_PTR (UINT32, (b)))
 #else
-#define ACPI_COMPARE_NAME(a,b)          (!ACPI_STRNCMP (ACPI_CAST_PTR (char,(a)), ACPI_CAST_PTR (char,(b)), ACPI_NAME_SIZE))
+#define ACPI_COMPARE_NAME(a,b)          (!ACPI_STRNCMP (ACPI_CAST_PTR (char, (a)), ACPI_CAST_PTR (char, (b)), ACPI_NAME_SIZE))
 #endif
 
 /*
@@ -191,7 +191,7 @@
 
 /* Split 64-bit integer into two 32-bit values. Use with %8.8X%8.8X */
 
-#define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i),ACPI_LODWORD(i)
+#define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
 #if ACPI_MACHINE_WIDTH == 64
 #define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)
@@ -210,37 +210,33 @@
  * Macros for big-endian machines
  */
 
-/* This macro sets a buffer index, starting from the end of the buffer */
-
-#define ACPI_BUFFER_INDEX(BufLen,BufOffset,ByteGran)  ((BufLen) - (((BufOffset)+1) * (ByteGran)))
-
 /* These macros reverse the bytes during the move, converting little-endian to big endian */
 
                                                      /* Big Endian      &lt;==        Little Endian */
                                                      /*  Hi...Lo                     Lo...Hi     */
 /* 16-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_16_TO_16(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[1];\
+#define ACPI_MOVE_16_TO_16(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[1];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[0];}
 
-#define ACPI_MOVE_16_TO_32(d,s)         {(*(UINT32 *)(void *)(d))=0;\
+#define ACPI_MOVE_16_TO_32(d, s)        {(*(UINT32 *)(void *)(d))=0;\
                                            ((UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[1];\
                                            ((UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[0];}
 
-#define ACPI_MOVE_16_TO_64(d,s)         {(*(UINT64 *)(void *)(d))=0;\
+#define ACPI_MOVE_16_TO_64(d, s)        {(*(UINT64 *)(void *)(d))=0;\
                                            ((UINT8 *)(void *)(d))[6] = ((UINT8 *)(void *)(s))[1];\
                                            ((UINT8 *)(void *)(d))[7] = ((UINT8 *)(void *)(s))[0];}
 
 /* 32-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 
-#define ACPI_MOVE_32_TO_32(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[3];\
+#define ACPI_MOVE_32_TO_32(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[3];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[2];\
                                          ((  UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[1];\
                                          ((  UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[0];}
 
-#define ACPI_MOVE_32_TO_64(d,s)         {(*(UINT64 *)(void *)(d))=0;\
+#define ACPI_MOVE_32_TO_64(d, s)        {(*(UINT64 *)(void *)(d))=0;\
                                            ((UINT8 *)(void *)(d))[4] = ((UINT8 *)(void *)(s))[3];\
                                            ((UINT8 *)(void *)(d))[5] = ((UINT8 *)(void *)(s))[2];\
                                            ((UINT8 *)(void *)(d))[6] = ((UINT8 *)(void *)(s))[1];\
@@ -248,11 +244,11 @@
 
 /* 64-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 
-#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)    /* Truncate to 32 */
 
-#define ACPI_MOVE_64_TO_64(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];\
+#define ACPI_MOVE_64_TO_64(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[7];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[6];\
                                          ((  UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[5];\
                                          ((  UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[4];\
@@ -265,63 +261,59 @@
  * Macros for little-endian machines
  */
 
-/* This macro sets a buffer index, starting from the beginning of the buffer */
-
-#define ACPI_BUFFER_INDEX(BufLen,BufOffset,ByteGran)  (BufOffset)
-
 #ifndef ACPI_MISALIGNMENT_NOT_SUPPORTED
 
 /* The hardware supports unaligned transfers, just do the little-endian move */
 
 /* 16-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_16_TO_16(d,s)         *(UINT16 *)(void *)(d) = *(UINT16 *)(void *)(s)
-#define ACPI_MOVE_16_TO_32(d,s)         *(UINT32 *)(void *)(d) = *(UINT16 *)(void *)(s)
-#define ACPI_MOVE_16_TO_64(d,s)         *(UINT64 *)(void *)(d) = *(UINT16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_16(d, s)        *(UINT16 *)(void *)(d) = *(UINT16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_32(d, s)        *(UINT32 *)(void *)(d) = *(UINT16 *)(void *)(s)
+#define ACPI_MOVE_16_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT16 *)(void *)(s)
 
 /* 32-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
-#define ACPI_MOVE_32_TO_32(d,s)         *(UINT32 *)(void *)(d) = *(UINT32 *)(void *)(s)
-#define ACPI_MOVE_32_TO_64(d,s)         *(UINT64 *)(void *)(d) = *(UINT32 *)(void *)(s)
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_32(d, s)        *(UINT32 *)(void *)(d) = *(UINT32 *)(void *)(s)
+#define ACPI_MOVE_32_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT32 *)(void *)(s)
 
 /* 64-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
-#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
-#define ACPI_MOVE_64_TO_64(d,s)         *(UINT64 *)(void *)(d) = *(UINT64 *)(void *)(s)
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d, s)        *(UINT64 *)(void *)(d) = *(UINT64 *)(void *)(s)
 
 #else
 /*
- * The hardware does not support unaligned transfers.  We must move the
- * data one byte at a time.  These macros work whether the source or
+ * The hardware does not support unaligned transfers. We must move the
+ * data one byte at a time. These macros work whether the source or
  * the destination (or both) is/are unaligned.  (Little-endian move)
  */
 
 /* 16-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_16_TO_16(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
+#define ACPI_MOVE_16_TO_16(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[1];}
 
-#define ACPI_MOVE_16_TO_32(d,s)         {(*(UINT32 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d,s);}
-#define ACPI_MOVE_16_TO_64(d,s)         {(*(UINT64 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d,s);}
+#define ACPI_MOVE_16_TO_32(d, s)        {(*(UINT32 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
+#define ACPI_MOVE_16_TO_64(d, s)        {(*(UINT64 *)(void *)(d)) = 0; ACPI_MOVE_16_TO_16(d, s);}
 
 /* 32-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_32_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
+#define ACPI_MOVE_32_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
 
-#define ACPI_MOVE_32_TO_32(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
+#define ACPI_MOVE_32_TO_32(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[1];\
                                          ((  UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[2];\
                                          ((  UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[3];}
 
-#define ACPI_MOVE_32_TO_64(d,s)         {(*(UINT64 *)(void *)(d)) = 0; ACPI_MOVE_32_TO_32(d,s);}
+#define ACPI_MOVE_32_TO_64(d, s)        {(*(UINT64 *)(void *)(d)) = 0; ACPI_MOVE_32_TO_32(d, s);}
 
 /* 64-bit source, 16/32/64 destination */
 
-#define ACPI_MOVE_64_TO_16(d,s)         ACPI_MOVE_16_TO_16(d,s)    /* Truncate to 16 */
-#define ACPI_MOVE_64_TO_32(d,s)         ACPI_MOVE_32_TO_32(d,s)    /* Truncate to 32 */
-#define ACPI_MOVE_64_TO_64(d,s)         {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
+#define ACPI_MOVE_64_TO_16(d, s)        ACPI_MOVE_16_TO_16(d, s)    /* Truncate to 16 */
+#define ACPI_MOVE_64_TO_32(d, s)        ACPI_MOVE_32_TO_32(d, s)    /* Truncate to 32 */
+#define ACPI_MOVE_64_TO_64(d, s)        {((  UINT8 *)(void *)(d))[0] = ((UINT8 *)(void *)(s))[0];\
                                          ((  UINT8 *)(void *)(d))[1] = ((UINT8 *)(void *)(s))[1];\
                                          ((  UINT8 *)(void *)(d))[2] = ((UINT8 *)(void *)(s))[2];\
                                          ((  UINT8 *)(void *)(d))[3] = ((UINT8 *)(void *)(s))[3];\
@@ -332,65 +324,53 @@
 #endif
 #endif
 
-/* Macros based on machine integer width */
 
-#if ACPI_MACHINE_WIDTH == 32
-#define ACPI_MOVE_SIZE_TO_16(d,s)       ACPI_MOVE_32_TO_16(d,s)
-
-#elif ACPI_MACHINE_WIDTH == 64
-#define ACPI_MOVE_SIZE_TO_16(d,s)       ACPI_MOVE_64_TO_16(d,s)
-
-#else
-#error unknown ACPI_MACHINE_WIDTH
-#endif
-
-
 /*
  * Fast power-of-two math macros for non-optimized compilers
  */
-#define _ACPI_DIV(value,PowerOf2)       ((UINT32) ((value) &gt;&gt; (PowerOf2)))
-#define _ACPI_MUL(value,PowerOf2)       ((UINT32) ((value) &lt;&lt; (PowerOf2)))
-#define _ACPI_MOD(value,Divisor)        ((UINT32) ((value) &amp; ((Divisor) -1)))
+#define _ACPI_DIV(value, PowerOf2)      ((UINT32) ((value) &gt;&gt; (PowerOf2)))
+#define _ACPI_MUL(value, PowerOf2)      ((UINT32) ((value) &lt;&lt; (PowerOf2)))
+#define _ACPI_MOD(value, Divisor)       ((UINT32) ((value) &amp; ((Divisor) -1)))
 
-#define ACPI_DIV_2(a)                   _ACPI_DIV(a,1)
-#define ACPI_MUL_2(a)                   _ACPI_MUL(a,1)
-#define ACPI_MOD_2(a)                   _ACPI_MOD(a,2)
+#define ACPI_DIV_2(a)                   _ACPI_DIV(a, 1)
+#define ACPI_MUL_2(a)                   _ACPI_MUL(a, 1)
+#define ACPI_MOD_2(a)                   _ACPI_MOD(a, 2)
 
-#define ACPI_DIV_4(a)                   _ACPI_DIV(a,2)
-#define ACPI_MUL_4(a)                   _ACPI_MUL(a,2)
-#define ACPI_MOD_4(a)                   _ACPI_MOD(a,4)
+#define ACPI_DIV_4(a)                   _ACPI_DIV(a, 2)
+#define ACPI_MUL_4(a)                   _ACPI_MUL(a, 2)
+#define ACPI_MOD_4(a)                   _ACPI_MOD(a, 4)
 
-#define ACPI_DIV_8(a)                   _ACPI_DIV(a,3)
-#define ACPI_MUL_8(a)                   _ACPI_MUL(a,3)
-#define ACPI_MOD_8(a)                   _ACPI_MOD(a,8)
+#define ACPI_DIV_8(a)                   _ACPI_DIV(a, 3)
+#define ACPI_MUL_8(a)                   _ACPI_MUL(a, 3)
+#define ACPI_MOD_8(a)                   _ACPI_MOD(a, 8)
 
-#define ACPI_DIV_16(a)                  _ACPI_DIV(a,4)
-#define ACPI_MUL_16(a)                  _ACPI_MUL(a,4)
-#define ACPI_MOD_16(a)                  _ACPI_MOD(a,16)
+#define ACPI_DIV_16(a)                  _ACPI_DIV(a, 4)
+#define ACPI_MUL_16(a)                  _ACPI_MUL(a, 4)
+#define ACPI_MOD_16(a)                  _ACPI_MOD(a, 16)
 
-#define ACPI_DIV_32(a)                  _ACPI_DIV(a,5)
-#define ACPI_MUL_32(a)                  _ACPI_MUL(a,5)
-#define ACPI_MOD_32(a)                  _ACPI_MOD(a,32)
+#define ACPI_DIV_32(a)                  _ACPI_DIV(a, 5)
+#define ACPI_MUL_32(a)                  _ACPI_MUL(a, 5)
+#define ACPI_MOD_32(a)                  _ACPI_MOD(a, 32)
 
 /*
  * Rounding macros (Power of two boundaries only)
  */
-#define ACPI_ROUND_DOWN(value,boundary)     (((ACPI_SIZE)(value)) &amp; \
+#define ACPI_ROUND_DOWN(value, boundary)    (((ACPI_SIZE)(value)) &amp; \
                                                 (~(((ACPI_SIZE) boundary)-1)))
 
-#define ACPI_ROUND_UP(value,boundary)       ((((ACPI_SIZE)(value)) + \
+#define ACPI_ROUND_UP(value, boundary)      ((((ACPI_SIZE)(value)) + \
                                                 (((ACPI_SIZE) boundary)-1)) &amp; \
                                                 (~(((ACPI_SIZE) boundary)-1)))
 
 /* Note: sizeof(ACPI_SIZE) evaluates to either 4 or 8 (32- vs 64-bit mode) */
 
-#define ACPI_ROUND_DOWN_TO_32BIT(a)         ACPI_ROUND_DOWN(a,4)
-#define ACPI_ROUND_DOWN_TO_64BIT(a)         ACPI_ROUND_DOWN(a,8)
-#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)   ACPI_ROUND_DOWN(a,sizeof(ACPI_SIZE))
+#define ACPI_ROUND_DOWN_TO_32BIT(a)         ACPI_ROUND_DOWN(a, 4)
+#define ACPI_ROUND_DOWN_TO_64BIT(a)         ACPI_ROUND_DOWN(a, 8)
+#define ACPI_ROUND_DOWN_TO_NATIVE_WORD(a)   ACPI_ROUND_DOWN(a, sizeof(ACPI_SIZE))
 
-#define ACPI_ROUND_UP_TO_32BIT(a)           ACPI_ROUND_UP(a,4)
-#define ACPI_ROUND_UP_TO_64BIT(a)           ACPI_ROUND_UP(a,8)
-#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)     ACPI_ROUND_UP(a,sizeof(ACPI_SIZE))
+#define ACPI_ROUND_UP_TO_32BIT(a)           ACPI_ROUND_UP(a, 4)
+#define ACPI_ROUND_UP_TO_64BIT(a)           ACPI_ROUND_UP(a, 8)
+#define ACPI_ROUND_UP_TO_NATIVE_WORD(a)     ACPI_ROUND_UP(a, sizeof(ACPI_SIZE))
 
 #define ACPI_ROUND_BITS_UP_TO_BYTES(a)      ACPI_DIV_8((a) + 7)
 #define ACPI_ROUND_BITS_DOWN_TO_BYTES(a)    ACPI_DIV_8((a))
@@ -399,9 +379,9 @@
 
 /* Generic (non-power-of-two) rounding */
 
-#define ACPI_ROUND_UP_TO(value,boundary)    (((value) + ((boundary)-1)) / (boundary))
+#define ACPI_ROUND_UP_TO(value, boundary)   (((value) + ((boundary)-1)) / (boundary))
 
-#define ACPI_IS_MISALIGNED(value)           (((ACPI_SIZE)value) &amp; (sizeof(ACPI_SIZE)-1))
+#define ACPI_IS_MISALIGNED(value)           (((ACPI_SIZE) value) &amp; (sizeof(ACPI_SIZE)-1))
 
 /*
  * Bitmask creation
@@ -412,9 +392,6 @@
 #define ACPI_MASK_BITS_ABOVE(position)      (~((ACPI_INTEGER_MAX) &lt;&lt; ((UINT32) (position))))
 #define ACPI_MASK_BITS_BELOW(position)      ((ACPI_INTEGER_MAX) &lt;&lt; ((UINT32) (position)))
 
-#define ACPI_IS_OCTAL_DIGIT(d)              (((char)(d) &gt;= '0') &amp;&amp; ((char)(d) &lt;= '7'))
-
-
 /* Bitfields within ACPI registers */
 
 #define ACPI_REGISTER_PREPARE_BITS(Val, Pos, Mask)      ((Val &lt;&lt; Pos) &amp; Mask)
@@ -422,40 +399,29 @@
 
 #define ACPI_INSERT_BITS(Target, Mask, Source)          Target = ((Target &amp; (~(Mask))) | (Source &amp; Mask))
 
-/* Generate a UUID */
-
-#define ACPI_INIT_UUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
-    (a) &amp; 0xFF, ((a) &gt;&gt; 8) &amp; 0xFF, ((a) &gt;&gt; 16) &amp; 0xFF, ((a) &gt;&gt; 24) &amp; 0xFF, \
-    (b) &amp; 0xFF, ((b) &gt;&gt; 8) &amp; 0xFF, \
-    (c) &amp; 0xFF, ((c) &gt;&gt; 8) &amp; 0xFF, \
-    (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7)
-
 /*
- * An ACPI_NAMESPACE_NODE * can appear in some contexts,
- * where a pointer to an ACPI_OPERAND_OBJECT  can also
- * appear.  This macro is used to distinguish them.
+ * An ACPI_NAMESPACE_NODE can appear in some contexts
+ * where a pointer to an ACPI_OPERAND_OBJECT can also
+ * appear. This macro is used to distinguish them.
  *
  * The &quot;Descriptor&quot; field is the first field in both structures.
  */
 #define ACPI_GET_DESCRIPTOR_TYPE(d)     (((ACPI_DESCRIPTOR *)(void *)(d))-&gt;Common.DescriptorType)
-#define ACPI_SET_DESCRIPTOR_TYPE(d,t)   (((ACPI_DESCRIPTOR *)(void *)(d))-&gt;Common.DescriptorType = t)
+#define ACPI_SET_DESCRIPTOR_TYPE(d, t)  (((ACPI_DESCRIPTOR *)(void *)(d))-&gt;Common.DescriptorType = t)
 
-
 /* Macro to test the object type */
 
 #define ACPI_GET_OBJECT_TYPE(d)         (((ACPI_OPERAND_OBJECT *)(void *)(d))-&gt;Common.Type)
 
-/* Macro to check the table flags for SINGLE or MULTIPLE tables are allowed */
-
-#define ACPI_IS_SINGLE_TABLE(x)         (((x) &amp; 0x01) == ACPI_TABLE_SINGLE ? 1 : 0)
-
 /*
  * Macros for the master AML opcode table
  */
-#if defined(ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
-#define ACPI_OP(Name,PArgs,IArgs,ObjType,Class,Type,Flags)     {Name,(UINT32)(PArgs),(UINT32)(IArgs),(UINT32)(Flags),ObjType,Class,Type}
+#if defined (ACPI_DISASSEMBLER) || defined (ACPI_DEBUG_OUTPUT)
+#define ACPI_OP(Name, PArgs, IArgs, ObjType, Class, Type, Flags) \
+    {Name, (UINT32)(PArgs), (UINT32)(IArgs), (UINT32)(Flags), ObjType, Class, Type}
 #else
-#define ACPI_OP(Name,PArgs,IArgs,ObjType,Class,Type,Flags)     {(UINT32)(PArgs),(UINT32)(IArgs),(UINT32)(Flags),ObjType,Class,Type}
+#define ACPI_OP(Name, PArgs, IArgs, ObjType, Class, Type, Flags) \
+    {(UINT32)(PArgs), (UINT32)(IArgs), (UINT32)(Flags), ObjType, Class, Type}
 #endif
 
 #ifdef ACPI_DISASSEMBLER
@@ -473,18 +439,18 @@
 #define ARG_6(x)                        ((UINT32)(x) &lt;&lt; (5 * ARG_TYPE_WIDTH))
 
 #define ARGI_LIST1(a)                   (ARG_1(a))
-#define ARGI_LIST2(a,b)                 (ARG_1(b)|ARG_2(a))
-#define ARGI_LIST3(a,b,c)               (ARG_1(c)|ARG_2(b)|ARG_3(a))
-#define ARGI_LIST4(a,b,c,d)             (ARG_1(d)|ARG_2(c)|ARG_3(b)|ARG_4(a))
-#define ARGI_LIST5(a,b,c,d,e)           (ARG_1(e)|ARG_2(d)|ARG_3(c)|ARG_4(b)|ARG_5(a))
-#define ARGI_LIST6(a,b,c,d,e,f)         (ARG_1(f)|ARG_2(e)|ARG_3(d)|ARG_4(c)|ARG_5(b)|ARG_6(a))
+#define ARGI_LIST2(a, b)                (ARG_1(b)|ARG_2(a))
+#define ARGI_LIST3(a, b, c)             (ARG_1(c)|ARG_2(b)|ARG_3(a))
+#define ARGI_LIST4(a, b, c, d)          (ARG_1(d)|ARG_2(c)|ARG_3(b)|ARG_4(a))
+#define ARGI_LIST5(a, b, c, d, e)       (ARG_1(e)|ARG_2(d)|ARG_3(c)|ARG_4(b)|ARG_5(a))
+#define ARGI_LIST6(a, b, c, d, e, f)    (ARG_1(f)|ARG_2(e)|ARG_3(d)|ARG_4(c)|ARG_5(b)|ARG_6(a))
 
 #define ARGP_LIST1(a)                   (ARG_1(a))
-#define ARGP_LIST2(a,b)                 (ARG_1(a)|ARG_2(b))
-#define ARGP_LIST3(a,b,c)               (ARG_1(a)|ARG_2(b)|ARG_3(c))
-#define ARGP_LIST4(a,b,c,d)             (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d))
-#define ARGP_LIST5(a,b,c,d,e)           (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e))
-#define ARGP_LIST6(a,b,c,d,e,f)         (ARG_1(a)|ARG_2(b)|ARG_3(c)|ARG_4(d)|ARG_5(e)|ARG_6(f))
+#define ARGP_LIST2(a, b)                (ARG_1(a)|ARG_2(b))
+#define ARGP_LIST3(a, b, c)             (ARG_1(a)|ARG_2(b)|ARG_3(c))

[... truncated: 383 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010366.html">[Haiku-commits] r26498 - haiku/vendor/acpica
</A></li>
	<LI>Next message: <A HREF="010368.html">[Haiku-commits] r26500 - haiku/trunk/src/preferences/devices
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10367">[ date ]</a>
              <a href="thread.html#10367">[ thread ]</a>
              <a href="subject.html#10367">[ subject ]</a>
              <a href="author.html#10367">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
