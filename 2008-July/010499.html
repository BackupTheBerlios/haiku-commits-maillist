<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26579 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26579%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm%20src/tools/fs_shell&In-Reply-To=%3C200807231548.m6NFm0D8019302%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010498.html">
   <LINK REL="Next"  HREF="010500.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26579 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm src/tools/fs_shell</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26579%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm%20src/tools/fs_shell&In-Reply-To=%3C200807231548.m6NFm0D8019302%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26579 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/iso9660	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm src/tools/fs_shell">bonefish at mail.berlios.de
       </A><BR>
    <I>Wed Jul 23 17:48:00 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010498.html">[Haiku-commits] r26578 - in haiku/trunk: headers/private/kernel	src/system/kernel/vm
</A></li>
        <LI>Next message: <A HREF="010500.html">[Haiku-commits] r26580 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10499">[ date ]</a>
              <a href="thread.html#10499">[ thread ]</a>
              <a href="subject.html#10499">[ subject ]</a>
              <a href="author.html#10499">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-07-23 17:47:47 +0200 (Wed, 23 Jul 2008)
New Revision: 26579
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26579&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26579&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/headers/private/kernel/vfs.h
   haiku/trunk/headers/private/kernel/vm_page.h
   haiku/trunk/headers/private/kernel/vm_types.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.h
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/fs/fifo.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/vm/VMAnonymousCache.cpp
   haiku/trunk/src/system/kernel/vm/VMAnonymousCache.h
   haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.cpp
   haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.h
   haiku/trunk/src/system/kernel/vm/VMDeviceCache.cpp
   haiku/trunk/src/system/kernel/vm/VMDeviceCache.h
   haiku/trunk/src/system/kernel/vm/vm.cpp
   haiku/trunk/src/system/kernel/vm/vm_cache.cpp
   haiku/trunk/src/system/kernel/vm/vm_page.cpp
   haiku/trunk/src/tools/fs_shell/file_cache.cpp
   haiku/trunk/src/tools/fs_shell/vfs.cpp
   haiku/trunk/src/tools/fs_shell/vfs.h
Log:
* bfs_fsync() was the only place which could cause the
  fs_vnode_ops::write_pages() to be called with fsReenter = true. Since
  this is no longer the case, the argument has become superfluous. For
  read_pages() it always was. Removed the argument from the functions
  and all functions that propagated it.
* Some whitespace at the end of lines was removed.


Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -119,11 +119,10 @@
 	/* VM file access */
 	bool (*can_page)(fs_volume *volume, fs_vnode *vnode, void *cookie);
 	status_t (*read_pages)(fs_volume *volume, fs_vnode *vnode, void *cookie,
-				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes,
-				bool reenter);
+				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes);
 	status_t (*write_pages)(fs_volume *volume, fs_vnode *vnode,
 				void *cookie, off_t pos, const iovec *vecs, size_t count,
-				size_t *_numBytes, bool reenter);
+				size_t *_numBytes);
 
 	/* cache file access */
 	status_t (*get_file_map)(fs_volume *volume, fs_vnode *vnode, off_t offset,
@@ -299,9 +298,9 @@
 					bool *removed);
 
 extern status_t read_pages(int fd, off_t pos, const struct iovec *vecs,
-					size_t count, size_t *_numBytes, bool fsReenter);
+					size_t count, size_t *_numBytes);
 extern status_t write_pages(int fd, off_t pos, const struct iovec *vecs,
-					size_t count, size_t *_numBytes, bool fsReenter);
+					size_t count, size_t *_numBytes);
 extern status_t read_file_io_vec_pages(int fd,
 					const struct file_io_vec *fileVecs, size_t fileVecCount,
 					const struct iovec *vecs, size_t vecCount,

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -137,10 +137,10 @@
 				fssh_fs_cookie cookie);
 	fssh_status_t (*read_pages)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
-				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
+				fssh_size_t count, fssh_size_t *_numBytes);
 	fssh_status_t (*write_pages)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
-				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
+				fssh_size_t count, fssh_size_t *_numBytes);
 
 	/* cache file access */
 	fssh_status_t (*get_file_map)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
@@ -339,10 +339,10 @@
 
 extern fssh_status_t fssh_read_pages(int fd, fssh_off_t pos,
 				const struct fssh_iovec *vecs, fssh_size_t count,
-				fssh_size_t *_numBytes, bool fsReenter);
+				fssh_size_t *_numBytes);
 extern fssh_status_t fssh_write_pages(int fd, fssh_off_t pos,
 				const struct fssh_iovec *vecs, fssh_size_t count,
-				fssh_size_t *_numBytes, bool fsReenter);
+				fssh_size_t *_numBytes);
 extern fssh_status_t fssh_read_file_io_vec_pages(int fd,
 				const struct fssh_file_io_vec *fileVecs,
 				fssh_size_t fileVecCount, const struct fssh_iovec *vecs,

Modified: haiku/trunk/headers/private/kernel/vfs.h
===================================================================
--- haiku/trunk/headers/private/kernel/vfs.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/headers/private/kernel/vfs.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -26,7 +26,7 @@
 
 #define DEFAULT_FD_TABLE_SIZE	256
 #define MAX_FD_TABLE_SIZE		8192
-#define DEFAULT_NODE_MONITORS	4096 
+#define DEFAULT_NODE_MONITORS	4096
 #define MAX_NODE_MONITORS		65536
 
 #define B_UNMOUNT_BUSY_PARTITION	0x80000000
@@ -64,7 +64,7 @@
 
 #ifdef __cplusplus
 extern &quot;C&quot; {
-#endif 
+#endif
 
 status_t vfs_init(struct kernel_args *args);
 status_t vfs_bootstrap_file_systems(void);
@@ -94,9 +94,9 @@
 status_t vfs_get_cookie_from_fd(int fd, void **_cookie);
 bool vfs_can_page(struct vnode *vnode, void *cookie);
 status_t vfs_read_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
+			const iovec *vecs, size_t count, size_t *_numBytes);
 status_t vfs_write_pages(struct vnode *vnode, void *cookie, off_t pos,
-			const iovec *vecs, size_t count, size_t *_numBytes, bool fsReenter);
+			const iovec *vecs, size_t count, size_t *_numBytes);
 status_t vfs_get_vnode_cache(struct vnode *vnode, struct VMCache **_cache,
 			bool allocate);
 status_t vfs_get_file_map(struct vnode *vnode, off_t offset, size_t size,
@@ -250,6 +250,6 @@
 
 #ifdef __cplusplus
 }
-#endif 
+#endif
 
 #endif	/* _KERNEL_VFS_H */

Modified: haiku/trunk/headers/private/kernel/vm_page.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm_page.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/headers/private/kernel/vm_page.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -36,8 +36,8 @@
 size_t vm_page_num_available_pages(void);
 
 status_t vm_page_write_modified_page_range(struct VMCache *cache,
-	uint32 firstPage, uint32 endPage, bool fsReenter);
-status_t vm_page_write_modified_pages(struct VMCache *cache, bool fsReenter);
+	uint32 firstPage, uint32 endPage);
+status_t vm_page_write_modified_pages(struct VMCache *cache);
 void vm_page_schedule_write_page(struct vm_page *page);
 void vm_page_schedule_write_page_range(struct VMCache *cache,
 	uint32 firstPage, uint32 endPage);

Modified: haiku/trunk/headers/private/kernel/vm_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm_types.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/headers/private/kernel/vm_types.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -202,7 +202,7 @@
 			status_t	InsertAreaLocked(vm_area* area);
 			status_t	RemoveArea(vm_area* area);
 
-			status_t	WriteModified(bool fsReenter);
+			status_t	WriteModified();
 			status_t	SetMinimalCommitment(off_t commitment);
 			status_t	Resize(off_t newSize);
 
@@ -217,9 +217,9 @@
 	virtual	bool		HasPage(off_t offset);
 
 	virtual	status_t	Read(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 	virtual	status_t	Write(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 
 	virtual	status_t	Fault(struct vm_address_space *aspace, off_t offset);
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -332,7 +332,7 @@
 
 static status_t
 bfs_read_pages(fs_volume *_volume, fs_vnode *_node, void *_cookie,
-	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	Volume *volume = (Volume *)_volume-&gt;private_volume;
 	Inode *inode = (Inode *)_node-&gt;private_node;
@@ -340,8 +340,7 @@
 	if (inode-&gt;FileCache() == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
-	if (!reenter)
-		rw_lock_read_lock(&amp;inode-&gt;Lock());
+	rw_lock_read_lock(&amp;inode-&gt;Lock());
 
 	uint32 vecIndex = 0;
 	size_t vecOffset = 0;
@@ -369,8 +368,7 @@
 		bytesLeft -= bytes;
 	}
 
-	if (!reenter)
-		rw_lock_read_unlock(&amp;inode-&gt;Lock());
+	rw_lock_read_unlock(&amp;inode-&gt;Lock());
 
 	return status;
 }
@@ -378,7 +376,7 @@
 
 static status_t
 bfs_write_pages(fs_volume *_volume, fs_vnode *_node, void *_cookie,
-	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	Volume *volume = (Volume *)_volume-&gt;private_volume;
 	Inode *inode = (Inode *)_node-&gt;private_node;
@@ -389,8 +387,7 @@
 	if (inode-&gt;FileCache() == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
-	if (!reenter)
-		rw_lock_read_lock(&amp;inode-&gt;Lock());
+	rw_lock_read_lock(&amp;inode-&gt;Lock());
 
 	uint32 vecIndex = 0;
 	size_t vecOffset = 0;
@@ -418,8 +415,7 @@
 		bytesLeft -= bytes;
 	}
 
-	if (!reenter)
-		rw_lock_read_unlock(&amp;inode-&gt;Lock());
+	rw_lock_read_unlock(&amp;inode-&gt;Lock());
 
 	return status;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -1584,7 +1584,7 @@
 
 static status_t
 cdda_read_pages(fs_volume *_volume, fs_vnode *_node, void *cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }
@@ -1592,7 +1592,7 @@
 
 static status_t
 cdda_write_pages(fs_volume *_volume, fs_vnode *_node, void *cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -199,7 +199,7 @@
 
 static status_t
 ext2_read_pages(fs_volume* _volume, fs_vnode* _node, void* _cookie,
-	off_t pos, const iovec* vecs, size_t count, size_t* _numBytes, bool reenter)
+	off_t pos, const iovec* vecs, size_t count, size_t* _numBytes)
 {
 	Volume* volume = (Volume*)_volume-&gt;private_volume;
 	Inode* inode = (Inode*)_node-&gt;private_node;
@@ -207,8 +207,7 @@
 	if (inode-&gt;FileCache() == NULL)
 		return B_BAD_VALUE;
 
-	if (!reenter)
-		rw_lock_read_lock(inode-&gt;Lock());
+	rw_lock_read_lock(inode-&gt;Lock());
 
 	uint32 vecIndex = 0;
 	size_t vecOffset = 0;
@@ -236,8 +235,7 @@
 		bytesLeft -= bytes;
 	}
 
-	if (!reenter)
-		rw_lock_read_unlock(inode-&gt;Lock());
+	rw_lock_read_unlock(inode-&gt;Lock());
 
 	return status;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -115,7 +115,7 @@
 
 		uint32 len = strlen(buf);
 		// lower case the parms data
-		for (i = 0; i &lt; len + 1; i++) 
+		for (i = 0; i &lt; len + 1; i++)
 			buf[i] = tolower(buf[i]);
 
 		// look for nojoliet
@@ -252,7 +252,7 @@
 			TRACE((&quot;fs_walk - read buffer from disk at LBN %Ld into buffer 0x%x.\n&quot;,
 				block, blockData));
 
-			// Move to the next 2-block set if necessary				
+			// Move to the next 2-block set if necessary
 			// Don't go over end of buffer, if dir record sits on boundary.
 
 			node.fileIDString = NULL;
@@ -285,7 +285,7 @@
 						free(node.attr.slName);
 						node.attr.slName = NULL;
 					}
-				} else {	
+				} else {
 					result = initResult;
 					if (bytesRead == 0)
 						done = TRUE;
@@ -298,7 +298,7 @@
 			}
 			totalRead += ns-&gt;logicalBlkSize[FS_DATA_FORMAT];
 			block++;
-			
+
 			TRACE((&quot;fs_walk - moving to next block %Ld, total read %Ld\n&quot;, block, totalRead));
 			block_cache_put(ns-&gt;fBlockCache, cachedBlock);
 
@@ -340,12 +340,12 @@
 
 	status_t result = InitNode(newNode, data + pos, NULL, ns-&gt;joliet_level);
 	block_cache_put(ns-&gt;fBlockCache, block);
-	
+
 	if (result &lt; B_OK) {
 		free(newNode);
 		return result;
 	}
-	
+
 	newNode-&gt;id = vnodeID;
 	_node-&gt;private_node = newNode;
 	_node-&gt;ops = &amp;gISO9660VnodeOps;
@@ -372,7 +372,7 @@
 
 	TRACE((&quot;fs_release_vnode - ENTER (0x%x)\n&quot;, node));
 
-	if (node != NULL) { 
+	if (node != NULL) {
 		if (node-&gt;id != ISO_ROOTNODE_ID) {
 			if (node-&gt;fileIDString != NULL)
 				free (node-&gt;fileIDString);
@@ -392,7 +392,7 @@
 
 static status_t
 fs_read_pages(fs_volume *_vol, fs_vnode *_node, void * _cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	nspace *ns = (nspace *)_vol-&gt;private_volume;
 	vnode *node = (vnode *)_node-&gt;private_node;
@@ -441,7 +441,7 @@
 
 	// Same for file/dir in ISO9660
 	st-&gt;st_size = node-&gt;dataLen[FS_DATA_FORMAT];
-	if (ConvertRecDate(&amp;(node-&gt;recordDate), &amp;time) == B_NO_ERROR) 
+	if (ConvertRecDate(&amp;(node-&gt;recordDate), &amp;time) == B_NO_ERROR)
 		st-&gt;st_ctime = st-&gt;st_mtime = st-&gt;st_atime = time;
 
 	TRACE((&quot;fs_read_stat - EXIT, result is %s\n&quot;, strerror(result)));
@@ -595,8 +595,8 @@
 	TRACE((&quot;fs_read_dir - EXIT, result is %s\n&quot;, strerror(result)));
 	return result;
 }
-			
 
+
 static status_t
 fs_rewind_dir(fs_volume *_vol, fs_vnode *_node, void* _cookie)
 {

Modified: haiku/trunk/src/system/kernel/cache/file_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/cache/file_cache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -211,7 +211,7 @@
 
 	// read file into reserved pages
 	status_t status = vfs_read_pages(ref-&gt;vnode, cookie, offset, vecs,
-		vecCount, &amp;numBytes, false);
+		vecCount, &amp;numBytes);
 	if (status &lt; B_OK) {
 		// reading failed, free allocated pages
 
@@ -294,7 +294,7 @@
 	vm_page_unreserve_pages(lastReservedPages);
 
 	status_t status = vfs_read_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-		&amp;vec, 1, &amp;bufferSize, false);
+		&amp;vec, 1, &amp;bufferSize);
 	if (status == B_OK)
 		reserve_pages(ref, reservePages, false);
 
@@ -361,7 +361,7 @@
 		size_t bytesRead = B_PAGE_SIZE;
 
 		status = vfs_read_pages(ref-&gt;vnode, cookie, offset, &amp;readVec, 1,
-			&amp;bytesRead, false);
+			&amp;bytesRead);
 		// ToDo: handle errors for real!
 		if (status &lt; B_OK)
 			panic(&quot;1. vfs_read_pages() failed: %s!\n&quot;, strerror(status));
@@ -385,7 +385,7 @@
 
 			status = vfs_read_pages(ref-&gt;vnode, cookie,
 				PAGE_ALIGN(offset + pageOffset + bufferSize) - B_PAGE_SIZE,
-				&amp;readVec, 1, &amp;bytesRead, false);
+				&amp;readVec, 1, &amp;bytesRead);
 			// ToDo: handle errors for real!
 			if (status &lt; B_OK)
 				panic(&quot;vfs_read_pages() failed: %s!\n&quot;, strerror(status));
@@ -420,7 +420,7 @@
 	if (writeThrough) {
 		// write cached pages back to the file if we were asked to do that
 		status_t status = vfs_write_pages(ref-&gt;vnode, cookie, offset, vecs,
-			vecCount, &amp;numBytes, false);
+			vecCount, &amp;numBytes);
 		if (status &lt; B_OK) {
 			// ToDo: remove allocated pages, ...?
 			panic(&quot;file_cache: remove allocated pages! write pages failed: %s\n&quot;,
@@ -491,7 +491,7 @@
 				chunkSize = bufferSize;
 
 			status = vfs_write_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-				&amp;vec, 1, &amp;chunkSize, false);
+				&amp;vec, 1, &amp;chunkSize);
 			if (status &lt; B_OK)
 				break;
 
@@ -502,7 +502,7 @@
 		free((void*)buffer);
 	} else {
 		status = vfs_write_pages(ref-&gt;vnode, cookie, offset + pageOffset,
-			&amp;vec, 1, &amp;bufferSize, false);
+			&amp;vec, 1, &amp;bufferSize);
 	}
 
 	if (status == B_OK)
@@ -958,7 +958,7 @@
 	if (ref == NULL)
 		return B_BAD_VALUE;
 
-	return ref-&gt;cache-&gt;WriteModified(false);
+	return ref-&gt;cache-&gt;WriteModified();
 }
 
 

Modified: haiku/trunk/src/system/kernel/cache/vnode_store.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -41,12 +41,12 @@
 
 status_t
 VMVnodeCache::Read(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	size_t bytesUntouched = *_numBytes;
 
 	status_t status = vfs_read_pages(fVnode, NULL, offset, vecs, count,
-		_numBytes, fsReenter);
+		_numBytes);
 
 	bytesUntouched -= *_numBytes;
 
@@ -73,10 +73,9 @@
 
 status_t
 VMVnodeCache::Write(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
-	return vfs_write_pages(fVnode, NULL, offset, vecs, count, _numBytes,
-		fsReenter);
+	return vfs_write_pages(fVnode, NULL, offset, vecs, count, _numBytes);
 }
 
 

Modified: haiku/trunk/src/system/kernel/cache/vnode_store.h
===================================================================
--- haiku/trunk/src/system/kernel/cache/vnode_store.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/cache/vnode_store.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -20,9 +20,9 @@
 	virtual	bool		HasPage(off_t offset);
 
 	virtual	status_t	Read(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 	virtual	status_t	Write(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 
 	virtual	status_t	Fault(struct vm_address_space *aspace, off_t offset);
 

Modified: haiku/trunk/src/system/kernel/device_manager/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -1593,7 +1593,7 @@
 
 static status_t
 devfs_read_pages(fs_volume *_volume, fs_vnode *_vnode, void *_cookie,
-	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	struct devfs_vnode *vnode = (devfs_vnode *)_vnode-&gt;private_node;
 	struct devfs_cookie *cookie = (struct devfs_cookie *)_cookie;
@@ -1651,7 +1651,7 @@
 
 static status_t
 devfs_write_pages(fs_volume* _volume, fs_vnode* _vnode, void* _cookie,
-	off_t pos, const iovec* vecs, size_t count, size_t* _numBytes, bool reenter)
+	off_t pos, const iovec* vecs, size_t count, size_t* _numBytes)
 {
 	struct devfs_vnode *vnode = (devfs_vnode *)_vnode-&gt;private_node;
 	struct devfs_cookie *cookie = (struct devfs_cookie *)_cookie;

Modified: haiku/trunk/src/system/kernel/fs/fifo.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/fifo.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/fs/fifo.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -319,7 +319,7 @@
 }
 
 
-status_t 
+status_t
 Inode::InitCheck()
 {
 	return B_OK;
@@ -920,7 +920,7 @@
 	Inode *inode = (Inode *)_node-&gt;private_node;
 	if (!inode)
 		return B_ERROR;
-	
+
 	MutexLocker locker(inode-&gt;RequestLock());
 	return inode-&gt;Deselect(event, sync, cookie-&gt;open_mode);
 }
@@ -935,7 +935,7 @@
 
 static status_t
 fifo_read_pages(fs_volume *_volume, fs_vnode *_v, void *cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }
@@ -943,7 +943,7 @@
 
 static status_t
 fifo_write_pages(fs_volume *_volume, fs_vnode *_v, void *cookie,
-	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }

Modified: haiku/trunk/src/system/kernel/fs/rootfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/rootfs.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/fs/rootfs.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -813,7 +813,7 @@
 
 static status_t
 rootfs_read_pages(fs_volume *_volume, fs_vnode *_v, void *cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }
@@ -821,7 +821,7 @@
 
 static status_t
 rootfs_write_pages(fs_volume *_volume, fs_vnode *_v, void *cookie, off_t pos,
-	const iovec *vecs, size_t count, size_t *_numBytes, bool reenter)
+	const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_NOT_ALLOWED;
 }

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -1056,7 +1056,7 @@
 		mutex_unlock(&amp;sVnodeMutex);
 
 		if (vnode-&gt;cache != NULL)
-			vnode-&gt;cache-&gt;WriteModified(false);
+			vnode-&gt;cache-&gt;WriteModified();
 
 		dec_vnode_ref_count(vnode, true, false);
 			// this should free the vnode when it's still unused
@@ -2912,7 +2912,7 @@
 			size = numBytes;
 
 		status = FS_CALL(vnode, read_pages, cookie, fileVecs[0].offset,
-			&amp;vecs[vecIndex], vecCount - vecIndex, &amp;size, false);
+			&amp;vecs[vecIndex], vecCount - vecIndex, &amp;size);
 		if (status &lt; B_OK)
 			return status;
 
@@ -3007,10 +3007,10 @@
 			size_t bytes = size;
 			if (doWrite) {
 				status = FS_CALL(vnode, write_pages, cookie, fileOffset,
-					tempVecs, tempCount, &amp;bytes, false);
+					tempVecs, tempCount, &amp;bytes);
 			} else {
 				status = FS_CALL(vnode, read_pages, cookie, fileOffset,
-					tempVecs, tempCount, &amp;bytes, false);
+					tempVecs, tempCount, &amp;bytes);
 			}
 			if (status &lt; B_OK)
 				return status;
@@ -3282,7 +3282,7 @@
 
 extern &quot;C&quot; status_t
 read_pages(int fd, off_t pos, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	struct file_descriptor *descriptor;
 	struct vnode *vnode;
@@ -3292,7 +3292,7 @@
 		return B_FILE_ERROR;
 
 	status_t status = FS_CALL(vnode, read_pages, descriptor-&gt;cookie, pos, vecs,
-		count, _numBytes, fsReenter);
+		count, _numBytes);
 
 	put_fd(descriptor);
 	return status;
@@ -3301,7 +3301,7 @@
 
 extern &quot;C&quot; status_t
 write_pages(int fd, off_t pos, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	struct file_descriptor *descriptor;
 	struct vnode *vnode;
@@ -3311,7 +3311,7 @@
 		return B_FILE_ERROR;
 
 	status_t status = FS_CALL(vnode, write_pages, descriptor-&gt;cookie, pos, vecs,
-		count, _numBytes, fsReenter);
+		count, _numBytes);
 
 	put_fd(descriptor);
 	return status;
@@ -3888,23 +3888,21 @@
 
 extern &quot;C&quot; status_t
 vfs_read_pages(struct vnode *vnode, void *cookie, off_t pos, const iovec *vecs,
-	size_t count, size_t *_numBytes, bool fsReenter)
+	size_t count, size_t *_numBytes)
 {
 	FUNCTION((&quot;vfs_read_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs, pos));
 
-	return FS_CALL(vnode, read_pages, cookie, pos, vecs, count, _numBytes,
-		fsReenter);
+	return FS_CALL(vnode, read_pages, cookie, pos, vecs, count, _numBytes);
 }
 
 
 extern &quot;C&quot; status_t
 vfs_write_pages(struct vnode *vnode, void *cookie, off_t pos, const iovec *vecs,
-	size_t count, size_t *_numBytes, bool fsReenter)
+	size_t count, size_t *_numBytes)
 {
 	FUNCTION((&quot;vfs_write_pages: vnode %p, vecs %p, pos %Ld\n&quot;, vnode, vecs, pos));
 
-	return FS_CALL(vnode, write_pages, cookie, pos, vecs, count, _numBytes,
-		fsReenter);
+	return FS_CALL(vnode, write_pages, cookie, pos, vecs, count, _numBytes);
 }
 
 
@@ -6712,7 +6710,7 @@
 				put_vnode(previousVnode);
 
 			if (vnode-&gt;cache != NULL)
-				vnode-&gt;cache-&gt;WriteModified(false);
+				vnode-&gt;cache-&gt;WriteModified();
 
 			// the next vnode might change until we lock the vnode list again,
 			// but this vnode won't go away since we keep a reference to it.

Modified: haiku/trunk/src/system/kernel/vm/VMAnonymousCache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMAnonymousCache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMAnonymousCache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -186,7 +186,7 @@
 
 status_t
 VMAnonymousCache::Read(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	off_t cacheOffset = offset &gt;&gt; PAGE_SHIFT;
 
@@ -207,7 +207,7 @@
 		off_t pos = (startPageIndex - swapFile-&gt;first_page) * PAGE_SIZE;
 
 		status_t status = vfs_read_pages(swapFile-&gt;vnode, NULL, pos, vecs + i,
-				j - i, _numBytes, fsReenter);
+				j - i, _numBytes);
 		if (status != B_OK)
 			return status;
 	}
@@ -218,7 +218,7 @@
 
 status_t
 VMAnonymousCache::Write(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	offset &gt;&gt;= PAGE_SHIFT;
 	uint32 n = count;
@@ -243,7 +243,7 @@
 		off_t pos = (pageIndex - swapFile-&gt;first_page) * PAGE_SIZE;
 
 		status_t status = vfs_write_pages(swapFile-&gt;vnode, NULL, pos, vecs + i ,
-				n, _numBytes, fsReenter);
+				n, _numBytes);
 		if (status != B_OK)
 			return status;
 	}

Modified: haiku/trunk/src/system/kernel/vm/VMAnonymousCache.h
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMAnonymousCache.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMAnonymousCache.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -26,9 +26,9 @@
 	virtual	bool		HasPage(off_t offset);
 
 	virtual	status_t	Read(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 	virtual	status_t	Write(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 
 	virtual	status_t	Fault(struct vm_address_space *aspace, off_t offset);
 

Modified: haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -96,7 +96,7 @@
 
 status_t
 VMAnonymousNoSwapCache::Read(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	panic(&quot;anonymous_store: read called. Invalid!\n&quot;);
 	return B_ERROR;
@@ -105,7 +105,7 @@
 
 status_t
 VMAnonymousNoSwapCache::Write(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	// no place to write, this will cause the page daemon to skip this store
 	return B_ERROR;

Modified: haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.h
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMAnonymousNoSwapCache.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -23,9 +23,9 @@
 	virtual	bool		HasPage(off_t offset);
 
 	virtual	status_t	Read(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 	virtual	status_t	Write(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 
 	virtual	status_t	Fault(struct vm_address_space *aspace, off_t offset);
 

Modified: haiku/trunk/src/system/kernel/vm/VMDeviceCache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMDeviceCache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMDeviceCache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -27,7 +27,7 @@
 
 status_t
 VMDeviceCache::Read(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	panic(&quot;device_store: read called. Invalid!\n&quot;);
 	return B_ERROR;
@@ -36,7 +36,7 @@
 
 status_t
 VMDeviceCache::Write(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+	size_t *_numBytes)
 {
 	// no place to write, this will cause the page daemon to skip this store
 	return B_OK;

Modified: haiku/trunk/src/system/kernel/vm/VMDeviceCache.h
===================================================================
--- haiku/trunk/src/system/kernel/vm/VMDeviceCache.h	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/VMDeviceCache.h	2008-07-23 15:47:47 UTC (rev 26579)
@@ -19,9 +19,9 @@
 	virtual	bool		HasPage(off_t offset);
 
 	virtual	status_t	Read(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 	virtual	status_t	Write(off_t offset, const iovec *vecs, size_t count,
-							size_t *_numBytes, bool fsReenter);
+							size_t *_numBytes);
 
 private:
 	addr_t	fBaseAddress;

Modified: haiku/trunk/src/system/kernel/vm/vm.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/vm.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/vm.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -2249,7 +2249,7 @@
 	vm_unmap_pages(area, area-&gt;base, area-&gt;size, !area-&gt;cache-&gt;temporary);
 
 	if (!area-&gt;cache-&gt;temporary)
-		area-&gt;cache-&gt;WriteModified(false);
+		area-&gt;cache-&gt;WriteModified();
 
 	arch_vm_unset_memory_type(area);
 	remove_area_from_address_space(addressSpace, area);
@@ -4195,8 +4195,7 @@
 			size_t bytesRead = vec.iov_len = B_PAGE_SIZE;
 
 			// read it in
-			status_t status = cache-&gt;Read(cacheOffset, &amp;vec, 1, &amp;bytesRead,
-				false);
+			status_t status = cache-&gt;Read(cacheOffset, &amp;vec, 1, &amp;bytesRead);
 
 			map-&gt;ops-&gt;put_physical_page((addr_t)vec.iov_base);
 
@@ -5759,7 +5758,7 @@
 			if (writeSync) {
 				// synchronous
 				error = vm_page_write_modified_page_range(cache, firstPage,
-					endPage, false);
+					endPage);
 				if (error != B_OK)
 					return error;
 			} else {

Modified: haiku/trunk/src/system/kernel/vm/vm_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/vm_cache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/vm_cache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -688,7 +688,7 @@
 
 
 status_t
-VMCache::WriteModified(bool fsReenter)
+VMCache::WriteModified()
 {
 	TRACE((&quot;VMCache::WriteModified(cache = %p)\n&quot;, this));
 
@@ -696,7 +696,7 @@
 		return B_OK;
 
 	Lock();
-	status_t status = vm_page_write_modified_pages(this, fsReenter);
+	status_t status = vm_page_write_modified_pages(this);
 	Unlock();
 
 	return status;
@@ -813,16 +813,14 @@
 
 
 status_t
-VMCache::Read(off_t offset, const iovec *vecs, size_t count, size_t *_numBytes,
-	bool fsReenter)
+VMCache::Read(off_t offset, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_ERROR;
 }
 
 
 status_t
-VMCache::Write(off_t offset, const iovec *vecs, size_t count,
-	size_t *_numBytes, bool fsReenter)
+VMCache::Write(off_t offset, const iovec *vecs, size_t count, size_t *_numBytes)
 {
 	return B_ERROR;
 }

Modified: haiku/trunk/src/system/kernel/vm/vm_page.cpp
===================================================================
--- haiku/trunk/src/system/kernel/vm/vm_page.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/system/kernel/vm/vm_page.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -844,7 +844,7 @@
 
 
 static status_t
-write_page(vm_page *page, bool fsReenter)
+write_page(vm_page *page)
 {
 	size_t length = B_PAGE_SIZE;
 	status_t status;
@@ -859,7 +859,7 @@
 	vecs-&gt;iov_len = B_PAGE_SIZE;
 
 	status = page-&gt;cache-&gt;Write((off_t)page-&gt;cache_offset &lt;&lt; PAGE_SHIFT,
-		vecs, 1, &amp;length, fsReenter);
+		vecs, 1, &amp;length);
 
 	vm_put_physical_page((addr_t)vecs[0].iov_base);
 #if 0
@@ -1035,7 +1035,7 @@
 		// TODO: put this as requests into the I/O scheduler
 		status_t writeStatus[kNumPages];
 		for (uint32 i = 0; i &lt; numPages; i++) {
-			writeStatus[i] = write_page(u.pages[i], false);
+			writeStatus[i] = write_page(u.pages[i]);
 		}
 
 		// mark pages depending on whether they could be written or not
@@ -1280,7 +1280,7 @@
 */
 status_t
 vm_page_write_modified_page_range(struct VMCache *cache, uint32 firstPage,
-	uint32 endPage, bool fsReenter)
+	uint32 endPage)
 {
 	// TODO: join adjacent pages into one vec list
 
@@ -1321,7 +1321,7 @@
 		vm_clear_map_flags(page, PAGE_MODIFIED);
 
 		cache-&gt;Unlock();
-		status_t status = write_page(page, fsReenter);
+		status_t status = write_page(page);
 		cache-&gt;Lock();
 
 		InterruptsSpinLocker locker(&amp;sPageLock);
@@ -1361,10 +1361,10 @@
 	Note that the cache lock is released in this function.
 */
 status_t
-vm_page_write_modified_pages(vm_cache *cache, bool fsReenter)
+vm_page_write_modified_pages(vm_cache *cache)
 {
 	return vm_page_write_modified_page_range(cache, 0,
-		(cache-&gt;virtual_end + B_PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT, fsReenter);
+		(cache-&gt;virtual_end + B_PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT);
 }
 
 

Modified: haiku/trunk/src/tools/fs_shell/file_cache.cpp
===================================================================
--- haiku/trunk/src/tools/fs_shell/file_cache.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/tools/fs_shell/file_cache.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -90,7 +90,7 @@
 	fssh_mutex_unlock(&amp;ref-&gt;lock);
 
 	fssh_status_t status = vfs_read_pages(ref-&gt;node, cookie,
-		offset + pageOffset, &amp;vec, 1, &amp;bufferSize, false);
+		offset + pageOffset, &amp;vec, 1, &amp;bufferSize);
 
 	fssh_mutex_lock(&amp;ref-&gt;lock);
 
@@ -109,7 +109,7 @@
 	fssh_mutex_unlock(&amp;ref-&gt;lock);
 
 	fssh_status_t status = vfs_write_pages(ref-&gt;node, cookie,
-		offset + pageOffset, &amp;vec, 1, &amp;bufferSize, false);
+		offset + pageOffset, &amp;vec, 1, &amp;bufferSize);
 
 	fssh_mutex_lock(&amp;ref-&gt;lock);
 

Modified: haiku/trunk/src/tools/fs_shell/vfs.cpp
===================================================================
--- haiku/trunk/src/tools/fs_shell/vfs.cpp	2008-07-23 15:45:40 UTC (rev 26578)
+++ haiku/trunk/src/tools/fs_shell/vfs.cpp	2008-07-23 15:47:47 UTC (rev 26579)
@@ -141,7 +141,7 @@
  *	- the fields immutable after initialization of the fs_mount structures in
  *	  sMountsTable will not be modified,
  *	- vnode::covered_by of any vnode in sVnodeTable will not be modified.
- *	
+ *
  *	The thread trying to lock the lock must not hold sVnodeMutex or
  *	sMountMutex.
  */
@@ -612,7 +612,7 @@
 	vnode-&gt;id = vnodeID;
 
 	// add the vnode to the mount structure
-	fssh_mutex_lock(&amp;sMountMutex);	

[... truncated: 399 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010498.html">[Haiku-commits] r26578 - in haiku/trunk: headers/private/kernel	src/system/kernel/vm
</A></li>
	<LI>Next message: <A HREF="010500.html">[Haiku-commits] r26580 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10499">[ date ]</a>
              <a href="thread.html#10499">[ thread ]</a>
              <a href="subject.html#10499">[ subject ]</a>
              <a href="author.html#10499">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
