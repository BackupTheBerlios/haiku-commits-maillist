<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29177 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29177%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tools/fs_shell&In-Reply-To=%3C200902092306.n19N6nIn005885%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014303.html">
   <LINK REL="Next"  HREF="014305.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29177 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell</H1>
    <B>mmlr at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29177%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tools/fs_shell&In-Reply-To=%3C200902092306.n19N6nIn005885%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29177 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell">mmlr at mail.berlios.de
       </A><BR>
    <I>Tue Feb 10 00:06:49 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014303.html">[Haiku-commits] r29176 - haiku/trunk/src/preferences/keymap
</A></li>
        <LI>Next message: <A HREF="014305.html">[Haiku-commits] r29178 - haiku/trunk/src/preferences/keymap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14304">[ date ]</a>
              <a href="thread.html#14304">[ thread ]</a>
              <a href="subject.html#14304">[ subject ]</a>
              <a href="author.html#14304">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmlr
Date: 2009-02-10 00:06:31 +0100 (Tue, 10 Feb 2009)
New Revision: 29177
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29177&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29177&amp;view=rev</A>

Added:
   haiku/trunk/src/system/kernel/fs/overlay.cpp
   haiku/trunk/src/system/kernel/fs/overlay.h
Modified:
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/fs/Jamfile
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp
   haiku/trunk/src/tools/fs_shell/vfs.cpp
Log:
* Add an additional argument to get_vnode() that gets the fs_vnode_ops of the
  node. That is needed for a layered filesystem to be able to construct a full
  fs_vnode out of a volume/inode pair.
* Adapt places where get_vnode is used. Sadly this is a C API and we can't just
  use a default NULL for that argument.
* Introduce a flag B_VNODE_WANTS_OVERLAY_SUB_NODE that can be returned in the
  flags field of a fs get_vnode call. A filesystem can use this flag to indicate
  that it doesn't support the full set of fs features (attributes, write support)
  and it'd like to have unsupported calls emulated by an overlay sub node.
* Add a perliminary overlay filesystem that emulates file attributes using files
  on a filesystem where attributes aren't supported. It does currently only
  support reading attributes/attribute directories though. All other calls are
  just passed through to the super filesystem.
* Adjust places where a HAS_FS_CALL() is taken as a guarantee that the operation
  is supported. For the overlay filesystem we may later return a B_UNSUPPORTED,
  so make sure that in that case proper fallback options are taken.
* Make the iso9660 filesystem request overlay sub nodes. This can be fine tuned
  later to only trigger where there are features on a CD that need emulation
  at all.

If you happened to know the attribute file format and location you could build
an iso with read-only attribute support now. Note that this won't be enough to
get a bootable iso-only image as the query and index support is yet missing.


Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2009-02-09 23:06:31 UTC (rev 29177)
@@ -43,6 +43,7 @@
 // flags for publish_vnode() and fs_volume_ops::get_vnode()
 #define B_VNODE_PUBLISH_REMOVED					0x01
 #define B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE	0x02
+#define B_VNODE_WANTS_OVERLAY_SUB_NODE			0x04
 
 
 #ifdef __cplusplus
@@ -307,7 +308,7 @@
 					void *privateNode, fs_vnode_ops *ops, int type,
 					uint32 flags);
 extern status_t get_vnode(fs_volume *volume, ino_t vnodeID,
-					void **_privateNode);
+					void **_privateNode, fs_vnode_ops **_vnodeOps);
 extern status_t put_vnode(fs_volume *volume, ino_t vnodeID);
 extern status_t acquire_vnode(fs_volume *volume, ino_t vnodeID);
 extern status_t remove_vnode(fs_volume *volume, ino_t vnodeID);

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2009-02-09 23:06:31 UTC (rev 29177)
@@ -344,7 +344,8 @@
 				fssh_vnode_id vnodeID, void *privateNode,
 				fssh_fs_vnode_ops *ops, int type, uint32_t flags);
 extern fssh_status_t fssh_get_vnode(fssh_fs_volume *volume,
-				fssh_vnode_id vnodeID, void **_privateNode);
+				fssh_vnode_id vnodeID, void **_privateNode,
+				fssh_fs_vnode_ops **_vnodeOps);
 extern fssh_status_t fssh_put_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID);
 extern fssh_status_t fssh_acquire_vnode(fssh_fs_volume *volume,

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -2701,7 +2701,7 @@
 	// if you haven't yet access to the attributes directory, get it
 	if (fAttributes == NULL) {
 		if (get_vnode(volume-&gt;FSVolume(), volume-&gt;ToVnode(fInode-&gt;Attributes()),
-				(void**)&amp;fAttributes) != B_OK) {
+				(void**)&amp;fAttributes, NULL) != B_OK) {
 			FATAL((&quot;get_vnode() failed in AttributeIterator::GetNext(ino_t&quot;
 				&quot; = %Ld,name = \&quot;%s\&quot;)\n&quot;, fInode-&gt;ID(), name));
 			return B_ENTRY_NOT_FOUND;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2009-02-09 23:06:31 UTC (rev 29177)
@@ -354,7 +354,8 @@
 	{
 		Unset();
 
-		return fStatus = get_vnode(volume-&gt;FSVolume(), id, (void**)&amp;fInode);
+		return fStatus = get_vnode(volume-&gt;FSVolume(), id, (void**)&amp;fInode,
+			NULL);
 	}
 
 	status_t SetTo(Volume* volume, block_run run)

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -556,7 +556,7 @@
 	locker.Unlock();
 
 	Inode* inode;
-	status = get_vnode(volume-&gt;FSVolume(), *_vnodeID, (void**)&amp;inode);
+	status = get_vnode(volume-&gt;FSVolume(), *_vnodeID, (void**)&amp;inode, NULL);
 	if (status != B_OK) {
 		REPORT_ERROR(status);
 		return B_ENTRY_NOT_FOUND;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -1493,7 +1493,7 @@
 	if (inode == NULL)
 		return B_ENTRY_NOT_FOUND;
 
-	status = get_vnode(volume-&gt;FSVolume(), inode-&gt;ID(), NULL);
+	status = get_vnode(volume-&gt;FSVolume(), inode-&gt;ID(), NULL, NULL);
 	if (status &lt; B_OK)
 		return status;
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -310,7 +310,7 @@
 	if ((fBlockCache = opener.InitCache(NumBlocks(), fBlockSize)) == NULL)
 		return B_ERROR;
 
-	status = get_vnode(fFSVolume, EXT2_ROOT_NODE, (void**)&amp;fRootNode);
+	status = get_vnode(fFSVolume, EXT2_ROOT_NODE, (void**)&amp;fRootNode, NULL);
 	if (status != B_OK) {
 		TRACE(&quot;could not create root node: get_vnode() failed!\n&quot;);
 		return status;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -319,7 +319,7 @@
 			break;
 	}
 
-	return get_vnode(volume-&gt;FSVolume(), *_vnodeID, NULL);
+	return get_vnode(volume-&gt;FSVolume(), *_vnodeID, NULL, NULL);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2009-02-09 23:06:31 UTC (rev 29177)
@@ -433,7 +433,7 @@
 		if (vnid)
 			*vnid = found_vnid;
 		if (node)
-			result = get_vnode(vol-&gt;volume, found_vnid, (void **)node);
+			result = get_vnode(vol-&gt;volume, found_vnid, (void **)node, NULL);
 		result = B_OK;
 	} else {
 		result = ENOENT;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2009-02-09 23:06:31 UTC (rev 29177)
@@ -890,7 +890,7 @@
 		*vnid = dummy.vnid;
 		dummy.magic = ~VNODE_MAGIC;
 
-		result = get_vnode(_vol, *vnid, (void **)&amp;file);
+		result = get_vnode(_vol, *vnid, (void **)&amp;file, NULL);
 		if (result &lt; B_OK) {
 			if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)
 				_dosfs_sync(vol);
@@ -1155,7 +1155,7 @@
 			if (vnid == vol-&gt;root_vnode.vnid)
 				break;
 
-			result = get_vnode(_vol, vnid, (void **)&amp;dir);
+			result = get_vnode(_vol, vnid, (void **)&amp;dir, NULL);
 			if (result &lt; B_OK)
 				goto bi1;
 			parent = dir-&gt;dir_vnid;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -224,12 +224,12 @@
 		// base directory
 		TRACE((&quot;fs_walk - found \&quot;.\&quot; file.\n&quot;));
 		*_vnodeID = baseNode-&gt;id;
-		return get_vnode(_vol, *_vnodeID, (void **)&amp;newNode);
+		return get_vnode(_vol, *_vnodeID, NULL, NULL);
 	} else if (strcmp(file, &quot;..&quot;) == 0) {
 		// parent directory
 		TRACE((&quot;fs_walk - found \&quot;..\&quot; file.\n&quot;));
 		*_vnodeID = baseNode-&gt;parID;
-		return get_vnode(_vol, *_vnodeID, (void **)&amp;newNode);
+		return get_vnode(_vol, *_vnodeID, NULL, NULL);
 	}
 
 	// look up file in the directory
@@ -272,7 +272,7 @@
 						TRACE((&quot;fs_walk - New vnode id is %Ld\n&quot;, *_vnodeID));
 
 						result = get_vnode(_vol, *_vnodeID,
-							(void **)&amp;newNode);
+							(void **)&amp;newNode, NULL);
 						if (result == B_OK) {
 							newNode-&gt;parID = baseNode-&gt;id;
 							done = true;
@@ -349,7 +349,7 @@
 	_node-&gt;private_node = newNode;
 	_node-&gt;ops = &amp;gISO9660VnodeOps;
 	*_type = newNode-&gt;attr.stat[FS_DATA_FORMAT].st_mode &amp; ~(S_IWUSR | S_IWGRP | S_IWOTH);
-	*_flags = 0;
+	*_flags = B_VNODE_WANTS_OVERLAY_SUB_NODE;
 
 	if ((newNode-&gt;flags &amp; ISO_ISDIR) == 0) {
 		newNode-&gt;cache = file_cache_create(ns-&gt;id, vnodeID,

Modified: haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c	2009-02-09 23:06:31 UTC (rev 29177)
@@ -898,7 +898,7 @@
 		isLink=S_ISLNK(st.st_mode);
 	}
 
-	if ((result=get_vnode (_volume,*vnid,(void **)&amp;dummy))&lt;B_OK)
+	if ((result=get_vnode (_volume,*vnid,(void **)&amp;dummy,NULL))&lt;B_OK)
 		return result;
 
 	return B_OK;
@@ -1755,7 +1755,7 @@
 
 		*vnid=st.st_ino;
 
-		if ((result=get_vnode(_volume,*vnid,&amp;dummy))&lt;B_OK)
+		if ((result=get_vnode(_volume,*vnid,&amp;dummy,NULL))&lt;B_OK)
 			return result;
 
 		if (S_ISDIR(st.st_mode))
@@ -1901,7 +1901,7 @@
 
 	insert_node (ns,newNode);
 
-	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy))&lt;B_OK)
+	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy,NULL))&lt;B_OK)
 	{
 		XDRInPacketDestroy (&amp;reply);
 		XDROutPacketDestroy (&amp;call);
@@ -2195,7 +2195,7 @@
 
 	insert_node (ns,newNode);
 
-	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy))&lt;B_OK)
+	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy,NULL))&lt;B_OK)
 	{
 		XDRInPacketDestroy(&amp;reply);
 		XDROutPacketDestroy(&amp;call);
@@ -2341,7 +2341,7 @@
 	if (result==B_OK)
 	{
 		void *dummy;
-		if ((result=get_vnode(_volume,st.st_ino,&amp;dummy))&lt;B_OK)
+		if ((result=get_vnode(_volume,st.st_ino,&amp;dummy,NULL))&lt;B_OK)
 			return result;
 
 		XDRInPacketDestroy (&amp;reply);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -294,7 +294,7 @@
 status_t
 Volume::GetVNode(ino_t id, VNode **node)
 {
-	return get_vnode(GetFSVolume(), id, (void**)node);
+	return get_vnode(GetFSVolume(), id, (void**)node, NULL);
 }
 
 // PutVNode

Modified: haiku/trunk/src/system/kernel/device_manager/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -407,7 +407,8 @@
 
 	// increase reference count of raw device -
 	// the partition device really needs it
-	status = get_vnode(fs-&gt;volume, device-&gt;id, (void**)&amp;partition-&gt;raw_device);
+	status = get_vnode(fs-&gt;volume, device-&gt;id, (void**)&amp;partition-&gt;raw_device,
+		NULL);
 	if (status &lt; B_OK)
 		goto err1;
 
@@ -937,7 +938,7 @@
 {
 	struct devfs *fs = (struct devfs *)_volume-&gt;private_volume;
 	struct devfs_vnode *dir = (struct devfs_vnode *)_dir-&gt;private_node;
-	struct devfs_vnode *vnode, *vdummy;
+	struct devfs_vnode *vnode;
 	status_t status;
 
 	TRACE((&quot;devfs_lookup: entry dir %p, name '%s'\n&quot;, dir, name));
@@ -958,7 +959,7 @@
 		return B_ENTRY_NOT_FOUND;
 	}
 
-	status = get_vnode(fs-&gt;volume, vnode-&gt;id, (void**)&amp;vdummy);
+	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL);
 	if (status &lt; B_OK)
 		return status;
 
@@ -1062,7 +1063,7 @@
 	if (openMode &amp; O_EXCL)
 		return B_FILE_EXISTS;
 
-	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL);
+	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL);
 	if (status &lt; B_OK)
 		return status;
 
@@ -2091,7 +2092,7 @@
 {
 	devfs_vnode* node;
 	status_t status = get_vnode(sDeviceFileSystem-&gt;volume, device-&gt;ID(),
-		(void**)&amp;node);
+		(void**)&amp;node, NULL);
 	if (status != B_OK)
 		return status;
 

Modified: haiku/trunk/src/system/kernel/fs/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/fs/Jamfile	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/system/kernel/fs/Jamfile	2009-02-09 23:06:31 UTC (rev 29177)
@@ -12,6 +12,7 @@
 	fifo.cpp
 	KPath.cpp
 	node_monitor.cpp
+	overlay.cpp
 	rootfs.cpp
 	socket.cpp
 	vfs.cpp

Added: haiku/trunk/src/system/kernel/fs/overlay.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/overlay.cpp	2009-02-09 22:33:01 UTC (rev 29176)
+++ haiku/trunk/src/system/kernel/fs/overlay.cpp	2009-02-09 23:06:31 UTC (rev 29177)
@@ -0,0 +1,1097 @@
+/*
+ * Copyright 2009, Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Michael Lotz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">mmlr at mlotz.ch</A>&gt;
+ */
+
+#include &lt;new&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;dirent.h&gt;
+
+#include &lt;debug.h&gt;
+#include &lt;KernelExport.h&gt;
+#include &lt;NodeMonitor.h&gt;
+
+#include &quot;overlay.h&quot;
+
+
+//#define TRACE_OVERLAY
+#ifdef TRACE_OVERLAY
+#define TRACE(x...)			dprintf(&quot;overlay: &quot; x)
+#define TRACE_ALWAYS(x...)	dprintf(&quot;overlay: &quot; x)
+#else
+#define TRACE(x...)			/* nothing */
+#define TRACE_ALWAYS(x...)	dprintf(&quot;overlay: &quot; x)
+#endif
+
+
+namespace overlay {
+
+class AttributeFile;
+class AttributeEntry;
+
+
+class OverlayInode {
+public:
+							OverlayInode(fs_volume *superVolume,
+								fs_vnode *superVnode);
+							~OverlayInode();
+
+		status_t			InitCheck();
+
+		fs_vnode *			SuperVnode() { return &fSuperVnode; }
+
+		AttributeFile *		GetAttributeFile();
+
+private:
+		fs_volume			fSuperVolume;
+		fs_vnode			fSuperVnode;
+		AttributeFile *		fAttributeFile;
+};
+
+
+class AttributeFile {
+public:
+							AttributeFile(fs_volume *volume, fs_vnode *vnode);
+							~AttributeFile();
+
+		status_t			InitCheck() { return fStatus; }
+
+		dev_t				VolumeID() { return fVolumeID; }
+		ino_t				ParentInode() { return fParentInode; }
+
+		uint32				CountAttributes();
+		AttributeEntry *	FindAttribute(const char *name);
+
+		status_t			ReadAttributeDir(struct dirent *dirent,
+								size_t bufferSize, uint32 *numEntries);
+		status_t			RewindAttributeDir()
+							{
+								fAttributeDirIndex = 0;
+								return B_OK;
+							}
+
+private:
+		#define ATTRIBUTE_OVERLAY_FILE_MAGIC			'attr'
+		#define ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME	&quot;_HAIKU&quot;
+
+		struct attribute_file {
+			uint32			magic; // 'attr'
+			uint32			entry_count;
+			uint8			entries[1];
+		} _PACKED;
+
+		status_t			fStatus;
+		dev_t				fVolumeID;
+		ino_t				fParentInode;
+		attribute_file *	fFile;
+		uint32				fAttributeDirIndex;
+		AttributeEntry **	fEntries;
+};
+
+
+class AttributeEntry {
+public:
+							AttributeEntry(AttributeFile *parent,
+								uint8 *buffer);
+							~AttributeEntry();
+
+		size_t				EntrySize();
+
+		uint8				NameLength() { return fEntry-&gt;name_length; }
+		const char *		Name() { return fEntry-&gt;name; }
+
+		status_t			FillDirent(struct dirent *dirent,
+								size_t bufferSize, uint32 *numEntries);
+
+		status_t			Read(off_t position, void *buffer, size_t *length);
+		status_t			ReadStat(struct stat *stat);
+
+private:
+		struct attribute_entry {
+			type_code		type;
+			uint32			size;
+			uint8			name_length; // including 0 byte
+			char			name[1]; // 0 terminated, followed by data
+		} _PACKED;
+
+		AttributeFile *		fParent;
+		attribute_entry *	fEntry;
+		uint8 *				fData;
+};
+
+
+//	#pragma mark OverlayInode
+
+
+OverlayInode::OverlayInode(fs_volume *superVolume, fs_vnode *superVnode)
+	:	fSuperVolume(*superVolume),
+		fSuperVnode(*superVnode),
+		fAttributeFile(NULL)
+{
+	TRACE(&quot;inode created\n&quot;);
+}
+
+
+OverlayInode::~OverlayInode()
+{
+	TRACE(&quot;inode destroyed\n&quot;);
+	delete fAttributeFile;
+}
+
+
+status_t
+OverlayInode::InitCheck()
+{
+	return B_OK;
+}
+
+
+AttributeFile *
+OverlayInode::GetAttributeFile()
+{
+	if (fAttributeFile == NULL) {
+		fAttributeFile = new(std::nothrow) AttributeFile(&amp;fSuperVolume,
+			&amp;fSuperVnode);
+		if (fAttributeFile == NULL) {
+			TRACE_ALWAYS(&quot;no memory to allocate attribute file\n&quot;);
+			return NULL;
+		}
+	}
+
+	if (fAttributeFile-&gt;InitCheck() != B_OK)
+		return NULL;
+
+	return fAttributeFile;
+}
+
+
+//	#pragma mark AttributeFile
+
+
+AttributeFile::AttributeFile(fs_volume *volume, fs_vnode *vnode)
+	:	fStatus(B_NO_INIT),
+		fVolumeID(volume-&gt;id),
+		fParentInode(0),
+		fFile(NULL),
+		fAttributeDirIndex(0),
+		fEntries(NULL)
+{
+	if (vnode-&gt;ops-&gt;get_vnode_name == NULL) {
+		TRACE_ALWAYS(&quot;cannot get vnode name, hook missing\n&quot;);
+		fStatus = B_UNSUPPORTED;
+		return;
+	}
+
+	char nameBuffer[B_FILE_NAME_LENGTH];
+	nameBuffer[sizeof(nameBuffer) - 1] = 0;
+	fStatus = vnode-&gt;ops-&gt;get_vnode_name(volume, vnode, nameBuffer,
+		sizeof(nameBuffer) - 1);
+	if (fStatus != B_OK) {
+		TRACE_ALWAYS(&quot;failed to get vnode name: %s\n&quot;, strerror(fStatus));
+		return;
+	}
+
+	if (strcmp(nameBuffer, ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME) == 0) {
+		// we don't want attribute overlays on the attribute dir itself
+		fStatus = B_UNSUPPORTED;
+		return;
+	}
+
+	struct stat stat;
+	if (vnode-&gt;ops-&gt;read_stat != NULL
+		&amp;&amp; vnode-&gt;ops-&gt;read_stat(volume, vnode, &amp;stat) == B_OK) {
+		fParentInode = stat.st_ino;
+	}
+
+	// TODO: the &quot;..&quot; lookup is not actually valid for non-directory vnodes.
+	// we make use of the fact that a filesystem probably still provides the
+	// lookup hook and has hardcoded &quot;..&quot; to resolve to the parent entry. if we
+	// wanted to do this correctly we need some other way to relate this vnode
+	// to its parent directory vnode.
+	const char *lookup[]
+		= { &quot;..&quot;, ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME, nameBuffer };
+	int32 lookupCount = sizeof(lookup) / sizeof(lookup[0]);
+	fs_vnode currentVnode = *vnode;
+	ino_t lastInodeNumber = 0;
+
+	for (int32 i = 0; i &lt; lookupCount; i++) {
+		if (currentVnode.ops-&gt;lookup == NULL) {
+			TRACE_ALWAYS(&quot;lookup not possible, lookup hook missing\n&quot;);
+			fStatus = B_UNSUPPORTED;
+			if (i &gt; 0)
+				put_vnode(volume, lastInodeNumber);
+			return;
+		}
+
+		ino_t inodeNumber;
+		fStatus = currentVnode.ops-&gt;lookup(volume, &amp;currentVnode, lookup[i],
+			&amp;inodeNumber);
+
+		if (i &gt; 0)
+			put_vnode(volume, lastInodeNumber);
+
+		if (fStatus != B_OK) {
+			if (fStatus != B_ENTRY_NOT_FOUND) {
+				TRACE_ALWAYS(&quot;lookup of \&quot;%s\&quot; failed: %s\n&quot;, lookup[i],
+					strerror(fStatus));
+			}
+			return;
+		}
+
+		fStatus = get_vnode(volume, inodeNumber, &amp;currentVnode.private_node,
+			&amp;currentVnode.ops);
+		if (fStatus != B_OK) {
+			TRACE_ALWAYS(&quot;getting vnode failed: %s\n&quot;, strerror(fStatus));
+			return;
+		}
+
+		lastInodeNumber = inodeNumber;
+	}
+
+	if (currentVnode.ops-&gt;read_stat == NULL || currentVnode.ops-&gt;open == NULL
+		|| currentVnode.ops-&gt;read == NULL) {
+		TRACE_ALWAYS(&quot;can't use attribute file, hooks missing\n&quot;);
+		put_vnode(volume, lastInodeNumber);
+		fStatus = B_UNSUPPORTED;
+		return;
+	}
+
+	fStatus = currentVnode.ops-&gt;read_stat(volume, &amp;currentVnode, &amp;stat);
+	if (fStatus != B_OK) {
+		TRACE_ALWAYS(&quot;failed to stat attribute file: %s\n&quot;, strerror(fStatus));
+		put_vnode(volume, lastInodeNumber);
+		return;
+	}
+
+	void *attrFileCookie = NULL;
+	fStatus = currentVnode.ops-&gt;open(volume, &amp;currentVnode, O_RDONLY,
+		&amp;attrFileCookie);
+	if (fStatus != B_OK) {
+		TRACE_ALWAYS(&quot;failed to open attribute file: %s\n&quot;, strerror(fStatus));
+		put_vnode(volume, lastInodeNumber);
+		return;
+	}
+
+	size_t readLength = stat.st_size;
+	uint8 *buffer = (uint8 *)malloc(readLength);
+	if (buffer == NULL) {
+		TRACE_ALWAYS(&quot;cannot allocate memory for read buffer\n&quot;);
+		put_vnode(volume, lastInodeNumber);
+		fStatus = B_NO_MEMORY;
+		return;
+	}
+
+	fStatus = currentVnode.ops-&gt;read(volume, &amp;currentVnode, attrFileCookie, 0,
+		buffer, &amp;readLength);
+	if (fStatus != B_OK) {
+		TRACE_ALWAYS(&quot;failed to read from file: %s\n&quot;, strerror(fStatus));
+		put_vnode(volume, lastInodeNumber);
+		return;
+	}
+
+	if (currentVnode.ops-&gt;close != NULL)
+		currentVnode.ops-&gt;close(volume, &amp;currentVnode, attrFileCookie);
+	if (currentVnode.ops-&gt;free_cookie != NULL)
+		currentVnode.ops-&gt;free_cookie(volume, &amp;currentVnode, attrFileCookie);
+
+	put_vnode(volume, lastInodeNumber);
+
+	fFile = (attribute_file *)buffer;
+	if (fFile-&gt;magic != ATTRIBUTE_OVERLAY_FILE_MAGIC) {
+		TRACE_ALWAYS(&quot;attribute file has bad magic\n&quot;);
+		fStatus = B_BAD_VALUE;
+		return;
+	}
+
+	fEntries = new(std::nothrow) AttributeEntry *[fFile-&gt;entry_count];
+	if (fEntries == NULL) {
+		TRACE_ALWAYS(&quot;no memory to allocate entry pointers\n&quot;);
+		fStatus = B_NO_MEMORY;
+		return;
+	}
+
+	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++)
+		fEntries[i] = NULL;
+
+	size_t totalSize = 0;
+	readLength -= sizeof(attribute_file) - 1;
+	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++) {
+		fEntries[i] = new(std::nothrow) AttributeEntry(this,
+			fFile-&gt;entries + totalSize);
+		if (fEntries[i] == NULL) {
+			TRACE_ALWAYS(&quot;no memory to allocate attribute entry\n&quot;);
+			fStatus = B_NO_MEMORY;
+			return;
+		}
+
+		totalSize += fEntries[i]-&gt;EntrySize();
+		if (totalSize &gt; readLength) {
+			TRACE_ALWAYS(&quot;attribute entries are too large for buffer\n&quot;);
+			fStatus = B_BAD_VALUE;
+			return;
+		}
+	}
+}
+
+
+AttributeFile::~AttributeFile()
+{
+	if (fFile == NULL)
+		return;
+
+	if (fEntries != NULL) {
+		for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++)
+			delete fEntries[i];
+
+		delete [] fEntries;
+	}
+
+	free(fFile);
+}
+
+
+uint32
+AttributeFile::CountAttributes()
+{
+	if (fFile == NULL)
+		return 0;
+
+	return fFile-&gt;entry_count;
+}
+
+
+AttributeEntry *
+AttributeFile::FindAttribute(const char *name)
+{
+	if (fFile == NULL)
+		return NULL;
+
+	for (uint32 i = 0; i &lt; fFile-&gt;entry_count; i++) {
+		if (strncmp(fEntries[i]-&gt;Name(), name, fEntries[i]-&gt;NameLength()) == 0)
+			return fEntries[i];
+	}
+
+	return NULL;
+}
+
+
+status_t
+AttributeFile::ReadAttributeDir(struct dirent *dirent, size_t bufferSize,
+	uint32 *numEntries)
+{
+	if (fFile == NULL || fAttributeDirIndex &gt;= fFile-&gt;entry_count) {
+		*numEntries = 0;
+		return B_OK;
+	}
+
+	return fEntries[fAttributeDirIndex++]-&gt;FillDirent(dirent, bufferSize,
+		numEntries);
+}
+
+
+//	#pragma mark AttributeEntry
+
+
+AttributeEntry::AttributeEntry(AttributeFile *parent, uint8 *buffer)
+	:	fParent(parent),
+		fEntry(NULL),
+		fData(NULL)
+{
+	fEntry = (attribute_entry *)buffer;
+	fData = (uint8 *)fEntry-&gt;name + fEntry-&gt;name_length;
+}
+
+
+AttributeEntry::~AttributeEntry()
+{
+}
+
+
+size_t
+AttributeEntry::EntrySize()
+{
+	return sizeof(attribute_entry) - 1 + fEntry-&gt;name_length + fEntry-&gt;size;
+}
+
+
+status_t
+AttributeEntry::FillDirent(struct dirent *dirent, size_t bufferSize,
+	uint32 *numEntries)
+{
+	dirent-&gt;d_dev = dirent-&gt;d_pdev = fParent-&gt;VolumeID();
+	dirent-&gt;d_ino = (ino_t)this;
+	dirent-&gt;d_pino = fParent-&gt;ParentInode();
+	dirent-&gt;d_reclen = sizeof(struct dirent) + fEntry-&gt;name_length;
+	if (bufferSize &lt; dirent-&gt;d_reclen) {
+		*numEntries = 0;
+		return B_BAD_VALUE;
+	}
+
+	strncpy(dirent-&gt;d_name, fEntry-&gt;name, fEntry-&gt;name_length);
+	dirent-&gt;d_name[fEntry-&gt;name_length - 1] = 0;
+	*numEntries = 1;
+	return B_OK;
+}
+
+
+status_t
+AttributeEntry::Read(off_t position, void *buffer, size_t *length)
+{
+	*length = min_c(*length, fEntry-&gt;size);
+	if (*length &lt;= position) {
+		*length = 0;
+		return B_OK;
+	}
+
+	*length -= position;
+	memcpy(buffer, fData + position, *length);
+	return B_OK;
+}
+
+
+status_t
+AttributeEntry::ReadStat(struct stat *stat)
+{
+	stat-&gt;st_dev = fParent-&gt;VolumeID();
+	stat-&gt;st_ino = (ino_t)this;
+	stat-&gt;st_nlink = 1;
+	stat-&gt;st_blksize = 512;
+	stat-&gt;st_uid = 1;
+	stat-&gt;st_gid = 1;
+	stat-&gt;st_size = fEntry-&gt;size;
+	stat-&gt;st_mode = S_ATTR | 0x0777;
+	stat-&gt;st_type = fEntry-&gt;type;
+	stat-&gt;st_atime = stat-&gt;st_mtime = stat-&gt;st_crtime = time(NULL);
+	stat-&gt;st_blocks = (fEntry-&gt;size + stat-&gt;st_blksize - 1) / stat-&gt;st_blksize;
+	return B_OK;
+}
+
+
+//	#pragma mark -
+
+
+static status_t
+overlay_put_vnode(fs_volume *volume, fs_vnode *vnode, bool reenter)
+{
+	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;
+	fs_vnode *superVnode = node-&gt;SuperVnode();
+
+	status_t result = B_OK;
+	if (superVnode-&gt;ops-&gt;put_vnode != NULL)
+		result = superVnode-&gt;ops-&gt;put_vnode(volume, superVnode, reenter);
+
+	delete node;
+	return result;
+}
+
+
+static status_t
+overlay_remove_vnode(fs_volume *volume, fs_vnode *vnode, bool reenter)
+{
+	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;
+	fs_vnode *superVnode = node-&gt;SuperVnode();
+
+	status_t result = B_OK;
+	if (superVnode-&gt;ops-&gt;remove_vnode != NULL)
+		result = superVnode-&gt;ops-&gt;remove_vnode(volume, superVnode, reenter);
+
+	delete node;
+	return result;
+}
+
+
+static status_t
+overlay_get_super_vnode(fs_volume *volume, fs_vnode *vnode,
+	fs_volume *superVolume, fs_vnode *_superVnode)
+{
+	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;
+	fs_vnode *superVnode = node-&gt;SuperVnode();
+
+	if (superVnode-&gt;ops-&gt;get_super_vnode != NULL) {
+		return superVnode-&gt;ops-&gt;get_super_vnode(volume, superVnode, superVolume,
+			_superVnode);
+	}
+
+	*_superVnode = *superVnode;
+	return B_OK;
+}
+
+
+//	#pragma mark -
+
+
+#define OVERLAY_CALL(op, params...) \
+	TRACE(&quot;relaying op: &quot; #op &quot;\n&quot;); \
+	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node; \
+	fs_vnode *superVnode = node-&gt;SuperVnode(); \
+	if (superVnode-&gt;ops-&gt;op != NULL) \
+		return superVnode-&gt;ops-&gt;op(volume, superVnode, params);
+
+
+static status_t
+overlay_lookup(fs_volume *volume, fs_vnode *vnode, const char *name, ino_t *id)
+{
+	OVERLAY_CALL(lookup, name, id)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_get_vnode_name(fs_volume *volume, fs_vnode *vnode, char *buffer,
+	size_t bufferSize)
+{
+	OVERLAY_CALL(get_vnode_name, buffer, bufferSize)
+	return B_UNSUPPORTED;
+}
+
+
+static bool
+overlay_can_page(fs_volume *volume, fs_vnode *vnode, void *cookie)
+{
+	OVERLAY_CALL(can_page, cookie)
+	return false;
+}
+
+
+static status_t
+overlay_read_pages(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,
+	const iovec *vecs, size_t count, size_t *numBytes)
+{
+	OVERLAY_CALL(read_pages, cookie, pos, vecs, count, numBytes)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_write_pages(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos,
+	const iovec *vecs, size_t count, size_t *numBytes)
+{
+	OVERLAY_CALL(write_pages, cookie, pos, vecs, count, numBytes)
+	return B_UNSUPPORTED;
+}
+
+
+#if 0
+static status_t
+overlay_io(fs_volume *volume, fs_vnode *vnode, void *cookie,
+	io_request *request)
+{
+	OVERLAY_CALL(io, cookie, request)
+	return B_UNSUPPORTED;
+}
+#endif
+
+
+static status_t
+overlay_cancel_io(fs_volume *volume, fs_vnode *vnode, void *cookie,
+	io_request *request)
+{
+	OVERLAY_CALL(cancel_io, cookie, request)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_get_file_map(fs_volume *volume, fs_vnode *vnode, off_t offset,
+	size_t size, struct file_io_vec *vecs, size_t *count)
+{
+	OVERLAY_CALL(get_file_map, offset, size, vecs, count)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_ioctl(fs_volume *volume, fs_vnode *vnode, void *cookie, ulong op,
+	void *buffer, size_t length)
+{
+	OVERLAY_CALL(ioctl, cookie, op, buffer, length)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_set_flags(fs_volume *volume, fs_vnode *vnode, void *cookie,
+	int flags)
+{
+	OVERLAY_CALL(set_flags, cookie, flags)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_select(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event,
+	selectsync *sync)
+{
+	OVERLAY_CALL(select, cookie, event, sync)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_deselect(fs_volume *volume, fs_vnode *vnode, void *cookie, uint8 event,
+	selectsync *sync)
+{
+	OVERLAY_CALL(deselect, cookie, event, sync)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_fsync(fs_volume *volume, fs_vnode *vnode)
+{
+	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;
+	fs_vnode *superVnode = node-&gt;SuperVnode();
+
+	if (superVnode-&gt;ops-&gt;fsync != NULL)
+		return superVnode-&gt;ops-&gt;fsync(volume, superVnode);
+
+	return B_OK;
+}
+
+
+static status_t
+overlay_read_symlink(fs_volume *volume, fs_vnode *vnode, char *buffer,
+	size_t *bufferSize)
+{
+	OVERLAY_CALL(read_symlink, buffer, bufferSize)
+	return B_UNSUPPORTED;
+}
+
+
+static status_t
+overlay_create_symlink(fs_volume *volume, fs_vnode *vnode, const char *name,
+	const char *path, int mode)
+{
+	OVERLAY_CALL(create_symlink, name, path, mode)

[... truncated: 636 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014303.html">[Haiku-commits] r29176 - haiku/trunk/src/preferences/keymap
</A></li>
	<LI>Next message: <A HREF="014305.html">[Haiku-commits] r29178 - haiku/trunk/src/preferences/keymap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14304">[ date ]</a>
              <a href="thread.html#14304">[ thread ]</a>
              <a href="subject.html#14304">[ subject ]</a>
              <a href="author.html#14304">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
