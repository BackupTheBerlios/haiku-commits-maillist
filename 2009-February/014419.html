<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29250 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/overlay	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29250%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/overlay%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tools/fs_shell&In-Reply-To=%3C200902191813.n1JIDJCA023012%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014437.html">
   <LINK REL="Next"  HREF="014422.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29250 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/overlay	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell</H1>
    <B>mmlr at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29250%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/file_systems/cdda%0A%09src/add-ons/kernel/file_systems/ext2%0A%09src/add-ons/kernel/file_systems/fat%0A%09src/add-ons/kernel/file_systems/iso9660%0A%09src/add-ons/kernel/file_systems/nfs%0A%09src/add-ons/kernel/file_systems/overlay%0A%09src/add-ons/kernel/file_systems/reiserfs%0A%09src/system/kernel/device_manager%20src/system/kernel/fs%0A%09src/tools/fs_shell&In-Reply-To=%3C200902191813.n1JIDJCA023012%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29250 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/file_systems/cdda	src/add-ons/kernel/file_systems/ext2	src/add-ons/kernel/file_systems/fat	src/add-ons/kernel/file_systems/iso9660	src/add-ons/kernel/file_systems/nfs	src/add-ons/kernel/file_systems/overlay	src/add-ons/kernel/file_systems/reiserfs	src/system/kernel/device_manager src/system/kernel/fs	src/tools/fs_shell">mmlr at mail.berlios.de
       </A><BR>
    <I>Thu Feb 19 19:13:19 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014437.html">[Haiku-commits] r29249 - haiku/trunk/src/add-ons/kernel/file_systems/overlay
</A></li>
        <LI>Next message: <A HREF="014422.html">[Haiku-commits] r29251 -	haiku/trunk/src/add-ons/kernel/file_systems/overlay
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14419">[ date ]</a>
              <a href="thread.html#14419">[ thread ]</a>
              <a href="subject.html#14419">[ subject ]</a>
              <a href="author.html#14419">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmlr
Date: 2009-02-19 19:13:01 +0100 (Thu, 19 Feb 2009)
New Revision: 29250
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29250&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29250&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
   haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c
   haiku/trunk/src/add-ons/kernel/file_systems/overlay/overlay.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/tools/fs_shell/vfs.cpp
Log:
Remove the additional fs_vnode_ops arugment from get_vnode() again as it's not
needed at all when used as intended. Thanks Ingo for the explanation on how this
is intended to work. Adjusted the overlay fs accordingly and updated/reverted
the changes to the other filesystems.


Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2009-02-19 18:13:01 UTC (rev 29250)
@@ -310,7 +310,7 @@
 					void *privateNode, fs_vnode_ops *ops, int type,
 					uint32 flags);
 extern status_t get_vnode(fs_volume *volume, ino_t vnodeID,
-					void **_privateNode, fs_vnode_ops **_vnodeOps);
+					void **_privateNode);
 extern status_t put_vnode(fs_volume *volume, ino_t vnodeID);
 extern status_t acquire_vnode(fs_volume *volume, ino_t vnodeID);
 extern status_t remove_vnode(fs_volume *volume, ino_t vnodeID);

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2009-02-19 18:13:01 UTC (rev 29250)
@@ -344,8 +344,7 @@
 				fssh_vnode_id vnodeID, void *privateNode,
 				fssh_fs_vnode_ops *ops, int type, uint32_t flags);
 extern fssh_status_t fssh_get_vnode(fssh_fs_volume *volume,
-				fssh_vnode_id vnodeID, void **_privateNode,
-				fssh_fs_vnode_ops **_vnodeOps);
+				fssh_vnode_id vnodeID, void **_privateNode);
 extern fssh_status_t fssh_put_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID);
 extern fssh_status_t fssh_acquire_vnode(fssh_fs_volume *volume,

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -2701,7 +2701,7 @@
 	// if you haven't yet access to the attributes directory, get it
 	if (fAttributes == NULL) {
 		if (get_vnode(volume-&gt;FSVolume(), volume-&gt;ToVnode(fInode-&gt;Attributes()),
-				(void**)&amp;fAttributes, NULL) != B_OK) {
+				(void**)&amp;fAttributes) != B_OK) {
 			FATAL((&quot;get_vnode() failed in AttributeIterator::GetNext(ino_t&quot;
 				&quot; = %Ld,name = \&quot;%s\&quot;)\n&quot;, fInode-&gt;ID(), name));
 			return B_ENTRY_NOT_FOUND;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h	2009-02-19 18:13:01 UTC (rev 29250)
@@ -354,8 +354,7 @@
 	{
 		Unset();
 
-		return fStatus = get_vnode(volume-&gt;FSVolume(), id, (void**)&amp;fInode,
-			NULL);
+		return fStatus = get_vnode(volume-&gt;FSVolume(), id, (void**)&amp;fInode);
 	}
 
 	status_t SetTo(Volume* volume, block_run run)

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -556,7 +556,7 @@
 	locker.Unlock();
 
 	Inode* inode;
-	status = get_vnode(volume-&gt;FSVolume(), *_vnodeID, (void**)&amp;inode, NULL);
+	status = get_vnode(volume-&gt;FSVolume(), *_vnodeID, (void**)&amp;inode);
 	if (status != B_OK) {
 		REPORT_ERROR(status);
 		return B_ENTRY_NOT_FOUND;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/cdda/kernel_interface.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -1493,7 +1493,7 @@
 	if (inode == NULL)
 		return B_ENTRY_NOT_FOUND;
 
-	status = get_vnode(volume-&gt;FSVolume(), inode-&gt;ID(), NULL, NULL);
+	status = get_vnode(volume-&gt;FSVolume(), inode-&gt;ID(), NULL);
 	if (status &lt; B_OK)
 		return status;
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ext2/Volume.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -310,7 +310,7 @@
 	if ((fBlockCache = opener.InitCache(NumBlocks(), fBlockSize)) == NULL)
 		return B_ERROR;
 
-	status = get_vnode(fFSVolume, EXT2_ROOT_NODE, (void**)&amp;fRootNode, NULL);
+	status = get_vnode(fFSVolume, EXT2_ROOT_NODE, (void**)&amp;fRootNode);
 	if (status != B_OK) {
 		TRACE(&quot;could not create root node: get_vnode() failed!\n&quot;);
 		return status;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ext2/kernel_interface.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -319,7 +319,7 @@
 			break;
 	}
 
-	return get_vnode(volume-&gt;FSVolume(), *_vnodeID, NULL, NULL);
+	return get_vnode(volume-&gt;FSVolume(), *_vnodeID, NULL);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2009-02-19 18:13:01 UTC (rev 29250)
@@ -433,7 +433,7 @@
 		if (vnid)
 			*vnid = found_vnid;
 		if (node)
-			result = get_vnode(vol-&gt;volume, found_vnid, (void **)node, NULL);
+			result = get_vnode(vol-&gt;volume, found_vnid, (void **)node);
 		result = B_OK;
 	} else {
 		result = ENOENT;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c	2009-02-19 18:13:01 UTC (rev 29250)
@@ -890,7 +890,7 @@
 		*vnid = dummy.vnid;
 		dummy.magic = ~VNODE_MAGIC;
 
-		result = get_vnode(_vol, *vnid, (void **)&amp;file, NULL);
+		result = get_vnode(_vol, *vnid, (void **)&amp;file);
 		if (result &lt; B_OK) {
 			if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)
 				_dosfs_sync(vol);
@@ -1155,7 +1155,7 @@
 			if (vnid == vol-&gt;root_vnode.vnid)
 				break;
 
-			result = get_vnode(_vol, vnid, (void **)&amp;dir, NULL);
+			result = get_vnode(_vol, vnid, (void **)&amp;dir);
 			if (result &lt; B_OK)
 				goto bi1;
 			parent = dir-&gt;dir_vnid;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/iso9660/kernel_interface.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -225,12 +225,12 @@
 		// base directory
 		TRACE((&quot;fs_walk - found \&quot;.\&quot; file.\n&quot;));
 		*_vnodeID = baseNode-&gt;id;
-		return get_vnode(_vol, *_vnodeID, NULL, NULL);
+		return get_vnode(_vol, *_vnodeID, NULL);
 	} else if (strcmp(file, &quot;..&quot;) == 0) {
 		// parent directory
 		TRACE((&quot;fs_walk - found \&quot;..\&quot; file.\n&quot;));
 		*_vnodeID = baseNode-&gt;parID;
-		return get_vnode(_vol, *_vnodeID, NULL, NULL);
+		return get_vnode(_vol, *_vnodeID, NULL);
 	}
 
 	// look up file in the directory
@@ -273,7 +273,7 @@
 						TRACE((&quot;fs_walk - New vnode id is %Ld\n&quot;, *_vnodeID));
 
 						result = get_vnode(_vol, *_vnodeID,
-							(void **)&amp;newNode, NULL);
+							(void **)&amp;newNode);
 						if (result == B_OK) {
 							newNode-&gt;parID = baseNode-&gt;id;
 							done = true;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/nfs/nfs_add_on.c	2009-02-19 18:13:01 UTC (rev 29250)
@@ -898,7 +898,7 @@
 		isLink=S_ISLNK(st.st_mode);
 	}
 
-	if ((result=get_vnode (_volume,*vnid,(void **)&amp;dummy,NULL))&lt;B_OK)
+	if ((result=get_vnode (_volume,*vnid,(void **)&amp;dummy))&lt;B_OK)
 		return result;
 
 	return B_OK;
@@ -1755,7 +1755,7 @@
 
 		*vnid=st.st_ino;
 
-		if ((result=get_vnode(_volume,*vnid,&amp;dummy,NULL))&lt;B_OK)
+		if ((result=get_vnode(_volume,*vnid,&amp;dummy))&lt;B_OK)
 			return result;
 
 		if (S_ISDIR(st.st_mode))
@@ -1901,7 +1901,7 @@
 
 	insert_node (ns,newNode);
 
-	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy,NULL))&lt;B_OK)
+	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy))&lt;B_OK)
 	{
 		XDRInPacketDestroy (&amp;reply);
 		XDROutPacketDestroy (&amp;call);
@@ -2195,7 +2195,7 @@
 
 	insert_node (ns,newNode);
 
-	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy,NULL))&lt;B_OK)
+	if ((result=get_vnode(_volume,st.st_ino,(void **)&amp;dummy))&lt;B_OK)
 	{
 		XDRInPacketDestroy(&amp;reply);
 		XDROutPacketDestroy(&amp;call);
@@ -2341,7 +2341,7 @@
 	if (result==B_OK)
 	{
 		void *dummy;
-		if ((result=get_vnode(_volume,st.st_ino,&amp;dummy,NULL))&lt;B_OK)
+		if ((result=get_vnode(_volume,st.st_ino,&amp;dummy))&lt;B_OK)
 			return result;
 
 		XDRInPacketDestroy (&amp;reply);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/overlay/overlay.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/overlay/overlay.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/overlay/overlay.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -65,6 +65,7 @@
 
 		status_t			AllLayersMounted();
 
+		fs_volume *			Volume() { return fVolume; }
 		fs_volume *			SuperVolume() { return fVolume-&gt;super_volume; }
 
 		bool				WriteSupport() { return fWriteSupport; }
@@ -83,6 +84,7 @@
 
 		status_t			InitCheck();
 
+		fs_volume *			Volume() { return fVolume-&gt;Volume(); }
 		fs_volume *			SuperVolume() { return fVolume-&gt;SuperVolume(); }
 		fs_vnode *			SuperVnode() { return &fSuperVnode; }
 		ino_t				InodeNumber() { return fInodeNumber; }
@@ -114,7 +116,8 @@
 
 class AttributeFile {
 public:
-							AttributeFile(fs_volume *volume, fs_vnode *vnode);
+							AttributeFile(fs_volume *overlay, fs_volume *volume,
+								fs_vnode *vnode);
 							~AttributeFile();
 
 		status_t			InitCheck() { return fStatus; }
@@ -123,8 +126,8 @@
 		ino_t				FileInode() { return fFileInode; }
 
 		status_t			CreateEmpty();
-		status_t			WriteAttributeFile(fs_volume *volume,
-								fs_vnode *vnode);
+		status_t			WriteAttributeFile(fs_volume *overlay,
+								fs_volume *volume, fs_vnode *vnode);
 
 		status_t			ReadAttributeDir(struct dirent *dirent,
 								size_t bufferSize, uint32 *numEntries,
@@ -286,8 +289,8 @@
 OverlayInode::GetAttributeFile(AttributeFile **attributeFile)
 {
 	if (fAttributeFile == NULL) {
-		fAttributeFile = new(std::nothrow) AttributeFile(SuperVolume(),
-			&amp;fSuperVnode);
+		fAttributeFile = new(std::nothrow) AttributeFile(Volume(),
+			SuperVolume(), &amp;fSuperVnode);
 		if (fAttributeFile == NULL) {
 			TRACE_ALWAYS(&quot;no memory to allocate attribute file\n&quot;);
 			return B_NO_MEMORY;
@@ -321,7 +324,8 @@
 	if (result != B_OK)
 		return result;
 
-	return fAttributeFile-&gt;WriteAttributeFile(SuperVolume(), &amp;fSuperVnode);
+	return fAttributeFile-&gt;WriteAttributeFile(Volume(), SuperVolume(),
+		&amp;fSuperVnode);
 }
 
 
@@ -553,7 +557,8 @@
 //	#pragma mark AttributeFile
 
 
-AttributeFile::AttributeFile(fs_volume *volume, fs_vnode *vnode)
+AttributeFile::AttributeFile(fs_volume *overlay, fs_volume *volume,
+	fs_vnode *vnode)
 	:	fStatus(B_NO_INIT),
 		fVolumeID(volume-&gt;id),
 		fFileInode(0),
@@ -633,13 +638,14 @@
 		else if (i == 2)
 			fAttributeFileInode = inodeNumber;
 
-		fStatus = get_vnode(volume, inodeNumber, &amp;currentVnode.private_node,
-			&amp;currentVnode.ops);
+		OverlayInode *overlayInode = NULL;
+		fStatus = get_vnode(overlay, inodeNumber, (void **)&amp;overlayInode);
 		if (fStatus != B_OK) {
 			TRACE_ALWAYS(&quot;getting vnode failed: %s\n&quot;, strerror(fStatus));
 			return;
 		}
 
+		currentVnode = *overlayInode-&gt;SuperVnode();
 		lastInodeNumber = inodeNumber;
 	}
 
@@ -767,7 +773,8 @@
 
 
 status_t
-AttributeFile::WriteAttributeFile(fs_volume *volume, fs_vnode *vnode)
+AttributeFile::WriteAttributeFile(fs_volume *overlay, fs_volume *volume,
+	fs_vnode *vnode)
 {
 	if (fFile == NULL)
 		return B_NO_INIT;
@@ -787,15 +794,17 @@
 	}
 
 	fs_vnode currentVnode;
+	OverlayInode *overlayInode = NULL;
 	if (fAttributeDirInode == 0) {
-		result = get_vnode(volume, fDirectoryInode,
-			&amp;currentVnode.private_node, &amp;currentVnode.ops);
+		result = get_vnode(overlay, fDirectoryInode, (void **)&amp;overlayInode);
 		if (result != B_OK) {
 			TRACE_ALWAYS(&quot;failed to get directory vnode: %s\n&quot;,
 				strerror(result));
 			return result;
 		}
 
+		currentVnode = *overlayInode-&gt;SuperVnode();
+
 		// create the attribute directory
 		result = currentVnode.ops-&gt;create_dir(volume, &amp;currentVnode,
 			ATTRIBUTE_OVERLAY_ATTRIBUTE_DIR_NAME, S_IRWXU | S_IRWXG | S_IRWXO,
@@ -813,14 +822,15 @@
 
 	void *attrFileCookie = NULL;
 	if (fAttributeFileInode == 0) {
-		result = get_vnode(volume, fAttributeDirInode,
-			&amp;currentVnode.private_node, &amp;currentVnode.ops);
+		result = get_vnode(overlay, fAttributeDirInode, (void **)&amp;overlayInode);
 		if (result != B_OK) {
 			TRACE_ALWAYS(&quot;failed to get attribute directory vnode: %s\n&quot;,
 				strerror(result));
 			return result;
 		}
 
+		currentVnode = *overlayInode-&gt;SuperVnode();
+
 		// create the attribute file
 		result = currentVnode.ops-&gt;create(volume, &amp;currentVnode,
 			nameBuffer, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP
@@ -835,22 +845,24 @@
 			return result;
 		}
 
-		result = get_vnode(volume, fAttributeFileInode,
-			&amp;currentVnode.private_node, &amp;currentVnode.ops);
+		result = get_vnode(overlay, fAttributeFileInode, (void **)&amp;overlayInode);
 		if (result != B_OK) {
 			TRACE_ALWAYS(&quot;getting attribute file vnode after create failed: %s\n&quot;,
 				strerror(result));
 			return result;
 		}
+
+		currentVnode = *overlayInode-&gt;SuperVnode();
 	} else {
-		result = get_vnode(volume, fAttributeFileInode,
-			&amp;currentVnode.private_node, &amp;currentVnode.ops);
+		result = get_vnode(overlay, fAttributeFileInode, (void **)&amp;overlayInode);
 		if (result != B_OK) {
 			TRACE_ALWAYS(&quot;getting attribute file vnode failed: %s\n&quot;,
 				strerror(result));
 			return result;
 		}
 
+		currentVnode = *overlayInode-&gt;SuperVnode();
+
 		// open the attribute file
 		result = currentVnode.ops-&gt;open(volume, &amp;currentVnode, O_RDWR | O_TRUNC,
 			&amp;attrFileCookie);
@@ -1296,6 +1308,11 @@
 overlay_get_super_vnode(fs_volume *volume, fs_vnode *vnode,
 	fs_volume *superVolume, fs_vnode *_superVnode)
 {
+	if (volume == superVolume) {
+		*_superVnode = *vnode;
+		return B_OK;
+	}
+
 	OverlayInode *node = (OverlayInode *)vnode-&gt;private_node;
 	fs_vnode *superVnode = node-&gt;SuperVnode();
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/add-ons/kernel/file_systems/reiserfs/Volume.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -294,7 +294,7 @@
 status_t
 Volume::GetVNode(ino_t id, VNode **node)
 {
-	return get_vnode(GetFSVolume(), id, (void**)node, NULL);
+	return get_vnode(GetFSVolume(), id, (void**)node);
 }
 
 // PutVNode

Modified: haiku/trunk/src/system/kernel/device_manager/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/system/kernel/device_manager/devfs.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -407,8 +407,7 @@
 
 	// increase reference count of raw device -
 	// the partition device really needs it
-	status = get_vnode(fs-&gt;volume, device-&gt;id, (void**)&amp;partition-&gt;raw_device,
-		NULL);
+	status = get_vnode(fs-&gt;volume, device-&gt;id, (void**)&amp;partition-&gt;raw_device);
 	if (status &lt; B_OK)
 		goto err1;
 
@@ -959,7 +958,7 @@
 		return B_ENTRY_NOT_FOUND;
 	}
 
-	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL);
+	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL);
 	if (status &lt; B_OK)
 		return status;
 
@@ -1063,7 +1062,7 @@
 	if (openMode &amp; O_EXCL)
 		return B_FILE_EXISTS;
 
-	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL);
+	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL);
 	if (status &lt; B_OK)
 		return status;
 
@@ -2092,7 +2091,7 @@
 {
 	devfs_vnode* node;
 	status_t status = get_vnode(sDeviceFileSystem-&gt;volume, device-&gt;ID(),
-		(void**)&amp;node, NULL);
+		(void**)&amp;node);
 	if (status != B_OK)
 		return status;
 

Modified: haiku/trunk/src/system/kernel/fs/rootfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/rootfs.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/system/kernel/fs/rootfs.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -284,7 +284,7 @@
 {
 	// schedule this vnode to be removed when it's ref goes to zero
 
-	bool gotNode = (get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL) == B_OK);
+	bool gotNode = (get_vnode(fs-&gt;volume, vnode-&gt;id, NULL) == B_OK);
 
 	status_t status = B_OK;
 	if (gotNode)
@@ -447,7 +447,7 @@
 		goto err;
 	}
 
-	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL, NULL);
+	status = get_vnode(fs-&gt;volume, vnode-&gt;id, NULL);
 	if (status &lt; B_OK)
 		goto err;
 

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -3626,8 +3626,7 @@
 
 
 extern &quot;C&quot; status_t
-get_vnode(fs_volume *volume, ino_t vnodeID, void **_privateNode,
-	fs_vnode_ops **_vnodeOps)
+get_vnode(fs_volume *volume, ino_t vnodeID, void **_privateNode)
 {
 	struct vnode *vnode;
 
@@ -3653,14 +3652,8 @@
 
 		if (_privateNode != NULL)
 			*_privateNode = resolvedNode.private_node;
-		if (_vnodeOps != NULL)
-			*_vnodeOps = resolvedNode.ops;
-	} else {
-		if (_privateNode != NULL)
-			*_privateNode = vnode-&gt;private_node;
-		if (_vnodeOps != NULL)
-			*_vnodeOps = vnode-&gt;ops;
-	}
+	} else if (_privateNode != NULL)
+		*_privateNode = vnode-&gt;private_node;
 
 	return B_OK;
 }
@@ -4054,7 +4047,7 @@
 	}
 
 	// Use get_vnode() to resolve the cookie for the right layer.
-	status = get_vnode(volume, vnode-&gt;id, _node, NULL);
+	status = get_vnode(volume, vnode-&gt;id, _node);
 	put_vnode(vnode);
 
 	return status;

Modified: haiku/trunk/src/tools/fs_shell/vfs.cpp
===================================================================
--- haiku/trunk/src/tools/fs_shell/vfs.cpp	2009-02-19 01:20:10 UTC (rev 29249)
+++ haiku/trunk/src/tools/fs_shell/vfs.cpp	2009-02-19 18:13:01 UTC (rev 29250)
@@ -1986,7 +1986,7 @@
 
 extern &quot;C&quot; fssh_status_t
 fssh_get_vnode(fssh_fs_volume *volume, fssh_vnode_id vnodeID,
-	void **privateNode, fssh_fs_vnode_ops **vnodeOps)
+	void **privateNode)
 {
 	struct vnode *vnode;
 
@@ -2012,14 +2012,8 @@
 
 		if (privateNode != NULL)
 			*privateNode = resolvedNode.private_node;
-		if (vnodeOps != NULL)
-			*vnodeOps = resolvedNode.ops;
-	} else {
-		if (privateNode != NULL)
-			*privateNode = vnode-&gt;private_node;
-		if (vnodeOps != NULL)
-			*vnodeOps = vnode-&gt;ops;
-	}
+	} else if (privateNode != NULL)
+		*privateNode = vnode-&gt;private_node;
 
 	return FSSH_B_OK;
 }
@@ -2451,7 +2445,7 @@
 	}
 
 	// Use get_vnode() to resolve the cookie for the right layer.
-	status = ::fssh_get_vnode(volume, vnode-&gt;id, _node, NULL);
+	status = ::fssh_get_vnode(volume, vnode-&gt;id, _node);
 	put_vnode(vnode);
 
 	return FSSH_B_OK;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014437.html">[Haiku-commits] r29249 - haiku/trunk/src/add-ons/kernel/file_systems/overlay
</A></li>
	<LI>Next message: <A HREF="014422.html">[Haiku-commits] r29251 -	haiku/trunk/src/add-ons/kernel/file_systems/overlay
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14419">[ date ]</a>
              <a href="thread.html#14419">[ thread ]</a>
              <a href="subject.html#14419">[ subject ]</a>
              <a href="author.html#14419">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
