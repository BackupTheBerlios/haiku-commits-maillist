<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29535 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil: . x86
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29535%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil%3A%20.%20x86&In-Reply-To=%3C200903150134.n2F1YixI011756%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014867.html">
   <LINK REL="Next"  HREF="014869.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29535 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil: . x86</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29535%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil%3A%20.%20x86&In-Reply-To=%3C200903150134.n2F1YixI011756%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29535 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil: . x86">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Sun Mar 15 02:34:44 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014867.html">[Haiku-commits] r29534 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale
</A></li>
        <LI>Next message: <A HREF="014869.html">[Haiku-commits] r29536 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: . x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14868">[ date ]</a>
              <a href="thread.html#14868">[ thread ]</a>
              <a href="subject.html#14868">[ subject ]</a>
              <a href="author.html#14868">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2009-03-15 02:34:41 +0100 (Sun, 15 Mar 2009)
New Revision: 29535
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29535&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29535&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/pixfmt.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random_seed.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random_seed.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/timer.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/x86/
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/x86/bswap.h
Removed:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/softfloat.c
Modified:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/common.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/crc_data.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/des.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/des.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/fifo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/fifo.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/integer.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/integer.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/internal.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intfloat_readwrite.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intfloat_readwrite.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/intreadwrite.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lfg.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lls.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lls.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/log.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/log.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lzo.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/lzo.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mathematics.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mathematics.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/md5.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/md5.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mem.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/mem.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/pca.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/pca.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/random.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rational.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rational.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rc4.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/rc4.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/sha1.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/sha1.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/softfloat.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/tree.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/tree.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/x86_cpu.h
Log:
sync with ffmpeg 0.5 release

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2009-03-15 01:34:41 UTC (rev 29535)
@@ -4,14 +4,16 @@
 TARGET_WARNING_CCFLAGS = [ FFilter $(TARGET_WARNING_CCFLAGS)
 	: -Wall -Wmissing-prototypes -Wsign-compare -Wpointer-arith ] ;
 
+SubDirHdrs [ FDirName $(SUBDIR) .. ] ;
 SubDirHdrs [ FDirName $(SUBDIR) ../libavcodec ] ;
 
 SubDirCcFlags -fomit-frame-pointer -DPIC ;
-SubDirCcFlags -DHAVE_AV_CONFIG_H=1 ;
+#SubDirCcFlags -DHAVE_AV_CONFIG_H=1 ;
 
 StaticLibrary libavutil.a :
 	adler32.c
 	aes.c
+	avstring.c
 	base64.c
 	crc.c
 	des.c
@@ -27,10 +29,10 @@
 	mem.c
 	pca.c
 	random.c
+	random_seed.c
 	rational.c
 	rc4.c
 	sha1.c
-	softfloat.c
 	string.c
 	tree.c
 	utils.c

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.c	2009-03-15 01:34:41 UTC (rev 29535)
@@ -1,4 +1,5 @@
-/* adler32.c -- compute the Adler-32 checksum of a data stream
+/*
+ * Compute the Adler-32 checksum of a data stream.
  * This is a modified version based on adler32.c from the zlib library.
  *
  * Copyright (C) 1995 Mark Adler
@@ -35,7 +36,7 @@
     unsigned long s2 = adler &gt;&gt; 16;
 
     while (len&gt;0) {
-#ifdef CONFIG_SMALL
+#if CONFIG_SMALL
         while(len&gt;4 &amp;&amp; s2 &lt; (1U&lt;&lt;31)){
             DO4(buf); len-=4;
 #else

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/adler32.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FFMPEG_ADLER32_H
-#define FFMPEG_ADLER32_H
+#ifndef AVUTIL_ADLER32_H
+#define AVUTIL_ADLER32_H
 
 #include &lt;stdint.h&gt;
 #include &quot;common.h&quot;
@@ -27,4 +27,4 @@
 unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
                                 unsigned int len) av_pure;
 
-#endif /* FFMPEG_ADLER32_H */
+#endif /* AVUTIL_ADLER32_H */

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.c	2009-03-15 01:34:41 UTC (rev 29535)
@@ -39,7 +39,7 @@
 
 static uint8_t     sbox[256];
 static uint8_t inv_sbox[256];
-#ifdef CONFIG_SMALL
+#if CONFIG_SMALL
 static uint32_t enc_multbl[1][256];
 static uint32_t dec_multbl[1][256];
 #else
@@ -47,12 +47,12 @@
 static uint32_t dec_multbl[4][256];
 #endif
 
-static inline void addkey(uint64_t dst[2], uint64_t src[2], uint64_t round_key[2]){
+static inline void addkey(uint64_t dst[2], const uint64_t src[2], const uint64_t round_key[2]){
     dst[0] = src[0] ^ round_key[0];
     dst[1] = src[1] ^ round_key[1];
 }
 
-static void subshift(uint8_t s0[2][16], int s, uint8_t *box){
+static void subshift(uint8_t s0[2][16], int s, const uint8_t *box){
     uint8_t (*s1)[16]= s0[0] - s;
     uint8_t (*s3)[16]= s0[0] + s;
     s0[0][0]=box[s0[1][ 0]]; s0[0][ 4]=box[s0[1][ 4]]; s0[0][ 8]=box[s0[1][ 8]]; s0[0][12]=box[s0[1][12]];
@@ -62,7 +62,7 @@
 }
 
 static inline int mix_core(uint32_t multbl[4][256], int a, int b, int c, int d){
-#ifdef CONFIG_SMALL
+#if CONFIG_SMALL
 #define ROT(x,s) ((x&lt;&lt;s)|(x&gt;&gt;(32-s)))
     return multbl[0][a] ^ ROT(multbl[0][b], 8) ^ ROT(multbl[0][c], 16) ^ ROT(multbl[0][d], 24);
 #else
@@ -77,7 +77,7 @@
     ((uint32_t *)(state))[3] = mix_core(multbl, state[1][3][0], state[1][s1-1][1], state[1][1][2], state[1][s3-1][3]);
 }
 
-static inline void crypt(AVAES *a, int s, uint8_t *sbox, uint32_t *multbl){
+static inline void crypt(AVAES *a, int s, const uint8_t *sbox, const uint32_t *multbl){
     int r;
 
     for(r=a-&gt;rounds-1; r&gt;0; r--){
@@ -87,7 +87,7 @@
     subshift(a-&gt;state[0][0], s, sbox);
 }
 
-void av_aes_crypt(AVAES *a, uint8_t *dst, uint8_t *src, int count, uint8_t *iv, int decrypt){
+void av_aes_crypt(AVAES *a, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt){
     while(count--){
         addkey(a-&gt;state[1], src, a-&gt;round_key[a-&gt;rounds]);
         if(decrypt) {
@@ -108,13 +108,13 @@
     }
 }
 
-static void init_multbl2(uint8_t tbl[1024], int c[4], uint8_t *log8, uint8_t *alog8, uint8_t *sbox){
+static void init_multbl2(uint8_t tbl[1024], const int c[4], const uint8_t *log8, const uint8_t *alog8, const uint8_t *sbox){
     int i, j;
     for(i=0; i&lt;1024; i++){
         int x= sbox[i&gt;&gt;2];
         if(x) tbl[i]= alog8[ log8[x] + log8[c[i&amp;3]] ];
     }
-#ifndef CONFIG_SMALL
+#if !CONFIG_SMALL
     for(j=256; j&lt;1024; j++)
         for(i=0; i&lt;4; i++)
             tbl[4*j+i]= tbl[4*j + ((i-1)&amp;3) - 1024];
@@ -146,8 +146,8 @@
             inv_sbox[j]= i;
             sbox    [i]= j;
         }
-        init_multbl2(dec_multbl[0], (int[4]){0xe, 0x9, 0xd, 0xb}, log8, alog8, inv_sbox);
-        init_multbl2(enc_multbl[0], (int[4]){0x2, 0x1, 0x1, 0x3}, log8, alog8, sbox);
+        init_multbl2(dec_multbl[0], (const int[4]){0xe, 0x9, 0xd, 0xb}, log8, alog8, inv_sbox);
+        init_multbl2(enc_multbl[0], (const int[4]){0x2, 0x1, 0x1, 0x3}, log8, alog8, sbox);
     }
 
     if(key_bits!=128 &amp;&amp; key_bits!=192 &amp;&amp; key_bits!=256)

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/aes.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FFMPEG_AES_H
-#define FFMPEG_AES_H
+#ifndef AVUTIL_AES_H
+#define AVUTIL_AES_H
 
 #include &lt;stdint.h&gt;
 
@@ -42,6 +42,6 @@
  * @param iv initialization vector for CBC mode, if NULL then ECB will be used
  * @param decrypt 0 for encryption, 1 for decryption
  */
-void av_aes_crypt(struct AVAES *a, uint8_t *dst, uint8_t *src, int count, uint8_t *iv, int decrypt);
+void av_aes_crypt(struct AVAES *a, uint8_t *dst, const uint8_t *src, int count, uint8_t *iv, int decrypt);
 
-#endif /* FFMPEG_AES_H */
+#endif /* AVUTIL_AES_H */

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.c	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.c	2009-03-15 01:34:41 UTC (rev 29535)
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
+ * Copyright (c) 2007 Mans Rullgard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ctype.h&gt;
+#include &quot;avstring.h&quot;
+
+int av_strstart(const char *str, const char *pfx, const char **ptr)
+{
+    while (*pfx &amp;&amp; *pfx == *str) {
+        pfx++;
+        str++;
+    }
+    if (!*pfx &amp;&amp; ptr)
+        *ptr = str;
+    return !*pfx;
+}
+
+int av_stristart(const char *str, const char *pfx, const char **ptr)
+{
+    while (*pfx &amp;&amp; toupper((unsigned)*pfx) == toupper((unsigned)*str)) {
+        pfx++;
+        str++;
+    }
+    if (!*pfx &amp;&amp; ptr)
+        *ptr = str;
+    return !*pfx;
+}
+
+size_t av_strlcpy(char *dst, const char *src, size_t size)
+{
+    size_t len = 0;
+    while (++len &lt; size &amp;&amp; *src)
+        *dst++ = *src++;
+    if (len &lt;= size)
+        *dst = 0;
+    return len + strlen(src) - 1;
+}
+
+size_t av_strlcat(char *dst, const char *src, size_t size)
+{
+    size_t len = strlen(dst);
+    if (size &lt;= len + 1)
+        return len + strlen(src);
+    return len + av_strlcpy(dst + len, src, size - len);
+}
+
+size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...)
+{
+    int len = strlen(dst);
+    va_list vl;
+
+    va_start(vl, fmt);
+    len += vsnprintf(dst + len, size &gt; len ? size - len : 0, fmt, vl);
+    va_end(vl);
+
+    return len;
+}

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avstring.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -18,8 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FFMPEG_AVSTRING_H
-#define FFMPEG_AVSTRING_H
+#ifndef AVUTIL_AVSTRING_H
+#define AVUTIL_AVSTRING_H
 
 #include &lt;stddef.h&gt;
 
@@ -29,7 +29,7 @@
  *
  * @param str input string
  * @param pfx prefix to test
- * @param ptr updated after the prefix in str in there is a match
+ * @param ptr updated if the prefix is matched inside str
  * @return non-zero if the prefix matches, zero otherwise
  */
 int av_strstart(const char *str, const char *pfx, const char **ptr);
@@ -41,14 +41,14 @@
  *
  * @param str input string
  * @param pfx prefix to test
- * @param ptr updated after the prefix in str in there is a match
+ * @param ptr updated if the prefix is matched inside str
  * @return non-zero if the prefix matches, zero otherwise
  */
 int av_stristart(const char *str, const char *pfx, const char **ptr);
 
 /**
  * Copy the string src to dst, but no more than size - 1 bytes, and
- * null terminate dst.
+ * null-terminate dst.
  *
  * This function is the same as BSD strlcpy().
  *
@@ -61,7 +61,7 @@
 
 /**
  * Append the string src to the string dst, but to a total length of
- * no more than size - 1 bytes, and null terminate dst.
+ * no more than size - 1 bytes, and null-terminate dst.
  *
  * This function is similar to BSD strlcat(), but differs when
  * size &lt;= strlen(dst).
@@ -87,4 +87,4 @@
  */
 size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...);
 
-#endif /* FFMPEG_AVSTRING_H */
+#endif /* AVUTIL_AVSTRING_H */

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/avutil.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -18,11 +18,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FFMPEG_AVUTIL_H
-#define FFMPEG_AVUTIL_H
+#ifndef AVUTIL_AVUTIL_H
+#define AVUTIL_AVUTIL_H
 
 /**
- * @file avutil.h
+ * @file libavutil/avutil.h
  * external API header
  */
 
@@ -35,7 +35,7 @@
 #define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
 
 #define LIBAVUTIL_VERSION_MAJOR 49
-#define LIBAVUTIL_VERSION_MINOR 10
+#define LIBAVUTIL_VERSION_MINOR 15
 #define LIBAVUTIL_VERSION_MICRO  0
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
@@ -58,90 +58,6 @@
 #include &quot;rational.h&quot;
 #include &quot;intfloat_readwrite.h&quot;
 #include &quot;log.h&quot;
+#include &quot;pixfmt.h&quot;
 
-/**
- * Pixel format. Notes:
- *
- * PIX_FMT_RGB32 is handled in an endian-specific manner. A RGBA
- * color is put together as:
- *  (A &lt;&lt; 24) | (R &lt;&lt; 16) | (G &lt;&lt; 8) | B
- * This is stored as BGRA on little endian CPU architectures and ARGB on
- * big endian CPUs.
- *
- * When the pixel format is palettized RGB (PIX_FMT_PAL8), the palettized
- * image data is stored in AVFrame.data[0]. The palette is transported in
- * AVFrame.data[1] and, is 1024 bytes long (256 4-byte entries) and is
- * formatted the same as in PIX_FMT_RGB32 described above (i.e., it is
- * also endian-specific). Note also that the individual RGB palette
- * components stored in AVFrame.data[1] should be in the range 0..255.
- * This is important as many custom PAL8 video codecs that were designed
- * to run on the IBM VGA graphics adapter use 6-bit palette components.
- */
-enum PixelFormat {
-    PIX_FMT_NONE= -1,
-    PIX_FMT_YUV420P,   ///&lt; Planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)
-    PIX_FMT_YUYV422,   ///&lt; Packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
-    PIX_FMT_RGB24,     ///&lt; Packed RGB 8:8:8, 24bpp, RGBRGB...
-    PIX_FMT_BGR24,     ///&lt; Packed RGB 8:8:8, 24bpp, BGRBGR...
-    PIX_FMT_YUV422P,   ///&lt; Planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)
-    PIX_FMT_YUV444P,   ///&lt; Planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)
-    PIX_FMT_RGB32,     ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8A 8R 8G 8B(lsb), in cpu endianness
-    PIX_FMT_YUV410P,   ///&lt; Planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)
-    PIX_FMT_YUV411P,   ///&lt; Planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)
-    PIX_FMT_RGB565,    ///&lt; Packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), in cpu endianness
-    PIX_FMT_RGB555,    ///&lt; Packed RGB 5:5:5, 16bpp, (msb)1A 5R 5G 5B(lsb), in cpu endianness most significant bit to 0
-    PIX_FMT_GRAY8,     ///&lt;        Y        ,  8bpp
-    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black
-    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white
-    PIX_FMT_PAL8,      ///&lt; 8 bit with PIX_FMT_RGB32 palette
-    PIX_FMT_YUVJ420P,  ///&lt; Planar YUV 4:2:0, 12bpp, full scale (jpeg)
-    PIX_FMT_YUVJ422P,  ///&lt; Planar YUV 4:2:2, 16bpp, full scale (jpeg)
-    PIX_FMT_YUVJ444P,  ///&lt; Planar YUV 4:4:4, 24bpp, full scale (jpeg)
-    PIX_FMT_XVMC_MPEG2_MC,///&lt; XVideo Motion Acceleration via common packet passing(xvmc_render.h)
-    PIX_FMT_XVMC_MPEG2_IDCT,
-    PIX_FMT_UYVY422,   ///&lt; Packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
-    PIX_FMT_UYYVYY411, ///&lt; Packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
-    PIX_FMT_BGR32,     ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8A 8B 8G 8R(lsb), in cpu endianness
-    PIX_FMT_BGR565,    ///&lt; Packed RGB 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), in cpu endianness
-    PIX_FMT_BGR555,    ///&lt; Packed RGB 5:5:5, 16bpp, (msb)1A 5B 5G 5R(lsb), in cpu endianness most significant bit to 1
-    PIX_FMT_BGR8,      ///&lt; Packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
-    PIX_FMT_BGR4,      ///&lt; Packed RGB 1:2:1,  4bpp, (msb)1B 2G 1R(lsb)
-    PIX_FMT_BGR4_BYTE, ///&lt; Packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
-    PIX_FMT_RGB8,      ///&lt; Packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
-    PIX_FMT_RGB4,      ///&lt; Packed RGB 1:2:1,  4bpp, (msb)2R 3G 3B(lsb)
-    PIX_FMT_RGB4_BYTE, ///&lt; Packed RGB 1:2:1,  8bpp, (msb)2R 3G 3B(lsb)
-    PIX_FMT_NV12,      ///&lt; Planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 for UV
-    PIX_FMT_NV21,      ///&lt; as above, but U and V bytes are swapped
-
-    PIX_FMT_RGB32_1,   ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8R 8G 8B 8A(lsb), in cpu endianness
-    PIX_FMT_BGR32_1,   ///&lt; Packed RGB 8:8:8, 32bpp, (msb)8B 8G 8R 8A(lsb), in cpu endianness
-
-    PIX_FMT_GRAY16BE,  ///&lt;        Y        , 16bpp, big-endian
-    PIX_FMT_GRAY16LE,  ///&lt;        Y        , 16bpp, little-endian
-    PIX_FMT_YUV440P,   ///&lt; Planar YUV 4:4:0 (1 Cr &amp; Cb sample per 1x2 Y samples)
-    PIX_FMT_YUVJ440P,  ///&lt; Planar YUV 4:4:0 full scale (jpeg)
-    PIX_FMT_YUVA420P,  ///&lt; Planar YUV 4:2:0, 20bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples)
-    PIX_FMT_NB,        ///&lt; number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
-};
-
-#ifdef WORDS_BIGENDIAN
-#define PIX_FMT_RGBA PIX_FMT_RGB32_1
-#define PIX_FMT_BGRA PIX_FMT_BGR32_1
-#define PIX_FMT_ARGB PIX_FMT_RGB32
-#define PIX_FMT_ABGR PIX_FMT_BGR32
-#define PIX_FMT_GRAY16 PIX_FMT_GRAY16BE
-#else
-#define PIX_FMT_RGBA PIX_FMT_BGR32
-#define PIX_FMT_BGRA PIX_FMT_RGB32
-#define PIX_FMT_ARGB PIX_FMT_BGR32_1
-#define PIX_FMT_ABGR PIX_FMT_RGB32_1
-#define PIX_FMT_GRAY16 PIX_FMT_GRAY16LE
-#endif
-
-#if LIBAVUTIL_VERSION_INT &lt; (50&lt;&lt;16)
-#define PIX_FMT_UYVY411 PIX_FMT_UYYVYY411
-#define PIX_FMT_RGBA32  PIX_FMT_RGB32
-#define PIX_FMT_YUV422  PIX_FMT_YUYV422
-#endif
-
-#endif /* FFMPEG_AVUTIL_H */
+#endif /* AVUTIL_AVUTIL_H */

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.c	2009-03-15 01:34:41 UTC (rev 29535)
@@ -1,5 +1,4 @@
 /*
- * Base64.c
  * Copyright (c) 2006 Ryan Martell. (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>)
  *
  * This file is part of FFmpeg.
@@ -20,8 +19,8 @@
  */
 
 /**
-* @file base64.c
- * @brief Base64 Encode/Decode
+ * @file libavutil/base64.c
+ * @brief Base64 encode/decode
  * @author Ryan Martell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>&gt; (with lots of Michael)
  */
 
@@ -43,7 +42,7 @@
     0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33
 };
 
-int av_base64_decode(uint8_t * out, const char *in, int out_length)
+int av_base64_decode(uint8_t *out, const char *in, int out_size)
 {
     int i, v;
     uint8_t *dst = out;
@@ -51,11 +50,11 @@
     v = 0;
     for (i = 0; in[i] &amp;&amp; in[i] != '='; i++) {
         unsigned int index= in[i]-43;
-        if (index&gt;=(sizeof(map2)/sizeof(map2[0])) || map2[index] == 0xff)
+        if (index&gt;=FF_ARRAY_ELEMS(map2) || map2[index] == 0xff)
             return -1;
         v = (v &lt;&lt; 6) + map2[index];
         if (i &amp; 3) {
-            if (dst - out &lt; out_length) {
+            if (dst - out &lt; out_size) {
                 *dst++ = v &gt;&gt; (6 - 2 * (i &amp; 3));
             }
         }
@@ -65,26 +64,26 @@
 }
 
 /*****************************************************************************
-* b64_encode: stolen from VLC's http.c
-* simplified by michael
-* fixed edge cases and made it work from data (vs. strings) by ryan.
+* b64_encode: Stolen from VLC's http.c.
+* Simplified by Michael.
+* Fixed edge cases and made it work from data (vs. strings) by Ryan.
 *****************************************************************************/
 
-char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len)
+char *av_base64_encode(char *out, int out_size, const uint8_t *in, int in_size)
 {
     static const char b64[] =
         &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
     char *ret, *dst;
     unsigned i_bits = 0;
     int i_shift = 0;
-    int bytes_remaining = len;
+    int bytes_remaining = in_size;
 
-    if (len &gt;= UINT_MAX / 4 ||
-        buf_len &lt; len * 4 / 3 + 12)
+    if (in_size &gt;= UINT_MAX / 4 ||
+        out_size &lt; (in_size+2) / 3 * 4 + 1)
         return NULL;
-    ret = dst = buf;
+    ret = dst = out;
     while (bytes_remaining) {
-        i_bits = (i_bits &lt;&lt; 8) + *src++;
+        i_bits = (i_bits &lt;&lt; 8) + *in++;
         bytes_remaining--;
         i_shift += 8;
 
@@ -100,129 +99,65 @@
     return ret;
 }
 
-// #define TEST_BASE64
+#ifdef TEST
 
-#ifdef TEST_BASE64
-#include &quot;avutil.h&quot;
+#undef printf
 
-int b64test()
+#define MAX_DATA_SIZE    1024
+#define MAX_ENCODED_SIZE 2048
+
+int test_encode_decode(const uint8_t *data, unsigned int data_size, const char *encoded_ref)
 {
-    int numerr = 0;
-    int len;
-    int numtest = 1;
-    uint8_t decode[1000];
-    struct test {
-        void *data;
-        int len;
-        const char *result;
-    } *t, tests[] = {
-        {
-        &quot;&quot;, 0, &quot;&quot;}, {
-        &quot;1&quot;, 1, &quot;MQ==&quot;}, {
-        &quot;22&quot;, 2, &quot;MjI=&quot;}, {
-        &quot;333&quot;, 3, &quot;MzMz&quot;}, {
-        &quot;4444&quot;, 4, &quot;NDQ0NA==&quot;}, {
-        &quot;55555&quot;, 5, &quot;NTU1NTU=&quot;}, {
-        &quot;abc:def&quot;, 7, &quot;YWJjOmRlZg==&quot;}, {
-        NULL}
-    };
-    for (t = tests; t-&gt;data; t++) {
-        char *str;
+    char  encoded[MAX_ENCODED_SIZE];
+    uint8_t data2[MAX_DATA_SIZE];
+    int data2_size, max_data2_size = MAX_DATA_SIZE;
 
-        av_log(NULL, AV_LOG_ERROR, &quot;Encoding %s...\n&quot;, (char *) t-&gt;data);
-        str = av_base64_encode(t-&gt;data, t-&gt;len);
-        if (str) {
-            av_log(NULL, AV_LOG_ERROR, &quot;Encoded to %s...\n&quot;, str);
-            if (strcmp(str, t-&gt;result) != 0) {
-                av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: %s != %s\n&quot;,
-                       numtest, str, t-&gt;result);
-                numerr++;
-            }
-            av_free(str);
-        }
+    if (!av_base64_encode(encoded, MAX_ENCODED_SIZE, data, data_size)) {
+        printf(&quot;Failed: cannot encode the input data\n&quot;);
+        return 1;
+    }
+    if (encoded_ref &amp;&amp; strcmp(encoded, encoded_ref)) {
+        printf(&quot;Failed: encoded string differs from reference\n&quot;
+               &quot;Encoded:\n%s\nReference:\n%s\n&quot;, encoded, encoded_ref);
+        return 1;
+    }
 
-        av_log(NULL, AV_LOG_ERROR, &quot;Done encoding, about to decode...\n&quot;);
-        len = av_base64_decode(decode, t-&gt;result, sizeof(decode));
-        if (len != t-&gt;len) {
-            av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: len %d != %d\n&quot;,
-                   numtest, len, t-&gt;len);
-            numerr++;
-        } else if (memcmp(decode, t-&gt;data, t-&gt;len) != 0) {
-            av_log(NULL, AV_LOG_ERROR, &quot;failed test %d: data\n&quot;, numtest);
-            numerr++;
-        } else {
-            av_log(NULL, AV_LOG_ERROR, &quot;Decoded to %s\n&quot;,
-                   (char *) t-&gt;data);
-        }
-        numtest++;
+    if ((data2_size = av_base64_decode(data2, encoded, max_data2_size)) &lt; 0) {
+        printf(&quot;Failed: cannot decode the encoded string\n&quot;
+               &quot;Encoded:\n%s\n&quot;, encoded);
+        return 1;
     }
+    if (memcmp(data2, data, data_size)) {
+        printf(&quot;Failed: encoded/decoded data differs from original data\n&quot;);
+        return 1;
+    }
 
-#undef srand
-#undef rand
+    printf(&quot;Passed!\n&quot;);
+    return 0;
+}
 
-    {
-        int test_count;
-        srand(123141);          // time(NULL));
-        for (test_count = 0; test_count &lt; 100; test_count++) {
-            int size = rand() % 1024;
-            int ii;
-            uint8_t *data;
-            char *encoded_result;
+int main(void)
+{
+    int i, error_count = 0;
+    struct test {
+        const uint8_t *data;
+        const char *encoded_ref;
+    } tests[] = {
+        { &quot;&quot;,        &quot;&quot;},
+        { &quot;1&quot;,       &quot;MQ==&quot;},
+        { &quot;22&quot;,      &quot;MjI=&quot;},
+        { &quot;333&quot;,     &quot;MzMz&quot;},
+        { &quot;4444&quot;,    &quot;NDQ0NA==&quot;},
+        { &quot;55555&quot;,   &quot;NTU1NTU=&quot;},
+        { &quot;666666&quot;,  &quot;NjY2NjY2&quot;},
+        { &quot;abc:def&quot;, &quot;YWJjOmRlZg==&quot;},
+    };
 
-            av_log(NULL, AV_LOG_ERROR, &quot;Test %d: Size %d bytes...&quot;,
-                   test_count, size);
-            data = (uint8_t *) av_malloc(size);
-            for (ii = 0; ii &lt; size; ii++) {
-                data[ii] = rand() % 255;
-            }
+    printf(&quot;Encoding/decoding tests\n&quot;);
+    for (i = 0; i &lt; FF_ARRAY_ELEMS(tests); i++)
+        error_count += test_encode_decode(tests[i].data, strlen(tests[i].data), tests[i].encoded_ref);
 
-            encoded_result = av_base64_encode(data, size);
-            if (encoded_result) {
-                int decode_buffer_size = size + 10;     // try without 10 as well
-                uint8_t *decode_buffer = av_malloc(decode_buffer_size);
-                if (decode_buffer) {
-                    int decoded_size =
-                        av_base64_decode(decode_buffer, encoded_result,
-                                   decode_buffer_size);
-
-                    if (decoded_size != size) {
-                        av_log(NULL, AV_LOG_ERROR,
-                               &quot;Decoded/Encoded size mismatch (%d != %d)\n&quot;,
-                               decoded_size, size);
-                    } else {
-                        if (memcmp(decode_buffer, data, decoded_size) == 0) {
-                            av_log(NULL, AV_LOG_ERROR, &quot;Passed!\n&quot;);
-                        } else {
-                            av_log(NULL, AV_LOG_ERROR,
-                                   &quot;Failed (Data differs)!\n&quot;);
-                        }
-                    }
-                    av_free(decode_buffer);
-                }
-
-                av_free(encoded_result);
-            }
-        }
-    }
-
-    // these are invalid strings, that it currently decodes (which it probably shouldn't?)
-    {
-        uint8_t str[32];
-        if (av_base64_decode(str, &quot;M=M=&quot;, sizeof(str)) != -1) {
-            av_log(NULL, AV_LOG_ERROR,
-                   &quot;failed test %d: successful decode of `M=M='\n&quot;,
-                   numtest++);
-            numerr++;
-        }
-        if (av_base64_decode(str, &quot;MQ===&quot;, sizeof(str)) != -1) {
-            av_log(NULL, AV_LOG_ERROR,
-                   &quot;failed test %d: successful decode of `MQ==='\n&quot;,
-                   numtest++);
-            numerr++;
-        }
-    }
-
-    return numerr;
+    return error_count;
 }
-#endif
 
+#endif

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/base64.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -1,5 +1,4 @@
 /*
- * Base64.c
  * Copyright (c) 2006 Ryan Martell. (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rdm4 at martellventures.com</A>)
  *
  * This file is part of FFmpeg.
@@ -19,22 +18,32 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#ifndef FFMPEG_BASE64_H
-#define FFMPEG_BASE64_H
+#ifndef AVUTIL_BASE64_H
+#define AVUTIL_BASE64_H
 
 #include &lt;stdint.h&gt;
 
 /**
- * decodes base64
- * param order as strncpy()
+ * Decodes the base64-encoded string in \p in and puts the decoded
+ * data in \p out.
+ *
+ * @param out_size size in bytes of the \p out buffer, it should be at
+ * least 3/4 of the length of \p in
+ * @return the number of bytes written, or a negative value in case of
+ * error
  */
-int av_base64_decode(uint8_t * out, const char *in, int out_length);
+int av_base64_decode(uint8_t *out, const char *in, int out_size);
 
 /**
- * encodes base64
- * @param src data, not a string
- * @param buf output string
+ * Encodes in base64 the data in \p in and puts the resulting string
+ * in \p out.
+ *
+ * @param out_size size in bytes of the \p out string, it should be at
+ * least ((\p in_size + 2) / 3) * 4 + 1
+ * @param in_size size in bytes of the \p in buffer
+ * @return the string containing the encoded data, or NULL in case of
+ * error
  */
-char *av_base64_encode(char * buf, int buf_len, const uint8_t * src, int len);
+char *av_base64_encode(char *out, int out_size, const uint8_t *in, int in_size);
 
-#endif /* FFMPEG_BASE64_H */
+#endif /* AVUTIL_BASE64_H */

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/bswap.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -19,83 +19,51 @@
  */
 
 /**
- * @file bswap.h
+ * @file libavutil/bswap.h
  * byte swapping routines
  */
 
-#ifndef FFMPEG_BSWAP_H
-#define FFMPEG_BSWAP_H
+#ifndef AVUTIL_BSWAP_H
+#define AVUTIL_BSWAP_H
 
 #include &lt;stdint.h&gt;
 #include &quot;config.h&quot;
 #include &quot;common.h&quot;
 
-#ifdef HAVE_BYTESWAP_H
-#include &lt;byteswap.h&gt;
-#else
+#if   ARCH_ARM
+#   include &quot;arm/bswap.h&quot;
+#elif ARCH_BFIN
+#   include &quot;bfin/bswap.h&quot;
+#elif ARCH_SH4
+#   include &quot;sh4/bswap.h&quot;
+#elif ARCH_X86
+#   include &quot;x86/bswap.h&quot;
+#endif
 
+#ifndef bswap_16
 static av_always_inline av_const uint16_t bswap_16(uint16_t x)
 {
-#if defined(ARCH_X86)
-    asm(&quot;rorw $8, %0&quot; : &quot;+r&quot;(x));
-#elif defined(ARCH_SH4)
-    asm(&quot;swap.b %0,%0&quot; : &quot;=r&quot;(x) : &quot;0&quot;(x));
-#elif defined(HAVE_ARMV6)
-    asm(&quot;rev16 %0, %0&quot; : &quot;+r&quot;(x));
-#else
     x= (x&gt;&gt;8) | (x&lt;&lt;8);
-#endif
     return x;
 }
+#endif
 
+#ifndef bswap_32
 static av_always_inline av_const uint32_t bswap_32(uint32_t x)
 {
-#if defined(ARCH_X86)
-#ifdef HAVE_BSWAP
-    asm(&quot;bswap   %0&quot; : &quot;+r&quot; (x));
-#else
-    asm(&quot;rorw    $8,  %w0 \n\t&quot;
-        &quot;rorl    $16, %0  \n\t&quot;
-        &quot;rorw    $8,  %w0&quot;
-        : &quot;+r&quot;(x));
-#endif
-#elif defined(ARCH_SH4)
-    asm(&quot;swap.b %0,%0\n&quot;
-        &quot;swap.w %0,%0\n&quot;
-        &quot;swap.b %0,%0\n&quot;
-        : &quot;=r&quot;(x) : &quot;0&quot;(x));
-#elif defined(HAVE_ARMV6)
-    asm(&quot;rev %0, %0&quot; : &quot;+r&quot;(x));
-#elif defined(ARCH_ARMV4L)
-    uint32_t t;
-    asm (&quot;eor %1, %0, %0, ror #16 \n\t&quot;
-         &quot;bic %1, %1, #0xFF0000   \n\t&quot;
-         &quot;mov %0, %0, ror #8      \n\t&quot;
-         &quot;eor %0, %0, %1, lsr #8  \n\t&quot;
-         : &quot;+r&quot;(x), &quot;+r&quot;(t));
-#elif defined(ARCH_BFIN)
-    unsigned tmp;
-    asm(&quot;%1 = %0 &gt;&gt; 8 (V);      \n\t&quot;
-        &quot;%0 = %0 &lt;&lt; 8 (V);      \n\t&quot;
-        &quot;%0 = %0 | %1;          \n\t&quot;
-        &quot;%0 = PACK(%0.L, %0.H); \n\t&quot;
-        : &quot;+d&quot;(x), &quot;=&amp;d&quot;(tmp));
-#else
     x= ((x&lt;&lt;8)&amp;0xFF00FF00) | ((x&gt;&gt;8)&amp;0x00FF00FF);
     x= (x&gt;&gt;16) | (x&lt;&lt;16);
-#endif
     return x;
 }
+#endif
 
+#ifndef bswap_64
 static inline uint64_t av_const bswap_64(uint64_t x)
 {
 #if 0
     x= ((x&lt;&lt; 8)&amp;0xFF00FF00FF00FF00ULL) | ((x&gt;&gt; 8)&amp;0x00FF00FF00FF00FFULL);
     x= ((x&lt;&lt;16)&amp;0xFFFF0000FFFF0000ULL) | ((x&gt;&gt;16)&amp;0x0000FFFF0000FFFFULL);
     return (x&gt;&gt;32) | (x&lt;&lt;32);
-#elif defined(ARCH_X86_64)
-  asm(&quot;bswap  %0&quot;: &quot;=r&quot; (x) : &quot;0&quot; (x));
-  return x;
 #else
     union {
         uint64_t ll;
@@ -107,12 +75,11 @@
     return r.ll;
 #endif
 }
+#endif
 
-#endif  /* !HAVE_BYTESWAP_H */
+// be2me ... big-endian to machine-endian
+// le2me ... little-endian to machine-endian
 
-// be2me ... BigEndian to MachineEndian
-// le2me ... LittleEndian to MachineEndian
-
 #ifdef WORDS_BIGENDIAN
 #define be2me_16(x) (x)
 #define be2me_32(x) (x)
@@ -129,4 +96,4 @@
 #define le2me_64(x) (x)
 #endif
 
-#endif /* FFMPEG_BSWAP_H */
+#endif /* AVUTIL_BSWAP_H */

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/common.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/common.h	2009-03-15 01:34:21 UTC (rev 29534)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/common.h	2009-03-15 01:34:41 UTC (rev 29535)
@@ -19,30 +19,30 @@
  */
 
 /**
- * @file common.h
+ * @file libavutil/common.h
  * common internal and external API header
  */
 
-#ifndef FFMPEG_COMMON_H
-#define FFMPEG_COMMON_H
+#ifndef AVUTIL_COMMON_H
+#define AVUTIL_COMMON_H
 
+#include &lt;ctype.h&gt;
+#include &lt;errno.h&gt;
 #include &lt;inttypes.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
 
-#ifdef HAVE_AV_CONFIG_H
-/* only include the following when compiling package */
-#    include &quot;config.h&quot;
+#ifdef __GNUC__
+#    define AV_GCC_VERSION_AT_LEAST(x,y) (__GNUC__ &gt; x || __GNUC__ == x &amp;&amp; __GNUC_MINOR__ &gt;= y)
+#else
+#    define AV_GCC_VERSION_AT_LEAST(x,y) 0
+#endif
 
-#    include &lt;stdlib.h&gt;
-#    include &lt;stdio.h&gt;
-#    include &lt;string.h&gt;
-#    include &lt;ctype.h&gt;
-#    include &lt;limits.h&gt;
-#    include &lt;errno.h&gt;
-#    include &lt;math.h&gt;
-#endif /* HAVE_AV_CONFIG_H */
-
 #ifndef av_always_inline
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
+#if AV_GCC_VERSION_AT_LEAST(3,1)
 #    define av_always_inline __attribute__((always_inline)) inline
 #else
 #    define av_always_inline inline
@@ -50,7 +50,7 @@
 #endif
 
 #ifndef av_noinline
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
+#if AV_GCC_VERSION_AT_LEAST(3,1)
 #    define av_noinline __attribute__((noinline))
 #else
 #    define av_noinline
@@ -58,7 +58,7 @@
 #endif
 
 #ifndef av_pure
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
+#if AV_GCC_VERSION_AT_LEAST(3,1)
 #    define av_pure __attribute__((pure))
 #else
 #    define av_pure
@@ -66,7 +66,7 @@
 #endif
 
 #ifndef av_const
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 2 || __GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt; 5)
+#if AV_GCC_VERSION_AT_LEAST(2,6)
 #    define av_const __attribute__((const))
 #else
 #    define av_const
@@ -74,19 +74,23 @@
 #endif
 
 #ifndef av_cold
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt; 2)
+#if (!defined(__ICC) || __ICC &gt; 1100) &amp;&amp; AV_GCC_VERSION_AT_LEAST(4,3)
 #    define av_cold __attribute__((cold))
 #else
 #    define av_cold
 #endif
 #endif
 
-#ifdef HAVE_AV_CONFIG_H
-#    include &quot;internal.h&quot;
-#endif /* HAVE_AV_CONFIG_H */
+#ifndef av_flatten
+#if AV_GCC_VERSION_AT_LEAST(4,1)
+#    define av_flatten __attribute__((flatten))
+#else
+#    define av_flatten
+#endif
+#endif
 
 #ifndef attribute_deprecated
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 3 || __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt; 0)
+#if AV_GCC_VERSION_AT_LEAST(3,1)
 #    define attribute_deprecated __attribute__((deprecated))
 #else
 #    define attribute_deprecated
@@ -101,9 +105,15 @@

[... truncated: 3491 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014867.html">[Haiku-commits] r29534 -	haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale
</A></li>
	<LI>Next message: <A HREF="014869.html">[Haiku-commits] r29536 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: . x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14868">[ date ]</a>
              <a href="thread.html#14868">[ thread ]</a>
              <a href="subject.html#14868">[ subject ]</a>
              <a href="author.html#14868">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
