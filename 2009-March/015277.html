<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29799 - in haiku/trunk/src/add-ons/media/plugins:	. APE_reader APE_reader/LibMonkeysAudio APE_reader/MAClib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29799%20-%20in%20haiku/trunk/src/add-ons/media/plugins%3A%0A%09.%20APE_reader%20APE_reader/LibMonkeysAudio%20APE_reader/MAClib&In-Reply-To=%3C200903300656.n2U6u04j014608%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015318.html">
   <LINK REL="Next"  HREF="015279.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29799 - in haiku/trunk/src/add-ons/media/plugins:	. APE_reader APE_reader/LibMonkeysAudio APE_reader/MAClib</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29799%20-%20in%20haiku/trunk/src/add-ons/media/plugins%3A%0A%09.%20APE_reader%20APE_reader/LibMonkeysAudio%20APE_reader/MAClib&In-Reply-To=%3C200903300656.n2U6u04j014608%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29799 - in haiku/trunk/src/add-ons/media/plugins:	. APE_reader APE_reader/LibMonkeysAudio APE_reader/MAClib">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Mar 30 08:56:00 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="015318.html">[Haiku-commits] r29798 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="015279.html">[Haiku-commits] r29800 - haiku/trunk/build/jam
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15277">[ date ]</a>
              <a href="thread.html#15277">[ thread ]</a>
              <a href="subject.html#15277">[ subject ]</a>
              <a href="author.html#15277">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2009-03-30 08:55:56 +0200 (Mon, 30 Mar 2009)
New Revision: 29799
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29799&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29799&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/APE_reader/
   haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/Jamfile
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/Jamfile
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/MonkeysAudioMIMEType.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCore.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCore.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCreate.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCreate.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEDecompress.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEDecompress.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEHeader.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEHeader.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEInfo.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APEInfo.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APELink.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APELink.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APESimple.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APETag.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APETag.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/All.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Assembly.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Assembly.nasm
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/BitArray.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/BitArray.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/CharacterHelper.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/CharacterHelper.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/CircleBuffer.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/CircleBuffer.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/GlobalFunctions.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/GlobalFunctions.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/ID3Genres.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/IO.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Jamfile
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MACLib.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MACLib.dsp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MACLib.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MACProgressHelper.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MACProgressHelper.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MD5.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/MD5.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/NNFilter.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/NNFilter.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/NewPredictor.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/NewPredictor.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/NoWindows.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Predictor.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Prepare.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Prepare.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/RollBuffer.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/ScaledFirstOrderFilter.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/SmartPtr.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/StartFilter.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/StdLibFileIO.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/StdLibFileIO.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/Tools.inc
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/UnBitArray.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/UnBitArray.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/UnBitArrayBase.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/UnBitArrayBase.h
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/WAVInputSource.cpp
   haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/WAVInputSource.h
Log:
APE Reader from sources donated by SHINTA

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.cpp	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.cpp	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,219 @@
+#include &lt;InterfaceDefs.h&gt;
+
+/*============================================================================*/
+const char*	gAppName = &quot;APE (Monkey's Audio) reader&quot;;
+const char*	gAppVer = &quot;Ver 1.12&quot;;
+const char*	gCright = &quot;Copyright &quot;B_UTF8_COPYRIGHT&quot; 2005-2008 by SHINTA&quot;;
+const char*	gAppSignature = &quot;application/x-vnd.SHINTA-MediaKitAPEReader&quot;;
+/*============================================================================*/
+
+/*=== Memo =====================================================================
+==============================================================================*/
+
+//------------------------------------------------------------------------------
+#include &quot;APEReader.h&quot;
+//------------------------------------------------------------------------------
+// BeOS
+// C++
+// MAC
+#include &quot;MACLib.h&quot;
+// Proj
+//------------------------------------------------------------------------------
+//==============================================================================
+TAPEReader::TAPEReader()
+		: SUPER()
+{
+	mDecodedData = NULL;
+	mDecomp = NULL;
+	Unset();
+}
+//------------------------------------------------------------------------------
+TAPEReader::~TAPEReader()
+{
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::AllocateCookie(int32 oStreamNumber, void** oCookie)
+{
+	*oCookie = NULL;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+const char*	TAPEReader::Copyright()
+{
+	return gCright;
+}
+//------------------------------------------------------------------------------
+bigtime_t	TAPEReader::CurrentTime() const
+{
+	return mDecomp-&gt;GetInfo(APE_DECOMPRESS_CURRENT_MS)*static_cast&lt;bigtime_t&gt;(1000);
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::FreeCookie(void* oCookie)
+{
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+void	TAPEReader::GetFileFormatInfo(media_file_format* oMFF)
+{
+	oMFF-&gt;capabilities = media_file_format::B_READABLE
+			| media_file_format::B_PERFECTLY_SEEKABLE
+//			| media_file_format::B_IMPERFECTLY_SEEKABLE
+			| media_file_format::B_KNOWS_RAW_AUDIO
+			| media_file_format::B_KNOWS_ENCODED_AUDIO;
+	oMFF-&gt;family = B_ANY_FORMAT_FAMILY;
+	oMFF-&gt;version = MEDIA_FILE_FORMAT_VERSION;
+	strcpy(oMFF-&gt;mime_type, MIME_TYPE_APE);
+	strcpy(oMFF-&gt;pretty_name, MIME_TYPE_APE_LONG_DESCRIPTION);
+	strcpy(oMFF-&gt;short_name, MIME_TYPE_APE_SHORT_DESCRIPTION);
+	strcpy(oMFF-&gt;file_extension, MIME_TYPE_APE_EXTENSION);
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::GetNextChunk(void* oCookie, const void** oChunkBuffer, size_t* oChunkSize, media_header* oMediaHeader)
+{
+	int64		aOutSize;
+
+	// check whether song is finished or not
+	if ( mReadPosTotal-mReadPos+mPlayPos &gt;= mDataSize )
+		return B_ERROR;
+	// reading data
+	if ( mPlayPos &gt;= mReadPos ) {
+		ReadBlocks();
+	}
+	// passing data
+	if ( mReadPos-mPlayPos &gt;= BUFFER_SIZE ) {
+		aOutSize = BUFFER_SIZE;
+	} else {
+		aOutSize = mReadPos-mPlayPos;
+	}
+	*oChunkBuffer = &amp;mDecodedData[mPlayPos];
+	mPlayPos += aOutSize;
+	// passing info
+	*oChunkSize = aOutSize;
+	oMediaHeader-&gt;start_time = CurrentTime();
+	oMediaHeader-&gt;file_pos = mPlayPos;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::GetStreamInfo(void* oCookie, int64* oFrameCount, bigtime_t* oDuration, media_format* oFormat,
+		const void** oInfoBuffer, size_t* oInfoSize)
+{
+	if ( LoadAPECheck() != B_OK )
+		return LoadAPECheck();
+	*oFrameCount = mDataSize/(mDecomp-&gt;GetInfo(APE_INFO_BITS_PER_SAMPLE)/8*mDecomp-&gt;GetInfo(APE_INFO_CHANNELS));
+	*oDuration = mDecomp-&gt;GetInfo(APE_INFO_LENGTH_MS)*static_cast&lt;bigtime_t&gt;(1000);
+	// media_format
+	oFormat-&gt;type = B_MEDIA_RAW_AUDIO;
+	oFormat-&gt;u.raw_audio.frame_rate = mDecomp-&gt;GetInfo(APE_INFO_SAMPLE_RATE);
+	oFormat-&gt;u.raw_audio.channel_count = mDecomp-&gt;GetInfo(APE_INFO_CHANNELS);
+	if ( mDecomp-&gt;GetInfo(APE_INFO_BITS_PER_SAMPLE) == 16 ) {
+		oFormat-&gt;u.raw_audio.format = media_raw_audio_format::B_AUDIO_SHORT;
+	} else {
+		oFormat-&gt;u.raw_audio.format = media_raw_audio_format::B_AUDIO_UCHAR;
+	}
+	oFormat-&gt;u.raw_audio.byte_order = B_MEDIA_LITTLE_ENDIAN;
+	oFormat-&gt;u.raw_audio.buffer_size = BUFFER_SIZE;
+	oInfoBuffer = NULL;
+	oInfoSize = NULL;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::LoadAPECheck() const
+{
+	return mLoadAPECheck;
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::ReadBlocks()
+{
+	int		aBlocksRead;
+	int		aRetVal = 0;
+
+	aRetVal = mDecomp-&gt;GetData(reinterpret_cast&lt;char*&gt;(mDecodedData), BLOCK_COUNT, &amp;aBlocksRead);
+	if ( aRetVal != ERROR_SUCCESS ) {
+		return B_ERROR;
+	}
+	mPlayPos = 0;
+	mReadPos = aBlocksRead*mDecomp-&gt;GetInfo(APE_INFO_BLOCK_ALIGN);
+	mReadPosTotal += mReadPos;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::Seek(void* oCookie, uint32 oFlags, int64* oFrame, bigtime_t* oTime)
+{
+	return B_ERROR;
+#if 0	// not work in Haiku
+	int32		aNewBlock;
+
+	if ( oFlags&amp;B_MEDIA_SEEK_TO_FRAME ) {
+		DBEXP(&quot;TAPEReader::Seek()&quot;, &quot;Seek by frame not supported yet&quot;);
+		return B_ERROR;
+	} else if ( oFlags&amp;B_MEDIA_SEEK_TO_TIME ) {
+		DBEXP(&quot;TAPEReader::Seek() - B_MEDIA_SEEK_TO_TIME&quot;, *oTime);
+		aNewBlock = (*oTime)/1000*mDecomp-&gt;GetInfo(APE_DECOMPRESS_TOTAL_BLOCKS)/mDecomp-&gt;GetInfo(APE_DECOMPRESS_LENGTH_MS);
+		DBEXP(&quot;TAPEReader::Seek() - aNewBlock&quot;, aNewBlock);
+	} else {
+		return B_ERROR;
+	}
+	mReadPosTotal = aNewBlock*mDecomp-&gt;GetInfo(APE_INFO_BLOCK_ALIGN);
+	int a = mDecomp-&gt;Seek(aNewBlock);
+	ReadBlocks();
+	return B_OK;
+#endif
+}
+//------------------------------------------------------------------------------
+status_t	TAPEReader::Sniff(int32* oStreamCount)
+{
+	Unset();
+	// prepare about file
+	mSrcPIO = dynamic_cast&lt;BPositionIO*&gt;(Source());
+	if ( mSrcPIO == NULL )
+		return B_ERROR;
+	mPositionBridgeIO.SetPositionIO(mSrcPIO);
+	mDecomp = CreateIAPEDecompressEx(&amp;mPositionBridgeIO);
+	if ( mDecomp == NULL )
+		return B_ERROR;
+	// prepare about data
+	mDataSize = static_cast&lt;int64&gt;(mDecomp-&gt;GetInfo(APE_DECOMPRESS_TOTAL_BLOCKS))
+			*mDecomp-&gt;GetInfo(APE_INFO_BLOCK_ALIGN);
+	mDecodedData = new char [max_c(BUFFER_SIZE*mDecomp-&gt;GetInfo(APE_INFO_CHANNELS),
+			BLOCK_COUNT*mDecomp-&gt;GetInfo(APE_INFO_BLOCK_ALIGN))];
+	mLoadAPECheck = B_OK;
+	*oStreamCount = 1;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+void	TAPEReader::Unset()
+{
+	mLoadAPECheck = B_NO_INIT;
+	// about file
+	mPositionBridgeIO.SetPositionIO(NULL);
+	mSrcPIO = NULL;
+	delete mDecomp;
+	// about data
+	mDataSize = 0;
+	mReadPos = 0;
+	mReadPosTotal = 0;
+	mPlayPos = 0;
+	delete [] mDecodedData;
+}
+//------------------------------------------------------------------------------
+//==============================================================================
+TAPEReaderPlugin::TAPEReaderPlugin()
+{
+}
+//------------------------------------------------------------------------------
+TAPEReaderPlugin::~TAPEReaderPlugin()
+{
+}
+//------------------------------------------------------------------------------
+Reader*	TAPEReaderPlugin::NewReader()
+{
+	return new TAPEReader();
+}
+//------------------------------------------------------------------------------
+//==============================================================================
+MediaPlugin*	instantiate_plugin()
+{
+	return new TAPEReaderPlugin();
+}
+//------------------------------------------------------------------------------
+//==============================================================================

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.h	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/APEReader.h	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,68 @@
+#ifndef	___APEReader_H_
+#define	___APEReader_H_
+//------------------------------------------------------------------------------
+// BeOS
+// MAC
+#include &quot;MACLib.h&quot;
+#include &quot;MonkeysAudioMIMEType.h&quot;
+#include &quot;PositionBridgeIO.h&quot;
+// Proj
+#include &quot;ReaderPlugin.h&quot;		// Haiku private header
+//------------------------------------------------------------------------------
+const int32		BLOCK_COUNT = 1024*4;				// number of blocks, get from MACLib at once
+const int32		BUFFER_SIZE = 1024*4;				// size of audio data passing to Media Kit
+const int32		MEDIA_FILE_FORMAT_VERSION = 100;	// media_file_format::version
+//==============================================================================
+class	TAPEReader : public Reader
+{
+public:
+	TAPEReader();
+	virtual	~TAPEReader();
+
+	virtual	const char*	Copyright();
+
+	virtual	status_t	Sniff(int32* oStreamCount);
+
+	virtual	void		GetFileFormatInfo(media_file_format* oMFF);
+
+	virtual	status_t	AllocateCookie(int32 oStreamNumber, void** oCookie);
+	virtual	status_t	FreeCookie(void* oCookie);
+
+	virtual	status_t	GetStreamInfo(void* oCookie, int64* oFrameCount, bigtime_t* oDuration, media_format* oFormat,
+								const void** oInfoBuffer, size_t* oInfoSize);
+
+	virtual	status_t	Seek(void* oCookie, uint32 oFlags, int64* oFrame, bigtime_t* oTime);
+
+	virtual	status_t	GetNextChunk(void* oCookie, const void** oChunkBuffer, size_t* oChunkSize, media_header* oMediaHeader);
+
+private:
+	typedef	Reader	SUPER;
+
+	bigtime_t			CurrentTime() const;
+	status_t			LoadAPECheck() const;
+	status_t			ReadBlocks();
+	void				Unset();
+
+	char*				mDecodedData;				// data after decoding
+	int64				mDataSize;
+	int64				mPlayPos;
+	int64				mReadPos;
+	int64				mReadPosTotal;
+	status_t			mLoadAPECheck;
+	BPositionIO*		mSrcPIO;
+	IAPEDecompress*		mDecomp;
+	TPositionBridgeIO	mPositionBridgeIO;
+};
+//==============================================================================
+class	TAPEReaderPlugin : public ReaderPlugin
+{
+public:
+	TAPEReaderPlugin();
+	virtual	~TAPEReaderPlugin();
+
+	virtual	Reader*	NewReader();
+};
+//==============================================================================
+MediaPlugin*	instantiate_plugin();
+//==============================================================================
+#endif	// ___APEReader_H_

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/Jamfile	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/Jamfile	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,16 @@
+SubDir HAIKU_TOP src add-ons media plugins APE_reader ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+UsePrivateHeaders media ;
+
+SubDirHdrs [ FDirName $(SUBDIR) LibMonkeysAudio ] ;
+SubDirHdrs [ FDirName $(SUBDIR) MAClib ] ;
+
+Addon APE_reader :
+	APEReader.cpp
+	: libMonkeysAudio.a MAClib.a be libmedia.so
+;
+
+SubInclude HAIKU_TOP src add-ons media plugins APE_reader LibMonkeysAudio ;
+SubInclude HAIKU_TOP src add-ons media plugins APE_reader MAClib ;

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/Jamfile	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/Jamfile	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,10 @@
+SubDir HAIKU_TOP src add-ons media plugins APE_reader LibMonkeysAudio ;
+
+SubDirHdrs [ FDirName $(SUBDIR) ../MAClib ] ;
+
+SubDirAsFlags -DWIN32=1 ;
+
+StaticLibrary libMonkeysAudio.a :
+	PositionBridgeIO.cpp
+	LibMonkeysAudio.cpp
+	;

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.cpp	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.cpp	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,59 @@
+#include &lt;InterfaceDefs.h&gt;
+
+/*============================================================================*/
+const char*	gAppName = &quot;Lib Monkey's Audio&quot;;
+const char*	gAppVer = &quot;Ver 1.65&quot;;
+const char*	gCright = &quot;Copyright &quot;B_UTF8_COPYRIGHT&quot; 2003-2008 by SHINTA&quot;;
+const char*	gOriginal = &quot;MAC library Copyright &quot;B_UTF8_COPYRIGHT&quot; by Matthew T. Ashland&quot;;
+const char*	gAppSignature = &quot;application/x-vnd.SHINTA-LibMonkeysAudio&quot;;
+/*============================================================================*/
+
+/*=== Memo =====================================================================
+==============================================================================*/
+
+//------------------------------------------------------------------------------
+#include &quot;LibMonkeysAudio.h&quot;
+//------------------------------------------------------------------------------
+// BeOS
+// C++
+#include &lt;string&gt;
+// Add2
+//===========================================================================
+CAPETag*	create_capetag_1(CIO* oIO, BOOL oAnalyze)
+{
+	return new CAPETag(oIO, oAnalyze);
+}
+//------------------------------------------------------------------------------
+CAPETag*	create_capetag_2(const char* oFilename, BOOL oAnalyze)
+{
+	return new CAPETag(oFilename, oAnalyze);
+}
+//------------------------------------------------------------------------------
+void	destroy_capetag(CAPETag* oAPETag)
+{
+	delete oAPETag;
+}
+//------------------------------------------------------------------------------
+const char*	lib_monkeys_audio_components()
+{
+	return gOriginal;
+}
+//------------------------------------------------------------------------------
+const char*	lib_monkeys_audio_copyright()
+{
+	static string	saCright;
+
+	saCright = string(gCright)+&quot;\n&quot;+gOriginal;
+	return saCright.c_str();
+}
+//------------------------------------------------------------------------------
+const char*	lib_monkeys_audio_name()
+{
+	return gAppName;
+}
+//------------------------------------------------------------------------------
+const char*	lib_monkeys_audio_version()
+{
+	return gAppVer;
+}
+//===========================================================================

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.h	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/LibMonkeysAudio.h	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,20 @@
+#ifndef	___LibMonkeysAudio_H_
+#define	___LibMonkeysAudio_H_
+//---------------------------------------------------------------------------
+// BeOS Header
+// C++ Header
+// Project Header
+#include &quot;APETag.h&quot;
+//===========================================================================
+extern &quot;C&quot;
+{
+	_EXPORT CAPETag*	create_capetag_1(CIO* oIO, BOOL oAnalyze = TRUE);
+	_EXPORT CAPETag*	create_capetag_2(const char* oFilename, BOOL oAnalyze = TRUE);
+	_EXPORT void		destroy_capetag(CAPETag* oAPETag);
+	_EXPORT const char*	lib_monkeys_audio_components();
+	_EXPORT const char*	lib_monkeys_audio_copyright();
+	_EXPORT const char*	lib_monkeys_audio_name();
+	_EXPORT const char*	lib_monkeys_audio_version();
+}
+//===========================================================================
+#endif	// ___LibMonkeysAudio_H_

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/MonkeysAudioMIMEType.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/MonkeysAudioMIMEType.h	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/MonkeysAudioMIMEType.h	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,10 @@
+#ifndef	___MONKEYS_AUDIO_MIME_TYPE_H_
+#define	___MONKEYS_AUDIO_MIME_TYPE_H_
+//---------------------------------------------------------------------------
+//===========================================================================
+const char	MIME_TYPE_APE[] = &quot;audio/x-ape&quot;;
+const char	MIME_TYPE_APE_EXTENSION[] = &quot;ape&quot;;
+const char	MIME_TYPE_APE_SHORT_DESCRIPTION[] = &quot;APE (Monkey's Audio) Sound File&quot;;
+const char	MIME_TYPE_APE_LONG_DESCRIPTION[] = &quot;Lossless Compressed APE (Monkey's Audio) Sound File&quot;;
+//===========================================================================
+#endif	// ___MONKEYS_AUDIO_MIME_TYPE_H_

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.cpp	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.cpp	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,117 @@
+/*==============================================================================
+	Bridge class for passing BPositionIO to functions who need CIO in MACLib
+	Ver 1.01
+	Copyright (C) 2005-2008 by SHINTA
+==============================================================================*/
+
+/*==============================================================================
+BPositionIO* passed to SetPositionIO() must not be released before rleasing this class.
+==============================================================================*/
+
+//------------------------------------------------------------------------------
+#include &quot;PositionBridgeIO.h&quot;
+//------------------------------------------------------------------------------
+// BeOS
+// C++
+// Proj
+#include &quot;All.h&quot;
+//------------------------------------------------------------------------------
+//==============================================================================
+TPositionBridgeIO::TPositionBridgeIO()
+		: CIO()
+{
+	mPositionIO = NULL;
+}
+//------------------------------------------------------------------------------
+TPositionBridgeIO::~TPositionBridgeIO()
+{
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Close()
+{
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Create(const wchar_t* oName)
+{
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Delete()
+{
+	return B_ERROR;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::GetName(wchar_t* oBuffer)
+{
+	strcpy(oBuffer, &quot;&lt;TPositionBridgeIO&gt;&quot;);
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::GetPosition()
+{
+	if ( mPositionIO == NULL )
+		return 0;
+	return mPositionIO-&gt;Position();
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::GetSize()
+{
+	off_t	aCurPos;
+	off_t	aSize;
+
+	if ( mPositionIO == NULL )
+		return 0;
+	aCurPos = mPositionIO-&gt;Position();
+	mPositionIO-&gt;Seek(0, SEEK_END);
+	aSize = mPositionIO-&gt;Position();
+	mPositionIO-&gt;Seek(aCurPos, SEEK_SET);
+	return aSize;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Open(const wchar_t* oName)
+{
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Read(void* oBuf, unsigned int oBytesToRead, unsigned int* oBytesRead)
+{
+	if ( mPositionIO == NULL )
+		return ERROR_IO_READ;
+	*oBytesRead = mPositionIO-&gt;Read(oBuf, oBytesToRead);
+	return *oBytesRead == 0 ? ERROR_IO_READ : B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::Seek(int oDistance, unsigned int oMoveMode)
+{
+	if ( mPositionIO == NULL )
+		return B_ERROR;
+	return mPositionIO-&gt;Seek(oDistance, oMoveMode) &lt; B_OK ? B_ERROR : B_OK;
+}
+//------------------------------------------------------------------------------
+int	TPositionBridgeIO::SetEOF()
+{
+	if ( mPositionIO == NULL )
+		return B_ERROR;
+	mPositionIO-&gt;SetSize(mPositionIO-&gt;Position());
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+status_t	TPositionBridgeIO::SetPositionIO(BPositionIO* oPositionIO)
+{
+	mPositionIO = oPositionIO;
+	return B_OK;
+}
+//------------------------------------------------------------------------------
+/* ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
+untested function
+'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''' */
+int	TPositionBridgeIO::Write(const void* oBuf, unsigned int oBytesToWrite, unsigned int* oBytesWritten)
+{
+	if ( mPositionIO == NULL )
+		return ERROR_IO_WRITE;
+	*oBytesWritten = mPositionIO-&gt;Write(oBuf, oBytesToWrite);
+	return *oBytesWritten != oBytesToWrite ? ERROR_IO_WRITE : B_OK;
+}
+//------------------------------------------------------------------------------
+//==============================================================================

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.h	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/LibMonkeysAudio/PositionBridgeIO.h	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,42 @@
+#ifndef	___POSITION_BRIDGE_IO_H_
+#define	___POSITION_BRIDGE_IO_H_
+//------------------------------------------------------------------------------
+// BeOS
+#include &lt;DataIO.h&gt;
+#include &lt;SupportDefs.h&gt;
+// C++
+// MAC
+#include &quot;NoWindows.h&quot;	// before IO.h
+#include &quot;IO.h&quot;
+//------------------------------------------------------------------------------
+//==============================================================================
+class	TPositionBridgeIO : public CIO
+{
+public:
+	TPositionBridgeIO();
+	virtual	~TPositionBridgeIO();
+
+	virtual int	Open(const wchar_t* oName);
+	virtual int	Close();
+
+	virtual int	Read(void* oBuf, unsigned int oBytesToRead, unsigned int* oBytesRead);
+	virtual int	Write(const void* oBuf, unsigned int oBytesToWrite, unsigned int* oBytesWritten);
+
+	virtual int	Seek(int oDistance, unsigned int oMoveMode);
+
+	virtual int	Create(const wchar_t* oName);
+	virtual int	Delete();
+
+	virtual int	SetEOF();
+
+	virtual int	GetPosition();
+	virtual int	GetSize();
+	virtual int	GetName(wchar_t* oBuffer);
+
+	status_t	SetPositionIO(BPositionIO* oPositionIO);
+
+private:
+	BPositionIO*	mPositionIO;
+};
+//==============================================================================
+#endif	// ___POSITION_BRIDGE_IO_H_

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.cpp	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.cpp	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,246 @@
+#include &quot;All.h&quot;
+#include &quot;APECompress.h&quot;
+#include IO_HEADER_FILE
+#include &quot;APECompressCreate.h&quot;
+#include &quot;WAVInputSource.h&quot;
+
+CAPECompress::CAPECompress()
+{
+    m_nBufferHead        = 0;
+    m_nBufferTail        = 0;
+    m_nBufferSize        = 0;
+    m_bBufferLocked        = FALSE;
+    m_bOwnsOutputIO        = FALSE;
+    m_pioOutput            = NULL;
+
+    m_spAPECompressCreate.Assign(new CAPECompressCreate());
+
+    m_pBuffer = NULL;
+}
+
+CAPECompress::~CAPECompress()
+{
+    SAFE_ARRAY_DELETE(m_pBuffer)
+
+    if (m_bOwnsOutputIO)
+    {
+        SAFE_DELETE(m_pioOutput)
+    }
+}
+
+int CAPECompress::Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
+{
+    m_pioOutput = new IO_CLASS_NAME;
+    m_bOwnsOutputIO = TRUE;
+    
+    if (m_pioOutput-&gt;Create(pOutputFilename) != 0)
+    {
+        return ERROR_INVALID_OUTPUT_FILE;
+    }
+        
+    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
+        pHeaderData, nHeaderBytes);
+    
+    SAFE_ARRAY_DELETE(m_pBuffer)
+    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
+    m_pBuffer = new unsigned char [m_nBufferSize];
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
+{
+    m_pioOutput = pioOutput;
+    m_bOwnsOutputIO = FALSE;
+
+    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
+        pHeaderData, nHeaderBytes);
+
+    SAFE_ARRAY_DELETE(m_pBuffer)
+    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
+    m_pBuffer = new unsigned char [m_nBufferSize];
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::GetBufferBytesAvailable()
+{
+    return m_nBufferSize - m_nBufferTail;
+}
+
+int CAPECompress::UnlockBuffer(int nBytesAdded, BOOL bProcess)
+{
+    if (m_bBufferLocked == FALSE)
+        return ERROR_UNDEFINED;
+    
+    m_nBufferTail += nBytesAdded;
+    m_bBufferLocked = FALSE;
+    
+    if (bProcess)
+    {
+        int nRetVal = ProcessBuffer();
+        if (nRetVal != 0) { return nRetVal; }
+    }
+    
+    return ERROR_SUCCESS;
+}
+
+unsigned char * CAPECompress::LockBuffer(int * pBytesAvailable)
+{
+    if (m_pBuffer == NULL) { return NULL; }
+    
+    if (m_bBufferLocked)
+        return NULL;
+    
+    m_bBufferLocked = TRUE;
+    
+    if (pBytesAvailable)
+        *pBytesAvailable = GetBufferBytesAvailable();
+    
+    return &amp;m_pBuffer[m_nBufferTail];
+}
+
+int CAPECompress::AddData(unsigned char * pData, int nBytes)
+{
+    if (m_pBuffer == NULL) return ERROR_INSUFFICIENT_MEMORY;
+
+    int nBytesDone = 0;
+    
+    while (nBytesDone &lt; nBytes)
+    {
+        // lock the buffer
+        int nBytesAvailable = 0;
+        unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
+        if (pBuffer == NULL || nBytesAvailable &lt;= 0)
+            return ERROR_UNDEFINED;
+        
+        // calculate how many bytes to copy and add that much to the buffer
+        int nBytesToProcess = min(nBytesAvailable, nBytes - nBytesDone);
+        memcpy(pBuffer, &amp;pData[nBytesDone], nBytesToProcess);
+                        
+        // unlock the buffer (fail if not successful)
+        int nRetVal = UnlockBuffer(nBytesToProcess);
+        if (nRetVal != ERROR_SUCCESS)
+                return nRetVal;
+
+        // update our progress
+        nBytesDone += nBytesToProcess;
+    }
+
+    return ERROR_SUCCESS;
+} 
+
+int CAPECompress::Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes)
+{
+    RETURN_ON_ERROR(ProcessBuffer(TRUE))
+    return m_spAPECompressCreate-&gt;Finish(pTerminatingData, nTerminatingBytes, nWAVTerminatingBytes);
+}
+
+int CAPECompress::Kill()
+{
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::ProcessBuffer(BOOL bFinalize)
+{
+    if (m_pBuffer == NULL) { return ERROR_UNDEFINED; }
+    
+    try
+    {
+        // process as much as possible
+        int nThreshold = (bFinalize) ? 0 : m_spAPECompressCreate-&gt;GetFullFrameBytes();
+        
+        while ((m_nBufferTail - m_nBufferHead) &gt;= nThreshold)
+        {
+            int nFrameBytes = min(m_spAPECompressCreate-&gt;GetFullFrameBytes(), m_nBufferTail - m_nBufferHead);
+            
+            if (nFrameBytes == 0)
+                break;
+
+            int nRetVal = m_spAPECompressCreate-&gt;EncodeFrame(&amp;m_pBuffer[m_nBufferHead], nFrameBytes);
+            if (nRetVal != 0) { return nRetVal; }
+            
+            m_nBufferHead += nFrameBytes;
+        }
+        
+        // shift the buffer
+        if (m_nBufferHead != 0)
+        {
+            int nBytesLeft = m_nBufferTail - m_nBufferHead;
+            
+            if (nBytesLeft != 0)
+                memmove(m_pBuffer, &amp;m_pBuffer[m_nBufferHead], nBytesLeft);
+            
+            m_nBufferTail -= m_nBufferHead;
+            m_nBufferHead = 0;
+        }
+    }
+    catch(...)
+    {
+        return ERROR_UNDEFINED;
+    }
+    
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes, int * pBytesAdded)
+{
+    // error check the parameters
+    if (pInputSource == NULL) return ERROR_BAD_PARAMETER;
+
+    // initialize
+    if (pBytesAdded) *pBytesAdded = 0;
+        
+    // lock the buffer
+    int nBytesAvailable = 0;
+    unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
+    if ((pBuffer == NULL) || (nBytesAvailable == 0))
+        return ERROR_INSUFFICIENT_MEMORY;
+    
+    // calculate the 'ideal' number of bytes
+    unsigned int nBytesRead = 0;
+
+    int nIdealBytes = m_spAPECompressCreate-&gt;GetFullFrameBytes() - (m_nBufferTail - m_nBufferHead);
+    if (nIdealBytes &gt; 0)
+    {
+        // get the data
+        int nBytesToAdd = nBytesAvailable;
+        
+        if (nMaxBytes &gt; 0)
+        {
+            if (nBytesToAdd &gt; nMaxBytes) nBytesToAdd = nMaxBytes;
+        }
+
+        if (nBytesToAdd &gt; nIdealBytes) nBytesToAdd = nIdealBytes;
+
+        // always make requests along block boundaries
+        while ((nBytesToAdd % m_wfeInput.nBlockAlign) != 0)
+            nBytesToAdd--;
+
+        int nBlocksToAdd = nBytesToAdd / m_wfeInput.nBlockAlign;
+
+        // get data
+        int nBlocksAdded = 0;
+        int nRetVal = pInputSource-&gt;GetData(pBuffer, nBlocksToAdd, &amp;nBlocksAdded);
+        if (nRetVal != 0)
+            return ERROR_IO_READ;
+        else
+            nBytesRead = (nBlocksAdded * m_wfeInput.nBlockAlign);
+        
+        // store the bytes read
+        if (pBytesAdded)
+            *pBytesAdded = nBytesRead;
+    }
+        
+    // unlock the data and process
+    int nRetVal = UnlockBuffer(nBytesRead, TRUE);
+    if (nRetVal != 0)
+    {
+        return nRetVal;
+    }
+    
+    return ERROR_SUCCESS;
+}
+

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.h	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompress.h	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,56 @@
+#ifndef APE_APECOMPRESS_H
+#define APE_APECOMPRESS_H
+
+#include &quot;MACLib.h&quot;
+class CAPECompressCreate;
+
+/*************************************************************************************************
+CAPECompress - uses the CAPECompressHub to provide a simpler compression interface (with buffering, etc)
+*************************************************************************************************/
+class CAPECompress : public IAPECompress
+{
+public:
+
+    CAPECompress();
+    ~CAPECompress();
+
+    // start encoding
+    int Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
+    int StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
+    
+    // add data / compress data
+
+    // allows linear, immediate access to the buffer (fast)
+    int GetBufferBytesAvailable();
+    int UnlockBuffer(int nBytesAdded, BOOL bProcess = TRUE);
+    unsigned char * LockBuffer(int * pBytesAvailable);
+    
+    // slower, but easier than locking and unlocking (copies data)
+    int AddData(unsigned char * pData, int nBytes);
+    
+    // use a CIO (input source) to add data
+    int AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes = -1, int * pBytesAdded = NULL);
+    
+    // finish / kill
+    int Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes);
+    int Kill();
+    
+private:
+    
+    int    ProcessBuffer(BOOL bFinalize = FALSE);
+    
+    CSmartPtr&lt;CAPECompressCreate&gt; m_spAPECompressCreate;
+
+    int                m_nBufferHead;
+    int                m_nBufferTail;
+    int                m_nBufferSize;
+    unsigned char * m_pBuffer;
+    BOOL            m_bBufferLocked;
+
+    CIO    *            m_pioOutput;
+    BOOL            m_bOwnsOutputIO;
+    WAVEFORMATEX    m_wfeInput;
+
+};
+
+#endif // #ifndef APE_APECOMPRESS_H

Added: haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCore.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCore.cpp	2009-03-30 06:52:51 UTC (rev 29798)
+++ haiku/trunk/src/add-ons/media/plugins/APE_reader/MAClib/APECompressCore.cpp	2009-03-30 06:55:56 UTC (rev 29799)
@@ -0,0 +1,126 @@
+#include &quot;All.h&quot;
+#include &quot;APECompressCore.h&quot;
+
+#include &quot;BitArray.h&quot;
+#include &quot;Prepare.h&quot;
+#include &quot;NewPredictor.h&quot;
+
+CAPECompressCore::CAPECompressCore(CIO * pIO, const WAVEFORMATEX * pwfeInput, int nMaxFrameBlocks, int nCompressionLevel)
+{
+    m_spBitArray.Assign(new CBitArray(pIO));
+    m_spDataX.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spDataY.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spTempData.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spPrepare.Assign(new CPrepare);
+    m_spPredictorX.Assign(new CPredictorCompressNormal(nCompressionLevel));
+    m_spPredictorY.Assign(new CPredictorCompressNormal(nCompressionLevel));
+
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+    m_nPeakLevel = 0;
+}
+
+CAPECompressCore::~CAPECompressCore()
+{
+}
+
+int CAPECompressCore::EncodeFrame(const void * pInputData, int nInputBytes)
+{
+    // variables
+    const int nInputBlocks = nInputBytes / m_wfeInput.nBlockAlign;
+    int nSpecialCodes = 0;
+
+    // always start a new frame on a byte boundary
+    m_spBitArray-&gt;AdvanceToByteBoundary();
+    
+    // do the preparation stage
+    RETURN_ON_ERROR(Prepare(pInputData, nInputBytes, &amp;nSpecialCodes))
+
+    m_spPredictorX-&gt;Flush();
+    m_spPredictorY-&gt;Flush();
+
+    m_spBitArray-&gt;FlushState(m_BitArrayStateX);
+    m_spBitArray-&gt;FlushState(m_BitArrayStateY);
+
+    m_spBitArray-&gt;FlushBitArray();
+
+    if (m_wfeInput.nChannels == 2) 
+    {
+        BOOL bEncodeX = TRUE;
+        BOOL bEncodeY = TRUE;
+        
+        if ((nSpecialCodes &amp; SPECIAL_FRAME_LEFT_SILENCE) &amp;&amp; 
+            (nSpecialCodes &amp; SPECIAL_FRAME_RIGHT_SILENCE)) 
+        {
+            bEncodeX = FALSE;
+            bEncodeY = FALSE;
+        }
+        
+        if (nSpecialCodes &amp; SPECIAL_FRAME_PSEUDO_STEREO) 
+        {
+            bEncodeY = FALSE;
+        }
+        
+        if (bEncodeX &amp;&amp; bEncodeY)
+        {
+            int nLastX = 0;
+            for (int z = 0; z &lt; nInputBlocks; z++)

[... truncated: 9796 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015318.html">[Haiku-commits] r29798 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="015279.html">[Haiku-commits] r29800 - haiku/trunk/build/jam
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15277">[ date ]</a>
              <a href="thread.html#15277">[ thread ]</a>
              <a href="subject.html#15277">[ subject ]</a>
              <a href="author.html#15277">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
