<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29446 - in haiku/trunk: headers/os/drivers	src/add-ons/kernel/drivers/disk/scsi/scsi_cd	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/generic/scsi_periph	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29446%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_cd%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_disk%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/generic/scsi_periph%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm&In-Reply-To=%3C200903081730.n28HUj5q025063%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014748.html">
   <LINK REL="Next"  HREF="014750.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29446 - in haiku/trunk: headers/os/drivers	src/add-ons/kernel/drivers/disk/scsi/scsi_cd	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/generic/scsi_periph	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29446%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_cd%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_disk%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/generic/scsi_periph%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm&In-Reply-To=%3C200903081730.n28HUj5q025063%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29446 - in haiku/trunk: headers/os/drivers	src/add-ons/kernel/drivers/disk/scsi/scsi_cd	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/generic/scsi_periph	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm">bonefish at mail.berlios.de
       </A><BR>
    <I>Sun Mar  8 18:30:45 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014748.html">[Haiku-commits] r29445 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . jmicron2x0	jmicron2x0/dev jmicron2x0/dev/jme jmicron2x0/dev/mii
</A></li>
        <LI>Next message: <A HREF="014750.html">[Haiku-commits] r29447 - in haiku/trunk/src/tests/add-ons/kernel: .	file_systems/userlandfs/bfs kernelland_emu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14749">[ date ]</a>
              <a href="thread.html#14749">[ thread ]</a>
              <a href="subject.html#14749">[ subject ]</a>
              <a href="author.html#14749">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-03-08 18:30:37 +0100 (Sun, 08 Mar 2009)
New Revision: 29446
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29446&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29446&amp;view=rev</A>

Added:
   haiku/trunk/headers/os/drivers/io_requests.h
   haiku/trunk/src/system/kernel/device_manager/IORequest.cpp
   haiku/trunk/src/system/kernel/device_manager/IORequest.h
   haiku/trunk/src/system/kernel/device_manager/io_requests.cpp
Removed:
   haiku/trunk/src/system/kernel/device_manager/io_requests.cpp
   haiku/trunk/src/system/kernel/device_manager/io_requests.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd/scsi_cd.h
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.cpp
   haiku/trunk/src/system/kernel/device_manager/IOScheduler.h
   haiku/trunk/src/system/kernel/device_manager/Jamfile
   haiku/trunk/src/system/kernel/device_manager/devfs.cpp
   haiku/trunk/src/system/kernel/device_manager/device_manager.cpp
   haiku/trunk/src/system/kernel/device_manager/dma_resources.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/vm/VMAnonymousCache.cpp
   haiku/trunk/src/system/kernel/vm/vm.cpp
   haiku/trunk/src/system/kernel/vm/vm_page.cpp
Log:
* Renamed src/system/kernel/device_manager/io_requests.{h,cpp} to
  IORequest.{h,cpp}.
* Introduced public &lt;io_requests.h&gt; header. Currently it only declares the
  single function BFS uses.


Added: haiku/trunk/headers/os/drivers/io_requests.h
===================================================================
--- haiku/trunk/headers/os/drivers/io_requests.h	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/headers/os/drivers/io_requests.h	2009-03-08 17:30:37 UTC (rev 29446)
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2009, Haiku Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _IO_REQUESTS_H
+#define _IO_REQUESTS_H
+
+/*! I/O request interface */
+
+
+#include &lt;SupportDefs.h&gt;
+
+
+typedef struct IORequest io_request;
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+bool io_request_is_write(const io_request* request);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* _IO_REQUESTS_H */

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd/scsi_cd.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd/scsi_cd.h	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd/scsi_cd.h	2009-03-08 17:30:37 UTC (rev 29446)
@@ -12,7 +12,7 @@
 #include &lt;scsi.h&gt;
 
 #include &quot;dma_resources.h&quot;
-#include &quot;io_requests.h&quot;
+#include &quot;IORequest.h&quot;
 #include &quot;IOScheduler.h&quot;
 
 

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h	2009-03-08 17:30:37 UTC (rev 29446)
@@ -12,7 +12,7 @@
 #include &lt;scsi_periph.h&gt;
 
 #include &quot;dma_resources.h&quot;
-#include &quot;io_requests.h&quot;
+#include &quot;IORequest.h&quot;
 #include &quot;IOScheduler.h&quot;
 
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2009-03-08 17:30:37 UTC (rev 29446)
@@ -18,7 +18,7 @@
 
 // TODO: temporary solution as long as there is no public I/O requests API
 #ifndef BFS_SHELL
-#	include &quot;io_requests.h&quot;
+#	include &lt;io_requests.h&gt;
 #endif
 
 #define BFS_IO_SIZE	65536
@@ -458,7 +458,7 @@
 	Inode* inode = (Inode*)_node-&gt;private_node;
 
 #ifndef BFS_SHELL
-	if (request-&gt;IsWrite() &amp;&amp; volume-&gt;IsReadOnly())
+	if (io_request_is_write(request) &amp;&amp; volume-&gt;IsReadOnly())
 		return B_READ_ONLY_DEVICE;
 #endif
 

Modified: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h	2009-03-08 17:30:37 UTC (rev 29446)
@@ -12,7 +12,7 @@
 #include &lt;scsi_periph.h&gt;
 #include &lt;device_manager.h&gt;
 
-#include &quot;io_requests.h&quot;
+#include &quot;IORequest.h&quot;
 #include &quot;wrapper.h&quot;
 
 

Modified: haiku/trunk/src/system/kernel/cache/file_cache.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/file_cache.cpp	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/system/kernel/cache/file_cache.cpp	2009-03-08 17:30:37 UTC (rev 29446)
@@ -25,7 +25,7 @@
 #include &lt;vm_page.h&gt;
 #include &lt;vm_cache.h&gt;
 
-#include &quot;io_requests.h&quot;
+#include &quot;IORequest.h&quot;
 
 
 //#define TRACE_FILE_CACHE

Modified: haiku/trunk/src/system/kernel/cache/vnode_store.cpp
===================================================================
--- haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2009-03-08 16:46:12 UTC (rev 29445)
+++ haiku/trunk/src/system/kernel/cache/vnode_store.cpp	2009-03-08 17:30:37 UTC (rev 29446)
@@ -13,7 +13,7 @@
 #include &lt;vfs.h&gt;
 #include &lt;vm.h&gt;
 
-#include &quot;io_requests.h&quot;
+#include &quot;IORequest.h&quot;
 
 
 status_t

Copied: haiku/trunk/src/system/kernel/device_manager/IORequest.cpp (from rev 29443, haiku/trunk/src/system/kernel/device_manager/io_requests.cpp)
===================================================================
--- haiku/trunk/src/system/kernel/device_manager/io_requests.cpp	2009-03-08 16:08:03 UTC (rev 29443)
+++ haiku/trunk/src/system/kernel/device_manager/IORequest.cpp	2009-03-08 17:30:37 UTC (rev 29446)
@@ -0,0 +1,1405 @@
+/*
+ * Copyright 2008, Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ingo_weinhold at gmx.de.</A>
+ * Copyright 2008, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+ * Distributed under the terms of the MIT License.
+ */
+
+#include &quot;IORequest.h&quot;
+
+#include &lt;string.h&gt;
+
+#include &lt;arch/debug.h&gt;
+#include &lt;debug.h&gt;
+#include &lt;heap.h&gt;
+#include &lt;kernel.h&gt;
+#include &lt;thread.h&gt;
+#include &lt;util/AutoLock.h&gt;
+#include &lt;vm.h&gt;
+
+#include &quot;dma_resources.h&quot;
+
+
+//#define TRACE_IO_REQUEST
+#ifdef TRACE_IO_REQUEST
+#	define TRACE(x...) dprintf(x)
+#else
+#	define TRACE(x...) ;
+#endif
+
+
+#define VIP_HEAP_SIZE	1024 * 1024
+
+// partial I/O operation phases
+enum {
+	PHASE_READ_BEGIN	= 0,
+	PHASE_READ_END		= 1,
+	PHASE_DO_ALL		= 2
+};
+
+heap_allocator* sVIPHeap;
+
+
+// #pragma mark -
+
+
+IORequestChunk::IORequestChunk()
+	:
+	fParent(NULL),
+	fStatus(1)
+{
+}
+
+
+IORequestChunk::~IORequestChunk()
+{
+}
+
+
+void
+IORequestChunk::operator delete(void* address, size_t size)
+{
+	io_request_free(address);
+}
+
+
+//	#pragma mark -
+
+
+IOBuffer*
+IOBuffer::Create(uint32 count, bool vip)
+{
+	size_t size = sizeof(IOBuffer) + sizeof(iovec) * (count - 1);
+	IOBuffer* buffer
+		= (IOBuffer*)(vip ? vip_io_request_malloc(size) : malloc(size));
+	if (buffer == NULL)
+		return NULL;
+
+	buffer-&gt;fCapacity = count;
+	buffer-&gt;fVecCount = 0;
+	buffer-&gt;fUser = false;
+	buffer-&gt;fPhysical = false;
+	buffer-&gt;fVIP = vip;
+	buffer-&gt;fMemoryLocked = false;
+
+	return buffer;
+}
+
+
+void
+IOBuffer::Delete()
+{
+	if (this == NULL)
+		return;
+
+	if (fVIP)
+		vip_io_request_free(this);
+	else
+		free(this);
+}
+
+
+void
+IOBuffer::SetVecs(size_t firstVecOffset, const iovec* vecs, uint32 count,
+	size_t length, uint32 flags)
+{
+	memcpy(fVecs, vecs, sizeof(iovec) * count);
+	if (count &gt; 0 &amp;&amp; firstVecOffset &gt; 0) {
+		fVecs[0].iov_base = (uint8*)fVecs[0].iov_base + firstVecOffset;
+		fVecs[0].iov_len -= firstVecOffset;
+	}
+
+	fVecCount = count;
+	fLength = length;
+	fUser = IS_USER_ADDRESS(vecs[0].iov_base);
+	fPhysical = (flags &amp; B_PHYSICAL_IO_REQUEST) != 0;
+}
+
+
+status_t
+IOBuffer::LockMemory(team_id team, bool isWrite)
+{
+	if (fMemoryLocked) {
+		panic(&quot;memory already locked!&quot;);
+		return B_BAD_VALUE;
+	}
+
+	for (uint32 i = 0; i &lt; fVecCount; i++) {
+		status_t status = lock_memory_etc(team, fVecs[i].iov_base,
+			fVecs[i].iov_len, isWrite ? 0 : B_READ_DEVICE);
+		if (status != B_OK) {
+			_UnlockMemory(team, i, isWrite);
+			return status;
+		}
+	}
+
+	fMemoryLocked = true;
+	return B_OK;
+}
+
+
+void
+IOBuffer::_UnlockMemory(team_id team, size_t count, bool isWrite)
+{
+	for (uint32 i = 0; i &lt; count; i++) {
+		unlock_memory_etc(team, fVecs[i].iov_base, fVecs[i].iov_len,
+			isWrite ? 0 : B_READ_DEVICE);
+	}
+}
+
+
+void
+IOBuffer::UnlockMemory(team_id team, bool isWrite)
+{
+	if (!fMemoryLocked) {
+		panic(&quot;memory not locked&quot;);
+		return;
+	}
+
+	_UnlockMemory(team, fVecCount, isWrite);
+	fMemoryLocked = false;
+}
+
+
+void
+IOBuffer::Dump() const
+{
+	kprintf(&quot;IOBuffer at %p\n&quot;, this);
+
+	kprintf(&quot;  origin:     %s\n&quot;, fUser ? &quot;user&quot; : &quot;kernel&quot;);
+	kprintf(&quot;  kind:       %s\n&quot;, fPhysical ? &quot;physical&quot; : &quot;virtual&quot;);
+	kprintf(&quot;  length:     %lu\n&quot;, fLength);
+	kprintf(&quot;  capacity:   %lu\n&quot;, fCapacity);
+	kprintf(&quot;  vecs:       %lu\n&quot;, fVecCount);
+
+	for (uint32 i = 0; i &lt; fVecCount; i++) {
+		kprintf(&quot;    [%lu] %p, %lu\n&quot;, i, fVecs[i].iov_base, fVecs[i].iov_len);
+	}
+}
+
+
+// #pragma mark -
+
+
+bool
+IOOperation::Finish()
+{
+	TRACE(&quot;IOOperation::Finish()\n&quot;);
+	if (fStatus == B_OK) {
+		if (fParent-&gt;IsWrite()) {
+			TRACE(&quot;  is write\n&quot;);
+			if (fPhase == PHASE_READ_BEGIN) {
+				TRACE(&quot;  phase read begin\n&quot;);
+				// repair phase adjusted vec
+				fDMABuffer-&gt;VecAt(fSavedVecIndex).iov_len = fSavedVecLength;
+
+				// partial write: copy partial begin to bounce buffer
+				bool skipReadEndPhase;
+				status_t error = _CopyPartialBegin(true, skipReadEndPhase);
+				if (error == B_OK) {
+					// We're done with the first phase only (read in begin).
+					// Get ready for next phase...
+					fPhase = HasPartialEnd() &amp;&amp; !skipReadEndPhase
+						? PHASE_READ_END : PHASE_DO_ALL;
+					_PrepareVecs();
+					ResetStatus();
+						// TODO: Is there a race condition, if the request is
+						// aborted at the same time?
+					return false;
+				}
+
+				SetStatus(error);
+			} else if (fPhase == PHASE_READ_END) {
+				TRACE(&quot;  phase read end\n&quot;);
+				// repair phase adjusted vec
+				iovec&amp; vec = fDMABuffer-&gt;VecAt(fSavedVecIndex);
+				vec.iov_base = (uint8*)vec.iov_base
+					+ vec.iov_len - fSavedVecLength;
+				vec.iov_len = fSavedVecLength;
+
+				// partial write: copy partial end to bounce buffer
+				status_t error = _CopyPartialEnd(true);
+				if (error == B_OK) {
+					// We're done with the second phase only (read in end).
+					// Get ready for next phase...
+					fPhase = PHASE_DO_ALL;
+					ResetStatus();
+						// TODO: Is there a race condition, if the request is
+						// aborted at the same time?
+					return false;
+				}
+
+				SetStatus(error);
+			}
+		}
+	}
+
+	if (fParent-&gt;IsRead() &amp;&amp; UsesBounceBuffer()) {
+		TRACE(&quot;  read with bounce buffer\n&quot;);
+		// copy the bounce buffer segments to the final location
+		uint8* bounceBuffer = (uint8*)fDMABuffer-&gt;BounceBufferAddress();
+		addr_t bounceBufferStart = fDMABuffer-&gt;PhysicalBounceBufferAddress();
+		addr_t bounceBufferEnd = bounceBufferStart
+			+ fDMABuffer-&gt;BounceBufferSize();
+
+		const iovec* vecs = fDMABuffer-&gt;Vecs();
+		uint32 vecCount = fDMABuffer-&gt;VecCount();
+
+		status_t error = B_OK;
+
+		off_t offset = fOffset;
+		off_t startOffset = fOriginalOffset;
+		off_t endOffset = fOriginalOffset + fOriginalLength;
+
+		for (uint32 i = 0; error == B_OK &amp;&amp; i &lt; vecCount; i++) {
+			const iovec&amp; vec = vecs[i];
+			addr_t base = (addr_t)vec.iov_base;
+			size_t length = vec.iov_len;
+
+			if (offset &lt; startOffset) {
+				if (offset + length &lt;= startOffset) {
+					offset += length;
+					continue;
+				}
+
+				size_t diff = startOffset - offset;
+				base += diff;
+				length -= diff;
+			}
+
+			if (offset + length &gt; endOffset) {
+				if (offset &gt;= endOffset)
+					break;
+
+				length = endOffset - offset;
+			}
+
+			if (base &gt;= bounceBufferStart &amp;&amp; base &lt; bounceBufferEnd) {
+				error = fParent-&gt;CopyData(
+					bounceBuffer + (base - bounceBufferStart), offset, length);
+			}
+
+			offset += length;
+		}
+
+		if (error != B_OK)
+			SetStatus(error);
+	}
+
+	return true;
+}
+
+
+/*!	Note: SetPartial() must be called first!
+*/
+status_t
+IOOperation::Prepare(IORequest* request)
+{
+	if (fParent != NULL)
+		fParent-&gt;RemoveOperation(this);
+
+	fParent = request;
+
+	fTransferredBytes = 0;
+
+	// set initial phase
+	fPhase = PHASE_DO_ALL;
+	if (fParent-&gt;IsWrite()) {
+		// Copy data to bounce buffer segments, save the partial begin/end vec,
+		// which will be copied after their respective read phase.
+		if (UsesBounceBuffer()) {
+			TRACE(&quot;  write with bounce buffer\n&quot;);
+			uint8* bounceBuffer = (uint8*)fDMABuffer-&gt;BounceBufferAddress();
+			addr_t bounceBufferStart
+				= fDMABuffer-&gt;PhysicalBounceBufferAddress();
+			addr_t bounceBufferEnd = bounceBufferStart
+				+ fDMABuffer-&gt;BounceBufferSize();
+
+			const iovec* vecs = fDMABuffer-&gt;Vecs();
+			uint32 vecCount = fDMABuffer-&gt;VecCount();
+			size_t vecOffset = 0;
+			uint32 i = 0;
+
+			off_t offset = fOffset;
+			off_t endOffset = fOffset + fLength;
+
+			if (HasPartialBegin()) {
+				// skip first block
+				size_t toSkip = fBlockSize;
+				while (toSkip &gt; 0) {
+					if (vecs[i].iov_len &lt;= toSkip) {
+						toSkip -= vecs[i].iov_len;
+						i++;
+					} else {
+						vecOffset = toSkip;
+						break;
+					}
+				}
+
+				offset += fBlockSize;
+			}
+
+			if (HasPartialEnd()) {
+				// skip last block
+				size_t toSkip = fBlockSize;
+				while (toSkip &gt; 0) {
+					if (vecs[vecCount - 1].iov_len &lt;= toSkip) {
+						toSkip -= vecs[vecCount - 1].iov_len;
+						vecCount--;
+					} else
+						break;
+				}
+
+				endOffset -= fBlockSize;
+			}
+
+			for (; i &lt; vecCount; i++) {
+				const iovec&amp; vec = vecs[i];
+				addr_t base = (addr_t)vec.iov_base + vecOffset;
+				size_t length = vec.iov_len - vecOffset;
+				vecOffset = 0;
+
+				if (base &gt;= bounceBufferStart &amp;&amp; base &lt; bounceBufferEnd) {
+					if (offset + length &gt; endOffset)
+						length = endOffset - offset;
+					status_t error = fParent-&gt;CopyData(offset,
+						bounceBuffer + (base - bounceBufferStart), length);
+					if (error != B_OK)
+						return error;
+				}
+
+				offset += length;
+			}
+		}
+
+		if (HasPartialBegin())
+			fPhase = PHASE_READ_BEGIN;
+		else if (HasPartialEnd())
+			fPhase = PHASE_READ_END;
+
+		_PrepareVecs();
+	}
+
+	ResetStatus();
+
+	if (fParent != NULL)
+		fParent-&gt;AddOperation(this);
+
+	return B_OK;
+}
+
+
+void
+IOOperation::SetOriginalRange(off_t offset, size_t length)
+{
+	fOriginalOffset = fOffset = offset;
+	fOriginalLength = fLength = length;
+}
+
+
+void
+IOOperation::SetRange(off_t offset, size_t length)
+{
+	fOffset = offset;
+	fLength = length;
+}
+
+
+off_t
+IOOperation::Offset() const
+{
+	return fPhase == PHASE_READ_END ? fOffset + fLength - fBlockSize : fOffset;
+}
+
+
+size_t
+IOOperation::Length() const
+{
+	return fPhase == PHASE_DO_ALL ? fLength : fBlockSize;
+}
+
+
+iovec*
+IOOperation::Vecs() const
+{
+	switch (fPhase) {
+		case PHASE_READ_END:
+			return fDMABuffer-&gt;Vecs() + fSavedVecIndex;
+		case PHASE_READ_BEGIN:
+		case PHASE_DO_ALL:
+		default:
+			return fDMABuffer-&gt;Vecs();
+	}
+}
+
+
+uint32
+IOOperation::VecCount() const
+{
+	switch (fPhase) {
+		case PHASE_READ_BEGIN:
+			return fSavedVecIndex + 1;
+		case PHASE_READ_END:
+			return fDMABuffer-&gt;VecCount() - fSavedVecIndex;
+		case PHASE_DO_ALL:
+		default:
+			return fDMABuffer-&gt;VecCount();
+	}
+}
+
+
+void
+IOOperation::SetPartial(bool partialBegin, bool partialEnd)
+{
+	TRACE(&quot;partial begin %d, end %d\n&quot;, partialBegin, partialEnd);
+	fPartialBegin = partialBegin;
+	fPartialEnd = partialEnd;
+}
+
+
+bool
+IOOperation::IsWrite() const
+{
+	return fParent-&gt;IsWrite() &amp;&amp; fPhase == PHASE_DO_ALL;
+}
+
+
+bool
+IOOperation::IsRead() const
+{
+	return fParent-&gt;IsRead();
+}
+
+
+void
+IOOperation::_PrepareVecs()
+{
+	// we need to prepare the vecs for consumption by the drivers
+	if (fPhase == PHASE_READ_BEGIN) {
+		iovec* vecs = fDMABuffer-&gt;Vecs();
+		uint32 vecCount = fDMABuffer-&gt;VecCount();
+		size_t vecLength = fBlockSize;
+		for (uint32 i = 0; i &lt; vecCount; i++) {
+			iovec&amp; vec = vecs[i];
+			if (vec.iov_len &gt;= vecLength) {
+				fSavedVecIndex = i;
+				fSavedVecLength = vec.iov_len;
+				vec.iov_len = vecLength;
+				break;
+			}
+			vecLength -= vec.iov_len;
+		}
+	} else if (fPhase == PHASE_READ_END) {
+		iovec* vecs = fDMABuffer-&gt;Vecs();
+		uint32 vecCount = fDMABuffer-&gt;VecCount();
+		size_t vecLength = fBlockSize;
+		for (int32 i = vecCount - 1; i &gt;= 0; i--) {
+			iovec&amp; vec = vecs[i];
+			if (vec.iov_len &gt;= vecLength) {
+				fSavedVecIndex = i;
+				fSavedVecLength = vec.iov_len;
+				vec.iov_base = (uint8*)vec.iov_base
+					+ vec.iov_len - vecLength;
+				vec.iov_len = vecLength;
+				break;
+			}
+			vecLength -= vec.iov_len;
+		}
+	}
+}
+
+
+status_t
+IOOperation::_CopyPartialBegin(bool isWrite, bool&amp; singleBlockOnly)
+{
+	size_t relativeOffset = OriginalOffset() - fOffset;
+	size_t length = fBlockSize - relativeOffset;
+
+	singleBlockOnly = length &gt;= OriginalLength();
+	if (singleBlockOnly)
+		length = OriginalLength();
+
+	TRACE(&quot;_CopyPartialBegin(%s, single only %d)\n&quot;,
+		isWrite ? &quot;write&quot; : &quot;read&quot;, singleBlockOnly);
+
+	if (isWrite) {
+		return fParent-&gt;CopyData(OriginalOffset(),
+			(uint8*)fDMABuffer-&gt;BounceBufferAddress() + relativeOffset, length);
+	} else {
+		return fParent-&gt;CopyData(
+			(uint8*)fDMABuffer-&gt;BounceBufferAddress() + relativeOffset,
+			OriginalOffset(), length);
+	}
+}
+
+
+status_t
+IOOperation::_CopyPartialEnd(bool isWrite)
+{
+	TRACE(&quot;_CopyPartialEnd(%s)\n&quot;, isWrite ? &quot;write&quot; : &quot;read&quot;);
+
+	const iovec&amp; lastVec = fDMABuffer-&gt;VecAt(fDMABuffer-&gt;VecCount() - 1);
+	off_t lastVecPos = fOffset + fLength - fBlockSize;
+	uint8* base = (uint8*)fDMABuffer-&gt;BounceBufferAddress()
+		+ ((addr_t)lastVec.iov_base + lastVec.iov_len - fBlockSize
+		- fDMABuffer-&gt;PhysicalBounceBufferAddress());
+		// NOTE: this won't work if we don't use the bounce buffer contiguously
+		// (because of boundary alignments).
+	size_t length = OriginalOffset() + OriginalLength() - lastVecPos;
+
+	if (isWrite)
+		return fParent-&gt;CopyData(lastVecPos, base, length);
+
+	return fParent-&gt;CopyData(base, lastVecPos, length);
+}
+
+
+void
+IOOperation::Dump() const
+{
+	kprintf(&quot;io_operation at %p\n&quot;, this);
+
+	kprintf(&quot;  parent:           %p\n&quot;, fParent);
+	kprintf(&quot;  status:           %s\n&quot;, strerror(fStatus));
+	kprintf(&quot;  dma buffer:       %p\n&quot;, fDMABuffer);
+	kprintf(&quot;  offset:           %-8Ld (original: %Ld)\n&quot;, fOffset,
+		fOriginalOffset);
+	kprintf(&quot;  length:           %-8lu (original: %lu)\n&quot;, fLength,
+		fOriginalLength);
+	kprintf(&quot;  transferred:      %lu\n&quot;, fTransferredBytes);
+	kprintf(&quot;  block size:       %lu\n&quot;, fBlockSize);
+	kprintf(&quot;  saved vec index:  %u\n&quot;, fSavedVecIndex);
+	kprintf(&quot;  saved vec length: %u\n&quot;, fSavedVecLength);
+	kprintf(&quot;  r/w:              %s\n&quot;, IsWrite() ? &quot;write&quot; : &quot;read&quot;);
+	kprintf(&quot;  phase:            %s\n&quot;, fPhase == PHASE_READ_BEGIN
+		? &quot;read begin&quot; : fPhase == PHASE_READ_END ? &quot;read end&quot;
+		: fPhase == PHASE_DO_ALL ? &quot;do all&quot; : &quot;unknown&quot;);
+	kprintf(&quot;  partial begin:    %s\n&quot;, fPartialBegin ? &quot;yes&quot; : &quot;no&quot;);
+	kprintf(&quot;  partial end:      %s\n&quot;, fPartialEnd ? &quot;yes&quot; : &quot;no&quot;);
+	kprintf(&quot;  bounce buffer:    %s\n&quot;, fUsesBounceBuffer ? &quot;yes&quot; : &quot;no&quot;);
+
+	set_debug_variable(&quot;_parent&quot;, (addr_t)fParent);
+	set_debug_variable(&quot;_buffer&quot;, (addr_t)fDMABuffer);
+}
+
+
+// #pragma mark -
+
+
+IORequest::IORequest()
+	:
+	fFinishedCallback(NULL),
+	fFinishedCookie(NULL),
+	fIterationCallback(NULL),
+	fIterationCookie(NULL)
+{
+	mutex_init(&amp;fLock, &quot;I/O request lock&quot;);
+	fFinishedCondition.Init(this, &quot;I/O request finished&quot;);
+}
+
+
+IORequest::~IORequest()
+{
+	mutex_lock(&amp;fLock);
+	DeleteSubRequests();
+	fBuffer-&gt;Delete();
+	mutex_destroy(&amp;fLock);
+}
+
+
+/* static */ IORequest*
+IORequest::Create(bool vip)
+{
+	return vip ? new(vip_io_alloc) IORequest : new(std::nothrow) IORequest;
+}
+
+
+status_t
+IORequest::Init(off_t offset, void* buffer, size_t length, bool write,
+	uint32 flags)
+{
+	iovec vec;
+	vec.iov_base = buffer;
+	vec.iov_len = length;
+	return Init(offset, &amp;vec, 1, length, write, flags);
+}
+
+
+status_t
+IORequest::Init(off_t offset, size_t firstVecOffset, const iovec* vecs,
+	size_t count, size_t length, bool write, uint32 flags)
+{
+	fBuffer = IOBuffer::Create(count, (flags &amp; B_VIP_IO_REQUEST) != 0);
+	if (fBuffer == NULL)
+		return B_NO_MEMORY;
+
+	fBuffer-&gt;SetVecs(firstVecOffset, vecs, count, length, flags);
+
+	fOwner = NULL;
+	fOffset = offset;
+	fLength = length;
+	fRelativeParentOffset = 0;
+	fTransferSize = 0;
+	fFlags = flags;
+	struct thread* thread = thread_get_current_thread();
+	fTeam = thread-&gt;team-&gt;id;
+	fThread = thread-&gt;id;
+	fIsWrite = write;
+	fPartialTransfer = 0;
+
+	// these are for iteration
+	fVecIndex = 0;
+	fVecOffset = 0;
+	fRemainingBytes = length;
+
+	fPendingChildren = 0;
+
+	fStatus = 1;
+
+	return B_OK;
+}
+
+
+status_t
+IORequest::CreateSubRequest(off_t parentOffset, off_t offset, size_t length,
+	IORequest*&amp; _subRequest)
+{
+	ASSERT(parentOffset &gt;= fOffset &amp;&amp; length &lt;= fLength
+		&amp;&amp; parentOffset - fOffset &lt;= fLength - length);
+
+	// find start vec
+	size_t vecOffset = parentOffset - fOffset;
+	iovec* vecs = fBuffer-&gt;Vecs();
+	int32 vecCount = fBuffer-&gt;VecCount();
+	int32 startVec = 0;
+	for (; startVec &lt; vecCount; startVec++) {
+		const iovec&amp; vec = vecs[startVec];
+		if (vecOffset &lt; vec.iov_len)
+			break;
+
+		vecOffset -= vec.iov_len;
+	}
+
+	// count vecs
+	size_t currentVecOffset = vecOffset;
+	int32 endVec = startVec;
+	size_t remainingLength = length;
+	for (; endVec &lt; vecCount; endVec++) {
+		const iovec&amp; vec = vecs[endVec];
+		if (vec.iov_len - currentVecOffset &gt;= remainingLength)
+			break;
+
+		remainingLength -= vec.iov_len - currentVecOffset;
+		currentVecOffset = 0;
+	}
+
+	// create subrequest
+	IORequest* subRequest = Create((fFlags &amp; B_VIP_IO_REQUEST) != 0);
+	if (subRequest == NULL)
+		return B_NO_MEMORY;
+
+	status_t error = subRequest-&gt;Init(offset, vecOffset, vecs + startVec,
+		endVec - startVec + 1, length, fIsWrite, fFlags &amp; ~B_DELETE_IO_REQUEST);
+	if (error != B_OK) {
+		delete subRequest;
+		return error;
+	}
+
+	subRequest-&gt;fRelativeParentOffset = parentOffset - fOffset;
+	subRequest-&gt;fTeam = fTeam;
+	subRequest-&gt;fThread = fThread;
+
+	_subRequest = subRequest;
+	subRequest-&gt;SetParent(this);
+
+	MutexLocker _(fLock);
+
+	fChildren.Add(subRequest);
+	fPendingChildren++;
+	TRACE(&quot;IORequest::CreateSubRequest(): request: %p, subrequest: %p\n&quot;, this,
+		subRequest);
+
+	return B_OK;
+}
+
+
+void
+IORequest::DeleteSubRequests()
+{
+	while (IORequestChunk* chunk = fChildren.RemoveHead())
+		delete chunk;
+}
+
+
+void
+IORequest::SetFinishedCallback(io_request_finished_callback callback,
+	void* cookie)
+{
+	fFinishedCallback = callback;
+	fFinishedCookie = cookie;
+}
+
+
+void
+IORequest::SetIterationCallback(io_request_iterate_callback callback,
+	void* cookie)
+{
+	fIterationCallback = callback;
+	fIterationCookie = cookie;
+}
+
+
+io_request_finished_callback
+IORequest::FinishedCallback(void** _cookie) const
+{
+	if (_cookie != NULL)
+		*_cookie = fFinishedCookie;
+	return fFinishedCallback;
+}
+
+
+status_t
+IORequest::Wait(uint32 flags, bigtime_t timeout)
+{
+	MutexLocker locker(fLock);
+
+	if (IsFinished())
+		return Status();
+
+	ConditionVariableEntry entry;
+	fFinishedCondition.Add(&amp;entry);
+
+	locker.Unlock();
+
+	status_t error = entry.Wait(flags, timeout);
+	if (error != B_OK)
+		return error;
+
+	return Status();
+}
+
+
+void
+IORequest::NotifyFinished()
+{
+	TRACE(&quot;IORequest::NotifyFinished(): request: %p\n&quot;, this);
+
+	MutexLocker locker(fLock);
+
+	if (fStatus == B_OK &amp;&amp; !fPartialTransfer &amp;&amp; RemainingBytes() &gt; 0) {
+		// The request is not really done yet. If it has an iteration callback,
+		// call it.
+		if (fIterationCallback != NULL) {
+			ResetStatus();
+			locker.Unlock();
+			bool partialTransfer = false;
+			status_t error = fIterationCallback(fIterationCookie, this,
+				&amp;partialTransfer);
+			if (error == B_OK &amp;&amp; !partialTransfer)
+				return;
+
+			// Iteration failed, which means we're responsible for notifying the
+			// requests finished.
+			locker.Lock();
+			fStatus = error;
+			fPartialTransfer = true;
+		}
+	}
+
+	ASSERT(fPendingChildren == 0);
+	ASSERT(fChildren.IsEmpty()
+		|| dynamic_cast&lt;IOOperation*&gt;(fChildren.Head()) == NULL);
+
+	// unlock the memory
+	if (fBuffer-&gt;IsMemoryLocked())
+		fBuffer-&gt;UnlockMemory(fTeam, fIsWrite);
+
+
+	// Cache the callbacks before we unblock waiters and unlock. Any of the
+	// following could delete this request, so we don't want to touch it
+	// once we have started telling others that it is done.
+	IORequest* parent = fParent;
+	io_request_finished_callback finishedCallback = fFinishedCallback;
+	void* finishedCookie = fFinishedCookie;
+	status_t status = fStatus;
+	size_t lastTransferredOffset = fRelativeParentOffset + fTransferSize;
+	bool partialTransfer = status != B_OK || fPartialTransfer;
+	bool deleteRequest = (fFlags &amp; B_DELETE_IO_REQUEST) != 0;
+
+	// unblock waiters
+	fFinishedCondition.NotifyAll();
+
+	locker.Unlock();
+
+	// notify callback
+	if (finishedCallback != NULL) {
+		finishedCallback(finishedCookie, this, status, partialTransfer,
+			lastTransferredOffset);
+	}
+
+	// notify parent
+	if (parent != NULL) {
+		parent-&gt;SubRequestFinished(this, status, partialTransfer,
+			lastTransferredOffset);
+	}
+
+	if (deleteRequest)
+		delete this;
+}
+
+
+/*!	Returns whether this request or any of it's ancestors has a finished or
+	notification callback. Used to decide whether NotifyFinished() can be called
+	synchronously.
+*/
+bool
+IORequest::HasCallbacks() const
+{
+	if (fFinishedCallback != NULL || fIterationCallback != NULL)
+		return true;
+
+	return fParent != NULL &amp;&amp; fParent-&gt;HasCallbacks();
+}
+
+
+void
+IORequest::SetStatusAndNotify(status_t status)
+{
+	MutexLocker locker(fLock);
+
+	if (fStatus != 1)

[... truncated: 1068 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014748.html">[Haiku-commits] r29445 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . jmicron2x0	jmicron2x0/dev jmicron2x0/dev/jme jmicron2x0/dev/mii
</A></li>
	<LI>Next message: <A HREF="014750.html">[Haiku-commits] r29447 - in haiku/trunk/src/tests/add-ons/kernel: .	file_systems/userlandfs/bfs kernelland_emu
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14749">[ date ]</a>
              <a href="thread.html#14749">[ thread ]</a>
              <a href="subject.html#14749">[ subject ]</a>
              <a href="author.html#14749">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
