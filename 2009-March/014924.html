<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29572 - in haiku/trunk:	headers/private/userlandfs/private	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/file_systems/userlandfs/server/beos	src/add-ons/kernel/file_systems/userlandfs/server/haiku
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29572%20-%20in%20haiku/trunk%3A%0A%09headers/private/userlandfs/private%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/add-ons/kernel/file_systems/userlandfs/server/beos%0A%09src/add-ons/kernel/file_systems/userlandfs/server/haiku&In-Reply-To=%3C200903171851.n2HIpkB7021653%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014923.html">
   <LINK REL="Next"  HREF="014925.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29572 - in haiku/trunk:	headers/private/userlandfs/private	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/file_systems/userlandfs/server/beos	src/add-ons/kernel/file_systems/userlandfs/server/haiku</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29572%20-%20in%20haiku/trunk%3A%0A%09headers/private/userlandfs/private%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/add-ons/kernel/file_systems/userlandfs/server/beos%0A%09src/add-ons/kernel/file_systems/userlandfs/server/haiku&In-Reply-To=%3C200903171851.n2HIpkB7021653%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29572 - in haiku/trunk:	headers/private/userlandfs/private	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/file_systems/userlandfs/server/beos	src/add-ons/kernel/file_systems/userlandfs/server/haiku">bonefish at mail.berlios.de
       </A><BR>
    <I>Tue Mar 17 19:51:46 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014923.html">[Haiku-commits] r29571 -	haiku/trunk/headers/private/userlandfs/private
</A></li>
        <LI>Next message: <A HREF="014925.html">[Haiku-commits] r29573 - haiku/trunk/src/kits/storage/disk_device
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14924">[ date ]</a>
              <a href="thread.html#14924">[ thread ]</a>
              <a href="subject.html#14924">[ subject ]</a>
              <a href="author.html#14924">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-03-17 19:51:43 +0100 (Tue, 17 Mar 2009)
New Revision: 29572
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29572&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29572&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/userlandfs/private/Requests.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos/BeOSKernelFileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos/BeOSKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos/BeOSKernelVolume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos/beos_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/HaikuKernelFileSystem.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/HaikuKernelFileSystem.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/HaikuKernelNode.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/HaikuKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/HaikuKernelVolume.h
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/Jamfile
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku/haiku_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h
Log:
* Haiku kernel interface emulation: Retrieve the capabilities for each vnode.
  We do some caching using a hash table indexed by the operations vector.
* Pass the vnode capabilities to the kernel module.
* In the kernel tailor the operation vectors for volumes and vnodes passed to
  the VFS according to the respective capabilities. This way those vectors look
  pretty much like those from the client FS. This saves unnecessary calls when
  hooks are not implemented and should also fix compatibility problems in cases
  where not implementing a hook and returning an error don't mean the same to
  the VFS.
* Inlined some of the kernel module Volume class getters.


Modified: haiku/trunk/headers/private/userlandfs/private/Requests.h
===================================================================
--- haiku/trunk/headers/private/userlandfs/private/Requests.h	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/headers/private/userlandfs/private/Requests.h	2009-03-17 18:51:43 UTC (rev 29572)
@@ -509,9 +509,10 @@
 public:
 	ReadVNodeReply() : ReplyRequest(READ_VNODE_REPLY) {}
 
-	void*		node;
-	int			type;
-	uint32		flags;
+	void*				node;
+	int					type;
+	uint32				flags;
+	FSVNodeCapabilities	capabilities;
 };
 
 // WriteVNodeRequest
@@ -1604,9 +1605,10 @@
 public:
 	NewVNodeRequest() : Request(NEW_VNODE_REQUEST) {}
 
-	dev_t		nsid;
-	ino_t		vnid;
-	void*		node;
+	dev_t				nsid;
+	ino_t				vnid;
+	void*				node;
+	FSVNodeCapabilities	capabilities;
 };
 
 // NewVNodeReply
@@ -1620,11 +1622,12 @@
 public:
 	PublishVNodeRequest() : Request(PUBLISH_VNODE_REQUEST) {}
 
-	dev_t		nsid;
-	ino_t		vnid;
-	void*		node;
-	int			type;
-	uint32		flags;
+	dev_t				nsid;
+	ino_t				vnid;
+	void*				node;
+	int					type;
+	uint32				flags;
+	FSVNodeCapabilities	capabilities;
 };
 
 // PublishVNodeReply

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -3,18 +3,22 @@
  * Distributed under the terms of the MIT License.
  */
 
+#include &quot;Volume.h&quot;
+
+#include &lt;util/AutoLock.h&gt;
+
 #include &quot;AutoLocker.h&quot;
 #include &quot;Compatibility.h&quot;
 #include &quot;Debug.h&quot;
 #include &quot;FileSystem.h&quot;
 #include &quot;HashMap.h&quot;
+#include &quot;kernel_interface.h&quot;
 #include &quot;KernelRequestHandler.h&quot;
 #include &quot;PortReleaser.h&quot;
 #include &quot;RequestAllocator.h&quot;
 #include &quot;Requests.h&quot;
 #include &quot;Settings.h&quot;
 #include &quot;SingleReplyRequestHandler.h&quot;
-#include &quot;Volume.h&quot;
 
 // The time after which the notification thread times out at the port and
 // restarts the loop. Of interest only when the FS is deleted. It is the
@@ -30,7 +34,6 @@
 FileSystem::FileSystem()
 	:
 	fVolumes(),
-	fVolumeLock(),
 	fName(),
 	fTeam(-1),
 	fNotificationPort(NULL),
@@ -42,6 +45,8 @@
 	fInitialized(false),
 	fTerminating(false)
 {
+	mutex_init(&amp;fVolumeLock, &quot;userlandfs volumes&quot;);
+	mutex_init(&amp;fVNodeOpsLock, &quot;userlandfs vnode ops&quot;);
 }
 
 // destructor
@@ -65,6 +70,18 @@
 		delete fSelectSyncs;
 	}
 	delete fSettings;
+
+	// delete vnode ops vectors -- there shouldn't be any left, though
+	VNodeOps* ops = fVNodeOps.Clear();
+	int32 count = 0;
+	while (ops != NULL) {
+		count++;
+		VNodeOps* next = ops-&gt;fNext;
+		free(ops);
+		ops = next;
+	}
+	if (count &gt; 0)
+		WARN((&quot;Deleted %ld vnode ops vectors!\n&quot;, count));
 }
 
 // Init
@@ -83,6 +100,11 @@
 	if (!fName.SetTo(name))
 		return B_NO_MEMORY;
 
+	// init VNodeOps map
+	status_t error = fVNodeOps.Init();
+	if (error != B_OK)
+		return error;
+
 	fTeam = team;
 	fCapabilities = capabilities;
 
@@ -96,7 +118,7 @@
 	fNotificationPort = new(nothrow) RequestPort(infos);
 	if (!fNotificationPort)
 		RETURN_ERROR(B_NO_MEMORY);
-	status_t error = fNotificationPort-&gt;InitCheck();
+	error = fNotificationPort-&gt;InitCheck();
 	if (error != B_OK)
 		return error;
 
@@ -198,18 +220,18 @@
 		return B_NO_MEMORY;
 
 	// add volume to the volume list
-	fVolumeLock.Lock();
+	MutexLocker locker(fVolumeLock);
 	status_t error = fVolumes.PushBack(volume);
-	fVolumeLock.Unlock();
+	locker.Unlock();
 	if (error != B_OK)
 		return error;
 
 	// mount volume
 	error = volume-&gt;Mount(device, flags, parameters);
 	if (error != B_OK) {
-		fVolumeLock.Lock();
+		MutexLocker locker(fVolumeLock);
 		fVolumes.Remove(volume);
-		fVolumeLock.Unlock();
+		locker.Unlock();
 		volume-&gt;RemoveReference();
 		return error;
 	}
@@ -256,16 +278,15 @@
 void
 FileSystem::VolumeUnmounted(Volume* volume)
 {
-	fVolumeLock.Lock();
+	MutexLocker locker(fVolumeLock);
 	fVolumes.Remove(volume);
-	fVolumeLock.Unlock();
 }
 
 // GetVolume
 Volume*
 FileSystem::GetVolume(dev_t id)
 {
-	AutoLocker&lt;Locker&gt; _(fVolumeLock);
+	MutexLocker _(fVolumeLock);
 	for (Vector&lt;Volume*&gt;::Iterator it = fVolumes.Begin();
 		 it != fVolumes.End();
 		 it++) {
@@ -318,6 +339,7 @@
 	}
 }
 
+
 // KnowsSelectSyncEntry
 bool
 FileSystem::KnowsSelectSyncEntry(selectsync* sync)
@@ -325,6 +347,54 @@
 	return fSelectSyncs-&gt;ContainsKey(sync);
 }
 
+
+// GetVNodeOps
+VNodeOps*
+FileSystem::GetVNodeOps(const FSVNodeCapabilities&amp; capabilities)
+{
+	MutexLocker locker(fVNodeOpsLock);
+
+	// do we already have ops for those capabilities
+	VNodeOps* ops = fVNodeOps.Lookup(capabilities);
+	if (ops != NULL) {
+		ops-&gt;refCount++;
+		return ops;
+	}
+
+	// no, create a new object
+	fs_vnode_ops* opsVector = new(std::nothrow) fs_vnode_ops;
+	if (opsVector == NULL)
+		return NULL;
+
+	// set the operations
+	_InitVNodeOpsVector(opsVector, capabilities);
+
+	// create the VNodeOps object
+	ops = new(std::nothrow) VNodeOps(capabilities, opsVector);
+	if (ops == NULL) {
+		delete opsVector;
+		return NULL;
+	}
+
+	fVNodeOps.Insert(ops);
+
+	return ops;
+}
+
+
+// PutVNodeOps
+void
+FileSystem::PutVNodeOps(VNodeOps* ops)
+{
+	MutexLocker locker(fVNodeOpsLock);
+
+	if (--ops-&gt;refCount == 0) {
+		fVNodeOps.Remove(ops);
+		delete ops;
+	}
+}
+
+
 // IsUserlandServerThread
 bool
 FileSystem::IsUserlandServerThread() const
@@ -334,6 +404,108 @@
 	return (info.team == fUserlandServerTeam);
 }
 
+
+// _InitVNodeOpsVector
+void
+FileSystem::_InitVNodeOpsVector(fs_vnode_ops* ops,
+	const FSVNodeCapabilities&amp; capabilities)
+{
+	memcpy(ops, &amp;gUserlandFSVnodeOps, sizeof(fs_vnode_ops));
+
+	#undef CLEAR_UNSUPPORTED
+	#define CLEAR_UNSUPPORTED(capability, op) 	\
+		if (!capabilities.Get(capability))				\
+			ops-&gt;op = NULL
+
+	// vnode operations
+	// FS_VNODE_CAPABILITY_LOOKUP: lookup
+	// FS_VNODE_CAPABILITY_GET_VNODE_NAME: get_vnode_name
+		// emulated in userland
+	// FS_VNODE_CAPABILITY_PUT_VNODE: put_vnode
+	// FS_VNODE_CAPABILITY_REMOVE_VNODE: remove_vnode
+		// needed by Volume to clean up
+
+	// asynchronous I/O
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_IO, io);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CANCEL_IO, cancel_io);
+
+	// cache file access
+	ops-&gt;get_file_map = NULL;	// never used
+
+	// common operations
+	// FS_VNODE_CAPABILITY_IOCTL: ioctl
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_SET_FLAGS, set_flags);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_SELECT, select);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_DESELECT, deselect);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_FSYNC, fsync);
+
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ_SYMLINK, read_symlink);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CREATE_SYMLINK, create_symlink);
+
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_LINK, link);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_UNLINK, unlink);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_RENAME, rename);
+
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_ACCESS, access);
+	// FS_VNODE_CAPABILITY_READ_STAT: read_stat
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_WRITE_STAT, write_stat);
+
+	// file operations
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CREATE, create);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_OPEN, open);
+	// FS_VNODE_CAPABILITY_CLOSE: close
+		// needed by Volume
+	// FS_VNODE_CAPABILITY_FREE_COOKIE: free_cookie
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ, read);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_WRITE, write);
+
+	// directory operations
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CREATE_DIR, create_dir);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_REMOVE_DIR, remove_dir);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_OPEN_DIR, open_dir);
+	// FS_VNODE_CAPABILITY_CLOSE_DIR: close_dir
+		// needed by Volume
+	// FS_VNODE_CAPABILITY_FREE_DIR_COOKIE: free_dir_cookie
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ_DIR, read_dir);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_REWIND_DIR, rewind_dir);
+
+	// attribute directory operations
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_OPEN_ATTR_DIR, open_attr_dir);
+	// FS_VNODE_CAPABILITY_CLOSE_ATTR_DIR: close_attr_dir
+		// needed by Volume
+	// FS_VNODE_CAPABILITY_FREE_ATTR_DIR_COOKIE: free_attr_dir_cookie
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ_ATTR_DIR, read_attr_dir);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_REWIND_ATTR_DIR, rewind_attr_dir);
+
+	// attribute operations
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CREATE_ATTR, create_attr);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_OPEN_ATTR, open_attr);
+	// FS_VNODE_CAPABILITY_CLOSE_ATTR: close_attr
+		// needed by Volume
+	// FS_VNODE_CAPABILITY_FREE_ATTR_COOKIE: free_attr_cookie
+		// needed by Volume
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ_ATTR, read_attr);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_WRITE_ATTR, write_attr);
+
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_READ_ATTR_STAT, read_attr_stat);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_WRITE_ATTR_STAT, write_attr_stat);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_RENAME_ATTR, rename_attr);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_REMOVE_ATTR, remove_attr);
+
+	// support for node and FS layers
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_CREATE_SPECIAL_NODE,
+		create_special_node);
+	CLEAR_UNSUPPORTED(FS_VNODE_CAPABILITY_GET_SUPER_VNODE, get_super_vnode);
+
+	#undef CLEAR_UNSUPPORTED
+}
+
+
 // _NotificationThreadEntry
 int32
 FileSystem::_NotificationThreadEntry(void* data)
@@ -341,6 +513,7 @@
 	return ((FileSystem*)data)-&gt;_NotificationThread();
 }
 
+
 // _NotificationThread
 int32
 FileSystem::_NotificationThread()

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.h	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/FileSystem.h	2009-03-17 18:51:43 UTC (rev 29572)
@@ -7,6 +7,10 @@
 
 #include &lt;fs_interface.h&gt;
 
+#include &lt;util/OpenHashTable.h&gt;
+
+#include &lt;lock.h&gt;
+
 #include &quot;FSCapabilities.h&quot;
 #include &quot;LazyInitializable.h&quot;
 #include &quot;Locker.h&quot;
@@ -20,6 +24,42 @@
 class Settings;
 class Volume;
 
+
+struct VNodeOps : HashTableLink&lt;VNodeOps&gt; {
+	int32				refCount;
+	FSVNodeCapabilities	capabilities;
+	fs_vnode_ops*		ops;
+
+	VNodeOps(const FSVNodeCapabilities&amp; capabilities, fs_vnode_ops* ops)
+		:
+		refCount(1),
+		capabilities(capabilities),
+		ops(ops)
+	{
+	}
+
+	~VNodeOps()
+	{
+		delete ops;
+	}
+};
+
+
+struct VNodeOpsHashDefinition {
+	typedef FSVNodeCapabilities	KeyType;
+	typedef	VNodeOps			ValueType;
+
+	size_t HashKey(const FSVNodeCapabilities&amp; key) const
+		{ return key.GetHashCode(); }
+	size_t Hash(const VNodeOps* value) const
+		{ return HashKey(value-&gt;capabilities); }
+	bool Compare(const FSVNodeCapabilities&amp; key, const VNodeOps* value) const
+		{ return value-&gt;capabilities == key; }
+	HashTableLink&lt;VNodeOps&gt;* GetLink(VNodeOps* value) const
+		{ return value; }
+};
+
+
 class FileSystem {
 public:
 								FileSystem();
@@ -52,9 +92,16 @@
 			void				RemoveSelectSyncEntry(selectsync* sync);
 			bool				KnowsSelectSyncEntry(selectsync* sync);
 
+			VNodeOps*			GetVNodeOps(
+									const FSVNodeCapabilities&amp; capabilities);
+			void				PutVNodeOps(VNodeOps* ops);
+
 			bool				IsUserlandServerThread() const;
 
 private:
+			void				_InitVNodeOpsVector(fs_vnode_ops* ops,
+									const FSVNodeCapabilities&amp; capabilities);
+
 	static	int32				_NotificationThreadEntry(void* data);
 			int32				_NotificationThread();
 
@@ -62,9 +109,12 @@
 			friend class KernelDebug;
 			struct SelectSyncEntry;
 			struct SelectSyncMap;
+			typedef OpenHashTable&lt;VNodeOpsHashDefinition&gt; VNodeOpsMap;
 
 			Vector&lt;Volume*&gt;		fVolumes;
-			Locker				fVolumeLock;
+			mutex				fVolumeLock;
+			VNodeOpsMap			fVNodeOps;
+			mutex				fVNodeOpsLock;
 			String				fName;
 			team_id				fTeam;
 			FSCapabilities		fCapabilities;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -403,8 +403,11 @@
 	Volume* volume = NULL;
 	status_t result = _GetVolume(request-&gt;nsid, &amp;volume);
 	VolumePutter _(volume);
-	if (result == B_OK)
-		result = volume-&gt;NewVNode(request-&gt;vnid, request-&gt;node);
+	if (result == B_OK) {
+		result = volume-&gt;NewVNode(request-&gt;vnid, request-&gt;node,
+			request-&gt;capabilities);
+	}
+
 	// prepare the reply
 	RequestAllocator allocator(fPort-&gt;GetPort());
 	NewVNodeReply* reply;
@@ -412,6 +415,7 @@
 	if (error != B_OK)
 		return error;
 	reply-&gt;error = result;
+
 	// send the reply
 	return fPort-&gt;SendRequest(&amp;allocator);
 }
@@ -426,7 +430,7 @@
 	VolumePutter _(volume);
 	if (result == B_OK) {
 		result = volume-&gt;PublishVNode(request-&gt;vnid, request-&gt;node,
-			request-&gt;type, request-&gt;flags);
+			request-&gt;type, request-&gt;flags, request-&gt;capabilities);
 	}
 
 	// prepare the reply

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -47,22 +47,32 @@
 
 // VNode
 struct Volume::VNode : HashTableLink&lt;VNode&gt; {
-	ino_t	id;
-	void*	clientNode;
-	void*	fileCache;
-	int32	useCount;
-	bool	valid;
+	ino_t		id;
+	void*		clientNode;
+	void*		fileCache;
+	VNodeOps*	ops;
+	int32		useCount;
+	bool		valid;
 
-	VNode(ino_t id, void* clientNode)
+	VNode(ino_t id, void* clientNode, VNodeOps* ops)
 		:
 		id(id),
 		clientNode(clientNode),
 		fileCache(NULL),
+		ops(ops),
 		useCount(0),
 		valid(true)
 	{
 	}
 
+	void Delete(Volume* volume)
+	{
+		if (ops != NULL)
+			volume-&gt;GetFileSystem()-&gt;PutVNodeOps(ops);
+		delete this;
+	}
+
+protected:	// should be private, but gcc 2.95.3 issues a warning
 	~VNode()
 	{
 		if (fileCache != NULL)
@@ -278,27 +288,6 @@
 }
 
 
-// GetFileSystem
-FileSystem*
-Volume::GetFileSystem() const
-{
-	return fFileSystem;
-}
-
-// GetUserlandVolume
-void*
-Volume::GetUserlandVolume() const
-{
-	return fUserlandVolume;
-}
-
-// GetRootID
-ino_t
-Volume::GetRootID() const
-{
-	return fRootID;
-}
-
 // #pragma mark - client methods
 
 // GetVNode
@@ -342,7 +331,8 @@
 
 // NewVNode
 status_t
-Volume::NewVNode(ino_t vnid, void* clientNode)
+Volume::NewVNode(ino_t vnid, void* clientNode,
+	const FSVNodeCapabilities&amp; capabilities)
 {
 PRINT((&quot;new_vnode(%ld, %lld)\n&quot;, GetID(), vnid));
 	// lookup the node
@@ -353,17 +343,24 @@
 		RETURN_ERROR(B_BAD_VALUE);
 	}
 
+	// get the ops vector for the node
+	VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(capabilities);
+	if (ops == NULL)
+		RETURN_ERROR(B_NO_MEMORY);
+
 	// create the node
-	node = new(std::nothrow) VNode(vnid, clientNode);
-	if (node == NULL)
+	node = new(std::nothrow) VNode(vnid, clientNode, ops);
+	if (node == NULL) {
+		fFileSystem-&gt;PutVNodeOps(ops);
 		RETURN_ERROR(B_NO_MEMORY);
+	}
 
 	locker.Unlock();
 
 	// tell the VFS
-	status_t error = new_vnode(fFSVolume, vnid, node, &amp;gUserlandFSVnodeOps);
+	status_t error = new_vnode(fFSVolume, vnid, node, node-&gt;ops-&gt;ops);
 	if (error != B_OK) {
-		delete node;
+		node-&gt;Delete(this);
 		RETURN_ERROR(error);
 	}
 
@@ -376,7 +373,8 @@
 
 // PublishVNode
 status_t
-Volume::PublishVNode(ino_t vnid, void* clientNode, int type, uint32 flags)
+Volume::PublishVNode(ino_t vnid, void* clientNode, int type, uint32 flags,
+	const FSVNodeCapabilities&amp; capabilities)
 {
 PRINT((&quot;publish_vnode(%ld, %lld, %p)\n&quot;, GetID(), vnid, clientNode));
 	// lookup the node
@@ -386,21 +384,30 @@
 
 	if (!nodeKnown) {
 		// The node is not yet known -- create it.
-		node = new(std::nothrow) VNode(vnid, clientNode);
-		if (node == NULL)
+
+		// get the ops vector for the node
+		VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(capabilities);
+		if (ops == NULL)
 			RETURN_ERROR(B_NO_MEMORY);
+
+		// create the node
+		node = new(std::nothrow) VNode(vnid, clientNode, ops);
+		if (node == NULL) {
+			fFileSystem-&gt;PutVNodeOps(ops);
+			RETURN_ERROR(B_NO_MEMORY);
+		}
 	}
 
 	locker.Unlock();
 
 	// tell the VFS
-	status_t error = publish_vnode(fFSVolume, vnid, node, &amp;gUserlandFSVnodeOps,
+	status_t error = publish_vnode(fFSVolume, vnid, node, node-&gt;ops-&gt;ops,
 		type, flags);
 	if (error != B_OK) {
 // TODO: We should note whether the node was made known via new_vnode(). If so,
 // we should remove and delete it here!
 		if (!nodeKnown)
-			delete node;
+			node-&gt;Delete(this);
 		RETURN_ERROR(error);
 	}
 
@@ -690,29 +697,33 @@
 
 	// mount
 	status_t error = _Mount(device, flags, parameters);
+	if (error != B_OK)
+		RETURN_ERROR(error);
 
-	if (error == B_OK) {
-		MutexLocker locker(fLock);
-		// fetch the root node, so that we can serve Walk() requests on it,
-		// after the connection to the userland server is gone
-		fRootNode = fVNodes-&gt;Lookup(fRootID);
-		if (fRootNode == NULL) {
-			// The root node was not added while mounting. That's a serious
-			// problem -- not only because we don't have it, but also because
-			// the VFS requires publish_vnode() to be invoked for the root node.
-			ERROR((&quot;Volume::Mount(): new_vnode() was not called for root node! &quot;
-				&quot;Unmounting...\n&quot;));
-			locker.Unlock();
-			Unmount();
-			return B_ERROR;
-		}
+	MutexLocker locker(fLock);
+	// fetch the root node, so that we can serve Walk() requests on it,
+	// after the connection to the userland server is gone
+	fRootNode = fVNodes-&gt;Lookup(fRootID);
+	if (fRootNode == NULL) {
+		// The root node was not added while mounting. That's a serious
+		// problem -- not only because we don't have it, but also because
+		// the VFS requires publish_vnode() to be invoked for the root node.
+		ERROR((&quot;Volume::Mount(): new_vnode() was not called for root node! &quot;
+			&quot;Unmounting...\n&quot;));
+		locker.Unlock();
+		Unmount();
+		return B_ERROR;
+	}
 
-		// Decrement the root node use count. The publish_vnode() the client FS
-		// did will be balanced by the VFS.
-		if (fVNodeCountingEnabled)
-			fRootNode-&gt;useCount--;
-	}
-	return error;
+	// Decrement the root node use count. The publish_vnode() the client FS
+	// did will be balanced by the VFS.
+	if (fVNodeCountingEnabled)
+		fRootNode-&gt;useCount--;
+
+	// init the volume ops vector we'll give the VFS
+	_InitVolumeOps();
+
+	return B_OK;
 }
 
 // Unmount
@@ -729,7 +740,7 @@
 			VNode* node = fVNodes-&gt;Clear(true);
 			while (node != NULL) {
 				VNode* nextNode = node-&gt;fNext;
-				delete node;
+				node-&gt;Delete(this);
 				node = nextNode;
 			}
 			delete fVNodes;
@@ -937,8 +948,8 @@
 
 // ReadVNode
 status_t
-Volume::ReadVNode(ino_t vnid, bool reenter, void** _node, int* type,
-	uint32* flags)
+Volume::ReadVNode(ino_t vnid, bool reenter, void** _node, fs_vnode_ops** _ops,
+	int* type, uint32* flags)
 {
 	// get a free port
 	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();
@@ -958,7 +969,7 @@
 	request-&gt;reenter = reenter;
 
 	// add the uninitialized node to our map
-	VNode* vnode = new(std::nothrow) VNode(vnid, NULL);
+	VNode* vnode = new(std::nothrow) VNode(vnid, NULL, NULL);
 	if (vnode == NULL)
 		RETURN_ERROR(B_NO_MEMORY);
 	vnode-&gt;valid = false;
@@ -983,14 +994,23 @@
 		return reply-&gt;error;
 	}
 
+	// get the ops vector for the node
+	VNodeOps* ops = fFileSystem-&gt;GetVNodeOps(reply-&gt;capabilities);
+	if (ops == NULL) {
+		_RemoveInvalidVNode(vnid);
+		RETURN_ERROR(B_NO_MEMORY);
+	}
+
 	// everything went fine -- mark the node valid
 	locker.Lock();
 	vnode-&gt;clientNode = reply-&gt;node;
+	vnode-&gt;ops = ops;
 	vnode-&gt;valid = true;
 
 	*_node = vnode;
 	*type = reply-&gt;type;
 	*flags = reply-&gt;flags;
+	*_ops = ops-&gt;ops;
 	return B_OK;
 }
 
@@ -1021,7 +1041,7 @@
 	locker.Unlock();
 
 	void* clientNode = vnode-&gt;clientNode;
-	delete vnode;
+	vnode-&gt;Delete(this);
 
 	// get a free port
 	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();
@@ -3461,6 +3481,60 @@
 // #pragma mark -
 // #pragma mark ----- private implementations -----
 
+
+// _InitVolumeOps
+void
+Volume::_InitVolumeOps()
+{
+	memcpy(&amp;fVolumeOps, &amp;gUserlandFSVolumeOps, sizeof(fs_volume_ops));
+
+	#undef CLEAR_UNSUPPORTED
+	#define CLEAR_UNSUPPORTED(capability, op) 	\
+		if (!fCapabilities.Get(capability))				\
+			fVolumeOps.op = NULL
+
+	// FS operations
+	// FS_VOLUME_CAPABILITY_UNMOUNT: unmount
+		// always needed
+
+	// FS_VOLUME_CAPABILITY_READ_FS_INFO: read_fs_info
+		// always needed
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_WRITE_FS_INFO, write_fs_info);
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_SYNC, sync);
+
+	// vnode operations
+	// FS_VOLUME_CAPABILITY_GET_VNODE: get_vnode
+		// always needed
+
+	// index directory &amp; index operations
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_OPEN_INDEX_DIR, open_index_dir);
+	// FS_VOLUME_CAPABILITY_CLOSE_INDEX_DIR: close_index_dir
+		// always needed
+	// FS_VOLUME_CAPABILITY_FREE_INDEX_DIR_COOKIE: free_index_dir_cookie
+		// always needed
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_INDEX_DIR, read_index_dir);
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REWIND_INDEX_DIR, rewind_index_dir);
+
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_CREATE_INDEX, create_index);
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REMOVE_INDEX, remove_index);
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_INDEX_STAT, read_index_stat);
+
+	// query operations
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_OPEN_QUERY, open_query);
+	// FS_VOLUME_CAPABILITY_CLOSE_QUERY: close_query
+		// always needed
+	// FS_VOLUME_CAPABILITY_FREE_QUERY_COOKIE: free_query_cookie
+		// always needed
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_READ_QUERY, read_query);
+	CLEAR_UNSUPPORTED(FS_VOLUME_CAPABILITY_REWIND_QUERY, rewind_query);
+
+	#undef CLEAR_UNSUPPORTED
+}
+
+
+// #pragma mark -
+
+
 // _Mount
 status_t
 Volume::_Mount(const char* device, uint32 flags, const char* parameters)
@@ -3636,7 +3710,7 @@
 	locker.Unlock();
 
 	void* clientNode = vnode-&gt;clientNode;
-	delete vnode;
+	vnode-&gt;Delete(this);
 
 	// get a free port
 	RequestPort* port = fFileSystem-&gt;GetPortPool()-&gt;AcquirePort();
@@ -4280,7 +4354,7 @@
 	for (; vnode-&gt;useCount &gt; 0; vnode-&gt;useCount--)
 		put_vnode(fFSVolume, vnid);
 
-	delete vnode;
+	vnode-&gt;Delete(this);
 }
 
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.h	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.h	2009-03-17 18:51:43 UTC (rev 29572)
@@ -38,21 +38,24 @@
 									fs_volume* fsVolume);
 								~Volume();
 
-			FileSystem*			GetFileSystem() const;
+	inline	FileSystem*			GetFileSystem() const;
 	inline	dev_t				GetID() const;
 
+	inline	fs_volume_ops*		GetVolumeOps()		{ return &fVolumeOps; }
 	inline	bool				HasCapability(int capability) const;
 
-			void*				GetUserlandVolume() const;
-			ino_t				GetRootID() const;
+	inline	void*				GetUserlandVolume() const;
+	inline	ino_t				GetRootID() const;
 
 			// client methods
 			status_t			GetVNode(ino_t vnid, void** node);
 			status_t			PutVNode(ino_t vnid);
 			status_t			AcquireVNode(ino_t vnid);
-			status_t			NewVNode(ino_t vnid, void* node);
+			status_t			NewVNode(ino_t vnid, void* node,
+									const FSVNodeCapabilities&amp; capabilities);
 			status_t			PublishVNode(ino_t vnid, void* node,
-									int type, uint32 flags);
+									int type, uint32 flags,
+									const FSVNodeCapabilities&amp; capabilities);
 			status_t			RemoveVNode(ino_t vnid);
 			status_t			UnremoveVNode(ino_t vnid);
 			status_t			GetVNodeRemoved(ino_t vnid, bool* removed);
@@ -88,7 +91,8 @@
 			status_t			GetVNodeName(void* node, char* buffer,
 									size_t bufferSize);
 			status_t			ReadVNode(ino_t vnid, bool reenter,
-									void** node, int* type, uint32* flags);
+									void** node, fs_vnode_ops** _ops, int* type,
+									uint32* flags);
 			status_t			WriteVNode(void* node, bool reenter);
 			status_t			RemoveVNode(void* node, bool reenter);
 
@@ -227,6 +231,8 @@
 			friend class IORequestRemover;
 
 private:
+			void				_InitVolumeOps();
+
 			status_t			_Mount(const char* device, uint32 flags,
 									const char* parameters);
 			status_t			_Unmount();
@@ -289,6 +295,7 @@
 			FileSystem*			fFileSystem;
 			fs_volume*			fFSVolume;
 			FSVolumeCapabilities fCapabilities;
+			fs_volume_ops		fVolumeOps;
 			void*				fUserlandVolume;
 			ino_t				fRootID;
 			VNode*				fRootNode;
@@ -314,6 +321,15 @@
 }
 
 
+// GetFileSystem
+inline FileSystem*
+Volume::GetFileSystem() const
+{
+	return fFileSystem;
+}
+
+
+// HasCapability
 inline bool
 Volume::HasCapability(int capability) const
 {
@@ -321,6 +337,22 @@
 }
 
 
+// GetUserlandVolume
+inline void*
+Volume::GetUserlandVolume() const
+{
+	return fUserlandVolume;
+}
+
+
+// GetRootID
+inline ino_t
+Volume::GetRootID() const
+{
+	return fRootID;
+}
+
+
 inline bool
 Volume::HasVNodeCapability(VNode* vnode, int capability) const
 {

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/kernel_interface.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/kernel_interface.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -105,7 +105,7 @@
 	}
 
 	fsVolume-&gt;private_volume = volume;
-	fsVolume-&gt;ops = &gUserlandFSVolumeOps;
+	fsVolume-&gt;ops = volume-&gt;GetVolumeOps();
 	*rootVnodeID = volume-&gt;GetRootID();
 
 	PRINT((&quot;userlandfs_mount() done: %p, %lld\n&quot;, fsVolume-&gt;private_volume,
@@ -207,10 +207,12 @@
 	PRINT((&quot;userlandfs_get_vnode(%p, %lld, %p, %d)\n&quot;, volume, vnid,
 		fsNode-&gt;private_node, reenter));
 	void* node;
-	status_t error = volume-&gt;ReadVNode(vnid, reenter, &amp;node, _type, _flags);
+	fs_vnode_ops* ops;
+	status_t error = volume-&gt;ReadVNode(vnid, reenter, &amp;node, &amp;ops, _type,
+		_flags);
 	if (error == B_OK) {
 		fsNode-&gt;private_node = node;
-		fsNode-&gt;ops = &gUserlandFSVnodeOps;
+		fsNode-&gt;ops = ops;
 	}
 
 	PRINT((&quot;userlandfs_get_vnode() done: (%lx, %p)\n&quot;, error, node));

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -466,10 +466,11 @@
 	void* node;
 	int type;
 	uint32 flags;
+	FSVNodeCapabilities capabilities;
 	if (result == B_OK) {
 		RequestThreadContext context(volume);
 		result = volume-&gt;ReadVNode(request-&gt;vnid, request-&gt;reenter, &amp;node,
-			&amp;type, &amp;flags);
+			&amp;type, &amp;flags, &amp;capabilities);
 	}
 
 	// prepare the reply
@@ -483,6 +484,7 @@
 	reply-&gt;node = node;
 	reply-&gt;type = type;
 	reply-&gt;flags = flags;
+	reply-&gt;capabilities = capabilities;
 
 	// send the reply
 	return _SendReply(allocator, false);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.cpp	2009-03-17 18:30:33 UTC (rev 29571)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/Volume.cpp	2009-03-17 18:51:43 UTC (rev 29572)
@@ -1,4 +1,7 @@
-// Volume.cpp
+/*

[... truncated: 901 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014923.html">[Haiku-commits] r29571 -	haiku/trunk/headers/private/userlandfs/private
</A></li>
	<LI>Next message: <A HREF="014925.html">[Haiku-commits] r29573 - haiku/trunk/src/kits/storage/disk_device
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14924">[ date ]</a>
              <a href="thread.html#14924">[ thread ]</a>
              <a href="subject.html#14924">[ subject ]</a>
              <a href="author.html#14924">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
