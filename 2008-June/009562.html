<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25929 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine	src/add-ons/kernel/drivers/graphics/nvidia_gpgpu
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25929%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu/engine%0A%09src/add-ons/kernel/drivers/graphics/nvidia_gpgpu&In-Reply-To=%3C200806111814.m5BIEI5I027684%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009550.html">
   <LINK REL="Next"  HREF="009563.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25929 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine	src/add-ons/kernel/drivers/graphics/nvidia_gpgpu</H1>
    <B>rudolfc at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25929%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu/engine%0A%09src/add-ons/kernel/drivers/graphics/nvidia_gpgpu&In-Reply-To=%3C200806111814.m5BIEI5I027684%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25929 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine	src/add-ons/kernel/drivers/graphics/nvidia_gpgpu">rudolfc at mail.berlios.de
       </A><BR>
    <I>Wed Jun 11 20:14:18 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009550.html">[Haiku-commits] r25928 -	haiku/trunk/src/add-ons/media/media-add-ons/opensound
</A></li>
        <LI>Next message: <A HREF="009563.html">[Haiku-commits] r25930 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9562">[ date ]</a>
              <a href="thread.html#9562">[ thread ]</a>
              <a href="subject.html#9562">[ subject ]</a>
              <a href="author.html#9562">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: rudolfc
Date: 2008-06-11 20:14:15 +0200 (Wed, 11 Jun 2008)
New Revision: 25929
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25929&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25929&amp;view=rev</A>

Removed:
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_brooktreetv.c
Modified:
   haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc2.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_general.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_globals.h
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_info.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_proto.h
   haiku/trunk/src/add-ons/kernel/drivers/graphics/nvidia_gpgpu/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/nvidia_gpgpu/nvidia_gpgpu.settings
Log:
removed all pre-NV20 refs, removed all TVout stuff except clearing some flags, re-enabled force_ws option, force_ws is now default true, pgm_panel is now default false.

Modified: haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h
===================================================================
--- haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h	2008-06-11 18:14:15 UTC (rev 25929)
@@ -73,18 +73,6 @@
 
 /* card_type in order of date of NV chip design */
 enum {
-	NV04 = 0,
-	NV05,
-	NV05M64,
-	NV06,
-	NV10,
-	NV11,
-	NV11M,
-	NV15,
-	NV17,
-	NV17M,
-	NV18,
-	NV18M,
 	NV20,
 	NV25,
 	NV28,
@@ -118,27 +106,6 @@
 	NV50A
 };
 
-/* card info - information gathered from PINS (and other sources) */
-enum
-{	// tv_encoder_type in order of capability (more or less)
-	NONE = 0,
-	CH7003,
-	CH7004,
-	CH7005,
-	CH7006,
-	CH7007,
-	CH7008,
-	SAA7102,
-	SAA7103,
-	SAA7104,
-	SAA7105,
-	BT868,
-	BT869,
-	CX25870,
-	CX25871,
-	NVIDIA
-};
-
 /* handles to pre-defined engine commands */
 #define NV_ROP5_SOLID					0x00000000 /* 2D */
 #define NV_IMAGE_BLACK_RECTANGLE		0x00000001 /* 2D/3D */
@@ -214,12 +181,10 @@
 	// for accelerant
 	uint32 logmask;
 	uint32 memory;
-	uint32 tv_output;
 	bool   usebios;
 	bool   hardcursor;
 	bool   switchhead;
 	bool   pgm_panel;
-	bool   vga_on_tv;
 	bool   force_sync;
 	bool   force_ws;
 	uint32 gpu_clk;
@@ -287,7 +252,6 @@
 	display_mode dm;		/* current display mode configuration: head1 */
 	uint32 dpms_flags;		/* current DPMS mode */
 	bool acc_mode;			/* signals (non)accelerated mode */
-	bool interlaced_tv_mode;/* signals interlaced CRTC TV output mode */
 	bool crtc_switch_mode;	/* signals dualhead switch mode if panels are used */
 
   /*frame buffer config - for BDirectScreen*/
@@ -343,13 +307,6 @@
 		bool i2c_bus1;				/* we have a wired I2C bus 1 on board */
 		bool i2c_bus2;				/* we have a wired I2C bus 2 on board */
 		bool i2c_bus3;				/* we have a wired I2C bus 3 on board */
-		struct
-		{
-			uint32 type;			/* see tvchip_type enum above */
-			uint8 version;			/* chip silicon version */
-			uint8 bus;				/* I2C bus on which TVout chip resides */
-			uint8 adress;			/* I2C adress on which TVout chip resides */
-		} tv_encoder;
 		uint8 monitors;				/* output devices connection matrix */
 		bool int_assigned;			/* card has a useable INT assigned to it */
 		status_t pins_status;		/* B_OK if read correctly, B_ERROR if faked */
@@ -378,7 +335,6 @@
 		uint32 max_dac2_clock_32;
 		uint32 max_dac2_clock_32dh;
 		bool secondary_head;		/* presence of functions */
-		bool tvout;
 		bool primary_dvi;
 		bool secondary_dvi;
 		uint32 memory_size;			/* memory (in bytes) */

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c	2008-06-11 18:14:15 UTC (rev 25929)
@@ -40,8 +40,8 @@
 	// LOG is now available, si !NULL
 	LOG(4,(&quot;init_common: logmask 0x%08x, memory %dMB, hardcursor %d, usebios %d, switchhead %d\n&quot;,
 		si-&gt;settings.logmask, si-&gt;settings.memory, si-&gt;settings.hardcursor, si-&gt;settings.usebios, si-&gt;settings.switchhead));
-	LOG(4,(&quot;init_common: dumprom %d, pgm_panel %d, tv_output %d, vga_on_tv %d\n&quot;,
-		si-&gt;settings.dumprom, si-&gt;settings.pgm_panel, si-&gt;settings.tv_output, si-&gt;settings.vga_on_tv));
+	LOG(4,(&quot;init_common: dumprom %d, pgm_panel %d\n&quot;,
+		si-&gt;settings.dumprom, si-&gt;settings.pgm_panel));
 	LOG(4,(&quot;init_common: force_sync %d, gpu_clk %dMhz, ram_clk %dMhz, force_ws %d\n&quot;,
 		si-&gt;settings.force_sync, si-&gt;settings.gpu_clk, si-&gt;settings.ram_clk, si-&gt;settings.force_ws));
 
@@ -202,11 +202,6 @@
 	/* ensure DPMS state */
 	si-&gt;dpms_flags = B_DPMS_ON;
 
-	/* ensure TVout state:
-	 * TVencoder is on head to be assigned primary, no dualhead switch mode active. */
-	//fixme: actually check on what CRTC TVout was active during boot (if any)...
-	si-&gt;dm.flags = TV_PRIMARY;
-
 	/* make sure a possible 3D add-on will block rendering and re-initialize itself.
 	 * note: update in _this_ order only */
 	/* SET_DISPLAY_MODE will reset this flag when it's done. */

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c	2008-06-11 18:14:15 UTC (rev 25929)
@@ -4,7 +4,7 @@
 
 	Other authors for NV driver:
 	Mark Watson,
-	Rudolf Cornelissen 9/2002-4/2006
+	Rudolf Cornelissen 9/2002-6/2008
 */
 
 #define MODULE_BIT 0x00400000
@@ -188,69 +188,60 @@
 		return result;
 	}
 
-	/* disable aspect checks for a requested TVout mode when mode is TVout capable */
-	if (!si-&gt;ps.tvout
-		|| !(BT_check_tvmode(*target) &amp;&amp; (target-&gt;flags &amp; TV_BITS))) {
-		/* check if all connected output devices can display the requested mode's aspect: */
-		/* calculate display mode aspect */
-		target_aspect = (target-&gt;timing.h_display / ((float)target-&gt;timing.v_display));
-		/* NOTE:
-		 * allow 0.10 difference so 5:4 aspect panels will be able to use 4:3 aspect modes! */
-		switch (si-&gt;ps.monitors) {
-			case 0x01: /* digital panel on head 1, nothing on head 2 */
-				if (si-&gt;ps.panel1_aspect &lt; (target_aspect - 0.10)) {
-					LOG(4, (&quot;PROPOSEMODE: connected panel1 is not widescreen type, aborted.\n&quot;));
-					return B_ERROR;
-				}
-				break;
-			case 0x10: /* nothing on head 1, digital panel on head 2 */
-				if (si-&gt;ps.panel2_aspect &lt; (target_aspect - 0.10)) {
-					LOG(4, (&quot;PROPOSEMODE: connected panel2 is not widescreen type, aborted.\n&quot;));
-					return B_ERROR;
-				}
-				break;
-			case 0x11: /* digital panels on both heads */
-				if ((si-&gt;ps.panel1_aspect &lt; (target_aspect - 0.10))
-					|| (si-&gt;ps.panel2_aspect &lt; (target_aspect - 0.10))) {
-					LOG(4, (&quot;PROPOSEMODE: not all connected panels are widescreen type, aborted.\n&quot;));
-					return B_ERROR;
-				}
-				break;
-			default:
-#if 0
-				/* at least one analog monitor is connected, or nothing detected at all */
-				/* (if forcing widescreen type was requested don't block mode) */
-				if (target_aspect &gt; 1.34 &amp;&amp; !si-&gt;settings.force_ws) {
-					LOG(4, (&quot;PROPOSEMODE: not all output devices can display widescreen modes, aborted.\n&quot;));
-					return B_ERROR;
-				}
-#endif
-				break;
-		}
-
-// Wide screen modes are pretty common these days... - better use EDID!
-#if 0
-		/* only export widescreen panel-TV modes when an exact resolution match exists,
-		 * to prevent the modelist from becoming too crowded */
-		if (target_aspect &gt; 1.61 &amp;&amp; !si-&gt;settings.force_ws) {
-			status_t panel_TV_stat = B_ERROR;
-
-			if (si-&gt;ps.tmds1_active) {
-				if (target-&gt;timing.h_display == si-&gt;ps.p1_timing.h_display
-					&amp;&amp; target-&gt;timing.v_display == si-&gt;ps.p1_timing.v_display)
-					panel_TV_stat = B_OK;
+	/* check if all connected output devices can display the requested mode's aspect: */
+	/* calculate display mode aspect */
+	target_aspect = (target-&gt;timing.h_display / ((float)target-&gt;timing.v_display));
+	/* NOTE:
+	 * allow 0.10 difference so 5:4 aspect panels will be able to use 4:3 aspect modes! */
+	switch (si-&gt;ps.monitors) {
+		case 0x01: /* digital panel on head 1, nothing on head 2 */
+			if (si-&gt;ps.panel1_aspect &lt; (target_aspect - 0.10)) {
+				LOG(4, (&quot;PROPOSEMODE: connected panel1 is not widescreen type, aborted.\n&quot;));
+				return B_ERROR;
 			}
-			if (si-&gt;ps.tmds2_active) {
-				if (target-&gt;timing.h_display == si-&gt;ps.p2_timing.h_display
-					&amp;&amp; target-&gt;timing.v_display == si-&gt;ps.p2_timing.v_display)
-					panel_TV_stat = B_OK;
+			break;
+		case 0x10: /* nothing on head 1, digital panel on head 2 */
+			if (si-&gt;ps.panel2_aspect &lt; (target_aspect - 0.10)) {
+				LOG(4, (&quot;PROPOSEMODE: connected panel2 is not widescreen type, aborted.\n&quot;));
+				return B_ERROR;
 			}
-			if (panel_TV_stat != B_OK) {
-				LOG(4, (&quot;PROPOSEMODE: WS panel_TV mode requested but no such TV here, aborted.\n&quot;));
+			break;
+		case 0x11: /* digital panels on both heads */
+			if ((si-&gt;ps.panel1_aspect &lt; (target_aspect - 0.10))
+				|| (si-&gt;ps.panel2_aspect &lt; (target_aspect - 0.10))) {
+				LOG(4, (&quot;PROPOSEMODE: not all connected panels are widescreen type, aborted.\n&quot;));
 				return B_ERROR;
 			}
+			break;
+		default:
+			/* at least one analog monitor is connected, or nothing detected at all */
+			/* (if forcing widescreen type was requested don't block mode) */
+			if (target_aspect &gt; 1.34 &amp;&amp; !si-&gt;settings.force_ws) {
+				LOG(4, (&quot;PROPOSEMODE: not all output devices can display widescreen modes, aborted.\n&quot;));
+				return B_ERROR;
+			}
+			break;
+	}
+
+	/* only export widescreen panel-TV modes when an exact resolution match exists,
+	 * to prevent the modelist from becoming too crowded */
+	if (target_aspect &gt; 1.61 &amp;&amp; !si-&gt;settings.force_ws) {
+		status_t panel_TV_stat = B_ERROR;
+
+		if (si-&gt;ps.tmds1_active) {
+			if (target-&gt;timing.h_display == si-&gt;ps.p1_timing.h_display
+				&amp;&amp; target-&gt;timing.v_display == si-&gt;ps.p1_timing.v_display)
+				panel_TV_stat = B_OK;
 		}
-#endif
+		if (si-&gt;ps.tmds2_active) {
+			if (target-&gt;timing.h_display == si-&gt;ps.p2_timing.h_display
+				&amp;&amp; target-&gt;timing.v_display == si-&gt;ps.p2_timing.v_display)
+				panel_TV_stat = B_OK;
+		}
+		if (panel_TV_stat != B_OK) {
+			LOG(4, (&quot;PROPOSEMODE: WS panel_TV mode requested but no such TV here, aborted.\n&quot;));
+			return B_ERROR;
+		}
 	}
 
 	/* check if panel(s) can display the requested resolution (if connected) */
@@ -444,23 +435,10 @@
 	if (!(target-&gt;flags &amp; DUALHEAD_CAPABLE))
 		target-&gt;flags &amp;= ~DUALHEAD_BITS;
 
-	/* set TV_CAPABLE if suitable: pixelclock is not important (defined by TVstandard) */
-	if (si-&gt;ps.tvout &amp;&amp; BT_check_tvmode(*target))
-		target-&gt;flags |= TV_CAPABLE;
-
 	/* if not TVout capable card clear TVout flags */
 	if (!(target-&gt;flags &amp; TV_CAPABLE))
 		target-&gt;flags &amp;= ~TV_BITS;
 
-	/* make sure TV head assignment is sane */
-	if (target-&gt;flags &amp; TV_BITS) {
-		if (!si-&gt;ps.secondary_head)
-			target-&gt;flags |= TV_PRIMARY;
-		else if ((target-&gt;flags &amp; DUALHEAD_BITS) == DUALHEAD_OFF)
-			target-&gt;flags |= TV_PRIMARY;
-	} else
-		target-&gt;flags &amp;= ~TV_PRIMARY;
-
 	/* set HARDWARE_CURSOR mode if suitable */
 	if (si-&gt;settings.hardcursor)
 		target-&gt;flags |= B_HARDWARE_CURSOR;

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c	2008-06-11 18:14:15 UTC (rev 25929)
@@ -62,13 +62,9 @@
 //	head1_interrupt_enable(false);
 //	if (si-&gt;ps.secondary_head) head2_interrupt_enable(false);
 
-	/* disable TVout if supported */
-//	if (si-&gt;ps.tvout) BT_stop_tvout();
-
-	/* turn off screen(s) _after_ TVout is disabled (if applicable) */
+	/* turn off screen(s) */
 //	head1_dpms(false, false, false, true);
 //	if (si-&gt;ps.secondary_head) head2_dpms(false, false, false, true);
-//	if (si-&gt;ps.tvout) BT_dpms(false);
 
 	/*where in framebuffer the screen is (should this be dependant on previous MOVEDISPLAY?)*/
 	startadd = (uint8*)si-&gt;fbc.frame_buffer - (uint8*)si-&gt;framebuffer;
@@ -86,15 +82,6 @@
 
 		LOG(1,(&quot;SETMODE: setting DUALHEAD mode\n&quot;));
 
-		/* validate flags for secondary TVout */
-		//fixme: remove or block on autodetect fail. (is now shutoff)
-		if ((0) &amp;&amp; (target2.flags &amp; TV_BITS))
-		{
-			target.flags &amp;= ~TV_BITS;//still needed for some routines...
-			target2.flags &amp;= ~TV_BITS;
-			LOG(1,(&quot;SETMODE: blocking TVout: no TVout cable connected!\n&quot;));
-		}
-
 		/* detect which connectors have a CRT connected */
 		//fixme: 'hot-plugging' for analog monitors removed: remove code as well;
 		//or make it work with digital panels connected as well.
@@ -180,10 +167,6 @@
 			break;
 		}
 
-		/* check if we are doing interlaced TVout mode */
-		//fixme: we don't support interlaced mode?
-		si-&gt;interlaced_tv_mode = false;
-
 		/*set the display(s) pitches*/
 //		head1_set_display_pitch ();
 		//fixme: seperate for real dualhead modes:
@@ -210,9 +193,6 @@
 		/* set the timing */
 //		head1_set_timing(target);
 //		head2_set_timing(target2);
-
-		/* TVout support: program TVout encoder and modify CRTC timing */
-//		if (si-&gt;ps.tvout &amp;&amp; (target2.flags &amp; TV_BITS)) BT_setmode(target2);
 	}
 	else /* single head mode */
 	{
@@ -275,9 +255,6 @@
 		/* set the timing */
 //		head1_set_timing(target);
 
-		/* TVout support: program TVout encoder and modify CRTC timing */
-//		if (si-&gt;ps.tvout &amp;&amp; (target.flags &amp; TV_BITS)) BT_setmode(target);
-
 		//fixme: shut-off the videoPLL if it exists...
 	}
 
@@ -493,100 +470,10 @@
 		return B_ERROR;
 	}
 
-	/* CRTC used for TVout needs specific DPMS programming */
-	if (si-&gt;dm.flags &amp; TV_BITS)
-	{
-		/* TV_PRIMARY tells us that the head to be used with TVout is the head that's
-		 * actually assigned as being the primary head at powerup:
-		 * so non dualhead-mode-dependant, and not 'fixed' CRTC1! */
-		if (si-&gt;dm.flags &amp; TV_PRIMARY)
-		{
-			LOG(4,(&quot;SET_DPMS_MODE: tuning primary head DPMS settings for TVout compatibility\n&quot;));
-
-			if ((si-&gt;dm.flags &amp; DUALHEAD_BITS) != DUALHEAD_SWITCH)
-			{
-				if (!(si-&gt;settings.vga_on_tv))
-				{
-					/* block VGA output on head displaying on TV */
-					/* Note:
-					 * this specific sync setting is required: Vsync is used to keep TVout
-					 * synchronized to the CRTC 'vertically' (otherwise 'rolling' occurs).
-					 * This leaves Hsync only for shutting off the VGA screen. */
-					h1h = false;
-					h1v = true;
-					/* block panel DPMS updates */
-					do_p1 = false;
-				}
-				else
-				{
-					/* when concurrent VGA is used alongside TVout on a head, DPMS is safest
-					 * applied this way: Vsync is needed for stopping TVout successfully when
-					 * a (new) modeswitch occurs.
-					 * (see routine BT_stop_tvout() in nv_brooktreetv.c) */
-					/* Note:
-					 * applying 'normal' DPMS here and forcing Vsync on in the above mentioned
-					 * routine seems to not always be enough: sometimes image generation will
-					 * not resume in that case. */
-					h1h = display;
-					h1v = true;
-				}
-			}
-			else
-			{
-				if (!(si-&gt;settings.vga_on_tv))
-				{
-					h2h = false;
-					h2v = true;
-					do_p2 = false;
-				}
-				else
-				{
-					h2h = display;
-					h2v = true;
-				}
-			}
-		}
-		else
-		{
-			LOG(4,(&quot;SET_DPMS_MODE: tuning secondary head DPMS settings for TVout compatibility\n&quot;));
-
-			if ((si-&gt;dm.flags &amp; DUALHEAD_BITS) != DUALHEAD_SWITCH)
-			{
-				if (!(si-&gt;settings.vga_on_tv))
-				{
-					h2h = false;
-					h2v = true;
-					do_p2 = false;
-				}
-				else
-				{
-					h2h = display;
-					h2v = true;
-				}
-			}
-			else
-			{
-				if (!(si-&gt;settings.vga_on_tv))
-				{
-					h1h = false;
-					h1v = true;
-					do_p1 = false;
-				}
-				else
-				{
-					h1h = display;
-					h1v = true;
-				}
-			}
-		}
-	}
-
 	/* issue actual DPMS commands as far as applicable */
 	head1_dpms(display, h1h, h1v, do_p1);
 	if ((si-&gt;ps.secondary_head) &amp;&amp; (si-&gt;dm.flags &amp; DUALHEAD_BITS))
 		head2_dpms(display, h2h, h2v, do_p2);
-	if (si-&gt;dm.flags &amp; TV_BITS)
-		BT_dpms(display);
 
 	//fixme:
 	//add head2 once we use one driver instance 'per head' (instead of 'per card')

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile	2008-06-11 18:14:15 UTC (rev 25929)
@@ -8,7 +8,6 @@
 StaticLibrary libnvidia_gpgpu_engine.a :
 	nv_acc_dma.c
 	nv_bes.c
-	nv_brooktreetv.c
 	nv_crtc.c
 	nv_crtc2.c
 	nv_dac.c

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c	2008-06-11 18:14:15 UTC (rev 25929)
@@ -1,7 +1,7 @@
 /* NV Acceleration functions */
 
 /* Author:
-   Rudolf Cornelissen 8/2003-9/2007.
+   Rudolf Cornelissen 8/2003-6/2008.
 
    This code was possible thanks to:
     - the Linux XFree86 NV driver,
@@ -270,14 +270,6 @@
 
 		ACCW(HT_HANDL_13, (0x80000000 | NV_SCALED_IMAGE_FROM_MEMORY)); /* 32bit handle */
 		ACCW(HT_VALUE_13, 0x8001114b); /* instance $114b, engine = acc engine, CHID = $00 */
-
-		//2007 3D tests..
-		if (si-&gt;ps.card_type == NV15)
-		{
-			ACCW(HT_HANDL_14, (0x80000000 | NV_TCL_PRIMITIVE_3D)); /* 32bit handle */
-			ACCW(HT_VALUE_14, 0x8001114d); /* instance $114d, engine = acc engine, CHID = $00 */
-		}
-
 	}
 
 	/* program CTX registers: CTX1 is mostly done later (colorspace dependant) */
@@ -359,202 +351,7 @@
 									  * table is located at end of cardRAM (b12-31):
 									  * It's adress needs to be at a 4kb boundary! */
 	}
-	else
-	{
-		/* setup a DMA define for use by command defines below. */
-		ACCW(PR_CTX0_R, 0x00003000); /* DMA page table present and of linear type;
-									  * DMA target node is NVM (non-volatile memory?)
-									  * (instead of doing PCI or AGP transfers) */
-		ACCW(PR_CTX1_R, (si-&gt;ps.memory_size - 1)); /* DMA limit: size is all cardRAM */
-		ACCW(PR_CTX2_R, ((0x00000000 &amp; 0xfffff000) | 0x00000002));
-									 /* DMA access type is READ_AND_WRITE;
-									  * memory starts at start of cardRAM (b12-31):
-									  * It's adress needs to be at a 4kb boundary! */
-		ACCW(PR_CTX3_R, 0x00000002); /* unknown (looks like this is rubbish/not needed?) */
-		/* setup set '0' for cmd NV_ROP5_SOLID */
-		ACCW(PR_CTX0_0, 0x01008043); /* NVclass $043, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_0, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_0, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_0, 0x00000000); /* method traps disabled */
-		/* setup set '1' for cmd NV_IMAGE_BLACK_RECTANGLE */
-		ACCW(PR_CTX0_1, 0x01008019); /* NVclass $019, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_1, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_1, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_1, 0x00000000); /* method traps disabled */
-		/* setup set '2' for cmd NV_IMAGE_PATTERN */
-		ACCW(PR_CTX0_2, 0x01008018); /* NVclass $018, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_2, 0x00000002); /* colorspace not set, notify instance is $0200 (b16-31) */
-		ACCW(PR_CTX2_2, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_2, 0x00000000); /* method traps disabled */
-		/* setup set '3' for ... */
-		if(si-&gt;ps.card_arch &gt;= NV10A)
-		{
-			/* ... cmd NV10_CONTEXT_SURFACES_2D */
-			ACCW(PR_CTX0_3, 0x01008062); /* NVclass $062, nv10+: little endian */
-		}
-		else
-		{
-			/* ... cmd NV4_SURFACE */
-			ACCW(PR_CTX0_3, 0x01008042); /* NVclass $042, nv10+: little endian */
-		}
-		ACCW(PR_CTX1_3, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_3, 0x11401140); /* DMA0 instance is $1140, DMA1 instance invalid */
-		ACCW(PR_CTX3_3, 0x00000000); /* method trap 0 is $1140, trap 1 disabled */
-		/* setup set '4' for ... */
-		if (si-&gt;ps.card_type &gt;= NV11)
-		{
-			/* ... cmd NV12_IMAGE_BLIT */
-			ACCW(PR_CTX0_4, 0x0100809f); /* NVclass $09f, patchcfg ROP_AND, nv10+: little endian */
-		}
-		else
-		{
-			/* ... cmd NV_IMAGE_BLIT */
-			ACCW(PR_CTX0_4, 0x0100805f); /* NVclass $05f, patchcfg ROP_AND, nv10+: little endian */
-		}
-		ACCW(PR_CTX1_4, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_4, 0x11401140); /* DMA0 instance is $1140, DMA1 instance invalid */
-		ACCW(PR_CTX3_4, 0x00000000); /* method trap 0 is $1140, trap 1 disabled */
-		/* setup set '5' for cmd NV4_GDI_RECTANGLE_TEXT */
-		ACCW(PR_CTX0_5, 0x0100804a); /* NVclass $04a, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_5, 0x00000002); /* colorspace not set, notify instance is $0200 (b16-31) */
-		ACCW(PR_CTX2_5, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_5, 0x00000000); /* method traps disabled */
-		/* setup set '6' ... */
-		if (si-&gt;ps.card_arch &gt;= NV10A)
-		{
-			/* ... for cmd NV10_CONTEXT_SURFACES_ARGB_ZS */
-			ACCW(PR_CTX0_6, 0x00000093); /* NVclass $093, nv10+: little endian */
-		}
-		else
-		{
-			/* ... for cmd NV4_CONTEXT_SURFACES_ARGB_ZS */
-			ACCW(PR_CTX0_6, 0x00000053); /* NVclass $053, nv10+: little endian */
-		}
-		ACCW(PR_CTX1_6, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_6, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-		ACCW(PR_CTX3_6, 0x00000000); /* method traps disabled */
-		/* setup set '7' ... */
-		if (si-&gt;ps.card_arch &gt;= NV10A)
-		{
-			/* ... for cmd NV10_DX5_TEXTURE_TRIANGLE */
-			ACCW(PR_CTX0_7, 0x0300a094); /* NVclass $094, patchcfg ROP_AND, userclip enable,
-										  * context surface0 valid, nv10+: little endian */
-		}
-		else
-		{
-			/* ... for cmd NV4_DX5_TEXTURE_TRIANGLE */
-			ACCW(PR_CTX0_7, 0x0300a054); /* NVclass $054, patchcfg ROP_AND, userclip enable,
-										  * context surface0 valid */
-		}
-		ACCW(PR_CTX1_7, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_7, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-		ACCW(PR_CTX3_7, 0x00000000); /* method traps disabled */
-		/* setup set '8' ... */
-		if (si-&gt;ps.card_arch &gt;= NV10A)
-		{
-			/* ... for cmd NV10_DX6_MULTI_TEXTURE_TRIANGLE (not used) */
-			ACCW(PR_CTX0_8, 0x0300a095); /* NVclass $095, patchcfg ROP_AND, userclip enable,
-										  * context surface0 valid, nv10+: little endian */
-		}
-		else
-		{
-			/* ... for cmd NV4_DX6_MULTI_TEXTURE_TRIANGLE (not used) */
-			ACCW(PR_CTX0_8, 0x0300a055); /* NVclass $055, patchcfg ROP_AND, userclip enable,
-										  * context surface0 valid */
-		}
-		ACCW(PR_CTX1_8, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_8, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-		ACCW(PR_CTX3_8, 0x00000000); /* method traps disabled */
-		/* setup set '9' for cmd NV_SCALED_IMAGE_FROM_MEMORY */
-		ACCW(PR_CTX0_9, 0x01018077); /* NVclass $077, patchcfg SRC_COPY,
-									  * context surface0 valid, nv10+: little endian */
-		ACCW(PR_CTX1_9, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_9, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-		ACCW(PR_CTX3_9, 0x00000000); /* method traps disabled */
-		/* setup set 'A' for cmd NV1_RENDER_SOLID_LIN (not used) */
-		ACCW(PR_CTX0_A, 0x0300a01c); /* NVclass $01c, patchcfg ROP_AND, userclip enable,
-									  * context surface0 valid, nv10+: little endian */
-		ACCW(PR_CTX1_A, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_A, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-		ACCW(PR_CTX3_A, 0x00000000); /* method traps disabled */
-		//2007 3D tests..
-		/* setup set 'B' ... */
-		if (si-&gt;ps.card_type == NV15)
-		{
-			/* ... for cmd NV11_TCL_PRIMITIVE_3D */
-			ACCW(PR_CTX0_B, 0x0300a096); /* NVclass $096, patchcfg ROP_AND, userclip enable,
-										  * context surface0 valid, nv10+: little endian */
-			ACCW(PR_CTX1_B, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-			ACCW(PR_CTX2_B, 0x11401140); /* DMA0, DMA1 instance = $1140 */
-			ACCW(PR_CTX3_B, 0x00000000); /* method traps disabled */
-		}
-		/* setup DMA set pointed at by PF_CACH1_DMAI */
-		if (0)//si-&gt;engine.agp_mode)
-		{
-			/* DMA page table present and of linear type;
-			 * DMA class is $002 (b0-11);
-			 * DMA target node is AGP */
-			ACCW(PR_CTX0_C, 0x00033002);
-		}
-		else
-		{
-			/* DMA page table present and of linear type;
-			 * DMA class is $002 (b0-11);
-			 * DMA target node is PCI */
-			ACCW(PR_CTX0_C, 0x00023002);
-		}
-		ACCW(PR_CTX1_C, 0x000fffff); /* DMA limit: tablesize is 1M bytes */
-		ACCW(PR_CTX2_C, (((uint32)((uint8 *)(si-&gt;dma_buffer_pci))) | 0x00000002));
-									 /* DMA access type is READ_AND_WRITE;
-									  * table is located in main system RAM (b12-31):
-									  * It's adress needs to be at a 4kb boundary! */
 
-		/* set the 3D rendering functions colordepth via BPIXEL's 'depth 2' */
-		/* note:
-		 * setting a depth to 'invalid' (zero) makes the engine report
-		 * ready with drawing 'immediately'. */
-		//fixme: NV30A and above (probably) needs to be corrected...
-		switch(si-&gt;dm.space)
-		{
-		case B_CMAP8:
-			if (si-&gt;ps.card_arch &lt; NV30A)
-				/* set depth 2: $1 = Y8 */
-				ACCW(BPIXEL, 0x00000100);
-			else
-				/* set depth 0-1: $1 = Y8, $2 = X1R5G5B5_Z1R5G5B5 */
-				ACCW(BPIXEL, 0x00000021);
-			break;
-		case B_RGB15_LITTLE:
-			if (si-&gt;ps.card_arch &lt; NV30A)
-				/* set depth 2: $4 = A1R5G5B5 */
-				ACCW(BPIXEL, 0x00000400);
-			else
-				/* set depth 0-1: $2 = X1R5G5B5_Z1R5G5B5, $4 = A1R5G5B5 */
-				ACCW(BPIXEL, 0x00000042);
-			break;
-		case B_RGB16_LITTLE:
-			if (si-&gt;ps.card_arch &lt; NV30A)
-				/* set depth 2: $5 = R5G6B5 */
-				ACCW(BPIXEL, 0x00000500);
-			else
-				/* set depth 0-1: $5 = R5G6B5, $a = X1A7R8G8B8_O1A7R8G8B8 */
-				ACCW(BPIXEL, 0x000000a5);
-			break;
-		case B_RGB32_LITTLE:
-		case B_RGBA32_LITTLE:
-			if (si-&gt;ps.card_arch &lt; NV30A)
-				/* set depth 2: $c = A8R8G8B8 */
-				ACCW(BPIXEL, 0x00000c00);
-			else
-				/* set depth 0-1: $7 = X8R8G8B8_Z8R8G8B8, $e = V8YB8U8YA8 */
-				ACCW(BPIXEL, 0x000000e7);
-			break;
-		default:
-			LOG(8,(&quot;ACC: init, invalid bit depth\n&quot;));
-			return B_ERROR;
-		}
-	}
-
 	if (si-&gt;ps.card_arch == NV04A)
 	{
 		/* do a explicit engine reset */
@@ -921,11 +718,8 @@
 	/* setup sync parameters for NV12_IMAGE_BLIT command for the current mode:
 	 * values given are CRTC vertical counter limit values. The NV12 command will wait
 	 * for the specified's CRTC's vertical counter to be in between the given values */
-	if (si-&gt;ps.card_type &gt;= NV11)
-	{
-		ACCW(NV11_CRTC_LO, si-&gt;dm.timing.v_display - 1);
-		ACCW(NV11_CRTC_HI, si-&gt;dm.timing.v_display + 1);
-	}
+	ACCW(NV11_CRTC_LO, si-&gt;dm.timing.v_display - 1);
+	ACCW(NV11_CRTC_HI, si-&gt;dm.timing.v_display + 1);
 
 	/*** PFIFO ***/
 	/* (setup caches) */
@@ -1773,26 +1567,15 @@
 		((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = 0x00000002; /* Format */
 	}
 
-	/* TNT1 has fixed operation mode 'SRCcopy' while the rest can be programmed: */
-	if (si-&gt;ps.card_type != NV04)
-	{
-		/* wait for room in fifo for cmds if needed. */
-		if (nv_acc_fifofree_dma(5) != B_OK) return;
-		/* now setup source bitmap colorspace */
-		nv_acc_cmd_dma(NV_SCALED_IMAGE_FROM_MEMORY, NV_SCALED_IMAGE_FROM_MEMORY_SETCOLORFORMAT, 2);
-		((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = cmd_depth; /* SetColorFormat */
-		/* now setup operation mode to SRCcopy */
-		((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = 0x00000003; /* SetOperation */
-	}
-	else
-	{
-		/* wait for room in fifo for cmd if needed. */
-		if (nv_acc_fifofree_dma(4) != B_OK) return;
-		/* now setup source bitmap colorspace */
-		nv_acc_cmd_dma(NV_SCALED_IMAGE_FROM_MEMORY, NV_SCALED_IMAGE_FROM_MEMORY_SETCOLORFORMAT, 1);
-		((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = cmd_depth; /* SetColorFormat */
-		/* TNT1 has fixed operation mode SRCcopy */
-	}
+	/* program operation mode 'SRCcopy' */
+	/* wait for room in fifo for cmds if needed. */
+	if (nv_acc_fifofree_dma(5) != B_OK) return;
+	/* now setup source bitmap colorspace */
+	nv_acc_cmd_dma(NV_SCALED_IMAGE_FROM_MEMORY, NV_SCALED_IMAGE_FROM_MEMORY_SETCOLORFORMAT, 2);
+	((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = cmd_depth; /* SetColorFormat */
+	/* now setup operation mode to SRCcopy */
+	((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = 0x00000003; /* SetOperation */
+
 	/* now setup fill color (writing 2 32bit words) */
 	nv_acc_cmd_dma(NV4_GDI_RECTANGLE_TEXT, NV4_GDI_RECTANGLE_TEXT_COLOR1A, 1);
 	((uint32*)(si-&gt;dma_buffer))[si-&gt;engine.dma.current++] = 0x00000000; /* Color1A */

Deleted: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_brooktreetv.c

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc.c	2008-06-11 14:59:40 UTC (rev 25928)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc.c	2008-06-11 18:14:15 UTC (rev 25929)
@@ -1,6 +1,6 @@
 /* CTRC functionality */
 /* Author:
-   Rudolf Cornelissen 11/2002-2/2006
+   Rudolf Cornelissen 11/2002-6/2008
 */
 
 #define MODULE_BIT 0x00040000
@@ -29,79 +29,8 @@
 	return result;
 }
 
-/* doing general fail-safe default setup here */
-//fixme: this is a _very_ basic setup, and it's preliminary...
 status_t nv_crtc_update_fifo()
 {
-	uint8 bytes_per_pixel = 1;
-	uint32 drain;
-
-	/* we are only using this on &gt;&gt;coldstarted&lt;&lt; cards which really need this */
-	//fixme: re-enable or remove after general user confirmation of behaviour...
-	if (/*(si-&gt;settings.usebios) ||*/ (si-&gt;ps.card_type != NV05M64)) return B_OK;
-
-	/* enable access to primary head */
-	set_crtc_owner(0);
-
-	/* set CRTC FIFO low watermark according to memory drain */
-	switch(si-&gt;dm.space)
-	{
-	case B_CMAP8:
-		bytes_per_pixel = 1;
-		break;
-	case B_RGB15_LITTLE:
-	case B_RGB16_LITTLE:
-		bytes_per_pixel = 2;
-		break;
-	case B_RGB24_LITTLE:
-		bytes_per_pixel = 3;
-		break;
-	case B_RGB32_LITTLE:
-		bytes_per_pixel = 4;
-		break;
-	}
-	/* fixme:
-	 * - I should probably include the refreshrate as well;
-	 * - and the memory clocking speed, core clocking speed, RAM buswidth.. */
-	drain = si-&gt;dm.timing.h_display * si-&gt;dm.timing.v_display * bytes_per_pixel;
-
-	/* Doesn't work for other than 32bit space (yet?) */
-	if (si-&gt;dm.space != B_RGB32_LITTLE)
-	{
-		/* BIOS defaults */
-		CRTCW(FIFO, 0x03);
-		CRTCW(FIFO_LWM, 0x20);
-		LOG(4,(&quot;CRTC: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));
-		return B_OK;
-	}
-
-	if (drain &gt; (((uint32)1280) * 1024 * 4))
-	{
-		/* set CRTC FIFO burst size for 'smaller' bursts */
-		CRTCW(FIFO, 0x01);
-		/* Instruct CRTC to fetch new data 'earlier' */
-		CRTCW(FIFO_LWM, 0x40);
-		LOG(4,(&quot;CRTC: FIFO low-watermark set to $40, burst size 64\n&quot;));
-	}
-	else
-	{
-		if (drain &gt; (((uint32)1024) * 768 * 4))
-		{
-			/* BIOS default */
-			CRTCW(FIFO, 0x02);
-			/* Instruct CRTC to fetch new data 'earlier' */
-			CRTCW(FIFO_LWM, 0x40);
-			LOG(4,(&quot;CRTC: FIFO low-watermark set to $40, burst size 128\n&quot;));
-		}
-		else
-		{
-			/* BIOS defaults */
-			CRTCW(FIFO, 0x03);
-			CRTCW(FIFO_LWM, 0x20);
-			LOG(4,(&quot;CRTC: FIFO low-watermark set to $20, burst size 256 (BIOS defaults)\n&quot;));
-		}
-	}
-
 	return B_OK;
 }
 
@@ -127,14 +56,7 @@
 	/* NOTE: keep horizontal timing at multiples of 8! */
 	/* confine to a reasonable width */
 	if (*hd_e &lt; 640) *hd_e = 640;
-	if (si-&gt;ps.card_type &gt; NV04)
-	{
-		if (*hd_e &gt; 2048) *hd_e = 2048;
-	}
-	else
-	{
-		if (*hd_e &gt; 1920) *hd_e = 1920;
-	}
+	if (*hd_e &gt; 2048) *hd_e = 2048;
 
 	/* if hor. total does not leave room for a sensible sync pulse, increase it! */
 	if (*ht &lt; (*hd_e + 80)) *ht = (*hd_e + 80);
@@ -160,14 +82,7 @@
 
 	/* confine to a reasonable height */
 	if (*vd_e &lt; 480) *vd_e = 480;
-	if (si-&gt;ps.card_type &gt; NV04)
-	{
-		if (*vd_e &gt; 1536) *vd_e = 1536;
-	}
-	else
-	{
-		if (*vd_e &gt; 1440) *vd_e = 1440;
-	}
+	if (*vd_e &gt; 1536) *vd_e = 1536;
 
 	/*if vertical total does not leave room for a sync pulse, increase it!*/
 	if (*vt &lt; (*vd_e + 3)) *vt = (*vd_e + 3);
@@ -238,12 +153,8 @@
 		 * OTOH the overlay unit distorts if we reserve too much time! */
 		if (target.timing.h_display == si-&gt;ps.p1_timing.h_display)
 		{
-			/* NV11 timing has different constraints than later cards */
-			if (si-&gt;ps.card_type == NV11)
-				target.timing.h_total -= 56;
-			else
-				/* confirmed NV34 with 1680x1050 panel */
-				target.timing.h_total -= 32;
+			/* confirmed NV34 with 1680x1050 panel */
+			target.timing.h_total -= 32;
 		}
 
 		if (target.timing.h_sync_start == target.timing.h_display)
@@ -409,7 +320,6 @@
 	CRTCW(INTERLACE, 0xff);
 
 	/* disable CRTC slaved mode unless a panel is in use */
-	// fixme: this kills TVout when it was in use...
 	if (!si-&gt;ps.tmds1_active) CRTCW(PIXEL, (CRTCR(PIXEL) &amp; 0x7f));
 
 	/* setup flatpanel if connected and active */
@@ -622,7 +532,7 @@
 			{
 				//fixme? linux only does this on dualhead cards...
 				//fixme: see if LVDS head can be determined with two panels there...
-				if (!si-&gt;ps.tmds2_active &amp;&amp; (si-&gt;ps.card_type != NV11))
+				if (!si-&gt;ps.tmds2_active)
 				{
 					/* b2 = 0 = enable laptop panel backlight */
 					/* note: this seems to be a write-only register. */
@@ -665,7 +575,7 @@
 			{
 				//fixme? linux only does this on dualhead cards...
 				//fixme: see if LVDS head can be determined with two panels there...
-				if (!si-&gt;ps.tmds2_active &amp;&amp; (si-&gt;ps.card_type != NV11))
+				if (!si-&gt;ps.tmds2_active)
 				{
 					/* b2 = 1 = disable laptop panel backlight */
 					/* note: this seems to be a write-only register. */
@@ -984,131 +894,3 @@
 
 	return B_OK;
 }
-
-status_t nv_crtc_stop_tvout(void)
-{
-	uint16 cnt;
-
-	LOG(4,(&quot;CRTC: stopping TV output\n&quot;));
-
-	/* enable access to primary head */
-	set_crtc_owner(0);
-
-	/* just to be sure Vsync is _really_ enabled */
-	CRTCW(REPAINT1, (CRTCR(REPAINT1) &amp; 0xbf));
-
-	/* wait for one image to be generated to make sure VGA has kicked in and is
-	 * running OK before continuing...
-	 * (Kicking in will fail often if we do not wait here) */
-	/* Note:
-	 * The used CRTC's Vsync is required to be enabled here. The DPMS state
-	 * programming in the driver makes sure this is the case.
-	 * (except for driver startup: see nv_general.c.) */
-
-	/* make sure we are 'in' active VGA picture: wait with timeout! */
-	cnt = 1;
-	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)
-	{
-		snooze(1);
-		cnt++;
-	}
-	/* wait for next vertical retrace start on VGA: wait with timeout! */
-	cnt = 1;
-	while ((!(NV_REG8(NV8_INSTAT1) &amp; 0x08)) &amp;&amp; cnt)
-	{
-		snooze(1);
-		cnt++;
-	}
-	/* now wait until we are 'in' active VGA picture again: wait with timeout! */
-	cnt = 1;
-	while ((NV_REG8(NV8_INSTAT1) &amp; 0x08) &amp;&amp; cnt)
-	{
-		snooze(1);
-		cnt++;
-	}
-
-	/* set CRTC to master mode (b7 = 0) if it wasn't slaved for a panel before */
-	if (!(si-&gt;ps.slaved_tmds1))	CRTCW(PIXEL, (CRTCR(PIXEL) &amp; 0x03));
-
-	/* CAUTION:
-	 * On old cards, PLLSEL (and TV_SETUP?) cannot be read (sometimes?), but
-	 * write actions do succeed ...
-	 * This is confirmed for both ISA and PCI access, on NV04 and NV11. */
-
-	/* setup TVencoder connection */
-	/* b1-0 = %00: encoder type is SLAVE;
-	 * b24 = 1: VIP datapos is b0-7 */
-	//fixme if needed: setup completely instead of relying on pre-init by BIOS..
-	//(it seems to work OK on NV04 and NV11 although read reg. doesn't seem to work)
-	DACW(TV_SETUP, ((DACR(TV_SETUP) &amp; ~0x00000003) | 0x01000000));
-
-	/* tell GPU to use pixelclock from internal source instead of using TVencoder */
-	if (si-&gt;ps.secondary_head)
-		DACW(PLLSEL, 0x30000f00);
-	else
-		DACW(PLLSEL, 0x10000700);
-
-	/* HTOTAL, VTOTAL and OVERFLOW return their default CRTC use, instead of
-	 * H, V-low and V-high 'shadow' counters(?)(b0, 4 and 6 = 0) (b7 use = unknown) */
-	CRTCW(TREG, 0x00);
-
-	/* select panel encoder, not TV encoder if needed (b0 = 1).
-	 * Note:
-	 * Both are devices (often) using the CRTC in slaved mode. */
-	if (si-&gt;ps.slaved_tmds1) CRTCW(LCD, (CRTCR(LCD) | 0x01));
-
-	return B_OK;
-}
-
-status_t nv_crtc_start_tvout(void)
-{
-	LOG(4,(&quot;CRTC: starting TV output\n&quot;));
-
-	if (si-&gt;ps.secondary_head)
-	{
-		/* switch TV encoder to CRTC1 */
-		NV_REG32(NV32_2FUNCSEL) &amp;= ~0x00000100;
-		NV_REG32(NV32_FUNCSEL) |= 0x00000100;
-	}

[... truncated: 1366 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009550.html">[Haiku-commits] r25928 -	haiku/trunk/src/add-ons/media/media-add-ons/opensound
</A></li>
	<LI>Next message: <A HREF="009563.html">[Haiku-commits] r25930 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9562">[ date ]</a>
              <a href="thread.html#9562">[ thread ]</a>
              <a href="subject.html#9562">[ subject ]</a>
              <a href="author.html#9562">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
