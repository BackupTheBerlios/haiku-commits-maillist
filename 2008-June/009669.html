<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25999 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25999%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu/engine&In-Reply-To=%3C200806171916.m5HJGs7M018559%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009666.html">
   <LINK REL="Next"  HREF="009671.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25999 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine</H1>
    <B>rudolfc at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25999%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu%0A%09src/add-ons/accelerants/nvidia_gpgpu/engine&In-Reply-To=%3C200806171916.m5HJGs7M018559%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25999 - in haiku/trunk:	headers/private/graphics/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu	src/add-ons/accelerants/nvidia_gpgpu/engine">rudolfc at mail.berlios.de
       </A><BR>
    <I>Tue Jun 17 21:16:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009666.html">[Haiku-commits] r25998 - in	haiku/trunk/src/add-ons/input_server/methods: . t9
</A></li>
        <LI>Next message: <A HREF="009671.html">[Haiku-commits] r26000 - haiku/trunk/headers/private/graphics/nvidia
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9669">[ date ]</a>
              <a href="thread.html#9669">[ thread ]</a>
              <a href="subject.html#9669">[ subject ]</a>
              <a href="author.html#9669">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: rudolfc
Date: 2008-06-17 21:16:40 +0200 (Tue, 17 Jun 2008)
New Revision: 25999
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25999&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25999&amp;view=rev</A>

Removed:
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Overlay.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_bes.c
Modified:
   haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Cursor.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/GetAccelerantHook.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Jamfile
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_crtc.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_dac.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_dac2.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_general.c
   haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_info.c
Log:
removed all pre-NV40refs, removed all overlay code (no info on the current engine known). Driver cleanup mostly done now I hope.

Modified: haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h
===================================================================
--- haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/headers/private/graphics/nvidia_gpgpu/DriverInterface.h	2008-06-17 19:16:40 UTC (rev 25999)
@@ -73,16 +73,7 @@
 
 /* card_type in order of date of NV chip design */
 enum {
-	NV20,
-	NV25,
-	NV28,
-	NV30,
-	NV31,
-	NV34,
-	NV35,
-	NV36,
-	NV38,
-	NV40,
+	NV40 = 0,
 	NV41,
 	NV43,
 	NV44,
@@ -98,11 +89,7 @@
 
 /* card_arch in order of date of NV chip design */
 enum {
-	NV04A = 0,
-	NV10A,
-	NV20A,
-	NV30A,
-	NV40A,
+	NV40A = 0,
 	NV50A
 };
 
@@ -124,28 +111,13 @@
  */
 //#define NV3_GDI_RECTANGLE_TEXT			0x00000012 /* 2D */
 #define NV4_GDI_RECTANGLE_TEXT			0x00000012 /* 2D */
-#define NV4_CONTEXT_SURFACES_ARGB_ZS	0x00000013 /* 3D */
-#define NV10_CONTEXT_SURFACES_ARGB_ZS	0x00000013 /* 3D */
-#define NV4_DX5_TEXTURE_TRIANGLE		0x00000014 /* 3D */
-#define NV10_DX5_TEXTURE_TRIANGLE		0x00000014 /* 3D */
-#define NV4_DX6_MULTI_TEXTURE_TRIANGLE	0x00000015 /* unused (yet?) */
-#define NV10_DX6_MULTI_TEXTURE_TRIANGLE	0x00000015 /* unused (yet?) */
 #define NV1_RENDER_SOLID_LIN			0x00000016 /* 2D: unused */
 
-/* max. number of overlay buffers */
-#define MAXBUFFERS 3
-
 //-----------------------------------------------------------------------------------
 /* safety byte-offset from end of cardRAM for preventing acceleration engine crashes
  * caused by the existance of DMA engine command buffers in cardRAM and/or fifo
  * channel engine command re-assigning on-the-fly */
 
-/* pre-NV40 notes:
- * - we need at least 70kB distance from the end of RAM for fifo-reassigning 'bug'
- *   (confirmed on a TNT1);
- * - keep extra failsafe room to prevent malfunctioning apps from crashing engine. */
-#define PRE_NV40_OFFSET		80 * 1024
-
 /* NV40 and higher notes:
  * - we need at least 416kB distance from the DMA command buffer:
  *   If you get too close to the DMA command buffer on NV40 and NV43 at least (both
@@ -346,22 +318,6 @@
 	/* some configuration settings from ~/config/settings/kernel/drivers/nv.settings if exists */
 	nv_settings settings;
 
-	struct
-	{
-		overlay_buffer myBuffer[MAXBUFFERS];/* scaler input buffers */
-		int_buf_info myBufInfo[MAXBUFFERS];	/* extra info on scaler input buffers */
-		overlay_token myToken;				/* scaler is free/in use */
-		benaphore lock;						/* for creating buffers and aquiring overlay unit routines */
-		bool crtc;							/* location of overlay unit */
-		/* variables needed for virtualscreens (move_overlay()): */
-		bool active;						/* true is overlay currently in use */
-		overlay_window ow;					/* current position of overlay output window */
-		overlay_buffer ob;					/* current inputbuffer in use */
-		overlay_view my_ov;					/* current corrected view in inputbuffer */
-		uint32 h_ifactor;					/* current 'unclipped' horizontal inverse scaling factor */
-		uint32 v_ifactor;					/* current 'unclipped' vertical inverse scaling factor */
-	} overlay;
-
 } shared_info;
 
 /* Read or write a value in PCI configuration space */

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Cursor.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Cursor.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Cursor.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -4,7 +4,7 @@
 
 	Other authors:
 	Mark Watson,
-	Rudolf Cornelissen 4/2003-5/2004
+	Rudolf Cornelissen 4/2003-6/2008
 */
 
 #define MODULE_BIT 0x20000000
@@ -96,7 +96,6 @@
 	if ((hds!=si-&gt;dm.h_display_start) || (vds!=si-&gt;dm.v_display_start)) 
 	{
 		MOVE_DISPLAY(hds,vds);
-		nv_bes_move_overlay();
 	}
 
 	/* put cursor in correct physical position, so stay onscreen (rel. to CRTC) */

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/GetAccelerantHook.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/GetAccelerantHook.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/GetAccelerantHook.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -24,8 +24,6 @@
 /*
 These definitions are out of pure lazyness.
 */
-#define CHKO(x) case B_##x: \
-	if (check_overlay_capability(B_##x) == B_OK) return (void *)x; else return (void *)0
 #define CHKA(x) case B_##x: \
 	if (check_acc_capability(B_##x) == B_OK) \
 		return (void *)x##_DMA; \
@@ -93,16 +91,7 @@
 		Note: These hooks are re-acquired by the app_server after each mode switch.
 		*/
 
-		/* only export video overlay functions if card is capable of it */
-		//CHKO(OVERLAY_COUNT);
-		//CHKO(OVERLAY_SUPPORTED_SPACES);
-		//CHKO(OVERLAY_SUPPORTED_FEATURES);
-		//CHKO(ALLOCATE_OVERLAY_BUFFER);
-		//CHKO(RELEASE_OVERLAY_BUFFER);
-		//CHKO(GET_OVERLAY_CONSTRAINTS);
-		//CHKO(ALLOCATE_OVERLAY);
-		//CHKO(RELEASE_OVERLAY);
-		//CHKO(CONFIGURE_OVERLAY);
+		/* video overlay functions are not supported */
 
 		/*
 		When requesting an acceleration hook, the calling application provides a
@@ -129,65 +118,12 @@
 	/* Return a null pointer for any feature we don't understand. */
 	return 0;
 }
-#undef CHKO
 #undef CHKA
 #undef CHKD
 #undef HOOK
 #undef ZERO
 #undef HRDC
 
-status_t check_overlay_capability(uint32 feature)
-{
-	char *msg = &quot;&quot;;
-
-	/* setup logmessage text */
-	switch (feature)
-	{
-	case B_OVERLAY_COUNT:
-		msg = &quot;B_OVERLAY_COUNT&quot;;
-		break;
-	case B_OVERLAY_SUPPORTED_SPACES:
-		msg = &quot;B_OVERLAY_SUPPORTED_SPACES&quot;;
-		break;
-	case B_OVERLAY_SUPPORTED_FEATURES:
-		msg = &quot;B_OVERLAY_SUPPORTED_FEATURES&quot;;
-		break;
-	case B_ALLOCATE_OVERLAY_BUFFER:
-		msg = &quot;B_ALLOCATE_OVERLAY_BUFFER&quot;;
-		break;
-	case B_RELEASE_OVERLAY_BUFFER:
-		msg = &quot;B_RELEASE_OVERLAY_BUFFER&quot;;
-		break;
-	case B_GET_OVERLAY_CONSTRAINTS:
-		msg = &quot;B_GET_OVERLAY_CONSTRAINTS&quot;;
-		break;
-	case B_ALLOCATE_OVERLAY:
-		msg = &quot;B_ALLOCATE_OVERLAY&quot;;
-		break;
-	case B_RELEASE_OVERLAY:
-		msg = &quot;B_RELEASE_OVERLAY&quot;;
-		break;
-	case B_CONFIGURE_OVERLAY:
-		msg = &quot;B_CONFIGURE_OVERLAY&quot;;
-		break;
-	default:
-		msg = &quot;UNKNOWN&quot;;
-		break;
-	}
-
-	/* all older cards have a supported bes */
-	if ((si-&gt;ps.card_type &lt;= NV40) || (si-&gt;ps.card_type == NV45))
-	{
-		LOG(4, (&quot;Overlay: Exporting hook %s.\n&quot;, msg));
-		return B_OK;
-	}
-
-	/* all newer NV40 architecture cards have a new HDTV capable bes except for
-	 * GeForce 6800's. Unfortunately we have no info about the new bes yet. */
-	LOG(4, (&quot;Overlay: Not exporting hook %s.\n&quot;, msg));
-	return B_ERROR;
-}
-
 status_t check_acc_capability(uint32 feature)
 {
 	char *msg = &quot;&quot;;

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/InitAccelerant.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -97,7 +97,6 @@
 {
 	status_t result;
 	int pointer_reservation; //mem reserved for pointer
-	int cnt; 				 //used for iteration through the overlay buffers
 
 	if (0) {
 		time_t now = time (NULL);
@@ -174,20 +173,6 @@
 	si-&gt;engine.threeD.reload = 0xffffffff;
 	INIT_BEN(si-&gt;engine.lock);
 
-	INIT_BEN(si-&gt;overlay.lock);
-	for (cnt = 0; cnt &lt; MAXBUFFERS; cnt++)
-	{
-		/* make sure overlay buffers are 'marked' as being free */
-		si-&gt;overlay.myBuffer[cnt].buffer = NULL;
-		si-&gt;overlay.myBuffer[cnt].buffer_dma = NULL;
-	}
-
-	/* make sure overlay unit is 'marked' as being free */
-	si-&gt;overlay.myToken = NULL;	
-
-	/* note that overlay is not in use (for nv_bes_move_overlay()) */
-	si-&gt;overlay.active = false;
-
 	/* bail out if something failed */
 	if (result != B_OK) goto error1;
 
@@ -347,7 +332,6 @@
 
 		/* delete benaphores ONLY if we are the primary accelerant */
 		DELETE_BEN(si-&gt;engine.lock);
-		DELETE_BEN(si-&gt;overlay.lock);
 
 		/* ensure that INIT_ACCELERANT can be executed again */
 		si-&gt;accelerant_in_use = false;

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Jamfile	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Jamfile	2008-06-17 19:16:40 UTC (rev 25999)
@@ -15,7 +15,6 @@
 	GetModeInfo.c
 	GetTimingConstraints.c
 	InitAccelerant.c
-	Overlay.c
 	ProposeDisplayMode.c
 	SetDisplayMode.c
 	: libnvidia_gpgpu_engine.a

Deleted: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/Overlay.c

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/ProposeDisplayMode.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -343,10 +343,7 @@
 
 	/* Reserve extra space as a workaround for certain bugs (see DriverInterface.h
 	 * for an explanation). */
-	if (si-&gt;ps.card_arch &lt; NV40A)
-		mem_reservation += PRE_NV40_OFFSET;
-	else
-		mem_reservation += NV40_PLUS_OFFSET;
+	mem_reservation += NV40_PLUS_OFFSET;
 
 	/* memory requirement for frame buffer */
 	if (row_bytes * target-&gt;virtual_height &gt; si-&gt;ps.memory_size - mem_reservation) {

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/SetDisplayMode.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -288,13 +288,8 @@
 	si-&gt;engine.threeD.mem_high = si-&gt;ps.memory_size - 1;
 	/* Keep some extra distance as a workaround for certain bugs (see
 	 * DriverInterface.h for an explanation). */
-	if (si-&gt;ps.card_arch &lt; NV40A)
-		si-&gt;engine.threeD.mem_high -= PRE_NV40_OFFSET;
-	else
-		si-&gt;engine.threeD.mem_high -= NV40_PLUS_OFFSET;
+	si-&gt;engine.threeD.mem_high -= NV40_PLUS_OFFSET;
 
-	si-&gt;engine.threeD.mem_high -= (MAXBUFFERS * 1024 * 1024 * 2); /* see overlay.c file */
-
 	/* restore screen(s) output state(s) */
 //	SET_DPMS_MODE(si-&gt;dpms_flags);
 

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/Jamfile	2008-06-17 19:16:40 UTC (rev 25999)
@@ -7,7 +7,6 @@
 
 StaticLibrary libnvidia_gpgpu_engine.a :
 	nv_acc_dma.c
-	nv_bes.c
 	nv_crtc.c
 	nv_crtc2.c
 	nv_dac.c

Modified: haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c	2008-06-17 16:45:20 UTC (rev 25998)
+++ haiku/trunk/src/add-ons/accelerants/nvidia_gpgpu/engine/nv_acc_dma.c	2008-06-17 19:16:40 UTC (rev 25999)
@@ -21,7 +21,6 @@
 blit
 */
 
-static void nv_init_for_3D_dma(void);
 static void nv_start_dma(void);
 static status_t nv_acc_fifofree_dma(uint16 cmd_size);
 static void nv_acc_cmd_dma(uint32 cmd, uint16 offset, uint16 size);
@@ -85,27 +84,6 @@
 	snooze(1000);
 	NV_REG32(NV32_PWRUPCTRL) = 0x13111111;
 
-	/* don't try this on NV20 and later.. */
-	/* note:
-	 * the specific register that's responsible for the speedfix on NV18 is
-	 * $00400ed8: bit 6 needs to be zero for fastest rendering (confirmed). */
-	/* note also:
-	 * on NV28 the following ranges could be reset (confirmed):
-	 * $00400000 upto/incl. $004002fc;
-	 * $00400400 upto/incl. $004017fc;
-	 * $0040180c upto/incl. $00401948;
-	 * $00401994 upto/incl. $00401a80;
-	 * $00401a94 upto/incl. $00401ffc.
-	 * The intermediate ranges hang the engine upon resetting. */
-	if (si-&gt;ps.card_arch &lt; NV20A)
-	{
-		/* actively reset the PGRAPH registerset (acceleration engine) */
-		for (cnt = 0x00400000; cnt &lt; 0x00402000; cnt +=4)
-		{
-			NV_REG32(cnt) = 0x00000000;
-		}
-	}
-
 	/* setup PTIMER: */
 	//fixme? how about NV28 setup as just after coldstarting? (see nv_info.c)
 	/* set timer numerator to 8 (in b0-15) */
@@ -118,72 +96,63 @@
 	/* reset timer-alarm INT status bit (b0) */
 	ACCW(PT_INTSTAT, 0xffffffff);
 
-	/* enable PRAMIN write access on pre NV10 before programming it! */
-	if (si-&gt;ps.card_arch == NV04A)
+	/* setup acc engine 'source' tile adressranges */
+	if ((si-&gt;ps.card_type == NV40) || (si-&gt;ps.card_type == NV45))
 	{
-		/* set framebuffer config: type = notiling, PRAMIN write access enabled */
-		NV_REG32(NV32_PFB_CONFIG_0) = 0x00001114;
+		ACCW(NV10_FBTIL0AD, 0);
+		ACCW(NV10_FBTIL1AD, 0);
+		ACCW(NV10_FBTIL2AD, 0);
+		ACCW(NV10_FBTIL3AD, 0);
+		ACCW(NV10_FBTIL4AD, 0);
+		ACCW(NV10_FBTIL5AD, 0);
+		ACCW(NV10_FBTIL6AD, 0);
+		ACCW(NV10_FBTIL7AD, 0);
+		ACCW(NV10_FBTIL0ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL1ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL2ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL3ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL4ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL5ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL6ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV10_FBTIL7ED, (si-&gt;ps.memory_size - 1));
 	}
 	else
 	{
-		/* setup acc engine 'source' tile adressranges */
-		if ((si-&gt;ps.card_type &lt;= NV40) || (si-&gt;ps.card_type == NV45))
+		/* NV41, 43, 44, G70 and up */
+		ACCW(NV41_FBTIL0AD, 0);
+		ACCW(NV41_FBTIL1AD, 0);
+		ACCW(NV41_FBTIL2AD, 0);
+		ACCW(NV41_FBTIL3AD, 0);
+		ACCW(NV41_FBTIL4AD, 0);
+		ACCW(NV41_FBTIL5AD, 0);
+		ACCW(NV41_FBTIL6AD, 0);
+		ACCW(NV41_FBTIL7AD, 0);
+		ACCW(NV41_FBTIL8AD, 0);
+		ACCW(NV41_FBTIL9AD, 0);
+		ACCW(NV41_FBTILAAD, 0);
+		ACCW(NV41_FBTILBAD, 0);
+		ACCW(NV41_FBTIL0ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL1ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL2ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL3ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL4ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL5ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL6ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL7ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL8ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTIL9ED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTILAED, (si-&gt;ps.memory_size - 1));
+		ACCW(NV41_FBTILBED, (si-&gt;ps.memory_size - 1));
+
+		if (si-&gt;ps.card_type &gt;= G70)
 		{
-			ACCW(NV10_FBTIL0AD, 0);
-			ACCW(NV10_FBTIL1AD, 0);
-			ACCW(NV10_FBTIL2AD, 0);
-			ACCW(NV10_FBTIL3AD, 0);
-			ACCW(NV10_FBTIL4AD, 0);
-			ACCW(NV10_FBTIL5AD, 0);
-			ACCW(NV10_FBTIL6AD, 0);
-			ACCW(NV10_FBTIL7AD, 0);
-			ACCW(NV10_FBTIL0ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL1ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL2ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL3ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL4ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL5ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL6ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV10_FBTIL7ED, (si-&gt;ps.memory_size - 1));
+			ACCW(G70_FBTILCAD, 0);
+			ACCW(G70_FBTILDAD, 0);
+			ACCW(G70_FBTILEAD, 0);
+			ACCW(G70_FBTILCED, (si-&gt;ps.memory_size - 1));
+			ACCW(G70_FBTILDED, (si-&gt;ps.memory_size - 1));
+			ACCW(G70_FBTILEED, (si-&gt;ps.memory_size - 1));
 		}
-		else
-		{
-			/* NV41, 43, 44, G70 and up */
-			ACCW(NV41_FBTIL0AD, 0);
-			ACCW(NV41_FBTIL1AD, 0);
-			ACCW(NV41_FBTIL2AD, 0);
-			ACCW(NV41_FBTIL3AD, 0);
-			ACCW(NV41_FBTIL4AD, 0);
-			ACCW(NV41_FBTIL5AD, 0);
-			ACCW(NV41_FBTIL6AD, 0);
-			ACCW(NV41_FBTIL7AD, 0);
-			ACCW(NV41_FBTIL8AD, 0);
-			ACCW(NV41_FBTIL9AD, 0);
-			ACCW(NV41_FBTILAAD, 0);
-			ACCW(NV41_FBTILBAD, 0);
-			ACCW(NV41_FBTIL0ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL1ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL2ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL3ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL4ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL5ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL6ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL7ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL8ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTIL9ED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTILAED, (si-&gt;ps.memory_size - 1));
-			ACCW(NV41_FBTILBED, (si-&gt;ps.memory_size - 1));
-
-			if (si-&gt;ps.card_type &gt;= G70)
-			{
-				ACCW(G70_FBTILCAD, 0);
-				ACCW(G70_FBTILDAD, 0);
-				ACCW(G70_FBTILEAD, 0);
-				ACCW(G70_FBTILCED, (si-&gt;ps.memory_size - 1));
-				ACCW(G70_FBTILDED, (si-&gt;ps.memory_size - 1));
-				ACCW(G70_FBTILEED, (si-&gt;ps.memory_size - 1));
-			}
-		}
 	}
 
 	/*** PRAMIN ***/
@@ -207,71 +176,30 @@
 	 * That command is linked to the handle noted here. This handle is then used to
 	 * tell the FIFO to which engine command it is connected!
 	 * (CTX registers are actually a sort of RAM space.) */
-	if (si-&gt;ps.card_arch &gt;= NV40A)
-	{
-		/* (first set) */
-		ACCW(HT_HANDL_00, (0x80000000 | NV10_CONTEXT_SURFACES_2D)); /* 32bit handle (not used) */
-		ACCW(HT_VALUE_00, 0x0010114c); /* instance $114c, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_01, (0x80000000 | NV_IMAGE_BLIT)); /* 32bit handle */
-		ACCW(HT_VALUE_01, 0x00101148); /* instance $1148, engine = acc engine, CHID = $00 */
+	/* (first set) */
+	ACCW(HT_HANDL_00, (0x80000000 | NV10_CONTEXT_SURFACES_2D)); /* 32bit handle (not used) */
+	ACCW(HT_VALUE_00, 0x0010114c); /* instance $114c, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_02, (0x80000000 | NV4_GDI_RECTANGLE_TEXT)); /* 32bit handle */
-		ACCW(HT_VALUE_02, 0x0010114a); /* instance $114a, engine = acc engine, CHID = $00 */
+	ACCW(HT_HANDL_01, (0x80000000 | NV_IMAGE_BLIT)); /* 32bit handle */
+	ACCW(HT_VALUE_01, 0x00101148); /* instance $1148, engine = acc engine, CHID = $00 */
 
-		/* (second set) */
-		ACCW(HT_HANDL_10, (0x80000000 | NV_ROP5_SOLID)); /* 32bit handle */
-		ACCW(HT_VALUE_10, 0x00101142); /* instance $1142, engine = acc engine, CHID = $00 */
+	ACCW(HT_HANDL_02, (0x80000000 | NV4_GDI_RECTANGLE_TEXT)); /* 32bit handle */
+	ACCW(HT_VALUE_02, 0x0010114a); /* instance $114a, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_11, (0x80000000 | NV_IMAGE_BLACK_RECTANGLE)); /* 32bit handle */
-		ACCW(HT_VALUE_11, 0x00101144); /* instance $1144, engine = acc engine, CHID = $00 */
+	/* (second set) */
+	ACCW(HT_HANDL_10, (0x80000000 | NV_ROP5_SOLID)); /* 32bit handle */
+	ACCW(HT_VALUE_10, 0x00101142); /* instance $1142, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_12, (0x80000000 | NV_IMAGE_PATTERN)); /* 32bit handle */
-		ACCW(HT_VALUE_12, 0x00101146); /* instance $1146, engine = acc engine, CHID = $00 */
+	ACCW(HT_HANDL_11, (0x80000000 | NV_IMAGE_BLACK_RECTANGLE)); /* 32bit handle */
+	ACCW(HT_VALUE_11, 0x00101144); /* instance $1144, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_13, (0x80000000 | NV_SCALED_IMAGE_FROM_MEMORY)); /* 32bit handle */
-		ACCW(HT_VALUE_13, 0x0010114e); /* instance $114e, engine = acc engine, CHID = $00 */
-	}
-	else
-	{
-		/* (first set) */
-		ACCW(HT_HANDL_00, (0x80000000 | NV4_SURFACE)); /* 32bit handle */
-		ACCW(HT_VALUE_00, 0x80011145); /* instance $1145, engine = acc engine, CHID = $00 */
+	ACCW(HT_HANDL_12, (0x80000000 | NV_IMAGE_PATTERN)); /* 32bit handle */
+	ACCW(HT_VALUE_12, 0x00101146); /* instance $1146, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_01, (0x80000000 | NV_IMAGE_BLIT)); /* 32bit handle */
-		ACCW(HT_VALUE_01, 0x80011146); /* instance $1146, engine = acc engine, CHID = $00 */
+	ACCW(HT_HANDL_13, (0x80000000 | NV_SCALED_IMAGE_FROM_MEMORY)); /* 32bit handle */
+	ACCW(HT_VALUE_13, 0x0010114e); /* instance $114e, engine = acc engine, CHID = $00 */
 
-		ACCW(HT_HANDL_02, (0x80000000 | NV4_GDI_RECTANGLE_TEXT)); /* 32bit handle */
-		ACCW(HT_VALUE_02, 0x80011147); /* instance $1147, engine = acc engine, CHID = $00 */
-
-		ACCW(HT_HANDL_03, (0x80000000 | NV4_CONTEXT_SURFACES_ARGB_ZS)); /* 32bit handle (3D) */
-		ACCW(HT_VALUE_03, 0x80011148); /* instance $1148, engine = acc engine, CHID = $00 */
-
-		/* NV4_ and NV10_DX5_TEXTURE_TRIANGLE should be identical */
-		ACCW(HT_HANDL_04, (0x80000000 | NV4_DX5_TEXTURE_TRIANGLE)); /* 32bit handle (3D) */
-		ACCW(HT_VALUE_04, 0x80011149); /* instance $1149, engine = acc engine, CHID = $00 */
-
-		/* NV4_ and NV10_DX6_MULTI_TEXTURE_TRIANGLE should be identical */
-		ACCW(HT_HANDL_05, (0x80000000 | NV4_DX6_MULTI_TEXTURE_TRIANGLE)); /* 32bit handle (not used) */
-		ACCW(HT_VALUE_05, 0x8001114a); /* instance $114a, engine = acc engine, CHID = $00 */
-
-		ACCW(HT_HANDL_06, (0x80000000 | NV1_RENDER_SOLID_LIN)); /* 32bit handle (not used) */
-		ACCW(HT_VALUE_06, 0x8001114c); /* instance $114c, engine = acc engine, CHID = $00 */
-
-		/* (second set) */
-		ACCW(HT_HANDL_10, (0x80000000 | NV_ROP5_SOLID)); /* 32bit handle */
-		ACCW(HT_VALUE_10, 0x80011142); /* instance $1142, engine = acc engine, CHID = $00 */
-
-		ACCW(HT_HANDL_11, (0x80000000 | NV_IMAGE_BLACK_RECTANGLE)); /* 32bit handle */
-		ACCW(HT_VALUE_11, 0x80011143); /* instance $1143, engine = acc engine, CHID = $00 */
-
-		ACCW(HT_HANDL_12, (0x80000000 | NV_IMAGE_PATTERN)); /* 32bit handle */
-		ACCW(HT_VALUE_12, 0x80011144); /* instance $1144, engine = acc engine, CHID = $00 */
-
-		ACCW(HT_HANDL_13, (0x80000000 | NV_SCALED_IMAGE_FROM_MEMORY)); /* 32bit handle */
-		ACCW(HT_VALUE_13, 0x8001114b); /* instance $114b, engine = acc engine, CHID = $00 */
-	}
-
 	/* program CTX registers: CTX1 is mostly done later (colorspace dependant) */
 	/* note:
 	 * CTX determines which HT handles point to what engine commands. */
@@ -279,433 +207,272 @@
 	 * CTX registers are in fact in the same GPU internal RAM space as the engine's
 	 * hashtable. This means that stuff programmed in here also survives resets and
 	 * power-outages! (confirmed NV11) */
-	if (si-&gt;ps.card_arch &gt;= NV40A)
-	{
-		/* setup a DMA define for use by command defines below. */
-		ACCW(PR_CTX0_R, 0x00003000); /* DMA page table present and of linear type;
-									  * DMA target node is NVM (non-volatile memory?)
-									  * (instead of doing PCI or AGP transfers) */
-		ACCW(PR_CTX1_R, (si-&gt;ps.memory_size - 1)); /* DMA limit: size is all cardRAM */
-		ACCW(PR_CTX2_R, ((0x00000000 &amp; 0xfffff000) | 0x00000002));
-									 /* DMA access type is READ_AND_WRITE;
-									  * memory starts at start of cardRAM (b12-31):
-									  * It's adress needs to be at a 4kb boundary! */
-		ACCW(PR_CTX3_R, 0x00000002); /* unknown (looks like this is rubbish/not needed?) */
-		/* setup set '0' for cmd NV_ROP5_SOLID */
-		ACCW(PR_CTX0_0, 0x02080043); /* NVclass $043, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_0, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_0, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_0, 0x00000000); /* method traps disabled */
-		ACCW(PR_CTX0_1, 0x00000000); /* extra */
-		ACCW(PR_CTX1_1, 0x00000000); /* extra */
-		/* setup set '1' for cmd NV_IMAGE_BLACK_RECTANGLE */
-		ACCW(PR_CTX0_2, 0x02080019); /* NVclass $019, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_2, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_2, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_2, 0x00000000); /* method traps disabled */
-		ACCW(PR_CTX0_3, 0x00000000); /* extra */
-		ACCW(PR_CTX1_3, 0x00000000); /* extra */
-		/* setup set '2' for cmd NV_IMAGE_PATTERN */
-		ACCW(PR_CTX0_4, 0x02080018); /* NVclass $018, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_4, 0x02000000); /* colorspace not set, notify instance is $0200 (b16-31) */
-		ACCW(PR_CTX2_4, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_4, 0x00000000); /* method traps disabled */
-		ACCW(PR_CTX0_5, 0x00000000); /* extra */
-		ACCW(PR_CTX1_5, 0x00000000); /* extra */
-		/* setup set '4' for cmd NV12_IMAGE_BLIT */
-		ACCW(PR_CTX0_6, 0x0208009f); /* NVclass $09f, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_6, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_6, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
-		ACCW(PR_CTX3_6, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
-		ACCW(PR_CTX0_7, 0x00000000); /* extra */
-		ACCW(PR_CTX1_7, 0x00000000); /* extra */
-		/* setup set '5' for cmd NV4_GDI_RECTANGLE_TEXT */
-		ACCW(PR_CTX0_8, 0x0208004a); /* NVclass $04a, patchcfg ROP_AND, nv10+: little endian */
-		ACCW(PR_CTX1_8, 0x02000000); /* colorspace not set, notify instance is $0200 (b16-31) */
-		ACCW(PR_CTX2_8, 0x00000000); /* DMA0 and DMA1 instance invalid */
-		ACCW(PR_CTX3_8, 0x00000000); /* method traps disabled */
-		ACCW(PR_CTX0_9, 0x00000000); /* extra */
-		ACCW(PR_CTX1_9, 0x00000000); /* extra */
-		/* setup set '6' for cmd NV10_CONTEXT_SURFACES_2D */
-		ACCW(PR_CTX0_A, 0x02080062); /* NVclass $062, nv10+: little endian */
-		ACCW(PR_CTX1_A, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_A, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
-		ACCW(PR_CTX3_A, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
-		ACCW(PR_CTX0_B, 0x00000000); /* extra */
-		ACCW(PR_CTX1_B, 0x00000000); /* extra */
-		/* setup set '7' for cmd NV_SCALED_IMAGE_FROM_MEMORY */
-		ACCW(PR_CTX0_C, 0x02080077); /* NVclass $077, nv10+: little endian */
-		ACCW(PR_CTX1_C, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
-		ACCW(PR_CTX2_C, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
-		ACCW(PR_CTX3_C, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
-		ACCW(PR_CTX0_D, 0x00000000); /* extra */
-		ACCW(PR_CTX1_D, 0x00000000); /* extra */
-		/* setup DMA set pointed at by PF_CACH1_DMAI */
-		ACCW(PR_CTX0_E, 0x00003002); /* DMA page table present and of linear type;
-									  * DMA class is $002 (b0-11);
-									  * DMA target node is NVM (non-volatile memory?)
-									  * (instead of doing PCI or AGP transfers) */
-		ACCW(PR_CTX1_E, 0x00007fff); /* DMA limit: tablesize is 32k bytes */
-		ACCW(PR_CTX2_E, (((si-&gt;ps.memory_size - 1) &amp; 0xffff8000) | 0x00000002));
-									 /* DMA access type is READ_AND_WRITE;
-									  * table is located at end of cardRAM (b12-31):
-									  * It's adress needs to be at a 4kb boundary! */
-	}
 
-	if (si-&gt;ps.card_arch == NV04A)
-	{
-		/* do a explicit engine reset */
-		ACCW(DEBUG0, 0x000001ff);
+	/* setup a DMA define for use by command defines below. */
+	ACCW(PR_CTX0_R, 0x00003000); /* DMA page table present and of linear type;
+								  * DMA target node is NVM (non-volatile memory?)
+								  * (instead of doing PCI or AGP transfers) */
+	ACCW(PR_CTX1_R, (si-&gt;ps.memory_size - 1)); /* DMA limit: size is all cardRAM */
+	ACCW(PR_CTX2_R, ((0x00000000 &amp; 0xfffff000) | 0x00000002));
+								 /* DMA access type is READ_AND_WRITE;
+								  * memory starts at start of cardRAM (b12-31):
+								  * It's adress needs to be at a 4kb boundary! */
+	ACCW(PR_CTX3_R, 0x00000002); /* unknown (looks like this is rubbish/not needed?) */
+	/* setup set '0' for cmd NV_ROP5_SOLID */
+	ACCW(PR_CTX0_0, 0x02080043); /* NVclass $043, patchcfg ROP_AND, nv10+: little endian */
+	ACCW(PR_CTX1_0, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
+	ACCW(PR_CTX2_0, 0x00000000); /* DMA0 and DMA1 instance invalid */
+	ACCW(PR_CTX3_0, 0x00000000); /* method traps disabled */
+	ACCW(PR_CTX0_1, 0x00000000); /* extra */
+	ACCW(PR_CTX1_1, 0x00000000); /* extra */
+	/* setup set '1' for cmd NV_IMAGE_BLACK_RECTANGLE */
+	ACCW(PR_CTX0_2, 0x02080019); /* NVclass $019, patchcfg ROP_AND, nv10+: little endian */
+	ACCW(PR_CTX1_2, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
+	ACCW(PR_CTX2_2, 0x00000000); /* DMA0 and DMA1 instance invalid */
+	ACCW(PR_CTX3_2, 0x00000000); /* method traps disabled */
+	ACCW(PR_CTX0_3, 0x00000000); /* extra */
+	ACCW(PR_CTX1_3, 0x00000000); /* extra */
+	/* setup set '2' for cmd NV_IMAGE_PATTERN */
+	ACCW(PR_CTX0_4, 0x02080018); /* NVclass $018, patchcfg ROP_AND, nv10+: little endian */
+	ACCW(PR_CTX1_4, 0x02000000); /* colorspace not set, notify instance is $0200 (b16-31) */
+	ACCW(PR_CTX2_4, 0x00000000); /* DMA0 and DMA1 instance invalid */
+	ACCW(PR_CTX3_4, 0x00000000); /* method traps disabled */
+	ACCW(PR_CTX0_5, 0x00000000); /* extra */
+	ACCW(PR_CTX1_5, 0x00000000); /* extra */
+	/* setup set '4' for cmd NV12_IMAGE_BLIT */
+	ACCW(PR_CTX0_6, 0x0208009f); /* NVclass $09f, patchcfg ROP_AND, nv10+: little endian */
+	ACCW(PR_CTX1_6, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
+	ACCW(PR_CTX2_6, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
+	ACCW(PR_CTX3_6, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
+	ACCW(PR_CTX0_7, 0x00000000); /* extra */
+	ACCW(PR_CTX1_7, 0x00000000); /* extra */
+	/* setup set '5' for cmd NV4_GDI_RECTANGLE_TEXT */
+	ACCW(PR_CTX0_8, 0x0208004a); /* NVclass $04a, patchcfg ROP_AND, nv10+: little endian */
+	ACCW(PR_CTX1_8, 0x02000000); /* colorspace not set, notify instance is $0200 (b16-31) */
+	ACCW(PR_CTX2_8, 0x00000000); /* DMA0 and DMA1 instance invalid */
+	ACCW(PR_CTX3_8, 0x00000000); /* method traps disabled */
+	ACCW(PR_CTX0_9, 0x00000000); /* extra */
+	ACCW(PR_CTX1_9, 0x00000000); /* extra */
+	/* setup set '6' for cmd NV10_CONTEXT_SURFACES_2D */
+	ACCW(PR_CTX0_A, 0x02080062); /* NVclass $062, nv10+: little endian */
+	ACCW(PR_CTX1_A, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
+	ACCW(PR_CTX2_A, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
+	ACCW(PR_CTX3_A, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
+	ACCW(PR_CTX0_B, 0x00000000); /* extra */
+	ACCW(PR_CTX1_B, 0x00000000); /* extra */
+	/* setup set '7' for cmd NV_SCALED_IMAGE_FROM_MEMORY */
+	ACCW(PR_CTX0_C, 0x02080077); /* NVclass $077, nv10+: little endian */
+	ACCW(PR_CTX1_C, 0x00000000); /* colorspace not set, notify instance invalid (b16-31) */
+	ACCW(PR_CTX2_C, 0x00001140); /* DMA0 instance is $1140, DMA1 instance invalid */
+	ACCW(PR_CTX3_C, 0x00001140); /* method trap 0 is $1140, trap 1 disabled */
+	ACCW(PR_CTX0_D, 0x00000000); /* extra */
+	ACCW(PR_CTX1_D, 0x00000000); /* extra */
+	/* setup DMA set pointed at by PF_CACH1_DMAI */
+	ACCW(PR_CTX0_E, 0x00003002); /* DMA page table present and of linear type;
+								  * DMA class is $002 (b0-11);
+								  * DMA target node is NVM (non-volatile memory?)
+								  * (instead of doing PCI or AGP transfers) */
+	ACCW(PR_CTX1_E, 0x00007fff); /* DMA limit: tablesize is 32k bytes */
+	ACCW(PR_CTX2_E, (((si-&gt;ps.memory_size - 1) &amp; 0xffff8000) | 0x00000002));
+								 /* DMA access type is READ_AND_WRITE;
+								  * table is located at end of cardRAM (b12-31):
+								  * It's adress needs to be at a 4kb boundary! */
 
-		/* init some function blocks */
-		/* DEBUG0, b20 and b21 should be high, this has a big influence on
-		 * 3D rendering speed! (on all cards, confirmed) */
-		ACCW(DEBUG0, 0x1230c000);
-		/* DEBUG1, b19 = 1 increases 3D rendering speed on TNT2 (M64) a bit,
-		 * TNT1 rendering speed stays the same (all cards confirmed) */
-		ACCW(DEBUG1, 0x72191101);
-		ACCW(DEBUG2, 0x11d5f071);
-		ACCW(DEBUG3, 0x0004ff31);
-		/* init OP methods */
-		ACCW(DEBUG3, 0x4004ff31);
+	/* do a explicit engine reset */
+	ACCW(DEBUG0, 0xffffffff);
+	ACCW(DEBUG0, 0x00000000);
+	/* disable all acceleration engine INT reguests */
+	ACCW(ACC_INTE, 0x00000000);
+	/* reset all acceration engine INT status bits */
+	ACCW(ACC_INTS, 0xffffffff);
+	/* context control enabled */
+	ACCW(NV10_CTX_CTRL, 0x10010100);
+	/* all acceleration buffers, pitches and colors are valid */
+	ACCW(NV10_ACC_STAT, 0xffffffff);
+	/* enable acceleration engine command FIFO */
+	ACCW(FIFO_EN, 0x00000001);
+	/* setup surface type:
+	 * b1-0 = %01 = surface type is non-swizzle;
+	 * this is needed to enable 3D on NV1x (confirmed) and maybe others? */
+	ACCW(NV10_SURF_TYP, ((ACCR(NV10_SURF_TYP)) &amp; 0x0007ff00));
+	ACCW(NV10_SURF_TYP, ((ACCR(NV10_SURF_TYP)) | 0x00020101));
 
-		/* disable all acceleration engine INT reguests */
-		ACCW(ACC_INTE, 0x00000000);
-		/* reset all acceration engine INT status bits */
-		ACCW(ACC_INTS, 0xffffffff);
-		/* context control enabled */
-		ACCW(NV04_CTX_CTRL, 0x10010100);
-		/* all acceleration buffers, pitches and colors are valid */
-		ACCW(NV04_ACC_STAT, 0xffffffff);
-		/* enable acceleration engine command FIFO */
-		ACCW(FIFO_EN, 0x00000001);
+	/* init some function blocks */
+	ACCW(DEBUG1, 0x401287c0);
+	ACCW(DEBUG3, 0x60de8051);
+	/* disable specific functions, but enable SETUP_SPARE2 register */
+	ACCW(NV10_DEBUG4, 0x00008000);
+	/* set limit_viol_pix_adress(?): more likely something unknown.. */
+	ACCW(NV25_WHAT0, 0x00be3c5f);
 
-		/* setup location of active screen in framebuffer */
-		ACCW(OFFSET0, ((uint8*)si-&gt;fbc.frame_buffer - (uint8*)si-&gt;framebuffer));
-		ACCW(OFFSET1, ((uint8*)si-&gt;fbc.frame_buffer - (uint8*)si-&gt;framebuffer));
-		/* setup accesible card memory range */
-		ACCW(BLIMIT0, (si-&gt;ps.memory_size - 1));
-		ACCW(BLIMIT1, (si-&gt;ps.memory_size - 1));
-
-		/* pattern shape value = 8x8, 2 color */
-		//fixme: not needed, unless the engine has a hardware fault (setting via cmd)!
-		//ACCW(PAT_SHP, 0x00000000);
-		/* Pgraph Beta AND value (fraction) b23-30 */
-		ACCW(BETA_AND_VAL, 0xffffffff);
-	}
-	else
+	/* setup some unknown serially accessed registers (?) */
+	tmp = (NV_REG32(NV32_NV4X_WHAT0) &amp; 0x000000ff);
+	for (cnt = 0; (tmp &amp;&amp; !(tmp &amp; 0x00000001)); tmp &gt;&gt;= 1, cnt++);
 	{
-		/* do a explicit engine reset */
-		ACCW(DEBUG0, 0xffffffff);
-		ACCW(DEBUG0, 0x00000000);
-		/* disable all acceleration engine INT reguests */
-		ACCW(ACC_INTE, 0x00000000);
-		/* reset all acceration engine INT status bits */
-		ACCW(ACC_INTS, 0xffffffff);
-		/* context control enabled */
-		ACCW(NV10_CTX_CTRL, 0x10010100);
-		/* all acceleration buffers, pitches and colors are valid */
-		ACCW(NV10_ACC_STAT, 0xffffffff);
-		/* enable acceleration engine command FIFO */
-		ACCW(FIFO_EN, 0x00000001);
-		/* setup surface type:
-		 * b1-0 = %01 = surface type is non-swizzle;
-		 * this is needed to enable 3D on NV1x (confirmed) and maybe others? */
-		ACCW(NV10_SURF_TYP, ((ACCR(NV10_SURF_TYP)) &amp; 0x0007ff00));
-		ACCW(NV10_SURF_TYP, ((ACCR(NV10_SURF_TYP)) | 0x00020101));
+		ACCW(NV4X_WHAT2, cnt);
 	}
 
-	if (si-&gt;ps.card_arch == NV10A)
+	/* unknown.. */
+	switch (si-&gt;ps.card_type)
 	{
-		/* init some function blocks */
-		ACCW(DEBUG1, 0x00118700);
-		/* DEBUG2 has a big influence on 3D speed for NV11 and NV15
-		 * (confirmed b3 and b18 should both be '1' on both cards!)
-		 * (b16 should also be '1', increases 3D speed on NV11 a bit more) */
-		ACCW(DEBUG2, 0x24fd2ad9);
-		ACCW(DEBUG3, 0x55de0030);
-		/* NV10_DEBUG4 has a big influence on 3D speed for NV11, NV15 and NV18
-		 * (confirmed b14 and b15 should both be '1' on these cards!)
-		 * (confirmed b8 should be '0' on NV18 to prevent complete engine crash!) */
-		ACCW(NV10_DEBUG4, 0x0000c000);
+	case NV40:
+	case NV45:
+	/* and NV48: but these are pgm'd as NV45 currently */
+		ACCW(NV40_WHAT0, 0x83280fff);
+		ACCW(NV40_WHAT1, 0x000000a0);
+		ACCW(NV40_WHAT2, 0x0078e366);
+		ACCW(NV40_WHAT3, 0x0000014c);
+		break;
+	case NV41:
+	/* and ID == 0x012x: but no cards defined yet */
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
+		ACCW(NV40P_WHAT2, 0x007596ff);
+		ACCW(NV40P_WHAT3, 0x00000108);
+		break;
+	case NV43:
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
+		ACCW(NV40P_WHAT2, 0x0072cb77);
+		ACCW(NV40P_WHAT3, 0x00000108);
+		break;
+	case NV44:
+	case G72:
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
 
-		/* copy tile setup stuff from 'source' to acc engine */
-		for (cnt = 0; cnt &lt; 32; cnt++)
-		{
-			NV_REG32(NVACC_NV10_TIL0AD + (cnt &lt;&lt; 2)) =
-				NV_REG32(NVACC_NV10_FBTIL0AD + (cnt &lt;&lt; 2));
-		}
+		NV_REG32(NV32_NV44_WHAT10) = NV_REG32(NV32_NV10STRAPINFO);
+		NV_REG32(NV32_NV44_WHAT11) = 0x00000000;
+		NV_REG32(NV32_NV44_WHAT12) = 0x00000000;
+		NV_REG32(NV32_NV44_WHAT13) = NV_REG32(NV32_NV10STRAPINFO);
 
-		/* setup location of active screen in framebuffer */
-		ACCW(OFFSET0, ((uint8*)si-&gt;fbc.frame_buffer - (uint8*)si-&gt;framebuffer));
-		ACCW(OFFSET1, ((uint8*)si-&gt;fbc.frame_buffer - (uint8*)si-&gt;framebuffer));
-		/* setup accesible card memory range */
-		ACCW(BLIMIT0, (si-&gt;ps.memory_size - 1));
-		ACCW(BLIMIT1, (si-&gt;ps.memory_size - 1));
+		ACCW(NV44_WHAT2, 0x00000000);
+		ACCW(NV44_WHAT3, 0x00000000);
+			break;
+/*	case NV44 type 2: (cardID 0x022x)
+		//fixme if needed: doesn't seem to need the strapinfo thing..
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
 
-		/* pattern shape value = 8x8, 2 color */
-		//fixme: not needed, unless the engine has a hardware fault (setting via cmd)!
-		//ACCW(PAT_SHP, 0x00000000);
-		/* Pgraph Beta AND value (fraction) b23-30 */
-		ACCW(BETA_AND_VAL, 0xffffffff);
+		ACCW(NV44_WHAT2, 0x00000000);
+		ACCW(NV44_WHAT3, 0x00000000);
+		break;
+*/	case G70:
+	case G71:
+	case G73:
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
+		ACCW(NV40P_WHAT2, 0x07830610);
+		ACCW(NV40P_WHAT3, 0x0000016a);
+		break;
+	default:
+		ACCW(NV40P_WHAT0, 0x83280eff);
+		ACCW(NV40P_WHAT1, 0x000000a0);
+		break;
 	}
 
-	if (si-&gt;ps.card_arch &gt;= NV20A)
+	ACCW(NV10_TIL3PT, 0x2ffff800);
+	ACCW(NV10_TIL3ST, 0x00006000);
+	ACCW(NV4X_WHAT1, 0x01000000);
+	/* engine data source DMA instance = $1140 */
+	ACCW(NV4X_DMA_SRC, 0x00001140);
+
+	/* copy tile setup stuff from previous setup 'source' to acc engine
+	 * (pattern colorRAM?) */
+	if ((si-&gt;ps.card_type == NV40) || (si-&gt;ps.card_type == NV45))
 	{
-		switch (si-&gt;ps.card_arch)
+		for (cnt = 0; cnt &lt; 32; cnt++)
 		{
-		case NV40A:
-			/* init some function blocks */
-			ACCW(DEBUG1, 0x401287c0);
-			ACCW(DEBUG3, 0x60de8051);
-			/* disable specific functions, but enable SETUP_SPARE2 register */
-			ACCW(NV10_DEBUG4, 0x00008000);
-			/* set limit_viol_pix_adress(?): more likely something unknown.. */
-			ACCW(NV25_WHAT0, 0x00be3c5f);
+			/* copy NV10_FBTIL0AD upto/including NV10_FBTIL7ST */
+			NV_REG32(NVACC_NV20_WHAT0 + (cnt &lt;&lt; 2)) =
+				NV_REG32(NVACC_NV10_FBTIL0AD + (cnt &lt;&lt; 2));
 
-			/* setup some unknown serially accessed registers (?) */
-			tmp = (NV_REG32(NV32_NV4X_WHAT0) &amp; 0x000000ff);
-			for (cnt = 0; (tmp &amp;&amp; !(tmp &amp; 0x00000001)); tmp &gt;&gt;= 1, cnt++);
-			{
-				ACCW(NV4X_WHAT2, cnt);
-			}
-
-			/* unknown.. */
-			switch (si-&gt;ps.card_type)
-			{
-			case NV40:
-			case NV45:
-			/* and NV48: but these are pgm'd as NV45 currently */
-				ACCW(NV40_WHAT0, 0x83280fff);
-				ACCW(NV40_WHAT1, 0x000000a0);
-				ACCW(NV40_WHAT2, 0x0078e366);
-				ACCW(NV40_WHAT3, 0x0000014c);
-				break;
-			case NV41:
-			/* and ID == 0x012x: but no cards defined yet */
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-				ACCW(NV40P_WHAT2, 0x007596ff);
-				ACCW(NV40P_WHAT3, 0x00000108);
-				break;
-			case NV43:
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-				ACCW(NV40P_WHAT2, 0x0072cb77);
-				ACCW(NV40P_WHAT3, 0x00000108);
-				break;
-			case NV44:
-			case G72:
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-
-				NV_REG32(NV32_NV44_WHAT10) = NV_REG32(NV32_NV10STRAPINFO);
-				NV_REG32(NV32_NV44_WHAT11) = 0x00000000;
-				NV_REG32(NV32_NV44_WHAT12) = 0x00000000;
-				NV_REG32(NV32_NV44_WHAT13) = NV_REG32(NV32_NV10STRAPINFO);
-
-				ACCW(NV44_WHAT2, 0x00000000);
-				ACCW(NV44_WHAT3, 0x00000000);
-				break;
-/*			case NV44 type 2: (cardID 0x022x)
-				//fixme if needed: doesn't seem to need the strapinfo thing..
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-
-				ACCW(NV44_WHAT2, 0x00000000);
-				ACCW(NV44_WHAT3, 0x00000000);
-				break;
-*/			case G70:
-			case G71:
-			case G73:
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-				ACCW(NV40P_WHAT2, 0x07830610);
-				ACCW(NV40P_WHAT3, 0x0000016a);
-				break;
-			default:
-				ACCW(NV40P_WHAT0, 0x83280eff);
-				ACCW(NV40P_WHAT1, 0x000000a0);
-				break;
-			}
-
-			ACCW(NV10_TIL3PT, 0x2ffff800);
-			ACCW(NV10_TIL3ST, 0x00006000);
-			ACCW(NV4X_WHAT1, 0x01000000);
-			/* engine data source DMA instance = $1140 */
-			ACCW(NV4X_DMA_SRC, 0x00001140);
-			break;
-		case NV30A:
-			/* init some function blocks, but most is unknown.. */
-			ACCW(DEBUG1, 0x40108700);
-			ACCW(NV25_WHAT1, 0x00140000);
-			ACCW(DEBUG3, 0xf00e0431);
-			ACCW(NV10_DEBUG4, 0x00008000);
-			ACCW(NV25_WHAT0, 0xf04b1f36);
-			ACCW(NV20_WHAT3, 0x1002d888);
-			ACCW(NV25_WHAT2, 0x62ff007f);

[... truncated: 1389 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009666.html">[Haiku-commits] r25998 - in	haiku/trunk/src/add-ons/input_server/methods: . t9
</A></li>
	<LI>Next message: <A HREF="009671.html">[Haiku-commits] r26000 - haiku/trunk/headers/private/graphics/nvidia
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9669">[ date ]</a>
              <a href="thread.html#9669">[ thread ]</a>
              <a href="subject.html#9669">[ subject ]</a>
              <a href="author.html#9669">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
