<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25971 - in	haiku/trunk/src/add-ons/media/plugins/matroska: .	libMatroskaParser libebml libebml/ebml libebml/ebml/c	libmatroska libmatroska/matroska libmatroska/matroska/c
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25971%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/matroska%3A%20.%0A%09libMatroskaParser%20libebml%20libebml/ebml%20libebml/ebml/c%0A%09libmatroska%20libmatroska/matroska%20libmatroska/matroska/c&In-Reply-To=%3C200806161318.m5GDIs6k013565%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="009636.html">
   <LINK REL="Next"  HREF="009638.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25971 - in	haiku/trunk/src/add-ons/media/plugins/matroska: .	libMatroskaParser libebml libebml/ebml libebml/ebml/c	libmatroska libmatroska/matroska libmatroska/matroska/c</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25971%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/matroska%3A%20.%0A%09libMatroskaParser%20libebml%20libebml/ebml%20libebml/ebml/c%0A%09libmatroska%20libmatroska/matroska%20libmatroska/matroska/c&In-Reply-To=%3C200806161318.m5GDIs6k013565%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25971 - in	haiku/trunk/src/add-ons/media/plugins/matroska: .	libMatroskaParser libebml libebml/ebml libebml/ebml/c	libmatroska libmatroska/matroska libmatroska/matroska/c">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Mon Jun 16 15:18:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="009636.html">[Haiku-commits] r25970 - haiku/trunk/src/apps/deskbar
</A></li>
        <LI>Next message: <A HREF="009638.html">[Haiku-commits] r25972 - in haiku/trunk/src/apps/mediaplayer: .	media_node_framework
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9637">[ date ]</a>
              <a href="thread.html#9637">[ thread ]</a>
              <a href="subject.html#9637">[ subject ]</a>
              <a href="author.html#9637">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2008-06-16 15:18:51 +0200 (Mon, 16 Jun 2008)
New Revision: 25971
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25971&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25971&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/MatroskaParser.c
   haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/MatroskaParser.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/StreamIO.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/StreamIO.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/Debug.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlBinary.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlCrc32.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlDate.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlElement.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlFloat.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlHead.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlMaster.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlSInteger.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlString.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlUInteger.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlUnicodeString.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/EbmlVoid.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/StdIOCallback.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlBinary.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlConfig.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlCrc32.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlDate.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlElement.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlEndian.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlFloat.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlId.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlMaster.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlSInteger.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlString.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlUInteger.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlUnicodeString.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlVersion.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/EbmlVoid.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/MemIOCallback.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/StdIOCallback.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libebml/ebml/c/libebml_t.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxAttached.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxBlock.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxBlockData.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxChapters.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxCluster.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxClusterData.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxCues.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxCuesData.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxInfo.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxInfoData.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxSegment.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxTrackEntryData.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/KaxTracks.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxAttached.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxBlock.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxBlockData.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxChapters.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxCluster.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxClusterData.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxConfig.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxContexts.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxCues.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxCuesData.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxInfoData.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxTag.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxTrackEntryData.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxTypes.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/KaxVersion.h
   haiku/trunk/src/add-ons/media/plugins/matroska/libmatroska/matroska/c/libmatroska_t.h
   haiku/trunk/src/add-ons/media/plugins/matroska/matroska_reader.cpp
   haiku/trunk/src/add-ons/media/plugins/matroska/matroska_reader.h
Log:
Update matroska to latest support library versions (libmatroskaparser 1.31)

Modified: haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/MatroskaParser.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/MatroskaParser.c	2008-06-16 13:14:46 UTC (rev 25970)
+++ haiku/trunk/src/add-ons/media/plugins/matroska/libMatroskaParser/MatroskaParser.c	2008-06-16 13:18:51 UTC (rev 25971)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004 Mike Matsnev.  All Rights Reserved.
+ * Copyright (c) 2004-2005 Mike Matsnev.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -25,7 +25,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  * 
- * $Id: MatroskaParser.c,v 1.8 2004/09/17 12:23:51 mike Exp $
+ * $Id: MatroskaParser.c,v 1.31 2005/03/07 11:22:16 mike Exp $
  * 
  */
 
@@ -37,21 +37,22 @@
 
 #ifdef _WIN32
 // MS names some functions differently
-#define	vsnprintf _vsnprintf
 #define	alloca	  _alloca
 #define	inline	  __inline
 
 #include &lt;tchar.h&gt;
 #endif
 
-#include &lt;zlib.h&gt;
-
 #ifndef EVCBUG
 #define	EVCBUG
 #endif
 
 #include &quot;MatroskaParser.h&quot;
 
+#ifdef MATROSKA_COMPRESSION_SUPPORT
+#include &lt;zlib.h&gt;
+#endif
+
 #define	EBML_VERSION	      1
 #define	EBML_MAX_ID_LENGTH    4
 #define	EBML_MAX_SIZE_LENGTH  8
@@ -61,7 +62,7 @@
 #define	MAX_STRING_LEN	      1023
 #define	QSEGSIZE	      512
 #define	MAX_TRACKS	      32
-#define	MAX_READAHEAD	      (384*1024)
+#define	MAX_READAHEAD	      (512*1024)
 
 #define	DEFAULT_PAGE_SIZE     65536
 #define	MIN_PAGE_SIZE	      4096
@@ -69,11 +70,19 @@
 #define	MAXCLUSTER	      (64*1048576)
 #define	MAXFRAME	      (4*1048576)
 
-#define	MAXU64		      0xffffffffffffffff
+#ifdef WIN32
+#define	LL(x)	x##i64
+#define	ULL(x)	x##ui64
+#else
+#define	LL(x)	x##ll
+#define	ULL(x)	x##ull
+#endif
 
+#define	MAXU64		      ULL(0xffffffffffffffff)
+#define	ONE		      ULL(1)
+
 // compatibility
-#ifdef _WIN32_WCE
-static char  *strdup(const char *src) {
+static char  *mystrdup(struct InputStream *is,const char *src) {
   size_t  len;
   char	  *dst;
 
@@ -81,7 +90,7 @@
     return NULL;
 
   len = strlen(src);
-  dst = malloc(len+1);
+  dst = (char *)is-&gt;memalloc(is,len+1);
   if (dst==NULL)
     return NULL;
 
@@ -89,9 +98,8 @@
 
   return dst;
 }
-#endif
 
-#if defined(_WIN32) || defined(__BEOS___)
+#ifdef _WIN32
 static void  strlcpy(char *dst,const char *src,unsigned size) {
   unsigned  i;
 
@@ -135,7 +143,7 @@
   unsigned    flags;
 
   // input
-  FileCache   *cache;
+  InputStream *cache;
 
   // internal buffering
   char	      inbuf[IBSZ];
@@ -208,11 +216,194 @@
 
 ///////////////////////////////////////////////////////////////////////////
 // error reporting
+static void   myvsnprintf_string(char **pdest,char *de,const char *str) {
+  char	*dest = *pdest;
+
+  while (dest &lt; de &amp;&amp; *str)
+    *dest++ = *str++;
+
+  *pdest = dest;
+}
+
+static void   myvsnprintf_uint_impl(char **pdest,char *de,int width,int zero,
+				    int neg,unsigned base,int letter,
+				    int ms,ulonglong val)
+{
+  char	*dest = *pdest;
+  char	tmp[21]; /* enough for 64 bit ints */
+  char	*np = tmp + sizeof(tmp);
+  int	rw,pad,trail;
+  char	pc = zero ? '0' : ' ';
+
+  *--np = '\0';
+  while (val != 0) {
+    int	  rem = (int)(val % base);
+    val = val / base;
+
+    *--np = rem &lt; 10 ? rem + '0' : rem - 10 + letter;
+  }
+
+  rw = (int)(tmp - np + sizeof(tmp) - 1);
+  if (ms)
+    ++rw;
+
+  pad = trail = 0;
+
+  if (rw &lt; width)
+    pad = width - rw;
+
+  if (neg)
+    trail = pad, pad = 0;
+
+  if (dest &lt; de &amp;&amp; ms)
+    *dest++ = '-';
+
+  while (dest &lt; de &amp;&amp; pad--)
+    *dest++ = pc;
+
+  while (dest &lt; de &amp;&amp; *np)
+    *dest++ = *np++;
+
+  while (dest &lt; de &amp;&amp; trail--)
+    *dest++ = ' ';
+
+  *pdest = dest;
+}
+
+static void   myvsnprintf_uint(char **pdest,char *de,int width,int zero,
+			       int neg,unsigned base,int letter,
+			       ulonglong val)
+{
+  myvsnprintf_uint_impl(pdest,de,width,zero,neg,base,letter,0,val);
+}
+
+static void   myvsnprintf_int(char **pdest,char *de,int width,int zero,
+			      int neg,unsigned base,int letter,
+			      longlong val)
+{
+  if (val &lt; 0)
+    myvsnprintf_uint_impl(pdest,de,width,zero,neg,base,letter,1,-val);
+  else
+    myvsnprintf_uint_impl(pdest,de,width,zero,neg,base,letter,0,val);
+}
+
+static void   myvsnprintf(char *dest,unsigned dsize,const char *fmt,va_list ap) {
+  // s,d,x,u,ll
+  char	    *de = dest + dsize - 1;
+  int	    state = 0, width, zero, neg, ll;
+
+  if (dsize &lt;= 1) {
+    if (dsize &gt; 0)
+      *dest = '\0';
+    return;
+  }
+
+  while (*fmt &amp;&amp; dest &lt; de)
+    switch (state) {
+      case 0:
+	if (*fmt == '%') {
+	  ++fmt;
+	  state = 1;
+	  width = zero = neg = ll = 0;
+	} else
+	  *dest++ = *fmt++;
+	break;
+      case 1:
+	if (*fmt == '-') {
+	  neg = 1;
+	  ++fmt;
+	  state = 2;
+	  break;
+	}
+	state = 2;
+      case 2:
+	if (*fmt &gt;= '0' &amp;&amp; *fmt &lt;= '9') {
+	  width = width * 10 + *fmt++ - '0';
+	  break;
+	}
+	state = 3;
+      case 3:
+	if (*fmt == 'l') {
+	  ++ll;
+	  ++fmt;
+	  break;
+	}
+	state = 4;
+      case 4:
+	switch (*fmt) {
+	  case 's':
+	    myvsnprintf_string(&amp;dest,de,va_arg(ap,const char *));
+	    break;
+	  case 'd':
+	    switch (ll) {
+	      case 0:
+		myvsnprintf_int(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,int));
+		break;
+	      case 1:
+		myvsnprintf_int(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,long));
+		break;
+	      case 2:
+		myvsnprintf_int(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,longlong));
+		break;
+	    }
+	    break;
+	  case 'u':
+	    switch (ll) {
+	      case 0:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,unsigned int));
+		break;
+	      case 1:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,unsigned long));
+		break;
+	      case 2:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,10,'a',va_arg(ap,ulonglong));
+		break;
+	    }
+	    break;
+	  case 'x':
+	    switch (ll) {
+	      case 0:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'a',va_arg(ap,unsigned int));
+		break;
+	      case 1:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'a',va_arg(ap,unsigned long));
+		break;
+	      case 2:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'a',va_arg(ap,ulonglong));
+		break;
+	    }
+	    break;
+	  case 'X':
+	    switch (ll) {
+	      case 0:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'A',va_arg(ap,unsigned int));
+		break;
+	      case 1:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'A',va_arg(ap,unsigned long));
+		break;
+	      case 2:
+		myvsnprintf_uint(&amp;dest,de,width,zero,neg,16,'A',va_arg(ap,ulonglong));
+		break;
+	    }
+	    break;
+	  default:
+	    break;
+	}
+	++fmt;
+	state = 0;
+	break;
+      default:
+	state = 0;
+	break;
+    }
+  *dest = '\0';
+}
+
 static void   errorjmp(MatroskaFile *mf,const char *fmt, ...) {
   va_list   ap;
 
   va_start(ap, fmt);
-  vsnprintf(mf-&gt;errmsg,sizeof(mf-&gt;errmsg),fmt,ap);
+  myvsnprintf(mf-&gt;errmsg,sizeof(mf-&gt;errmsg),fmt,ap);
   va_end(ap);
 
   mf-&gt;flags |= MPF_ERROR;
@@ -231,7 +422,7 @@
     if (newsize==0)
       newsize = 1;
 
-    np = realloc(*base,newsize*elem_size);
+    np = mf-&gt;cache-&gt;memrealloc(mf-&gt;cache,*base,newsize*elem_size);
     if (np==NULL)
       errorjmp(mf,&quot;Out of memory in ArrayAlloc&quot;);
 
@@ -242,11 +433,11 @@
   return (char*)*base + elem_size * (*cur)++;
 }
 
-static void ArrayReleaseMemory(void **base,
+static void ArrayReleaseMemory(MatroskaFile *mf,void **base,
 			       unsigned cur,unsigned *max,unsigned elem_size)
 {
   if (cur&lt;*max) {
-    void  *np = realloc(*base,cur*elem_size);
+    void  *np = mf-&gt;cache-&gt;memrealloc(mf-&gt;cache,*base,cur*elem_size);
     *base = np;
     *max = cur;
   }
@@ -255,7 +446,7 @@
 
 #define	ASGET(f,s,name)	  ArrayAlloc((f),(void**)&amp;(s)-&gt;name,&amp;(s)-&gt;n##name,&amp;(s)-&gt;n##name##Size,sizeof(*((s)-&gt;name)))
 #define	AGET(f,name)	  ArrayAlloc((f),(void**)&amp;(f)-&gt;name,&amp;(f)-&gt;n##name,&amp;(f)-&gt;n##name##Size,sizeof(*((f)-&gt;name)))
-#define	ARELEASE(f,name)  ArrayReleaseMemory((void**)&amp;(f)-&gt;name,(f)-&gt;n##name,&amp;(f)-&gt;n##name##Size,sizeof(*((f)-&gt;name)))
+#define	ARELEASE(f,s,name)  ArrayReleaseMemory((f),(void**)&amp;(s)-&gt;name,(s)-&gt;n##name,&amp;(s)-&gt;n##name##Size,sizeof(*((s)-&gt;name)))
 
 ///////////////////////////////////////////////////////////////////////////
 // queues
@@ -287,7 +478,7 @@
 
     qep = AGET(mf,QBlocks);
 
-    *qep = malloc(QSEGSIZE * sizeof(*qe));
+    *qep = mf-&gt;cache-&gt;memalloc(mf-&gt;cache,QSEGSIZE * sizeof(*qe));
     if (*qep == NULL)
       errorjmp(mf,&quot;Ouf of memory&quot;);
 
@@ -346,7 +537,7 @@
 }
 
 static void   readbytes(MatroskaFile *mf,void *buffer,int len) {
-  char	*cp = buffer;
+  char	*cp = (char *)buffer;
   int	nb = mf-&gt;buflen - mf-&gt;bufpos;
 
   if (nb &gt; len)
@@ -423,7 +614,6 @@
   //       .. r1 r0 ..
   //
   //    r = ((x0*y0) &gt;&gt; 32) + (x1*y0) + (x0*y1) + ((x1*y1) &lt;&lt; 32)
-  // TODO calc tc*scale
   unsigned    x0,x1,y0,y1;
   ulonglong   p;
   char	      sign = 0;
@@ -445,7 +635,7 @@
 
   return p;
 #else
-  return (ulonglong)(scale * tc);
+  return (longlong)(scale * tc);
 #endif
 }
 
@@ -524,15 +714,15 @@
   ulonglong v = readVLUIntImp(mf,&amp;m);
 
   // see if it's unspecified
-  if (v == (0xffffffffffffffff &gt;&gt; (57-m*7)))
+  if (v == (MAXU64 &gt;&gt; (57-m*7)))
     errorjmp(mf,&quot;Unspecified element size is not supported here.&quot;);
 
   return v;
 }
 
 static inline longlong	readVLSInt(MatroskaFile *mf) {
-  static longlong bias[8] = { (1&lt;&lt;6)-1, (1&lt;&lt;13)-1, (1&lt;&lt;20)-1, (1&lt;&lt;27)-1,
-			      (1LL&lt;&lt;34)-1, (1LL&lt;&lt;41)-1, (1LL&lt;&lt;48)-1, (1LL&lt;&lt;55)-1 };
+  static longlong bias[8] = { (ONE&lt;&lt;6)-1, (ONE&lt;&lt;13)-1, (ONE&lt;&lt;20)-1, (ONE&lt;&lt;27)-1,
+			      (ONE&lt;&lt;34)-1, (ONE&lt;&lt;41)-1, (ONE&lt;&lt;48)-1, (ONE&lt;&lt;55)-1 };
 
   int	    m;
   longlong  v = readVLUIntImp(mf,&amp;m);
@@ -553,7 +743,7 @@
   do {
     c = readch(mf);
     if (c == EOF)
-      errorjmp(mf,&quot;Got EOF while read EBML unsigned integer&quot;);
+      errorjmp(mf,&quot;Got EOF while reading EBML unsigned integer&quot;);
     v = (v&lt;&lt;8) | c;
   } while (--m);
 
@@ -595,9 +785,9 @@
     else if (shift == 255)
 inf:
       if (ui &amp; 0x80000000)
-	f.v = 0x8000000000000000;
+	f.v = LL(0x8000000000000000);
       else
-	f.v = 0x7fffffffffffffff;
+	f.v = LL(0x7fffffffffffffff);
     else {
       shift += -127 + 9;
       if (shift &gt; 39)
@@ -608,11 +798,9 @@
       else if (shift &gt; 0)
 	f.v = f.v &lt;&lt; shift;
     }
-  }
-
-  if (len == 8) {
-    ulonglong  ui = (unsigned)readUInt(mf,(unsigned)len);
-    f.v = (ui &amp; 0xfffffffffffff) | 0x10000000000000;
+  } else if (len == 8) {
+    ulonglong  ui = readUInt(mf,(unsigned)len);
+    f.v = (ui &amp; LL(0xfffffffffffff)) | LL(0x10000000000000);
     if (ui &amp; 0x80000000)
       f.v = -f.v;
     shift = (int)((ui &gt;&gt; 52) &amp; 0x7ff);
@@ -695,19 +883,20 @@
 
 #define	ENDFOR(f) ENDFOR1(f) ENDFOR2()
 
+#define	myalloca(f,c) alloca(c)
 #define	STRGETF(f,v,len,func) \
   { \
     char *TmpVal; \
     unsigned TmpLen = (len)&gt;MAX_STRING_LEN ? MAX_STRING_LEN : (unsigned)(len); \
-    TmpVal = func(TmpLen+1); \
+    TmpVal = (char *)func(f-&gt;cache,TmpLen+1); \
     if (TmpVal == NULL) \
       errorjmp(mf,&quot;Out of memory&quot;); \
     readString(f,len,TmpVal,TmpLen+1); \
     (v) = TmpVal; \
   }
 
-#define	STRGETA(f,v,len)  STRGETF(f,v,len,alloca)
-#define	STRGETM(f,v,len)  STRGETF(f,v,len,malloc)
+#define	STRGETA(f,v,len)  STRGETF(f,v,len,myalloca)
+#define	STRGETM(f,v,len)  STRGETF(f,v,len,f-&gt;cache-&gt;memalloc)
 
 static int  IsWritingApp(MatroskaFile *mf,const char *str) {
   const char  *cp = mf-&gt;Seg.WritingApp;
@@ -819,8 +1008,10 @@
 static void parseSegmentInfo(MatroskaFile *mf,ulonglong toplen) {
   MKFLOAT     duration;
 
-  if (mf-&gt;seen.SegmentInfo)
+  if (mf-&gt;seen.SegmentInfo) {
+    skipbytes(mf,toplen);
     return;
+  }
 
   mf-&gt;seen.SegmentInfo = 1;
   mf-&gt;Seg.TimecodeScale = 1000000; // Default value
@@ -852,6 +1043,8 @@
       break;
     case 0x2ad7b1: // TimecodeScale
       mf-&gt;Seg.TimecodeScale = readUInt(mf,(unsigned)len);
+      if (mf-&gt;Seg.TimecodeScale == 0)
+	errorjmp(mf,&quot;Segment timecode scale is zero&quot;);
       break;
     case 0x4489: // Duration
       duration = readFloat(mf,(unsigned)len);
@@ -1089,7 +1282,7 @@
       if (len&gt;262144) // 256KB
 	errorjmp(mf,&quot;CodecPrivate is too large: %d&quot;,(int)len);
       cplen = (unsigned)len;
-      cp = alloca(cplen);
+      cp = (char *)alloca(cplen);
       readbytes(mf,cp,(int)cplen);
       break;
     case 0x258688: // CodecName
@@ -1161,7 +1354,7 @@
     errorjmp(mf,&quot;Track has no Codec ID&quot;);
 
   // allocate new track
-  tpp = AGET(mf,Tracks);
+  tpp = (TrackInfo **)AGET(mf,Tracks);
 
   // copy strings
   if (t.Name)
@@ -1171,7 +1364,7 @@
   if (t.CodecID)
     cpadd += strlen(t.CodecID)+1;
 
-  tp = malloc(sizeof(*tp) + cplen + cpadd);
+  tp = (TrackInfo *)mf-&gt;cache-&gt;memalloc(mf-&gt;cache,sizeof(*tp) + cplen + cpadd);
   if (tp == NULL)
     errorjmp(mf,&quot;Out of memory&quot;);
 
@@ -1211,14 +1404,36 @@
   cc-&gt;Block = 0;
 }
 
+static void fixupCues(MatroskaFile *mf) {
+  // adjust cues, shift cues if file does not start at 0
+  unsigned  i;
+  longlong  adjust = mf-&gt;firstTimecode * mf-&gt;Seg.TimecodeScale;
+
+  for (i=0;i&lt;mf-&gt;nCues;++i) {
+    mf-&gt;Cues[i].Time *= mf-&gt;Seg.TimecodeScale;
+    mf-&gt;Cues[i].Time -= adjust;
+  }
+}
+
 static void parseCues(MatroskaFile *mf,ulonglong toplen) {
+  jmp_buf     jb;
   ulonglong   v;
   struct Cue  cc;
   unsigned    i,j,k;
 
   mf-&gt;seen.Cues = 1;
+  mf-&gt;nCues = 0;
   cc.Block = 0;
 
+  memcpy(&amp;jb,&amp;mf-&gt;jb,sizeof(jb));
+
+  if (setjmp(mf-&gt;jb)) {
+    memcpy(&amp;mf-&gt;jb,&amp;jb,sizeof(jb));
+    mf-&gt;nCues = 0;
+    mf-&gt;seen.Cues = 0;
+    return;
+  }
+
   FOREACH(mf,toplen)
     case 0xbb: // CuePoint
       FOREACH(mf,len)
@@ -1262,24 +1477,29 @@
 	  break;
       ENDFOR(mf);
 
-      if (mf-&gt;nCues == 0)
-	addCue(mf,mf-&gt;pCluster,mf-&gt;firstTimecode);
+      if (mf-&gt;nCues == 0 &amp;&amp; mf-&gt;pCluster - mf-&gt;pSegment != cc.Position)
+		addCue(mf,mf-&gt;pCluster - mf-&gt;pSegment,mf-&gt;firstTimecode);
 
       memcpy(AGET(mf,Cues),&amp;cc,sizeof(cc));
       break;
   ENDFOR(mf);
 
-  ARELEASE(mf,Cues);
+  memcpy(&amp;mf-&gt;jb,&amp;jb,sizeof(jb));
 
+  ARELEASE(mf,mf,Cues);
+
   // bubble sort the cues and fuck the losers that write unordered cues
-  for (i = mf-&gt;nCues - 1, k = 1; i &gt; 0 &amp;&amp; k &gt; 0; --i)
-    for (j = k = 0; j &lt; i; ++j)
-      if (mf-&gt;Cues[j].Time &gt; mf-&gt;Cues[j+1].Time) {
-	struct Cue tmp = mf-&gt;Cues[j+1];
-	mf-&gt;Cues[j+1] = mf-&gt;Cues[j];
-	mf-&gt;Cues[j] = tmp;
-	++k;
-      }
+  if (mf-&gt;nCues &gt; 0)
+    for (i = mf-&gt;nCues - 1, k = 1; i &gt; 0 &amp;&amp; k &gt; 0; --i)
+      for (j = k = 0; j &lt; i; ++j)
+	if (mf-&gt;Cues[j].Time &gt; mf-&gt;Cues[j+1].Time) {
+	  struct Cue tmp = mf-&gt;Cues[j+1];
+	  mf-&gt;Cues[j+1] = mf-&gt;Cues[j];
+	  mf-&gt;Cues[j] = tmp;
+	  ++k;
+	}
+
+  fixupCues(mf);
 }
 
 static void parseAttachment(MatroskaFile *mf,ulonglong toplen) {
@@ -1313,11 +1533,11 @@
   memcpy(pa,&amp;a,sizeof(a));
 
   if (a.Description)
-    pa-&gt;Description = strdup(a.Description);
+    pa-&gt;Description = mystrdup(mf-&gt;cache,a.Description);
   if (a.Name)
-    pa-&gt;Name = strdup(a.Name);
+    pa-&gt;Name = mystrdup(mf-&gt;cache,a.Name);
   if (a.MimeType)
-    pa-&gt;MimeType = strdup(a.MimeType);
+    pa-&gt;MimeType = mystrdup(mf-&gt;cache,a.MimeType);
 }
 
 static void parseAttachments(MatroskaFile *mf,ulonglong toplen) {
@@ -1332,8 +1552,9 @@
 
 static void parseChapter(MatroskaFile *mf,ulonglong toplen,struct Chapter *parent) {
   struct ChapterDisplay	*disp;
+  struct ChapterProcess	*proc;
   struct ChapterCommand	*cmd;
-  struct Chapter	*ch = ASGET(mf,parent,Children);
+  struct Chapter	*ch = (Chapter *)ASGET(mf,parent,Children);
 
   memset(ch,0,sizeof(*ch));
 
@@ -1399,45 +1620,80 @@
       ENDFOR(mf);
 
       if (disp &amp;&amp; !disp-&gt;String) {
-	free(disp-&gt;Language);
-	free(disp-&gt;Country);
+	mf-&gt;cache-&gt;memfree(mf-&gt;cache,disp-&gt;Language);
+	mf-&gt;cache-&gt;memfree(mf-&gt;cache,disp-&gt;Country);
 	--ch-&gt;nDisplay;
       }
       break;
-    case 0x6944: // ChapterCommand
-      cmd = NULL;
+    case 0x6944: // ChapProcess
+      proc = NULL;
 
       FOREACH(mf,len)
-	case 0x6922: // ChapterCommandTime
-	  if (cmd == NULL) {
-	    cmd = ASGET(mf,ch,Commands);
-	    memset(cmd, 0, sizeof(*cmd));
+	case 0x6955: // ChapProcessCodecID
+	  if (proc == NULL) {
+	    proc = ASGET(mf, ch, Process);
+	    memset(proc, 0, sizeof(*proc));
 	  }
-	  cmd-&gt;Time = readUInt(mf,(unsigned)len);
+	  proc-&gt;CodecID = (unsigned)readUInt(mf,(unsigned)len);
 	  break;
-	case 0x6937: // ChapterCommandString
-	  if (cmd == NULL) {
-	    cmd = ASGET(mf,ch,Commands);
-	    memset(cmd, 0, sizeof(*cmd));
+	case 0x450d: // ChapProcessPrivate
+	  if (proc == NULL) {
+	    proc = ASGET(mf, ch, Process);
+	    memset(proc, 0, sizeof(*proc));
 	  }
-	  if (cmd-&gt;String)
-	    skipbytes(mf,len);
-	  else
-	    STRGETM(mf,cmd-&gt;String,len);
+	  if (proc-&gt;CodecPrivate)
+	    skipbytes(mf, len);
+	  else {
+	    proc-&gt;CodecPrivateLength = (unsigned)len;
+	    STRGETM(mf,proc-&gt;CodecPrivate,len);
+	  }
 	  break;
+	case 0x6911: // ChapProcessCommand
+	  if (proc == NULL) {
+	    proc = ASGET(mf, ch, Process);
+	    memset(proc, 0, sizeof(*proc));
+	  }
+
+	  cmd = NULL;
+
+	  FOREACH(mf,len)
+	    case 0x6922: // ChapterCommandTime
+	      if (cmd == NULL) {
+		cmd = ASGET(mf,proc,Commands);
+		memset(cmd, 0, sizeof(*cmd));
+	      }
+	      cmd-&gt;Time = (unsigned)readUInt(mf,(unsigned)len);
+	      break;
+	    case 0x6933: // ChapterCommandString
+	      if (cmd == NULL) {
+		cmd = ASGET(mf,proc,Commands);
+		memset(cmd, 0, sizeof(*cmd));
+	      }
+	      if (cmd-&gt;Command)
+		skipbytes(mf,len);
+	      else {
+		cmd-&gt;CommandLength = (unsigned)len;
+		STRGETM(mf,cmd-&gt;Command,len);
+	      }
+	      break;
+	  ENDFOR(mf);
+
+	  if (cmd &amp;&amp; !cmd-&gt;Command)
+	    --proc-&gt;nCommands;
+	  break;
       ENDFOR(mf);
 
-      if (cmd &amp;&amp; !cmd-&gt;String)
-	--ch-&gt;nCommands;
+      if (proc &amp;&amp; !proc-&gt;nCommands)
+	--ch-&gt;nProcess;
       break;
     case 0xb6: // Nested ChapterAtom
       parseChapter(mf,len,ch);
       break;
   ENDFOR(mf);
 
-  ARELEASE(ch,Tracks);
-  ARELEASE(ch,Display);
-  ARELEASE(ch,Children);
+  ARELEASE(mf,ch,Tracks);
+  ARELEASE(mf,ch,Display);
+  ARELEASE(mf,ch,Children);
 }
 
 static void parseChapters(MatroskaFile *mf,ulonglong toplen) {
@@ -1447,7 +1703,7 @@
 
   FOREACH(mf,toplen)
     case 0x45b9: // EditionEntry
-	ch = AGET(mf,Chapters);
+	ch = (Chapter *)AGET(mf,Chapters);
 	memset(ch, 0, sizeof(*ch));
  	FOREACH(mf,len)
 	  case 0x45bc: // EditionUID
@@ -1459,8 +1715,8 @@
 	  case 0x45db: // EditionFlagDefault
 	    ch-&gt;Default = readUInt(mf,(unsigned)len)!=0;
 	    break;
-	  case 0x45dd: // EditionManaged
-	    ch-&gt;Managed = readUInt(mf,(unsigned)len)!=0;
+	  case 0x45dd: // EditionFlagOrdered
+	    ch-&gt;Ordered = readUInt(mf,(unsigned)len)!=0;
 	    break;
 	  case 0xb6: // ChapterAtom
 	    parseChapter(mf,len,ch);
@@ -1479,7 +1735,7 @@
 
   FOREACH(mf,toplen)
     case 0x7373: // Tag
-      tag = AGET(mf,Tags);
+      tag = (Tag *)AGET(mf,Tags);
       memset(tag,0,sizeof(*tag));
 
       FOREACH(mf,len)
@@ -1536,8 +1792,8 @@
 	  ENDFOR(mf);
 
 	  if (!st-&gt;Name || !st-&gt;Value) {
-	    free(st-&gt;Name);
-	    free(st-&gt;Value);
+	    mf-&gt;cache-&gt;memfree(mf-&gt;cache,st-&gt;Name);
+	    mf-&gt;cache-&gt;memfree(mf-&gt;cache,st-&gt;Value);
 	    --tag-&gt;nSimpleTags;
 	  }
 	  break;
@@ -1591,8 +1847,12 @@
     parseContainerPos(mf,mf-&gt;pCluster);
   if (mf-&gt;pTracks &amp;&amp; !mf-&gt;seen.Tracks)
     parseContainerPos(mf,mf-&gt;pTracks);
-  if (mf-&gt;pCues &amp;&amp; !mf-&gt;seen.Cues)
+  if (mf-&gt;pCues &amp;&amp; !mf-&gt;seen.Cues) {
     parseContainerPos(mf,mf-&gt;pCues);
+
+    // ignore errors
+    mf-&gt;flags &amp;= ~MPF_ERROR;
+  }
   if (mf-&gt;pAttachments &amp;&amp; !mf-&gt;seen.Attachments)
     parseContainerPos(mf,mf-&gt;pAttachments);
   if (mf-&gt;pChapters &amp;&amp; !mf-&gt;seen.Chapters)
@@ -1747,7 +2007,7 @@
 	nframes = c+1;
       } else
 	nframes = 1;
-      sizes = alloca(nframes*sizeof(*sizes));
+      sizes = (unsigned *)alloca(nframes*sizeof(*sizes));
  
       switch (lacing) {
 	case 0: // No lacing
@@ -1904,7 +2164,7 @@
     if (++retries &gt; 3) // don't try too hard
       goto ex;
 
-    for (;;cp) {  // &lt;-- XXX TODO FIX THIS!
+    for (;;) {
       if (filepos(mf) &gt;= mf-&gt;pSegmentTop) {
 	mf-&gt;readPosition = filepos(mf);
 	goto ex;
@@ -1941,7 +2201,7 @@
 
   seek(mf,mf-&gt;readPosition);
 
-  for (;;) {
+  while (filepos(mf) &lt; mf-&gt;pSegmentTop) {
     cid = readID(mf);
     if (cid == EOF) {
       ret = EOF;
@@ -1972,7 +2232,7 @@
 out:;
     } else {
       if (toplen &gt; MAXFRAME)
-	errorjmp(mf,&quot;Element in a cluster is too large %X [%u]&quot;,cid,(unsigned)toplen);
+	errorjmp(mf,&quot;Element in a cluster is too large around %llu, %X [%u]&quot;,filepos(mf),cid,(unsigned)toplen);
       if (cid == 0xa0) // BlockGroup
 	parseBlockGroup(mf,toplen,mf-&gt;tcCluster);
       else
@@ -2019,8 +2279,173 @@
   }
 }
 
+static void reindex(MatroskaFile *mf) {
+  jmp_buf     jb;
+  ulonglong   pos = mf-&gt;pCluster;
+  ulonglong   step = 10*1024*1024;
+  ulonglong   size, tc, isize;
+  longlong    next_cluster;
+  int	      id, have_tc, bad;
+  struct Cue  *cue;
+
+  if (pos &gt;= mf-&gt;pSegmentTop)
+    return;
+
+  if (pos + step * 10 &gt; mf-&gt;pSegmentTop)
+    step = (mf-&gt;pSegmentTop - pos) / 10;
+  if (step == 0)
+    step = 1;
+
+  memcpy(&amp;jb,&amp;mf-&gt;jb,sizeof(jb));
+
+  // remove all cues
+  mf-&gt;nCues = 0;
+
+  bad = 0;
+
+  while (pos &lt; mf-&gt;pSegmentTop) {
+    if (!mf-&gt;cache-&gt;progress(mf-&gt;cache,pos,mf-&gt;pSegmentTop))
+      break;
+
+    if (++bad &gt; 50) {
+      pos += step;
+      bad = 0;
+      continue;
+    }
+
+    // find next cluster header
+    next_cluster = mf-&gt;cache-&gt;scan(mf-&gt;cache,pos,0x1f43b675); // cluster
+    if (next_cluster &lt; 0 || (ulonglong)next_cluster &gt;= mf-&gt;pSegmentTop)
+      break;
+
+    pos = next_cluster + 4; // prevent endless loops
+
+    if (setjmp(mf-&gt;jb)) // something evil happened while reindexing
+      continue;
+
+    seek(mf,next_cluster);
+
+    id = readID(mf);
+    if (id == EOF)
+      break;
+    if (id != 0x1f43b675) // shouldn't happen
+      continue;
+
+    size = readVLUInt(mf);
+    if (size &gt;= MAXCLUSTER || size &lt; 1024)
+      continue;
+
+    have_tc = 0;
+    size += filepos(mf);
+
+    while (filepos(mf) &lt; (ulonglong)next_cluster + 1024) {
+      id = readID(mf);
+      if (id == EOF)
+	break;
+
+      isize = readVLUInt(mf);
+
+      if (id == 0xe7) { // cluster timecode
+	tc = readUInt(mf,(unsigned)isize);
+	have_tc = 1;
+	break;
+      }
+
+      skipbytes(mf,isize);
+    }
+
+    if (!have_tc)
+      continue;
+
+    seek(mf,size);
+    id = readID(mf);
+
+    if (id == EOF)
+      break;
+
+    if (id != 0x1f43b675) // cluster
+      continue;
+
+    // good cluster, remember it
+    cue = AGET(mf,Cues);
+    cue-&gt;Time = tc;
+    cue-&gt;Position = next_cluster - mf-&gt;pSegment;
+    cue-&gt;Block = 0;
+    cue-&gt;Track = 0;
+
+    // advance to the next point
+    pos = next_cluster + step;
+    if (pos &lt; size)
+      pos = size;
+
+    bad = 0;
+  }
+
+  fixupCues(mf);
+
+  if (mf-&gt;nCues == 0) {
+    cue = AGET(mf,Cues);
+    cue-&gt;Time = mf-&gt;firstTimecode;
+    cue-&gt;Position = mf-&gt;pCluster - mf-&gt;pSegment;
+    cue-&gt;Block = 0;
+    cue-&gt;Track = 0;
+  }
+
+  mf-&gt;cache-&gt;progress(mf-&gt;cache,0,0);
+
+  memcpy(&amp;mf-&gt;jb,&amp;jb,sizeof(jb));
+}
+
+static void fixupChapter(ulonglong adj, struct Chapter *ch) {
+  unsigned i;
+
+  if (ch-&gt;Start != 0)
+    ch-&gt;Start -= adj;
+  if (ch-&gt;End != 0)
+    ch-&gt;End -= adj;
+
+  for (i=0;i&lt;ch-&gt;nChildren;++i)
+    fixupChapter(adj,&amp;ch-&gt;Children[i]);
+}
+
+static longlong	findLastTimecode(MatroskaFile *mf) {
+  ulonglong   nd = 0;
+  unsigned    n,vtrack;
+
+  if (mf-&gt;nCues == 0 || mf-&gt;nTracks == 0)
+    return -1;
+
+  for (n=vtrack=0;n&lt;mf-&gt;nTracks;++n)
+    if (mf-&gt;Tracks[n]-&gt;Type == TT_VIDEO) {
+      vtrack = n;
+      goto ok;
+    }
+
+  return -1;
+ok:
+
+  mf-&gt;trackMask = ~(1 &lt;&lt; vtrack);
+  mf-&gt;readPosition = mf-&gt;Cues[mf-&gt;nCues - 1].Position + mf-&gt;pSegment;
+  mf-&gt;tcCluster = mf-&gt;Cues[mf-&gt;nCues - 1].Time / mf-&gt;Seg.TimecodeScale;
+
+  do
+    while (mf-&gt;Queues[vtrack].head)
+    {
+      ulonglong   tc = mf-&gt;Queues[vtrack].head-&gt;flags &amp; FRAME_UNKNOWN_END ?
+			  mf-&gt;Queues[vtrack].head-&gt;Start : mf-&gt;Queues[vtrack].head-&gt;End;
+      if (nd &lt; tc)
+	nd = tc;
+      QFree(mf,QGet(&amp;mf-&gt;Queues[vtrack]));
+    }
+  while (readMoreBlocks(mf) != EOF);
+
+  mf-&gt;trackMask = 0;
+
+  return nd;
+}
+
 static void parseFile(MatroskaFile *mf) {
-  ulonglong len;
+  ulonglong len = filepos(mf), adjust;
   unsigned  i;
   int	    id = readID(mf);
   int	    m;
@@ -2028,6 +2453,11 @@
   if (id==EOF)
     errorjmp(mf,&quot;Unexpected EOF at start of file&quot;);
 
+  // files with multiple concatenated segments can have only
+  // one EBML prolog
+  if (len &gt; 0 &amp;&amp; id == 0x18538067)
+    goto segment;
+
   if (id!=0x1a45dfa3)
     errorjmp(mf,&quot;First element in file is not EBML&quot;);
 
@@ -2038,6 +2468,7 @@
     id = readID(mf);
     if (id==EOF)
       errorjmp(mf,&quot;No segments found in the file&quot;);
+segment:
     len = readVLUIntImp(mf,&amp;m);
     // see if it's unspecified
     if (len == (MAXU64 &gt;&gt; (57-m*7)))
@@ -2060,50 +2491,65 @@
   if (!mf-&gt;seen.Cluster)
     errorjmp(mf,&quot;Couldn't find any Clusters&quot;);
 
-  // ensure we have cues
-  if (mf-&gt;nCues == 0)
-    addCue(mf,mf-&gt;pCluster,mf-&gt;firstTimecode);
+  adjust = mf-&gt;firstTimecode * mf-&gt;Seg.TimecodeScale;
 
+  for (i=0;i&lt;mf-&gt;nChapters;++i)
+    fixupChapter(adjust, &amp;mf-&gt;Chapters[i]);

[... truncated: 5486 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="009636.html">[Haiku-commits] r25970 - haiku/trunk/src/apps/deskbar
</A></li>
	<LI>Next message: <A HREF="009638.html">[Haiku-commits] r25972 - in haiku/trunk/src/apps/mediaplayer: .	media_node_framework
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9637">[ date ]</a>
              <a href="thread.html#9637">[ thread ]</a>
              <a href="subject.html#9637">[ subject ]</a>
              <a href="author.html#9637">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
