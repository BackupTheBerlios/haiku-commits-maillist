<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26858 - in haiku/trunk/src/add-ons/kernel:	bus_managers/firewire bus_managers/scsi bus_managers/usb	busses/ide/silicon_image_3112 busses/scsi/ahci	drivers/audio/ac97/auich drivers/audio/ac97/auvia	drivers/audio/ac97/es1370 drivers/audio/ac97/ich	drivers/audio/ac97/ichaudio/lala drivers/audio/echo	drivers/audio/emuxki drivers/audio/hda drivers/audio/ice1712	drivers/dvb/cx23882 drivers/graphics/matrox	drivers/graphics/nvidia drivers/graphics/nvidia_gpgpu	drivers/network/bcm570x drivers/network/dp83815	drivers/network/ipro1000 drivers/network/ipw2100	drivers/network/rtl8169 generic/block_io generic/ide_adapter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26858%20-%20in%20haiku/trunk/src/add-ons/kernel%3A%0A%09bus_managers/firewire%20bus_managers/scsi%20bus_managers/usb%0A%09busses/ide/silicon_image_3112%20busses/scsi/ahci%0A%09drivers/audio/ac97/auich%20drivers/audio/ac97/auvia%0A%09drivers/audio/ac97/es1370%20drivers/audio/ac97/ich%0A%09drivers/audio/ac97/ichaudio/lala%20drivers/audio/echo%0A%09drivers/audio/emuxki%20drivers/audio/hda%20drivers/audio/ice1712%0A%09drivers/dvb/cx23882%20drivers/graphics/matrox%0A%09drivers/graphics/nvidia%20drivers/graphics/nvidia_gpgpu%0A%09drivers/network/bcm570x%20drivers/network/dp83815%0A%09drivers/network/ipro1000%20drivers/network/ipw2100%0A%09drivers/network/rtl8169%20generic/block_io%20generic/ide_adapter&In-Reply-To=%3C200808071300.m77D0gPm003738%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010902.html">
   <LINK REL="Next"  HREF="010909.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26858 - in haiku/trunk/src/add-ons/kernel:	bus_managers/firewire bus_managers/scsi bus_managers/usb	busses/ide/silicon_image_3112 busses/scsi/ahci	drivers/audio/ac97/auich drivers/audio/ac97/auvia	drivers/audio/ac97/es1370 drivers/audio/ac97/ich	drivers/audio/ac97/ichaudio/lala drivers/audio/echo	drivers/audio/emuxki drivers/audio/hda drivers/audio/ice1712	drivers/dvb/cx23882 drivers/graphics/matrox	drivers/graphics/nvidia drivers/graphics/nvidia_gpgpu	drivers/network/bcm570x drivers/network/dp83815	drivers/network/ipro1000 drivers/network/ipw2100	drivers/network/rtl8169 generic/block_io generic/ide_adapter</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26858%20-%20in%20haiku/trunk/src/add-ons/kernel%3A%0A%09bus_managers/firewire%20bus_managers/scsi%20bus_managers/usb%0A%09busses/ide/silicon_image_3112%20busses/scsi/ahci%0A%09drivers/audio/ac97/auich%20drivers/audio/ac97/auvia%0A%09drivers/audio/ac97/es1370%20drivers/audio/ac97/ich%0A%09drivers/audio/ac97/ichaudio/lala%20drivers/audio/echo%0A%09drivers/audio/emuxki%20drivers/audio/hda%20drivers/audio/ice1712%0A%09drivers/dvb/cx23882%20drivers/graphics/matrox%0A%09drivers/graphics/nvidia%20drivers/graphics/nvidia_gpgpu%0A%09drivers/network/bcm570x%20drivers/network/dp83815%0A%09drivers/network/ipro1000%20drivers/network/ipw2100%0A%09drivers/network/rtl8169%20generic/block_io%20generic/ide_adapter&In-Reply-To=%3C200808071300.m77D0gPm003738%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26858 - in haiku/trunk/src/add-ons/kernel:	bus_managers/firewire bus_managers/scsi bus_managers/usb	busses/ide/silicon_image_3112 busses/scsi/ahci	drivers/audio/ac97/auich drivers/audio/ac97/auvia	drivers/audio/ac97/es1370 drivers/audio/ac97/ich	drivers/audio/ac97/ichaudio/lala drivers/audio/echo	drivers/audio/emuxki drivers/audio/hda drivers/audio/ice1712	drivers/dvb/cx23882 drivers/graphics/matrox	drivers/graphics/nvidia drivers/graphics/nvidia_gpgpu	drivers/network/bcm570x drivers/network/dp83815	drivers/network/ipro1000 drivers/network/ipw2100	drivers/network/rtl8169 generic/block_io generic/ide_adapter">axeld at mail.berlios.de
       </A><BR>
    <I>Thu Aug  7 15:00:42 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010902.html">[Haiku-commits] r26857 -	haiku/trunk/src/add-ons/kernel/bus_managers/ps2
</A></li>
        <LI>Next message: <A HREF="010909.html">[Haiku-commits] r26858 - in haiku/trunk/src/add-ons/kernel:	bus_managers/firewire bus_managers/scsi bus_managers/usb	busses/ide/silicon_image_3112 busses/scsi/ahci drivers/audio/ac97/auich drivers/audio/ac97/auvia	drivers/audio/ac97/es1370 drivers/audio/ac97/ich	drivers/audio/ac97/ichaudio/lala drivers/audio/echo drivers/audio/emuxki drivers/audio/hda drivers/audio/ice1712	drivers/dvb/cx23882 drivers/graphics/matrox	drivers/graphics/nvidia drivers/graphics/nvidia_gpgpu drivers/network/bcm570x drivers/network/dp83815	drivers/network/ipro1000 drivers/network/ipw2100	drivers/network/rtl8169 generic/block_io generic/ide_adapter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10905">[ date ]</a>
              <a href="thread.html#10905">[ thread ]</a>
              <a href="subject.html#10905">[ subject ]</a>
              <a href="author.html#10905">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-08-07 15:00:36 +0200 (Thu, 07 Aug 2008)
New Revision: 26858
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26858&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26858&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/bus_managers/firewire/util.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scatter_gather.c
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
   haiku/trunk/src/add-ons/kernel/busses/ide/silicon_image_3112/silicon_image_3112.c
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auvia/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/ich/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/ichaudio/lala/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/echo/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/emuxki/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/hda/hda_controller.cpp
   haiku/trunk/src/add-ons/kernel/drivers/audio/ice1712/util.c
   haiku/trunk/src/add-ons/kernel/drivers/dvb/cx23882/util.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/matrox/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/nvidia/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/nvidia_gpgpu/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/network/bcm570x/b57um.c
   haiku/trunk/src/add-ons/kernel/drivers/network/dp83815/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/network/dp83815/util.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/if_em_osdep.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ipw2100/ipw2100.cpp
   haiku/trunk/src/add-ons/kernel/drivers/network/rtl8169/util.c
   haiku/trunk/src/add-ons/kernel/generic/block_io/block_io.c
   haiku/trunk/src/add-ons/kernel/generic/ide_adapter/ide_adapter.c
Log:
* Fixed a ton of wrong usages of B_CONTIGUOUS + B_FULL_LOCK.
* The use of B_{READ|WRITE}_AREA throughout the drivers is surely alarming.
  Defining these flags means that *every user* application can access these
  buffers read/write, it becomes visible in userspace like any other memory
  (just shared among all apps). I would like to ask each driver maintainer
  to see if that is really wished here. If you only need one app to be able
  to access it, cloning the area would be more appropriate.
* I came across the use of B_ANY_KERNEL_BLOCK_ADDRESS a number of times. This
  is almost completely useless for most usages, as it tries to align the
  virtual to a multiple of the size of the area. It just makes the allocation
  more likely to fail. Please only use where appropriate, and please review
  your code.
* Minor cleanup.


Modified: haiku/trunk/src/add-ons/kernel/bus_managers/firewire/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/firewire/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/firewire/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -1,7 +1,7 @@
 /* Realtek RTL8169 Family Driver
  * Copyright (C) 2004 Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;. All rights reserved.
  *
- * Permission to use, copy, modify and distribute this software and its 
+ * Permission to use, copy, modify and distribute this software and its
  * documentation for any purpose and without fee is hereby granted, provided
  * that the above copyright notice appear in all copies, and that both the
  * copyright notice and this permission notice appear in supporting documentation.
@@ -25,31 +25,35 @@
 #include &quot;fwdebug.h&quot;
 #include &quot;util.h&quot;
 
+
 static inline uint32
 round_to_pagesize(uint32 size)
 {
 	return (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 }
 
+
 area_id
-alloc_mem(void **virt, void **phy, size_t size, uint32 protection, const char *name)
+alloc_mem(void **virt, void **phy, size_t size, uint32 protection,
+	const char *name)
 {
 	physical_entry pe;
-	void * virtadr;
-	area_id areaid;
+	void *virtadr;
+	area_id area;
 	status_t rv;
-	
+
 	TRACE(&quot;allocating %ld bytes for %s\n&quot;, size, name);
 
 	size = round_to_pagesize(size);
-	areaid = create_area(name, &amp;virtadr, B_ANY_KERNEL_ADDRESS, size, B_FULL_LOCK | B_CONTIGUOUS, protection);
-	if (areaid &lt; B_OK) {
+	area = create_area(name, &amp;virtadr, B_ANY_KERNEL_ADDRESS, size, B_CONTIGUOUS,
+		protection);
+	if (area &lt; B_OK) {
 		ERROR(&quot;couldn't allocate area %s\n&quot;, name);
 		return B_ERROR;
 	}
 	rv = get_memory_map(virtadr, size, &amp;pe, 1);
 	if (rv &lt; B_OK) {
-		delete_area(areaid);
+		delete_area(area);
 		ERROR(&quot;couldn't get mapping for %s\n&quot;, name);
 		return B_ERROR;
 	}
@@ -58,33 +62,40 @@
 		*virt = virtadr;
 	if (phy)
 		*phy = pe.address;
-	TRACE(&quot;area = %ld, size = %ld, virt = %p, phy = %p\n&quot;, areaid, size, virtadr, pe.address);
-	return areaid;
+	TRACE(&quot;area = %ld, size = %ld, virt = %p, phy = %p\n&quot;, area, size, virtadr,
+		pe.address);
+	return area;
 }
 
+
 area_id
-map_mem(void **virt, void *phy, size_t size, uint32 protection, const char *name)
+map_mem(void **virt, void *phy, size_t size, uint32 protection,
+	const char *name)
 {
 	uint32 offset;
 	void *phyadr;
 	void *mapadr;
 	area_id area;
 
-	TRACE(&quot;mapping physical address %p with %ld bytes for %s\n&quot;, phy, size, name);
+	TRACE(&quot;mapping physical address %p with %ld bytes for %s\n&quot;, phy, size,
+		name);
 
 	offset = (uint32)phy &amp; (B_PAGE_SIZE - 1);
 	phyadr = (char *)phy - offset;
 	size = round_to_pagesize(size + offset);
-	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS, protection, &amp;mapadr);
+	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS,
+		protection, &amp;mapadr);
 	if (area &lt; B_OK) {
-		ERROR(&quot;mapping '%s' failed, error 0x%lx (%s)\n&quot;, name, area, strerror(area));
+		ERROR(&quot;mapping '%s' failed, error 0x%lx (%s)\n&quot;, name, area,
+			strerror(area));
 		return area;
 	}
-	
+
 	*virt = (char *)mapadr + offset;
 
-	TRACE(&quot;physical = %p, virtual = %p, offset = %ld, phyadr = %p, mapadr = %p, size = %ld, area = 0x%08lx\n&quot;,
-		phy, *virt, offset, phyadr, mapadr, size, area);
-	
+	TRACE(&quot;physical = %p, virtual = %p, offset = %ld, phyadr = %p, mapadr = &quot;
+		&quot;%p, size = %ld, area = 0x%08lx\n&quot;, phy, *virt, offset, phyadr, mapadr,
+		size, area);
+
 	return area;
 }

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -99,7 +99,7 @@
 	// the bus is not ready yet so the CCB cannot be initialized
 	// correctly
 	bus-&gt;ccb_pool = locked_pool-&gt;create(sizeof(scsi_ccb), sizeof(uint32) - 1, 0,
-		CCB_CHUNK_SIZE, CCB_NUM_MAX, 0, &quot;scsi_ccb_pool&quot;, B_FULL_LOCK | B_CONTIGUOUS,
+		CCB_CHUNK_SIZE, CCB_NUM_MAX, 0, &quot;scsi_ccb_pool&quot;, B_CONTIGUOUS,
 		ccb_low_alloc_hook, ccb_low_free_hook, bus);
 
 	if (bus-&gt;ccb_pool == NULL)

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
+ * Copyright 2004-2008, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
  * Copyright 2002/03, Thomas Kurschel. All rights reserved.
  *
  * Distributed under the terms of the MIT License.
@@ -213,8 +213,7 @@
 
 		buffer-&gt;area = create_area(&quot;DMA buffer&quot;,
 			(void **)&amp;dma_buffer_address_unaligned,
-			B_ANY_KERNEL_ADDRESS, size,
-			B_FULL_LOCK | B_CONTIGUOUS, 0 );
+			B_ANY_KERNEL_ADDRESS, size, B_CONTIGUOUS, 0);
 		if (buffer-&gt;area &lt; 0) {
 			SHOW_ERROR(2, &quot;Cannot create contignous DMA buffer of %d bytes&quot;,
 				(int)size);

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scatter_gather.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scatter_gather.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/scatter_gather.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2007, Haiku, Inc. All RightsReserved.
+ * Copyright 2004-2008, Haiku, Inc. All RightsReserved.
  * Copyright 2002-2003, Thomas Kurschel. All rights reserved.
  *
  * Distributed under the terms of the MIT License.
@@ -50,20 +50,20 @@
 
 	if (dma_boundary != ~0UL || ccb-&gt;data_length &gt; max_sg_block_size) {
 		// S/G list may not be controller-compatible:
-		// we have to split offending entries		
-		SHOW_FLOW(3, &quot;Checking violation of dma boundary 0x%x and entry size 0x%x&quot;, 
+		// we have to split offending entries
+		SHOW_FLOW(3, &quot;Checking violation of dma boundary 0x%x and entry size 0x%x&quot;,
 			(int)dma_boundary, (int)max_sg_block_size);
 
 		for (cur_idx = 0; cur_idx &lt; num_entries; ++cur_idx) {
 			addr_t max_len;
 
 			// calculate space upto next dma boundary crossing
-			max_len = (dma_boundary + 1) - 
+			max_len = (dma_boundary + 1) -
 				((addr_t)temp_sg[cur_idx].address &amp; dma_boundary);
 			// restrict size per sg item
 			max_len = min(max_len, max_sg_block_size);
 
-			SHOW_FLOW(4, &quot;addr=%p, size=%x, max_len=%x, idx=%d, num=%d&quot;, 
+			SHOW_FLOW(4, &quot;addr=%p, size=%x, max_len=%x, idx=%d, num=%d&quot;,
 				temp_sg[cur_idx].address, (int)temp_sg[cur_idx].size,
 				(int)max_len, (int)cur_idx, (int)num_entries);
 
@@ -72,7 +72,7 @@
 				if (++num_entries &gt; max_sg_blocks)
 					goto too_complex;
 
-				memmove(&amp;temp_sg[cur_idx + 1], &amp;temp_sg[cur_idx], 
+				memmove(&amp;temp_sg[cur_idx + 1], &amp;temp_sg[cur_idx],
 					(num_entries - 1 - cur_idx) * sizeof(physical_entry));
 
 				temp_sg[cur_idx].size = max_len;
@@ -84,7 +84,7 @@
 
 	ccb-&gt;sg_count = num_entries;
 
-	return true;	
+	return true;
 
 too_complex:
 	SHOW_ERROR( 2, &quot;S/G list to complex for IO request (max %d entries)&quot;,
@@ -147,7 +147,7 @@
 {
 	status_t res;
 
-	SHOW_FLOW(3, &quot;ccb=%p, data=%p, data_length=%d&quot;, 
+	SHOW_FLOW(3, &quot;ccb=%p, data=%p, data_length=%d&quot;,
 		ccb, ccb-&gt;data, (int)ccb-&gt;data_length);
 
 	res = unlock_memory(ccb-&gt;data, ccb-&gt;data_length, B_DMA_IO
@@ -170,12 +170,11 @@
 int
 init_temp_sg(void)
 {
-	temp_sg_pool = locked_pool-&gt;create( 
+	temp_sg_pool = locked_pool-&gt;create(
 		MAX_TEMP_SG_FRAGMENTS * sizeof(physical_entry),
 		sizeof(physical_entry) - 1, 0,
-		B_PAGE_SIZE, MAX_TEMP_SG_LISTS, 1, 
-		&quot;scsi_temp_sg_pool&quot;, B_FULL_LOCK | B_CONTIGUOUS,
-		NULL, NULL, NULL);
+		B_PAGE_SIZE, MAX_TEMP_SG_LISTS, 1,
+		&quot;scsi_temp_sg_pool&quot;, B_CONTIGUOUS, NULL, NULL, NULL);
 
 	if (temp_sg_pool == NULL)
 		return B_NO_MEMORY;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/PhysicalMemoryAllocator.cpp	2008-08-07 13:00:36 UTC (rev 26858)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006, Haiku Inc. All rights reserved.
+ * Copyright 2006-2008, Haiku Inc. All rights reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
@@ -69,7 +69,7 @@
 	roundedSize = (roundedSize + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 
 	fArea = create_area(fName, &amp;fLogicalBase, B_ANY_KERNEL_ADDRESS,
-		roundedSize, B_FULL_LOCK | B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
+		roundedSize, B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
 	if (fArea &lt; B_OK) {
 		TRACE_ERROR((&quot;PMA: failed to create memory area\n&quot;));
 		return;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2008-08-07 13:00:36 UTC (rev 26858)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006, Haiku Inc. All rights reserved.
+ * Copyright 2003-2008, Haiku Inc. All rights reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
@@ -282,7 +282,7 @@
 	void *logAddress;
 	size = (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 	area_id area = create_area(name, &amp;logAddress, B_ANY_KERNEL_ADDRESS, size,
-		B_FULL_LOCK | B_CONTIGUOUS, 0);
+		B_CONTIGUOUS, 0);
 
 	if (area &lt; B_OK) {
 		TRACE_ERROR((&quot;USB Stack: couldn't allocate area %s\n&quot;, name));

Modified: haiku/trunk/src/add-ons/kernel/busses/ide/silicon_image_3112/silicon_image_3112.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/ide/silicon_image_3112/silicon_image_3112.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/busses/ide/silicon_image_3112/silicon_image_3112.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -211,7 +211,7 @@
 		};
 		device_attr attrs[] = {
 			// properties of this controller for ide bus manager
-			// there are always max. 2 devices 
+			// there are always max. 2 devices
 			// (unless this is a Compact Flash Card with a built-in IDE controller,
 			//  which has exactly 1 device)
 			{ IDE_CONTROLLER_MAX_DEVICES_ITEM, B_UINT8_TYPE, { ui8: kASICData[asicIndex].channel_count }},
@@ -221,9 +221,9 @@
 			{ IDE_CONTROLLER_CAN_CQ_ITEM, B_UINT8_TYPE, { ui8: true }},
 			// choose any name here
 			{ IDE_CONTROLLER_CONTROLLER_NAME_ITEM, B_STRING_TYPE, { string: CONTROLLER_NAME }},
-	
+
 			// DMA properties
-			// data must be word-aligned; 
+			// data must be word-aligned;
 			// warning: some controllers are more picky!
 			{ B_BLOCK_DEVICE_DMA_ALIGNMENT, B_UINT32_TYPE, { ui32: 1}},
 			// one S/G block must not cross 64K boundary
@@ -232,7 +232,7 @@
 			{ B_BLOCK_DEVICE_MAX_SG_BLOCK_SIZE, B_UINT32_TYPE, { ui32: 0x10000 }},
 			// see definition of MAX_SG_COUNT
 			{ B_BLOCK_DEVICE_MAX_SG_BLOCKS, B_UINT32_TYPE, { ui32: IDE_ADAPTER_MAX_SG_COUNT }},
-	
+
 			// private data to find controller
 			{ &quot;silicon_image_3112/asic_index&quot;, B_UINT32_TYPE, { ui32: asicIndex }},
 			{ &quot;silicon_image_3112/mmio_base&quot;, B_UINT32_TYPE, { ui32: mmioBase }},
@@ -248,7 +248,7 @@
 }
 
 
-static status_t 
+static status_t
 controller_init(device_node *node, void **_controllerCookie)
 {
 	controller_data *controller;
@@ -263,9 +263,9 @@
 	status_t res;
 	uint32 temp;
 	int i;
-	
+
 	TRACE(&quot;controller_init\n&quot;);
-	
+
 	if (dm-&gt;get_attr_uint32(node, &quot;silicon_image_3112/asic_index&quot;, &amp;asicIndex, false) != B_OK)
 		return B_ERROR;
 	if (dm-&gt;get_attr_uint32(node, &quot;silicon_image_3112/mmio_base&quot;, &amp;mmioBase, false) != B_OK)
@@ -277,10 +277,10 @@
 	if (!controller)
 		return B_NO_MEMORY;
 
-	FLOW(&quot;controller %p\n&quot;, controller);	
+	FLOW(&quot;controller %p\n&quot;, controller);
 
 	mmioArea = map_physical_memory(&quot;Silicon Image SATA regs&quot;,
-		(void *)mmioBase, kASICData[asicIndex].mmio_bar_size, 
+		(void *)mmioBase, kASICData[asicIndex].mmio_bar_size,
 		B_ANY_KERNEL_ADDRESS, 0, (void **)&amp;mmioAddr);
 	if (mmioArea &lt; B_OK) {
 		TRACE(&quot;controller_init: mapping memory failed\n&quot;);
@@ -320,7 +320,7 @@
 	for (i = 0; i &lt; kASICData[asicIndex].channel_count; i++)
 		*(volatile uint32 *)(mmioAddr + kControllerChannelData[i].sien) = 0;
 	*(volatile uint32 *)(mmioAddr + kControllerChannelData[0].sien); // flush
-	
+
 	// install interrupt handler
 	res = install_io_interrupt_handler(interruptNumber, handle_interrupt,
 		controller, 0);
@@ -336,7 +336,7 @@
 	temp &amp;= (asicIndex == ASIC_SI3114) ? (~SI_MASK_4PORT) : (~SI_MASK_2PORT);
 	*(volatile uint32 *)(mmioAddr + SI_SYSCFG) = temp;
 	*(volatile uint32 *)(mmioAddr + SI_SYSCFG); // flush
-	
+
 	*_controllerCookie = controller;
 
 	TRACE(&quot;controller_init success\n&quot;);
@@ -418,9 +418,9 @@
 	physical_entry entry;
 	size_t prdtSize;
 	uint32 channelIndex;
-	
+
 	TRACE(&quot;channel_init enter\n&quot;);
-	
+
 	channel = malloc(sizeof(channel_data));
 	if (!channel)
 		return B_NO_MEMORY;
@@ -445,18 +445,19 @@
 	TRACE(&quot;channel_index %ld\n&quot;, channelIndex);
 	TRACE(&quot;channel name: %s\n&quot;, kControllerChannelData[channelIndex].name);
 
-	TRACE(&quot;channel %p\n&quot;, channel);	
+	TRACE(&quot;channel %p\n&quot;, channel);
 
 	parent = dm-&gt;get_parent_node(node);
 	dm-&gt;get_driver(parent, NULL, (void **)&amp;controller);
 	dm-&gt;put_node(parent);
 
-	TRACE(&quot;controller %p\n&quot;, controller);	
+	TRACE(&quot;controller %p\n&quot;, controller);
 	TRACE(&quot;mmio_addr %p\n&quot;, (void *)controller-&gt;mmio_addr);
 
-	// PRDT must be contiguous, dword-aligned and must not cross 64K boundary 
+	// PRDT must be contiguous, dword-aligned and must not cross 64K boundary
 	prdtSize = (IDE_ADAPTER_MAX_SG_COUNT * sizeof(prd_entry) + (B_PAGE_SIZE - 1)) &amp; ~(B_PAGE_SIZE - 1);
-	channel-&gt;prd_area = create_area(&quot;prd&quot;, (void **)&amp;channel-&gt;prdt, B_ANY_KERNEL_ADDRESS, prdtSize, B_FULL_LOCK | B_CONTIGUOUS, 0);
+	channel-&gt;prd_area = create_area(&quot;prd&quot;, (void **)&amp;channel-&gt;prdt,
+		B_ANY_KERNEL_ADDRESS, prdtSize, B_CONTIGUOUS, 0);
 	if (channel-&gt;prd_area &lt; B_OK) {
 		TRACE(&quot;creating prd_area failed\n&quot;);
 		goto err;
@@ -543,7 +544,7 @@
 	int i;
 
 	FLOW(&quot;task_file_write\n&quot;);
-	
+
 	if (channel-&gt;lost)
 		return B_ERROR;
 
@@ -552,14 +553,14 @@
 			FLOW(&quot;%x-&gt;HI(%x)\n&quot;, tf-&gt;raw.r[i + 7], i );
 			channel-&gt;task_file[i] = tf-&gt;raw.r[i + 7];
 		}
-		
+
 		if (((1 &lt;&lt; i) &amp; mask) != 0) {
 			FLOW(&quot;%x-&gt;LO(%x)\n&quot;, tf-&gt;raw.r[i], i );
 			channel-&gt;task_file[i] = tf-&gt;raw.r[i];
 		}
 	}
 	*channel-&gt;dev_ctrl; // read altstatus to flush
-	
+
 	return B_OK;
 }
 
@@ -581,7 +582,7 @@
 			FLOW(&quot;%x: %x\n&quot;, i, (int)tf-&gt;raw.r[i] );
 		}
 	}
-	
+
 	return B_OK;
 }
 
@@ -600,19 +601,19 @@
 }
 
 
-static status_t 
+static status_t
 device_control_write(void *channelCookie, uint8 val)
 {
 	channel_data *channel = channelCookie;
 
 	FLOW(&quot;device_control_write 0x%x\n&quot;, val);
-	
+
 	if (channel-&gt;lost)
 		return B_ERROR;
 
 	*channel-&gt;dev_ctrl = val;
 	*channel-&gt;dev_ctrl; // read altstatus to flush
-	
+
 	return B_OK;
 }
 
@@ -635,12 +636,12 @@
 	} else {
 		volatile uint32 * base = (volatile uint32 *)channel-&gt;command_block;
 		uint32 *cur_data = (uint32 *)data;
-		
+
 		for ( ; count &gt; 0; count -= 2 )
 			*base = *(cur_data++);
 	}
 	*channel-&gt;dev_ctrl; // read altstatus to flush
-	
+
 	return B_OK;
 }
 
@@ -653,7 +654,7 @@
 		return B_ERROR;
 
 	FLOW(&quot;pio_read force_16bit = %d, (count &amp; 1) = %d\n&quot;, force_16bit, (count &amp; 1));
-	
+
 	// The data port is only 8 bit wide in the command register block.
 	// We are memory mapped and read using 16 or 32 bit access from this 8 bit location.
 
@@ -664,11 +665,11 @@
 	} else {
 		volatile uint32 * base = (volatile uint32 *)channel-&gt;command_block;
 		uint32 *cur_data = (uint32 *)data;
-		
+
 		for ( ; count &gt; 0; count -= 2 )
 			*(cur_data++) = *base;
 	}
-	
+
 	return B_OK;
 }
 
@@ -745,9 +746,9 @@
 	*channel-&gt;bm_command_reg = command;
 
 	*channel-&gt;dev_ctrl; // read altstatus to flush
-	
+
 	FLOW(&quot;dma_start leave\n&quot;);
-	
+
 	return B_OK;
 }
 
@@ -772,7 +773,7 @@
 		| IDE_BM_STATUS_ERROR;
 
 	*channel-&gt;dev_ctrl; // read altstatus to flush
-	
+
 	if ((status &amp; IDE_BM_STATUS_ERROR) != 0) {
 		FLOW(&quot;dma_finish: failed\n&quot;);
 		return B_ERROR;
@@ -851,7 +852,7 @@
 			0,
 			NULL
 		},
-		
+
 		.supports_device			= NULL,
 		.register_device			= NULL,
 		.init_driver				= &amp;channel_init,

Modified: haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -13,24 +13,28 @@
 #define TRACE(a...) dprintf(&quot;\33[34mahci:\33[0m &quot; a)
 #define ERROR(a...) dprintf(&quot;\33[34mahci:\33[0m &quot; a)
 
+
 static inline uint32
 round_to_pagesize(uint32 size)
 {
 	return (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 }
 
+
 area_id
-alloc_mem(void **virt, void **phy, size_t size, uint32 protection, const char *name)
+alloc_mem(void **virt, void **phy, size_t size, uint32 protection,
+	const char *name)
 {
 	physical_entry pe;
 	void * virtadr;
 	area_id areaid;
 	status_t rv;
-	
+
 	TRACE(&quot;allocating %ld bytes for %s\n&quot;, size, name);
 
 	size = round_to_pagesize(size);
-	areaid = create_area(name, &amp;virtadr, B_ANY_KERNEL_ADDRESS, size, B_FULL_LOCK | B_CONTIGUOUS, protection);
+	areaid = create_area(name, &amp;virtadr, B_ANY_KERNEL_ADDRESS, size,
+		B_CONTIGUOUS, protection);
 	if (areaid &lt; B_OK) {
 		ERROR(&quot;couldn't allocate area %s\n&quot;, name);
 		return B_ERROR;
@@ -49,8 +53,10 @@
 	return areaid;
 }
 
+
 area_id
-map_mem(void **virt, void *phy, size_t size, uint32 protection, const char *name)
+map_mem(void **virt, void *phy, size_t size, uint32 protection,
+	const char *name)
 {
 	uint32 offset;
 	void *phyadr;
@@ -62,34 +68,37 @@
 	offset = (uint32)phy &amp; (B_PAGE_SIZE - 1);
 	phyadr = (char *)phy - offset;
 	size = round_to_pagesize(size + offset);
-	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS, protection, &amp;mapadr);
+	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS,
+		protection, &amp;mapadr);
 	if (area &lt; B_OK) {
 		ERROR(&quot;mapping '%s' failed, error 0x%lx (%s)\n&quot;, name, area, strerror(area));
 		return area;
 	}
-	
+
 	*virt = (char *)mapadr + offset;
 
 	TRACE(&quot;physical = %p, virtual = %p, offset = %ld, phyadr = %p, mapadr = %p, size = %ld, area = 0x%08lx\n&quot;,
 		phy, *virt, offset, phyadr, mapadr, size, area);
-	
+
 	return area;
 }
 
 
 status_t
-sg_memcpy(const physical_entry *sgTable, int sgCount, const void *data, size_t dataSize)
+sg_memcpy(const physical_entry *sgTable, int sgCount, const void *data,
+	size_t dataSize)
 {
 	int i;
 	for (i = 0; i &lt; sgCount &amp;&amp; dataSize &gt; 0; i++) {
 		size_t size = min_c(dataSize, sgTable[i].size);
 		addr_t address;
 
-		if (vm_get_physical_page((addr_t)sgTable[i].address, &amp;address, PHYSICAL_PAGE_CAN_WAIT) &lt; B_OK)
+		if (vm_get_physical_page((addr_t)sgTable[i].address, &amp;address,
+				PHYSICAL_PAGE_CAN_WAIT) &lt; B_OK)
 			return B_ERROR;
 
 		TRACE(&quot;sg_memcpy phyAddr %p, addr %p, size %lu\n&quot;, sgTable[i].address, (void *)address, size);
-		
+
 		memcpy((void *)address, data, size);
 		vm_put_physical_page(address);
 

Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auich/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -4,24 +4,24 @@
  * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
  *
  * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
- * - Redistributions of source code must retain the above copyright notice, 
+ * - Redistributions of source code must retain the above copyright notice,
  *   this list of conditions and the following disclaimer.
  * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
+ *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
@@ -38,60 +38,72 @@
 
 uint32 round_to_pagesize(uint32 size);
 
-cpu_status lock(void)
+
+cpu_status
+lock(void)
 {
 	cpu_status status = disable_interrupts();
 	acquire_spinlock(&amp;slock);
 	return status;
 }
 
-void unlock(cpu_status status)
+
+void
+unlock(cpu_status status)
 {
 	release_spinlock(&amp;slock);
 	restore_interrupts(status);
 }
 
-uint32 round_to_pagesize(uint32 size)
+
+uint32
+round_to_pagesize(uint32 size)
 {
 	return (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 }
 
-area_id alloc_mem(void **phy, void **log, size_t size, const char *name)
+
+area_id
+alloc_mem(void **phy, void **log, size_t size, const char *name)
 {
 	physical_entry pe;
 	void * logadr;
-	area_id areaid;
+	area_id area;
 	status_t rv;
-	
+
 	LOG((&quot;allocating %d bytes for %s\n&quot;,size,name));
 
 	size = round_to_pagesize(size);
-	areaid = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS,size,B_FULL_LOCK | B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
-	if (areaid &lt; B_OK) {
-		PRINT((&quot;couldn't allocate area %s\n&quot;,name));
+	area = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS, size, B_CONTIGUOUS,
+		B_READ_AREA | B_WRITE_AREA);
+	if (area &lt; B_OK) {
+		PRINT((&quot;couldn't allocate area %s\n&quot;, name));
 		return B_ERROR;
 	}
-	rv = get_memory_map(logadr,size,&amp;pe,1);
+	rv = get_memory_map(logadr, size, &amp;pe, 1);
 	if (rv &lt; B_OK) {
-		delete_area(areaid);
+		delete_area(area);
 		PRINT((&quot;couldn't map %s\n&quot;,name));
 		return B_ERROR;
 	}
-	memset(logadr,0,size);
+	memset(logadr, 0, size);
 	if (log)
 		*log = logadr;
 	if (phy)
 		*phy = pe.address;
-	LOG((&quot;area = %d, size = %d, log = %#08X, phy = %#08X\n&quot;,areaid,size,logadr,pe.address));
-	return areaid;
+	LOG((&quot;area = %d, size = %d, log = %#08X, phy = %#08X\n&quot;, area, size, logadr,
+		pe.address));
+	return area;
 }
 
+
 /* This is not the most advanced method to map physical memory for io access.
  * Perhaps using B_ANY_KERNEL_ADDRESS instead of B_ANY_KERNEL_BLOCK_ADDRESS
  * makes the whole offset calculation and relocation obsolete. But the code
  * below does work, and I can't test if using B_ANY_KERNEL_ADDRESS also works.
  */
-area_id map_mem(void **log, void *phy, size_t size, const char *name)
+area_id
+map_mem(void **log, void *phy, size_t size, const char *name)
 {
 	uint32 offset;
 	void *phyadr;
@@ -108,6 +120,6 @@
 
 	LOG((&quot;physical = %p, logical = %p, offset = %#x, phyadr = %p, mapadr = %p, size = %#x, area = %#x\n&quot;,
 		phy, *log, offset, phyadr, mapadr, size, area));
-	
+
 	return area;
 }

Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auvia/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auvia/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/auvia/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -4,24 +4,24 @@
  * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
  *
  * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
- * - Redistributions of source code must retain the above copyright notice, 
+ * - Redistributions of source code must retain the above copyright notice,
  *   this list of conditions and the following disclaimer.
  * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
+ *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
@@ -38,35 +38,44 @@
 
 uint32 round_to_pagesize(uint32 size);
 
-cpu_status lock(void)
+
+cpu_status
+lock(void)
 {
 	cpu_status status = disable_interrupts();
 	acquire_spinlock(&amp;slock);
 	return status;
 }
 
-void unlock(cpu_status status)
+
+void
+unlock(cpu_status status)
 {
 	release_spinlock(&amp;slock);
 	restore_interrupts(status);
 }
 
-uint32 round_to_pagesize(uint32 size)
+
+uint32
+round_to_pagesize(uint32 size)
 {
 	return (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 }
 
-area_id alloc_mem(void **phy, void **log, size_t size, const char *name)
+
+area_id
+alloc_mem(void **phy, void **log, size_t size, const char *name)
 {
 	physical_entry pe;
 	void * logadr;
 	area_id areaid;
 	status_t rv;
-	
+
 	LOG((&quot;allocating %d bytes for %s\n&quot;,size,name));
 
 	size = round_to_pagesize(size);
-	areaid = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS,size,B_FULL_LOCK | B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
+	areaid = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS, size,
+		B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
 	if (areaid &lt; B_OK) {
 		PRINT((&quot;couldn't allocate area %s\n&quot;,name));
 		return B_ERROR;

Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -4,24 +4,24 @@
  * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
  *
  * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
- * - Redistributions of source code must retain the above copyright notice, 
+ * - Redistributions of source code must retain the above copyright notice,
  *   this list of conditions and the following disclaimer.
  * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
+ *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
@@ -38,60 +38,72 @@
 
 uint32 round_to_pagesize(uint32 size);
 
-cpu_status lock(void)
+
+cpu_status
+lock(void)
 {
 	cpu_status status = disable_interrupts();
 	acquire_spinlock(&amp;slock);
 	return status;
 }
 
-void unlock(cpu_status status)
+
+void
+unlock(cpu_status status)
 {
 	release_spinlock(&amp;slock);
 	restore_interrupts(status);
 }
 
-uint32 round_to_pagesize(uint32 size)
+
+uint32
+round_to_pagesize(uint32 size)
 {
 	return (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
 }
 
-area_id alloc_mem(void **phy, void **log, size_t size, const char *name)
+
+area_id
+alloc_mem(void **phy, void **log, size_t size, const char *name)
 {
 	physical_entry pe;
 	void * logadr;
 	area_id areaid;
 	status_t rv;
-	
+
 	LOG((&quot;allocating %d bytes for %s\n&quot;,size,name));
 
 	size = round_to_pagesize(size);
-	areaid = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS,size,B_FULL_LOCK | B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
+	areaid = create_area(name, &amp;logadr, B_ANY_KERNEL_ADDRESS, size,
+		B_CONTIGUOUS, B_READ_AREA | B_WRITE_AREA);
 	if (areaid &lt; B_OK) {
 		PRINT((&quot;couldn't allocate area %s\n&quot;,name));
 		return B_ERROR;
 	}
-	rv = get_memory_map(logadr,size,&amp;pe,1);
+	rv = get_memory_map(logadr, size, &amp;pe, 1);
 	if (rv &lt; B_OK) {
 		delete_area(areaid);
-		PRINT((&quot;couldn't map %s\n&quot;,name));
+		PRINT((&quot;couldn't map %s\n&quot;, name));
 		return B_ERROR;
 	}
-	memset(logadr,0,size);
+	memset(logadr, 0, size);
 	if (log)
 		*log = logadr;
 	if (phy)
 		*phy = pe.address;
-	LOG((&quot;area = %d, size = %d, log = %#08X, phy = %#08X\n&quot;,areaid,size,logadr,pe.address));
+	LOG((&quot;area = %d, size = %d, log = %#08X, phy = %#08X\n&quot;, areaid, size,
+		logadr, pe.address));
 	return areaid;
 }
 
+
 /* This is not the most advanced method to map physical memory for io access.
  * Perhaps using B_ANY_KERNEL_ADDRESS instead of B_ANY_KERNEL_BLOCK_ADDRESS
  * makes the whole offset calculation and relocation obsolete. But the code
  * below does work, and I can't test if using B_ANY_KERNEL_ADDRESS also works.
  */
-area_id map_mem(void **log, void *phy, size_t size, const char *name)
+area_id
+map_mem(void **log, void *phy, size_t size, const char *name)
 {
 	uint32 offset;
 	void *phyadr;
@@ -103,11 +115,12 @@
 	offset = (uint32)phy &amp; (B_PAGE_SIZE - 1);
 	phyadr = phy - offset;
 	size = round_to_pagesize(size + offset);
-	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS, B_READ_AREA | B_WRITE_AREA, &amp;mapadr);
+	area = map_physical_memory(name, phyadr, size, B_ANY_KERNEL_BLOCK_ADDRESS,
+		B_READ_AREA | B_WRITE_AREA, &amp;mapadr);
 	*log = mapadr + offset;
 
 	LOG((&quot;physical = %p, logical = %p, offset = %#x, phyadr = %p, mapadr = %p, size = %#x, area = %#x\n&quot;,
 		phy, *log, offset, phyadr, mapadr, size, area));
-	
+
 	return area;
 }

Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/ich/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/ich/util.c	2008-08-07 12:29:32 UTC (rev 26857)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/ich/util.c	2008-08-07 13:00:36 UTC (rev 26858)
@@ -4,24 +4,24 @@
  * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
  *
  * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
+ * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *
- * - Redistributions of source code must retain the above copyright notice, 
+ * - Redistributions of source code must retain the above copyright notice,
  *   this list of conditions and the following disclaimer.
  * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
+ *   this list of conditions and the following disclaimer in the documentation
  *   and/or other materials provided with the distribution.
  *

[... truncated: 2144 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010902.html">[Haiku-commits] r26857 -	haiku/trunk/src/add-ons/kernel/bus_managers/ps2
</A></li>
	<LI>Next message: <A HREF="010909.html">[Haiku-commits] r26858 - in haiku/trunk/src/add-ons/kernel:	bus_managers/firewire bus_managers/scsi bus_managers/usb	busses/ide/silicon_image_3112 busses/scsi/ahci drivers/audio/ac97/auich drivers/audio/ac97/auvia	drivers/audio/ac97/es1370 drivers/audio/ac97/ich	drivers/audio/ac97/ichaudio/lala drivers/audio/echo drivers/audio/emuxki drivers/audio/hda drivers/audio/ice1712	drivers/dvb/cx23882 drivers/graphics/matrox	drivers/graphics/nvidia drivers/graphics/nvidia_gpgpu drivers/network/bcm570x drivers/network/dp83815	drivers/network/ipro1000 drivers/network/ipw2100	drivers/network/rtl8169 generic/block_io generic/ide_adapter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10905">[ date ]</a>
              <a href="thread.html#10905">[ thread ]</a>
              <a href="subject.html#10905">[ subject ]</a>
              <a href="author.html#10905">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
