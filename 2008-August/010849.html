<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r26828 - in haiku/trunk: build/jam	headers/os/drivers/bus headers/private/drivers	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/generic/scsi_periph
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26828%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers/bus%20headers/private/drivers%0A%09src/add-ons/kernel/bus_managers/ata%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_disk%0A%09src/add-ons/kernel/generic/scsi_periph&In-Reply-To=%3C200808052111.m75LBsJY008040%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="010848.html">
   <LINK REL="Next"  HREF="010850.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r26828 - in haiku/trunk: build/jam	headers/os/drivers/bus headers/private/drivers	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/generic/scsi_periph</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r26828%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers/bus%20headers/private/drivers%0A%09src/add-ons/kernel/bus_managers/ata%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/drivers/disk/scsi/scsi_disk%0A%09src/add-ons/kernel/generic/scsi_periph&In-Reply-To=%3C200808052111.m75LBsJY008040%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r26828 - in haiku/trunk: build/jam	headers/os/drivers/bus headers/private/drivers	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/drivers/disk/scsi/scsi_disk	src/add-ons/kernel/generic/scsi_periph">axeld at mail.berlios.de
       </A><BR>
    <I>Tue Aug  5 23:11:54 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="010848.html">[Haiku-commits] r26827 -	haiku/trunk/src/add-ons/media/plugins/raw_decoder
</A></li>
        <LI>Next message: <A HREF="010850.html">[Haiku-commits] r26829 -	haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10849">[ date ]</a>
              <a href="thread.html#10849">[ thread ]</a>
              <a href="subject.html#10849">[ subject ]</a>
              <a href="author.html#10849">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-08-05 23:11:51 +0200 (Tue, 05 Aug 2008)
New Revision: 26828
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=26828&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=26828&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device_icons.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/error_handling.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/handle.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/io.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/removable.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph.cpp
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/sync.cpp
Removed:
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device_icons.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/error_handling.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/handle.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/io.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/removable.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph.c
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/sync.c
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/headers/os/drivers/bus/SCSI.h
   haiku/trunk/headers/private/drivers/scsi_periph.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ata/ata_request.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.cpp
   haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/Jamfile
   haiku/trunk/src/add-ons/kernel/generic/scsi_periph/scsi_periph_int.h
Log:
* First baby steps in letting our drivers use the new I/O request/scheduler
  architecture: for now, we do this on the lowest layer only, therefore all
  requests are handled synchronously (ie. in the scheduler's thread).
* Instead of using the block_io module, scsi_disk (and scsi_cd) are now
  exporting a device on their own, and use an I/O scheduler with an appropriate
  DMA resource.
* There are still lots of TODOs, and it can easily panic - don't update if
  you intend to demo Haiku.
* scsi_periph now only has an io() function that get an io_operation, instead
  of the previous read/write functions, moved preferred CCB size from those
  functions into the device registration.
* Changed all scsi_periph files to C++.
* scsi_cd ported, too, but untested.
* Removed block_io from image - it will be removed completely soon.
* Temporarily commented an ASSERT() in the ATA bus manager (in case you use
  it); it's sometimes triggered by the code now, and I haven't yet looked into
  the issue -- doesn't seem to harm, at least.


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/build/jam/HaikuImage	2008-08-05 21:11:51 UTC (rev 26828)
@@ -160,7 +160,7 @@
 AddFilesToHaikuImage beos system add-ons kernel file_systems
 	: $(BEOS_ADD_ONS_FILE_SYSTEMS) ;
 AddFilesToHaikuImage beos system add-ons kernel generic
-	: block_io dpc ide_adapter locked_pool mpu401 scsi_periph ;
+	: dpc ide_adapter locked_pool mpu401 scsi_periph ;
 AddFilesToHaikuImage beos system add-ons kernel partitioning_systems
 	: intel session ;
 AddFilesToHaikuImage beos system add-ons kernel interrupt_controllers
@@ -372,7 +372,7 @@
 AddBootModuleSymlinksToHaikuImage
 	pci $(X86_ONLY)isa config_manager ide scsi usb
 	$(PPC_ONLY)openpic
-	block_io ide_adapter locked_pool scsi_periph
+	ide_adapter locked_pool scsi_periph
 	ahci generic_ide_pci it8211 legacy_sata silicon_image_3112 $(X86_ONLY)ide_isa
 	&lt;usb&gt;uhci &lt;usb&gt;ohci &lt;usb&gt;ehci
 	scsi_cd scsi_disk usb_disk

Modified: haiku/trunk/headers/os/drivers/bus/SCSI.h
===================================================================
--- haiku/trunk/headers/os/drivers/bus/SCSI.h	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/headers/os/drivers/bus/SCSI.h	2008-08-05 21:11:51 UTC (rev 26828)
@@ -134,6 +134,7 @@
 	uint16		sg_count;			// number of S/G entries
 	uint32		data_length;		// length of data
 	int32		data_resid;			// data transfer residual length: 2's comp
+	void		*io_operation;
 
 	uchar		sense[SCSI_MAX_SENSE_SIZE]; // autosense data
 	uchar		sense_resid;		// autosense resid length: 2's comp

Modified: haiku/trunk/headers/private/drivers/scsi_periph.h
===================================================================
--- haiku/trunk/headers/private/drivers/scsi_periph.h	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/headers/private/drivers/scsi_periph.h	2008-08-05 21:11:51 UTC (rev 26828)
@@ -7,8 +7,7 @@
 #ifndef _SCSI_PERIPH_H
 #define _SCSI_PERIPH_H
 
-/*
-	Use this module to minimize work required to write a SCSI
+/*!	Use this module to minimize work required to write a SCSI
 	peripheral driver.
 
 	It takes care of:
@@ -64,21 +63,21 @@
 // cookie issued by driver per file handle
 typedef struct periph_handle_info *periph_handle_cookie;
 
+typedef struct IOOperation io_operation;
 
 // callbacks to be provided by peripheral driver
 typedef struct scsi_periph_callbacks {
 	// *** block devices ***
 	// informs of new size of medium
 	// (set to NULL if not a block device)
-	void (*set_capacity)( periph_device_cookie periph_device, uint64 capacity,
-		uint32 block_size );
+	void (*set_capacity)(periph_device_cookie cookie, uint64 capacity,
+		uint32 blockSize);
 
 	// *** removable devices
 	// called when media got changed (can be NULL if medium is not changable)
 	// (you don't need to call periph-&gt;media_changed, but it's doesn't if you do)
 	// ccb - request at your disposal
-	void (*media_changed)( periph_device_cookie periph_device,
-		scsi_ccb *request );
+	void (*media_changed)(periph_device_cookie cookie, scsi_ccb *request);
 } scsi_periph_callbacks;
 
 
@@ -87,73 +86,61 @@
 	module_info info;
 
 	// *** init/cleanup ***
-	status_t (*register_device)(
-		periph_device_cookie periph_device,
-		scsi_periph_callbacks *callbacks,
-		scsi_device scsi_device,
-		scsi_device_interface *scsi,
-		device_node *node,
-		bool removable,
-		scsi_periph_device *driver );
-	status_t (*unregister_device)( scsi_periph_device driver );
+	// preferred_ccb_size - preferred command size; if zero, the shortest is used
+	status_t (*register_device)(periph_device_cookie cookie,
+		scsi_periph_callbacks *callbacks, scsi_device scsiDevice,
+		scsi_device_interface *scsi, device_node *node, bool removable,
+		int preferredCcbSize, scsi_periph_device *driver);
+	status_t (*unregister_device)(scsi_periph_device driver);
 
 	// *** basic command execution ***
 	// exec command, retrying on problems
-	status_t (*safe_exec)(
-		scsi_periph_device periph_device,
-		scsi_ccb *request );
+	status_t (*safe_exec)(scsi_periph_device periphCookie, scsi_ccb *request);
 	// exec simple command
-	status_t (*simple_exec)( scsi_periph_device device,
-		void *cdb, uchar cdb_len, void *data, size_t data_len,
-		int ccb_flags );
+	status_t (*simple_exec)(scsi_periph_device device, void *cdb,
+		uint8 cdbLength, void *data, size_t dataLength, int ccbFlags);
 
 	// *** file handling ***
 	// to be called when a new file is opened
-	status_t (*handle_open)( scsi_periph_device device,
-		periph_handle_cookie periph_handle, scsi_periph_handle *res_handle );
+	status_t (*handle_open)(scsi_periph_device device,
+		periph_handle_cookie periph_handle, scsi_periph_handle *_handle);
 	// to be called when a file is closed
-	status_t (*handle_close)( scsi_periph_handle handle );
+	status_t (*handle_close)(scsi_periph_handle handle);
 	// to be called when a file is freed
-	status_t (*handle_free)( scsi_periph_handle handle );
+	status_t (*handle_free)(scsi_periph_handle handle);
 
 	// *** default implementation for block devices ***
-	// block read
-	// preferred_ccb_size - preferred command size; if zero, the shortest is used
-	status_t (*read)( scsi_periph_handle handle, const phys_vecs *vecs,
-		off_t pos, size_t num_blocks, uint32 block_size, size_t *bytes_transferred,
-		int preferred_ccb_size );
-	// block write
-	// (see block_read)
-	status_t (*write)( scsi_periph_handle handle, const phys_vecs *vecs,
-		off_t pos, size_t num_blocks, uint32 block_size, size_t *bytes_transferred,
-		int preferred_ccb_size );
+	status_t (*io)(scsi_periph_device device, io_operation *operation,
+		size_t *_bytesTransferred);
+
 	// block ioctls
-	status_t (*ioctl)( scsi_periph_handle handle, int op, void *buf, size_t len );
+	status_t (*ioctl)(scsi_periph_handle handle, int op, void *buffer,
+		size_t length);
 	// check medium capacity (calls set_capacity callback on success)
 	// request - ccb for this device; is used to talk to device
-	status_t (*check_capacity)( scsi_periph_device device, scsi_ccb *request );
+	status_t (*check_capacity)(scsi_periph_device device, scsi_ccb *request);
 
 	// *** removable media ***
 	// to be called when a medium change is detected to block subsequent commands
-	void (*media_changed)( scsi_periph_device device );
+	void (*media_changed)(scsi_periph_device device);
 	// convert result of *request to err_res
-	err_res (*check_error)( scsi_periph_device device, scsi_ccb *request );
+	err_res (*check_error)(scsi_periph_device device, scsi_ccb *request);
 	// send start or stop command to device
-	// with_LoEj = true - include loading/ejecting,
-	//             false - only do allow/deny
-	err_res (*send_start_stop)( scsi_periph_device device, scsi_ccb *request,
-		bool start, bool with_LoEj );
+	// withLoadEject = true - include loading/ejecting,
+	//   false - only do allow/deny
+	err_res (*send_start_stop)(scsi_periph_device device, scsi_ccb *request,
+		bool start, bool withLoadEject);
 	// checks media status and waits for device to become ready
 	// returns: B_OK, B_DEV_MEDIA_CHANGE_REQUESTED, B_NO_MEMORY or
 	// pending error reported by handle_get_error
-	status_t (*get_media_status)( scsi_periph_handle handle );
+	status_t (*get_media_status)(scsi_periph_handle handle);
 
 	// compose device name consisting of prefix and path/target/LUN
 	// (result must be freed by caller)
 	char *(*compose_device_name)(device_node *device_node, const char *prefix);
 
 	// fill data with icon (for B_GET_ICON ioctl)
-	status_t (*get_icon)( icon_type type, device_icon *data );
+	status_t (*get_icon)(icon_type type, device_icon *data);
 
 	// synchronizes (flush) the device cache
 	err_res(*synchronize_cache)(scsi_periph_device device, scsi_ccb *request);
@@ -162,4 +149,3 @@
 #define SCSI_PERIPH_MODULE_NAME &quot;generic/scsi_periph/v1&quot;
 
 #endif	/* _SCSI_PERIPH_H */
-

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ata/ata_request.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ata/ata_request.c	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ata/ata_request.c	2008-08-05 21:11:51 UTC (rev 26828)
@@ -14,7 +14,7 @@
 }
 
 
-/* Start the request, but don't clear sense to allow 
+/* Start the request, but don't clear sense to allow
  * retrieving the previous sense data.
  */
 void ata_request_start(ata_request **_request, struct ide_device_info *device, struct scsi_ccb *ccb)
@@ -31,7 +31,7 @@
 
 		device-&gt;bus-&gt;state = ata_state_busy;
 		device-&gt;bus-&gt;active_device = device;
-	
+
 		request = device-&gt;requestFree;
 		device-&gt;requestActive = request;
 		device-&gt;requestFree = NULL;
@@ -77,7 +77,7 @@
 void
 ata_request_set_status(ata_request *request, uint8 status)
 {
-	ASSERT(status != SCSI_REQ_CMP);
+//	ASSERT(status != SCSI_REQ_CMP);
 	if (request &amp;&amp; request-&gt;ccb)
 		request-&gt;ccb-&gt;subsys_status = status;
 }
@@ -106,10 +106,10 @@
 			request, ccb-&gt;subsys_status, request-&gt;senseKey);
 
 	// when the request completed and has set sense
-    // data, report this to the scsci stack by setting 
+    // data, report this to the scsi stack by setting
     // CHECK CONDITION status
 	if (ccb-&gt;subsys_status == SCSI_REQ_CMP &amp;&amp; request-&gt;senseKey != 0) {
-	
+
 		TRACE(&quot;ata_request_finish - setting check condition\n&quot;);
 
 		request-&gt;ccb-&gt;subsys_status = SCSI_REQ_CMP_ERR;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/ccb.c	2008-08-05 21:11:51 UTC (rev 26828)
@@ -8,7 +8,7 @@
 
 	CCB manager
 
-	As allocation of ccb can be on the paging path we must use a 
+	As allocation of ccb can be on the paging path we must use a
 	locked pool.
 */
 
@@ -19,7 +19,7 @@
 // ccb are relatively large, so don't make it too small to not waste memory
 #define CCB_CHUNK_SIZE 16*1024
 
-// maximum number of CCBs - probably, we want to make that editable 
+// maximum number of CCBs - probably, we want to make that editable
 // it must be at least 1 for normal use and 1 for stand-by autosense request
 #define CCB_NUM_MAX 128
 
@@ -40,6 +40,7 @@
 	// reset some very important fields
 	// TODO: should we better omit that to find bugs easier?
 	ccb-&gt;sg_list = NULL;
+	ccb-&gt;io_operation = NULL;
 	ccb-&gt;sort = -1;
 
 	SHOW_FLOW(3, &quot;path=%d&quot;, ccb-&gt;path_id);

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/Jamfile	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/Jamfile	2008-08-05 21:11:51 UTC (rev 26828)
@@ -1,6 +1,7 @@
 SubDir HAIKU_TOP src add-ons kernel drivers disk scsi scsi_disk ;
 
 UsePrivateHeaders drivers kernel ;
+SubDirHdrs $(HAIKU_TOP) src system kernel device_manager ;
 
 KernelAddon scsi_disk :
 	scsi_disk.cpp

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.cpp	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.cpp	2008-08-05 21:11:51 UTC (rev 26828)
@@ -29,13 +29,12 @@
 #endif
 
 
-static scsi_periph_interface *sSCSIPeripheral;
-static device_manager_info *sDeviceManager;
-static block_io_for_driver_interface *sBlockIO;
+static scsi_periph_interface* sSCSIPeripheral;
+static device_manager_info* sDeviceManager;
 
 
 static status_t
-update_capacity(das_device_info *device)
+update_capacity(das_driver_info *device)
 {
 	TRACE(&quot;update_capacity()\n&quot;);
 
@@ -53,20 +52,20 @@
 
 
 static status_t
-get_geometry(das_handle_info *handle, device_geometry *geometry)
+get_geometry(das_handle* handle, device_geometry* geometry)
 {
-	das_device_info *device = handle-&gt;device;
+	das_driver_info* info = handle-&gt;info;
 
-	status_t status = update_capacity(device);
+	status_t status = update_capacity(info);
 	if (status &lt; B_OK)
 		return status;
 
-	geometry-&gt;bytes_per_sector = device-&gt;block_size;
+	geometry-&gt;bytes_per_sector = info-&gt;block_size;
 	geometry-&gt;sectors_per_track = 1;
-	geometry-&gt;cylinder_count = device-&gt;capacity;
+	geometry-&gt;cylinder_count = info-&gt;capacity;
 	geometry-&gt;head_count = 1;
 	geometry-&gt;device_type = B_DISK;
-	geometry-&gt;removable = device-&gt;removable;
+	geometry-&gt;removable = info-&gt;removable;
 
 	// TBD: for all but CD-ROMs, read mode sense - medium type
 	// (bit 7 of block device specific parameter for Optical Memory Block Device)
@@ -86,7 +85,7 @@
 
 
 static status_t
-load_eject(das_device_info *device, bool load)
+load_eject(das_driver_info *device, bool load)
 {
 	TRACE(&quot;load_eject()\n&quot;);
 
@@ -104,7 +103,7 @@
 
 
 static status_t
-synchronize_cache(das_device_info *device)
+synchronize_cache(das_driver_info *device)
 {
 	TRACE(&quot;synchronize_cache()\n&quot;);
 
@@ -135,36 +134,65 @@
 }
 
 
-//	#pragma mark - block_io API
+static status_t
+do_io(void* cookie, IOOperation* operation)
+{
+	das_driver_info* info = (das_driver_info*)cookie;
 
+	// TODO: this can go away as soon as we pushed the IOOperation to the upper
+	// layers - we can then set scsi_periph::io() as callback for the scheduler
+	size_t bytesTransferred;
+	status_t status = sSCSIPeripheral-&gt;io(info-&gt;scsi_periph_device, operation,
+		&amp;bytesTransferred);
 
-static void
-das_set_device(das_device_info *info, block_io_device device)
+	info-&gt;io_scheduler-&gt;OperationCompleted(operation, status, bytesTransferred);
+	return status;
+}
+
+
+//	#pragma mark - device module API
+
+
+static status_t
+das_init_device(void* _info, void** _cookie)
 {
-	info-&gt;block_io_device = device;
+	das_driver_info* info = (das_driver_info*)_info;
 
 	// and get (initial) capacity
 	scsi_ccb *request = info-&gt;scsi-&gt;alloc_ccb(info-&gt;scsi_device);
 	if (request == NULL)
-		return;
+		return B_NO_MEMORY;
 
 	sSCSIPeripheral-&gt;check_capacity(info-&gt;scsi_periph_device, request);
 	info-&gt;scsi-&gt;free_ccb(request);
+
+	*_cookie = info;
+	return B_OK;
 }
 
 
+static void
+das_uninit_device(void* _cookie)
+{
+	das_driver_info* info = (das_driver_info*)_cookie;
+
+	delete info-&gt;io_scheduler;
+	delete info-&gt;dma_resource;
+}
+
+
 static status_t
-das_open(das_device_info *device, das_handle_info **_cookie)
+das_open(void* _info, const char* path, int openMode, void** _cookie)
 {
-	TRACE(&quot;open()\n&quot;);
+	das_driver_info* info = (das_driver_info*)_info;
 
-	das_handle_info *handle = (das_handle_info *)malloc(sizeof(*handle));
+	das_handle* handle = (das_handle*)malloc(sizeof(das_handle));
 	if (handle == NULL)
 		return B_NO_MEMORY;
 
-	handle-&gt;device = device;
+	handle-&gt;info = info;
 
-	status_t status = sSCSIPeripheral-&gt;handle_open(device-&gt;scsi_periph_device,
+	status_t status = sSCSIPeripheral-&gt;handle_open(info-&gt;scsi_periph_device,
 		(periph_handle_cookie)handle, &amp;handle-&gt;scsi_periph_handle);
 	if (status &lt; B_OK) {
 		free(handle);
@@ -177,8 +205,9 @@
 
 
 static status_t
-das_close(das_handle_info *handle)
+das_close(void* cookie)
 {
+	das_handle* handle = (das_handle*)cookie;
 	TRACE(&quot;close()\n&quot;);
 
 	sSCSIPeripheral-&gt;handle_close(handle-&gt;scsi_periph_handle);
@@ -187,8 +216,9 @@
 
 
 static status_t
-das_free(das_handle_info *handle)
+das_free(void* cookie)
 {
+	das_handle* handle = (das_handle*)cookie;
 	TRACE(&quot;free()\n&quot;);
 
 	sSCSIPeripheral-&gt;handle_free(handle-&gt;scsi_periph_handle);
@@ -198,38 +228,80 @@
 
 
 static status_t
-das_read(das_handle_info *handle, const phys_vecs *vecs, off_t pos,
-	size_t num_blocks, uint32 block_size, size_t *bytes_transferred)
+das_read(void* cookie, off_t pos, void* buffer, size_t* _length)
 {
-	return sSCSIPeripheral-&gt;read(handle-&gt;scsi_periph_handle, vecs, pos,
-		num_blocks, block_size, bytes_transferred, 10);
+	das_handle* handle = (das_handle*)cookie;
+	size_t length = *_length;
+
+	IORequest request;
+	status_t status = request.Init(pos, buffer, length, false, 0);
+	if (status != B_OK)
+		return status;
+
+	status = handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(&amp;request);
+	if (status != B_OK)
+		return status;
+
+	status = request.Wait(0, 0);
+	if (status == B_OK)
+		*_length = length;
+	else
+		dprintf(&quot;das_read(): request.Wait() returned: %s\n&quot;, strerror(status));
+
+	return status;
 }
 
 
 static status_t
-das_write(das_handle_info *handle, const phys_vecs *vecs, off_t pos,
-	size_t num_blocks, uint32 block_size, size_t *bytes_transferred)
+das_write(void* cookie, off_t pos, const void* buffer, size_t* _length)
 {
-	return sSCSIPeripheral-&gt;write(handle-&gt;scsi_periph_handle, vecs, pos,
-		num_blocks, block_size, bytes_transferred, 10);
+	das_handle* handle = (das_handle*)cookie;
+	size_t length = *_length;
+
+	IORequest request;
+	status_t status = request.Init(pos, (void*)buffer, length, true, 0);
+	if (status != B_OK)
+		return status;
+
+	status = handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(&amp;request);
+	if (status != B_OK)
+		return status;
+
+	status = request.Wait(0, 0);
+	if (status == B_OK)
+		*_length = length;
+	else
+		dprintf(&quot;das_write(): request.Wait() returned: %s\n&quot;, strerror(status));
+
+	return status;
 }
 
 
 static status_t
-das_ioctl(das_handle_info *handle, int op, void *buffer, size_t length)
+das_io(void *cookie, io_request *request)
 {
-	das_device_info *device = handle-&gt;device;
+	das_handle* handle = (das_handle*)cookie;
 
+	return handle-&gt;info-&gt;io_scheduler-&gt;ScheduleRequest(request);
+}
+
+
+static status_t
+das_ioctl(void* cookie, uint32 op, void* buffer, size_t length)
+{
+	das_handle* handle = (das_handle*)cookie;
+	das_driver_info* info = handle-&gt;info;
+
 	TRACE(&quot;ioctl(op = %d)\n&quot;, op);
 
 	switch (op) {
 		case B_GET_DEVICE_SIZE:
 		{
-			status_t status = update_capacity(device);
+			status_t status = update_capacity(info);
 			if (status != B_OK)
 				return status;
 
-			size_t size = device-&gt;capacity * device-&gt;block_size;
+			size_t size = info-&gt;capacity * info-&gt;block_size;
 			return user_memcpy(buffer, &amp;size, sizeof(size_t));
 		}
 
@@ -242,23 +314,23 @@
 			status_t status = get_geometry(handle, &amp;geometry);
 			if (status != B_OK)
 				return status;
-			
+
 			return user_memcpy(buffer, &amp;geometry, sizeof(device_geometry));
 		}
 
 		case B_GET_ICON:
-			return sSCSIPeripheral-&gt;get_icon(device-&gt;removable
+			return sSCSIPeripheral-&gt;get_icon(info-&gt;removable
 				? icon_type_floppy : icon_type_disk, (device_icon *)buffer);
 
 		case B_EJECT_DEVICE:
 		case B_SCSI_EJECT:
-			return load_eject(device, false);
+			return load_eject(info, false);
 
 		case B_LOAD_MEDIA:
-			return load_eject(device, true);
+			return load_eject(info, true);
 
 		case B_FLUSH_DRIVE_CACHE:
-			return synchronize_cache(device);
+			return synchronize_cache(info);
 
 		default:
 			return sSCSIPeripheral-&gt;ioctl(handle-&gt;scsi_periph_handle, op,
@@ -271,7 +343,7 @@
 
 
 static void
-das_set_capacity(das_device_info *device, uint64 capacity, uint32 blockSize)
+das_set_capacity(das_driver_info* info, uint64 capacity, uint32 blockSize)
 {
 	TRACE(&quot;das_set_capacity(device = %p, capacity = %Ld, blockSize = %ld)\n&quot;,
 		device, capacity, blockSize);
@@ -282,19 +354,40 @@
 	if ((1UL &lt;&lt; blockShift) != blockSize)
 		blockShift = 0;
 
-	device-&gt;capacity = capacity;
-	device-&gt;block_size = blockSize;
+	info-&gt;capacity = capacity;
 
-	sBlockIO-&gt;set_media_params(device-&gt;block_io_device, blockSize,
-		blockShift, capacity);
+	if (info-&gt;block_size != blockSize) {
+		if (info-&gt;block_size != 0) {
+			dprintf(&quot;old %ld, new %ld\n&quot;, info-&gt;block_size, blockSize);
+			panic(&quot;updating DMAResource not yet implemented...&quot;);
+		}
+
+		// TODO: we need to replace the DMAResource in our IOScheduler
+		status_t status = info-&gt;dma_resource-&gt;Init(info-&gt;node, blockSize);
+		if (status != B_OK)
+			panic(&quot;initializing DMAResource failed: %s&quot;, strerror(status));
+
+		info-&gt;io_scheduler = new(std::nothrow) IOScheduler(info-&gt;dma_resource);
+		if (info-&gt;io_scheduler == NULL)
+			panic(&quot;allocating IOScheduler failed.&quot;);
+
+		// TODO: use whole device name here
+		status = info-&gt;io_scheduler-&gt;Init(&quot;scsi&quot;);
+		if (status != B_OK)
+			panic(&quot;initializing IOScheduler failed: %s&quot;, strerror(status));
+
+		info-&gt;io_scheduler-&gt;SetCallback(do_io, info);
+	}
+
+	info-&gt;block_size = blockSize;
 }
 
 
 static void
-das_media_changed(das_device_info *device, scsi_ccb *request)
+das_media_changed(das_driver_info *device, scsi_ccb *request)
 {
 	// do a capacity check
-	// TBD: is this a good idea (e.g. if this is an empty CD)?
+	// TODO: is this a good idea (e.g. if this is an empty CD)?
 	sSCSIPeripheral-&gt;check_capacity(device-&gt;scsi_periph_device, request);
 }
 
@@ -363,53 +456,54 @@
 		{&quot;removable&quot;, B_UINT8_TYPE, {ui8: deviceInquiry-&gt;removable_medium}},
 		// impose own max block restriction
 		{B_BLOCK_DEVICE_MAX_BLOCKS_ITEM, B_UINT32_TYPE, {ui32: maxBlocks}},
-		// in general, any disk can be a BIOS drive (even ZIP-disks)
-		{B_BLOCK_DEVICE_IS_BIOS_DRIVE, B_UINT8_TYPE, {ui8: 1}},
 		{ NULL }
 	};
 
-	return sDeviceManager-&gt;register_node(node, SCSI_DISK_MODULE_NAME, attrs,
-		NULL, NULL);
+	return sDeviceManager-&gt;register_node(node, SCSI_DISK_DRIVER_MODULE_NAME,
+		attrs, NULL, NULL);
 }
 
 
 static status_t
 das_init_driver(device_node *node, void **cookie)
 {
-	das_device_info *device;
-	status_t status;
-	uint8 removable;
-
 	TRACE(&quot;das_init_driver&quot;);
 
-	status = sDeviceManager-&gt;get_attr_uint8(node, &quot;removable&quot;,
+	uint8 removable;
+	status_t status = sDeviceManager-&gt;get_attr_uint8(node, &quot;removable&quot;,
 		&amp;removable, false);
 	if (status != B_OK)
 		return status;
 
-	device = (das_device_info *)malloc(sizeof(*device));
-	if (device == NULL)
+	das_driver_info* info = (das_driver_info*)malloc(sizeof(das_driver_info));
+	if (info == NULL)
 		return B_NO_MEMORY;
 
-	memset(device, 0, sizeof(*device));
+	memset(info, 0, sizeof(*info));
 
-	device-&gt;node = node;
-	device-&gt;removable = removable;
+	info-&gt;dma_resource = new(std::nothrow) DMAResource;
+	if (info-&gt;dma_resource == NULL) {
+		free(info);
+		return B_NO_MEMORY;
+	}
 
-	device_node *parent = sDeviceManager-&gt;get_parent_node(node);
-	sDeviceManager-&gt;get_driver(parent, (driver_module_info **)&amp;device-&gt;scsi,
-		(void **)&amp;device-&gt;scsi_device);
+	info-&gt;node = node;
+	info-&gt;removable = removable;
+
+	device_node* parent = sDeviceManager-&gt;get_parent_node(node);
+	sDeviceManager-&gt;get_driver(parent, (driver_module_info **)&amp;info-&gt;scsi,
+		(void **)&amp;info-&gt;scsi_device);
 	sDeviceManager-&gt;put_node(parent);
 
-	status = sSCSIPeripheral-&gt;register_device((periph_device_cookie)device,
-		&amp;callbacks, device-&gt;scsi_device, device-&gt;scsi, device-&gt;node,
-		device-&gt;removable, &amp;device-&gt;scsi_periph_device);
+	status = sSCSIPeripheral-&gt;register_device((periph_device_cookie)info,
+		&amp;callbacks, info-&gt;scsi_device, info-&gt;scsi, info-&gt;node,
+		info-&gt;removable, 10, &amp;info-&gt;scsi_periph_device);
 	if (status != B_OK) {
-		free(device);
+		free(info);
 		return status;
 	}
 
-	*cookie = device;
+	*cookie = info;
 	return B_OK;
 }
 
@@ -417,26 +511,26 @@
 static void
 das_uninit_driver(void *_cookie)
 {
-	das_device_info *device = (das_device_info *)_cookie;
+	das_driver_info* info = (das_driver_info*)_cookie;
 
-	sSCSIPeripheral-&gt;unregister_device(device-&gt;scsi_periph_device);
-	free(device);
+	sSCSIPeripheral-&gt;unregister_device(info-&gt;scsi_periph_device);
+	free(info);
 }
 
 
 static status_t
-das_register_child_devices(void *_cookie)
+das_register_child_devices(void* _cookie)
 {
-	das_device_info *device = (das_device_info *)_cookie;
+	das_driver_info* info = (das_driver_info*)_cookie;
 	status_t status;
-	char *name;
 
-	name = sSCSIPeripheral-&gt;compose_device_name(device-&gt;node, &quot;disk/scsi&quot;);
+	char* name = sSCSIPeripheral-&gt;compose_device_name(info-&gt;node,
+		&quot;disk/scsi&quot;);
 	if (name == NULL)
 		return B_ERROR;
 
-	status = sDeviceManager-&gt;publish_device(device-&gt;node, name,
-		B_BLOCK_IO_DEVICE_MODULE_NAME);
+	status = sDeviceManager-&gt;publish_device(info-&gt;node, name,
+		SCSI_DISK_DEVICE_MODULE_NAME);
 
 	free(name);
 	return status;
@@ -444,43 +538,52 @@
 
 
 module_dependency module_dependencies[] = {
-	{SCSI_PERIPH_MODULE_NAME, (module_info **)&amp;sSCSIPeripheral},
-	{B_BLOCK_IO_FOR_DRIVER_MODULE_NAME, (module_info **)&amp;sBlockIO},
-	{B_DEVICE_MANAGER_MODULE_NAME, (module_info **)&amp;sDeviceManager},
+	{SCSI_PERIPH_MODULE_NAME, (module_info**)&amp;sSCSIPeripheral},
+	{B_DEVICE_MANAGER_MODULE_NAME, (module_info**)&amp;sDeviceManager},
 	{}
 };
 
-block_device_interface sSCSIDiskModule = {
+struct device_module_info sSCSIDiskDevice = {
 	{
-		{
-			SCSI_DISK_MODULE_NAME,
-			0,
-			NULL
-		},
-
-		das_supports_device,
-		das_register_device,
-		das_init_driver,
-		das_uninit_driver,
-		das_register_child_devices,
-		NULL,	// rescan
-		NULL,	// removed
+		SCSI_DISK_DEVICE_MODULE_NAME,
+		0,
+		NULL
 	},
 
-	(void (*)(block_device_cookie *, block_io_device))	&amp;das_set_device,
-	(status_t (*)(block_device_cookie *, block_device_handle_cookie **))&amp;das_open,
-	(status_t (*)(block_device_handle_cookie *))		&amp;das_close,
-	(status_t (*)(block_device_handle_cookie *))		&amp;das_free,
+	das_init_device,
+	das_uninit_device,
+	NULL, //das_remove,
 
-	(status_t (*)(block_device_handle_cookie *, const phys_vecs *,
-		off_t, size_t, uint32, size_t *))				&amp;das_read,
-	(status_t (*)(block_device_handle_cookie *, const phys_vecs *,
-		off_t, size_t, uint32, size_t *))				&amp;das_write,
+	das_open,
+	das_close,
+	das_free,
+	das_read,
+	das_write,
+	das_io,
+	das_ioctl,
 
-	(status_t (*)(block_device_handle_cookie *, int, void *, size_t))&amp;das_ioctl,
+	NULL,	// select
+	NULL,	// deselect
 };
 
-module_info *modules[] = {
-	(module_info *)&amp;sSCSIDiskModule,
+struct driver_module_info sSCSIDiskDriver = {
+	{
+		SCSI_DISK_DRIVER_MODULE_NAME,
+		0,
+		NULL
+	},
+
+	das_supports_device,
+	das_register_device,
+	das_init_driver,
+	das_uninit_driver,
+	das_register_child_devices,
+	NULL,	// rescan
+	NULL,	// removed
+};
+
+module_info* modules[] = {
+	(module_info*)&amp;sSCSIDiskDriver,
+	(module_info*)&amp;sSCSIDiskDevice,
 	NULL
 };

Modified: haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_disk/scsi_disk.h	2008-08-05 21:11:51 UTC (rev 26828)
@@ -12,27 +12,32 @@
 #include &lt;scsi.h&gt;
 #include &lt;scsi_periph.h&gt;
 
+#include &quot;dma_resources.h&quot;
+#include &quot;io_requests.h&quot;
+#include &quot;IOScheduler.h&quot;
 
-#define SCSI_DISK_MODULE_NAME &quot;drivers/disk/scsi/scsi_dsk/driver_v1&quot;
 
+#define SCSI_DISK_DRIVER_MODULE_NAME &quot;drivers/disk/scsi/scsi_disk/driver_v1&quot;
+#define SCSI_DISK_DEVICE_MODULE_NAME &quot;drivers/disk/scsi/scsi_disk/device_v1&quot;
 
-// must start as block_device_cookie
-typedef struct das_device_info {
-	device_node *node;
-	::scsi_periph_device scsi_periph_device;
-	::scsi_device scsi_device;
-	scsi_device_interface *scsi;
-	::block_io_device block_io_device;
 
-	uint64 capacity;
-	uint32 block_size;
+struct das_driver_info {
+	device_node*			node;
+	::scsi_periph_device	scsi_periph_device;
+	::scsi_device			scsi_device;
+	scsi_device_interface*	scsi;
+	IOScheduler*			io_scheduler;
+	DMAResource*			dma_resource;
 
-	bool removable;			// true, if device is removable
-} das_device_info;
+	uint64					capacity;
+	uint32					block_size;
 
-typedef struct das_handle_info {
-	::scsi_periph_handle scsi_periph_handle;
-	das_device_info *device;
-} das_handle_info;
+	bool					removable;
+};
 
+struct das_handle {
+	::scsi_periph_handle	scsi_periph_handle;
+	das_driver_info*		info;
+};
+
 #endif	/* _SCSI_DISK_H */

Modified: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/generic/scsi_periph/Jamfile	2008-08-05 21:09:12 UTC (rev 26827)
+++ haiku/trunk/src/add-ons/kernel/generic/scsi_periph/Jamfile	2008-08-05 21:11:51 UTC (rev 26828)
@@ -1,6 +1,7 @@
 SubDir HAIKU_TOP src add-ons kernel generic scsi_periph ;
 
 UsePrivateHeaders drivers kernel ;
+SubDirHdrs $(HAIKU_TOP) src system kernel device_manager ;
 
 # disable debug output, if debugging is disabled
 if $(DEBUG) = 0 {
@@ -8,13 +9,13 @@
 }
 
 KernelAddon scsi_periph :
-	block.c
-	device_icons.c
-	device.c
-	error_handling.c
-	handle.c
-	io.c
-	removable.c
-	scsi_periph.c
-	sync.c
+	block.cpp
+	device_icons.cpp
+	device.cpp
+	error_handling.cpp
+	handle.cpp
+	io.cpp
+	removable.cpp
+	scsi_periph.cpp
+	sync.cpp
 	;

Deleted: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.c

Copied: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.cpp (from rev 26819, haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.c)
===================================================================
--- haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.c	2008-08-05 17:19:46 UTC (rev 26819)
+++ haiku/trunk/src/add-ons/kernel/generic/scsi_periph/block.cpp	2008-08-05 21:11:51 UTC (rev 26828)
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2004-2008, Haiku, Inc. All RightsReserved.
+ * Copyright 2002-2003, Thomas Kurschel. All rights reserved.
+ *
+ * Distributed under the terms of the MIT License.
+ */
+
+//!	Handling of block device (currently, only a capacity check is provided)
+
+
+#include &quot;scsi_periph_int.h&quot;
+#include &lt;string.h&gt;
+
+
+status_t
+periph_check_capacity(scsi_periph_device_info *device, scsi_ccb *request)
+{
+	scsi_res_read_capacity capacityResult;
+	scsi_cmd_read_capacity *cmd = (scsi_cmd_read_capacity *)request-&gt;cdb;
+	uint64 capacity;
+	uint32 blockSize;
+	status_t res;
+
+	SHOW_FLOW(3, &quot;%p, %p&quot;, device, request);
+
+	// driver doesn't support capacity callback - seems to be no block
+	// device driver, so ignore
+	if (device-&gt;callbacks-&gt;set_capacity == NULL)
+		return B_OK;
+
+	request-&gt;flags = SCSI_DIR_IN;
+
+	request-&gt;data = (uint8*)&capacityResult;
+	request-&gt;data_length = sizeof(capacityResult);
+	request-&gt;cdb_length = sizeof(scsi_cmd_read_capacity);
+	request-&gt;timeout = device-&gt;std_timeout;
+	request-&gt;sort = -1;
+	request-&gt;sg_list = NULL;
+
+	memset(cmd, 0, sizeof(*cmd));
+	cmd-&gt;opcode = SCSI_OP_READ_CAPACITY;
+	// we don't set PMI (partial medium indicator) as we want the whole capacity;
+	// in this case, all other parameters must be zero
+
+	res = periph_safe_exec(device, request);
+
+	if (res == B_DEV_MEDIA_CHANGED) {
+		// in this case, the error handler has already called check_capacity
+		// recursively, so we ignore our (invalid) result
+		SHOW_FLOW0( 3, &quot;ignore result because medium change&quot; );
+		return B_DEV_MEDIA_CHANGED;
+	}
+
+	ACQUIRE_BEN(&amp;device-&gt;mutex);
+
+	if (res == B_OK &amp;&amp; request-&gt;data_resid == 0) {
+		capacity = B_BENDIAN_TO_HOST_INT32(capacityResult.lba);
+
+		// the command returns the index of the _last_ block,
+		// i.e. the size is one larger
+		++capacity;
+
+		blockSize = B_BENDIAN_TO_HOST_INT32(capacityResult.block_size);
+	} else {
+		capacity = 0;
+		blockSize = 0;
+	}
+
+	SHOW_FLOW(3, &quot;capacity = %Ld, block_size = %ld&quot;, capacity, blockSize);
+
+	device-&gt;block_size = blockSize;
+
+	device-&gt;callbacks-&gt;set_capacity(device-&gt;periph_device,
+		capacity, blockSize);
+
+/*	device-&gt;byte2blk_shift = log2( device-&gt;block_size );
+	if( device-&gt;byte2blk_shift &lt; 0 ) {
+		// this may be too restrictive...
+		device-&gt;capacity = -1;
+		return ERR_DEV_GENERAL;
+	}*/
+
+	RELEASE_BEN(&amp;device-&gt;mutex);
+
+	SHOW_FLOW(3, &quot;done (%s)&quot;, strerror(res));
+
+	return res;
+}
+

Deleted: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.c

Copied: haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.cpp (from rev 26819, haiku/trunk/src/add-ons/kernel/generic/scsi_periph/device.c)
===================================================================

[... truncated: 1093 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="010848.html">[Haiku-commits] r26827 -	haiku/trunk/src/add-ons/media/plugins/raw_decoder
</A></li>
	<LI>Next message: <A HREF="010850.html">[Haiku-commits] r26829 -	haiku/trunk/src/add-ons/kernel/drivers/disk/scsi/scsi_cd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#10849">[ date ]</a>
              <a href="thread.html#10849">[ thread ]</a>
              <a href="subject.html#10849">[ subject ]</a>
              <a href="author.html#10849">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
