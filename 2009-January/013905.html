<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28915 - in haiku/trunk: headers/os/bluetooth	src/servers/bluetooth
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28915%20-%20in%20haiku/trunk%3A%20headers/os/bluetooth%0A%09src/servers/bluetooth&In-Reply-To=%3C200901162032.n0GKWKob025286%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013904.html">
   <LINK REL="Next"  HREF="013906.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28915 - in haiku/trunk: headers/os/bluetooth	src/servers/bluetooth</H1>
    <B>oruizdorantes at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28915%20-%20in%20haiku/trunk%3A%20headers/os/bluetooth%0A%09src/servers/bluetooth&In-Reply-To=%3C200901162032.n0GKWKob025286%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28915 - in haiku/trunk: headers/os/bluetooth	src/servers/bluetooth">oruizdorantes at mail.berlios.de
       </A><BR>
    <I>Fri Jan 16 21:32:20 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="013904.html">[Haiku-commits] r28914 -	haiku/trunk/src/add-ons/kernel/drivers/audio/hda
</A></li>
        <LI>Next message: <A HREF="013906.html">[Haiku-commits] r28915 - in haiku/trunk: headers/os/bluetooth src/servers/bluetooth
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13905">[ date ]</a>
              <a href="thread.html#13905">[ thread ]</a>
              <a href="subject.html#13905">[ subject ]</a>
              <a href="author.html#13905">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: oruizdorantes
Date: 2009-01-16 21:32:19 +0100 (Fri, 16 Jan 2009)
New Revision: 28915
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28915&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28915&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/bluetooth/LinkKeyUtils.h
   haiku/trunk/headers/os/bluetooth/bdaddrUtils.h
   haiku/trunk/headers/os/bluetooth/bluetooth_util.h
   haiku/trunk/src/servers/bluetooth/BluetoothServer.cpp
   haiku/trunk/src/servers/bluetooth/HCIDelegate.h
   haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp
   haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp
   haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.h
Log:
some cleanups and styling by Mika and me

Modified: haiku/trunk/headers/os/bluetooth/LinkKeyUtils.h
===================================================================
--- haiku/trunk/headers/os/bluetooth/LinkKeyUtils.h	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/headers/os/bluetooth/LinkKeyUtils.h	2009-01-16 20:32:19 UTC (rev 28915)
@@ -30,10 +30,10 @@
 		static char str[50];
 
 		sprintf(str, &quot;%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:&quot;
-			&quot;%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X&quot;, 
-			lk.l[0], lk.l[1], lk.l[2], lk.l[3], lk.l[4], lk.l[5],
-			lk.l[6], lk.l[7], lk.l[8], lk.l[9], lk.l[10], lk.l[11],
-			lk.l[12], lk.l[13], lk.l[14], lk.l[15]);
+				&quot;%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X&quot;, 
+				lk.l[0], lk.l[1], lk.l[2], lk.l[3], lk.l[4], lk.l[5],
+				lk.l[6], lk.l[7], lk.l[8], lk.l[9], lk.l[10], lk.l[11],
+				lk.l[12], lk.l[13], lk.l[14], lk.l[15]);
 
 		return str;
 	}
@@ -43,9 +43,9 @@
 		if (lkstr != NULL) {
 			int l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15;
 			size_t count = sscanf(lkstr, &quot;%2X:%2X:%2X:%2X:%2X:%2X:%2X:%2X:&quot;
-								&quot;%2X:%2X:%2X:%2X:%2X:%2X:%2X:%2X&quot;, &amp;l0, &amp;l1, &amp;l2, &amp;l3, 
-								&amp;l4, &amp;l5, &amp;l6, &amp;l7, &amp;l8, &amp;l9, &amp;l10, &amp;l11, &amp;l12, &amp;l13,
-								 &amp;l14, &amp;l15);
+							&quot;%2X:%2X:%2X:%2X:%2X:%2X:%2X:%2X&quot;, &amp;l0, &amp;l1, &amp;l2, &amp;l3, 
+							&amp;l4, &amp;l5, &amp;l6, &amp;l7, &amp;l8, &amp;l9, &amp;l10, &amp;l11, &amp;l12, &amp;l13,
+							&amp;l14, &amp;l15);
 
 			if (count == 16) {
 				return (linkkey_t){{l0, l1, l2, l3, l4, l5, l6, l7, l8,

Modified: haiku/trunk/headers/os/bluetooth/bdaddrUtils.h
===================================================================
--- haiku/trunk/headers/os/bluetooth/bdaddrUtils.h	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/headers/os/bluetooth/bdaddrUtils.h	2009-01-16 20:32:19 UTC (rev 28915)
@@ -58,7 +58,7 @@
 
 		if (addr != NULL) {
 			size_t count = sscanf(addr, &quot;%2X:%2X:%2X:%2X:%2X:%2X&quot;,
-									&amp;b0, &amp;b1, &amp;b2, &amp;b3, &amp;b4, &amp;b5);
+						&amp;b0, &amp;b1, &amp;b2, &amp;b3, &amp;b4, &amp;b5);
 
 			if (count == 6)
 				return ((bdaddr_t) {{b0, b1, b2, b3, b4, b5}});

Modified: haiku/trunk/headers/os/bluetooth/bluetooth_util.h
===================================================================
--- haiku/trunk/headers/os/bluetooth/bluetooth_util.h	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/headers/os/bluetooth/bluetooth_util.h	2009-01-16 20:32:19 UTC (rev 28915)
@@ -21,31 +21,17 @@
 }
 
 
-static inline void baswap(bdaddr_t* dst, bdaddr_t* src) {
-
-}
-
-
-static inline char*	batostr(bdaddr_t *ba)
+static inline void baswap(bdaddr_t* dst, bdaddr_t* src)
 {
-	return &quot;00:00:00:00:00:00&quot;;
+  register uint8* d = (uint8*)dst;
+  register uint8* s = (uint8*)src;
+  register int i;
 
-}
+  for(i=0; i&lt;6; i++) d[i] = s[5-i];
 
-
-static inline void strtoba(const char *str, bdaddr_t *ba)
-{
-
 }
 
 
-/* Link key Management */
-static inline char* lktostr( uint8 link_key[16] )
-{
-	return &quot;00:00:00:00:00:00&quot;;
-}
-
-
 /* TODO: Bluetooth Errors */
 static inline char*	btstrerror(int error_code)
 {

Modified: haiku/trunk/src/servers/bluetooth/BluetoothServer.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/BluetoothServer.cpp	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/src/servers/bluetooth/BluetoothServer.cpp	2009-01-16 20:32:19 UTC (rev 28915)
@@ -1,6 +1,6 @@
 /*
- * Copyright 2007 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
+ * Copyright 2007-2009 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ * Copyright 2008 Mika Lindqvist, monni1995_at_gmail.com
  * All rights reserved. Distributed under the terms of the MIT License.
  *
  */
@@ -9,15 +9,13 @@
 #include &lt;fcntl.h&gt;
 #include &lt;unistd.h&gt;
 
-
 #include &lt;Entry.h&gt;
-#include &lt;Path.h&gt;
-#include &lt;Message.h&gt;
 #include &lt;Directory.h&gt;
-#include &lt;String.h&gt;
+#include &lt;Message.h&gt;
+#include &lt;Path.h&gt;
 #include &lt;Roster.h&gt;
+#include &lt;String.h&gt;
 
-
 #include &lt;TypeConstants.h&gt;
 #include &lt;syslog.h&gt;
 
@@ -31,7 +29,7 @@
 
 
 BluetoothServer::BluetoothServer() : BApplication(BLUETOOTH_SIGNATURE)
-{ 
+{
 	Output::Instance()-&gt;Run();
 	Output::Instance()-&gt;SetTitle(&quot;Bluetooth message gathering&quot;);
 
@@ -40,16 +38,15 @@
 	Output::Instance()-&gt;AddTab(&quot;Events&quot;, BLACKBOARD_EVENTS);
 	Output::Instance()-&gt;AddTab(&quot;Kit&quot;, BLACKBOARD_KIT);
 
-	
 	ShowWindow(Output::Instance());
 
-    fDeviceManager = new DeviceManager();
+	fDeviceManager = new DeviceManager();
 	fLocalDevicesList.MakeEmpty();
 
 	// TODO: Some events should be handled faster than in KL...
-	fEventListener = spawn_thread(notification_Thread, &quot;BT port listener&quot; , B_URGENT_DISPLAY_PRIORITY , this);
+	fEventListener = spawn_thread(notification_Thread, &quot;BT port listener&quot; ,
+					B_URGENT_DISPLAY_PRIORITY , this);
 
-   
 }
 
 bool BluetoothServer::QuitRequested(void)
@@ -58,128 +55,114 @@
 	Output::Instance()-&gt;Lock();
 	Output::Instance()-&gt;Quit();
 
-
-/*	HCIDelegate *hd = NULL;
-	while ((hd = (HCIDelegate *)fDelegatesList.RemoveItem((int32)0)) !=NULL)
-		delete hd;
-*/
-
+	LocalDeviceImpl* ldi = NULL;
+	while ((ldi = (LocalDeviceImpl *)fLocalDevicesList.RemoveItem((int32)0))
+		!= NULL)
+		delete ldi;
+ 
 	printf(&quot;Accepting quitting of the application\n&quot;);
 	return BApplication::QuitRequested();
 }
 
+
 void BluetoothServer::ArgvReceived(int32 argc, char **argv)
 {
 	if (argc&gt;1) {
 		if (strcmp(argv[1], &quot;--finish&quot;) == 0)
 			PostMessage(B_QUIT_REQUESTED);
-
-	    else {
-
-	
-	    }
 	}
 
 }
 
 
-void BluetoothServer::ReadyToRun(void) {
-    
-    fDeviceManager-&gt;StartMonitoringDevice(&quot;bluetooth/h2generic&quot;);
-	
-		
+void BluetoothServer::ReadyToRun(void)
+{
+	fDeviceManager-&gt;StartMonitoringDevice(&quot;bluetooth/h2generic&quot;);
 	// Launch the notifier thread
 	if ( resume_thread(fEventListener) != B_OK ) 
 	{
 		Output::Instance()-&gt;Post(&quot;Bluetooth port listener failed\n&quot;, BLACKBOARD_GENERAL);
 	}
-    
-    Output::Instance()-&gt;Post(&quot;Bluetooth server Ready\n&quot;, BLACKBOARD_GENERAL);
+
+	Output::Instance()-&gt;Post(&quot;Bluetooth server Ready\n&quot;, BLACKBOARD_GENERAL);
 }
 
-void BluetoothServer::AppActivated(bool act) {
 
+void BluetoothServer::AppActivated(bool act)
+{
 	printf(&quot;Activated %d\n&quot;,act);
-
 }
 
 
-
 void BluetoothServer::MessageReceived(BMessage *message)
 {
 	BMessage reply;
-	status_t status = B_WOULD_BLOCK; // mark somehow.. do not reply anything
+	status_t status = B_WOULD_BLOCK;
+		// mark somehow.. do not reply anything
 	
 	switch(message-&gt;what)
 	{
-	
 		case BT_MSG_ADD_DEVICE:
 		{
 			BString str;
-	        message-&gt;FindString(&quot;name&quot;, &amp;str);        
+			message-&gt;FindString(&quot;name&quot;, &amp;str);
 			BPath path(str.String());
+			Output::Instance()-&gt;Postf(BLACKBOARD_GENERAL,
+							&quot;Requested LocalDevice %s\n&quot;, str.String());
+			LocalDeviceImpl* ldi = LocalDeviceImpl::CreateTransportAccessor(&amp;path);
 
-     	   (Output::Instance()-&gt;Postf(BLACKBOARD_GENERAL, &quot;Requested LocalDevice %s\n&quot;, str.String()));
-	        
-	        LocalDeviceImpl* ldi = LocalDeviceImpl::CreateTransportAccessor(&amp;path);
+			if (ldi-&gt;GetID() &gt;= 0) {
+				fLocalDevicesList.AddItem(ldi);
+				Output::Instance()-&gt;AddTab(&quot;Local Device&quot;, BLACKBOARD_LD(ldi-&gt;GetID()));
+				Output::Instance()-&gt;Postf(BLACKBOARD_LD(ldi-&gt;GetID()),
+						&quot;LocalDevice %s id=%x added\n&quot;,
+						str.String(), ldi-&gt;GetID());
+			} else {
+				Output::Instance()-&gt;Post(&quot;Adding LocalDevice failed\n&quot;,
+								 BLACKBOARD_GENERAL);
+			}
 
-	        if (ldi-&gt;GetID() &gt;= 0) {
-                      fLocalDevicesList.AddItem(ldi);
-					  Output::Instance()-&gt;AddTab(&quot;Local Device&quot;, BLACKBOARD_LD(ldi-&gt;GetID()));
-					  (Output::Instance()-&gt;Postf(BLACKBOARD_LD(ldi-&gt;GetID()), &quot;LocalDevice %s id=%x added\n&quot;, str.String(), ldi-&gt;GetID()));
-			 
-
-            } else {
-					  (Output::Instance()-&gt;Post(&quot;Adding LocalDevice failed\n&quot;, BLACKBOARD_GENERAL));
-            }
-            
-            status = B_WOULD_BLOCK;
-            
-            /* TODO: This should be by user request only! */
-            ldi-&gt;Launch();
-        }   
-			
+			status = B_WOULD_BLOCK;
+			/* TODO: This should be by user request only! */
+			ldi-&gt;Launch();
+		}
+		break;	
 		case BT_MSG_COUNT_LOCAL_DEVICES: 
 			status = HandleLocalDevicesCount(message, &amp;reply);
-    	break;	
-    	
+		break;
 		case BT_MSG_ACQUIRE_LOCAL_DEVICE:
 			status = HandleAcquireLocalDevice(message, &amp;reply);
 		break;
 
-        case BT_MSG_HANDLE_SIMPLE_REQUEST:
-            status = HandleSimpleRequest(message, &amp;reply);
-        break;
-
-
+		case BT_MSG_HANDLE_SIMPLE_REQUEST:
+			status = HandleSimpleRequest(message, &amp;reply);
+		break;
 		/* Handle if the bluetooth preferences is running?? */
 		case B_SOME_APP_LAUNCHED:
    		{
 			const char *signature;
 			// TODO: what's this for?
-			if (message-&gt;FindString(&quot;be:signature&quot;, &amp;signature)==B_OK) {
+			if (message-&gt;FindString(&quot;be:signature&quot;, &amp;signature) == B_OK) {
 				printf(&quot;input_server : %s\n&quot;, signature);
-				if (strcmp(signature, &quot;application/x-vnd.Be-TSKB&quot;)==0) {
+				if (strcmp(signature, &quot;application/x-vnd.Be-TSKB&quot;) == 0) {
 
 				}
 			}
 			return;
 		}
-		
 
 		default:
 			BApplication::MessageReceived(message);
 		break;
 	}
 	
-	// Can we reply right now? 
+	// Can we reply right now?
 	// TOD: review this condition
-    if (status != B_WOULD_BLOCK) {
-	    reply.AddInt32(&quot;status&quot;, status);
-	    message-&gt;SendReply(&amp;reply);
-	    printf(&quot;Sending reply message\n&quot;); 
+	if (status != B_WOULD_BLOCK) {
+		reply.AddInt32(&quot;status&quot;, status);
+		message-&gt;SendReply(&amp;reply);
+		printf(&quot;Sending reply message\n&quot;);
 	}
-
 }
 
 #if 0
@@ -189,42 +172,36 @@
 LocalDeviceImpl* 
 BluetoothServer::LocateDelegateFromMessage(BMessage* message)
 {
-    LocalDeviceImpl* ldi = NULL;
- 	hci_id hid;
-    
-    if (message-&gt;FindInt32(&quot;hci_id&quot;, &amp;hid) == B_OK)	    
-	{
-	    /* Try to find out when a ID was specified */
-	    int index;
-	    
-	    for (index = 0; index &lt; fLocalDevicesList.CountItems() ; index ++) {
+	LocalDeviceImpl* ldi = NULL;
+	hci_id hid;
 
+	if (message-&gt;FindInt32(&quot;hci_id&quot;, &amp;hid) == B_OK) {
+		/* Try to find out when a ID was specified */
+		int index;
+		for (index = 0; index &lt; fLocalDevicesList.CountItems(); index ++) {
 		    ldi = fLocalDevicesList.ItemAt(index);
-		    if (ldi-&gt;GetID() == hid)  {            
+		    if (ldi-&gt;GetID() == hid)
 		        break;
-		    }		    
-        }
-    }
-        	
-    return ldi;
+		}
+	}
+
+	return ldi;
+
 }
 
 LocalDeviceImpl*
 BluetoothServer::LocateLocalDeviceImpl(hci_id hid) 
 {
+	/* Try to find out when a ID was specified */
+	int index;
 
-    /* Try to find out when a ID was specified */
-    int index;
-    
-    for (index = 0; index &lt; fLocalDevicesList.CountItems() ; index ++) {
+	for (index = 0; index &lt; fLocalDevicesList.CountItems(); index ++) {
+		LocalDeviceImpl* ldi = fLocalDevicesList.ItemAt(index);
+		if (ldi-&gt;GetID() == hid) 
+			return ldi;
+	}
 
-	    LocalDeviceImpl* ldi = fLocalDevicesList.ItemAt(index);
-	    if (ldi-&gt;GetID() == hid)  {
-	        return ldi;
-	    }		    
-    }
-    
-    return NULL;
+	return NULL;
 }
 
 
@@ -246,79 +223,72 @@
 	ssize_t size;
 	bdaddr_t bdaddr;
 	LocalDeviceImpl* ldi = NULL;
-    int32 index = 0;
+	int32 index = 0;
 	
-	if (message-&gt;FindInt32(&quot;hci_id&quot;, &amp;hid) == B_OK)	    
+	if (message-&gt;FindInt32(&quot;hci_id&quot;, &amp;hid) == B_OK)
 	{
-	    Output::Instance()-&gt;Post(&quot;GetLocalDevice requested with id\n&quot;, BLACKBOARD_KIT);
-        ldi = LocateDelegateFromMessage(message);						
-		
-	} else if (message-&gt;FindData(&quot;bdaddr&quot;, B_ANY_TYPE, (const void**)&amp;bdaddr, &amp;size ) == B_OK)
-	{
-	    /* Try to find out when the user specified the address */
-	    Output::Instance()-&gt;Post(&quot;GetLocalDevice requested with bdaddr\n&quot;, BLACKBOARD_KIT);	    
-	    for (index = 0; index &lt; fLocalDevicesList.CountItems() ; index ++) {	        
-	        
-	        bdaddr_t local;
-		    ldi = fLocalDevicesList.ItemAt(index);
-		    // TODO: Only if the property is available
-		    //if ((ldi-&gt;GetAddress(&amp;local, message) == B_OK) &amp;&amp; bacmp(&amp;local, &amp;bdaddr))  {
-		    //    break;
-		    //}		    		    
-        }		    
-	    
-	} else
-	{
-	    /* Careless, any device not performing operations will be fine */	    	    
-	    Output::Instance()-&gt;Post(&quot;GetLocalDevice requested\n&quot;, BLACKBOARD_KIT);	    
-	    for (index = 0; index &lt; fLocalDevicesList.CountItems() ; index ++) {
-	        
-		    ldi = fLocalDevicesList.ItemAt(index);
-		    printf(&quot;Requesting local device %ld\n&quot;, ldi-&gt;GetID());
-		    if (ldi != NULL &amp;&amp; ldi-&gt;Available())
-		    {
-  			    printf(&quot;dev ours %ld\n&quot;, ldi-&gt;GetID());
-		        break;
-		    }
-		    
-        }	
-	}
+		Output::Instance()-&gt;Post(&quot;GetLocalDevice requested with id\n&quot;, 
+						BLACKBOARD_KIT);
+		ldi = LocateDelegateFromMessage(message);
 
-    if (index &lt;= fLocalDevicesList.CountItems() &amp;&amp; ldi != NULL &amp;&amp; ldi-&gt;Available())
-	{
-	    Output::Instance()-&gt;Post(&quot;Device acquired\n&quot;, BLACKBOARD_KIT);
-	    ldi-&gt;Acquire();
-	    return reply-&gt;AddInt32(&quot;hci_id&quot;, hid);
-	}
+	} else if (message-&gt;FindData(&quot;bdaddr&quot;, B_ANY_TYPE, (const void**)&amp;bdaddr, &amp;size ) 
+			== B_OK) {
+		/* Try to find out when the user specified the address */
+		Output::Instance()-&gt;Post(&quot;GetLocalDevice requested with bdaddr\n&quot;, 
+						BLACKBOARD_KIT);
+		for (index = 0; index &lt; fLocalDevicesList.CountItems(); index ++) {
+			bdaddr_t local;
+			ldi = fLocalDevicesList.ItemAt(index);
+			// TODO: Only if the property is available
+			//if ((ldi-&gt;GetAddress(&amp;local, message) == B_OK) 
+			//	&amp;&amp; bacmp(&amp;local, &amp;bdaddr))  {
+			//    break;
+			//}
+		}
 
-	return B_ERROR;	
+		} else	{
+			/* Careless, any device not performing operations will be fine */
+			Output::Instance()-&gt;Post(&quot;GetLocalDevice requested\n&quot;, BLACKBOARD_KIT);
+			for (index = 0; index &lt; fLocalDevicesList.CountItems(); index ++) {
+				ldi = fLocalDevicesList.ItemAt(index);
+				printf(&quot;Requesting local device %ld\n&quot;, ldi-&gt;GetID());
+				if (ldi != NULL &amp;&amp; ldi-&gt;Available())
+				{
+					printf(&quot;dev ours %ld\n&quot;, ldi-&gt;GetID());
+					break;
+				}
+			}	
+		}
 	
+	if (index &lt;= fLocalDevicesList.CountItems() &amp;&amp; ldi != NULL &amp;&amp; ldi-&gt;Available()) {
+		Output::Instance()-&gt;Post(&quot;Device acquired\n&quot;, BLACKBOARD_KIT);
+		ldi-&gt;Acquire();
+		return reply-&gt;AddInt32(&quot;hci_id&quot;, hid);
+	}
+	
+	return B_ERROR;
+	
 }
 
 
 status_t
 BluetoothServer::HandleSimpleRequest(BMessage* message, BMessage* reply)
 {
-
-    LocalDeviceImpl* ldi = LocateDelegateFromMessage(message);
+	LocalDeviceImpl* ldi = LocateDelegateFromMessage(message);
 	BString propertyRequested;
-		
-	// Find out if there is a property being requested, 
-    if (message-&gt;FindString(&quot;property&quot;, &amp;propertyRequested) == B_OK) {
-    	// Check if the property has been already retrieved
-    	
-    	if (ldi-&gt;IsPropertyAvailable(propertyRequested)) {
-    	
-    	    // Dump everything
-    		reply-&gt;AddMessage(&quot;properties&quot;,ldi-&gt;GetPropertiesMessage());
-    		return B_OK;
-    	}
-    	               	
-    }
+
+	// Find out if there is a property being requested,
+	if (message-&gt;FindString(&quot;property&quot;, &amp;propertyRequested) == B_OK) {
+		// Check if the property has been already retrieved
+		if (ldi-&gt;IsPropertyAvailable(propertyRequested)) {
+			// Dump everything
+			reply-&gt;AddMessage(&quot;properties&quot;,ldi-&gt;GetPropertiesMessage());
+			return B_OK;
+		}
+	}
 	
 	// we are gonna need issue the command ...
 	if (ldi-&gt;ProcessSimpleRequest(DetachCurrentMessage()) == B_OK)
-//	if (ldi-&gt;ProcessSimpleRequest(message) == B_OK)
 		return B_WOULD_BLOCK;
 	else
 		return B_ERROR;
@@ -334,7 +304,7 @@
 int32 
 BluetoothServer::notification_Thread(void* data)
 {
-	BPortNot notifierd( (BluetoothServer*) data , BT_USERLAND_PORT_NAME);
+	BPortNot notifierd((BluetoothServer*)data, BT_USERLAND_PORT_NAME);
 	
 	notifierd.loop();
 	return B_NO_ERROR;
@@ -367,7 +337,7 @@
 int
 main(int /*argc*/, char** /*argv*/)
 {
-	setbuf(stdout,NULL);
+	setbuf(stdout, NULL);
 
 	BluetoothServer* bluetoothServer = new BluetoothServer;
 

Modified: haiku/trunk/src/servers/bluetooth/HCIDelegate.h
===================================================================
--- haiku/trunk/src/servers/bluetooth/HCIDelegate.h	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/src/servers/bluetooth/HCIDelegate.h	2009-01-16 20:32:19 UTC (rev 28915)
@@ -1,10 +1,8 @@
 /*
  * Copyright 2007-2008 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
+ * Copyright 2008 Mika Lindqvist, monni1995_at_gmail.com
  * All rights reserved. Distributed under the terms of the MIT License.
- *
  */
-
 #ifndef _HCIDELEGATE_H_
 #define _HCIDELEGATE_H_
 
@@ -30,43 +28,59 @@
 			if (fFD &gt; 0) {
 				// find out which ID was assigned
 				status = ioctl(fFD, GET_HCI_ID, &amp;fHID, 0);
-				printf(&quot;%s: hid retrieved %lx status=%ld\n&quot;, __FUNCTION__, fHID, status);
+				printf(&quot;%s: hid retrieved %lx status=%ld\n&quot;, __FUNCTION__, 
+					fHID, status);
 			}
 			else {
-				printf(&quot;%s: Device driver could not be opened %ld\n&quot;, __FUNCTION__, fHID);
+				printf(&quot;%s: Device driver could not be opened %ld\n&quot;, __FUNCTION__, 
+					fHID);
 				fHID = B_ERROR;
 			}
-	    
-			//TODO create such queue					
 
+			//TODO create such queue
+
 		}
-						
+
 		
 		hci_id GetID(void)
 		{
 			return fHID;
 		}
 
-		virtual status_t IssueCommand(raw_command rc, size_t size)=0; // TODO means to be private
+
+		virtual ~HCIDelegate()
+ 		{
+			if (fFD  &gt; 0)
+			{
+				close (fFD);
+				fFD = -1;
+				fHID = B_ERROR;
+			}
+		}
+
+		virtual status_t IssueCommand(raw_command rc, size_t size)=0; 
+			// TODO means to be private use QueueCommand
 		virtual status_t Launch()=0;
 
-		void FreeWindow(uint8 slots) { // TODO: hci control flow 
 
+		void FreeWindow(uint8 slots)
+		{
+			// TODO: hci control flow
 		} 
 
+
 		status_t QueueCommand(raw_command rc, size_t size) 
 		{
-			// TODO: this is suposed to queue the command in a queue so all are actually send to HW
+			// TODO: this is suposed to queue the command in a queue so all
+			//  are actually send to HW
 			return IssueCommand(rc, size);
 		}
 
-
 	protected:
-		
 
 		hci_id fHID;
 		int fFD;
-	
+
 	private:
 
 

Modified: haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/src/servers/bluetooth/LocalDeviceHandler.cpp	2009-01-16 20:32:19 UTC (rev 28915)
@@ -1,25 +1,22 @@
 /*
- * Copyright 2007 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
- *
+ * Copyright 2007-2009 Oliver Ruiz Dorantes, oliver.ruiz.dorantes_at_gmail.com
+ * Copyright 2008 Mika Lindqvist, monni1995_at_gmail.com
  * All rights reserved. Distributed under the terms of the MIT License.
- *
  */
 
-
 #include &quot;LocalDeviceHandler.h&quot;
 
-    
-    
+
 LocalDeviceHandler::LocalDeviceHandler(HCIDelegate* hd)
 {
 	fHCIDelegate = hd;
-	fProperties = new BMessage();
-	
+	fProperties = new BMessage();	
 }
 
+
 LocalDeviceHandler::~LocalDeviceHandler() 
 {
-
+	delete fProperties;	
 }
 
 
@@ -29,6 +26,7 @@
     return fHCIDelegate-&gt;GetID();
 }
 
+
 status_t
 LocalDeviceHandler::Launch(void)
 {
@@ -37,26 +35,27 @@
 
 
 bool 
-LocalDeviceHandler::Available() {
+LocalDeviceHandler::Available()
+{
 
 	return true;
 }
 
 
 void
-LocalDeviceHandler::Acquire(void) {
+LocalDeviceHandler::Acquire(void)
+{
 
 }
 
 
 bool
-LocalDeviceHandler::IsPropertyAvailable(const BString&amp; property) {
-	
+LocalDeviceHandler::IsPropertyAvailable(const BString&amp; property)
+{
 	type_code typeFound;
 	int32     countFound;
 
 	return (fProperties-&gt;GetInfo(property.String(), &amp;typeFound, &amp;countFound) == B_OK );
-
 }
 
 
@@ -70,28 +69,28 @@
     fEventsWanted.Unlock();
 }
 
+
 void 
 LocalDeviceHandler::ClearWantedEvent(BMessage* msg)
 {
     fEventsWanted.Lock();
-    fEventsWanted.RemoveMessage(msg);    
+    fEventsWanted.RemoveMessage(msg);
     fEventsWanted.Unlock();
-
 }
 
 
 void 
 LocalDeviceHandler::ClearWantedEvent(BMessage* msg, uint16 event, uint16 opcode)
-{  
-    // Remove the whole petition from queue
-    fEventsWanted.Lock();
+{
+	// Remove the whole petition from queue
+	fEventsWanted.Lock();
 
-    int16 eventFound;
-    int16 opcodeFound;
+	int16 eventFound;
+	int16 opcodeFound;
 	int32 eventIndex = 0;
 
-    // for each Event    
-	while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
+	// for each Event    
+	while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK) {
 
 		printf(&quot;%s:Event expected@%ld...\n&quot;, __FUNCTION__, eventIndex);
 
@@ -102,19 +101,20 @@
 			if (opcode != 0) {
 
 				// The opcode matches
-				if ( (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) &amp;&amp;
-					((uint16)opcodeFound == opcode) ) {
+				if ( (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) 
+					&amp;&amp; ((uint16)opcodeFound == opcode) ) {
 
 					// this should remove only the entry
-					printf(&quot;Removed event %#x and opcode %d from request %p\n&quot;, event, opcode, msg); 
+					printf(&quot;Removed event %#x and opcode %d from request %p\n&quot;,
+						event, opcode, msg); 
 					(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
 					(void)msg-&gt;RemoveData(&quot;opcodeExpected&quot;, eventIndex);
 					goto finish;
 				}
 
-			}  else {
+			} else {
 				// Event matches so far
-				printf(&quot;Removed event %d from message %p\n&quot;, event, msg); 
+				printf(&quot;Removed event %d from message %p\n&quot;, event, msg);
 				(void)msg-&gt;RemoveData(&quot;eventExpected&quot;, eventIndex);
 				goto finish;
 			}
@@ -133,49 +133,49 @@
 BMessage*
 LocalDeviceHandler::FindPetition(uint16 event, uint16 opcode, int32* indexFound)
 {
-    int16 eventFound;
-    int16 opcodeFound;
+	int16 eventFound;
+	int16 opcodeFound;
 	int32 eventIndex;
 
-    fEventsWanted.Lock();
-    // for each Petition
-    for (int32 index = 0 ; index &lt; fEventsWanted.CountMessages() ; index++) {
-        BMessage* msg = fEventsWanted.FindMessage(index);
-		
-		printf(&quot;%s:Petition %ld ... of %ld msg #%p\n&quot;, __FUNCTION__, index, fEventsWanted.CountMessages(), msg);
+	fEventsWanted.Lock();
+	// for each Petition
+	for (int32 index = 0 ; index &lt; fEventsWanted.CountMessages() ; index++) {
+		BMessage* msg = fEventsWanted.FindMessage(index);
+		printf(&quot;%s:Petition %ld ... of %ld msg #%p\n&quot;, __FUNCTION__, index, 
+			fEventsWanted.CountMessages(), msg);
 		//msg-&gt;PrintToStream();
 		eventIndex = 0;
 
-        // for each Event
-        while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
-            if (eventFound == event) {
-
-        		printf(&quot;%s:Event found@%ld...&quot;, __FUNCTION__, eventIndex);
-                // there is an opcode specified.. 
-                if (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) == B_OK) {
-
-                	// ensure the opcode
-                	if ((uint16)opcodeFound != opcode) {
-		        		printf(&quot;%s:opcode does not match %d\n&quot;,__FUNCTION__, opcode);
-    	                break;
-    	            }
-					printf(&quot;opcode match %d\n&quot;, opcode);
-                } else {
-                	printf(&quot;no opcode specified\n&quot;);
-                }
-
-	            fEventsWanted.Unlock();
+		// for each Event
+		while (msg-&gt;FindInt16(&quot;eventExpected&quot;, eventIndex, &amp;eventFound) == B_OK ) {
+			if (eventFound == event) {
+		
+				printf(&quot;%s:Event found@%ld...&quot;, __FUNCTION__, eventIndex);
+				// there is an opcode specified.. 
+				if (msg-&gt;FindInt16(&quot;opcodeExpected&quot;, eventIndex, &amp;opcodeFound) 
+					== B_OK) {
+					// ensure the opcode
+					if ((uint16)opcodeFound != opcode) {
+						printf(&quot;%s:opcode does not match %d\n&quot;,
+							__FUNCTION__, opcode);
+						break;
+					}
+					printf(&quot;Opcode matches %d\n&quot;, opcode);
+				} else {
+					printf(&quot;No opcode specified\n&quot;);
+				}
+		
+				fEventsWanted.Unlock();
 				if (indexFound != NULL)
 					*indexFound = eventIndex;
-    	        return msg;
+				return msg;
+			} 
+			eventIndex++;
+		}
+	}
+	printf(&quot;%s:Nothing found\n&quot;, __FUNCTION__);
 
+	fEventsWanted.Unlock();
+	return NULL;
 
-            } 
-            eventIndex++;
-        }
-    }
-  	printf(&quot;%s:Nothing found\n&quot;,__FUNCTION__);
-
-    fEventsWanted.Unlock();
-    return NULL;
 }

Modified: haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp
===================================================================
--- haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.cpp	2009-01-16 20:32:19 UTC (rev 28915)
@@ -34,7 +34,7 @@
 LocalDeviceImpl::CreateControllerAccessor(BPath* path)
 {
     HCIDelegate* hd = new HCIControllerAccessor(path);
-    
+
     if ( hd != NULL)
         return new LocalDeviceImpl(hd);
     else
@@ -46,11 +46,11 @@
 LocalDeviceImpl::CreateTransportAccessor(BPath* path)
 {
     HCIDelegate* hd = new HCITransportAccessor(path);
-    
+
     if ( hd != NULL)
-        return new LocalDeviceImpl(hd);    
+        return new LocalDeviceImpl(hd);
     else
-        return NULL;        
+        return NULL;
 }
 
 
@@ -75,30 +75,25 @@
 
 	// Events here might have not been initated by us
 	// TODO: ML mark as handled pass a reply by parameter and reply in common
-    switch (event-&gt;ecode) {
-        case HCI_EVENT_HARDWARE_ERROR:
+	switch (event-&gt;ecode) {
+		case HCI_EVENT_HARDWARE_ERROR:
 			//HardwareError(event);    	
-   		return;
+		return;
 		case HCI_EVENT_CONN_REQUEST:
 			ConnectionRequest((struct hci_ev_conn_request*)(event+1), NULL);
 		return;
-
 		case HCI_EVENT_CONN_COMPLETE:
 			// should belong to a request?  can be sporadic or initiated by us&#191;?...
 			ConnectionComplete((struct hci_ev_conn_complete*)(event+1), NULL);					
 		return;
-
 		case HCI_EVENT_PIN_CODE_REQ:
 			PinCodeRequest((struct hci_ev_pin_code_req*)(event+1), NULL);
 		return;
-
-   		default:
-   			// lets go on
-   		break;        
+		default:
+			// lets go on
+		break;
 	}
 
-	
-
 	BMessage*	request = NULL;
 	int32		eventIndexLocation;
 	

Modified: haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.h
===================================================================
--- haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.h	2009-01-15 23:01:45 UTC (rev 28914)
+++ haiku/trunk/src/servers/bluetooth/LocalDeviceImpl.h	2009-01-16 20:32:19 UTC (rev 28915)
@@ -48,7 +48,7 @@
 	// Connection
 	void ConnectionComplete(struct hci_ev_conn_complete* event, BMessage* request);
 	void ConnectionRequest(struct hci_ev_conn_request* event, BMessage* request);	
-	void DisconnectionComplete(struct hci_ev_disconnection_complete_reply* event, BMessage *request);	
+	void DisconnectionComplete(struct hci_ev_disconnection_complete_reply* event, BMessage* request);	
 
 	// Pairing
 	void PinCodeRequest(struct hci_ev_pin_code_req* event, BMessage* request);	


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013904.html">[Haiku-commits] r28914 -	haiku/trunk/src/add-ons/kernel/drivers/audio/hda
</A></li>
	<LI>Next message: <A HREF="013906.html">[Haiku-commits] r28915 - in haiku/trunk: headers/os/bluetooth src/servers/bluetooth
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13905">[ date ]</a>
              <a href="thread.html#13905">[ thread ]</a>
              <a href="subject.html#13905">[ subject ]</a>
              <a href="author.html#13905">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
