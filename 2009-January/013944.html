<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28940 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . geode
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28940%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97%3A%20.%20geode&In-Reply-To=%3C200901182110.n0ILA0FY001789%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013943.html">
   <LINK REL="Next"  HREF="013945.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28940 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . geode</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28940%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97%3A%20.%20geode&In-Reply-To=%3C200901182110.n0ILA0FY001789%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28940 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . geode">korli at mail.berlios.de
       </A><BR>
    <I>Sun Jan 18 22:10:00 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="013943.html">[Haiku-commits] r28939 - in haiku/trunk: headers/posix	src/system/libroot/posix/string
</A></li>
        <LI>Next message: <A HREF="013945.html">[Haiku-commits] r28941 - haiku/trunk/src/apps/deskbar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13944">[ date ]</a>
              <a href="thread.html#13944">[ thread ]</a>
              <a href="subject.html#13944">[ subject ]</a>
              <a href="author.html#13944">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2009-01-18 22:09:59 +0100 (Sun, 18 Jan 2009)
New Revision: 28940
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28940&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28940&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/ac97.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/ac97.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/device.cpp
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/driver.cpp
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/driver.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/gcscaudioreg.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/geode_controller.cpp
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/geode_multi.cpp
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile
Log:
added an experimental geode audio driver


Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile	2009-01-18 20:27:12 UTC (rev 28939)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile	2009-01-18 21:09:59 UTC (rev 28940)
@@ -3,5 +3,6 @@
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 auich ;
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 auvia ;
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 es1370 ;
+SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 geode ;
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 ich ;
 # SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 ichaudio ;

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/Jamfile	2009-01-18 20:27:12 UTC (rev 28939)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/Jamfile	2009-01-18 21:09:59 UTC (rev 28940)
@@ -0,0 +1,12 @@
+SubDir HAIKU_TOP src add-ons kernel drivers audio ac97 geode ;
+
+UsePrivateHeaders media ;
+
+KernelAddon geode :
+	ac97.c
+	driver.cpp
+	device.cpp
+	geode_multi.cpp
+	geode_controller.cpp
+;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/ac97.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/ac97.c	2009-01-18 20:27:12 UTC (rev 28939)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/geode/ac97.c	2009-01-18 21:09:59 UTC (rev 28940)
@@ -0,0 +1,975 @@
+/*
+ * AC97 interface
+ *
+ * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
+ * Copyright (c) 2008, J&#233;r&#244;me Duval
+ *
+ * All rights reserved.
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, 
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation 
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include &lt;KernelExport.h&gt;
+#include &lt;OS.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;MediaDefs.h&gt;
+#include &quot;ac97.h&quot;
+
+#define LOG(x)	dprintf x
+
+#define B_UTF8_REGISTERED	&quot;\xC2\xAE&quot;
+
+bool ac97_reg_is_valid(ac97_dev *dev, uint8 reg);
+void ac97_amp_enable(ac97_dev *dev, bool onoff);
+void ac97_dump_capabilities(ac97_dev *dev);
+void ac97_detect_capabilities(ac97_dev *dev);
+void ac97_detect_rates(ac97_dev *dev);
+void ac97_update_register_cache(ac97_dev *dev);
+
+const char * stereo_enhancement_technique[] =
+{
+	&quot;No 3D Stereo Enhancement&quot;,
+	&quot;Analog Devices&quot;,
+	&quot;Creative Technology&quot;,
+	&quot;National Semiconductor&quot;,
+	&quot;Yamaha&quot;,
+	&quot;BBE Sound&quot;,
+	&quot;Crystal Semiconductor&quot;,
+	&quot;Qsound Labs&quot;,
+	&quot;Spatializer Audio Laboratories&quot;,
+	&quot;SRS Labs&quot;,
+	&quot;Platform Tech&quot;,
+	&quot;AKM Semiconductor&quot;,
+	&quot;Aureal&quot;,
+	&quot;Aztech Labs&quot;,
+	&quot;Binaura&quot;,
+	&quot;ESS Technology&quot;,
+	&quot;Harman International&quot;,
+	&quot;Nvidea&quot;,
+	&quot;Philips&quot;,
+	&quot;Texas Instruments&quot;,
+	&quot;VLSI Technology&quot;,
+	&quot;TriTech&quot;,
+	&quot;Realtek&quot;,
+	&quot;Samsung&quot;,
+	&quot;Wolfson Microelectronics&quot;,
+	&quot;Delta Integration&quot;,
+	&quot;SigmaTel&quot;,
+	&quot;KS Waves&quot;,
+	&quot;Rockwell&quot;,
+	&quot;Unknown (29)&quot;,
+	&quot;Unknown (30)&quot;,
+	&quot;Unknown (31)&quot;
+};
+
+void default_init(ac97_dev *dev);
+void ad1819_init(ac97_dev *dev);
+void ad1881_init(ac97_dev *dev);
+void ad1885_init(ac97_dev *dev);
+void ad1886_init(ac97_dev *dev);
+void ad1980_init(ac97_dev *dev);
+void ad1981b_init(ac97_dev *dev);
+void alc650_init(ac97_dev *dev);
+void stac9708_init(ac97_dev *dev);
+void stac9721_init(ac97_dev *dev);
+void stac9744_init(ac97_dev *dev);
+void stac9756_init(ac97_dev *dev);
+void tr28028_init(ac97_dev *dev);
+void wm9701_init(ac97_dev *dev);
+void wm9703_init(ac97_dev *dev);
+void wm9704_init(ac97_dev *dev);
+
+bool ad1819_set_rate(ac97_dev *dev, uint8 reg, uint32 rate);
+bool ad1819_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate);
+
+typedef struct
+{
+	uint32 id;
+	uint32 mask;
+	codec_init init;
+	const char *info;
+} codec_table;
+
+codec_table codecs[] = 
+{
+	{ CODEC_ID_AD1819,	0xffffffff, ad1819_init,	&quot;Analog Devices AD1819A, AD1819B SoundPort&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1881,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1881 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1881A,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1881A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1885,	0xffffffff, ad1885_init,	&quot;Analog Devices AD1885 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1886,	0xffffffff, ad1886_init,	&quot;Analog Devices AD1886 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1886A,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1886A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1887,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1887 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1888,	0xffffffff, ad1881_init,	&quot;Analog Devices AD1888 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1980,	0xffffffff, ad1980_init,	&quot;Analog Devices AD1980 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445371,		0xffffffff, default_init,	&quot;Analog Devices 0x41445371 (???)&quot; },
+	{ 0x41445372,		0xffffffff, default_init,	&quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1981B,	0xffffffff, ad1981b_init,	&quot;Analog Devices AD1981B SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1985,	0xffffffff, default_init,	&quot;Analog Devices AD1985 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AD1986,	0xffffffff, default_init,	&quot;Analog Devices AD1986 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ CODEC_ID_AK4540,	0xffffffff, default_init,	&quot;Asahi Kasei AK4540&quot; },
+	{ CODEC_ID_AK4542,	0xffffffff, default_init,	&quot;Asahi Kasei AK4542&quot; },
+	{ CODEC_ID_AK4543,	0xffffffff, default_init,	&quot;Asahi Kasei AK4543&quot; },
+	{ 0x414c4320,		0xfffffff0, default_init,	&quot;Avance Logic (Realtek) ALC100/ALC100P, RL5383/RL5522&quot; },
+	{ 0x414c4730,		0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC101&quot; },
+	{ CODEC_ID_ALC201A,	0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC200/ALC200A, ALC201/ALC201A&quot; }, /* 0x4710 = ALC201A */
+	{ 0x414c4720,		0xffffffff, alc650_init,	&quot;Avance Logic (Realtek) ALC650&quot; }, /* 0x4720 = ALC650 */
+	{ 0x414c4740,		0xffffffff, default_init,	&quot;Avance Logic (Realtek) ALC202/ALC202A&quot; },
+	{ 0x434d4941,		0xffffffff, default_init,	&quot;C-Media CMI9738&quot; },
+	{ 0x434d4961,		0xffffffff, default_init,	&quot;C-Media CMI9739&quot; },
+	{ 0x43525900,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525903,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525913,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297A&quot; },
+	{ 0x43525914,		0xffffffff, default_init,	&quot;Cirrus Logic CS4297B&quot; },
+	{ 0x43525923,		0xffffffff, default_init,	&quot;Cirrus Logic CS4294C&quot; },
+	{ 0x4352592b,		0xffffffff, default_init,	&quot;Cirrus Logic CS4298C&quot; },
+	{ CODEC_ID_CS4299A,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299A&quot; },
+	{ CODEC_ID_CS4299C,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299C&quot; },
+	{ CODEC_ID_CS4299D,	0xffffffff, default_init,	&quot;Cirrus Logic CS4299D&quot; },
+	{ 0x43525941,		0xffffffff, default_init,	&quot;Cirrus Logic CS4201A&quot; },
+	{ 0x43525951,		0xffffffff, default_init,	&quot;Cirrus Logic CS4205A&quot; },
+	{ 0x43525961,		0xffffffff, default_init,	&quot;Cirrus Logic CS4291A&quot; },
+	{ 0x45838308,		0xffffffff, default_init,	&quot;ESS Technology ES1921&quot; },
+	{ 0x49434511,		0xffffffff, default_init,	&quot;ICEnsemble ICE1232&quot; },
+	{ 0x4e534331,		0xffffffff, default_init,	&quot;National Semiconductor LM4549&quot; },
+	{ CODEC_ID_STAC9700,0xffffffff, default_init,	&quot;SigmaTel STAC9700/9783/9784&quot; },
+	{ CODEC_ID_STAC9704,0xffffffff, default_init,	&quot;SigmaTel STAC9701/03, STAC9704/07, STAC9705 (???)&quot; },
+	{ CODEC_ID_STAC9705,0xffffffff, default_init,	&quot;SigmaTel STAC9704 (???)&quot; },
+	{ CODEC_ID_STAC9708,0xffffffff, stac9708_init,	&quot;SigmaTel STAC9708/9711&quot; },
+	{ CODEC_ID_STAC9721,0xffffffff, stac9721_init,	&quot;SigmaTel STAC9721/9723&quot; },
+	{ CODEC_ID_STAC9744,0xffffffff, stac9744_init,	&quot;SigmaTel STAC9744&quot; },
+	{ CODEC_ID_STAC9752,0xffffffff, default_init,	&quot;SigmaTel STAC9752/53&quot; },
+	{ CODEC_ID_STAC9756,0xffffffff, stac9756_init,	&quot;SigmaTel STAC9756/9757&quot; },
+	{ CODEC_ID_STAC9766,0xffffffff, default_init,	&quot;SigmaTel STAC9766/67&quot; },
+	{ 0x53494c22,		0xffffffff, default_init,	&quot;Silicon Laboratory Si3036&quot; },
+	{ 0x53494c23,		0xffffffff, default_init,	&quot;Silicon Laboratory Si3038&quot; },
+	{ 0x54524103,		0xffffffff, default_init,	&quot;TriTech TR?????&quot; },
+	{ 0x54524106,		0xffffffff, default_init,	&quot;TriTech TR28026&quot; },
+	{ 0x54524108,		0xffffffff, tr28028_init,	&quot;TriTech TR28028&quot; },
+	{ 0x54524123,		0xffffffff, default_init,	&quot;TriTech TR28602&quot; },
+	{ 0x574d4c00,		0xffffffff, wm9701_init,	&quot;Wolfson WM9701A&quot; },
+	{ 0x574d4c03,		0xffffffff, wm9703_init,	&quot;Wolfson WM9703/9704&quot; },
+	{ 0x574d4c04,		0xffffffff, wm9704_init,	&quot;Wolfson WM9704 (quad)&quot; },	
+	/* Vendors only: */
+	{ 0x41445300,		0xffffff00, default_init,	&quot;Analog Devices&quot; },
+	{ 0x414b4d00,		0xffffff00, default_init,	&quot;Asahi Kasei&quot; },
+	{ 0x414c4700,		0xffffff00, default_init,	&quot;Avance Logic (Realtek)&quot; },
+	{ 0x434d4900,		0xffffff00, default_init,	&quot;C-Media&quot; },
+	{ 0x43525900,		0xffffff00, default_init,	&quot;Cirrus Logic&quot; },
+	{ 0x45838300,		0xffffff00, default_init,	&quot;ESS Technology&quot; },
+	{ 0x49434500,		0xffffff00, default_init,	&quot;ICEnsemble&quot; },
+	{ 0x4e534300,		0xffffff00, default_init,	&quot;National Semiconductor&quot; },
+	{ 0x83847600,		0xffffff00, default_init,	&quot;SigmaTel&quot; },
+	{ 0x53494c00,		0xffffff00, default_init,	&quot;Silicon Laboratory&quot; },
+	{ 0x54524100,		0xffffff00, default_init,	&quot;TriTech&quot; },
+	{ 0x574d4c00,		0xffffff00, default_init,	&quot;Wolfson&quot; },
+	{ 0x00000000,		0x00000000, default_init,	&quot;Unknown&quot; } /* must be last one, matches every codec */
+};
+
+codec_table *find_codec_table(uint32 codecid);
+
+codec_table *
+find_codec_table(uint32 codecid)
+{
+	codec_table *codec;
+	for (codec = codecs; codec-&gt;id; codec++)
+		if ((codec-&gt;id &amp; codec-&gt;mask) == (codecid &amp; codec-&gt;mask))
+			break;
+	return codec;
+}
+
+void
+ac97_attach(ac97_dev **_dev, codec_reg_read reg_read, codec_reg_write reg_write, void *cookie,
+	ushort subvendor_id, ushort subsystem_id)
+{
+	ac97_dev *dev;
+	codec_table *codec;
+	int i;
+	
+	*_dev = dev = (ac97_dev *) malloc(sizeof(ac97_dev));
+	dev-&gt;cookie = cookie;
+	dev-&gt;reg_read = reg_read;
+	dev-&gt;reg_write = reg_write;
+	dev-&gt;set_rate = 0;
+	dev-&gt;get_rate = 0;
+	dev-&gt;clock = 48000; /* default clock on non-broken motherboards */
+	dev-&gt;min_vsr = 0x0001;	
+	dev-&gt;max_vsr = 0xffff;
+	dev-&gt;reversed_eamp_polarity = false;
+	dev-&gt;capabilities = 0;
+
+	dev-&gt;subsystem = (subvendor_id &lt;&lt; 16) | subsystem_id;
+	
+	if (dev-&gt;subsystem == 0x161f202f
+		|| dev-&gt;subsystem == 0x161f203a
+		|| dev-&gt;subsystem == 0x161f204c
+		|| dev-&gt;subsystem == 0x104d8144
+		|| dev-&gt;subsystem == 0x104d8197
+		|| dev-&gt;subsystem == 0x104d81c0
+		|| dev-&gt;subsystem == 0x104d81c5
+		|| dev-&gt;subsystem == 0x103c3089
+		|| dev-&gt;subsystem == 0x103c309a
+		|| dev-&gt;subsystem == 0x10338213
+		|| dev-&gt;subsystem == 0x103382be) {
+		dev-&gt;reversed_eamp_polarity = true;
+	}
+		
+	/* reset the codec */	
+	LOG((&quot;codec reset\n&quot;));
+	ac97_reg_uncached_write(dev, AC97_RESET, 0x0000);
+	for (i = 0; i &lt; 500; i++) {
+		if ((ac97_reg_uncached_read(dev, AC97_POWERDOWN) &amp; 0xf) == 0xf)
+			break;
+		snooze(1000);
+	}
+
+	dev-&gt;codec_id = ((uint32)reg_read(cookie, AC97_VENDOR_ID1) &lt;&lt; 16) | reg_read(cookie, AC97_VENDOR_ID2);
+	codec = find_codec_table(dev-&gt;codec_id);
+	dev-&gt;codec_info = codec-&gt;info;
+	dev-&gt;init = codec-&gt;init;
+		
+	dev-&gt;codec_3d_stereo_enhancement = stereo_enhancement_technique[(ac97_reg_cached_read(dev, AC97_RESET) &gt;&gt; 10) &amp; 31];
+
+	/* setup register cache */
+	ac97_update_register_cache(dev);
+	
+	ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 1, 1); // enable variable rate audio
+
+	ac97_detect_capabilities(dev);
+
+	dev-&gt;init(dev);
+	ac97_amp_enable(dev, true);
+	
+	/* set mixer defaults, enabled Line-out sources are PCM-out, CD-in, Line-in */
+	ac97_reg_update(dev, AC97_CENTER_LFE_VOLUME, 0x0000);	/* set LFE &amp; center volume 0dB */
+	ac97_reg_update(dev, AC97_SURR_VOLUME, 0x0000);			/* set surround volume 0dB */
+	ac97_reg_update(dev, AC97_MASTER_VOLUME, 0x0000);		/* set master output 0dB */
+	ac97_reg_update(dev, AC97_AUX_OUT_VOLUME, 0x0000);		/* set aux output 0dB */
+	ac97_reg_update(dev, AC97_MONO_VOLUME, 0x0000);			/* set mono output 0dB */
+	ac97_reg_update(dev, AC97_PCM_OUT_VOLUME, 0x0808);		/* enable pcm-out */
+	ac97_reg_update(dev, AC97_CD_VOLUME, 0x0808);			/* enable cd-in */
+	ac97_reg_update(dev, AC97_LINE_IN_VOLUME, 0x0808);		/* enable line-in */
+	
+	/* set record line in */
+	ac97_reg_update(dev, AC97_RECORD_SELECT, 0x0404);
+	
+	ac97_dump_capabilities(dev);
+}
+
+void
+ac97_detach(ac97_dev *dev)
+{
+	/* Mute everything */
+	ac97_reg_update_bits(dev, AC97_CENTER_LFE_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_SURR_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_MASTER_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_AUX_OUT_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_MONO_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_PCM_OUT_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_CD_VOLUME, 0x8000, 0x8000);
+	ac97_reg_update_bits(dev, AC97_LINE_IN_VOLUME, 0x8000, 0x8000);
+	
+	ac97_amp_enable(dev, false);	
+
+	free(dev);
+}
+
+void
+ac97_suspend(ac97_dev *dev)
+{
+	ac97_amp_enable(dev, false);
+}
+
+void
+ac97_resume(ac97_dev *dev)
+{
+	ac97_amp_enable(dev, true);
+}
+
+void
+ac97_reg_cached_write(ac97_dev *dev, uint8 reg, uint16 value)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return;
+	dev-&gt;reg_write(dev-&gt;cookie, reg, value);
+	dev-&gt;reg_cache[reg] = value;
+}
+
+uint16
+ac97_reg_cached_read(ac97_dev *dev, uint8 reg)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return 0;
+	return dev-&gt;reg_cache[reg];
+}
+
+void
+ac97_reg_uncached_write(ac97_dev *dev, uint8 reg, uint16 value)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return;
+	dev-&gt;reg_write(dev-&gt;cookie, reg, value);
+}
+
+uint16
+ac97_reg_uncached_read(ac97_dev *dev, uint8 reg)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return 0;
+	return dev-&gt;reg_read(dev-&gt;cookie, reg);
+}
+
+bool
+ac97_reg_update(ac97_dev *dev, uint8 reg, uint16 value)
+{
+	if (!ac97_reg_is_valid(dev, reg))
+		return false;
+	if (ac97_reg_cached_read(dev, reg) == value)
+		return false;
+	ac97_reg_cached_write(dev, reg, value);
+	return true;
+}
+
+bool
+ac97_reg_update_bits(ac97_dev *dev, uint8 reg, uint16 mask, uint16 value)
+{
+	uint16 old;
+	if (!ac97_reg_is_valid(dev, reg))
+		return false;
+	old = ac97_reg_cached_read(dev, reg);
+	value &amp;= mask;
+	value |= (old &amp; ~mask);
+	if (old == value)
+		return false;
+	ac97_reg_cached_write(dev, reg, value);
+	return true;
+}
+
+void
+ac97_update_register_cache(ac97_dev *dev)
+{
+	int reg;
+	for (reg = 0; reg &lt;= 0x7e; reg += 2)
+		dev-&gt;reg_cache[reg] = ac97_reg_uncached_read(dev, reg);
+}
+
+bool
+ac97_set_rate(ac97_dev *dev, uint8 reg, uint32 rate)
+{
+	uint32 value;
+	uint32 old;
+	
+	if (dev-&gt;set_rate)
+		return dev-&gt;set_rate(dev, reg, rate);
+
+	value = (uint32)((rate * 48000ULL) / dev-&gt;clock); /* need 64 bit calculation for rates 96000 or higher */
+
+	LOG((&quot;ac97_set_rate: clock = %ld, rate = %ld, value = %ld\n&quot;, dev-&gt;clock, rate, value));
+	
+	/* if double rate audio is currently enabled, divide value by 2 */
+	if (ac97_reg_cached_read(dev, AC97_EXTENDED_STAT_CTRL) &amp; 0x0002)
+		value /= 2;
+		
+	if (value &lt; dev-&gt;min_vsr || value &gt; dev-&gt;max_vsr)
+		return false;
+
+	old = ac97_reg_cached_read(dev, reg);
+	ac97_reg_cached_write(dev, reg, value);
+	if (value != ac97_reg_uncached_read(dev, reg)) {
+		LOG((&quot;ac97_set_rate failed, new rate %d\n&quot;, ac97_reg_uncached_read(dev, reg)));
+		ac97_reg_cached_write(dev, reg, old);
+		return false;
+	}
+	LOG((&quot;ac97_set_rate done\n&quot;));
+	return true;
+}
+
+bool
+ac97_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate)
+{
+	uint32 value;
+
+	if (dev-&gt;get_rate)
+		return dev-&gt;get_rate(dev, reg, rate);
+
+	value = ac97_reg_cached_read(dev, reg);
+	if (value == 0)
+		return false;
+
+	/* if double rate audio is currently enabled, multiply value by 2 */
+	if (ac97_reg_cached_read(dev, AC97_EXTENDED_STAT_CTRL) &amp; 0x0002)
+		value *= 2;
+
+	*rate = (uint32)((value * (uint64)dev-&gt;clock) / 48000); /* need 64 bit calculation to avoid overflow*/
+	return true;
+}
+
+void
+ac97_set_clock(ac97_dev *dev, uint32 clock)
+{
+	LOG((&quot;ac97_set_clock: clock = %ld\n&quot;, clock));
+	dev-&gt;clock = clock;
+	ac97_detect_rates(dev);
+	ac97_dump_capabilities(dev);
+}
+
+void
+ac97_detect_capabilities(ac97_dev *dev)
+{
+	uint16 val;
+	
+	val = ac97_reg_cached_read(dev, AC97_RESET);
+	if (val &amp; 0x0001)
+		dev-&gt;capabilities |= CAP_PCM_MIC;
+	if (val &amp; 0x0004)
+		dev-&gt;capabilities |= CAP_BASS_TREBLE_CTRL;
+	if (val &amp; 0x0008)
+		dev-&gt;capabilities |= CAP_SIMULATED_STEREO;
+	if (val &amp; 0x0010)
+		dev-&gt;capabilities |= CAP_HEADPHONE_OUT;
+	if (val &amp; 0x0020)
+		dev-&gt;capabilities |= CAP_LAUDNESS;
+	if (val &amp; 0x0040)
+		dev-&gt;capabilities |= CAP_DAC_18BIT;
+	if (val &amp; 0x0080)
+		dev-&gt;capabilities |= CAP_DAC_20BIT;
+	if (val &amp; 0x0100)
+		dev-&gt;capabilities |= CAP_ADC_18BIT;
+	if (val &amp; 0x0200)
+		dev-&gt;capabilities |= CAP_ADC_20BIT;
+	if (val &amp; 0x7C00)
+		dev-&gt;capabilities |= CAP_3D_ENHANCEMENT;
+
+	val = ac97_reg_cached_read(dev, AC97_EXTENDED_ID);
+	if (val &amp; EXID_VRA)
+		dev-&gt;capabilities |= CAP_VARIABLE_PCM;
+	if (val &amp; EXID_DRA)
+		dev-&gt;capabilities |= CAP_DOUBLE_PCM;
+	if (val &amp; EXID_SPDIF)
+		dev-&gt;capabilities |= CAP_SPDIF;
+	if (val &amp; EXID_VRM)
+		dev-&gt;capabilities |= CAP_VARIABLE_MIC;
+	if (val &amp; EXID_CDAC)
+		dev-&gt;capabilities |= CAP_CENTER_DAC;
+	if (val &amp; EXID_SDAC)
+		dev-&gt;capabilities |= CAP_SURR_DAC;
+	if (val &amp; EXID_LDAC)
+		dev-&gt;capabilities |= CAP_LFE_DAC;
+	if (val &amp; EXID_AMAP)
+		dev-&gt;capabilities |= CAP_AMAP;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == 0)
+		dev-&gt;capabilities |= CAP_REV21;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == EXID_REV0)
+		dev-&gt;capabilities |= CAP_REV22;
+	if ((val &amp; (EXID_REV0 | EXID_REV1)) == EXID_REV1)
+		dev-&gt;capabilities |= CAP_REV23;
+		
+	ac97_detect_rates(dev);
+}		
+
+void
+ac97_detect_rates(ac97_dev *dev)
+{
+	uint32 oldrate;
+	
+	dev-&gt;capabilities &amp;= ~CAP_PCM_RATE_MASK;
+
+	if (!ac97_get_rate(dev, AC97_PCM_FRONT_DAC_RATE, &amp;oldrate))
+		oldrate = 48000;
+	
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 20000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_CONTINUOUS;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 8000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_8000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 11025))
+		dev-&gt;capabilities |= CAP_PCM_RATE_11025;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 12000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_12000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 16000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_16000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 22050))
+		dev-&gt;capabilities |= CAP_PCM_RATE_22050;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 24000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_24000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 32000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_32000;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 44100))
+		dev-&gt;capabilities |= CAP_PCM_RATE_44100;
+	if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 48000))
+		dev-&gt;capabilities |= CAP_PCM_RATE_48000;
+
+	if (dev-&gt;capabilities &amp; CAP_DOUBLE_PCM) {
+		// enable double rate mode
+		if (ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 0x0002, 0x0002)) {
+			if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 88200))
+				dev-&gt;capabilities |= CAP_PCM_RATE_88200;	
+			if (ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 96000))
+				dev-&gt;capabilities |= CAP_PCM_RATE_96000;
+			// disable double rate mode
+			ac97_reg_update_bits(dev, AC97_EXTENDED_STAT_CTRL, 0x0002, 0x0000);
+		}
+	}
+		
+	ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, oldrate);
+}
+
+void
+ac97_dump_capabilities(ac97_dev *dev)
+{
+	LOG((&quot;AC97 capabilities:\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_MIC))
+		LOG((&quot;CAP_PCM_MIC\n&quot;));
+	if (ac97_has_capability(dev, CAP_BASS_TREBLE_CTRL))
+		LOG((&quot;CAP_BASS_TREBLE_CTRL\n&quot;));
+	if (ac97_has_capability(dev, CAP_SIMULATED_STEREO))
+		LOG((&quot;CAP_SIMULATED_STEREO\n&quot;));
+	if (ac97_has_capability(dev, CAP_HEADPHONE_OUT))
+		LOG((&quot;CAP_HEADPHONE_OUT\n&quot;));
+	if (ac97_has_capability(dev, CAP_LAUDNESS))
+		LOG((&quot;CAP_LAUDNESS\n&quot;));
+	if (ac97_has_capability(dev, CAP_DAC_18BIT))
+		LOG((&quot;CAP_DAC_18BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_DAC_20BIT))
+		LOG((&quot;CAP_DAC_20BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_ADC_18BIT))
+		LOG((&quot;CAP_ADC_18BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_ADC_20BIT))
+		LOG((&quot;CAP_ADC_20BIT\n&quot;));
+	if (ac97_has_capability(dev, CAP_3D_ENHANCEMENT))
+		LOG((&quot;CAP_3D_ENHANCEMENT\n&quot;));
+	if (ac97_has_capability(dev, CAP_VARIABLE_PCM))
+		LOG((&quot;CAP_VARIABLE_PCM\n&quot;));
+	if (ac97_has_capability(dev, CAP_DOUBLE_PCM))
+		LOG((&quot;CAP_DOUBLE_PCM\n&quot;));
+	if (ac97_has_capability(dev, CAP_VARIABLE_MIC))
+		LOG((&quot;CAP_VARIABLE_MIC\n&quot;));
+	if (ac97_has_capability(dev, CAP_CENTER_DAC))
+		LOG((&quot;CAP_CENTER_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_SURR_DAC))
+		LOG((&quot;CAP_SURR_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_LFE_DAC))
+		LOG((&quot;CAP_LFE_DAC\n&quot;));
+	if (ac97_has_capability(dev, CAP_AMAP))
+		LOG((&quot;CAP_AMAP\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV21))
+		LOG((&quot;CAP_REV21\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV22))
+		LOG((&quot;CAP_REV22\n&quot;));
+	if (ac97_has_capability(dev, CAP_REV23))
+		LOG((&quot;CAP_REV23\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_CONTINUOUS))
+		LOG((&quot;CAP_PCM_RATE_CONTINUOUS\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_8000))
+		LOG((&quot;CAP_PCM_RATE_8000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_11025))
+		LOG((&quot;CAP_PCM_RATE_11025\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_12000))
+		LOG((&quot;CAP_PCM_RATE_12000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_16000))
+		LOG((&quot;CAP_PCM_RATE_16000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_22050))
+		LOG((&quot;CAP_PCM_RATE_22050\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_24000))
+		LOG((&quot;CAP_PCM_RATE_24000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_32000))
+		LOG((&quot;CAP_PCM_RATE_32000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_44100))
+		LOG((&quot;CAP_PCM_RATE_44100\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_48000))
+		LOG((&quot;CAP_PCM_RATE_48000\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_88200))
+		LOG((&quot;CAP_PCM_RATE_88200\n&quot;));
+	if (ac97_has_capability(dev, CAP_PCM_RATE_96000))
+		LOG((&quot;CAP_PCM_RATE_96000\n&quot;));
+}
+
+bool
+ac97_has_capability(ac97_dev *dev, uint64 cap)
+{
+	// return (dev-&gt;capabilities &amp; cap); // does not work because of 64 bit to integer trucation 
+	return (dev-&gt;capabilities &amp; cap) != 0;
+}
+
+/*************************************************
+ * Codec specific initialization, etc.
+ */
+
+bool
+ac97_reg_is_valid(ac97_dev *dev, uint8 reg)
+{
+	if (reg &amp; 1)
+		return false;
+	if (reg &gt; 0x7e)
+		return false;
+
+	switch (dev-&gt;codec_id) {
+		case CODEC_ID_AK4540:
+		case CODEC_ID_AK4542:
+			if (reg &lt; 0x1e || reg == 0x20 || reg == 0x26 || reg &gt; 0x7a)
+				return true;
+			return false;
+
+		case CODEC_ID_AD1819:
+		case CODEC_ID_AD1881:
+		case CODEC_ID_AD1881A:
+			if (reg &lt; 0x3a || reg &gt; 0x6e)
+				return true;
+			return false;
+
+		case CODEC_ID_AD1885:
+		case CODEC_ID_AD1886:
+		case CODEC_ID_AD1886A:
+		case CODEC_ID_AD1887:
+			if (reg &lt; 0x3c || reg == 0x5a || reg &gt; 0x6e)
+				return true;
+			return false;
+
+		case CODEC_ID_STAC9700:
+		case CODEC_ID_STAC9704:
+		case CODEC_ID_STAC9705:
+		case CODEC_ID_STAC9708:
+		case CODEC_ID_STAC9721:
+		case CODEC_ID_STAC9744:
+		case CODEC_ID_STAC9756:
+			if (reg &lt; 0x3c || reg &gt; 0x58)
+				return true;
+			return false;
+		
+		default:
+			return true;
+	}
+}
+
+void ac97_amp_enable(ac97_dev *dev, bool yesno)
+{
+	switch (dev-&gt;codec_id) {	
+		case CODEC_ID_CS4299A:
+		case CODEC_ID_CS4299C:
+		case CODEC_ID_CS4299D:
+			LOG((&quot;cs4299_amp_enable\n&quot;));
+			if (yesno)
+				ac97_reg_cached_write(dev, 0x68, 0x8004);
+			else
+				ac97_reg_cached_write(dev, 0x68, 0);
+			break;
+		
+		default:
+			LOG((&quot;ac97_amp_enable, reverse eamp = %d\n&quot;, dev-&gt;reversed_eamp_polarity));
+			LOG((&quot;powerdown register was = %#04x\n&quot;, ac97_reg_uncached_read(dev, AC97_POWERDOWN)));
+			if (dev-&gt;reversed_eamp_polarity)
+				yesno = !yesno;
+			if (yesno)
+				ac97_reg_cached_write(dev, AC97_POWERDOWN, ac97_reg_uncached_read(dev, AC97_POWERDOWN) &amp; ~0x8000); /* switch on (low active) */
+			else
+				ac97_reg_cached_write(dev, AC97_POWERDOWN, ac97_reg_uncached_read(dev, AC97_POWERDOWN) | 0x8000); /* switch off */
+			LOG((&quot;powerdown register is = %#04x\n&quot;, ac97_reg_uncached_read(dev, AC97_POWERDOWN)));
+		break;
+	}
+}
+
+bool
+ad1819_set_rate(ac97_dev *dev, uint8 reg, uint32 rate)
+{
+	uint32 value;
+	
+	value = (uint32)((rate * 48000ULL) / dev-&gt;clock); /* need 64 bit calculation for rates 96000 or higher */
+
+	LOG((&quot;ad1819_set_rate: clock = %ld, rate = %ld, value = %ld\n&quot;, dev-&gt;clock, rate, value));
+	
+	if (value &lt; 0x1B58 || value &gt; 0xBB80)
+		return false;
+
+	switch (reg) {
+		case AC97_PCM_FRONT_DAC_RATE:
+			ac97_reg_cached_write(dev, AC97_AD_SAMPLE_RATE_0, value);
+			return true;
+		
+		case AC97_PCM_L_R_ADC_RATE:
+			ac97_reg_cached_write(dev, AC97_AD_SAMPLE_RATE_1, value);
+			return true;
+
+		default:
+			return false;
+	}
+}
+
+bool
+ad1819_get_rate(ac97_dev *dev, uint8 reg, uint32 *rate)
+{
+	uint32 value;
+	
+	switch (reg) {
+		case AC97_PCM_FRONT_DAC_RATE:
+			value = ac97_reg_cached_read(dev, AC97_AD_SAMPLE_RATE_0);
+			break;
+		
+		case AC97_PCM_L_R_ADC_RATE:
+			value = ac97_reg_cached_read(dev, AC97_AD_SAMPLE_RATE_1);
+			break;
+
+		default:
+			return false;
+	}
+
+	*rate = (uint32)((value * (uint64)dev-&gt;clock) / 48000); /* need 64 bit calculation to avoid overflow*/
+	return true;
+}
+
+
+void default_init(ac97_dev *dev)
+{
+	LOG((&quot;default_init\n&quot;));
+}
+
+void ad1819_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1819_init\n&quot;));
+
+	/* Default config for system with single AD1819 codec */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x7000);
+	ac97_update_register_cache(dev);
+
+	/* The AD1819 chip has proprietary  sample rate controls
+	 * Setup sample rate 0 generator for DAC,
+	 * Setup sample rate 1 generator for ADC,
+	 * ARSR=1, DRSR=0, ALSR=1, DLSR=0
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0101);
+	/* connect special rate set/get functions */
+	dev-&gt;set_rate = ad1819_set_rate;
+	dev-&gt;get_rate = ad1819_get_rate;
+	ac97_detect_rates(dev);
+	ac97_set_rate(dev, AC97_PCM_FRONT_DAC_RATE, 48000);
+	ac97_set_rate(dev, AC97_PCM_L_R_ADC_RATE, 48000);
+}
+
+void ad1881_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1881_init\n&quot;));
+	
+	/* Default config for system with single AD1819 codec,
+	 * BROKEN on systems with master &amp; slave codecs */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x7000);
+	ac97_update_register_cache(dev);
+
+	/* Setup DAC and ADC rate generator assignments compatible with AC97 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0404);
+
+	/* Setup variable frame rate limits */
+	dev-&gt;min_vsr = 0x1B58;	/*  7kHz */
+	dev-&gt;max_vsr = 0xBB80;	/* 48kHz */
+}
+
+void ad1885_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1885_init\n&quot;));
+	ad1881_init(dev);
+	
+	/* disable jack sense 0 and 1 (JS0, JS1) to turn off automatic mute */
+	ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE, ac97_reg_cached_read(dev, AC97_AD_JACK_SENSE) | 0x0300);
+}
+
+void ad1886_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1886_init\n&quot;));
+	ad1881_init(dev);
+	
+	/* change jack sense to always activate outputs*/
+	ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE, 0x0010);
+	/* change SPDIF to a valid value */
+	ac97_reg_cached_write(dev, AC97_SPDIF_CONTROL, 0x2a20);
+}
+
+void ad1980_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1980_init\n&quot;));
+
+	/* Select only master codec,
+	 * SPDIF and DAC are linked
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_SERIAL_CONFIG, 0x1001);
+	ac97_update_register_cache(dev);
+	
+	/* Select Line-out driven with mixer data (not surround data)
+	 * Select Headphone-out driven with mixer data (not surround data),
+	 * LOSEL = 0, HPSEL = 1
+	 * XXX this one needs to be changed to support surround	out
+	 */
+	ac97_reg_cached_write(dev, AC97_AD_MISC_CONTROL, 0x0400);
+}
+
+void ad1981b_init(ac97_dev *dev)
+{
+	LOG((&quot;ad1981b_init\n&quot;));
+	if (dev-&gt;subsystem == 0x103c0934
+		|| dev-&gt;subsystem == 0x103c006d
+		|| dev-&gt;subsystem == 0x103c088c
+		|| dev-&gt;subsystem == 0x103c0890
+		|| dev-&gt;subsystem == 0x103c0934
+		|| dev-&gt;subsystem == 0x103c0938
+		|| dev-&gt;subsystem == 0x103c0944
+		|| dev-&gt;subsystem == 0x103c099c
+		|| dev-&gt;subsystem == 0x101402d9) {
+		ac97_reg_cached_write(dev, AC97_AD_JACK_SENSE,
+				ac97_reg_cached_read(dev, AC97_AD_JACK_SENSE) | 0x0800);
+	}
+}
+
+void alc650_init(ac97_dev *dev)
+{
+	LOG((&quot;alc650_init\n&quot;));
+
+	/* Enable Surround, LFE and Center downmix into Line-out,
+	 * Set Surround-out as duplicated Line-out.
+	 */
+	ac97_reg_cached_write(dev, AC97_ALC650_MULTI_CHAN_CTRL, 0x0007);
+
+	/* Set Surround DAC Volume to 0dB
+	 * Set Center/LFE DAC Volume to 0dB
+	 * (but both should already be set, as these are hardware reset defaults)
+	 */
+	ac97_reg_cached_write(dev, AC97_ALC650_SURR_VOLUME, 0x0808);
+	ac97_reg_cached_write(dev, AC97_ALC650_CEN_LFE_VOLUME, 0x0808);
+}
+
+void stac9708_init(ac97_dev *dev)
+{
+	LOG((&quot;stac9708_init\n&quot;));
+	/* ALSA initializes some registers that according to the
+	 * documentation for this codec do not exist. If the
+	 * following doesn't work, we may need to do that, too.
+	 */
+	/* The Analog Special reg is at 0x6C, other codecs have it at 0x6E */
+	/* Set Analog Special to default (DAC/ADC -6dB disabled) */
+	ac97_reg_cached_write(dev, 0x6C, 0x0000);
+	/* Set Multi Channel to default */
+	ac97_reg_cached_write(dev, 0x74, 0x0000);
+}
+
+void stac9721_init(ac97_dev *dev)
+{
+	LOG((&quot;stac9721_init\n&quot;));
+	/* Set Analog Special to default (DAC/ADC -6dB disabled) */
+	ac97_reg_cached_write(dev, 0x6E, 0x0000);
+	/* Enable register 0x72 */
+	ac97_reg_cached_write(dev, 0x70, 0xabba);
+	/* Set Analog Current to -50% */
+	ac97_reg_cached_write(dev, 0x72, 0x0002);
+	/* Set Multi Channel to default */
+	ac97_reg_cached_write(dev, 0x74, 0x0000);
+	/* Enable register 0x78 */
+	ac97_reg_cached_write(dev, 0x76, 0xabba);
+	/* Set Clock Access to default */
+	ac97_reg_cached_write(dev, 0x78, 0x0000);
+}
+
+void stac9744_init(ac97_dev *dev)
+{
+	LOG((&quot;stac9744_init\n&quot;));
+	/* Set Analog Special to default (DAC/ADC -6dB disabled) */
+	ac97_reg_cached_write(dev, 0x6E, 0x0000);
+	/* Enable register 0x72 */
+	ac97_reg_cached_write(dev, 0x70, 0xabba);
+	/* Set Analog Current to -50% */
+	ac97_reg_cached_write(dev, 0x72, 0x0002);
+	/* Set Multi Channel to default */
+	ac97_reg_cached_write(dev, 0x74, 0x0000);
+	/* Enable register 0x78 */
+	ac97_reg_cached_write(dev, 0x76, 0xabba);
+	/* Set Clock Access to default */
+	ac97_reg_cached_write(dev, 0x78, 0x0000);
+}
+
+void stac9756_init(ac97_dev *dev)
+{
+	LOG((&quot;stac9756_init\n&quot;));
+	/* Set Analog Special to default (AC97 all-mix, DAC/ADC -6dB disabled) */
+	ac97_reg_cached_write(dev, 0x6E, 0x1000);
+	/* Enable register 0x72 */
+	ac97_reg_cached_write(dev, 0x70, 0xabba);
+	/* Set Analog Current to -50% */
+	ac97_reg_cached_write(dev, 0x72, 0x0002);
+	/* Set Multi Channel to default */
+	ac97_reg_cached_write(dev, 0x74, 0x0000);
+	/* Enable register 0x78 */
+	ac97_reg_cached_write(dev, 0x76, 0xabba);
+	/* Set Clock Access to default */
+	ac97_reg_cached_write(dev, 0x78, 0x0000);
+}
+
+void tr28028_init(ac97_dev *dev)
+{
+	LOG((&quot;tr28028_init\n&quot;));
+	ac97_reg_cached_write(dev, AC97_POWERDOWN, 0x0300);
+	ac97_reg_cached_write(dev, AC97_POWERDOWN, 0x0000);
+	ac97_reg_cached_write(dev, AC97_SURR_VOLUME, 0x0000);
+	ac97_reg_cached_write(dev, AC97_SPDIF_CONTROL, 0x0000);
+}
+
+void wm9701_init(ac97_dev *dev)
+{
+	LOG((&quot;wm9701_init\n&quot;));
+	/* ALSA writes some of these registers, but the codec
+	 * documentation states explicitly that 0x38 and 0x70 to 0x74
+	 * are not used in the WM9701A
+	 */
+
+	/* DVD noise patch (?) */
+	ac97_reg_cached_write(dev, 0x5a, 0x0200);
+}
+
+void wm9703_init(ac97_dev *dev)
+{
+	LOG((&quot;wm9703_init\n&quot;));
+	/* Set front mixer value to unmuted */
+	ac97_reg_cached_write(dev, 0x72, 0x0808);
+	/* Disable loopback, etc */
+	ac97_reg_cached_write(dev, AC97_GENERAL_PURPOSE, 0x8000);
+}
+
+void wm9704_init(ac97_dev *dev)
+{
+	LOG((&quot;wm9704_init\n&quot;));
+	/* Set read DAC value to unmuted */
+	ac97_reg_cached_write(dev, 0x70, 0x0808);
+	/* Set front mixer value to unmuted */
+	ac97_reg_cached_write(dev, 0x72, 0x0808);
+	/* Set rear mixer value to unmuted */
+	ac97_reg_cached_write(dev, 0x74, 0x0808);
+	/* DVD noise patch (?) */
+	ac97_reg_cached_write(dev, 0x5a, 0x0200);
+}
+
+const ac97_source_info source_info[] = {
+	{ &quot;Recording&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO|B_MIX_RECORDMUX, 100, AC97_RECORD_GAIN, 0x8000, 4, 0, 1, 0, 0.0, 22.5, 1.5 },
+	{ &quot;Master&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 101, AC97_MASTER_VOLUME, 0x8000, 5, 0, 1, 1,-46.5, 0.0, 1.5 },
+	//{ &quot;Bass/Treble&quot;, B_MIX_GAIN|B_MIX_STEREO, 102, AC97_MASTER_TONE, 0x0f0f, 4, 0, 1, 1,-12.0, 10.5, 1.5 },
+	//{ &quot;Aux Out&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 103, AC97_AUX_OUT_VOLUME, 0x8000, 5, 0, 1, 1,-46.5, 0.0, 1.5 },
+	{ &quot;PCM Out&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 104, AC97_PCM_OUT_VOLUME, 0x8808, 5, 0, 1, 1,-34.5, 12.0, 1.5 },

[... truncated: 2325 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013943.html">[Haiku-commits] r28939 - in haiku/trunk: headers/posix	src/system/libroot/posix/string
</A></li>
	<LI>Next message: <A HREF="013945.html">[Haiku-commits] r28941 - haiku/trunk/src/apps/deskbar
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13944">[ date ]</a>
              <a href="thread.html#13944">[ thread ]</a>
              <a href="subject.html#13944">[ subject ]</a>
              <a href="author.html#13944">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
