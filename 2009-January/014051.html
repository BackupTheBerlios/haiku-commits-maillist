<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29002 - in haiku/trunk/src/add-ons/kernel:	bus_managers/usb busses/usb
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29002%20-%20in%20haiku/trunk/src/add-ons/kernel%3A%0A%09bus_managers/usb%20busses/usb&In-Reply-To=%3C200901240128.n0O1SgZx025990%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="014060.html">
   <LINK REL="Next"  HREF="014052.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29002 - in haiku/trunk/src/add-ons/kernel:	bus_managers/usb busses/usb</H1>
    <B>mmlr at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29002%20-%20in%20haiku/trunk/src/add-ons/kernel%3A%0A%09bus_managers/usb%20busses/usb&In-Reply-To=%3C200901240128.n0O1SgZx025990%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29002 - in haiku/trunk/src/add-ons/kernel:	bus_managers/usb busses/usb">mmlr at mail.berlios.de
       </A><BR>
    <I>Sat Jan 24 02:28:42 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="014060.html">[Haiku-commits] r29001 - haiku/trunk/src/add-ons/kernel/file_systems/bfs
</A></li>
        <LI>Next message: <A HREF="014052.html">[Haiku-commits] r29003 - haiku/trunk/src/data/etc/keymaps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14051">[ date ]</a>
              <a href="thread.html#14051">[ thread ]</a>
              <a href="subject.html#14051">[ subject ]</a>
              <a href="author.html#14051">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmlr
Date: 2009-01-24 02:28:31 +0100 (Sat, 24 Jan 2009)
New Revision: 29002
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29002&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29002&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Device.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Hub.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Interface.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Object.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Pipe.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/Transfer.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb.cpp
   haiku/trunk/src/add-ons/kernel/bus_managers/usb/usb_p.h
   haiku/trunk/src/add-ons/kernel/busses/usb/ehci.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/ehci.h
   haiku/trunk/src/add-ons/kernel/busses/usb/ehci.rdef
   haiku/trunk/src/add-ons/kernel/busses/usb/ehci_rh.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci.h
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci.rdef
   haiku/trunk/src/add-ons/kernel/busses/usb/ohci_rh.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci.cpp
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci.h
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci.rdef
   haiku/trunk/src/add-ons/kernel/busses/usb/uhci_rh.cpp
Log:
* Rework the USB tracing mechanism. Cleaned it up and make it more convenient to
  use. It will now print out the usb_ids of the objects that generate the trace
  messages. These IDs are unique compared to the device address used previously,
  because device addresses are per bus while usb_ids are global. This makes
  trace output from devices across multiple controllers distinguishable.
* Some cleanup.


Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/BusManager.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -12,6 +12,7 @@
 
 BusManager::BusManager(Stack *stack)
 	:	fInitOK(false),
+		fStack(stack),
 		fRootHub(NULL)
 {
 	mutex_init(&amp;fLock, &quot;usb busmanager lock&quot;);
@@ -86,7 +87,7 @@
 		address = (address + 1) % 127;
 	}
 
-	TRACE_ERROR((&quot;USB BusManager: the busmanager has run out of device addresses\n&quot;));
+	TRACE_ERROR(&quot;the busmanager has run out of device addresses\n&quot;);
 	Unlock();
 	return -1;
 }
@@ -103,7 +104,7 @@
 		return;
 
 	if (!fDeviceMap[address]) {
-		TRACE_ERROR((&quot;USB BusManager: freeing address %d which was not allocated\n&quot;, address));
+		TRACE_ERROR(&quot;freeing address %d which was not allocated\n&quot;, address);
 	}
 
 	fDeviceMap[address] = false;
@@ -118,15 +119,15 @@
 	// Check if there is a free entry in the device map (for the device number)
 	int8 deviceAddress = AllocateAddress();
 	if (deviceAddress &lt; 0) {
-		TRACE_ERROR((&quot;USB BusManager: could not allocate an address\n&quot;));
+		TRACE_ERROR(&quot;could not allocate an address\n&quot;);
 		return NULL;
 	}
 
-	TRACE((&quot;USB BusManager: setting device address to %d\n&quot;, deviceAddress));
+	TRACE(&quot;setting device address to %d\n&quot;, deviceAddress);
 	ControlPipe *defaultPipe = _GetDefaultPipe(speed);
 
 	if (!defaultPipe) {
-		TRACE_ERROR((&quot;USB BusManager: error getting the default pipe for speed %d\n&quot;, (int)speed));
+		TRACE_ERROR(&quot;error getting the default pipe for speed %d\n&quot;, speed);
 		FreeAddress(deviceAddress);
 		return NULL;
 	}
@@ -153,7 +154,7 @@
 	}
 
 	if (result &lt; B_OK) {
-		TRACE_ERROR((&quot;USB BusManager: error while setting device address\n&quot;));
+		TRACE_ERROR(&quot;error while setting device address\n&quot;);
 		FreeAddress(deviceAddress);
 		return NULL;
 	}
@@ -173,7 +174,7 @@
 	size_t actualLength = 0;
 	usb_device_descriptor deviceDescriptor;
 
-	TRACE((&quot;USB BusManager: getting the device descriptor\n&quot;));
+	TRACE(&quot;getting the device descriptor\n&quot;);
 	pipe.SendRequest(
 		USB_REQTYPE_DEVICE_IN | USB_REQTYPE_STANDARD,		// type
 		USB_REQUEST_GET_DESCRIPTOR,							// request
@@ -185,33 +186,33 @@
 		&amp;actualLength);										// actual length
 
 	if (actualLength != 8) {
-		TRACE_ERROR((&quot;USB BusManager: error while getting the device descriptor\n&quot;));
+		TRACE_ERROR(&quot;error while getting the device descriptor\n&quot;);
 		FreeAddress(deviceAddress);
 		return NULL;
 	}
 
-	TRACE((&quot;short device descriptor for device %d:\n&quot;, deviceAddress));
-	TRACE((&quot;\tlength:..............%d\n&quot;, deviceDescriptor.length));
-	TRACE((&quot;\tdescriptor_type:.....0x%04x\n&quot;, deviceDescriptor.descriptor_type));
-	TRACE((&quot;\tusb_version:.........0x%04x\n&quot;, deviceDescriptor.usb_version));
-	TRACE((&quot;\tdevice_class:........0x%02x\n&quot;, deviceDescriptor.device_class));
-	TRACE((&quot;\tdevice_subclass:.....0x%02x\n&quot;, deviceDescriptor.device_subclass));
-	TRACE((&quot;\tdevice_protocol:.....0x%02x\n&quot;, deviceDescriptor.device_protocol));
-	TRACE((&quot;\tmax_packet_size_0:...%d\n&quot;, deviceDescriptor.max_packet_size_0));
+	TRACE(&quot;short device descriptor for device %d:\n&quot;, deviceAddress);
+	TRACE(&quot;\tlength:..............%d\n&quot;, deviceDescriptor.length);
+	TRACE(&quot;\tdescriptor_type:.....0x%04x\n&quot;, deviceDescriptor.descriptor_type);
+	TRACE(&quot;\tusb_version:.........0x%04x\n&quot;, deviceDescriptor.usb_version);
+	TRACE(&quot;\tdevice_class:........0x%02x\n&quot;, deviceDescriptor.device_class);
+	TRACE(&quot;\tdevice_subclass:.....0x%02x\n&quot;, deviceDescriptor.device_subclass);
+	TRACE(&quot;\tdevice_protocol:.....0x%02x\n&quot;, deviceDescriptor.device_protocol);
+	TRACE(&quot;\tmax_packet_size_0:...%d\n&quot;, deviceDescriptor.max_packet_size_0);
 
 	// Create a new instance based on the type (Hub or Device)
 	if (deviceDescriptor.device_class == 0x09) {
-		TRACE((&quot;USB BusManager: creating new hub\n&quot;));
+		TRACE(&quot;creating new hub\n&quot;);
 		Hub *hub = new(std::nothrow) Hub(parent, hubAddress, hubPort,
 			deviceDescriptor, deviceAddress, speed, false);
 		if (!hub) {
-			TRACE_ERROR((&quot;USB BusManager: no memory to allocate hub\n&quot;));
+			TRACE_ERROR(&quot;no memory to allocate hub\n&quot;);
 			FreeAddress(deviceAddress);
 			return NULL;
 		}
 
 		if (hub-&gt;InitCheck() &lt; B_OK) {
-			TRACE_ERROR((&quot;USB BusManager: hub failed init check\n&quot;));
+			TRACE_ERROR(&quot;hub failed init check\n&quot;);
 			FreeAddress(deviceAddress);
 			delete hub;
 			return NULL;
@@ -220,17 +221,17 @@
 		return (Device *)hub;
 	}
 
-	TRACE((&quot;USB BusManager: creating new device\n&quot;));
+	TRACE(&quot;creating new device\n&quot;);
 	Device *device = new(std::nothrow) Device(parent, hubAddress, hubPort,
 		deviceDescriptor, deviceAddress, speed, false);
 	if (!device) {
-		TRACE_ERROR((&quot;USB BusManager: no memory to allocate device\n&quot;));
+		TRACE_ERROR(&quot;no memory to allocate device\n&quot;);
 		FreeAddress(deviceAddress);
 		return NULL;
 	}
 
 	if (device-&gt;InitCheck() &lt; B_OK) {
-		TRACE_ERROR((&quot;USB BusManager: device failed init check\n&quot;));
+		TRACE_ERROR(&quot;device failed init check\n&quot;);
 		FreeAddress(deviceAddress);
 		delete device;
 		return NULL;
@@ -298,7 +299,7 @@
 	}
 
 	if (!fDefaultPipes[speed]) {
-		TRACE_ERROR((&quot;USB BusManager: failed to allocate default pipe for speed %d\n&quot;, speed));
+		TRACE_ERROR(&quot;failed to allocate default pipe for speed %d\n&quot;, speed);
 	}
 
 	Unlock();

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Device.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Device.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Device.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -25,11 +25,11 @@
 		fHubAddress(hubAddress),
 		fHubPort(hubPort)
 {
-	TRACE((&quot;USB Device %d: creating device\n&quot;, fDeviceAddress));
+	TRACE(&quot;creating device\n&quot;);
 
 	fDefaultPipe = new(std::nothrow) ControlPipe(this);
 	if (!fDefaultPipe) {
-		TRACE_ERROR((&quot;USB Device %d: could not allocate default pipe\n&quot;, fDeviceAddress));
+		TRACE_ERROR(&quot;could not allocate default pipe\n&quot;);
 		return;
 	}
 
@@ -43,32 +43,31 @@
 		(void *)&amp;fDeviceDescriptor, sizeof(fDeviceDescriptor), &amp;actualLength);
 
 	if (status &lt; B_OK || actualLength != sizeof(fDeviceDescriptor)) {
-		TRACE_ERROR((&quot;USB Device %d: error while getting the device descriptor\n&quot;, fDeviceAddress));
+		TRACE_ERROR(&quot;error while getting the device descriptor\n&quot;);
 		return;
 	}
 
-	TRACE((&quot;full device descriptor for device %d:\n&quot;, fDeviceAddress));
-	TRACE((&quot;\tlength:..............%d\n&quot;, fDeviceDescriptor.length));
-	TRACE((&quot;\tdescriptor_type:.....0x%04x\n&quot;, fDeviceDescriptor.descriptor_type));
-	TRACE((&quot;\tusb_version:.........0x%04x\n&quot;, fDeviceDescriptor.usb_version));
-	TRACE((&quot;\tdevice_class:........0x%02x\n&quot;, fDeviceDescriptor.device_class));
-	TRACE((&quot;\tdevice_subclass:.....0x%02x\n&quot;, fDeviceDescriptor.device_subclass));
-	TRACE((&quot;\tdevice_protocol:.....0x%02x\n&quot;, fDeviceDescriptor.device_protocol));
-	TRACE((&quot;\tmax_packet_size_0:...%d\n&quot;, fDeviceDescriptor.max_packet_size_0));
-	TRACE((&quot;\tvendor_id:...........0x%04x\n&quot;, fDeviceDescriptor.vendor_id));
-	TRACE((&quot;\tproduct_id:..........0x%04x\n&quot;, fDeviceDescriptor.product_id));
-	TRACE((&quot;\tdevice_version:......0x%04x\n&quot;, fDeviceDescriptor.device_version));
-	TRACE((&quot;\tmanufacturer:........0x%02x\n&quot;, fDeviceDescriptor.manufacturer));
-	TRACE((&quot;\tproduct:.............0x%02x\n&quot;, fDeviceDescriptor.product));
-	TRACE((&quot;\tserial_number:.......0x%02x\n&quot;, fDeviceDescriptor.serial_number));
-	TRACE((&quot;\tnum_configurations:..%d\n&quot;, fDeviceDescriptor.num_configurations));
+	TRACE(&quot;full device descriptor for device %d:\n&quot;, fDeviceAddress);
+	TRACE(&quot;\tlength:..............%d\n&quot;, fDeviceDescriptor.length);
+	TRACE(&quot;\tdescriptor_type:.....0x%04x\n&quot;, fDeviceDescriptor.descriptor_type);
+	TRACE(&quot;\tusb_version:.........0x%04x\n&quot;, fDeviceDescriptor.usb_version);
+	TRACE(&quot;\tdevice_class:........0x%02x\n&quot;, fDeviceDescriptor.device_class);
+	TRACE(&quot;\tdevice_subclass:.....0x%02x\n&quot;, fDeviceDescriptor.device_subclass);
+	TRACE(&quot;\tdevice_protocol:.....0x%02x\n&quot;, fDeviceDescriptor.device_protocol);
+	TRACE(&quot;\tmax_packet_size_0:...%d\n&quot;, fDeviceDescriptor.max_packet_size_0);
+	TRACE(&quot;\tvendor_id:...........0x%04x\n&quot;, fDeviceDescriptor.vendor_id);
+	TRACE(&quot;\tproduct_id:..........0x%04x\n&quot;, fDeviceDescriptor.product_id);
+	TRACE(&quot;\tdevice_version:......0x%04x\n&quot;, fDeviceDescriptor.device_version);
+	TRACE(&quot;\tmanufacturer:........0x%02x\n&quot;, fDeviceDescriptor.manufacturer);
+	TRACE(&quot;\tproduct:.............0x%02x\n&quot;, fDeviceDescriptor.product);
+	TRACE(&quot;\tserial_number:.......0x%02x\n&quot;, fDeviceDescriptor.serial_number);
+	TRACE(&quot;\tnum_configurations:..%d\n&quot;, fDeviceDescriptor.num_configurations);
 
 	// Get the configurations
 	fConfigurations = (usb_configuration_info *)malloc(
 		fDeviceDescriptor.num_configurations * sizeof(usb_configuration_info));
 	if (fConfigurations == NULL) {
-		TRACE_ERROR((&quot;USB Device %d: out of memory during config creations!\n&quot;,
-			fDeviceAddress));
+		TRACE_ERROR(&quot;out of memory during config creations!\n&quot;);
 		return;
 	}
 
@@ -81,25 +80,23 @@
 			&amp;actualLength);
 
 		if (status &lt; B_OK || actualLength != sizeof(usb_configuration_descriptor)) {
-			TRACE_ERROR((&quot;USB Device %d: error fetching configuration %ld\n&quot;,
-				fDeviceAddress, i));
+			TRACE_ERROR(&quot;error fetching configuration %ld\n&quot;, i);
 			return;
 		}
 
-		TRACE((&quot;USB Device %d: configuration %ld\n&quot;, fDeviceAddress, i));
-		TRACE((&quot;\tlength:..............%d\n&quot;, configDescriptor.length));
-		TRACE((&quot;\tdescriptor_type:.....0x%02x\n&quot;, configDescriptor.descriptor_type));
-		TRACE((&quot;\ttotal_length:........%d\n&quot;, configDescriptor.total_length));
-		TRACE((&quot;\tnumber_interfaces:...%d\n&quot;, configDescriptor.number_interfaces));
-		TRACE((&quot;\tconfiguration_value:.0x%02x\n&quot;, configDescriptor.configuration_value));
-		TRACE((&quot;\tconfiguration:.......0x%02x\n&quot;, configDescriptor.configuration));
-		TRACE((&quot;\tattributes:..........0x%02x\n&quot;, configDescriptor.attributes));
-		TRACE((&quot;\tmax_power:...........%d\n&quot;, configDescriptor.max_power));
+		TRACE(&quot;configuration %ld\n&quot;, i);
+		TRACE(&quot;\tlength:..............%d\n&quot;, configDescriptor.length);
+		TRACE(&quot;\tdescriptor_type:.....0x%02x\n&quot;, configDescriptor.descriptor_type);
+		TRACE(&quot;\ttotal_length:........%d\n&quot;, configDescriptor.total_length);
+		TRACE(&quot;\tnumber_interfaces:...%d\n&quot;, configDescriptor.number_interfaces);
+		TRACE(&quot;\tconfiguration_value:.0x%02x\n&quot;, configDescriptor.configuration_value);
+		TRACE(&quot;\tconfiguration:.......0x%02x\n&quot;, configDescriptor.configuration);
+		TRACE(&quot;\tattributes:..........0x%02x\n&quot;, configDescriptor.attributes);
+		TRACE(&quot;\tmax_power:...........%d\n&quot;, configDescriptor.max_power);
 
 		uint8 *configData = (uint8 *)malloc(configDescriptor.total_length);
 		if (configData == NULL) {
-			TRACE_ERROR((&quot;USB Device %d: out of memory when reading config\n&quot;,
-				fDeviceAddress));
+			TRACE_ERROR(&quot;out of memory when reading config\n&quot;);
 			return;
 		}
 
@@ -107,9 +104,9 @@
 			(void *)configData, configDescriptor.total_length, &amp;actualLength);
 
 		if (status &lt; B_OK || actualLength != configDescriptor.total_length) {
-			TRACE_ERROR((&quot;USB Device %d: error fetching full configuration&quot;
-				&quot; descriptor %ld got %lu expected %u\n&quot;, fDeviceAddress, i,
-				actualLength, configDescriptor.total_length));
+			TRACE_ERROR(&quot;error fetching full configuration&quot;
+				&quot; descriptor %ld got %lu expected %u\n&quot;, i,
+				actualLength, configDescriptor.total_length);
 			free(configData);
 			return;
 		}
@@ -121,8 +118,7 @@
 		fConfigurations[i].interface = (usb_interface_list *)malloc(
 			configuration-&gt;number_interfaces * sizeof(usb_interface_list));
 		if (fConfigurations[i].interface == NULL) {
-			TRACE_ERROR((&quot;USB Device %d: out of memory when creating interfaces\n&quot;,
-				fDeviceAddress));
+			TRACE_ERROR(&quot;out of memory when creating interfaces\n&quot;);
 			return;
 		}
 
@@ -134,18 +130,18 @@
 		while (descriptorStart &lt; actualLength) {
 			switch (configData[descriptorStart + 1]) {
 				case USB_DESCRIPTOR_INTERFACE: {
-					TRACE((&quot;USB Device %d: got interface descriptor\n&quot;, fDeviceAddress));
+					TRACE(&quot;got interface descriptor\n&quot;);
 					usb_interface_descriptor *interfaceDescriptor
 						= (usb_interface_descriptor *)&amp;configData[descriptorStart];
-					TRACE((&quot;\tlength:.............%d\n&quot;, interfaceDescriptor-&gt;length));
-					TRACE((&quot;\tdescriptor_type:....0x%02x\n&quot;, interfaceDescriptor-&gt;descriptor_type));
-					TRACE((&quot;\tinterface_number:...%d\n&quot;, interfaceDescriptor-&gt;interface_number));
-					TRACE((&quot;\talternate_setting:..%d\n&quot;, interfaceDescriptor-&gt;alternate_setting));
-					TRACE((&quot;\tnum_endpoints:......%d\n&quot;, interfaceDescriptor-&gt;num_endpoints));
-					TRACE((&quot;\tinterface_class:....0x%02x\n&quot;, interfaceDescriptor-&gt;interface_class));
-					TRACE((&quot;\tinterface_subclass:.0x%02x\n&quot;, interfaceDescriptor-&gt;interface_subclass));
-					TRACE((&quot;\tinterface_protocol:.0x%02x\n&quot;, interfaceDescriptor-&gt;interface_protocol));
-					TRACE((&quot;\tinterface:..........%d\n&quot;, interfaceDescriptor-&gt;interface));
+					TRACE(&quot;\tlength:.............%d\n&quot;, interfaceDescriptor-&gt;length);
+					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;, interfaceDescriptor-&gt;descriptor_type);
+					TRACE(&quot;\tinterface_number:...%d\n&quot;, interfaceDescriptor-&gt;interface_number);
+					TRACE(&quot;\talternate_setting:..%d\n&quot;, interfaceDescriptor-&gt;alternate_setting);
+					TRACE(&quot;\tnum_endpoints:......%d\n&quot;, interfaceDescriptor-&gt;num_endpoints);
+					TRACE(&quot;\tinterface_class:....0x%02x\n&quot;, interfaceDescriptor-&gt;interface_class);
+					TRACE(&quot;\tinterface_subclass:.0x%02x\n&quot;, interfaceDescriptor-&gt;interface_subclass);
+					TRACE(&quot;\tinterface_protocol:.0x%02x\n&quot;, interfaceDescriptor-&gt;interface_protocol);
+					TRACE(&quot;\tinterface:..........%d\n&quot;, interfaceDescriptor-&gt;interface);
 
 					usb_interface_list *interfaceList
 						= &amp;fConfigurations[i].interface[interfaceDescriptor-&gt;interface_number];
@@ -156,8 +152,8 @@
 						= (usb_interface_info *)realloc(interfaceList-&gt;alt,
 						interfaceList-&gt;alt_count * sizeof(usb_interface_info));
 					if (newAlternates == NULL) {
-						TRACE_ERROR((&quot;USB Device %d: out of memory allocating&quot;
-							&quot; alternate interface\n&quot;, fDeviceAddress));
+						TRACE_ERROR(&quot;out of memory allocating&quot;
+							&quot; alternate interface\n&quot;);
 						interfaceList-&gt;alt_count--;
 						return;
 					}
@@ -179,8 +175,8 @@
 					Interface *interface = new(std::nothrow) Interface(this,
 						interfaceDescriptor-&gt;interface_number);
 					if (interface == NULL) {
-						TRACE_ERROR((&quot;USB Device %d: failed to allocate&quot;
-							&quot; interface object\n&quot;, fDeviceAddress));
+						TRACE_ERROR(&quot;failed to allocate&quot;
+							&quot; interface object\n&quot;);
 						return;
 					}
 
@@ -190,15 +186,15 @@
 				}
 
 				case USB_DESCRIPTOR_ENDPOINT: {
-					TRACE((&quot;USB Device %d: got endpoint descriptor\n&quot;, fDeviceAddress));
+					TRACE(&quot;got endpoint descriptor\n&quot;);
 					usb_endpoint_descriptor *endpointDescriptor
 						= (usb_endpoint_descriptor *)&amp;configData[descriptorStart];
-					TRACE((&quot;\tlength:.............%d\n&quot;, endpointDescriptor-&gt;length));
-					TRACE((&quot;\tdescriptor_type:....0x%02x\n&quot;, endpointDescriptor-&gt;descriptor_type));
-					TRACE((&quot;\tendpoint_address:...0x%02x\n&quot;, endpointDescriptor-&gt;endpoint_address));
-					TRACE((&quot;\tattributes:.........0x%02x\n&quot;, endpointDescriptor-&gt;attributes));
-					TRACE((&quot;\tmax_packet_size:....%d\n&quot;, endpointDescriptor-&gt;max_packet_size));
-					TRACE((&quot;\tinterval:...........%d\n&quot;, endpointDescriptor-&gt;interval));
+					TRACE(&quot;\tlength:.............%d\n&quot;, endpointDescriptor-&gt;length);
+					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;, endpointDescriptor-&gt;descriptor_type);
+					TRACE(&quot;\tendpoint_address:...0x%02x\n&quot;, endpointDescriptor-&gt;endpoint_address);
+					TRACE(&quot;\tattributes:.........0x%02x\n&quot;, endpointDescriptor-&gt;attributes);
+					TRACE(&quot;\tmax_packet_size:....%d\n&quot;, endpointDescriptor-&gt;max_packet_size);
+					TRACE(&quot;\tinterval:...........%d\n&quot;, endpointDescriptor-&gt;interval);
 
 					if (!currentInterface)
 						break;
@@ -211,8 +207,8 @@
 						currentInterface-&gt;endpoint_count
 						* sizeof(usb_endpoint_info));
 					if (newEndpoints == NULL) {
-						TRACE_ERROR((&quot;USB Device %d: out of memory allocating&quot;
-							&quot; new endpoint\n&quot;, fDeviceAddress));
+						TRACE_ERROR(&quot;out of memory allocating&quot;
+							&quot; new endpoint\n&quot;);
 						currentInterface-&gt;endpoint_count--;
 						return;
 					}
@@ -228,11 +224,11 @@
 				}
 
 				default:
-					TRACE((&quot;USB Device %d: got generic descriptor\n&quot;, fDeviceAddress));
+					TRACE(&quot;got generic descriptor\n&quot;);
 					usb_generic_descriptor *genericDescriptor
 						= (usb_generic_descriptor *)&amp;configData[descriptorStart];
-					TRACE((&quot;\tlength:.............%d\n&quot;, genericDescriptor-&gt;length));
-					TRACE((&quot;\tdescriptor_type:....0x%02x\n&quot;, genericDescriptor-&gt;descriptor_type));
+					TRACE(&quot;\tlength:.............%d\n&quot;, genericDescriptor-&gt;length);
+					TRACE(&quot;\tdescriptor_type:....0x%02x\n&quot;, genericDescriptor-&gt;descriptor_type);
 
 					if (!currentInterface)
 						break;
@@ -244,8 +240,8 @@
 						currentInterface-&gt;generic_count
 						* sizeof(usb_descriptor *));
 					if (newGenerics == NULL) {
-						TRACE_ERROR((&quot;USB Device %d: out of memory allocating&quot;
-							&quot; generic descriptor\n&quot;, fDeviceAddress));
+						TRACE_ERROR(&quot;out of memory allocating&quot;
+							&quot; generic descriptor\n&quot;);
 						currentInterface-&gt;generic_count--;
 						return;
 					}
@@ -263,10 +259,9 @@
 	}
 
 	// Set default configuration
-	TRACE((&quot;USB Device %d: setting default configuration\n&quot;, fDeviceAddress));
+	TRACE(&quot;setting default configuration\n&quot;);
 	if (SetConfigurationAt(0) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Device %d: failed to set default configuration\n&quot;,
-			fDeviceAddress));
+		TRACE_ERROR(&quot;failed to set default configuration\n&quot;);
 		return;
 	}
 
@@ -468,8 +463,7 @@
 			}
 
 			if (pipe == NULL) {
-				TRACE_ERROR((&quot;USB Device %d: failed to allocate pipe\n&quot;,
-					fDeviceAddress));
+				TRACE_ERROR(&quot;failed to allocate pipe\n&quot;);
 				endpoint-&gt;handle = 0;
 				continue;
 			}
@@ -584,7 +578,7 @@
 	uint32 supportDescriptorCount, const usb_notify_hooks *hooks,
 	usb_driver_cookie **cookies, bool added, bool recursive)
 {
-	TRACE((&quot;USB Device %d: reporting device\n&quot;, fDeviceAddress));
+	TRACE(&quot;reporting device\n&quot;);
 	bool supported = false;
 	if (supportDescriptorCount == 0 || supportDescriptors == NULL)
 		supported = true;
@@ -685,6 +679,7 @@
 	if (!fAvailable)
 		return B_ERROR;
 
+	TRACE(&quot;set feature %u\n&quot;, selector);
 	return fDefaultPipe-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_OUT,
 		USB_REQUEST_SET_FEATURE,
@@ -703,6 +698,7 @@
 	if (!fAvailable)
 		return B_ERROR;
 
+	TRACE(&quot;clear feature %u\n&quot;, selector);
 	return fDefaultPipe-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_OUT,
 		USB_REQUEST_CLEAR_FEATURE,
@@ -721,6 +717,7 @@
 	if (!fAvailable)
 		return B_ERROR;
 
+	TRACE(&quot;get status\n&quot;);
 	return fDefaultPipe-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_DEVICE_IN,
 		USB_REQUEST_GET_STATUS,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Hub.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Hub.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Hub.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -18,14 +18,14 @@
 			isRootHub),
 		fInterruptPipe(NULL)
 {
-	TRACE((&quot;USB Hub %d: creating hub\n&quot;, DeviceAddress()));
+	TRACE(&quot;creating hub\n&quot;);
 
 	memset(&amp;fHubDescriptor, 0, sizeof(fHubDescriptor));
 	for (int32 i = 0; i &lt; USB_MAX_PORT_COUNT; i++)
 		fChildren[i] = NULL;
 
 	if (!fInitOK) {
-		TRACE_ERROR((&quot;USB Hub %d: device failed to initialize\n&quot;, DeviceAddress()));
+		TRACE_ERROR(&quot;device failed to initialize\n&quot;);
 		return;
 	}
 
@@ -33,33 +33,33 @@
 	fInitOK = false;
 
 	if (fDeviceDescriptor.device_class != 9) {
-		TRACE_ERROR((&quot;USB Hub %d: wrong class! bailing out\n&quot;, DeviceAddress()));
+		TRACE_ERROR(&quot;wrong class! bailing out\n&quot;);
 		return;
 	}
 
-	TRACE((&quot;USB Hub %d: Getting hub descriptor...\n&quot;, DeviceAddress()));
+	TRACE(&quot;getting hub descriptor...\n&quot;);
 	size_t actualLength;
 	status_t status = GetDescriptor(USB_DESCRIPTOR_HUB, 0, 0,
 		(void *)&amp;fHubDescriptor, sizeof(usb_hub_descriptor), &amp;actualLength);
 
 	// we need at least 8 bytes
 	if (status &lt; B_OK || actualLength &lt; 8) {
-		TRACE_ERROR((&quot;USB Hub %d: Error getting hub descriptor\n&quot;, DeviceAddress()));
+		TRACE_ERROR(&quot;error getting hub descriptor\n&quot;);
 		return;
 	}
 
-	TRACE((&quot;USB Hub %d: hub descriptor (%ld bytes):\n&quot;, DeviceAddress(), actualLength));
-	TRACE((&quot;\tlength:..............%d\n&quot;, fHubDescriptor.length));
-	TRACE((&quot;\tdescriptor_type:.....0x%02x\n&quot;, fHubDescriptor.descriptor_type));
-	TRACE((&quot;\tnum_ports:...........%d\n&quot;, fHubDescriptor.num_ports));
-	TRACE((&quot;\tcharacteristics:.....0x%04x\n&quot;, fHubDescriptor.characteristics));
-	TRACE((&quot;\tpower_on_to_power_g:.%d\n&quot;, fHubDescriptor.power_on_to_power_good));
-	TRACE((&quot;\tdevice_removeable:...0x%02x\n&quot;, fHubDescriptor.device_removeable));
-	TRACE((&quot;\tpower_control_mask:..0x%02x\n&quot;, fHubDescriptor.power_control_mask));
+	TRACE(&quot;hub descriptor (%ld bytes):\n&quot;, actualLength);
+	TRACE(&quot;\tlength:..............%d\n&quot;, fHubDescriptor.length);
+	TRACE(&quot;\tdescriptor_type:.....0x%02x\n&quot;, fHubDescriptor.descriptor_type);
+	TRACE(&quot;\tnum_ports:...........%d\n&quot;, fHubDescriptor.num_ports);
+	TRACE(&quot;\tcharacteristics:.....0x%04x\n&quot;, fHubDescriptor.characteristics);
+	TRACE(&quot;\tpower_on_to_power_g:.%d\n&quot;, fHubDescriptor.power_on_to_power_good);
+	TRACE(&quot;\tdevice_removeable:...0x%02x\n&quot;, fHubDescriptor.device_removeable);
+	TRACE(&quot;\tpower_control_mask:..0x%02x\n&quot;, fHubDescriptor.power_control_mask);
 
 	if (fHubDescriptor.num_ports &gt; USB_MAX_PORT_COUNT) {
-		TRACE_ERROR((&quot;USB Hub %d: hub supports more ports than we do (%d vs. %d)\n&quot;,
-			DeviceAddress(), fHubDescriptor.num_ports, USB_MAX_PORT_COUNT));
+		TRACE_ALWAYS(&quot;hub supports more ports than we do (%d vs. %d)\n&quot;,
+			fHubDescriptor.num_ports, USB_MAX_PORT_COUNT);
 		fHubDescriptor.num_ports = USB_MAX_PORT_COUNT;
 	}
 
@@ -70,7 +70,7 @@
 		fInterruptPipe-&gt;QueueInterrupt(fInterruptStatus,
 			sizeof(fInterruptStatus), InterruptCallback, this);
 	} else {
-		TRACE_ERROR((&quot;USB Hub %d: no interrupt pipe found\n&quot;, DeviceAddress()));
+		TRACE_ALWAYS(&quot;no interrupt pipe found\n&quot;);
 	}
 
 	// Wait some time before powering up the ports
@@ -83,14 +83,14 @@
 			USB_REQUEST_SET_FEATURE, PORT_POWER, i + 1, 0, NULL, 0, NULL);
 
 		if (status &lt; B_OK)
-			TRACE_ERROR((&quot;USB Hub %d: power up failed on port %ld\n&quot;, DeviceAddress(), i));
+			TRACE_ERROR(&quot;power up failed on port %ld\n&quot;, i);
 	}
 
 	// Wait for power to stabilize
 	snooze(fHubDescriptor.power_on_to_power_good * 2000);
 
 	fInitOK = true;
-	TRACE((&quot;USB Hub %d: initialised ok\n&quot;, DeviceAddress()));
+	TRACE(&quot;initialised ok\n&quot;);
 }
 
 
@@ -129,7 +129,7 @@
 		4, &amp;actualLength);
 
 	if (result &lt; B_OK || actualLength &lt; 4) {
-		TRACE_ERROR((&quot;USB Hub %d: error updating port status\n&quot;, DeviceAddress()));
+		TRACE_ERROR(&quot;error updating port status\n&quot;);
 		return B_ERROR;
 	}
 
@@ -160,7 +160,7 @@
 	}
 
 	if ((fPortStatus[index].change &amp; C_PORT_RESET) == 0) {
-		TRACE_ERROR((&quot;USB Hub %d: port %d won't reset\n&quot;, DeviceAddress(), index));
+		TRACE_ERROR(&quot;port %d won't reset\n&quot;, index);
 		return B_ERROR;
 	}
 
@@ -172,7 +172,7 @@
 
 	// wait for reset recovery
 	snooze(USB_DELAY_PORT_RESET_RECOVERY);
-	TRACE((&quot;USB Hub %d: port %d was reset successfully\n&quot;, DeviceAddress(), index));
+	TRACE(&quot;port %d was reset successfully\n&quot;, index);
 	return B_OK;
 }
 
@@ -197,8 +197,10 @@
 
 #ifdef TRACE_USB
 		if (fPortStatus[i].change) {
-			TRACE((&quot;USB Hub %d: port %ld: status: 0x%04x; change: 0x%04x\n&quot;, DeviceAddress(), i, fPortStatus[i].status, fPortStatus[i].change));
-			TRACE((&quot;USB Hub %d: device at port %ld: 0x%08lx\n&quot;, DeviceAddress(), i, fChildren[i]));
+			TRACE(&quot;port %ld: status: 0x%04x; change: 0x%04x\n&quot;, i,
+				fPortStatus[i].status, fPortStatus[i].change);
+			TRACE(&quot;device at port %ld: %p (%ld)\n&quot;, i, fChildren[i],
+				fChildren[i] != NULL ? fChildren[i]-&gt;USBID() : 0);
 		}
 #endif
 
@@ -210,7 +212,7 @@
 
 			if (fPortStatus[i].status &amp; PORT_STATUS_CONNECTION) {
 				// new device attached!
-				TRACE((&quot;USB Hub %d: new device connected\n&quot;, DeviceAddress()));
+				TRACE_ALWAYS(&quot;port %ld: new device connected\n&quot;, i);
 
 				// wait some time for the device to power up
 				snooze(USB_DELAY_DEVICE_POWER_UP);
@@ -218,7 +220,7 @@
 				// reset the port, this will also enable it
 				result = ResetPort(i);
 				if (result &lt; B_OK) {
-					TRACE_ERROR((&quot;USB Hub %d: resetting port %ld failed\n&quot;, DeviceAddress(), i));
+					TRACE_ERROR(&quot;resetting port %ld failed\n&quot;, i);
 					continue;
 				}
 
@@ -228,12 +230,12 @@
 
 				if ((fPortStatus[i].status &amp; PORT_STATUS_CONNECTION) == 0) {
 					// device has vanished after reset, ignore
-					TRACE((&quot;USB Hub %d: device disappeared on reset\n&quot;, DeviceAddress()));
+					TRACE(&quot;device disappeared on reset\n&quot;);
 					continue;
 				}
 
-				if (fChildren[i]) {
-					TRACE_ERROR((&quot;USB Hub %d: new device on a port that is already in use\n&quot;, DeviceAddress()));
+				if (fChildren[i] != NULL) {
+					TRACE_ERROR(&quot;new device on a port that is already in use\n&quot;);
 					fChildren[i]-&gt;Changed(changeList, false);
 					fChildren[i] = NULL;
 				}
@@ -251,7 +253,7 @@
 				int8 hubAddress = HubAddress();
 				uint8 hubPort = HubPort();
 				if (Speed() == USB_SPEED_HIGHSPEED) {
-					hubAddress = DeviceAddress();
+					hubAddress = USBID();
 					hubPort = i + 1;
 				}
 
@@ -269,9 +271,9 @@
 				}
 			} else {
 				// Device removed...
-				TRACE((&quot;USB Hub %d: device removed\n&quot;, DeviceAddress()));
-				if (fChildren[i]) {
-					TRACE((&quot;USB Hub %d: removing device 0x%08lx\n&quot;, DeviceAddress(), fChildren[i]));
+				TRACE_ALWAYS(&quot;port %ld: device removed\n&quot;, i);
+				if (fChildren[i] != NULL) {
+					TRACE(&quot;removing device %p\n&quot;, fChildren[i]);
 					fChildren[i]-&gt;Changed(changeList, false);
 					fChildren[i] = NULL;
 				}
@@ -280,28 +282,28 @@
 
 		// other port changes we do not really handle, report and clear them
 		if (fPortStatus[i].change &amp; PORT_STATUS_ENABLE) {
-			TRACE_ERROR((&quot;USB Hub %d: port %ld %sabled\n&quot;, DeviceAddress(), i, (fPortStatus[i].status &amp; PORT_STATUS_ENABLE) ? &quot;en&quot; : &quot;dis&quot;));
+			TRACE_ALWAYS(&quot;port %ld %sabled\n&quot;, i, (fPortStatus[i].status &amp; PORT_STATUS_ENABLE) ? &quot;en&quot; : &quot;dis&quot;);
 			DefaultPipe()-&gt;SendRequest(USB_REQTYPE_CLASS | USB_REQTYPE_OTHER_OUT,
 				USB_REQUEST_CLEAR_FEATURE, C_PORT_ENABLE, i + 1,
 				0, NULL, 0, NULL);
 		}
 
 		if (fPortStatus[i].change &amp; PORT_STATUS_SUSPEND) {
-			TRACE_ERROR((&quot;USB Hub %d: port %ld is %ssuspended\n&quot;, DeviceAddress(), i, (fPortStatus[i].status &amp; PORT_STATUS_SUSPEND) ? &quot;&quot; : &quot;not &quot;));
+			TRACE_ALWAYS(&quot;port %ld is %ssuspended\n&quot;, i, (fPortStatus[i].status &amp; PORT_STATUS_SUSPEND) ? &quot;&quot; : &quot;not &quot;);
 			DefaultPipe()-&gt;SendRequest(USB_REQTYPE_CLASS | USB_REQTYPE_OTHER_OUT,
 				USB_REQUEST_CLEAR_FEATURE, C_PORT_SUSPEND, i + 1,
 				0, NULL, 0, NULL);
 		}
 
 		if (fPortStatus[i].change &amp; PORT_STATUS_OVER_CURRENT) {
-			TRACE_ERROR((&quot;USB Hub %d: port %ld is %sin an over current state\n&quot;, DeviceAddress(), i, (fPortStatus[i].status &amp; PORT_STATUS_OVER_CURRENT) ? &quot;&quot; : &quot;not &quot;));
+			TRACE_ALWAYS(&quot;port %ld is %sin an over current state\n&quot;, i, (fPortStatus[i].status &amp; PORT_STATUS_OVER_CURRENT) ? &quot;&quot; : &quot;not &quot;);
 			DefaultPipe()-&gt;SendRequest(USB_REQTYPE_CLASS | USB_REQTYPE_OTHER_OUT,
 				USB_REQUEST_CLEAR_FEATURE, C_PORT_OVER_CURRENT, i + 1,
 				0, NULL, 0, NULL);
 		}
 
 		if (fPortStatus[i].change &amp; PORT_RESET) {
-			TRACE_ERROR((&quot;USB Hub %d: port %ld was reset\n&quot;, DeviceAddress(), i));
+			TRACE_ALWAYS(&quot;port %ld was reset\n&quot;, i);
 			DefaultPipe()-&gt;SendRequest(USB_REQTYPE_CLASS | USB_REQTYPE_OTHER_OUT,
 				USB_REQUEST_CLEAR_FEATURE, C_PORT_RESET, i + 1,
 				0, NULL, 0, NULL);
@@ -322,7 +324,7 @@
 Hub::InterruptCallback(void *cookie, status_t status, void *data,
 	size_t actualLength)
 {
-	TRACE((&quot;USB Hub %d: interrupt callback!\n&quot;, ((Hub *)data)-&gt;DeviceAddress()));
+	TRACE_STATIC((Hub *)cookie, &quot;interrupt callback!\n&quot;);
 }
 
 
@@ -347,7 +349,7 @@
 	uint32 supportDescriptorCount, const usb_notify_hooks *hooks,
 	usb_driver_cookie **cookies, bool added, bool recursive)
 {
-	TRACE((&quot;USB Hub %d: reporting hub\n&quot;, DeviceAddress()));
+	TRACE(&quot;reporting hub\n&quot;);
 
 	// Report ourselfs first
 	status_t result = Device::ReportDevice(supportDescriptors,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Interface.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Interface.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -13,12 +13,14 @@
 	:	Object(parent),
 		fInterfaceIndex(interfaceIndex)
 {
+	TRACE(&quot;creating interface\n&quot;);
 }
 
 
 status_t
 Interface::SetFeature(uint16 selector)
 {
+	TRACE(&quot;set feature %u\n&quot;, selector);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_INTERFACE_OUT,
 		USB_REQUEST_SET_FEATURE,
@@ -34,6 +36,7 @@
 status_t
 Interface::ClearFeature(uint16 selector)
 {
+	TRACE(&quot;clear feature %u\n&quot;, selector);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_INTERFACE_OUT,
 		USB_REQUEST_CLEAR_FEATURE,
@@ -49,6 +52,7 @@
 status_t
 Interface::GetStatus(uint16 *status)
 {
+	TRACE(&quot;get status\n&quot;);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_INTERFACE_IN,
 		USB_REQUEST_GET_STATUS,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Object.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Object.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Object.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -37,7 +37,7 @@
 Object::SetFeature(uint16 selector)
 {
 	// to be implemented in subclasses
-	TRACE_ERROR((&quot;USB Object: set feature called\n&quot;));
+	TRACE_ERROR(&quot;set feature called\n&quot;);
 	return B_ERROR;
 }
 
@@ -46,7 +46,7 @@
 Object::ClearFeature(uint16 selector)
 {
 	// to be implemented in subclasses
-	TRACE_ERROR((&quot;USB Object: clear feature called\n&quot;));
+	TRACE_ERROR(&quot;clear feature called\n&quot;);
 	return B_ERROR;
 }
 
@@ -55,6 +55,6 @@
 Object::GetStatus(uint16 *status)
 {
 	// to be implemented in subclasses
-	TRACE_ERROR((&quot;USB Object: get status called\n&quot;));
+	TRACE_ERROR(&quot;get status called\n&quot;);
 	return B_ERROR;
 }

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Pipe.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Pipe.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Pipe.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -69,6 +69,7 @@
 status_t
 Pipe::SetFeature(uint16 selector)
 {
+	TRACE(&quot;set feature %u\n&quot;, selector);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_ENDPOINT_OUT,
 		USB_REQUEST_SET_FEATURE,
@@ -89,6 +90,7 @@
 	if (selector == USB_FEATURE_ENDPOINT_HALT)
 		SetDataToggle(false);
 
+	TRACE(&quot;clear feature %u\n&quot;, selector);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_ENDPOINT_OUT,
 		USB_REQUEST_CLEAR_FEATURE,
@@ -105,6 +107,7 @@
 status_t
 Pipe::GetStatus(uint16 *status)
 {
+	TRACE(&quot;get status\n&quot;);
 	return ((Device *)Parent())-&gt;DefaultPipe()-&gt;SendRequest(
 		USB_REQTYPE_STANDARD | USB_REQTYPE_ENDPOINT_IN,
 		USB_REQUEST_GET_STATUS,
@@ -336,7 +339,7 @@
 	// The sem will be released unconditionally in the callback after the
 	// result data was filled in. Use a 1 second timeout for control transfers.
 	if (acquire_sem_etc(fNotifySem, 1, B_RELATIVE_TIMEOUT, 1000000) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB ControlPipe: timeout waiting for queued request to complete\n&quot;));
+		TRACE_ERROR(&quot;timeout waiting for queued request to complete\n&quot;);
 
 		CancelQueuedTransfers(false);
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Stack.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -26,7 +26,7 @@
 		fObjectArray(NULL),
 		fDriverList(NULL)
 {
-	TRACE((&quot;USB Stack: stack init\n&quot;));
+	TRACE(&quot;stack init\n&quot;);
 
 	mutex_init(&amp;fStackLock, &quot;usb stack lock&quot;);
 	mutex_init(&amp;fExploreLock, &quot;usb explore lock&quot;);
@@ -34,7 +34,7 @@
 	size_t objectArraySize = fObjectMaxCount * sizeof(Object *);
 	fObjectArray = (Object **)malloc(objectArraySize);
 	if (fObjectArray == NULL) {
-		TRACE_ERROR((&quot;USB Stack: failed to allocate object array\n&quot;));
+		TRACE_ERROR(&quot;failed to allocate object array\n&quot;);
 		return;
 	}
 
@@ -43,7 +43,7 @@
 	fAllocator = new(std::nothrow) PhysicalMemoryAllocator(&quot;USB Stack Allocator&quot;,
 		8, B_PAGE_SIZE * 4, 64);
 	if (!fAllocator || fAllocator-&gt;InitCheck() &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Stack: failed to allocate the allocator\n&quot;));
+		TRACE_ERROR(&quot;failed to allocate the allocator\n&quot;);
 		delete fAllocator;
 		fAllocator = NULL;
 		return;
@@ -66,25 +66,25 @@
 		NULL
 	};
 
-	TRACE((&quot;USB Stack: looking for host controller modules\n&quot;));
+	TRACE(&quot;looking for host controller modules\n&quot;);
 	for (uint32 i = 0; moduleNames[i]; i++) {
-		TRACE((&quot;USB Stack: looking for module %s\n&quot;, moduleNames[i]));
+		TRACE(&quot;looking for module %s\n&quot;, moduleNames[i]);
 
 		usb_host_controller_info *module = NULL;
 		if (get_module(moduleNames[i], (module_info **)&amp;module) != B_OK)
 			continue;
 
-		TRACE((&quot;USB Stack: adding module %s\n&quot;, moduleNames[i]));
+		TRACE(&quot;adding module %s\n&quot;, moduleNames[i]);
 		if (module-&gt;add_to(this) &lt; B_OK) {
 			put_module(moduleNames[i]);
 			continue;
 		}
 
-		TRACE((&quot;USB Stack: module %s successfully loaded\n&quot;, moduleNames[i]));
+		TRACE(&quot;module %s successfully loaded\n&quot;, moduleNames[i]);
 	}
 
 	if (fBusManagers.Count() == 0) {
-		TRACE_ERROR((&quot;USB Stack: no bus managers available\n&quot;));
+		TRACE_ERROR(&quot;no bus managers available\n&quot;);
 		return;
 	}
 
@@ -164,7 +164,7 @@
 		id = (id + 1) % fObjectMaxCount;
 	}
 
-	TRACE_ERROR((&quot;USB Stack: the stack did run out of usb_ids\n&quot;));
+	TRACE_ERROR(&quot;the stack did run out of usb_ids\n&quot;);
 	Unlock();
 	return 0;
 }
@@ -177,7 +177,7 @@
 		return;
 
 	if (id &gt;= fObjectMaxCount) {
-		TRACE_ERROR((&quot;USB Stack: tried to put an invalid usb_id\n&quot;));
+		TRACE_ERROR(&quot;tried to put an invalid usb_id\n&quot;);
 		Unlock();
 		return;
 	}
@@ -194,7 +194,7 @@
 		return NULL;
 
 	if (id &gt;= fObjectMaxCount) {
-		TRACE_ERROR((&quot;USB Stack: tried to get object with invalid usb_id\n&quot;));
+		TRACE_ERROR(&quot;tried to get object with invalid usb_id\n&quot;);
 		Unlock();
 		return NULL;
 	}
@@ -285,7 +285,7 @@
 Stack::AllocateArea(void **logicalAddress, void **physicalAddress, size_t size,
 	const char *name)
 {
-	TRACE((&quot;USB Stack: allocating %ld bytes for %s\n&quot;, size, name));
+	TRACE(&quot;allocating %ld bytes for %s\n&quot;, size, name);
 
 	void *logAddress;
 	size = (size + B_PAGE_SIZE - 1) &amp; ~(B_PAGE_SIZE - 1);
@@ -293,7 +293,7 @@
 		B_CONTIGUOUS, 0);
 
 	if (area &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Stack: couldn't allocate area %s\n&quot;, name));
+		TRACE_ERROR(&quot;couldn't allocate area %s\n&quot;, name);
 		return B_ERROR;
 	}
 
@@ -301,7 +301,7 @@
 	status_t result = get_memory_map(logAddress, size, &amp;physicalEntry, 1);
 	if (result &lt; B_OK) {
 		delete_area(area);
-		TRACE_ERROR((&quot;USB Stack: couldn't map area %s\n&quot;, name));
+		TRACE_ERROR(&quot;couldn't map area %s\n&quot;, name);
 		return B_ERROR;
 	}
 
@@ -312,8 +312,8 @@
 	if (physicalAddress)
 		*physicalAddress = physicalEntry.address;
 
-	TRACE((&quot;USB Stack: area = 0x%08lx, size = %ld, log = 0x%08lx, phy = 0x%08lx\n&quot;,
-		area, size, logAddress, physicalEntry.address));
+	TRACE(&quot;area = %ld, size = %ld, log = %p, phy = %p\n&quot;,
+		area, size, logAddress, physicalEntry.address);
 	return area;
 }
 
@@ -321,7 +321,7 @@
 void
 Stack::NotifyDeviceChange(Device *device, rescan_item **rescanList, bool added)
 {
-	TRACE((&quot;USB Stack: device %s\n&quot;, added ? &quot;added&quot; : &quot;removed&quot;));
+	TRACE(&quot;device %s\n&quot;, added ? &quot;added&quot; : &quot;removed&quot;);
 
 	usb_driver_info *element = fDriverList;
 	while (element) {
@@ -393,7 +393,7 @@
 	const usb_support_descriptor *descriptors,
 	size_t descriptorCount, const char *republishDriverName)
 {
-	TRACE((&quot;USB Stack: register driver \&quot;%s\&quot;\n&quot;, driverName));
+	TRACE(&quot;register driver \&quot;%s\&quot;\n&quot;, driverName);
 	if (!driverName)
 		return B_BAD_VALUE;
 
@@ -457,7 +457,7 @@
 status_t
 Stack::InstallNotify(const char *driverName, const usb_notify_hooks *hooks)
 {
-	TRACE((&quot;USB Stack: installing notify hooks for driver \&quot;%s\&quot;\n&quot;, driverName));
+	TRACE(&quot;installing notify hooks for driver \&quot;%s\&quot;\n&quot;, driverName);
 
 	usb_driver_info *element = fDriverList;
 	while (element) {
@@ -492,7 +492,7 @@
 status_t
 Stack::UninstallNotify(const char *driverName)
 {
-	TRACE((&quot;USB Stack: uninstalling notify hooks for driver \&quot;%s\&quot;\n&quot;, driverName));
+	TRACE(&quot;uninstalling notify hooks for driver \&quot;%s\&quot;\n&quot;, driverName);
 
 	usb_driver_info *element = fDriverList;
 	while (element) {

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/usb/Transfer.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/usb/Transfer.cpp	2009-01-24 00:31:16 UTC (rev 29001)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/usb/Transfer.cpp	2009-01-24 01:28:31 UTC (rev 29002)
@@ -71,7 +71,7 @@
 	// Calculate the bandwidth (only if it is not a bulk transfer)
 	if (!(fPipe-&gt;Type() &amp; USB_OBJECT_BULK_PIPE)) {
 		if (_CalculateBandwidth() &lt; B_OK)
-			TRACE_ERROR((&quot;USB Transfer: can't calculate bandwidth\n&quot;));
+			TRACE_ERROR(&quot;can't calculate bandwidth\n&quot;);
 	}
 }
 
@@ -135,8 +135,7 @@
 		if (IS_USER_ADDRESS(vector[i].iov_base)) {
 			fUserArea = area_for(vector[i].iov_base);
 			if (fUserArea &lt; B_OK) {
-				TRACE_ERROR((&quot;USB Transfer: failed to find area for user&quot;
-					&quot; space buffer!\n&quot;));
+				TRACE_ERROR(&quot;failed to find area for user space buffer!\n&quot;);
 				return B_BAD_ADDRESS;
 			}
 			break;
@@ -149,7 +148,7 @@
 
 	area_info areaInfo;
 	if (fUserArea &lt; B_OK || get_area_info(fUserArea, &amp;areaInfo) &lt; B_OK) {
-		TRACE_ERROR((&quot;USB Transfer: couldn't get user area info\n&quot;));
+		TRACE_ERROR(&quot;couldn't get user area info\n&quot;);
 		return B_BAD_ADDRESS;
 	}
 
@@ -158,7 +157,7 @@
 
 		if ((size_t)vector[i].iov_base &gt; areaInfo.size
 			|| (size_t)vector[i].iov_base + vector[i].iov_len &gt; areaInfo.size) {
-			TRACE_ERROR((&quot;USB Transfer: data buffer spans across multiple areas!\n&quot;));
+			TRACE_ERROR(&quot;data buffer spans across multiple areas!\n&quot;);
 			return B_BAD_ADDRESS;
 		}
 	}
@@ -264,7 +263,7 @@
 
 		default:
 			// We should never get here
-			TRACE((&quot;USB Transfer: speed unknown&quot;));
+			TRACE(&quot;speed unknown&quot;);
 			return B_ERROR;
 	}

[... truncated: 2744 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="014060.html">[Haiku-commits] r29001 - haiku/trunk/src/add-ons/kernel/file_systems/bfs
</A></li>
	<LI>Next message: <A HREF="014052.html">[Haiku-commits] r29003 - haiku/trunk/src/data/etc/keymaps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#14051">[ date ]</a>
              <a href="thread.html#14051">[ thread ]</a>
              <a href="subject.html#14051">[ subject ]</a>
              <a href="author.html#14051">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
