<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r20430 - in	haiku/trunk/src/add-ons/kernel/network/ppp/shared:	libkernelppp libppp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20430%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/network/ppp/shared%3A%0A%09libkernelppp%20libppp&In-Reply-To=%3C200703270014.l2R0EY98029631%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001216.html">
   <LINK REL="Next"  HREF="001219.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r20430 - in	haiku/trunk/src/add-ons/kernel/network/ppp/shared:	libkernelppp libppp</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20430%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/network/ppp/shared%3A%0A%09libkernelppp%20libppp&In-Reply-To=%3C200703270014.l2R0EY98029631%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r20430 - in	haiku/trunk/src/add-ons/kernel/network/ppp/shared:	libkernelppp libppp">axeld at mail.berlios.de
       </A><BR>
    <I>Tue Mar 27 02:14:34 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001216.html">[Haiku-commits] r20429 - haiku/trunk/src/bin/strace
</A></li>
        <LI>Next message: <A HREF="001219.html">[Haiku-commits] r20430 - in	haiku/trunk/src/add-ons/kernel/network/ppp/shared:	libkernelppp libppp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1218">[ date ]</a>
              <a href="thread.html#1218">[ thread ]</a>
              <a href="subject.html#1218">[ subject ]</a>
              <a href="author.html#1218">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-03-27 02:14:30 +0200 (Tue, 27 Mar 2007)
New Revision: 20430
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=20430&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=20430&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPConfigurePacket.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPDevice.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPInterface.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPLCP.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPLCPExtension.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPLayer.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPOptionHandler.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPProtocol.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPReportManager.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPStateMachine.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPUtils.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/_KPPPAuthenticationHandler.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/_KPPPMRUHandler.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/_KPPPPFCHandler.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/settings_tools.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/MessageDriverSettingsUtils.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/PPPInterface.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/PPPInterfaceListener.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/PPPManager.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/_libppputils.cpp
   haiku/trunk/src/add-ons/kernel/network/ppp/shared/libppp/_libppputils.h
Log:
Style cleanup, patch by Vasilis Kaoutsis - thanks!


Modified: haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPConfigurePacket.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPConfigurePacket.cpp	2007-03-26 22:27:15 UTC (rev 20429)
+++ haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPConfigurePacket.cpp	2007-03-27 00:14:30 UTC (rev 20430)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
+ * Copyright 2003-2007, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
  * Distributed under the terms of the MIT License.
  */
 
@@ -33,21 +33,21 @@
 	ppp_lcp_packet *header = mtod(packet, ppp_lcp_packet*);
 	
 	SetID(header-&gt;id);
-	if(!SetCode(header-&gt;code))
+	if (!SetCode(header-&gt;code))
 		return;
 	
 	uint16 length = ntohs(header-&gt;length);
 	
-	if(length &lt; 6 || length &gt; packet-&gt;m_len)
+	if (length &lt; 6 || length &gt; packet-&gt;m_len)
 		return;
 			// there are no items (or one corrupted item)
 	
 	int32 position = 0;
 	ppp_configure_item *item;
 	
-	while(position &lt; length - 4) {
+	while (position &lt; length - 4) {
 		item = (ppp_configure_item*) (header-&gt;data + position);
-		if(item-&gt;length &lt; 2)
+		if (item-&gt;length &lt; 2)
 			return;
 				// found a corrupted item
 		
@@ -60,7 +60,7 @@
 //!	Frees all items.
 KPPPConfigurePacket::~KPPPConfigurePacket()
 {
-	for(int32 index = 0; index &lt; CountItems(); index++)
+	for (int32 index = 0; index &lt; CountItems(); index++)
 		free(ItemAt(index));
 }
 
@@ -70,7 +70,7 @@
 KPPPConfigurePacket::SetCode(uint8 code)
 {
 	// only configure codes are allowed!
-	if(code &lt; PPP_CONFIGURE_REQUEST || code &gt; PPP_CONFIGURE_REJECT)
+	if (code &lt; PPP_CONFIGURE_REQUEST || code &gt; PPP_CONFIGURE_REJECT)
 		return false;
 	
 	fCode = code;
@@ -94,18 +94,18 @@
 bool
 KPPPConfigurePacket::AddItem(const ppp_configure_item *item, int32 index)
 {
-	if(!item || item-&gt;length &lt; 2)
+	if (!item || item-&gt;length &lt; 2)
 		return false;
 	
 	ppp_configure_item *add = (ppp_configure_item*) malloc(item-&gt;length);
 	memcpy(add, item, item-&gt;length);
 	
 	bool status;
-	if(index &lt; 0)
+	if (index &lt; 0)
 		status = fItems.AddItem(add);
 	else
 		status = fItems.AddItem(add, index);
-	if(!status) {
+	if (!status) {
 		free(add);
 		return false;
 	}
@@ -118,7 +118,7 @@
 bool
 KPPPConfigurePacket::RemoveItem(ppp_configure_item *item)
 {
-	if(!fItems.HasItem(item))
+	if (!fItems.HasItem(item))
 		return false;
 	
 	fItems.RemoveItem(item);
@@ -134,7 +134,7 @@
 {
 	ppp_configure_item *item = fItems.ItemAt(index);
 	
-	if(item == fItems.GetDefaultItem())
+	if (item == fItems.GetDefaultItem())
 		return NULL;
 	
 	return item;
@@ -147,9 +147,9 @@
 {
 	ppp_configure_item *item;
 	
-	for(int32 index = 0; index &lt; CountItems(); index++) {
+	for (int32 index = 0; index &lt; CountItems(); index++) {
 		item = ItemAt(index);
-		if(item &amp;&amp; item-&gt;type == type)
+		if (item &amp;&amp; item-&gt;type == type)
 			return item;
 	}
 	
@@ -180,11 +180,11 @@
 	uint16 length = 0;
 	ppp_configure_item *item;
 	
-	for(int32 index = 0; index &lt; CountItems(); index++) {
+	for (int32 index = 0; index &lt; CountItems(); index++) {
 		item = ItemAt(index);
 		
 		// make sure we have enough space left
-		if(MRU - length &lt; item-&gt;length) {
+		if (MRU - length &lt; item-&gt;length) {
 			m_freem(packet);
 			return NULL;
 		}

Modified: haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPDevice.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPDevice.cpp	2007-03-26 22:27:15 UTC (rev 20429)
+++ haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPDevice.cpp	2007-03-27 00:14:30 UTC (rev 20430)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
+ * Copyright 2003-2007, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
  * Distributed under the terms of the MIT License.
  */
 
@@ -40,7 +40,7 @@
 //!	Destructor. Removes device from interface.
 KPPPDevice::~KPPPDevice()
 {
-	if(Interface().Device() == this)
+	if (Interface().Device() == this)
 		Interface().SetDevice(NULL);
 }
 
@@ -52,26 +52,26 @@
 status_t
 KPPPDevice::Control(uint32 op, void *data, size_t length)
 {
-	switch(op) {
-		case PPPC_GET_DEVICE_INFO: {
-			if(length &lt; sizeof(ppp_device_info_t) || !data)
+	switch (op) {
+		case PPPC_GET_DEVICE_INFO: 
+			if (length &lt; sizeof(ppp_device_info_t) || !data)
 				return B_NO_MEMORY;
-			
+
 			ppp_device_info *info = (ppp_device_info*) data;
 			memset(info, 0, sizeof(ppp_device_info_t));
-			if(Name())
+			if (Name())
 				strncpy(info-&gt;name, Name(), PPP_HANDLER_NAME_LENGTH_LIMIT);
 			info-&gt;MTU = MTU();
 			info-&gt;inputTransferRate = InputTransferRate();
 			info-&gt;outputTransferRate = OutputTransferRate();
 			info-&gt;outputBytesCount = CountOutputBytes();
 			info-&gt;isUp = IsUp();
-		} break;
-		
+			break;
+
 		default:
 			return B_BAD_VALUE;
 	}
-	
+
 	return B_OK;
 }
 
@@ -90,7 +90,7 @@
 KPPPDevice::Receive(struct mbuf *packet, uint16 protocolNumber)
 {
 	// let the interface handle the packet
-	if(protocolNumber == 0)
+	if (protocolNumber == 0)
 		return Interface().ReceiveFromDevice(packet);
 	else
 		return Interface().Receive(packet, protocolNumber);

Modified: haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPInterface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPInterface.cpp	2007-03-26 22:27:15 UTC (rev 20429)
+++ haiku/trunk/src/add-ons/kernel/network/ppp/shared/libkernelppp/KPPPInterface.cpp	2007-03-27 00:14:30 UTC (rev 20430)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2006, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
+ * Copyright 2003-2007, Waldemar Kornewald &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wkornew at gmx.net</A>&gt;
  * Distributed under the terms of the MIT License.
  */
 
@@ -77,9 +77,9 @@
 	\param parent (Optional): Interface's parent (only used for multilink interfaces).
 */
 KPPPInterface::KPPPInterface(const char *name, ppp_interface_entry *entry,
-		ppp_interface_id ID, const driver_settings *settings,
-		KPPPInterface *parent)
-	: KPPPLayer(name, PPP_INTERFACE_LEVEL, 2),
+	ppp_interface_id ID, const driver_settings *settings, KPPPInterface *parent)
+	:
+	KPPPLayer(name, PPP_INTERFACE_LEVEL, 2),
 	fID(ID),
 	fSettings(NULL),
 	fIfnet(NULL),
@@ -111,14 +111,14 @@
 {
 	entry-&gt;interface = this;
 	
-	if(name) {
+	if (name) {
 		// load settings from description file
 		char path[B_PATH_NAME_LENGTH];
 		sprintf(path, &quot;ptpnet/%s&quot;, name);
 			// XXX: TODO: change base path to &quot;/etc/ptpnet&quot;
 		
 		void *handle = load_driver_settings(path);
-		if(!handle) {
+		if (!handle) {
 			fInitStatus = B_ERROR;
 			return;
 		}
@@ -129,28 +129,28 @@
 		fSettings = dup_driver_settings(settings);
 			// use the given settings
 	
-	if(!fSettings) {
+	if (!fSettings) {
 		fInitStatus = B_ERROR;
 		return;
 	}
 	
 	// add internal modules
 	// LCP
-	if(!AddProtocol(&amp;LCP())) {
+	if (!AddProtocol(&amp;LCP())) {
 		fInitStatus = B_ERROR;
 		return;
 	}
 	// MRU
 	_KPPPMRUHandler *mruHandler =
 		new _KPPPMRUHandler(*this);
-	if(!LCP().AddOptionHandler(mruHandler) || mruHandler-&gt;InitCheck() != B_OK) {
+	if (!LCP().AddOptionHandler(mruHandler) || mruHandler-&gt;InitCheck() != B_OK) {
 		ERROR(&quot;KPPPInterface: Could not add MRU handler!\n&quot;);
 		delete mruHandler;
 	}
 	// authentication
 	_KPPPAuthenticationHandler *authenticationHandler =
 		new _KPPPAuthenticationHandler(*this);
-	if(!LCP().AddOptionHandler(authenticationHandler)
+	if (!LCP().AddOptionHandler(authenticationHandler)
 			|| authenticationHandler-&gt;InitCheck() != B_OK) {
 		ERROR(&quot;KPPPInterface: Could not add authentication handler!\n&quot;);
 		delete authenticationHandler;
@@ -158,7 +158,7 @@
 	// PFC
 	_KPPPPFCHandler *pfcHandler =
 		new _KPPPPFCHandler(fLocalPFCState, fPeerPFCState, *this);
-	if(!LCP().AddOptionHandler(pfcHandler) || pfcHandler-&gt;InitCheck() != B_OK) {
+	if (!LCP().AddOptionHandler(pfcHandler) || pfcHandler-&gt;InitCheck() != B_OK) {
 		ERROR(&quot;KPPPInterface: Could not add PFC handler!\n&quot;);
 		delete pfcHandler;
 	}
@@ -169,11 +169,11 @@
 	fReconnectDelay = 1000;
 		// 1s delay between lost connection and reconnect
 	
-	if(get_module(PPP_INTERFACE_MODULE_NAME, (module_info**) &amp;fManager) != B_OK)
+	if (get_module(PPP_INTERFACE_MODULE_NAME, (module_info**) &amp;fManager) != B_OK)
 		ERROR(&quot;KPPPInterface: Manager module not found!\n&quot;);
 	
 	// are we a multilink subinterface?
-	if(parent &amp;&amp; parent-&gt;IsMultilink()) {
+	if (parent &amp;&amp; parent-&gt;IsMultilink()) {
 		fParent = parent;
 		fParent-&gt;AddChild(this);
 		fIsMultilink = true;
@@ -181,7 +181,7 @@
 	
 	RegisterInterface();
 	
-	if(!fSettings) {
+	if (!fSettings) {
 		fInitStatus = B_ERROR;
 		return;
 	}
@@ -196,17 +196,17 @@
 	
 	// get DisonnectAfterIdleSince settings
 	value = get_settings_value(PPP_DISONNECT_AFTER_IDLE_SINCE_KEY, fSettings);
-	if(!value)
+	if (!value)
 		fDisconnectAfterIdleSince = 0;
 	else
 		fDisconnectAfterIdleSince = atoi(value) * 1000;
 	
-	if(fDisconnectAfterIdleSince &lt; 0)
+	if (fDisconnectAfterIdleSince &lt; 0)
 		fDisconnectAfterIdleSince = 0;
 	
 	// get mode settings
 	value = get_settings_value(PPP_MODE_KEY, fSettings);
-	if(value &amp;&amp; !strcasecmp(value, PPP_SERVER_MODE_VALUE))
+	if (value &amp;&amp; !strcasecmp(value, PPP_SERVER_MODE_VALUE))
 		fMode = PPP_SERVER_MODE;
 	else
 		fMode = PPP_CLIENT_MODE;
@@ -223,7 +223,7 @@
 		get_settings_value(PPP_ASK_BEFORE_CONNECTING_KEY, fSettings), false);
 	
 	// load all protocols and the device
-	if(!LoadModules(fSettings, 0, fSettings-&gt;parameter_count)) {
+	if (!LoadModules(fSettings, 0, fSettings-&gt;parameter_count)) {
 		ERROR(&quot;KPPPInterface: Error loading modules!\n&quot;);
 		fInitStatus = B_ERROR;
 	}
@@ -237,21 +237,21 @@
 	
 	// tell protocols to uninit (remove routes, etc.)
 	KPPPProtocol *protocol = FirstProtocol();
-	for(; protocol; protocol = protocol-&gt;NextProtocol())
+	for (; protocol; protocol = protocol-&gt;NextProtocol())
 		protocol-&gt;Uninit();
 	
 	// make sure we are not accessible by any thread before we continue
 	UnregisterInterface();
 	
-	if(fManager)
+	if (fManager)
 		fManager-&gt;RemoveInterface(ID());
 	
 	// Call Down() until we get a lock on an interface that is down.
 	// This lock is not released until we are actually deleted.
-	while(true) {
+	while (true) {
 		Down();
 		fLock.Lock();
-		if(State() == PPP_INITIAL_STATE &amp;&amp; Phase() == PPP_DOWN_PHASE)
+		if (State() == PPP_INITIAL_STATE &amp;&amp; Phase() == PPP_DOWN_PHASE)
 			break;
 		fLock.Unlock();
 	}
@@ -264,30 +264,30 @@
 		// tell thread that we are being destroyed (200ms timeout)
 	wait_for_thread(fReconnectThread, &amp;tmp);
 	
-	while(CountChildren())
+	while (CountChildren())
 		delete ChildAt(0);
 	
 	delete Device();
 	
-	while(FirstProtocol()) {
-		if(FirstProtocol() == &amp;LCP())
+	while (FirstProtocol()) {
+		if (FirstProtocol() == &amp;LCP())
 			fFirstProtocol = fFirstProtocol-&gt;NextProtocol();
 		else
 			delete FirstProtocol();
 				// destructor removes protocol from list
 	}
 	
-	for(int32 index = 0; index &lt; fModules.CountItems(); index++) {
+	for (int32 index = 0; index &lt; fModules.CountItems(); index++) {
 		put_module(fModules.ItemAt(index));
 		delete[] fModules.ItemAt(index);
 	}
 	
 	free_driver_settings(fSettings);
 	
-	if(Parent())
+	if (Parent())
 		Parent()-&gt;RemoveChild(this);
 	
-	if(fManager)
+	if (fManager)
 		put_module(PPP_INTERFACE_MODULE_NAME);
 }
 
@@ -298,7 +298,7 @@
 {
 	LockerHelper locker(fLock);
 	
-	if(fDeleteCounter &gt; 0)
+	if (fDeleteCounter &gt; 0)
 		return;
 			// only one thread should delete us!
 	
@@ -314,17 +314,17 @@
 status_t
 KPPPInterface::InitCheck() const
 {
-	if(fInitStatus != B_OK)
+	if (fInitStatus != B_OK)
 		return fInitStatus;
 	
-	if(!fSettings || !fManager)
+	if (!fSettings || !fManager)
 		return B_ERROR;
 	
 	// sub-interfaces should have a device
-	if(IsMultilink()) {
-		if(Parent() &amp;&amp; !fDevice)
+	if (IsMultilink()) {
+		if (Parent() &amp;&amp; !fDevice)
 			return B_ERROR;
-	} else if(!fDevice)
+	} else if (!fDevice)
 		return B_ERROR;
 	
 	return B_OK;
@@ -336,7 +336,7 @@
 KPPPInterface::Username() const
 {
 	// this data is not available before we authenticate
-	if(Phase() &lt; PPP_AUTHENTICATION_PHASE)
+	if (Phase() &lt; PPP_AUTHENTICATION_PHASE)
 		return NULL;
 	
 	return fUsername;
@@ -348,7 +348,7 @@
 KPPPInterface::Password() const
 {
 	// this data is not available before we authenticate
-	if(Phase() &lt; PPP_AUTHENTICATION_PHASE)
+	if (Phase() &lt; PPP_AUTHENTICATION_PHASE)
 		return NULL;
 	
 	return fPassword;
@@ -361,7 +361,7 @@
 {
 	TRACE(&quot;KPPPInterface: SetMRU(%ld)\n&quot;, MRU);
 	
-	if(Device() &amp;&amp; MRU &gt; Device()-&gt;MTU() - 2)
+	if (Device() &amp;&amp; MRU &gt; Device()-&gt;MTU() - 2)
 		return false;
 	
 	LockerHelper locker(fLock);
@@ -380,7 +380,7 @@
 {
 	uint32 overhead = fHeaderLength + 2;
 	
-	if(Device())
+	if (Device())
 		overhead += Device()-&gt;Overhead();
 	
 	return overhead;
@@ -406,16 +406,17 @@
 status_t
 KPPPInterface::Control(uint32 op, void *data, size_t length)
 {
-	switch(op) {
-		case PPPC_GET_INTERFACE_INFO: {
-			if(length &lt; sizeof(ppp_interface_info_t) || !data)
+	switch (op) {
+		case PPPC_GET_INTERFACE_INFO:
+		{
+			if (length &lt; sizeof(ppp_interface_info_t) || !data)
 				return B_ERROR;
-			
+
 			ppp_interface_info *info = (ppp_interface_info*) data;
 			memset(info, 0, sizeof(ppp_interface_info_t));
-			if(Name())
+			if (Name())
 				strncpy(info-&gt;name, Name(), PPP_HANDLER_NAME_LENGTH_LIMIT);
-			if(Ifnet())
+			if (Ifnet())
 				info-&gt;if_unit = Ifnet()-&gt;if_unit;
 			else
 				info-&gt;if_unit = -1;
@@ -447,168 +448,182 @@
 			info-&gt;hasDevice = Device();
 			info-&gt;isMultilink = IsMultilink();
 			info-&gt;hasParent = Parent();
-		} break;
-		
-		case PPPC_SET_USERNAME: {
-			if(!data)
+			break;
+		}
+
+		case PPPC_SET_USERNAME:
+		{
+			if (!data)
 				return B_ERROR;
-			
+
 			LockerHelper locker(fLock);
 			// login information can only be changed before we authenticate
-			if(Phase() &gt;= PPP_AUTHENTICATION_PHASE)
+			if (Phase() &gt;= PPP_AUTHENTICATION_PHASE)
 				return B_NOT_ALLOWED;
-			
+
 			free(fUsername);
 			fUsername = data ? strdup((const char*) data) : strdup(&quot;&quot;);
-		} break;
-		
-		case PPPC_SET_PASSWORD: {
-			if(!data)
+			break;
+		}
+
+		case PPPC_SET_PASSWORD:
+		{
+			if (!data)
 				return B_ERROR;
 			
 			LockerHelper locker(fLock);
 			// login information can only be changed before we authenticate
-			if(Phase() &gt;= PPP_AUTHENTICATION_PHASE)
+			if (Phase() &gt;= PPP_AUTHENTICATION_PHASE)
 				return B_NOT_ALLOWED;
 			
 			free(fPassword);
 			fPassword = data ? strdup((const char*) data) : strdup(&quot;&quot;);
-		} break;
-		
+			break;
+		}
+
 		case PPPC_SET_ASK_BEFORE_CONNECTING:
-			if(length &lt; sizeof(uint32) || !data)
+			if (length &lt; sizeof(uint32) || !data)
 				return B_ERROR;
-			
+
 			SetAskBeforeConnecting(*((uint32*)data));
-		break;
-		
+			break;
+
 		case PPPC_SET_MRU:
-			if(length &lt; sizeof(uint32) || !data)
+			if (length &lt; sizeof(uint32) || !data)
 				return B_ERROR;
-			
+
 			SetMRU(*((uint32*)data));
-		break;
-		
+			break;
+
 		case PPPC_SET_CONNECT_ON_DEMAND:
-			if(length &lt; sizeof(uint32) || !data)
+			if (length &lt; sizeof(uint32) || !data)
 				return B_ERROR;
-			
+
 			SetConnectOnDemand(*((uint32*)data));
-		break;
-		
+			break;
+
 		case PPPC_SET_AUTO_RECONNECT:
-			if(length &lt; sizeof(uint32) || !data)
+			if (length &lt; sizeof(uint32) || !data)
 				return B_ERROR;
 			
 			SetAutoReconnect(*((uint32*)data));
-		break;
-		
+			break;
+
 		case PPPC_HAS_INTERFACE_SETTINGS:
-			if(length &lt; sizeof(driver_settings) || !data)
+			if (length &lt; sizeof(driver_settings) || !data)
 				return B_ERROR;
-			
-			if(equal_interface_settings(Settings(), (driver_settings*) data))
+
+			if (equal_interface_settings(Settings(), (driver_settings*) data))
 				return B_OK;
 			else
 				return B_ERROR;
-		break;
-		
-		case PPPC_ENABLE_REPORTS: {
-			if(length &lt; sizeof(ppp_report_request) || !data)
+			break;
+
+		case PPPC_ENABLE_REPORTS:
+		{
+			if (length &lt; sizeof(ppp_report_request) || !data)
 				return B_ERROR;
-			
+
 			LockerHelper locker(fLock);
 			ppp_report_request *request = (ppp_report_request*) data;
 			// first, we send an initial state report
-			if(request-&gt;type == PPP_CONNECTION_REPORT) {
+			if (request-&gt;type == PPP_CONNECTION_REPORT) {
 				ppp_report_packet report;
 				report.type = PPP_CONNECTION_REPORT;
 				report.code = StateMachine().fLastConnectionReportCode;
 				report.length = sizeof(fID);
 				KPPPReportManager::SendReport(request-&gt;thread, &amp;report);
-				if(request-&gt;flags &amp; PPP_REMOVE_AFTER_REPORT)
+				if (request-&gt;flags &amp; PPP_REMOVE_AFTER_REPORT)
 					return B_OK;
 			}
 			ReportManager().EnableReports(request-&gt;type, request-&gt;thread,
 				request-&gt;flags);
-		} break;
-		
-		case PPPC_DISABLE_REPORTS: {
-			if(length &lt; sizeof(ppp_report_request) || !data)
+			break;
+		}
+
+		case PPPC_DISABLE_REPORTS:
+		{
+			if (length &lt; sizeof(ppp_report_request) || !data)
 				return B_ERROR;
-			
+
 			ppp_report_request *request = (ppp_report_request*) data;
 			ReportManager().DisableReports(request-&gt;type, request-&gt;thread);
-		} break;
-		
-		case PPPC_GET_STATISTICS: {
-			if(length &lt; sizeof(ppp_statistics) || !data)
+			break;
+		}
+
+		case PPPC_GET_STATISTICS:
+			if (length &lt; sizeof(ppp_statistics) || !data)
 				return B_ERROR;
-			
+
 			memcpy(data, &amp;fStatistics, sizeof(ppp_statistics));
-		} break;
-		
-		case PPPC_CONTROL_DEVICE: {
-			if(length &lt; sizeof(ppp_control_info) || !data)
+			break;
+
+		case PPPC_CONTROL_DEVICE:
+		{
+			if (length &lt; sizeof(ppp_control_info) || !data)
 				return B_ERROR;
 			
 			ppp_control_info *control = (ppp_control_info*) data;
-			if(control-&gt;index != 0 || !Device())
+			if (control-&gt;index != 0 || !Device())
 				return B_BAD_INDEX;
-			
+
 			return Device()-&gt;Control(control-&gt;op, control-&gt;data, control-&gt;length);
-		} break;
-		
-		case PPPC_CONTROL_PROTOCOL: {
-			if(length &lt; sizeof(ppp_control_info) || !data)
+		}
+
+		case PPPC_CONTROL_PROTOCOL:
+		{
+			if (length &lt; sizeof(ppp_control_info) || !data)
 				return B_ERROR;
 			
 			ppp_control_info *control = (ppp_control_info*) data;
 			KPPPProtocol *protocol = ProtocolAt(control-&gt;index);
-			if(!protocol)
+			if (!protocol)
 				return B_BAD_INDEX;
 			
 			return protocol-&gt;Control(control-&gt;op, control-&gt;data, control-&gt;length);
-		} break;
-		
-		case PPPC_CONTROL_OPTION_HANDLER: {
-			if(length &lt; sizeof(ppp_control_info) || !data)
+		}
+
+		case PPPC_CONTROL_OPTION_HANDLER:
+		{
+			if (length &lt; sizeof(ppp_control_info) || !data)
 				return B_ERROR;
-			
+
 			ppp_control_info *control = (ppp_control_info*) data;
 			KPPPOptionHandler *optionHandler = LCP().OptionHandlerAt(control-&gt;index);
-			if(!optionHandler)
+			if (!optionHandler)
 				return B_BAD_INDEX;
-			
+
 			return optionHandler-&gt;Control(control-&gt;op, control-&gt;data,
 				control-&gt;length);
-		} break;
-		
-		case PPPC_CONTROL_LCP_EXTENSION: {
-			if(length &lt; sizeof(ppp_control_info) || !data)
+		}
+
+		case PPPC_CONTROL_LCP_EXTENSION: 
+		{
+			if (length &lt; sizeof(ppp_control_info) || !data)
 				return B_ERROR;
-			
+
 			ppp_control_info *control = (ppp_control_info*) data;
 			KPPPLCPExtension *lcpExtension = LCP().LCPExtensionAt(control-&gt;index);
-			if(!lcpExtension)
+			if (!lcpExtension)
 				return B_BAD_INDEX;
-			
+
 			return lcpExtension-&gt;Control(control-&gt;op, control-&gt;data,
 				control-&gt;length);
-		} break;
-		
-		case PPPC_CONTROL_CHILD: {
-			if(length &lt; sizeof(ppp_control_info) || !data)
+		}
+
+		case PPPC_CONTROL_CHILD:
+		{
+			if (length &lt; sizeof(ppp_control_info) || !data)
 				return B_ERROR;
-			
+
 			ppp_control_info *control = (ppp_control_info*) data;
 			KPPPInterface *child = ChildAt(control-&gt;index);
-			if(!child)
+			if (!child)
 				return B_BAD_INDEX;
-			
+
 			return child-&gt;Control(control-&gt;op, control-&gt;data, control-&gt;length);
-		} break;
-		
+		}
+
 		default:
 			return B_BAD_VALUE;
 	}
@@ -634,26 +649,26 @@
 {
 	TRACE(&quot;KPPPInterface: SetDevice(%p)\n&quot;, device);
 	
-	if(device &amp;&amp; &amp;device-&gt;Interface() != this)
+	if (device &amp;&amp; &amp;device-&gt;Interface() != this)
 		return false;
 	
-	if(IsMultilink() &amp;&amp; !Parent())
+	if (IsMultilink() &amp;&amp; !Parent())
 		return false;
 			// main interfaces do not have devices
 	
 	LockerHelper locker(fLock);
 	
-	if(Phase() != PPP_DOWN_PHASE)
+	if (Phase() != PPP_DOWN_PHASE)
 		return false;
 			// a running connection may not change
 	
-	if(fDevice &amp;&amp; (IsUp() || fDevice-&gt;IsUp()))
+	if (fDevice &amp;&amp; (IsUp() || fDevice-&gt;IsUp()))
 		Down();
 	
 	fDevice = device;
 	SetNext(device);
 	
-	if(fDevice)
+	if (fDevice)
 		fMRU = fDevice-&gt;MTU() - 2;
 	
 	CalculateInterfaceMTU();
@@ -685,28 +700,28 @@
 	TRACE(&quot;KPPPInterface: AddProtocol(%X)\n&quot;,
 		protocol ? protocol-&gt;ProtocolNumber() : 0);
 	
-	if(!protocol || &amp;protocol-&gt;Interface() != this
+	if (!protocol || &amp;protocol-&gt;Interface() != this
 			|| protocol-&gt;Level() == PPP_INTERFACE_LEVEL)
 		return false;
 	
 	LockerHelper locker(fLock);
 	
-	if(Phase() != PPP_DOWN_PHASE)
+	if (Phase() != PPP_DOWN_PHASE)
 		return false;
 			// a running connection may not change
 	
 	KPPPProtocol *current = fFirstProtocol, *previous = NULL;
 	
-	while(current) {
-		if(current-&gt;Level() &lt; protocol-&gt;Level())
+	while (current) {
+		if (current-&gt;Level() &lt; protocol-&gt;Level())
 			break;
 		
 		previous = current;
 		current = current-&gt;NextProtocol();
 	}
 	
-	if(!current) {
-		if(!previous)
+	if (!current) {
+		if (!previous)
 			fFirstProtocol = protocol;
 		else
 			previous-&gt;SetNextProtocol(protocol);
@@ -719,16 +734,16 @@
 	} else {
 		protocol-&gt;SetNextProtocol(current);
 		
-		if(!previous)
+		if (!previous)
 			fFirstProtocol = protocol;
 		else
 			previous-&gt;SetNextProtocol(protocol);
 	}
 	
-	if(protocol-&gt;Level() &lt; PPP_PROTOCOL_LEVEL)
+	if (protocol-&gt;Level() &lt; PPP_PROTOCOL_LEVEL)
 		CalculateInterfaceMTU();
 	
-	if(IsUp() || Phase() &gt;= protocol-&gt;ActivationPhase())
+	if (IsUp() || Phase() &gt;= protocol-&gt;ActivationPhase())
 		protocol-&gt;Up();
 	
 	return true;
@@ -755,22 +770,22 @@
 	
 	LockerHelper locker(fLock);
 	
-	if(Phase() != PPP_DOWN_PHASE)
+	if (Phase() != PPP_DOWN_PHASE)
 		return false;
 			// a running connection may not change
 	
 	KPPPProtocol *current = fFirstProtocol, *previous = NULL;
 	
-	while(current) {
-		if(current == protocol) {
-			if(!protocol-&gt;IsDown())
+	while (current) {
+		if (current == protocol) {
+			if (!protocol-&gt;IsDown())
 				protocol-&gt;Down();
 			
-			if(previous) {
+			if (previous) {
 				previous-&gt;SetNextProtocol(current-&gt;NextProtocol());
 				
 				// set us as next layer if needed
-				if(!previous-&gt;Next())
+				if (!previous-&gt;Next())
 					previous-&gt;SetNext(this);
 			} else
 				fFirstProtocol = current-&gt;NextProtocol();
@@ -799,7 +814,7 @@
 	KPPPProtocol *protocol = FirstProtocol();
 	
 	int32 count = 0;
-	for(; protocol; protocol = protocol-&gt;NextProtocol())
+	for (; protocol; protocol = protocol-&gt;NextProtocol())
 		++count;
 	
 	return count;
@@ -815,7 +830,7 @@
 	KPPPProtocol *protocol = FirstProtocol();
 	
 	int32 currentIndex = 0;
-	for(; protocol &amp;&amp; currentIndex != index; protocol = protocol-&gt;NextProtocol())
+	for (; protocol &amp;&amp; currentIndex != index; protocol = protocol-&gt;NextProtocol())
 		++currentIndex;
 	
 	return protocol;
@@ -838,8 +853,8 @@
 	
 	KPPPProtocol *current = start ? start : FirstProtocol();
 	
-	for(; current; current = current-&gt;NextProtocol()) {
-		if(current-&gt;ProtocolNumber() == protocolNumber
+	for (; current; current = current-&gt;NextProtocol()) {
+		if (current-&gt;ProtocolNumber() == protocolNumber
 				|| (current-&gt;Flags() &amp; PPP_INCLUDES_NCP
 					&amp;&amp; (current-&gt;ProtocolNumber() &amp; 0x7FFF)
 						== (protocolNumber &amp; 0x7FFF)))
@@ -856,12 +871,12 @@
 {
 	TRACE(&quot;KPPPInterface: AddChild(%lX)\n&quot;, child ? child-&gt;ID() : 0);
 	
-	if(!child)
+	if (!child)
 		return false;
 	
 	LockerHelper locker(fLock);
 	
-	if(fChildren.HasItem(child) || !fChildren.AddItem(child))
+	if (fChildren.HasItem(child) || !fChildren.AddItem(child))
 		return false;
 	
 	child-&gt;SetParent(this);
@@ -878,13 +893,13 @@
 	
 	LockerHelper locker(fLock);
 	
-	if(!fChildren.RemoveItem(child))
+	if (!fChildren.RemoveItem(child))
 		return false;
 	
 	child-&gt;SetParent(NULL);
 	
 	// parents cannot exist without their children
-	if(CountChildren() == 0 &amp;&amp; fManager &amp;&amp; Ifnet())
+	if (CountChildren() == 0 &amp;&amp; fManager &amp;&amp; Ifnet())
 		Delete();
 	
 	return true;
@@ -901,7 +916,7 @@
 	
 	KPPPInterface *child = fChildren.ItemAt(index);
 	
-	if(child == fChildren.GetDefaultItem())
+	if (child == fChildren.GetDefaultItem())
 		return NULL;
 	
 	return child;
@@ -914,7 +929,7 @@
 {
 	TRACE(&quot;KPPPInterface: SetAutoReconnect(%s)\n&quot;, autoReconnect ? &quot;true&quot; : &quot;false&quot;);
 	
-	if(Mode() != PPP_CLIENT_MODE)
+	if (Mode() != PPP_CLIENT_MODE)
 		return;
 	
 	fAutoReconnect = autoReconnect;
@@ -933,11 +948,11 @@
 	LockerHelper locker(fLock);
 	
 	// Only clients support ConnectOnDemand.
-	if(Mode() != PPP_CLIENT_MODE) {
+	if (Mode() != PPP_CLIENT_MODE) {
 		TRACE(&quot;KPPPInterface::SetConnectOnDemand(): Wrong mode!\n&quot;);
 		fConnectOnDemand = false;
 		return;
-	} else if(DoesConnectOnDemand() == connectOnDemand)
+	} else if (DoesConnectOnDemand() == connectOnDemand)
 		return;
 	
 	fConnectOnDemand = connectOnDemand;
@@ -947,8 +962,8 @@
 	// - enabling: this cannot happen because hidden interfaces are deleted if they
 	//    could not establish a connection (the user cannot access hidden interfaces)
 	// - disabling: the interface disappears as seen from the user, so we delete it
-	if(!Parent() &amp;&amp; State() == PPP_INITIAL_STATE &amp;&amp; Phase() == PPP_DOWN_PHASE) {
-		if(!connectOnDemand)
+	if (!Parent() &amp;&amp; State() == PPP_INITIAL_STATE &amp;&amp; Phase() == PPP_DOWN_PHASE) {
+		if (!connectOnDemand)
 			Delete();
 				// as long as the protocols were not configured we can just delete us
 		
@@ -956,11 +971,11 @@
 	}
 	
 	// check if we need to set/unset flags
-	if(connectOnDemand) {
-		if(Ifnet())
+	if (connectOnDemand) {
+		if (Ifnet())
 			Ifnet()-&gt;if_flags |= IFF_UP;
-	} else if(!connectOnDemand &amp;&amp; Phase() &lt; PPP_ESTABLISHED_PHASE) {
-		if(Ifnet())
+	} else if (!connectOnDemand &amp;&amp; Phase() &lt; PPP_ESTABLISHED_PHASE) {
+		if (Ifnet())
 			Ifnet()-&gt;if_flags &amp;= ~IFF_UP;
 	}
 }
@@ -975,7 +990,7 @@
 	bool old = fAskBeforeConnecting;
 	fAskBeforeConnecting = ask;
 	
-	if(old &amp;&amp; fAskBeforeConnecting == false &amp;&amp; State() == PPP_STARTING_STATE
+	if (old &amp;&amp; fAskBeforeConnecting == false &amp;&amp; State() == PPP_STARTING_STATE
 			&amp;&amp; Phase() == PPP_DOWN_PHASE) {
 		locker.UnlockNow();
 		StateMachine().ContinueOpenEvent();
@@ -991,7 +1006,7 @@
 	
 	LockerHelper locker(fLock);
 	
-	if(PFCOptions() &amp; PPP_FREEZE_PFC_OPTIONS)
+	if (PFCOptions() &amp; PPP_FREEZE_PFC_OPTIONS)
 		return false;
 	
 	fPFCOptions = pfcOptions;
@@ -1011,10 +1026,10 @@
 {
 	TRACE(&quot;KPPPInterface: Up()\n&quot;);

[... truncated: 4166 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001216.html">[Haiku-commits] r20429 - haiku/trunk/src/bin/strace
</A></li>
	<LI>Next message: <A HREF="001219.html">[Haiku-commits] r20430 - in	haiku/trunk/src/add-ons/kernel/network/ppp/shared:	libkernelppp libppp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1218">[ date ]</a>
              <a href="thread.html#1218">[ thread ]</a>
              <a href="subject.html#1218">[ subject ]</a>
              <a href="author.html#1218">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
