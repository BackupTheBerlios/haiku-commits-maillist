<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r20423 - haiku/trunk/src/bin/strace
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20423%20-%20haiku/trunk/src/bin/strace&In-Reply-To=%3C200703260126.l2Q1Q2nU018853%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001201.html">
   <LINK REL="Next"  HREF="001209.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r20423 - haiku/trunk/src/bin/strace</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20423%20-%20haiku/trunk/src/bin/strace&In-Reply-To=%3C200703260126.l2Q1Q2nU018853%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r20423 - haiku/trunk/src/bin/strace">bonefish at mail.berlios.de
       </A><BR>
    <I>Mon Mar 26 03:26:02 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001201.html">[Haiku-commits] r20422 -	haiku/trunk/src/add-ons/kernel/network/protocols/ipv4
</A></li>
        <LI>Next message: <A HREF="001209.html">[Haiku-commits] r20424 - haiku/trunk/src/bin/strace
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1208">[ date ]</a>
              <a href="thread.html#1208">[ thread ]</a>
              <a href="subject.html#1208">[ subject ]</a>
              <a href="author.html#1208">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2007-03-26 03:25:59 +0200 (Mon, 26 Mar 2007)
New Revision: 20423
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=20423&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=20423&amp;view=rev</A>

Added:
   haiku/trunk/src/bin/strace/ioctl.cpp
Modified:
   haiku/trunk/src/bin/strace/Jamfile
   haiku/trunk/src/bin/strace/Syscall.h
   haiku/trunk/src/bin/strace/TypeHandler.cpp
   haiku/trunk/src/bin/strace/TypeHandler.h
   haiku/trunk/src/bin/strace/strace.cpp
Log:
Patch by Hugo Santos:
* Print structures passed to ioctl() for several commands (networking and
  terminal).
* Optional hex/decimal formatting of numbers (option -i).
* New level of detail option -d.
* Other improvements, like the introduction of a Context class to simplify
  passing around stuff.


Modified: haiku/trunk/src/bin/strace/Jamfile
===================================================================
--- haiku/trunk/src/bin/strace/Jamfile	2007-03-25 14:01:56 UTC (rev 20422)
+++ haiku/trunk/src/bin/strace/Jamfile	2007-03-26 01:25:59 UTC (rev 20423)
@@ -3,11 +3,12 @@
 UseArchHeaders $(TARGET_ARCH) ;
 UsePrivateHeaders kernel ;
 UsePrivateHeaders shared ;
+UsePrivateHeaders net ;
 
 # find headers generated by gensyscalls
 SubDirHdrs $(TARGET_COMMON_DEBUG_LOCATE_TARGET) ;
 
-local straceSources = strace.cpp MemoryReader.cpp TypeHandler.cpp ;
+local straceSources = strace.cpp MemoryReader.cpp TypeHandler.cpp ioctl.cpp ;
 
 # Our compiler badly chokes when compiling the generated file. So will
 # split up the job into 20 pieces.

Modified: haiku/trunk/src/bin/strace/Syscall.h
===================================================================
--- haiku/trunk/src/bin/strace/Syscall.h	2007-03-25 14:01:56 UTC (rev 20422)
+++ haiku/trunk/src/bin/strace/Syscall.h	2007-03-26 01:25:59 UTC (rev 20423)
@@ -106,10 +106,50 @@
 		return NULL;
 	}
 
+	static Syscall *GetSyscall(const char *);
+
 private:
 	string				fName;
 	Type				*fReturnType;
 	vector&lt;Parameter*&gt;	fParameters;
 };
 
+class Context {
+public:
+	enum {
+		STRINGS		= 1 &lt;&lt; 0,
+		ENUMERATIONS	= 1 &lt;&lt; 1,
+		SIMPLE_STRUCTS	= 1 &lt;&lt; 2,
+		COMPLEX_STRUCTS	= 1 &lt;&lt; 3,
+		ALL		= 0xffffffff
+	};
+
+        Context(Syscall *sc, char *data, MemoryReader &amp;reader,
+		uint32 flags, bool decimal)
+                : fSyscall(sc), fData(data), fReader(reader),
+		  fFlags(flags), fDecimal(decimal) {}
+
+	Parameter *GetSibling(int32 index) const {
+		return fSyscall-&gt;ParameterAt(index);
+	}
+
+        const void *GetValue(Parameter *param) const {
+		return fData + param-&gt;Offset();
+	}
+
+	MemoryReader &amp;Reader() { return fReader; }
+	bool GetContents(uint32 what) const { return fFlags &amp; what; }
+
+	string FormatSigned(int64 value, const char *modifier = &quot;ll&quot;) const;
+	string FormatUnsigned(uint64 value) const;
+	string FormatFlags(uint64 value) const;
+
+private:
+	Syscall *fSyscall;
+	char *fData;
+	MemoryReader &fReader;
+	uint32 fFlags;
+	bool fDecimal;
+};
+
 #endif	// STRACE_SYSCALL_H

Modified: haiku/trunk/src/bin/strace/TypeHandler.cpp
===================================================================
--- haiku/trunk/src/bin/strace/TypeHandler.cpp	2007-03-25 14:01:56 UTC (rev 20422)
+++ haiku/trunk/src/bin/strace/TypeHandler.cpp	2007-03-26 01:25:59 UTC (rev 20423)
@@ -7,47 +7,38 @@
  * 		Hugo Santos &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">hugosantos at gmail.com</A>&gt;
  */
 
-#include &quot;MemoryReader.h&quot;
 #include &quot;TypeHandler.h&quot;
 
+// headers required for network structures
+#include &lt;arpa/inet.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
 
+#include &lt;net_stack_driver.h&gt;
+
+#include &quot;MemoryReader.h&quot;
+#include &quot;Syscall.h&quot;
+
 // TypeHandlerImpl
 template&lt;typename Type&gt;
 class TypeHandlerImpl : public TypeHandler {
 public:
-	virtual string GetParameterValue(const void *address, bool getContents,
-		MemoryReader &amp;reader);
-
-	virtual string GetReturnValue(uint64 value, bool getContents,
-		MemoryReader &amp;reader);
+	virtual string GetParameterValue(Context &amp;, Parameter *, const void *);
+	virtual string GetReturnValue(Context &amp;, uint64 value);
 };
 
-
-// #pragma mark -
-
-// get_number_value
 template&lt;typename value_t&gt;
-static inline
-string
-get_number_value(value_t value, const char *format)
+static inline value_t
+get_value(const void *address)
 {
-	char buffer[32];
-	sprintf(buffer, format, value);
-	return buffer;
-}
-
-// get_number_value
-template&lt;typename value_t&gt;
-static inline
-string
-get_number_value(const void *address, const char *format)
-{
 	if (sizeof(align_t) &gt; sizeof(value_t))
-		return get_number_value&lt;value_t&gt;(value_t(*(align_t*)address), format);
+		return value_t(*(align_t*)address);
 	else
-		return get_number_value&lt;value_t&gt;(*(value_t*)address, format);
+		return *(value_t*)address;
 }
 
+// #pragma mark -
+
 // get_pointer_value
 static inline
 string
@@ -82,13 +73,6 @@
 	return new TypeHandlerImpl&lt;const char*&gt;();
 }
 
-TypeHandler *
-create_fdset_type_handler()
-{
-	return new TypeHandlerImpl&lt;struct fd_set *&gt;();
-}
-
-
 // #pragma mark -
 
 // complete specializations
@@ -96,16 +80,14 @@
 // void
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;void&gt;::GetParameterValue(const void *address, bool getContents,
-		MemoryReader &amp;reader)
+TypeHandlerImpl&lt;void&gt;::GetParameterValue(Context &amp;, Parameter *, const void *)
 {
 	return &quot;void&quot;;
 }
 
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;void&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;void&gt;::GetReturnValue(Context &amp;, uint64 value)
 {
 	return &quot;&quot;;
 }
@@ -120,16 +102,15 @@
 // bool
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;bool&gt;::GetParameterValue(const void *address, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;bool&gt;::GetParameterValue(Context &amp;, Parameter *,
+					 const void *address)
 {
-	return (*(align_t*)address ? &quot;true&quot; : &quot;false&quot;);
+	return (*(const align_t*)address ? &quot;true&quot; : &quot;false&quot;);
 }
 
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;bool&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;bool&gt;::GetReturnValue(Context &amp;, uint64 value)
 {
 	return (value ? &quot;true&quot; : &quot;false&quot;);
 }
@@ -141,351 +122,414 @@
 	return new TypeHandlerImpl&lt;bool&gt;();
 }
 
-// char
-template&lt;&gt;
+// read_string
+static
 string
-TypeHandlerImpl&lt;char&gt;::GetParameterValue(const void *address, bool getContents,
-	MemoryReader &amp;reader)
+read_string(MemoryReader &amp;reader, void *data)
 {
-	return get_number_value&lt;char&gt;(address, &quot;0x%x&quot;);
+	char buffer[256];
+	int32 bytesRead;
+	status_t error = reader.Read(data, buffer, sizeof(buffer), bytesRead);
+	if (error == B_OK) {
+//		return string(&quot;\&quot;&quot;) + string(buffer, bytesRead) + &quot;\&quot;&quot;;
+//string result(&quot;\&quot;&quot;);
+//result += string(buffer, bytesRead);
+//result += &quot;\&quot;&quot;;
+//return result;
+
+// TODO: Unless I'm missing something obvious, our STL string class is broken.
+// The appended &quot;\&quot;&quot; doesn't appear in either of the above cases.
+
+		int32 len = strnlen(buffer, sizeof(buffer));
+		char largeBuffer[259];
+		largeBuffer[0] = '&quot;';
+		memcpy(largeBuffer + 1, buffer, len);
+		largeBuffer[len + 1] = '&quot;';
+		largeBuffer[len + 2] = '\0';
+		return largeBuffer;
+	}
+	return get_pointer_value(&amp;data) + &quot; (&quot; + strerror(error) + &quot;)&quot;;
 }
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;char&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+static string
+format_number(uint32 value)
 {
-	return get_number_value&lt;char&gt;(value, &quot;0x%x&quot;);
+	char tmp[32];
+	snprintf(tmp, sizeof(tmp), &quot;%u&quot;, (unsigned int)value);
+	return tmp;
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;char&gt;::Create()
+static string
+read_fdset(Context &amp;context, void *data)
 {
-	return new TypeHandlerImpl&lt;char&gt;();
+	// default FD_SETSIZE is 1024
+	unsigned long tmp[1024 / (sizeof(unsigned long) * 8)];
+	int32 bytesRead;
+
+	status_t err = context.Reader().Read(data, &amp;tmp, sizeof(tmp), bytesRead);
+	if (err != B_OK)
+		return get_pointer_value(&amp;data);
+
+	/* implicitly align to unsigned long lower boundary */
+	int count = bytesRead / sizeof(unsigned long);
+	int added = 0;
+
+	string r;
+	r.reserve(16);
+
+	r = &quot;[&quot;;
+
+	for (int i = 0; i &lt; count &amp;&amp; added &lt; 8; i++) {
+		for (int j = 0;
+			 j &lt; (int)(sizeof(unsigned long) * 8) &amp;&amp; added &lt; 8; j++) {
+			if (tmp[i] &amp; (1 &lt;&lt; j)) {
+				if (added &gt; 0)
+					r += &quot; &quot;;
+				unsigned int fd = i * sizeof(unsigned long) * 8 + j;
+				r += format_number(fd);
+				added++;
+			}
+		}
+	}
+
+	if (added &gt;= 8)
+		r += &quot; ...&quot;;
+
+	r += &quot;]&quot;;
+
+	return r;
 }
 
-// short
+// const void*
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;short&gt;::GetParameterValue(const void *address, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;const void*&gt;::GetParameterValue(Context &amp;, Parameter *,
+						const void *address)
 {
-	return get_number_value&lt;short&gt;(address, &quot;0x%x&quot;);
+	return get_pointer_value(address);
 }
 
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;short&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;const void*&gt;::GetReturnValue(Context &amp;, uint64 value)
 {
-	return get_number_value&lt;short&gt;(value, &quot;0x%x&quot;);
+	return get_pointer_value(value);
 }
 
+// const char*
 template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;short&gt;::Create()
+string
+TypeHandlerImpl&lt;const char*&gt;::GetParameterValue(Context &amp;context, Parameter *,
+						const void *address)
 {
-	return new TypeHandlerImpl&lt;short&gt;();
+	void *data = *(void **)address;
+	if (data != NULL &amp;&amp; context.GetContents(Context::STRINGS))
+		return read_string(context.Reader(), data);
+
+	return get_pointer_value(&amp;data);
 }
 
-
-// unsigned short
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;unsigned short&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
+TypeHandlerImpl&lt;const char*&gt;::GetReturnValue(Context &amp;context, uint64 value)
 {
-	return get_number_value&lt;unsigned short&gt;(address, &quot;0x%x&quot;);
+	void *ptr = (void *)value;
+	return GetParameterValue(context, NULL, (const void *)&amp;ptr);
 }
 
+// struct fd_set *
 template&lt;&gt;
 string
-TypeHandlerImpl&lt;unsigned short&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerImpl&lt;struct fd_set *&gt;::GetParameterValue(Context &amp;context, Parameter *,
+						    const void *address)
 {
-	return get_number_value&lt;unsigned short&gt;(value, &quot;0x%x&quot;);
+	void *data = *(void **)address;
+	if (data != NULL &amp;&amp; context.GetContents(Context::SIMPLE_STRUCTS))
+		return read_fdset(context, data);
+	return get_pointer_value(&amp;data);
 }
 
 template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;unsigned short&gt;::Create()
+string
+TypeHandlerImpl&lt;struct fd_set *&gt;::GetReturnValue(Context &amp;, uint64 value)
 {
-	return new TypeHandlerImpl&lt;unsigned short&gt;();
+	return get_pointer_value(value);
 }
 
-// int
-template&lt;&gt;
+EnumTypeHandler::EnumTypeHandler(const EnumMap &amp;m) : fMap(m) {}
+
 string
-TypeHandlerImpl&lt;int&gt;::GetParameterValue(const void *address, bool getContents,
-	MemoryReader &amp;reader)
+EnumTypeHandler::GetParameterValue(Context &amp;context, Parameter *,
+				   const void *address)
 {
-	return get_number_value&lt;int&gt;(address, &quot;0x%x&quot;);
+	return RenderValue(context, get_value&lt;unsigned int&gt;(address));
 }
 
-template&lt;&gt;
 string
-TypeHandlerImpl&lt;int&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+EnumTypeHandler::GetReturnValue(Context &amp;context, uint64 value)
 {
-	return get_number_value&lt;int&gt;(value, &quot;0x%x&quot;);
+	return RenderValue(context, value);
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;int&gt;::Create()
+string
+EnumTypeHandler::RenderValue(Context &amp;context, unsigned int value) const
 {
-	return new TypeHandlerImpl&lt;int&gt;();
+	if (context.GetContents(Context::ENUMERATIONS)) {
+		EnumMap::const_iterator i = fMap.find(value);
+		if (i != fMap.end() &amp;&amp; i-&gt;second != NULL)
+			return i-&gt;second;
+	}
+
+	return context.FormatUnsigned(value);
 }
 
-// unsigned int
-template&lt;&gt;
+TypeHandlerSelector::TypeHandlerSelector(const SelectMap &amp;m, int sibling,
+					 TypeHandler *def)
+	: fMap(m), fSibling(sibling), fDefault(def) {}
+
 string
-TypeHandlerImpl&lt;unsigned int&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
+TypeHandlerSelector::GetParameterValue(Context &amp;context, Parameter *param,
+				       const void *address)
 {
-	return get_number_value&lt;unsigned int&gt;(address, &quot;0x%x&quot;);
+	TypeHandler *target = fDefault;
+
+	int index = get_value&lt;int&gt;(context.GetValue(context.GetSibling(fSibling)));
+
+	SelectMap::const_iterator i = fMap.find(index);
+	if (i != fMap.end())
+		target = i-&gt;second;
+
+	return target-&gt;GetParameterValue(context, param, address);
 }
 
-template&lt;&gt;
 string
-TypeHandlerImpl&lt;unsigned int&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+TypeHandlerSelector::GetReturnValue(Context &amp;context, uint64 value)
 {
-	return get_number_value&lt;unsigned int&gt;(value, &quot;0x%x&quot;);
+	return fDefault-&gt;GetReturnValue(context, value);
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;unsigned int&gt;::Create()
+template&lt;typename Base&gt;
+static string
+format_pointer_deep(Context &amp;context, void *address)
 {
-	return new TypeHandlerImpl&lt;unsigned int&gt;();
+	if (address == NULL || !context.GetContents(Context::COMPLEX_STRUCTS))
+		return get_pointer_value(&amp;address);
+
+	Base data;
+	int32 bytesRead;
+
+	status_t err = context.Reader().Read(address, &amp;data, sizeof(Base), bytesRead);
+	if (err != B_OK || bytesRead &lt; (int32)sizeof(Base))
+		return get_pointer_value(&amp;address);
+
+	return format_pointer(context, &amp;data);
 }
 
-// long
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;long&gt;::GetParameterValue(const void *address, bool getContents,
-	MemoryReader &amp;reader)
+template&lt;typename Base&gt;
+static string
+format_pointer_value(Context &amp;context, const void *pointer)
 {
-	return get_number_value&lt;long&gt;(address, &quot;0x%lx&quot;);
+	return format_pointer_deep&lt;Base&gt;(context, *(void **)pointer);
 }
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;long&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+template&lt;typename Base&gt;
+static string
+format_pointer_value(Context &amp;context, uint64 value)
 {
-	return get_number_value&lt;long&gt;(value, &quot;0x%lx&quot;);
+	return format_pointer_deep&lt;Base&gt;(context, (void *)value);
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;long&gt;::Create()
+static string
+get_ipv4_address(struct in_addr *addr)
 {
-	return new TypeHandlerImpl&lt;long&gt;();
+	char tmp[32];
+	snprintf(tmp, sizeof(tmp), &quot;%u.%u.%u.%u&quot;,
+		 (unsigned int)(htonl(addr-&gt;s_addr) &gt;&gt; 24) &amp; 0xff,
+		 (unsigned int)(htonl(addr-&gt;s_addr) &gt;&gt; 16) &amp; 0xff,
+		 (unsigned int)(htonl(addr-&gt;s_addr) &gt;&gt;  8) &amp; 0xff,
+		 (unsigned int)(htonl(addr-&gt;s_addr) &gt;&gt;  0) &amp; 0xff);
+	return tmp;
 }
 
-// unsigned long
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;unsigned long&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
+static string
+format_pointer(Context &amp;context, sockaddr *saddr)
 {
-	return get_number_value&lt;unsigned long&gt;(address, &quot;0x%lx&quot;);
-}
+	string r = &quot;{&quot;;
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;unsigned long&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
-{
-	return get_number_value&lt;unsigned long&gt;(value, &quot;0x%lx&quot;);
+	struct sockaddr_in *sin = (struct sockaddr_in *)saddr;
+
+	switch (saddr-&gt;sa_family) {
+	case AF_INET:
+		r += &quot;AF_INET, &quot;;
+		r += get_ipv4_address(&amp;sin-&gt;sin_addr);
+		r += &quot;/&quot;;
+		r += format_number(ntohs(sin-&gt;sin_port));
+		break;
+
+	default:
+		r += &quot;family = &quot;;
+		r += context.FormatUnsigned(saddr-&gt;sa_family);
+		r += &quot;, ...&quot;;
+		break;
+	}
+
+	return r + &quot;}&quot;;
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;unsigned long&gt;::Create()
+static string
+format_pointer(Context &amp;context, sockaddr_args *args)
 {
-	return new TypeHandlerImpl&lt;unsigned long&gt;();
-}
+	string r = &quot;{&quot;;
 
-// long long
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;long long&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
-{
-	return get_number_value&lt;long long&gt;(address, &quot;0x%llx&quot;);
+	r +=   &quot;addr = &quot; + format_pointer_deep&lt;struct sockaddr&gt;(context, args-&gt;address);
+	r += &quot;, len = &quot; + context.FormatUnsigned(args-&gt;address_length);
+
+	return r + &quot;}&quot;;
 }
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;long long&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
+static string
+format_pointer(Context &amp;context, transfer_args *args)
 {
-	return get_number_value&lt;long long&gt;(value, &quot;0x%llx&quot;);
-}
+	string r = &quot;{&quot;;
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;long long&gt;::Create()
-{
-	return new TypeHandlerImpl&lt;long long&gt;();
+	r +=   &quot;data = &quot; + get_pointer_value(&amp;args-&gt;data);
+	r += &quot;, len = &quot; + context.FormatUnsigned(args-&gt;data_length);
+	r += &quot;, flags = &quot; + context.FormatFlags(args-&gt;flags);
+	r += &quot;, addr = &quot; + format_pointer_deep&lt;struct sockaddr&gt;(context, args-&gt;address);
+
+	return r + &quot;}&quot;;
 }
 
-// unsigned long
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;unsigned long long&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
+static string
+format_pointer(Context &amp;context, sockopt_args *args)
 {
-	return get_number_value&lt;unsigned long&gt;(address, &quot;0x%llx&quot;);
-}
+	string r = &quot;{&quot;;
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;unsigned long long&gt;::GetReturnValue(uint64 value,
-	bool getContents, MemoryReader &amp;reader)
-{
-	return get_number_value&lt;unsigned long long&gt;(value, &quot;0x%llx&quot;);
+	r +=   &quot;level = &quot; + context.FormatSigned(args-&gt;level);
+	r += &quot;, option = &quot; + context.FormatSigned(args-&gt;option);
+	r += &quot;, value = &quot; + get_pointer_value(args-&gt;value);
+	r += &quot;, len = &quot; + context.FormatSigned(args-&gt;length);
+
+	return r + &quot;}&quot;;
 }
 
-template&lt;&gt;
-TypeHandler *
-TypeHandlerFactory&lt;unsigned long long&gt;::Create()
+static string
+get_iovec(Context &amp;context, struct iovec *iov, int iovlen)
 {
-	return new TypeHandlerImpl&lt;unsigned long long&gt;();
+	string r = &quot;{&quot;;
+	r += get_pointer_value(&amp;iov);
+	r += &quot;, &quot; + context.FormatSigned(iovlen);
+	return r + &quot;}&quot;;
 }
 
-// read_string
-static
-string
-read_string(MemoryReader &amp;reader, void *data)
+static string
+format_pointer(Context &amp;context, msghdr *h)
 {
-	char buffer[256];
-	int32 bytesRead;
-	status_t error = reader.Read(data, buffer, sizeof(buffer), bytesRead);
-	if (error == B_OK) {
-//		return string(&quot;\&quot;&quot;) + string(buffer, bytesRead) + &quot;\&quot;&quot;;
-//string result(&quot;\&quot;&quot;);
-//result += string(buffer, bytesRead);
-//result += &quot;\&quot;&quot;;
-//return result;
+	string r = &quot;{&quot;;
 
-// TODO: Unless I'm missing something obvious, our STL string class is broken.
-// The appended &quot;\&quot;&quot; doesn't appear in either of the above cases.
+	r +=   &quot;name = &quot; + format_pointer_deep&lt;struct sockaddr&gt;(context, h-&gt;msg_name);
+	r += &quot;, name_len = &quot; + context.FormatUnsigned(h-&gt;msg_namelen);
+	r += &quot;, iov = &quot; + get_iovec(context, h-&gt;msg_iov, h-&gt;msg_iovlen);
+	r += &quot;, control = &quot; + get_pointer_value(&amp;h-&gt;msg_control);
+	r += &quot;, control_len = &quot; + context.FormatUnsigned(h-&gt;msg_controllen);
+	r += &quot;, flags = &quot; + context.FormatFlags(h-&gt;msg_flags);
 
-		int32 len = strnlen(buffer, sizeof(buffer));
-		char largeBuffer[259];
-		largeBuffer[0] = '&quot;';
-		memcpy(largeBuffer + 1, buffer, len);
-		largeBuffer[len + 1] = '&quot;';
-		largeBuffer[len + 2] = '\0';
-		return largeBuffer;
-	}
-	return get_pointer_value(&amp;data) + &quot; (&quot; + strerror(error) + &quot;)&quot;;
+	return r + &quot;}&quot;;
 }
 
-static string
-read_fdset(MemoryReader &amp;reader, void *data)
-{
-	/* default FD_SETSIZE is 1024 */
-	unsigned long tmp[1024 / (sizeof(unsigned long) * 8)];
-	int32 bytesRead;
+template&lt;typename Type&gt;
+class SignedIntegerTypeHandler : public TypeHandler {
+public:
+	SignedIntegerTypeHandler(const char *modifier)
+		: fModifier(modifier) {}
 
-	status_t err = reader.Read(data, &amp;tmp, sizeof(tmp), bytesRead);
-	if (err != B_OK)
-		return get_pointer_value(&amp;data);
+	string GetParameterValue(Context &amp;context, Parameter *,
+				 const void *address)
+	{
+		return context.FormatSigned(get_value&lt;Type&gt;(address), fModifier);
+	}
 
-	/* implicitly align to unsigned long lower boundary */
-	int count = bytesRead / sizeof(unsigned long);
-	int added = 0;
+	string GetReturnValue(Context &amp;context, uint64 value)
+	{
+		return context.FormatSigned(value, fModifier);
+	}
 
-	string r = &quot;[&quot;;
+private:
+	const char *fModifier;
+};
 
-	for (int i = 0; i &lt; count &amp;&amp; added &lt; 8; i++) {
-		for (int j = 0;
-			 j &lt; (int)(sizeof(unsigned long) * 8) &amp;&amp; added &lt; 8; j++) {
-			if (tmp[i] &amp; (1 &lt;&lt; j)) {
-				if (added &gt; 0)
-					r += &quot;, &quot;;
-				r += get_number_value&lt;unsigned long&gt;(
-						i * (sizeof(unsigned long) * 8) + j,
-						&quot;%u&quot;);
-				added++;
-			}
-		}
+template&lt;typename Type&gt;
+class UnsignedIntegerTypeHandler : public TypeHandler {
+public:
+	string GetParameterValue(Context &amp;context, Parameter *,
+				 const void *address)
+	{
+		return context.FormatUnsigned(get_value&lt;Type&gt;(address));
 	}
 
-	if (added &gt;= 8)
-		r += &quot; ...&quot;;
+	string GetReturnValue(Context &amp;context, uint64 value)
+	{
+		return context.FormatUnsigned(value);
+	}
+};
 
-	return r + &quot;]&quot;;
-}
+template&lt;typename Type&gt;
+class SpecializedPointerTypeHandler : public TypeHandler {
+	string GetParameterValue(Context &amp;context, Parameter *,
+				 const void *address)
+	{
+		return format_pointer_value&lt;Type&gt;(context, address);
+	}
 
-// const void*
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;const void*&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
-{
-	return get_pointer_value(address);
-}
+	string GetReturnValue(Context &amp;context, uint64 value)
+	{
+		return format_pointer_value&lt;Type&gt;(context, value);
+	}
+};
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;const void*&gt;::GetReturnValue(uint64 value, bool getContents,
-	MemoryReader &amp;reader)
-{
-	return get_pointer_value(value);
-}
+#define DEFINE_TYPE(name, type) \
+	TypeHandler *create_##name##_type_handler() \
+	{ \
+		return new TypeHandlerImpl&lt;type&gt;(); \
+	}
 
-// const char*
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;const char*&gt;::GetParameterValue(const void *address,
-	bool getContents, MemoryReader &amp;reader)
-{
-	void *data = *(void**)address;
-	if (getContents &amp;&amp; data)
-		return read_string(reader, data);
+#define SIGNED_INTEGER_TYPE(type, modifier) \
+	template&lt;&gt; \
+	TypeHandler * \
+	TypeHandlerFactory&lt;type&gt;::Create() \
+	{ \
+		return new SignedIntegerTypeHandler&lt;type&gt;(modifier); \
+	}
 
-	return get_pointer_value(&amp;data);
-}
+#define UNSIGNED_INTEGER_TYPE(type) \
+	template&lt;&gt; \
+	TypeHandler * \
+	TypeHandlerFactory&lt;type&gt;::Create() \
+	{ \
+		return new UnsignedIntegerTypeHandler&lt;type&gt;(); \
+	}
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;const char*&gt;::GetReturnValue(uint64 value,
-	bool getContents, MemoryReader &amp;reader)
-{
-	void *data = (void*)value;
-	if (getContents &amp;&amp; data)
-		return read_string(reader, data);
+#define POINTER_TYPE(name, type) \
+	TypeHandler *create_##name##_type_handler() \
+	{ \
+		return new SpecializedPointerTypeHandler&lt;type&gt;(); \
+	}
 
-	return get_pointer_value(&amp;data);
-}
+SIGNED_INTEGER_TYPE(char, &quot;hh&quot;);
+SIGNED_INTEGER_TYPE(short, &quot;h&quot;);
+SIGNED_INTEGER_TYPE(int, &quot;&quot;);
+SIGNED_INTEGER_TYPE(long, &quot;l&quot;);
+SIGNED_INTEGER_TYPE(long long, &quot;ll&quot;);
 
-// struct fd_set *
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;struct fd_set *&gt;::GetParameterValue(const void *address,
-		bool getContents, MemoryReader &amp;reader)
-{
-	void *data = *(void **)address;
-	if (getContents &amp;&amp; data)
-		return read_fdset(reader, data);
-	return get_pointer_value(&amp;data);
-}
+UNSIGNED_INTEGER_TYPE(unsigned char);
+UNSIGNED_INTEGER_TYPE(unsigned short);
+UNSIGNED_INTEGER_TYPE(unsigned int);
+UNSIGNED_INTEGER_TYPE(unsigned long);
+UNSIGNED_INTEGER_TYPE(unsigned long long);
 
-template&lt;&gt;
-string
-TypeHandlerImpl&lt;struct fd_set *&gt;::GetReturnValue(uint64 value,
-	bool getContents, MemoryReader &amp;reader)
-{
-	void *data = (void *)value;
-	if (getContents &amp;&amp; data)
-		return read_fdset(reader, data);
+DEFINE_TYPE(fdset_ptr, struct fd_set *);
+POINTER_TYPE(sockaddr_args_ptr, struct sockaddr_args);
+POINTER_TYPE(transfer_args_ptr, struct transfer_args);
+POINTER_TYPE(sockopt_args_ptr, struct sockopt_args);
+POINTER_TYPE(msghdr_ptr, struct msghdr);
 
-	return get_pointer_value(&amp;data);
-}

Modified: haiku/trunk/src/bin/strace/TypeHandler.h
===================================================================
--- haiku/trunk/src/bin/strace/TypeHandler.h	2007-03-25 14:01:56 UTC (rev 20422)
+++ haiku/trunk/src/bin/strace/TypeHandler.h	2007-03-26 01:25:59 UTC (rev 20423)
@@ -10,12 +10,15 @@
 #define STRACE_TYPE_HANDLER_H
 
 #include &lt;string&gt;
+#include &lt;map&gt;
 
 #include &lt;arch_config.h&gt;
 #include &lt;SupportDefs.h&gt;
 
 using std::string;
 
+class Context;
+class Parameter;
 class MemoryReader;
 
 typedef FUNCTION_CALL_PARAMETER_ALIGNMENT_TYPE align_t;
@@ -26,13 +29,43 @@
 	TypeHandler() {}
 	virtual ~TypeHandler() {}
 
-	virtual string GetParameterValue(const void *address, bool getContents,
-		MemoryReader &amp;reader) = 0;
+	virtual string GetParameterValue(Context &amp;, Parameter *,
+					 const void *value) = 0;
+	virtual string GetReturnValue(Context &amp;, uint64 value) = 0;
+};
 
-	virtual string GetReturnValue(uint64 value, bool getContents,
-		MemoryReader &amp;reader) = 0;
+class EnumTypeHandler : public TypeHandler {
+public:
+	typedef std::map&lt;int, const char *&gt; EnumMap;
+
+	EnumTypeHandler(const EnumMap &amp;);
+
+	string GetParameterValue(Context &amp;c, Parameter *, const void *);
+	string GetReturnValue(Context &amp;, uint64 value);
+
+private:
+	string RenderValue(Context &amp;, unsigned int value) const;
+
+	const EnumMap &fMap;
 };
 
+// currently limited to select ints
+class TypeHandlerSelector : public TypeHandler {
+public:
+	typedef std::map&lt;int, TypeHandler *&gt; SelectMap;
+
+	TypeHandlerSelector(const SelectMap &amp;, int sibling,
+			    TypeHandler *def);
+
+	string GetParameterValue(Context &amp;, Parameter *, const void *);
+	string GetReturnValue(Context &amp;, uint64 value);
+
+private:
+	const SelectMap &fMap;
+	int fSibling;
+	TypeHandler *fDefault;
+};
+
 // templatized TypeHandler factory class
 // (I tried a simple function first, but then the compiler complains for
 // the partial instantiation. Not sure, if I'm missing something or this is
@@ -44,7 +77,6 @@
 
 extern TypeHandler *create_pointer_type_handler();
 extern TypeHandler *create_string_type_handler();
-extern TypeHandler *create_fdset_type_handler();
 
 // specialization for &quot;const char*&quot;
 template&lt;&gt;
@@ -55,15 +87,21 @@
 	}
 };
 
-// specialization for 'struct fdset *'
-template&lt;&gt;
-struct TypeHandlerFactory&lt;struct fd_set *&gt; {
-	static inline TypeHandler *Create()
-	{
-		return create_fdset_type_handler();
-	}
-};
+#define DEFINE_FACTORY(name, type) \
+	template&lt;&gt; \
+	struct TypeHandlerFactory&lt;type&gt; { \
+		static inline TypeHandler *Create() \
+		{ \
+			extern TypeHandler *create_##name##_type_handler(); \
+			return create_##name##_type_handler(); \
+		} \
+	} \
 
+DEFINE_FACTORY(fdset_ptr, struct fd_set *);
+DEFINE_FACTORY(sockaddr_args_ptr, struct sockaddr_args *);
+DEFINE_FACTORY(transfer_args_ptr, struct transfer_args *);
+DEFINE_FACTORY(sockopt_args_ptr, struct sockopt_args *);
+
 // partial specialization for generic pointers
 template&lt;typename Type&gt;
 struct TypeHandlerFactory&lt;Type*&gt; {

Added: haiku/trunk/src/bin/strace/ioctl.cpp
===================================================================
--- haiku/trunk/src/bin/strace/ioctl.cpp	2007-03-25 14:01:56 UTC (rev 20422)
+++ haiku/trunk/src/bin/strace/ioctl.cpp	2007-03-26 01:25:59 UTC (rev 20423)
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2007, Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Hugo Santos &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">hugosantos at gmail.com</A>&gt;
+ */
+
+#include &lt;net_stack_driver.h&gt;
+#include &lt;termios.h&gt;
+
+#include &quot;Syscall.h&quot;
+#include &quot;TypeHandler.h&quot;
+
+struct ioctl_info {
+	int index;
+	const char *name;
+	TypeHandler *handler;
+};
+
+#define IOCTL_INFO_ENTRY(name) \
+	{ name, #name, NULL }
+
+#define IOCTL_INFO_ENTRY_TYPE(name, type) \
+	{ name, #name, TypeHandlerFactory&lt;type&gt;::Create() }
+
+static const ioctl_info kIOCtls[] = {
+	// network stack ioctls
+	IOCTL_INFO_ENTRY(NET_STACK_SOCKET),
+	IOCTL_INFO_ENTRY(NET_STACK_GET_COOKIE),
+	IOCTL_INFO_ENTRY(NET_STACK_CONTROL_NET_MODULE),
+	IOCTL_INFO_ENTRY(NET_STACK_GET_NEXT_STAT),
+	IOCTL_INFO_ENTRY_TYPE(NET_STACK_BIND, struct sockaddr_args *),
+	IOCTL_INFO_ENTRY_TYPE(NET_STACK_RECVFROM, struct transfer_args *),
+	IOCTL_INFO_ENTRY_TYPE(NET_STACK_RECV, struct transfer_args *),

[... truncated: 270 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001201.html">[Haiku-commits] r20422 -	haiku/trunk/src/add-ons/kernel/network/protocols/ipv4
</A></li>
	<LI>Next message: <A HREF="001209.html">[Haiku-commits] r20424 - haiku/trunk/src/bin/strace
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1208">[ date ]</a>
              <a href="thread.html#1208">[ thread ]</a>
              <a href="subject.html#1208">[ subject ]</a>
              <a href="author.html#1208">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
