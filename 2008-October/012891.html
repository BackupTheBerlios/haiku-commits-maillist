<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28244 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch/x86 headers/private/system	src/add-ons/kernel/bus_managers/acpi	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/scsi/ahci	src/system/kernel/arch/generic src/system/kernel/arch/m68k	src/system/kernel/arch/ppc src/system/kernel/arch/x86	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28244%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/arch/x86%20headers/private/system%0A%09src/add-ons/kernel/bus_managers/acpi%0A%09src/add-ons/kernel/bus_managers/ata%0A%09src/add-ons/kernel/bus_managers/ide%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/busses/scsi/ahci%0A%09src/system/kernel/arch/generic%20src/system/kernel/arch/m68k%0A%09src/system/kernel/arch/ppc%20src/system/kernel/arch/x86%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm&In-Reply-To=%3C200810200006.m9K06Dsf001363%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012890.html">
   <LINK REL="Next"  HREF="012892.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28244 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch/x86 headers/private/system	src/add-ons/kernel/bus_managers/acpi	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/scsi/ahci	src/system/kernel/arch/generic src/system/kernel/arch/m68k	src/system/kernel/arch/ppc src/system/kernel/arch/x86	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28244%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/arch/x86%20headers/private/system%0A%09src/add-ons/kernel/bus_managers/acpi%0A%09src/add-ons/kernel/bus_managers/ata%0A%09src/add-ons/kernel/bus_managers/ide%0A%09src/add-ons/kernel/bus_managers/scsi%0A%09src/add-ons/kernel/busses/scsi/ahci%0A%09src/system/kernel/arch/generic%20src/system/kernel/arch/m68k%0A%09src/system/kernel/arch/ppc%20src/system/kernel/arch/x86%0A%09src/system/kernel/cache%20src/system/kernel/device_manager%0A%09src/system/kernel/fs%20src/system/kernel/vm&In-Reply-To=%3C200810200006.m9K06Dsf001363%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28244 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch/x86 headers/private/system	src/add-ons/kernel/bus_managers/acpi	src/add-ons/kernel/bus_managers/ata	src/add-ons/kernel/bus_managers/ide	src/add-ons/kernel/bus_managers/scsi	src/add-ons/kernel/busses/scsi/ahci	src/system/kernel/arch/generic src/system/kernel/arch/m68k	src/system/kernel/arch/ppc src/system/kernel/arch/x86	src/system/kernel/cache src/system/kernel/device_manager	src/system/kernel/fs src/system/kernel/vm">bonefish at mail.berlios.de
       </A><BR>
    <I>Mon Oct 20 02:06:13 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="012890.html">[Haiku-commits] r28243 - haiku/trunk/src/system/kernel/vm
</A></li>
        <LI>Next message: <A HREF="012892.html">[Haiku-commits] r28244 - in haiku/trunk: headers/private/kernel headers/private/kernel/arch/x86 headers/private/system src/add-ons/kernel/bus_managers/acpi src/add-ons/kernel/bus_managers/ata src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/busses/scsi/ahci src/system/kernel/arch/generic src/system/kernel/arch/m68k src/system/kernel/arch/ppc src/system/kernel/arch/x86 src/system/kernel/cache src/system/kernel/device_manager src/system/kernel/fs src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12891">[ date ]</a>
              <a href="thread.html#12891">[ thread ]</a>
              <a href="subject.html#12891">[ subject ]</a>
              <a href="author.html#12891">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-10-20 02:06:09 +0200 (Mon, 20 Oct 2008)
New Revision: 28244
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28244&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28244&amp;view=rev</A>

Added:
   haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.cpp
   haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.h
   haiku/trunk/src/system/kernel/arch/x86/x86_paging.h
   haiku/trunk/src/system/kernel/arch/x86/x86_physical_page_mapper.cpp
   haiku/trunk/src/system/kernel/arch/x86/x86_physical_page_mapper.h
   haiku/trunk/src/system/kernel/arch/x86/x86_physical_page_mapper_large_memory.cpp
Modified:
   haiku/trunk/headers/private/kernel/arch/x86/arch_vm_translation_map.h
   haiku/trunk/headers/private/kernel/vm.h
   haiku/trunk/headers/private/kernel/vm_translation_map.h
   haiku/trunk/headers/private/system/vm_defs.h
   haiku/trunk/src/add-ons/kernel/bus_managers/acpi/oshaiku.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ata/emulation.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ata/pio.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/emulation.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ide/pio.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c
   haiku/trunk/src/add-ons/kernel/bus_managers/scsi/emulation.c
   haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c
   haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.h
   haiku/trunk/src/system/kernel/arch/m68k/Jamfile
   haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
   haiku/trunk/src/system/kernel/arch/ppc/Jamfile
   haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/arch/x86/Jamfile
   haiku/trunk/src/system/kernel/arch/x86/arch_thread.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_vm.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/cache/file_cache.cpp
   haiku/trunk/src/system/kernel/cache/vnode_store.cpp
   haiku/trunk/src/system/kernel/device_manager/io_requests.cpp
   haiku/trunk/src/system/kernel/fs/vfs_request_io.cpp
   haiku/trunk/src/system/kernel/vm/vm.cpp
   haiku/trunk/src/system/kernel/vm/vm_page.cpp
Log:
* Prefixed memset_physical() and memcpy_to_physical() with &quot;vm_&quot;,
  added vm_memcpy_from_physical() and vm_memcpy_physical_page(), and
  added respective functions to the vm_translation_map operations. The
  architecture specific implementation can now decide how to implement
  them most efficiently. Added generic implementations that can be used,
  though.
* Changed vm_{get,put}_physical_page(). The former no longer accepts
  flags (the only flag PHYSICAL_PAGE_DONT_WAIT wasn't needed anymore).
  Instead it returns an implementation-specific handle that has to be
  passed to the latter. Added vm_{get,put}_physical_page_current_cpu()
  and *_debug() variants, that work only for the current CPU,
  respectively when in the kernel debugger. Also adjusted the
  vm_translation_map operations accordingly.
* Made consequent use of the physical memory operations in the source
  tree.
* Also adjusted the m68k and ppc implementations with respect to the
  vm_translation_map operation changes, but they are probably broken,
  nevertheless.
* For x86 the generic physical page mapper isn't used anymore. It is
  suboptimal in any case. For systems with small memory it is too much
  overhead, since one can just map the complete physical memory (that's
  not done yet, though). For systems with large memory it counteracts
  the VM strategy to reuse the least recently used pages. Since those
  pages will most likely not be mapped by the page mapper anymore, it
  will keep remapping chunks. This was also the reason why building
  Haiku in Haiku was significantly faster with only 256 MB RAM (since
  that much could be kept mapped all the time).
  Now we're using a different strategy: We have small pools of virtual
  page slots per CPU that are used for the physical page operations
  (memset_physical(), memcpy_*_physical()) with CPU-pinned thread.
  Furthermore we have four slots per translation map, which are used to
  map page tables.

These changes speed up the Haiku image build in Haiku significantly. On
my Core2 Duo 2.2 GHz 2 GB machine about 40% to 20 min 40 s (KDEBUG
disabled, block cache debug disabled). Still more than factor 3 slower
than FreeBSD and Linux, though.


Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_vm_translation_map.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_vm_translation_map.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_vm_translation_map.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -5,24 +5,9 @@
 #ifndef _KERNEL_ARCH_x86_VM_TRANSLATION_MAP_H
 #define _KERNEL_ARCH_x86_VM_TRANSLATION_MAP_H
 
-
 #include &lt;arch/vm_translation_map.h&gt;
 
 
-#define PAGE_INVALIDATE_CACHE_SIZE 64
-
-struct page_directory_entry;
-
-typedef struct vm_translation_map_arch_info {
-	struct page_directory_entry *pgdir_virt;
-	struct page_directory_entry *pgdir_phys;
-	vint32 active_on_cpus;
-		// mask indicating on which CPUs the map is currently used
-	int num_invalidate_pages;
-	addr_t pages_to_invalidate[PAGE_INVALIDATE_CACHE_SIZE];
-} vm_translation_map_arch_info;
-
-
 // quick function to return the physical pgdir of a mapping, needed for a context switch
 #ifdef __cplusplus
 extern &quot;C&quot;

Modified: haiku/trunk/headers/private/kernel/vm.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/headers/private/kernel/vm.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -91,17 +91,27 @@
 			bool preserveModified);
 status_t vm_map_page(struct vm_area *area, struct vm_page *page, addr_t address,
 			uint32 protection);
-status_t vm_get_physical_page(addr_t paddr, addr_t *vaddr, uint32 flags);
-status_t vm_put_physical_page(addr_t vaddr);
 
+status_t vm_get_physical_page(addr_t paddr, addr_t* vaddr, void** _handle);
+status_t vm_put_physical_page(addr_t vaddr, void* handle);
+status_t vm_get_physical_page_current_cpu(addr_t paddr, addr_t* vaddr,
+			void** _handle);
+status_t vm_put_physical_page_current_cpu(addr_t vaddr, void* handle);
+status_t vm_get_physical_page_debug(addr_t paddr, addr_t* vaddr,
+			void** _handle);
+status_t vm_put_physical_page_debug(addr_t vaddr, void* handle);
+
 void vm_get_info(struct system_memory_info *info);
 uint32 vm_num_page_faults(void);
 off_t vm_available_memory(void);
 off_t vm_available_not_needed_memory(void);
 
-status_t memset_physical(addr_t address, int value, size_t length);
-status_t memcpy_to_physical(addr_t to, const void* from, size_t length,
-	bool user);
+status_t vm_memset_physical(addr_t address, int value, size_t length);
+status_t vm_memcpy_from_physical(void* to, addr_t from, size_t length,
+			bool user);
+status_t vm_memcpy_to_physical(addr_t to, const void* from, size_t length,
+			bool user);
+void vm_memcpy_physical_page(addr_t to, addr_t from);
 
 // user syscalls
 area_id _user_create_area(const char *name, void **address, uint32 addressSpec,

Modified: haiku/trunk/headers/private/kernel/vm_translation_map.h
===================================================================
--- haiku/trunk/headers/private/kernel/vm_translation_map.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/headers/private/kernel/vm_translation_map.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -43,9 +43,32 @@
 				uint32 attributes);
 	status_t (*clear_flags)(vm_translation_map *map, addr_t va, uint32 flags);
 	void (*flush)(vm_translation_map *map);
+
+	// get/put virtual address for physical page -- will be usuable on all CPUs
+	// (usually more expensive than the *_current_cpu() versions)
 	status_t (*get_physical_page)(addr_t physicalAddress,
-				addr_t *_virtualAddress, uint32 flags);
-	status_t (*put_physical_page)(addr_t virtualAddress);
+				addr_t *_virtualAddress, void **handle);
+	status_t (*put_physical_page)(addr_t virtualAddress, void *handle);
+
+	// get/put virtual address for physical page -- thread must be pinned the
+	// whole time
+	status_t (*get_physical_page_current_cpu)(addr_t physicalAddress,
+				addr_t *_virtualAddress, void **handle);
+	status_t (*put_physical_page_current_cpu)(addr_t virtualAddress,
+				void *handle);
+
+	// get/put virtual address for physical in KDL
+	status_t (*get_physical_page_debug)(addr_t physicalAddress,
+				addr_t *_virtualAddress, void **handle);
+	status_t (*put_physical_page_debug)(addr_t virtualAddress, void *handle);
+
+	// memory operations on pages
+	status_t (*memset_physical)(addr_t address, int value, size_t length);
+	status_t (*memcpy_from_physical)(void* to, addr_t from, size_t length,
+				bool user);
+	status_t (*memcpy_to_physical)(addr_t to, const void* from, size_t length,
+				bool user);
+	void (*memcpy_physical_page)(addr_t to, addr_t from);
 } vm_translation_map_ops;
 
 #include &lt;arch/vm_translation_map.h&gt;

Modified: haiku/trunk/headers/private/system/vm_defs.h
===================================================================
--- haiku/trunk/headers/private/system/vm_defs.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/headers/private/system/vm_defs.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -47,11 +47,6 @@
 	(B_KERNEL_PROTECTION | B_USER_CLONEABLE_AREA | B_OVERCOMMITTING_AREA \
 		| B_SHARED_AREA)
 
-// flags for vm_get_physical_page()
-enum {
-	PHYSICAL_PAGE_DONT_WAIT		= 0x01
-};
-
 // mapping argument for several internal VM functions
 enum {
 	REGION_NO_PRIVATE_MAP = 0,

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/acpi/oshaiku.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/acpi/oshaiku.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/acpi/oshaiku.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -1158,16 +1158,10 @@
 AcpiOsReadMemory(ACPI_PHYSICAL_ADDRESS Address, UINT32 *Value, UINT32 Width)
 {
 #ifdef _KERNEL_MODE
-	addr_t pageOffset = Address % B_PAGE_SIZE;
-	addr_t virtualAddress;
-	status_t error = vm_get_physical_page(Address - pageOffset,
-		&amp;virtualAddress, 0);
-	DEBUG_FUNCTION();
-	if (error != B_OK)
+	if (vm_memcpy_from_physical(Value, (addr_t)Address, Width / 8, false)
+			!= B_OK) {
 		return AE_ERROR;
-
-	memcpy(Value, (void*)(virtualAddress + pageOffset), Width / 8);
-	vm_put_physical_page(virtualAddress);
+	}
 	return AE_OK;
 #else
 	return AE_ERROR;
@@ -1193,16 +1187,10 @@
 AcpiOsWriteMemory(ACPI_PHYSICAL_ADDRESS Address, UINT32 Value, UINT32 Width)
 {
 #ifdef _KERNEL_MODE
-	addr_t pageOffset = Address % B_PAGE_SIZE;
-	addr_t virtualAddress;
-	status_t error = vm_get_physical_page(Address - pageOffset,
-		&amp;virtualAddress, 0);
-	DEBUG_FUNCTION();
-	if (error != B_OK)
+	if (vm_memcpy_to_physical((addr_t)Address, &amp;Value, Width / 8, false)
+			!= B_OK) {
 		return AE_ERROR;
-
-	memcpy((void*)(virtualAddress + pageOffset), &amp;Value, Width / 8);
-	vm_put_physical_page(virtualAddress);
+	}
 	return AE_OK;
 #else
 	return AE_ERROR;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ata/emulation.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ata/emulation.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ata/emulation.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -33,7 +33,7 @@
 	int sgCount = ccb-&gt;sg_count;
 	int requestSize;
 
-	SHOW_FLOW(3, &quot;offset=%u, req_size_limit=%d, size=%d, sg_list=%p, sg_cnt=%d, %s buffer&quot;, 
+	SHOW_FLOW(3, &quot;offset=%u, req_size_limit=%d, size=%d, sg_list=%p, sg_cnt=%d, %s buffer&quot;,
 		offset, allocationLength, size, sgList, sgCount, toBuffer ? &quot;to&quot; : &quot;from&quot;);
 
 	// skip unused S/G entries
@@ -46,31 +46,28 @@
 	if (sgCount == 0)
 		return 0;
 
-	// remaining bytes we are allowed to copy from/to ccb 		
+	// remaining bytes we are allowed to copy from/to ccb
 	requestSize = min(allocationLength, ccb-&gt;data_length) - offset;
 
 	// copy one S/G entry at a time
 	for (; size &gt; 0 &amp;&amp; requestSize &gt; 0 &amp;&amp; sgCount &gt; 0; ++sgList, --sgCount) {
-		addr_t virtualAddress;
 		size_t bytes;
 
 		bytes = min(size, requestSize);
 		bytes = min(bytes, sgList-&gt;size);
 
-		if (vm_get_physical_page((addr_t)sgList-&gt;address, &amp;virtualAddress,
-				0) != B_OK) 
-			return false;
-
 		SHOW_FLOW(4, &quot;buffer=%p, virt_addr=%p, bytes=%d, to_buffer=%d&quot;,
-			buffer, (void *)(virtualAddress + offset), (int)bytes, toBuffer);
+			buffer, (void *)((addr_t)sgList-&gt;address + offset), (int)bytes,
+			toBuffer);
 
-		if (toBuffer)
-			memcpy(buffer, (void *)(virtualAddress + offset), bytes);
-		else
-			memcpy((void *)(virtualAddress + offset), buffer, bytes);
+		if (toBuffer) {
+			vm_memcpy_from_physical(buffer, (addr_t)sgList-&gt;address + offset,
+				bytes, false);
+		} else {
+			vm_memcpy_to_physical((addr_t)sgList-&gt;address + offset, buffer,
+				bytes, false);
+		}
 
-		vm_put_physical_page(virtualAddress);
-
 		buffer = (char *)buffer + bytes;
 		size -= bytes;
 		offset = 0;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ata/pio.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ata/pio.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ata/pio.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -9,36 +9,37 @@
 	PIO data transmission
 
 	This file is more difficult then you might expect as the SCSI system
-	uses physical addresses everywhere which have to be mapped into 
+	uses physical addresses everywhere which have to be mapped into
 	virtual address space during transmission. Additionally, during ATAPI
 	commands we may have to transmit more data then exist because the
-	data len specified by the command doesn't need to be the same as 
+	data len specified by the command doesn't need to be the same as
 	of the data buffer provided.
-	
-	The handling of S/G entries of odd size may look superfluous as the 
+
+	The handling of S/G entries of odd size may look superfluous as the
 	SCSI bus manager can take care of that. In general, this would be possible
 	as most controllers need even alignment for DMA as well, but some can
 	handle _any_ S/G list and it wouldn't be sensitive to enforce stricter
 	alignement just for some rare PIO transmissions.
-	
+
 	Little hint for the meaning of &quot;transferred&quot;: this is the number of bytes
 	sent over the bus. For read-transmissions, this may be one more then copied
 	into the buffer (the extra byte read is stored in device-&gt;odd_byte), for
 	write-transmissions, this may be one less (the waiting byte is pending in
 	device-&gt;odd_byte).
-	
+
 	In terms of error handling: we don't bother checking transmission of every
-	single byte via read/write_pio(). At least at the end of the request, when 
+	single byte via read/write_pio(). At least at the end of the request, when
 	the status bits are verified, we will see that something has gone wrong.
-	
+
 	TBD: S/G entries may have odd start address. For non-Intel architecture
-	we either have to copy data to an aligned buffer or have to modify 
+	we either have to copy data to an aligned buffer or have to modify
 	PIO-handling in controller drivers.
 */
 
 #include &quot;ide_internal.h&quot;
 #include &quot;ide_sim.h&quot;
 
+#include &lt;thread.h&gt;
 #include &lt;vm.h&gt;
 
 #include &lt;string.h&gt;
@@ -74,7 +75,7 @@
 
 	if (write) {
 		// if there is a byte left from last chunk, transmit it together
-		// with the first byte of the current chunk (IDE requires 16 bits 
+		// with the first byte of the current chunk (IDE requires 16 bits
 		// to be transmitted at once)
 		if (device-&gt;has_odd_byte) {
 			uint8 buffer[2];
@@ -91,7 +92,7 @@
 		controller-&gt;write_pio(channel_cookie, (uint16 *)virtualAddress,
 			length / 2, false);
 
-		// take care if chunk size was odd, which means that 1 byte remains		
+		// take care if chunk size was odd, which means that 1 byte remains
 		virtualAddress += length &amp; ~1;
 		*transferred += length &amp; ~1;
 
@@ -112,7 +113,7 @@
 			length / 2, false);
 
 		// take care of odd chunk size;
-		// in this case we read 1 byte to few!		
+		// in this case we read 1 byte to few!
 		virtualAddress += length &amp; ~1;
 		*transferred += length &amp; ~1;
 
@@ -145,14 +146,18 @@
 	// one page into address space at once
 	while (length &gt; 0) {
 		addr_t virtualAddress;
+		void* handle;
 		int page_left, cur_len;
 		status_t err;
+		struct thread* thread = thread_get_current_thread();
 
 		SHOW_FLOW(4, &quot;Transmitting to/from physical address %lx, %d bytes left&quot;,
 			physicalAddress, length);
 
-		if (vm_get_physical_page(physicalAddress, &amp;virtualAddress,
-				0) != B_OK) {
+		thread_pin_to_current_cpu(thread);
+		if (vm_get_physical_page_current_cpu(physicalAddress, &amp;virtualAddress,
+				&amp;handle) != B_OK) {
+			thread_unpin_from_current_cpu(thread);
 			// ouch: this should never ever happen
 //xxx fix this			set_sense(device, SCSIS_KEY_HARDWARE_ERROR, SCSIS_ASC_INTERNAL_FAILURE);
 			return B_ERROR;
@@ -161,7 +166,7 @@
 		ASSERT((physicalAddress &amp; 4097) == (virtualAddress &amp; 4097));
 
 		// if chunks starts in the middle of a page, we have even less then
-		// a page left		
+		// a page left
 		page_left = B_PAGE_SIZE - physicalAddress % B_PAGE_SIZE;
 
 		SHOW_FLOW(4, &quot;page_left=%d&quot;, page_left);
@@ -173,12 +178,13 @@
 		err = transfer_PIO_virtcont(device, (char *)virtualAddress,
 			cur_len, write, transferred);
 
-		vm_put_physical_page(virtualAddress);
+		vm_put_physical_page_current_cpu(virtualAddress);
+		thread_unpin_from_current_cpu(thread);
 
 		if (err != B_OK)
 			return err;
 
-		length -= cur_len;	
+		length -= cur_len;
 		physicalAddress += cur_len;
 	}
 
@@ -243,7 +249,7 @@
 		int cur_len;
 
 		// if device asks for odd number of bytes, append an extra byte to
-		// make length even (this is the &quot;length + 1&quot; term)		
+		// make length even (this is the &quot;length + 1&quot; term)
 		cur_len = min(length + 1, (int)(sizeof(buffer))) / 2;
 
 		bus-&gt;controller-&gt;write_pio(bus-&gt;channel_cookie, (uint16 *)buffer, cur_len, false);

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ide/emulation.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ide/emulation.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ide/emulation.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -86,26 +86,22 @@
 
 	// copy one S/G entry at a time
 	for (; size &gt; 0 &amp;&amp; requestSize &gt; 0 &amp;&amp; sgCount &gt; 0; ++sgList, --sgCount) {
-		addr_t virtualAddress;
 		size_t bytes;
 
 		bytes = min(size, requestSize);
 		bytes = min(bytes, sgList-&gt;size);
 
-		if (vm_get_physical_page((addr_t)sgList-&gt;address, &amp;virtualAddress, 0)
-				!= B_OK)
-			return false;
-
 		SHOW_FLOW(4, &quot;buffer=%p, virt_addr=%p, bytes=%d, to_buffer=%d&quot;,
-			buffer, (void *)(virtualAddress + offset), (int)bytes, toBuffer);
+			buffer, (void *)(sgList-&gt;address + offset), (int)bytes, toBuffer);
 
-		if (toBuffer)
-			memcpy(buffer, (void *)(virtualAddress + offset), bytes);
-		else
-			memcpy((void *)(virtualAddress + offset), buffer, bytes);
+		if (toBuffer) {
+			vm_memcpy_from_physical(buffer, (addr_t)sgList-&gt;address + offset,
+				bytes, false);
+		} else {
+			vm_memcpy_to_physical((addr_t)sgList-&gt;address + offset, buffer,
+				bytes, false);
+		}
 
-		vm_put_physical_page(virtualAddress);
-
 		buffer = (char *)buffer + bytes;
 		size -= bytes;
 		offset = 0;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ide/pio.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ide/pio.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ide/pio.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -39,6 +39,7 @@
 #include &quot;ide_internal.h&quot;
 #include &quot;ide_sim.h&quot;
 
+#include &lt;thread.h&gt;
 #include &lt;vm.h&gt;
 
 #include &lt;string.h&gt;
@@ -144,13 +145,18 @@
 	// one page into address space at once
 	while (length &gt; 0) {
 		addr_t virtualAddress;
+		void* handle;
 		int page_left, cur_len;
 		status_t err;
+		struct thread* thread = thread_get_current_thread();
 
 		SHOW_FLOW(4, &quot;Transmitting to/from physical address %lx, %d bytes left&quot;,
 			physicalAddress, length);
 
-		if (vm_get_physical_page(physicalAddress, &amp;virtualAddress, 0) != B_OK) {
+		thread_pin_to_current_cpu(thread);
+		if (vm_get_physical_page_current_cpu(physicalAddress, &amp;virtualAddress,
+				&amp;handle) != B_OK) {
+			thread_unpin_from_current_cpu(thread);
 			// ouch: this should never ever happen
 			set_sense(device, SCSIS_KEY_HARDWARE_ERROR, SCSIS_ASC_INTERNAL_FAILURE);
 			return B_ERROR;
@@ -169,7 +175,8 @@
 		err = transfer_PIO_virtcont(device, (uint8 *)virtualAddress,
 			cur_len, write, transferred);
 
-		vm_put_physical_page(virtualAddress);
+		vm_put_physical_page_current_cpu(virtualAddress, handle);
+		thread_unpin_from_current_cpu(thread);
 
 		if (err != B_OK)
 			return err;

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/dma_buffer.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -114,22 +114,18 @@
 	// was allocated in kernel and is thus visible even if the thread
 	// was changed
 	for (; size &gt; 0 &amp;&amp; num_vecs &gt; 0; ++sg_list, --num_vecs) {
-		addr_t virtualAddress;
 		size_t bytes;
 
 		bytes = min( size, sg_list-&gt;size );
 
-		if (vm_get_physical_page((addr_t)sg_list-&gt;address, &amp;virtualAddress, 0)
-				!= B_OK)
-			return false;
+		if (to_buffer) {
+			vm_memcpy_from_physical(buffer_data, (addr_t)sg_list-&gt;address,
+				bytes, false);
+		} else {
+			vm_memcpy_to_physical((addr_t)sg_list-&gt;address, buffer_data,
+				bytes, false);
+		}
 
-		if (to_buffer)
-			memcpy(buffer_data, (void *)virtualAddress, bytes);
-		else
-			memcpy((void *)virtualAddress, buffer_data, bytes);
-
-		vm_put_physical_page(virtualAddress);
-
 		buffer_data += bytes;
 	}
 

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/scsi/emulation.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/scsi/emulation.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/scsi/emulation.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -459,25 +459,21 @@
 	// copy one S/G entry at a time
 	for (; size &gt; 0 &amp;&amp; req_size &gt; 0 &amp;&amp; sg_count &gt; 0; ++sg_list, --sg_count) {
 		size_t bytes;
-		addr_t virtualAddress;
 
 		bytes = min(size, req_size);
 		bytes = min(bytes, sg_list-&gt;size);
 
-		if (vm_get_physical_page((addr_t)sg_list-&gt;address,
-				(void*)&amp;virtualAddress, 0) != B_OK)
-			return false;
-
 		SHOW_FLOW(0, &quot;buffer = %p, virt_addr = %#lx, bytes = %lu, to_buffer = %d&quot;,
-			buffer, virtualAddress + offset, bytes, to_buffer);
+			buffer, (addr_t)sg_list-&gt;address + offset, bytes, to_buffer);
 
-		if (to_buffer)
-			memcpy(buffer, (void *)(virtualAddress + offset), bytes);
-		else
-			memcpy((void *)(virtualAddress + offset), buffer, bytes);
+		if (to_buffer) {
+			vm_memcpy_from_physical(buffer, (addr_t)sg_list-&gt;address + offset,
+				bytes, false);
+		} else {
+			vm_memcpy_to_physical((addr_t)sg_list-&gt;address + offset, buffer,
+				bytes, false);
+		}
 
-		vm_put_physical_page(virtualAddress);
-
 		buffer = (char *)buffer + bytes;
 		size -= bytes;
 		offset = 0;

Modified: haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/add-ons/kernel/busses/scsi/ahci/util.c	2008-10-20 00:06:09 UTC (rev 28244)
@@ -91,17 +91,11 @@
 	int i;
 	for (i = 0; i &lt; sgCount &amp;&amp; dataSize &gt; 0; i++) {
 		size_t size = min_c(dataSize, sgTable[i].size);
-		addr_t address;
 
-		if (vm_get_physical_page((addr_t)sgTable[i].address, &amp;address, 0)
-				&lt; B_OK)
-			return B_ERROR;
+		TRACE(&quot;sg_memcpy phyAddr %p, size %lu\n&quot;, sgTable[i].address, size);
 
-		TRACE(&quot;sg_memcpy phyAddr %p, addr %p, size %lu\n&quot;, sgTable[i].address, (void *)address, size);
+		vm_memcpy_to_physical((addr_t)sgTable[i].address, data, size, false);
 
-		memcpy((void *)address, data, size);
-		vm_put_physical_page(address);
-
 		data = (char *)data + size;
 		dataSize -= size;
 	}

Modified: haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.h
===================================================================
--- haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_mapper.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006, Ingo Weinhold &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de</A>&gt;.
+ * Copyright 2006-2008, Ingo Weinhold &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de</A>&gt;.
  * All rights reserved. Distributed under the terms of the MIT License.
  */
 
@@ -8,6 +8,12 @@
 
 #include &lt;boot/kernel_args.h&gt;
 
+
+// flags for generic_get_physical_page()
+enum {
+	PHYSICAL_PAGE_DONT_WAIT		= 0x01
+};
+
 #ifdef __cplusplus
 extern &quot;C&quot; {
 #endif

Added: haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.cpp	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.cpp	2008-10-20 00:06:09 UTC (rev 28244)
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2008, Ingo Weinhold &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ingo_weinhold at gmx.de</A>&gt;.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+
+#include &quot;generic_vm_physical_page_ops.h&quot;
+
+#include &lt;vm.h&gt;
+#include &lt;util/AutoLock.h&gt;
+
+
+status_t
+generic_vm_memset_physical(addr_t address, int value, size_t length)
+{
+	ThreadCPUPinner _(thread_get_current_thread());
+
+	while (length &gt; 0) {
+		addr_t pageOffset = address % B_PAGE_SIZE;
+		addr_t virtualAddress;
+		void* handle;
+		status_t error = vm_get_physical_page_current_cpu(address - pageOffset,
+			&amp;virtualAddress, &amp;handle);
+		if (error != B_OK)
+			return error;
+
+		size_t toSet = min_c(length, B_PAGE_SIZE - pageOffset);
+		memset((void*)(virtualAddress + pageOffset), value, toSet);
+
+		vm_put_physical_page_current_cpu(virtualAddress, handle);
+
+		length -= toSet;
+		address += toSet;
+	}
+
+	return B_OK;
+}
+
+
+status_t
+generic_vm_memcpy_from_physical(void* _to, addr_t from, size_t length,
+	bool user)
+{
+	uint8* to = (uint8*)_to;
+	addr_t pageOffset = from % B_PAGE_SIZE;
+
+	ThreadCPUPinner _(thread_get_current_thread());
+
+	while (length &gt; 0) {
+		size_t toCopy = min_c(length, B_PAGE_SIZE - pageOffset);
+
+		addr_t virtualAddress;
+		void* handle;
+		status_t error = vm_get_physical_page_current_cpu(from - pageOffset,
+			&amp;virtualAddress, &amp;handle);
+		if (error != B_OK)
+			return error;
+
+		if (user) {
+			error = user_memcpy(to, (void*)(virtualAddress + pageOffset),
+				toCopy);
+		} else
+			memcpy(to, (void*)(virtualAddress + pageOffset), toCopy);
+
+		vm_put_physical_page_current_cpu(virtualAddress, handle);
+
+		if (error != B_OK)
+			return error;
+
+		to += toCopy;
+		from += toCopy;
+		length -= toCopy;
+		pageOffset = 0;
+	}
+
+	return B_OK;
+}
+
+
+status_t
+generic_vm_memcpy_to_physical(addr_t to, const void* _from, size_t length,
+	bool user)
+{
+	const uint8* from = (const uint8*)_from;
+	addr_t pageOffset = to % B_PAGE_SIZE;
+
+	ThreadCPUPinner _(thread_get_current_thread());
+
+	while (length &gt; 0) {
+		size_t toCopy = min_c(length, B_PAGE_SIZE - pageOffset);
+
+		addr_t virtualAddress;
+		void* handle;
+		status_t error = vm_get_physical_page_current_cpu(to - pageOffset,
+			&amp;virtualAddress, &amp;handle);
+		if (error != B_OK)
+			return error;
+
+		if (user) {
+			error = user_memcpy((void*)(virtualAddress + pageOffset), from,
+				toCopy);
+		} else
+			memcpy((void*)(virtualAddress + pageOffset), from, toCopy);
+
+		vm_put_physical_page_current_cpu(virtualAddress, handle);
+
+		if (error != B_OK)
+			return error;
+
+		to += toCopy;
+		from += toCopy;
+		length -= toCopy;
+		pageOffset = 0;
+	}
+
+	return B_OK;
+}
+
+
+/*!	NOTE: If this function is used, vm_get_physical_page_current_cpu() must not
+	be blocking, since we need to call it twice and could thus deadlock.
+*/
+void
+generic_vm_memcpy_physical_page(addr_t to, addr_t from)
+{
+	ThreadCPUPinner _(thread_get_current_thread());
+
+	// map source page
+	addr_t fromVirtual;
+	void* fromHandle;
+	status_t error = vm_get_physical_page_current_cpu(from, &amp;fromVirtual,
+		&amp;fromHandle);
+	if (error != B_OK) {
+		panic(&quot;generic_vm_memcpy_physical_page(): Failed to map source page!&quot;);
+		return;
+	}
+
+	// map destination page
+	addr_t toVirtual;
+	void* toHandle;
+	error = vm_get_physical_page_current_cpu(to, &amp;toVirtual, &amp;toHandle);
+	if (error == B_OK) {
+		// both pages are mapped -- copy
+		memcpy((void*)toVirtual, (const void*)fromVirtual, B_PAGE_SIZE);
+		vm_put_physical_page_current_cpu(toVirtual, toHandle);
+	} else {
+		panic(&quot;generic_vm_memcpy_physical_page(): Failed to map destination &quot;
+			&quot;page!&quot;);
+	}
+
+	vm_put_physical_page_current_cpu(fromVirtual, fromHandle);
+}

Added: haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.h
===================================================================
--- haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.h	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/system/kernel/arch/generic/generic_vm_physical_page_ops.h	2008-10-20 00:06:09 UTC (rev 28244)
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2008, Ingo Weinhold &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ingo_weinhold at gmx.de</A>&gt;.
+ * All rights reserved. Distributed under the terms of the MIT License.
+ */
+#ifndef _KERNEL_GENERIC_VM_PHYSICAL_PAGE_OPS_H
+#define _KERNEL_GENERIC_VM_PHYSICAL_PAGE_OPS_H
+
+#include &lt;SupportDefs.h&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+status_t generic_vm_memset_physical(addr_t address, int value, size_t length);
+status_t generic_vm_memcpy_from_physical(void* to, addr_t from, size_t length,
+			bool user);
+status_t generic_vm_memcpy_to_physical(addr_t to, const void* from,
+			size_t length, bool user);
+void generic_vm_memcpy_physical_page(addr_t to, addr_t from);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	// _KERNEL_GENERIC_VM_PHYSICAL_PAGE_OPS_H

Modified: haiku/trunk/src/system/kernel/arch/m68k/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/Jamfile	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/system/kernel/arch/m68k/Jamfile	2008-10-20 00:06:09 UTC (rev 28244)
@@ -47,6 +47,7 @@
 	arch_asm.S
 
 	generic_vm_physical_page_mapper.cpp
+	generic_vm_physical_page_ops.cpp
 
 	:
 	$(TARGET_KERNEL_PIC_CCFLAGS) -Wno-unused

Modified: haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2008-10-19 23:56:48 UTC (rev 28243)
+++ haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2008-10-20 00:06:09 UTC (rev 28244)
@@ -55,9 +55,9 @@
 #include &lt;stdlib.h&gt;
 
 #include &quot;generic_vm_physical_page_mapper.h&quot;
+#include &quot;generic_vm_physical_page_ops.h&quot;
 
 
-
 #define TRACE_VM_TMAP
 #ifdef TRACE_VM_TMAP
 #	define TRACE(x) dprintf x
@@ -119,8 +119,8 @@
 #define IS_KERNEL_MAP(map)		(map-&gt;arch_data-&gt;rtdir_phys == sKernelPhysicalPageRoot)
 
 static status_t early_query(addr_t va, addr_t *out_physical);
-static status_t get_physical_page_tmap(addr_t pa, addr_t *va, uint32 flags);
-static status_t put_physical_page_tmap(addr_t va);
+static status_t get_physical_page_tmap_internal(addr_t pa, addr_t *va, uint32 flags);
+static status_t put_physical_page_tmap_internal(addr_t va);
 
 static void flush_tmap(vm_translation_map *map);
 
@@ -571,7 +571,7 @@
 	}
 	// now, fill in the pentry
 	do {
-		err = get_physical_page_tmap(PRE_TO_PA(pr[rindex]),
+		err = get_physical_page_tmap_internal(PRE_TO_PA(pr[rindex]),
 				&amp;pd_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (err &lt; 0);
 	pd = (page_directory_entry *)pd_pg;
@@ -615,7 +615,7 @@
 	}
 	// now, fill in the pentry
 	do {
-		err = get_physical_page_tmap(PDE_TO_PA(pd[dindex]),
+		err = get_physical_page_tmap_internal(PDE_TO_PA(pd[dindex]),
 				&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (err &lt; 0);
 	pt = (page_table_entry *)pt_pg;
@@ -627,8 +627,8 @@
 	put_page_table_entry_in_pgtable(&amp;pt[pindex], pa, attributes,
 		IS_KERNEL_MAP(map));
 
-	put_physical_page_tmap(pt_pg);
-	put_physical_page_tmap(pd_pg);
+	put_physical_page_tmap_internal(pt_pg);
+	put_physical_page_tmap_internal(pd_pg);
 
 	if (map-&gt;arch_data-&gt;num_invalidate_pages &lt; PAGE_INVALIDATE_CACHE_SIZE)
 		map-&gt;arch_data-&gt;pages_to_invalidate[map-&gt;arch_data-&gt;num_invalidate_pages] = va;
@@ -668,7 +668,7 @@
 	}
 
 	do {
-		status = get_physical_page_tmap(PRE_TO_PA(pr[index]),
+		status = get_physical_page_tmap_internal(PRE_TO_PA(pr[index]),
 			&amp;pd_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pd = (page_directory_entry *)pd_pg;
@@ -679,12 +679,12 @@
 	if (pd[index].type != DT_DIR) {
 		// no pagetable here, move the start up to access the next page table
 		start = ROUNDUP(start + 1, B_PAGE_SIZE);
-		put_physical_page_tmap(pd_pg);
+		put_physical_page_tmap_internal(pd_pg);
 		goto restart;
 	}
 
 	do {
-		status = get_physical_page_tmap(PDE_TO_PA(pd[index]),
+		status = get_physical_page_tmap_internal(PDE_TO_PA(pd[index]),
 			&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pt = (page_table_entry *)pt_pg;
@@ -710,8 +710,8 @@
 		map-&gt;arch_data-&gt;num_invalidate_pages++;
 	}
 
-	put_physical_page_tmap(pt_pg);
-	put_physical_page_tmap(pd_pg);
+	put_physical_page_tmap_internal(pt_pg);
+	put_physical_page_tmap_internal(pd_pg);
 
 	goto restart;
 }
@@ -795,7 +795,7 @@
 	}
 
 	do {
-		status = get_physical_page_tmap(PRE_TO_PA(pr[index]),
+		status = get_physical_page_tmap_internal(PRE_TO_PA(pr[index]),
 			&amp;pd_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pd = (page_directory_entry *)pd_pg;
@@ -806,12 +806,12 @@
 	index = VADDR_TO_PDENT(va);
 	if (pd[index].type != DT_DIR) {
 		// no pagetable here
-		put_physical_page_tmap(pd_pg);
+		put_physical_page_tmap_internal(pd_pg);
 		return B_NO_ERROR;
 	}
 
 	do {
-		status = get_physical_page_tmap(PDE_TO_PA(pd[index]),
+		status = get_physical_page_tmap_internal(PDE_TO_PA(pd[index]),
 			&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pt = (page_table_entry *)pt_pg;
@@ -825,14 +825,14 @@
 		pi = (page_indirect_entry *)pt;
 		pi_pg = pt_pg;
 		do {
-			status = get_physical_page_tmap(PIE_TO_PA(pi[index]),
+			status = get_physical_page_tmap_internal(PIE_TO_PA(pi[index]),
 				&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 		} while (status &lt; B_OK);
 		pt = (page_table_entry *)pt_pg;
 		// add offset from start of page
 		pt += PIE_TO_PO(pi[index]) / sizeof(page_table_entry);
 		// release the indirect table page
-		put_physical_page_tmap(pi_pg);
+		put_physical_page_tmap_internal(pi_pg);
 	}
 
 	*_physical = PTE_TO_PA(pt[index]);
@@ -847,8 +847,8 @@
 		| (pt[index].accessed ? PAGE_ACCESSED : 0)
 		| ((pt[index].type == DT_PAGE) ? PAGE_PRESENT : 0);
 
-	put_physical_page_tmap(pt_pg);
-	put_physical_page_tmap(pd_pg);
+	put_physical_page_tmap_internal(pt_pg);
+	put_physical_page_tmap_internal(pd_pg);
 
 	TRACE((&quot;query_tmap: returning pa 0x%lx for va 0x%lx\n&quot;, *_physical, va));
 
@@ -890,7 +890,7 @@
 	}
 
 	do {
-		status = get_physical_page_tmap(PRE_TO_PA(pr[index]),
+		status = get_physical_page_tmap_internal(PRE_TO_PA(pr[index]),
 			&amp;pd_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pd = (page_directory_entry *)pd_pg;
@@ -901,12 +901,12 @@
 	if (pd[index].type != DT_DIR) {
 		// no pagetable here, move the start up to access the next page table
 		start = ROUNDUP(start + 1, B_PAGE_SIZE);
-		put_physical_page_tmap(pd_pg);
+		put_physical_page_tmap_internal(pd_pg);
 		goto restart;
 	}
 
 	do {
-		status = get_physical_page_tmap(PDE_TO_PA(pd[index]),
+		status = get_physical_page_tmap_internal(PDE_TO_PA(pd[index]),
 			&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pt = (page_table_entry *)pt_pg;
@@ -936,8 +936,8 @@
 		map-&gt;arch_data-&gt;num_invalidate_pages++;
 	}
 
-	put_physical_page_tmap(pt_pg);
-	put_physical_page_tmap(pd_pg);
+	put_physical_page_tmap_internal(pt_pg);
+	put_physical_page_tmap_internal(pd_pg);
 
 	goto restart;
 }
@@ -962,7 +962,7 @@
 	}
 
 	do {
-		status = get_physical_page_tmap(PRE_TO_PA(pr[index]),
+		status = get_physical_page_tmap_internal(PRE_TO_PA(pr[index]),
 			&amp;pd_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pd = (page_directory_entry *)pd_pg;
@@ -973,12 +973,12 @@
 	index = VADDR_TO_PDENT(va);
 	if (pd[index].type != DT_DIR) {
 		// no pagetable here
-		put_physical_page_tmap(pd_pg);
+		put_physical_page_tmap_internal(pd_pg);
 		return B_NO_ERROR;
 	}
 
 	do {
-		status = get_physical_page_tmap(PDE_TO_PA(pd[index]),
+		status = get_physical_page_tmap_internal(PDE_TO_PA(pd[index]),
 			&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 	} while (status &lt; B_OK);
 	pt = (page_table_entry *)pt_pg;
@@ -992,14 +992,14 @@
 		pi = (page_indirect_entry *)pt;
 		pi_pg = pt_pg;
 		do {
-			status = get_physical_page_tmap(PIE_TO_PA(pi[index]),
+			status = get_physical_page_tmap_internal(PIE_TO_PA(pi[index]),
 				&amp;pt_pg, PHYSICAL_PAGE_DONT_WAIT);
 		} while (status &lt; B_OK);
 		pt = (page_table_entry *)pt_pg;
 		// add offset from start of page
 		pt += PIE_TO_PO(pi[index]) / sizeof(page_table_entry);
 		// release the indirect table page
-		put_physical_page_tmap(pi_pg);
+		put_physical_page_tmap_internal(pi_pg);
 	}
 
 	// clear out the flags we've been requested to clear
@@ -1012,8 +1012,8 @@
 		tlb_flush = true;
 	}
 
-	put_physical_page_tmap(pt_pg);
-	put_physical_page_tmap(pd_pg);
+	put_physical_page_tmap_internal(pt_pg);
+	put_physical_page_tmap_internal(pd_pg);
 
 	if (tlb_flush) {
 		if (map-&gt;arch_data-&gt;num_invalidate_pages &lt; PAGE_INVALIDATE_CACHE_SIZE)
@@ -1097,19 +1097,34 @@
 
 

[... truncated: 2549 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012890.html">[Haiku-commits] r28243 - haiku/trunk/src/system/kernel/vm
</A></li>
	<LI>Next message: <A HREF="012892.html">[Haiku-commits] r28244 - in haiku/trunk: headers/private/kernel headers/private/kernel/arch/x86 headers/private/system src/add-ons/kernel/bus_managers/acpi src/add-ons/kernel/bus_managers/ata src/add-ons/kernel/bus_managers/ide src/add-ons/kernel/bus_managers/scsi src/add-ons/kernel/busses/scsi/ahci src/system/kernel/arch/generic src/system/kernel/arch/m68k src/system/kernel/arch/ppc src/system/kernel/arch/x86 src/system/kernel/cache src/system/kernel/device_manager src/system/kernel/fs src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12891">[ date ]</a>
              <a href="thread.html#12891">[ thread ]</a>
              <a href="subject.html#12891">[ subject ]</a>
              <a href="author.html#12891">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
