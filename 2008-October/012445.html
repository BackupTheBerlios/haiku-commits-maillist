<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27913 - haiku/trunk/src/bin
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27913%20-%20haiku/trunk/src/bin&In-Reply-To=%3C200810072140.m97Legpc012259%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012472.html">
   <LINK REL="Next"  HREF="012449.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27913 - haiku/trunk/src/bin</H1>
    <B>julun at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27913%20-%20haiku/trunk/src/bin&In-Reply-To=%3C200810072140.m97Legpc012259%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27913 - haiku/trunk/src/bin">julun at mail.berlios.de
       </A><BR>
    <I>Tue Oct  7 23:40:42 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="012472.html">[Haiku-commits] r27912 - in haiku/trunk: headers/private/kernel headers/private/kernel/arch headers/private/kernel/arch/x86 src/system/kernel src/system/kernel/arch/m68k src/system/kernel/arch/ppc src/system/kernel/arch/x86
</A></li>
        <LI>Next message: <A HREF="012449.html">[Haiku-commits] r27914 - haiku/trunk/src/bin
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12445">[ date ]</a>
              <a href="thread.html#12445">[ thread ]</a>
              <a href="subject.html#12445">[ subject ]</a>
              <a href="author.html#12445">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: julun
Date: 2008-10-07 23:40:39 +0200 (Tue, 07 Oct 2008)
New Revision: 27913
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27913&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27913&amp;view=rev</A>

Modified:
   haiku/trunk/src/bin/hey.cpp
Log:
* whitespace cleanup



Modified: haiku/trunk/src/bin/hey.cpp
===================================================================
--- haiku/trunk/src/bin/hey.cpp	2008-10-07 21:39:19 UTC (rev 27912)
+++ haiku/trunk/src/bin/hey.cpp	2008-10-07 21:40:39 UTC (rev 27913)
@@ -10,7 +10,7 @@
 //		&quot;hey Becasso get AspectRatio of Canvas 0&quot;
 //		outputs
 //		Reply BMessage(B_REPLY):
-//		   &quot;result&quot; (B_DOUBLE_TYPE) : 0.600  
+//		   &quot;result&quot; (B_DOUBLE_TYPE) : 0.600
 //		but &quot;hey -o Becasso get AspectRatio of Canvas 0&quot;
 //		outputs 0.600000 directly.
 //
@@ -43,7 +43,7 @@
 //		          Suites   B_GET_PROPERTY                      DIRECT
 //		       Messenger   B_GET_PROPERTY                      DIRECT
 //		    InternalName   B_GET_PROPERTY                      DIRECT
-//		
+//
 //		            name   value                               kind
 //		--------------------------------------------------------------------------------
 //		          Backup   0x6261636B ('back')                 COMMAND
@@ -52,7 +52,7 @@
 //		                   Usage: Stops the current operation...
 //		       Type Code   0x74797065 ('type')                 TYPE CODE
 //		                   Usage: Type code info...
-// 
+//
 //	You can also use the application defined commands (as the verb) with hey:
 //		hey MyBackupApp Backup &quot;Maui&quot;
 //
@@ -62,7 +62,7 @@
 //      more like english, bare reverse-index-specifiers are now handled, and
 //      named specifiers can contain only digits by quoting it (but make sure the
 //      shell passed the quotes through).
-//      
+//
 //      Hey(target,const char*,reply) was previously limited to 100 tokens.  It
 //      now uses a vector&lt;&gt; so it's only limited by available memory.
 //
@@ -90,15 +90,15 @@
 //
 //		The range specifier sent to the target was 1 greater than it should've been. Fixed.
 //
-//		'hey' made the assumption that the first thread in a team will be the 
-//		application thread (and therefore have the application's name).  
+//		'hey' made the assumption that the first thread in a team will be the
+//		application thread (and therefore have the application's name).
 //		This was not always the case. Fix from Scott Lindsey &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wombat at gobe.com</A>&gt;.
 //
-//v1.1.0:	Flattened BPropertyInfo is printed if found in the reply of B_GET_SUPPORTED_SUITES 
-//		1,2,3 and 4 character message constant is supported (e.g. '1', '12', '123', '1234') 
-//		Alpha is sent with rgb_color 
+//v1.1.0:	Flattened BPropertyInfo is printed if found in the reply of B_GET_SUPPORTED_SUITES
+//		1,2,3 and 4 character message constant is supported (e.g. '1', '12', '123', '1234')
+//		Alpha is sent with rgb_color
 //
-//v1.0.0	First public release 
+//v1.0.0	First public release
 
 
 #include &lt;stdio.h&gt;
@@ -141,33 +141,33 @@
 parse(BMessenger&amp; the_application, int argc, char *argv[], int32 argapp)
 {
 	if (!the_application.IsValid()) {
-		if (!silent) 
+		if (!silent)
 			fprintf(stderr, &quot;Cannot find the application (%s)\n&quot;, argv[argapp]);
 		return B_ERROR;
 	}
 
 	if (argc &lt; 3) {
-		if (!silent) 
+		if (!silent)
 			fprintf(stderr, &quot;Cannot find the verb!\n&quot;);
 		return B_ERROR;
 	}
 
-	
+
 	BMessage the_reply;
 	int32 argx = argapp+1;
 	status_t err = Hey(&amp;the_application, argv, &amp;argx, argc, &amp;the_reply);
 
 	if (err != B_OK) {
-		if (!silent) 
+		if (!silent)
 			fprintf(stderr, &quot;Error when sending message to %s!\n&quot;, argv[argapp]);
 		return B_ERROR;
 	} else {
 		if (the_reply.what == (uint32)B_MESSAGE_NOT_UNDERSTOOD || the_reply.what==(uint32)B_ERROR){	// I do it myself
 			if (the_reply.HasString(&quot;message&quot;)){
-				if (!silent) 
+				if (!silent)
 					printf(&quot;%s (error 0x%8lX)\n&quot;, the_reply.FindString(&quot;message&quot;), the_reply.FindInt32(&quot;error&quot;));
 			} else {
-				if (!silent) 
+				if (!silent)
 					printf(&quot;error 0x%8lX\n&quot;, the_reply.FindInt32(&quot;error&quot;));
 			}
 			return 1;
@@ -231,7 +231,7 @@
 	return B_OK;
 }
 
-int 
+int
 main(int argc, char *argv[])
 {
 	BApplication app(&quot;application/x-amezei-hey&quot;);
@@ -250,14 +250,14 @@
 		&quot;         -o: output result to stdout for easy parsing\n\n&quot;, VERSION);
 		// Updated Usage string to reflect &quot;do&quot;, &quot;the&quot;, bare -index, and '&quot;name&quot;' changes below
 		//   -- <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pfolk at uni.uiuc.edu</A> 1999-11-03
-		
+
 		return 1;
 	}
-	
+
 	int32 argapp = 1;
 	silent = false;
 	output = false;
-	
+
 	// Updated option mechanism --SS
 	for (int i = 0; i &lt; argc; i++) {
 		if (strcmp(argv[i], &quot;-s&quot;)==0 || strcmp(argv[i], &quot;-S&quot;)==0){
@@ -303,25 +303,25 @@
 			}
 		}
 	}
-		
+
 	return 1;
 }
 
 
-int32 
+int32
 HeyInterpreterThreadHook(void* arg)
 {
 	if (!arg)
 		return 1;
-	
+
 	BMessage environment(*(BMessage*) arg);
 	char* prompt = &quot;Hey&quot;;
-	if (environment.HasString(&quot;prompt&quot;)) 
+	if (environment.HasString(&quot;prompt&quot;))
 		environment.FindString(&quot;prompt&quot;, (const char **)&amp;prompt);
 	printf(&quot;%s&gt; &quot;, prompt);
-	
+
 	BMessenger target;
-	if (environment.HasMessenger(&quot;Target&quot;)) 
+	if (environment.HasMessenger(&quot;Target&quot;))
 		environment.FindMessenger(&quot;Target&quot;, &amp;target);
 
 	char command[1024];
@@ -337,11 +337,11 @@
 		}
 		printf(&quot;%s&gt; &quot;, prompt);
 	}
-	
+
 	return 0;
 }
 
-status_t 
+status_t
 Hey(BMessenger* target, const char* arg, BMessage* reply)
 {
 	BList argv; // number of tokens is now limited only by memory  -- <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pfolk at uni.uiuc.edu</A> 1999-11-03
@@ -350,19 +350,19 @@
 	int32 tokenNdex = 0;
 	int32 argNdex = 0;
 	bool inquotes = false;
-	
+
 	while (arg[argNdex] != 0) { // for each character in arg
-		if (arg[argNdex] == '\&quot;') 
+		if (arg[argNdex] == '\&quot;')
 			inquotes = !inquotes;
 		if (!inquotes &amp;&amp; isSpace(arg[argNdex])) { // if the character is white space
 			if (tokenNdex!=0) { //  close off currentToken token
-				currentToken[tokenNdex] = 0; 
+				currentToken[tokenNdex] = 0;
 				argv.AddItem(currentToken);
 				currentToken += tokenNdex+1;
 				tokenNdex=0;
 				argNdex++;
 			} else { // just skip the whitespace
-				argNdex++; 
+				argNdex++;
 			}
 		} else { // copy char into current token
 			currentToken[tokenNdex] = arg[argNdex];
@@ -370,13 +370,13 @@
 			argNdex++;
 		}
 	}
-	
+
 	if (tokenNdex!=0) { //  close off currentToken token
-		currentToken[tokenNdex] = 0; 
+		currentToken[tokenNdex] = 0;
 		argv.AddItem(currentToken);
 	}
 	argv.AddItem(NULL);
-	
+
 	int32 argx = 0;
 	status_t ret = Hey(target, (char **)argv.Items(), &amp;argx, argv.CountItems()-1, reply);
 	  // This used to be &quot;return Hey(...);&quot;---so tokens wasn't delete'd.  -- <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pfolk at uni.uiuc.edu</A> 1999-11-03
@@ -385,7 +385,7 @@
 }
 
 
-bool 
+bool
 isSpace(char c)
 {
 	switch (c) {
@@ -399,7 +399,7 @@
 }
 
 
-status_t 
+status_t
 Hey(BMessenger* target, char* argv[], int32* argx, int32 argc, BMessage* reply)
 {
 	bool direct_what = false;
@@ -412,26 +412,26 @@
 		status_t result=B_OK;
 		while ((result = add_specifier(&amp;get_target, argv, argx, argc))==B_OK)
 			;
-		
+
 		if (result!=B_ERROR){	// bad syntax
-			if (!silent) 
+			if (!silent)
 				fprintf(stderr, &quot;Bad specifier syntax!\n&quot;);
 			return result;
 		}
 		BMessage msgr;
 		if (target &amp;&amp; target-&gt;IsValid()) {
 			result = target-&gt;SendMessage(&amp;get_target, &amp;msgr);
-			if (result!=B_OK) 
+			if (result!=B_OK)
 				return result;
 			result = msgr.FindMessenger (&quot;result&quot;, target);
 			if (result!=B_OK) {
-				if (!silent) 
+				if (!silent)
 					fprintf(stderr, &quot;Couldn't retrieve the BMessenger!\n&quot;);
 				return result;
 			}
 		}
 		if (!argv[*argx]) {
-			if (!silent) 
+			if (!silent)
 				fprintf(stderr, &quot;Syntax error - forgot \&quot;do\&quot;?\n&quot;);
 			return B_ERROR;
 		}
@@ -467,7 +467,7 @@
 			case 3:
 				the_message.what=(((int32)argv[*argx][0])&lt;&lt;16)|(((int32)argv[*argx][1])&lt;&lt;8)|(((int32)argv[*argx][2]));
 				break;
-			case 4:			
+			case 4:
 				the_message.what=(((int32)argv[*argx][0])&lt;&lt;24)|(((int32)argv[*argx][1])&lt;&lt;16)|(((int32)argv[*argx][2])&lt;&lt;8)|(((int32)argv[*argx][3]));
 				break;
 			default:
@@ -483,11 +483,11 @@
 						BPropertyInfo propinfo;
 						const value_info *vinfo;
 						int32 vinfo_index, vinfo_count;
-						
+
 //						const char *str;
 //						while (rply.FindString(&quot;suites&quot;, j++, &amp;str) == B_OK)
 //							printf (&quot;Suite %ld: %s\n&quot;, j, str);
-//							
+//
 //						j = 0;
 						while(rply.FindData(&quot;messages&quot;, B_PROPERTY_INFO_TYPE, j++, (const void **)&amp;voidptr, &amp;sizefound)==B_OK &amp;&amp; !found){
 							if(propinfo.Unflatten(B_PROPERTY_INFO_TYPE, (const void *)voidptr, sizefound)==B_OK){
@@ -497,11 +497,11 @@
 #if TEST_VALUEINFO&gt;0
 								value_info vinfo[10]={	{&quot;Backup&quot;, 'back', B_COMMAND_KIND, &quot;This command backs up your hard drive.&quot;},
 											{&quot;Abort&quot;, 'abor', B_COMMAND_KIND, &quot;Stops the current operation...&quot;},
-											{&quot;Type Code&quot;, 'type', B_TYPE_CODE_KIND, &quot;Type code info...&quot;}	
+											{&quot;Type Code&quot;, 'type', B_TYPE_CODE_KIND, &quot;Type code info...&quot;}
 										};
 								vinfo_count=3;
 #endif
-				
+
 								while(vinfo_index&lt;vinfo_count){
 									if(strcmp(vinfo[vinfo_index].name, argv[*argx])==0){
 										found=true;
@@ -513,7 +513,7 @@
 									}
 									vinfo_index++;
 								}
-								
+
 							}
 						}
 					}
@@ -521,14 +521,14 @@
 
 
 				if(!found){
-					if(!silent) 
+					if(!silent)
 						fprintf(stderr, &quot;Bad verb (\&quot;%s\&quot;)\n&quot;, argv[*argx]);
 					return -1;
 				}
 		}
 		direct_what = true;
 	}
-	
+
 	status_t result = B_OK;
 	(*argx)++;
 
@@ -540,15 +540,15 @@
 		if (the_message.what!=B_REFS_RECEIVED){	// LOAD has no specifier
 			while ((result=add_specifier(&amp;the_message, argv, argx, argc))==B_OK)
 				;
-		
+
 			if (result!=B_ERROR){	// bad syntax
-				if (!silent) 
+				if (!silent)
 					fprintf(stderr, &quot;Bad specifier syntax!\n&quot;);
 				return result;
 			}
 		}
 	}
-	
+
 	// if verb is SET or LOAD, there should be a to &lt;value&gt;
 	if ((the_message.what==B_SET_PROPERTY || the_message.what==B_REFS_RECEIVED) &amp;&amp; argv[*argx]!=NULL){
 		if (strcasecmp(argv[*argx], &quot;to&quot;)==0) {
@@ -557,10 +557,10 @@
 		result = add_data(&amp;the_message, argv, argx);
 		if (result!=B_OK) {
 			if (result==B_FILE_NOT_FOUND){
-				if (!silent) 
+				if (!silent)
 					fprintf(stderr, &quot;File not found!\n&quot;);
 			} else {
-				if (!silent) 
+				if (!silent)
 					fprintf(stderr, &quot;Invalid 'to...' value format!\n&quot;);
 			}
 			return result;
@@ -568,7 +568,7 @@
 	}
 
 	add_with(&amp;the_message, argv, argx, argc);
-	
+
 #if DEBUG_HEY&gt;0
 	fprintf(stderr, &quot;Send &quot;);
 	print_message(&amp;the_message);
@@ -587,7 +587,7 @@
 
 // There can be a with &lt;name&gt;=&lt;type&gt;() [and &lt;name&gt;=&lt;type&gt; ...]
 // I treat &quot;and&quot; just the same as &quot;with&quot;, it's just to make the script syntax more English-like.
-status_t 
+status_t
 add_with(BMessage *to_message, char *argv[], int32 *argx, int32 argc)
 {
 	status_t result = B_OK;
@@ -601,10 +601,10 @@
 				result=add_data(to_message, argv, argx);
 				if (result!=B_OK){
 					if (result==B_FILE_NOT_FOUND){
-						if (!silent) 
+						if (!silent)
 							fprintf(stderr, &quot;File not found!\n&quot;);
 					} else {
-						if (!silent) 
+						if (!silent)
 							fprintf(stderr, &quot;Invalid 'with...' value format!\n&quot;);
 					}
 					return result;
@@ -613,7 +613,7 @@
 				// printf (&quot;argc = %d, argv[%d] = %s\n&quot;, argc, *argx, argv[*argx]);
 				if (*argx &lt; argc - 1 &amp;&amp; strcasecmp(argv[*argx], &quot;and&quot;)==0) {
 					(*argx)++;
-				} else 
+				} else
 					done = true;
 			} while (!done);
 		}
@@ -621,47 +621,47 @@
 	return result;
 }
 
-// returns B_OK if successful 
+// returns B_OK if successful
 //         B_ERROR if no more specifiers
 //         B_BAD_SCRIPT_SYNTAX if syntax error
-status_t 
+status_t
 add_specifier(BMessage *to_message, char *argv[], int32 *argx, int32 argc)
 {
 	char *property=argv[*argx];
-	
+
 	if (property==NULL)
 		return B_ERROR;		// no more specifiers
-	
+
 	(*argx)++;
-	
+
 	if (strcasecmp(property, &quot;do&quot;)==0){	// Part of the &quot;hey App let Specifier do Verb&quot;.
 		return B_ERROR;	// no more specifiers
 	}
-	
+
 	if (strcasecmp(property, &quot;to&quot;)==0){	// it is the 'to' string!!!
 		return B_ERROR;	// no more specifiers
 	}
-	
+
 	if (strcasecmp(property, &quot;with&quot;)==0){	// it is the 'with' string!!!
 		*argx -= 2;
 		add_with (to_message, argv, argx, argc);
 		return B_ERROR;	// no more specifiers
 	}
-	
+
 	if (strcasecmp(property, &quot;of&quot;)==0){		// skip &quot;of&quot;, read real property
 		property = argv[*argx];
-		if (property==NULL) 
+		if (property==NULL)
 			return B_BAD_SCRIPT_SYNTAX;		// bad syntax
 		(*argx)++;
 	}
-	
+
 	if (strcasecmp(property, &quot;the&quot;)==0){		// skip &quot;the&quot;, read real property  -- <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pfolk at uni.uiuc.edu</A> 1999-11-03
 		property = argv[*argx];
-		if (property==NULL) 
+		if (property==NULL)
 			return B_BAD_SCRIPT_SYNTAX;		// bad syntax
 		(*argx)++;
 	}
-	
+
 	// decide the specifier
 
 	char *specifier = NULL;
@@ -678,12 +678,12 @@
 
 	if (strcasecmp(specifier, &quot;of&quot;)==0){	// direct specifier
 		to_message-&gt;AddSpecifier(property);
-		return B_OK;	
+		return B_OK;
 	}
 
 	if (strcasecmp(specifier, &quot;to&quot;)==0){	// direct specifier
 		to_message-&gt;AddSpecifier(property);
-		return B_ERROR;		// no more specifiers	
+		return B_ERROR;		// no more specifiers
 	}
 
 
@@ -700,14 +700,14 @@
 			ix1 = strtoul(specifier+1, &amp;end, 10);
 			if (end[0]==']'){	// it was an index
 				to_message-&gt;AddSpecifier(property, ix1);
-				return B_OK;	
+				return B_OK;
 			} else {
 				specifier=argv[*argx];
 				if (specifier==NULL){
 					// I was wrong, it was just an index
 					to_message-&gt;AddSpecifier(property, ix1);
-					return B_OK;	
-				}		
+					return B_OK;
+				}
 				(*argx)++;
 				if (strcasecmp(specifier, &quot;to&quot;)==0){
 					specifier = argv[*argx];
@@ -717,7 +717,7 @@
 					(*argx)++;
 					ix2 = strtoul(specifier, &amp;end, 10);
 					to_message-&gt;AddSpecifier(property, ix1, ix2-ix1&gt;0 ? ix2-ix1 : 1);
-					return B_OK;		
+					return B_OK;
 				} else {
 					return B_BAD_SCRIPT_SYNTAX;		// wrong syntax
 				}
@@ -735,7 +735,7 @@
 				break;
 			}
 		}
-		
+
 		if (index_spec){
 			if (reverse) {
 				// Copied from above  -- <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pfolk at uni.uiuc.edu</A> 1999-11-03
@@ -744,7 +744,7 @@
 				revspec.AddInt32(&quot;index&quot;, atol(specifier+1));
 				to_message-&gt;AddSpecifier(&amp;revspec);
 			}
-			else 
+			else
 				to_message-&gt;AddSpecifier(property, atol(specifier));
 		} else {
 			// Allow any name by counting an initial &quot; as a literal-string indicator
@@ -758,19 +758,19 @@
 			to_message-&gt;AddSpecifier(property, specifier);
 		}
 	}
-	
+
 	return B_OK;
 }
 
 
-status_t 
+status_t
 add_data(BMessage *to_message, char *argv[], int32 *argx)
 {
 	char *valuestring=argv[*argx];
-	
-	if (valuestring==NULL) 
+
+	if (valuestring==NULL)
 		return B_ERROR;
-	
+
 	// try to interpret it as an integer or float
 	bool contains_only_digits = true;
 	bool is_floating_point = false;
@@ -796,7 +796,7 @@
 			return B_OK;
 		}
 	}
-	
+
 	// if true or false, it is bool
 	if (strcasecmp(valuestring, &quot;true&quot;)==0){
 		to_message-&gt;AddBool(&quot;data&quot;, true);
@@ -812,12 +812,12 @@
 	#define MAX_NAME_LENGTH 128
 	char curname[MAX_NAME_LENGTH];
 	strcpy (curname, &quot;data&quot;);	// This is the default.
-	
+
 	char *s = valuestring;
 	while (*++s &amp;&amp; *s != '=')
 		// Look for a '=' character...
 		;
-	if (*s == '=') {	// We found a &lt;name&gt;= 
+	if (*s == '=') {	// We found a &lt;name&gt;=
 		*s = 0;
 		strcpy (curname, valuestring);	// Use the new &lt;name&gt;
 		valuestring = s + 1;			// Reposition the valuestring ptr.
@@ -879,7 +879,7 @@
 				}
 			}
 		}
-		
+
 		to_message-&gt;AddRect(curname, BRect(l,t,r,b));
 		return B_OK;
 	} else if (strncasecmp(valuestring, &quot;rgb_color&quot;, strlen(&quot;rgb_color&quot;))==0){
@@ -898,26 +898,26 @@
 				}
 			}
 		}
-		
+
 		to_message-&gt;AddData(curname, B_RGB_COLOR_TYPE, &amp;clr, sizeof(rgb_color));
 		return B_OK;
 	} else if (strncasecmp(valuestring, &quot;file&quot;, strlen(&quot;file&quot;))==0){
 		entry_ref file_ref;
-		
+
 		// remove the last ] or )
 		if (valuestring[strlen(valuestring)-1]==')' || valuestring[strlen(valuestring)-1]==']'){
 			valuestring[strlen(valuestring)-1] = 0;
 		}
-		
+
 		if (get_ref_for_path(valuestring+5, &amp;file_ref)!=B_OK){
 			return B_FILE_NOT_FOUND;
 		}
-		
+
 		// check if the ref is valid
 		BEntry entry;
 		if (entry.SetTo(&amp;file_ref)!=B_OK) return B_FILE_NOT_FOUND;
 		//if(!entry.Exists())  return B_FILE_NOT_FOUND;
-		
+
 		// add both ways, refsreceived needs it as &quot;refs&quot; while scripting needs &quot;data&quot;
 		to_message-&gt;AddRef(&quot;refs&quot;, &amp;file_ref);
 		to_message-&gt;AddRef(curname, &amp;file_ref);
@@ -937,12 +937,12 @@
 }
 
 
-void 
+void
 print_message(BMessage *message)
 {
 	BList textlist;
 	add_message_contents(&amp;textlist, message, 0);
-	
+
 	char *whatString = get_datatype_string(message-&gt;what);
 	printf(&quot;BMessage(%s):\n&quot;, whatString);
 	free(whatString);
@@ -954,7 +954,7 @@
 }
 
 
-void 
+void
 add_message_contents(BList *textlist, BMessage *msg, int32 level)
 {
 	int32 count;
@@ -968,13 +968,13 @@
 	void *voidptr;
 	BMessage a_message;
 	char *textline, *datatype, *content;
-	
+
 	// go though all message data
 	count = msg-&gt;CountNames(B_ANY_TYPE);
 	for (i=0; i&lt;count; i++){
 		msg-&gt;GetInfo(B_ANY_TYPE, i, &amp;namefound, &amp;typefound);
 		j = 0;
-		
+
 		while (msg-&gt;FindData(namefound, typefound, j++, (const void **)&amp;voidptr, &amp;sizefound)==B_OK){
 			datatype = get_datatype_string(typefound);
 			content = format_data(typefound, (char*)voidptr, sizefound);
@@ -984,7 +984,7 @@
 			textlist-&gt;AddItem(textline);
 			delete [] datatype;
 			delete [] content;
-			
+
 			if (typefound==B_MESSAGE_TYPE){
 				msg-&gt;FindMessage(namefound, j-1, &amp;a_message);
 				add_message_contents(textlist, &amp;a_message, level+1);
@@ -1002,7 +1002,7 @@
 get_datatype_string(int32 type)
 {
 	char *str = new char[128];
-	
+
 	switch (type){
 		case B_ANY_TYPE:	strcpy(str, &quot;B_ANY_TYPE&quot;); break;
 		case B_ASCII_TYPE:	strcpy(str, &quot;B_ASCII_TYPE&quot;); break;
@@ -1107,12 +1107,12 @@
 		case B_NAME_SPECIFIER	 :	strcpy(str, &quot;B_NAME_SPECIFIER&quot;); break;
 
 		case B_ERROR	 :	strcpy(str, &quot;B_ERROR&quot;); break;
-				
+
 		default:	// unknown
 					id_to_string(type, str);
 					break;
 	}
-	
+
 	return str;
 
 }
@@ -1139,7 +1139,7 @@
 	uint8 ui8;
 	BMessage anothermsg;
 	char *tempstr;
-	
+
 	if (size&lt;=0L){
 		str = new char;
 		*str = 0;
@@ -1150,7 +1150,7 @@
 		case B_MIME_TYPE:
 		case B_ASCII_TYPE:
 		case B_STRING_TYPE:
-					if (size&gt;512) 
+					if (size&gt;512)
 						size=512;
 					str = new char[size+4];
 					*str='\&quot;';
@@ -1173,58 +1173,58 @@
 						strcpy(str, &quot;invalid entry_ref&quot;);
 					}
 					break;
-					
+
 		case B_SSIZE_T_TYPE:
 		case B_INT64_TYPE:
 					str = new char[64];
 					i64 = *(int64*)ptr;
 					sprintf(str, &quot;%Ld (0x%LX)&quot;, i64, i64);
 					break;
-		
+
 		case B_SIZE_T_TYPE:
 		case B_INT32_TYPE:
 					str = new char[64];
 					i32 = *(int32*)ptr;
 					sprintf(str, &quot;%ld (0x%08lX)&quot;, i32, i32);
 					break;
-		
+
 		case B_INT16_TYPE:
 					str = new char[64];
 					i16 = *(int16*)ptr;
 					sprintf(str, &quot;%d (0x%04X)&quot;, i16, i16);
 					break;
-		
+
 		case B_CHAR_TYPE:
 		case B_INT8_TYPE:
 					str = new char[64];
 					i8 = *(int8*)ptr;
 					sprintf(str, &quot;%d (0x%02X)&quot;, i8, i8);
 					break;
-		
+
 		case B_UINT64_TYPE:
 					str = new char[64];
 					ui64 = *(uint64*)ptr;
 					sprintf(str, &quot;%Lu (0x%LX)&quot;, ui64, ui64);
 					break;
-		
+
 		case B_UINT32_TYPE:
 					str = new char[64];
 					ui32 = *(uint32*)ptr;
 					sprintf(str, &quot;%lu (0x%08lX)&quot;, ui32, ui32);
 					break;
-		
+
 		case B_UINT16_TYPE:
 					str = new char[64];
 					ui16 = *(uint16*)ptr;
 					sprintf(str, &quot;%u (0x%04X)&quot;, ui16, ui16);
 					break;
-		
+
 		case B_UINT8_TYPE:
 					str = new char[64];
 					ui8 = *(uint8*)ptr;
 					sprintf(str, &quot;%u (0x%02X)&quot;, ui8, ui8);
 					break;
-		
+
 		case B_BOOL_TYPE:
 					str = new char[10];
 					if (*ptr){
@@ -1233,36 +1233,36 @@
 						strcpy(str, &quot;FALSE&quot;);
 					}
 					break;
-					
+
 		case B_FLOAT_TYPE:
 					str = new char[40];
 					fptr = (float*)ptr;
 					sprintf(str, &quot;%.3f&quot;, *fptr);
 					break;
-					
+
 		case B_DOUBLE_TYPE:
 					str = new char[40];
 					dptr = (double*)ptr;
 					sprintf(str, &quot;%.3f&quot;, *dptr);
 					break;
-					
+
 		case B_RECT_TYPE:
 					str = new char[200];
 					fptr = (float*)ptr;
 					sprintf(str, &quot;BRect(%.1f, %.1f, %.1f, %.1f)&quot;, fptr[0], fptr[1], fptr[2], fptr[3]);
 					break;
-					
+
 		case B_POINT_TYPE:
 					str = new char[200];
 					fptr = (float*)ptr;
 					sprintf(str, &quot;BPoint(%.1f, %.1f)&quot;, fptr[0], fptr[1]);
 					break;
 
-		case B_RGB_COLOR_TYPE:	
+		case B_RGB_COLOR_TYPE:
 					str = new char[64];
 					sprintf(str, &quot;Red=%u  Green=%u  Blue=%u  Alpha=%u&quot;, ((uint8*)ptr)[0], ((uint8*)ptr)[1], ((uint8*)ptr)[2], ((uint8*)ptr)[3] );
 					break;
-					
+
 		case B_COLOR_8_BIT_TYPE:
 					str = new char[size*6+4];
 					*str = 0;
@@ -1283,7 +1283,7 @@
 						strcpy(str, &quot;error when unflattening&quot;);
 					}
 					break;
-					
+
 		case B_PROPERTY_INFO_TYPE: {
 					BPropertyInfo propinfo;
 					if (propinfo.Unflatten(B_PROPERTY_INFO_TYPE, (const void *)ptr, size)==B_OK){
@@ -1308,7 +1308,7 @@
 								strcat(str, &quot; &quot;);
 								delete [] tempstr;
 							}
-							
+
 							// pad the rest with spaces
 							if (strlen(start)&lt;36){
 								strcat(str, &quot;                                    &quot;+strlen(start) );
@@ -1329,7 +1329,7 @@
 									default: strcat(str, &quot;&lt;NONE&gt; &quot;); break;
 								}
 							}
-							
+
 							// pad the rest with spaces
 							if (strlen(start)&lt;60){
 								strcat(str, &quot;                                                            &quot;+strlen(start) );
@@ -1348,15 +1348,15 @@
 								for (int32 j = 0; j &lt; 5 &amp;&amp; pinfo[pinfo_index].ctypes[i].pairs[j].type != 0; j++) {
 									uint32 type = pinfo[pinfo_index].ctypes[i].pairs[j].type;
 									char str2[4];
-									sprintf(str2, &quot;(%s %c%c%c%c)&quot;, pinfo[pinfo_index].ctypes[i].pairs[j].name, 
+									sprintf(str2, &quot;(%s %c%c%c%c)&quot;, pinfo[pinfo_index].ctypes[i].pairs[j].name,
 										int(type &amp; 0xFF000000) &gt;&gt; 24,
-										int(type &amp; 0xFF0000) &gt;&gt; 16, 
+										int(type &amp; 0xFF0000) &gt;&gt; 16,
 										int(type &amp; 0xFF00) &gt;&gt; 8, (int)type &amp; 0xFF);
 									strcat(str, str2);
 								}
 							}
 							strcat(str, &quot;\n&quot;);
-							
+
 							// is there usage info?
 							if (pinfo[pinfo_index].usage){
 								strcat(str, &quot;                   Usage: &quot;);
@@ -1365,29 +1365,29 @@
 							}
 
 						}
-						
-						
+
+
 						// handle value infos....
 						const value_info *vinfo = propinfo.Values();
 						int32 vinfo_count = propinfo.CountValues();
 #if TEST_VALUEINFO&gt;0
 						value_info vinfo[10] = {	{&quot;Backup&quot;, 'back', B_COMMAND_KIND, &quot;This command backs up your hard drive.&quot;},
 										{&quot;Abort&quot;, 'abor', B_COMMAND_KIND, &quot;Stops the current operation...&quot;},
-										{&quot;Type Code&quot;, 'type', B_TYPE_CODE_KIND, &quot;Type code info...&quot;}	
+										{&quot;Type Code&quot;, 'type', B_TYPE_CODE_KIND, &quot;Type code info...&quot;}
 									};
 						vinfo_count = 3;
 #endif
 
 						if (vinfo &amp;&amp; vinfo_count&gt;0){
 							sprintf(str+strlen(str), &quot;\n            name   value                               kind\n--------------------------------------------------------------------------------\n&quot;);
-							
+
 							for (int32 vinfo_index = 0; vinfo_index&lt;vinfo_count; vinfo_index++){
-							
+
 								char *start = str+strlen(str);
 								strcat(str, &quot;                &quot;+(strlen(vinfo[vinfo_index].name) &lt;16 ? strlen(vinfo[vinfo_index].name) : 16 ));
 								strcat(str, vinfo[vinfo_index].name);
 								strcat(str, &quot;   &quot;);
-							
+
 								sprintf(str+strlen(str), &quot;0x%8lX (&quot;, vinfo[vinfo_index].value);
 								id_to_string(vinfo[vinfo_index].value, str+strlen(str));
 								strcat(str, &quot;)&quot;);
@@ -1404,9 +1404,9 @@
 									case B_TYPE_CODE_KIND: 	strcat(str, &quot;TYPE CODE       &quot;); break;
 									default:				strcat(str, &quot;unknown         &quot;); break;
 								}
-	
+
 								strcat(str, &quot;\n&quot;);
-								
+
 								// is there usage info?
 								if (vinfo[vinfo_index].usage){
 									strcat(str, &quot;                   Usage: &quot;);
@@ -1415,7 +1415,7 @@
 								}
 							}
 						}
-						
+
 					} else {
 						str = new char[64];
 						strcpy(str, &quot;error when unflattening&quot;);
@@ -1434,9 +1434,9 @@
 					*(str+strlen(str)-2) = 0;
 					break;
 	}
-	
+
 	return str;
-	
+
 }
 
 
@@ -1448,33 +1448,33 @@
 	uint8 digit2 = (ID&gt;&gt;8) &amp; 255;
 	uint8 digit3 = (ID) &amp; 255;
 	bool itsvalid = false;
-	
+
 	if (digit0==0){
 		if (digit1==0){
 			if (digit2==0) {
 				// 1 digits
-				if (is_valid_char(digit3) ) 
+				if (is_valid_char(digit3) )
 					itsvalid=TRUE;
 				sprintf(here, &quot;'%c'&quot;, digit3);
 			} else {
 				// 2 digits
-				if (is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) ) 
+				if (is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) )
 					itsvalid=TRUE;
 				sprintf(here, &quot;'%c%c'&quot;, digit2, digit3);
 			}
 		} else {
 			// 3 digits
-			if (is_valid_char(digit1) &amp;&amp; is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) ) 
+			if (is_valid_char(digit1) &amp;&amp; is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) )
 				itsvalid=TRUE;
 			sprintf(here, &quot;'%c%c%c'&quot;, digit1, digit2, digit3);
 		}
 	} else {
 		// 4 digits
-		if (is_valid_char(digit0) &amp;&amp; is_valid_char(digit1) &amp;&amp; is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) ) 
+		if (is_valid_char(digit0) &amp;&amp; is_valid_char(digit1) &amp;&amp; is_valid_char(digit2) &amp;&amp; is_valid_char(digit3) )
 			itsvalid=TRUE;
 		sprintf(here, &quot;'%c%c%c%c'&quot;, digit0, digit1, digit2, digit3);
 	}
-	
+
 	if (!itsvalid){
 		sprintf(here, &quot;%ldL&quot;, ID);
 	}
@@ -1483,7 +1483,7 @@
 }
 
 
-bool 
+bool
 is_valid_char(uint8 c)
 {
 	return (c&gt;=32 &amp;&amp; c&lt;128);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012472.html">[Haiku-commits] r27912 - in haiku/trunk: headers/private/kernel headers/private/kernel/arch headers/private/kernel/arch/x86 src/system/kernel src/system/kernel/arch/m68k src/system/kernel/arch/ppc src/system/kernel/arch/x86
</A></li>
	<LI>Next message: <A HREF="012449.html">[Haiku-commits] r27914 - haiku/trunk/src/bin
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12445">[ date ]</a>
              <a href="thread.html#12445">[ thread ]</a>
              <a href="subject.html#12445">[ subject ]</a>
              <a href="author.html#12445">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
