<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r27857 - in haiku/trunk/src: apps/soundrecorder	apps/text_search kits/tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27857%20-%20in%20haiku/trunk/src%3A%20apps/soundrecorder%0A%09apps/text_search%20kits/tracker&In-Reply-To=%3C200810031235.m93CZwVV007736%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="012345.html">
   <LINK REL="Next"  HREF="012347.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r27857 - in haiku/trunk/src: apps/soundrecorder	apps/text_search kits/tracker</H1>
    <B>julun at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r27857%20-%20in%20haiku/trunk/src%3A%20apps/soundrecorder%0A%09apps/text_search%20kits/tracker&In-Reply-To=%3C200810031235.m93CZwVV007736%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r27857 - in haiku/trunk/src: apps/soundrecorder	apps/text_search kits/tracker">julun at mail.berlios.de
       </A><BR>
    <I>Fri Oct  3 14:35:58 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="012345.html">[Haiku-commits] r27856 - haiku/trunk/src/apps/showimage
</A></li>
        <LI>Next message: <A HREF="012347.html">[Haiku-commits] r27858 - in haiku/trunk/src: apps/soundrecorder	apps/text_search kits/tracker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12346">[ date ]</a>
              <a href="thread.html#12346">[ thread ]</a>
              <a href="subject.html#12346">[ subject ]</a>
              <a href="author.html#12346">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: julun
Date: 2008-10-03 14:35:57 +0200 (Fri, 03 Oct 2008)
New Revision: 27857
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=27857&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=27857&amp;view=rev</A>

Modified:
   haiku/trunk/src/apps/soundrecorder/RecorderWindow.cpp
   haiku/trunk/src/apps/text_search/GrepWindow.cpp
   haiku/trunk/src/kits/tracker/InfoWindow.cpp
Log:
* whitespace cleanup



Modified: haiku/trunk/src/apps/soundrecorder/RecorderWindow.cpp
===================================================================
--- haiku/trunk/src/apps/soundrecorder/RecorderWindow.cpp	2008-10-03 12:32:52 UTC (rev 27856)
+++ haiku/trunk/src/apps/soundrecorder/RecorderWindow.cpp	2008-10-03 12:35:57 UTC (rev 27857)
@@ -55,7 +55,7 @@
 #define CONNECT FPRINTF
 #define WINDOW FPRINTF
 
-// default window positioning 
+// default window positioning
 static const float MIN_WIDTH = 400.0f;
 static const float MIN_HEIGHT = 336.0f;
 static const float XPOS = 100.0f;
@@ -64,27 +64,27 @@
 #define FOURCC(a,b,c,d)	((((uint32)(d)) &lt;&lt; 24) | (((uint32)(c)) &lt;&lt; 16) | (((uint32)(b)) &lt;&lt; 8) | ((uint32)(a)))
 
 struct riff_struct
-{ 
+{
 	uint32 riff_id; // 'RIFF'
 	uint32 len;
 	uint32 wave_id;	// 'WAVE'
-}; 
+};
 
-struct chunk_struct 
-{ 
+struct chunk_struct
+{
 	uint32 fourcc;
 	uint32 len;
 };
 
-struct format_struct 
-{ 
-	uint16 format_tag; 
-	uint16 channels; 
-	uint32 samples_per_sec; 
-	uint32 avg_bytes_per_sec; 
-	uint16 block_align; 
+struct format_struct
+{
+	uint16 format_tag;
+	uint16 channels;
+	uint32 samples_per_sec;
+	uint32 avg_bytes_per_sec;
+	uint16 block_align;
 	uint16 bits_per_sample;
-}; 
+};
 
 
 struct wave_struct
@@ -97,7 +97,7 @@
 
 
 RecorderWindow::RecorderWindow() :
-	BWindow(BRect(XPOS,YPOS,XPOS+MIN_WIDTH,YPOS+MIN_HEIGHT), &quot;SoundRecorder&quot;, B_TITLED_WINDOW, 
+	BWindow(BRect(XPOS,YPOS,XPOS+MIN_WIDTH,YPOS+MIN_HEIGHT), &quot;SoundRecorder&quot;, B_TITLED_WINDOW,
 		B_ASYNCHRONOUS_CONTROLS | B_NOT_V_RESIZABLE),
 		fPlayer(NULL),
 		fSoundList(NULL),
@@ -122,7 +122,7 @@
 	fButtonState = btnPaused;
 
 	CalcSizes(MIN_WIDTH, MIN_HEIGHT);
-	
+
 	fInitCheck = InitWindow();
 	if (fInitCheck != B_OK) {
 		ErrorAlert(&quot;connect to media server&quot;, fInitCheck);
@@ -141,14 +141,14 @@
 	if (fPlayer) {
 		delete fPlayer;
 	}
-	
+
 	if (fPlayTrack &amp;&amp; fPlayFile)
 		fPlayFile-&gt;ReleaseTrack(fPlayTrack);
 	if (fPlayFile)
 		delete fPlayFile;
 	fPlayTrack = NULL;
 	fPlayFile = NULL;
-	
+
 	//	Clean up items in list view.
 	if (fSoundList) {
 		fSoundList-&gt;DeselectAll();
@@ -200,7 +200,7 @@
 {
 	BPopUpMenu * popup = 0;
 	status_t error;
-	
+
 	try {
 		//	Find temp directory for recorded sounds.
 		BPath path;
@@ -241,21 +241,21 @@
 			B_WILL_DRAW|B_FRAME_EVENTS|B_NAVIGABLE_JUMP, B_PLAIN_BORDER);
 		AddChild(background);
 
-		
-		
+
+
 		r = background-&gt;Bounds();
 		r.left = 2;
 		r.right = r.left + 37;
 		r.bottom = r.top + 104;
 		fVUView = new VUView(r, B_FOLLOW_LEFT|B_FOLLOW_TOP);
 		background-&gt;AddChild(fVUView);
-		
+
 		r = background-&gt;Bounds();
 		r.left = r.left + 40;
 		r.bottom = r.top + 104;
 		fScopeView = new ScopeView(r, B_FOLLOW_LEFT_RIGHT|B_FOLLOW_TOP);
 		background-&gt;AddChild(fScopeView);
-		
+
 		r = background-&gt;Bounds();
 		r.left = 2;
 		r.right -= 26;
@@ -263,89 +263,89 @@
 		r.bottom = r.top + 30;
 		fTrackSlider = new TrackSlider(r, &quot;trackSlider&quot;, new BMessage(POSITION_CHANGED), B_FOLLOW_LEFT_RIGHT|B_FOLLOW_TOP);
 		background-&gt;AddChild(fTrackSlider);
-		
+
 		BRect buttonRect;
-  
+
   		//	Button for rewinding
 		buttonRect = BRect(BPoint(0,0), kSkipButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-7, 25));
-		fRewindButton = new TransportButton(buttonRect, &quot;Rewind&quot;, 
-			kSkipBackBitmapBits, kPressedSkipBackBitmapBits, kDisabledSkipBackBitmapBits, 
+		fRewindButton = new TransportButton(buttonRect, &quot;Rewind&quot;,
+			kSkipBackBitmapBits, kPressedSkipBackBitmapBits, kDisabledSkipBackBitmapBits,
 			new BMessage(REWIND));
 		background-&gt;AddChild(fRewindButton);
-		
+
 		//	Button for stopping recording or playback
 		buttonRect = BRect(BPoint(0,0), kStopButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-48, 25));
-		fStopButton = new TransportButton(buttonRect, &quot;Stop&quot;, 
-			kStopButtonBitmapBits, kPressedStopButtonBitmapBits, kDisabledStopButtonBitmapBits, 
+		fStopButton = new TransportButton(buttonRect, &quot;Stop&quot;,
+			kStopButtonBitmapBits, kPressedStopButtonBitmapBits, kDisabledStopButtonBitmapBits,
 			new BMessage(STOP));
 		background-&gt;AddChild(fStopButton);
-		
+
 		//	Button for starting playback of selected sound
 		BRect playRect(BPoint(0,0), kPlayButtonSize);
 		playRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-82, 25));
-		fPlayButton = new PlayPauseButton(playRect, &quot;Play&quot;, 
+		fPlayButton = new PlayPauseButton(playRect, &quot;Play&quot;,
 			new BMessage(PLAY), new BMessage(PLAY_PERIOD), ' ', 0);
 		background-&gt;AddChild(fPlayButton);
-		
+
 		//	Button for forwarding
 		buttonRect = BRect(BPoint(0,0), kSkipButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-133, 25));
-		fForwardButton = new TransportButton(buttonRect, &quot;Forward&quot;, 
-			kSkipForwardBitmapBits, kPressedSkipForwardBitmapBits, kDisabledSkipForwardBitmapBits, 
+		fForwardButton = new TransportButton(buttonRect, &quot;Forward&quot;,
+			kSkipForwardBitmapBits, kPressedSkipForwardBitmapBits, kDisabledSkipForwardBitmapBits,
 			new BMessage(FORWARD));
 		background-&gt;AddChild(fForwardButton);
-		
+
 		//	Button to start recording (or waiting for sound)
 		buttonRect = BRect(BPoint(0,0), kRecordButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-174, 25));
-		fRecordButton = new RecordButton(buttonRect, &quot;Record&quot;, 
+		fRecordButton = new RecordButton(buttonRect, &quot;Record&quot;,
 			new BMessage(RECORD), new BMessage(RECORD_PERIOD));
 		background-&gt;AddChild(fRecordButton);
 
 		//	Button for saving selected sound
 		buttonRect = BRect(BPoint(0,0), kDiskButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().LeftBottom() - BPoint(-250, 21));
-		fSaveButton = new TransportButton(buttonRect, &quot;Save&quot;, 
+		fSaveButton = new TransportButton(buttonRect, &quot;Save&quot;,
 			kDiskButtonBitmapsBits, kPressedDiskButtonBitmapsBits, kDisabledDiskButtonBitmapsBits, new BMessage(SAVE));
 		fSaveButton-&gt;SetResizingMode(B_FOLLOW_RIGHT | B_FOLLOW_TOP);
 		background-&gt;AddChild(fSaveButton);
-		
+
 		//	Button Loop
 		buttonRect = BRect(BPoint(0,0), kArrowSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().RightBottom() - BPoint(23, 48));
-		fLoopButton = new DrawButton(buttonRect, &quot;Loop&quot;, 
+		fLoopButton = new DrawButton(buttonRect, &quot;Loop&quot;,
 			kLoopArrowBits, kArrowBits, new BMessage(LOOP));
 		fLoopButton-&gt;SetResizingMode(B_FOLLOW_RIGHT | B_FOLLOW_TOP);
 		fLoopButton-&gt;SetTarget(this);
 		background-&gt;AddChild(fLoopButton);
-		
+
 		buttonRect = BRect(BPoint(0,0), kSpeakerIconBitmapSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().RightBottom() - BPoint(121, 17));
 		SpeakerView *speakerView = new SpeakerView(buttonRect, B_FOLLOW_LEFT | B_FOLLOW_TOP);
 		speakerView-&gt;SetResizingMode(B_FOLLOW_RIGHT | B_FOLLOW_TOP);
 		background-&gt;AddChild(speakerView);
-				
+
 		buttonRect = BRect(BPoint(0,0), BPoint(84, 19));
 		buttonRect.OffsetTo(background-&gt;Bounds().RightBottom() - BPoint(107, 20));
 		fVolumeSlider = new VolumeSlider(buttonRect, &quot;volumeSlider&quot;, B_FOLLOW_LEFT | B_FOLLOW_TOP);
 		fVolumeSlider-&gt;SetResizingMode(B_FOLLOW_RIGHT | B_FOLLOW_TOP);
 		background-&gt;AddChild(fVolumeSlider);
-		
+
 		// Button to mask/see sounds list
 		buttonRect = BRect(BPoint(0,0), kUpDownButtonSize);
 		buttonRect.OffsetTo(background-&gt;Bounds().RightBottom() - BPoint(21, 25));
 		fUpDownButton = new UpDownButton(buttonRect, new BMessage(VIEW_LIST));
 		fUpDownButton-&gt;SetResizingMode(B_FOLLOW_RIGHT | B_FOLLOW_TOP);
 		background-&gt;AddChild(fUpDownButton);
-		
+
 		r = Bounds();
 		r.top = background-&gt;Bounds().bottom + 1;
 		fBottomBox = new BBox(r, &quot;bottomBox&quot;, B_FOLLOW_ALL);
 		fBottomBox-&gt;SetBorder(B_NO_BORDER);
 		AddChild(fBottomBox);
-		
+
 		//	The actual list of recorded sounds (initially empty) sits
 		//	below the header with the controls.
 		r = fBottomBox-&gt;Bounds();
@@ -361,7 +361,7 @@
 		BScrollView *scroller = new BScrollView(&quot;scroller&quot;, fSoundList, B_FOLLOW_ALL,
 			0, false, true, B_FANCY_BORDER);
 		fBottomBox-&gt;AddChild(scroller);
-		
+
 		r = fBottomBox-&gt;Bounds();
 		r.right = r.left + 190;
 		r.bottom -= 25;
@@ -369,7 +369,7 @@
 		r.top -= 1;
 		fFileInfoBox = new BBox(r, &quot;fileinfo&quot;, B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);
 		fFileInfoBox-&gt;SetLabel(&quot;File Info&quot;);
-		
+
 		r = fFileInfoBox-&gt;Bounds();
 		r.left = 8;
 		r.top = 13;
@@ -401,13 +401,13 @@
 		r.bottom = r.top + 15;
 		fDuration = new BStringView(r, &quot;duration&quot;, &quot;Duration:&quot;);
 		fFileInfoBox-&gt;AddChild(fDuration);
-		
+
 		//	Input selection lists all available physical inputs that produce
 		//	buffers with B_MEDIA_RAW_AUDIO format data.
 		popup = new BPopUpMenu(&quot;Input&quot;);
 		int max_input_count = 64;
 		dormant_node_info dni[max_input_count];
-		
+
 		int32 real_count = max_input_count;
 		media_format output_format;
 		output_format.type = B_MEDIA_RAW_AUDIO;
@@ -436,7 +436,7 @@
 						break;
 					}
 		}
-		
+
 		//	Create the actual widget
 		BRect frame(fBottomBox-&gt;Bounds());
 		r = frame;
@@ -463,16 +463,16 @@
 		r.bottom -= 1;
 		BStringView* lenUnits = new BStringView(r, &quot;Seconds&quot;, &quot;seconds&quot;);
 		fBottomBox-&gt;AddChild(lenUnits);
-		
+
 		fBottomBox-&gt;AddChild(fFileInfoBox);
-		
+
 		fBottomBox-&gt;Hide();
 		CalcSizes(Frame().Width(), MIN_HEIGHT-161);
 		ResizeTo(Frame().Width(), MIN_HEIGHT-161);
 
-		
+
 		popup-&gt;Superitem()-&gt;SetLabel(selected_name);
-		
+
 		// Make sure the save panel is happy.
 		fSavePanel = new BFilePanel(B_SAVE_PANEL);
 		fSavePanel-&gt;SetTarget(this);
@@ -491,7 +491,7 @@
 	if (fRecordNode) {
 		fRecordNode-&gt;Release();
 	}
-	
+
 	delete fPlayer;
 	if (!fInputField) {
 		delete popup;
@@ -565,7 +565,7 @@
 			fBottomBox-&gt;Hide();
 			CalcSizes(Frame().Width(), MIN_HEIGHT-161);
 			ResizeTo(Frame().Width(), MIN_HEIGHT-161);
-			
+
 		}
 		break;
 	case UPDATE_TRACKSLIDER:
@@ -613,7 +613,7 @@
 
 void
 RecorderWindow::Record(BMessage * message)
-{	
+{
 	//	User pressed Record button
 	fRecording = true;
 	int seconds = atoi(fLengthControl-&gt;Text());
@@ -693,29 +693,29 @@
 		fPlayer-&gt;SetHasData(!fPlayer-&gt;HasData());
 		return;
 	}
-	
+
 	SetButtonState(btnPlaying);
 	fPlayButton-&gt;SetPlaying();
-	
+
 	if (!fPlayTrack) {
 		ErrorAlert(&quot;get the file to play&quot;, B_ERROR);
 		return;
 	}
-	
+
 	fPlayLimit = MIN(fPlayFrames, (off_t)(fTrackSlider-&gt;RightTime()*fPlayFormat.u.raw_audio.frame_rate/1000000LL));
 	fPlayTrack-&gt;SeekToTime(fTrackSlider-&gt;MainTime());
 	fPlayFrame = fPlayTrack-&gt;CurrentFrame();
-	
+
 	// Create our internal Node which plays sound, and register it.
 	fPlayer = new BSoundPlayer(fAudioMixerNode, &amp;fPlayFormat.u.raw_audio, &quot;Sound Player&quot;);
 	status_t err = fPlayer-&gt;InitCheck();
 	if (err &lt; B_OK) {
 		return;
 	}
-	
+
 	fVolumeSlider-&gt;SetSoundPlayer(fPlayer);
 	fPlayer-&gt;SetCallbacks(PlayFile, NotifyPlayFile, this);
-	
+
 	//	And get it going...
 	fPlayer-&gt;Start();
 	fPlayer-&gt;SetHasData(true);
@@ -741,14 +741,14 @@
 	if ((! pItem) || (pItem-&gt;Entry().InitCheck() != B_OK)) {
 		return;
 	}
-	
+
 	// Update the save panel and show it.
 	char filename[B_FILE_NAME_LENGTH];
 	pItem-&gt;Entry().GetName(filename);
 	BMessage saveMsg(B_SAVE_REQUESTED);
 	entry_ref ref;
 	pItem-&gt;Entry().GetRef(&amp;ref);
-	
+
 	saveMsg.AddPointer(&quot;sound list item&quot;, pItem);
 	fSavePanel-&gt;SetSaveText(filename);
 	fSavePanel-&gt;SetMessage(&amp;saveMsg);
@@ -765,7 +765,7 @@
 	entry_ref old_ref, new_dir_ref;
 	const char* new_name;
 	SoundListItem* pItem;
-		
+
 	if ((message-&gt;FindPointer(&quot;sound list item&quot;, (void**) &amp;pItem) == B_OK)
 		&amp;&amp; (message-&gt;FindRef(&quot;directory&quot;, &amp;new_dir_ref) == B_OK)
 		&amp;&amp; (message-&gt;FindString(&quot;name&quot;, &amp;new_name) == B_OK))
@@ -778,15 +778,15 @@
 		BDirectory newDir(&amp;new_dir_ref);
 		if (newDir.InitCheck() != B_OK)
 			return;
-			
-		BFile newFile;		
-		newDir.CreateFile(new_name, &amp;newFile); 
-		
+
+		BFile newFile;
+		newDir.CreateFile(new_name, &amp;newFile);
+
 		if (newFile.InitCheck() != B_OK)
 			return;
-				
+
 		status_t err = CopyFile(newFile, oldFile);
-		
+
 		if (err == B_OK) {
 			// clean up the sound list and item
 			if (pItem-&gt;IsTemp())
@@ -840,7 +840,7 @@
 	if (message-&gt;FindData(&quot;node&quot;, B_RAW_TYPE, (const void **)&amp;dni, &amp;size)) {
 		return;		//	bad input selection message
 	}
-	
+
 	media_node_id node_id;
 	status_t error = fRoster-&gt;GetInstancesFor(dni-&gt;addon, dni-&gt;flavor_id, &amp;node_id);
 	if (error != B_OK) {
@@ -862,7 +862,7 @@
 RecorderWindow::MakeRecordConnection(const media_node &amp; input)
 {
 	CONNECT((stderr, &quot;RecorderWindow::MakeRecordConnection()\n&quot;));
-	
+
 	//	Find an available output for the given input node.
 	int32 count = 0;
 	status_t err = fRoster-&gt;GetFreeOutputsFor(input, &amp;fAudioOutput, 1, &amp;count, B_MEDIA_RAW_AUDIO);
@@ -968,7 +968,7 @@
 	BreakRecordConnection();
 	fRecordNode-&gt;SetHooks(NULL,NULL,NULL);
 	if (fRecSize &gt; 0) {
-		
+
 		wave_struct header;
 		header.riff.riff_id = FOURCC('R','I','F','F');
 		header.riff.len = fRecSize + 36;
@@ -985,7 +985,7 @@
 		header.data_chunk.len = fRecSize;
 		fRecFile.Seek(0, SEEK_SET);
 		fRecFile.Write(&amp;header, sizeof(header));
-	
+
 		fRecFile.SetSize(fRecSize + sizeof(header));	//	We reserve space; make sure we cut off any excess at the end.
 		AddSoundItem(fRecEntry, true);
 	}
@@ -1001,7 +1001,7 @@
 	fRecSize = 0;
 	SetButtonState(btnPaused);
 	fRecordButton-&gt;SetStopped();
-	
+
 	return B_OK;
 }
 
@@ -1020,7 +1020,7 @@
 	fPlayButton-&gt;SetStopped();
 	fTrackSlider-&gt;ResetMainTime();
 	fScopeView-&gt;SetMainTime(*fTrackSlider-&gt;MainTime());
-	return B_OK;	
+	return B_OK;
 }
 
 
@@ -1050,7 +1050,7 @@
 extern &quot;C&quot; status_t DecodedFormat__11BMediaTrackP12media_format(BMediaTrack *self, media_format *inout_format);
 #endif
 
-void 
+void
 RecorderWindow::UpdatePlayFile()
 {
 	//	Get selection.
@@ -1059,7 +1059,7 @@
 	if (! pItem) {
 		return;
 	}
-	
+
 	if (fPlayTrack &amp;&amp; fPlayFile)
 		fPlayFile-&gt;ReleaseTrack(fPlayTrack);
 	if (fPlayFile)
@@ -1077,12 +1077,12 @@
 		delete fPlayFile;
 		return;
 	}
-		
+
 	for (int ix=0; ix&lt;fPlayFile-&gt;CountTracks(); ix++) {
 		BMediaTrack * track = fPlayFile-&gt;TrackAt(ix);
 		fPlayFormat.type = B_MEDIA_RAW_AUDIO;
 #ifdef __HAIKU__
-		if ((track-&gt;DecodedFormat(&amp;fPlayFormat) == B_OK) 
+		if ((track-&gt;DecodedFormat(&amp;fPlayFormat) == B_OK)
 #else
 		if ((DecodedFormat__11BMediaTrackP12media_format(track, &amp;fPlayFormat) == B_OK)
 #endif
@@ -1093,13 +1093,13 @@
 		if (track)
 			fPlayFile-&gt;ReleaseTrack(track);
 	}
-	
+
 	if (!fPlayTrack) {
 		ErrorAlert(&quot;get the file to play&quot;, err);
 		delete fPlayFile;
 		return;
 	}
-	
+
 	BString filename = &quot;File Name: &quot;;
 	filename &lt;&lt; ref.name;
 	fFilename-&gt;SetText(filename.String());
@@ -1124,22 +1124,22 @@
 	samplerate &lt;&lt; (int)fPlayFormat.u.raw_audio.frame_rate;
 	BString durationString = &quot;Duration: &quot;;
 	bigtime_t duration = fPlayTrack-&gt;Duration();
-	durationString &lt;&lt; (float)(duration / 1000000.0) &lt;&lt; &quot; seconds&quot;; 
-	
+	durationString &lt;&lt; (float)(duration / 1000000.0) &lt;&lt; &quot; seconds&quot;;
+
 	fFormat-&gt;SetText(format.String());
 	fCompression-&gt;SetText(compression.String());
 	fChannels-&gt;SetText(channels.String());
 	fSampleSize-&gt;SetText(samplesize.String());
 	fSampleRate-&gt;SetText(samplerate.String());
 	fDuration-&gt;SetText(durationString.String());
-	
+
 	fTrackSlider-&gt;SetTotalTime(duration, true);
 	fScopeView-&gt;SetMainTime(fTrackSlider-&gt;LeftTime());
 	fScopeView-&gt;SetTotalTime(duration);
 	fScopeView-&gt;SetRightTime(fTrackSlider-&gt;RightTime());
 	fScopeView-&gt;SetLeftTime(fTrackSlider-&gt;LeftTime());
 	fScopeView-&gt;RenderTrack(fPlayTrack, fPlayFormat);
-	
+
 	fPlayFrames = fPlayTrack-&gt;CountFrames();
 }
 
@@ -1204,7 +1204,7 @@
 	//	Callback called from the SoundConsumer when receiving buffers.
 	assert((format.format &amp; 0x02) &amp;&amp; format.channel_count);
 	RecorderWindow * window = (RecorderWindow *)cookie;
-	
+
 	if (window-&gt;fRecording) {
 		//	Write the data to file (we don't buffer or guard file access
 		//	or anything)
@@ -1234,12 +1234,12 @@
 
 void
 RecorderWindow::PlayFile(void * cookie, void * data, size_t size, const media_raw_audio_format &amp; format)
-{	
+{
 	//	Callback called from the SoundProducer when producing buffers.
 	RecorderWindow * window = (RecorderWindow *)cookie;
 	int32 frame_size = (window-&gt;fPlayFormat.u.raw_audio.format &amp; 0xf) *
 		window-&gt;fPlayFormat.u.raw_audio.channel_count;
-	
+
 	if ((window-&gt;fPlayFrame &lt; window-&gt;fPlayLimit) || window-&gt;fLooping) {
 		if (window-&gt;fPlayFrame &gt;= window-&gt;fPlayLimit) {
 			bigtime_t left = window-&gt;fTrackSlider-&gt;LeftTime();
@@ -1269,22 +1269,22 @@
 }
 
 
-void 
+void
 RecorderWindow::RefsReceived(BMessage *msg)
 {
 	entry_ref ref;
 	int32 i = 0;
-	
+
 	while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {
-		
+
 		BEntry entry(&amp;ref, true);
 		BPath path(&amp;entry);
 		BNode node(&amp;entry);
-		
+
 		if (node.IsFile()) {
 			AddSoundItem(entry, false);
 		} else if(node.IsDirectory()) {
-			
+
 		}
 	}
 }

Modified: haiku/trunk/src/apps/text_search/GrepWindow.cpp
===================================================================
--- haiku/trunk/src/apps/text_search/GrepWindow.cpp	2008-10-03 12:32:52 UTC (rev 27856)
+++ haiku/trunk/src/apps/text_search/GrepWindow.cpp	2008-10-03 12:35:57 UTC (rev 27857)
@@ -1,22 +1,22 @@
 /*
  * Copyright (c) 1998-2007 Matthijs Hollemans
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a 
- * copy of this software and associated documentation files (the &quot;Software&quot;), 
- * to deal in the Software without restriction, including without limitation 
- * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
- * and/or sell copies of the Software, and to permit persons to whom the 
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
  * Software is furnished to do so, subject to the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included in 
+ *
+ * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
 #include &quot;GrepWindow.h&quot;
@@ -141,7 +141,7 @@
 	_LoadPrefs();
 	_TileIfMultipleWindows();
 
-	Show(); 	
+	Show();
 }
 
 
@@ -404,7 +404,7 @@
 
 	if (!title.Length())
 		title = APP_NAME;
-		
+
 	SetTitle(title.String());
 }
 
@@ -419,34 +419,34 @@
 	fPreferencesMenu = new BMenu(_T(&quot;Preferences&quot;));
 	fHistoryMenu = new BMenu(_T(&quot;History&quot;));
 	fEncodingMenu = new BMenu(_T(&quot;Encoding&quot;));
-	
+
 	fNew = new BMenuItem(
 		_T(&quot;New Window&quot;), new BMessage(MSG_NEW_WINDOW), 'N');
-		
+
 	fOpen = new BMenuItem(
 		_T(&quot;Set Which Files to Search&quot;), new BMessage(MSG_OPEN_PANEL), 'F');
 
 	fClose = new BMenuItem(
 		_T(&quot;Close&quot;), new BMessage(B_QUIT_REQUESTED), 'W');
-	
+
 	fAbout = new BMenuItem(
 		_T(&quot;About&quot;), new BMessage(B_ABOUT_REQUESTED));
 
 	fQuit = new BMenuItem(
 		_T(&quot;Quit&quot;), new BMessage(MSG_QUIT_NOW), 'Q');
-	
+
 	fSearch = new BMenuItem(
 		_T(&quot;Search&quot;), new BMessage(MSG_START_CANCEL), 'S');
-		
+
 	fSelectAll = new BMenuItem(
 		_T(&quot;Select All&quot;), new BMessage(MSG_SELECT_ALL), 'A');
-		
+
 	fTrimSelection = new BMenuItem(
 		_T(&quot;Trim to Selection&quot;), new BMessage(MSG_TRIM_SELECTION), 'T');
-		
+
 	fOpenSelection = new BMenuItem(
 		_T(&quot;Open Selection&quot;), new BMessage(MSG_OPEN_SELECTION), 'O');
-		
+
 	fSelectInTracker = new BMenuItem(
 		_T(&quot;Show Files in Tracker&quot;), new BMessage(MSG_SELECT_IN_TRACKER), 'K');
 
@@ -477,12 +477,12 @@
 	fShowLinesMenuitem = new BMenuItem(
 		_T(&quot;Show Lines&quot;), new BMessage(MSG_MENU_SHOW_LINES), 'L');
 	fShowLinesMenuitem-&gt;SetMarked(true);
-	
+
 	fUTF8 = new BMenuItem(&quot;UTF8&quot;, new BMessage('utf8'));
 	fShiftJIS = new BMenuItem(&quot;ShiftJIS&quot;, new BMessage(B_SJIS_CONVERSION));
 	fEUC = new BMenuItem(&quot;EUC&quot;, new BMessage(B_EUC_CONVERSION));
 	fJIS = new BMenuItem(&quot;JIS&quot;, new BMessage(B_JIS_CONVERSION));
-	
+
 	fFileMenu-&gt;AddItem(fNew);
 	fFileMenu-&gt;AddSeparatorItem();
 	fFileMenu-&gt;AddItem(fOpen);
@@ -491,7 +491,7 @@
 	fFileMenu-&gt;AddItem(fAbout);
 	fFileMenu-&gt;AddSeparatorItem();
 	fFileMenu-&gt;AddItem(fQuit);
-	
+
 	fActionMenu-&gt;AddItem(fSearch);
 	fActionMenu-&gt;AddSeparatorItem();
 	fActionMenu-&gt;AddItem(fSelectAll);
@@ -500,7 +500,7 @@
 	fActionMenu-&gt;AddItem(fOpenSelection);
 	fActionMenu-&gt;AddItem(fSelectInTracker);
 	fActionMenu-&gt;AddItem(fCopyText);
-	
+
 	fPreferencesMenu-&gt;AddItem(fRecurseLinks);
 	fPreferencesMenu-&gt;AddItem(fRecurseDirs);
 	fPreferencesMenu-&gt;AddItem(fSkipDotDirs);
@@ -510,7 +510,7 @@
 	fPreferencesMenu-&gt;AddItem(fInvokePe);
 	fPreferencesMenu-&gt;AddSeparatorItem();
 	fPreferencesMenu-&gt;AddItem(fShowLinesMenuitem);
-	
+
  	fEncodingMenu-&gt;AddItem(fUTF8);
  	fEncodingMenu-&gt;AddItem(fShiftJIS);
  	fEncodingMenu-&gt;AddItem(fEUC);
@@ -526,10 +526,10 @@
 	fMenuBar-&gt;AddItem(fPreferencesMenu);
 	fMenuBar-&gt;AddItem(fHistoryMenu);
 	fMenuBar-&gt;AddItem(fEncodingMenu);
-	
+
 	AddChild(fMenuBar);
 	SetKeyMenuBar(fMenuBar);
-	
+
 	fSearch-&gt;SetEnabled(false);
 }
 
@@ -537,16 +537,16 @@
 void
 GrepWindow::_CreateViews()
 {
-	// The search pattern entry field does not send a message when 
-	// &lt;Enter&gt; is pressed, because the &quot;Search/Cancel&quot; button already 
+	// The search pattern entry field does not send a message when
+	// &lt;Enter&gt; is pressed, because the &quot;Search/Cancel&quot; button already
 	// does this and we don't want to send the same message twice.
 
 	fSearchText = new BTextControl(
 		BRect(0, 0, 0, 1), &quot;SearchText&quot;, NULL, NULL, NULL,
 		B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP,
-		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_NAVIGABLE); 
-	
-	fSearchText-&gt;TextView()-&gt;SetMaxBytes(1000); 
+		B_WILL_DRAW | B_FULL_UPDATE_ON_RESIZE | B_NAVIGABLE);
+
+	fSearchText-&gt;TextView()-&gt;SetMaxBytes(1000);
 	fSearchText-&gt;ResizeToPreferred();
 		// because it doesn't have a label
 
@@ -555,23 +555,23 @@
 	fButton = new BButton(
 		BRect(0, 1, 80, 1), &quot;Button&quot;, _T(&quot;Search&quot;),
 		new BMessage(MSG_START_CANCEL), B_FOLLOW_RIGHT);
-	
+
 	fButton-&gt;MakeDefault(true);
 	fButton-&gt;ResizeToPreferred();
 	fButton-&gt;SetEnabled(false);
-	
+
 	fShowLinesCheckbox = new BCheckBox(
 		BRect(0, 0, 1, 1), &quot;ShowLines&quot;, _T(&quot;Show Lines&quot;),
 		new BMessage(MSG_CHECKBOX_SHOW_LINES), B_FOLLOW_LEFT);
-	
+
 	fShowLinesCheckbox-&gt;SetValue(B_CONTROL_ON);
 	fShowLinesCheckbox-&gt;ResizeToPreferred();
-	
-	fSearchResults = new GrepListView(); 
 
+	fSearchResults = new GrepListView();
+
 	fSearchResults-&gt;SetInvocationMessage(new BMessage(MSG_INVOKE_ITEM));
 	fSearchResults-&gt;ResizeToPreferred();
-}	
+}
 
 
 void
@@ -581,13 +581,13 @@
 	fMenuBar-&gt;GetPreferredSize(&amp;menubarWidth, &amp;menubarHeight);
 
 	BBox *background = new BBox(
-		BRect(0, menubarHeight + 1, 2, menubarHeight + 2), B_EMPTY_STRING, 
-		B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP, 
-		B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE_JUMP, 
-		B_PLAIN_BORDER); 
+		BRect(0, menubarHeight + 1, 2, menubarHeight + 2), B_EMPTY_STRING,
+		B_FOLLOW_LEFT_RIGHT | B_FOLLOW_TOP,
+		B_WILL_DRAW | B_FRAME_EVENTS | B_NAVIGABLE_JUMP,
+		B_PLAIN_BORDER);
 
 	BScrollView *scroller = new BScrollView(
-		&quot;ScrollSearchResults&quot;, fSearchResults, B_FOLLOW_ALL_SIDES, 
+		&quot;ScrollSearchResults&quot;, fSearchResults, B_FOLLOW_ALL_SIDES,
 		B_FULL_UPDATE_ON_RESIZE, true, true, B_NO_BORDER);
 
 	scroller-&gt;ResizeToPreferred();
@@ -601,7 +601,7 @@
 	float backgroundHeight = 8 + fSearchText-&gt;Frame().Height()
 		+ 8 + fButton-&gt;Frame().Height() + 8;
 
-	ResizeTo(width, height);  
+	ResizeTo(width, height);
 
 	AddChild(background);
 	background-&gt;ResizeTo(width,	backgroundHeight);
@@ -641,15 +641,15 @@
 	if (be_app-&gt;Lock()) {
 		int32 windowCount = be_app-&gt;CountWindows();
 		be_app-&gt;Unlock();
-		
+
 		if (windowCount &gt; 1)
-			MoveBy(20,20); 
+			MoveBy(20,20);
 	}
-	
+
 	BScreen screen(this);
 	BRect screenFrame = screen.Frame();
 	BRect windowFrame = Frame();
-	
+
 	if (windowFrame.left &gt; screenFrame.right
 		|| windowFrame.top &gt; screenFrame.bottom
 		|| windowFrame.right &lt; screenFrame.left
@@ -788,16 +788,16 @@
 		fPreferencesMenu-&gt;SetEnabled(false);
 		fHistoryMenu-&gt;SetEnabled(false);
 		fEncodingMenu-&gt;SetEnabled(false);
-		
+
 		fSearchText-&gt;SetEnabled(false);
 
 		fButton-&gt;MakeFocus(true);
 		fButton-&gt;SetLabel(_T(&quot;Cancel&quot;));
 		fSearch-&gt;SetEnabled(false);
 
-		// We need to remember the search pattern, because during 
-		// the grepping, the text control's text will be replaced 
-		// by the name of the file that's currently being grepped. 
+		// We need to remember the search pattern, because during
+		// the grepping, the text control's text will be replaced
+		// by the name of the file that's currently being grepped.
 		// When the grepping finishes, we need to restore the old
 		// search pattern.
 
@@ -1102,7 +1102,7 @@
 	_ModelChanged();
 }
 
-		
+
 void
 GrepWindow::_OnSkipDotDirs()
 {
@@ -1120,7 +1120,7 @@
 	_ModelChanged();
 }
 
-	
+
 void
 GrepWindow::_OnCaseSensitive()
 {
@@ -1154,30 +1154,30 @@
 	// toggle checkbox and menuitem
 	fModel-&gt;fShowContents = !fModel-&gt;fShowContents;
 	fShowLinesMenuitem-&gt;SetMarked(!fShowLinesMenuitem-&gt;IsMarked());
-	
+
 	// Selection in BOutlineListView in multiple selection mode
 	// gets weird when collapsing. I've tried all sorts of things.
 	// It seems impossible to make it behave just right.
-	
+
 	// Going from collapsed to expande mode, the superitems
-	// keep their selection, the subitems don't (yet) have 
+	// keep their selection, the subitems don't (yet) have
 	// a selection. This works as expected, AFAIK.
-	
+
 	// Going from expanded to collapsed mode, I would like
 	// for a selected subitem (line) to select its superitem,
-	// (its file) and the subitem be unselected. 
-	
+	// (its file) and the subitem be unselected.
+
 	// I've successfully tried code patches that apply the
 	// selection pattern that I want, but with weird effects
-	// on subsequent manual selection. 
+	// on subsequent manual selection.
 	// Lines stay selected while the user tries to select
-	// some other line. It just gets weird. 
-	
-	// It's as though listItem-&gt;Select() and Deselect() 
+	// some other line. It just gets weird.
+
+	// It's as though listItem-&gt;Select() and Deselect()
 	// put the items in some semi-selected state.
 	// Or maybe I've got it all wrong.
-	
-	// So, here's the plain basic collapse/expand. 
+
+	// So, here's the plain basic collapse/expand.
 	// I think it's the least bad of what's possible on BeOS R5,
 	// but perhaps someone comes along with a patch of magic.
 
@@ -1214,7 +1214,7 @@
 GrepWindow::_OnInvokeItem()
 {
 	for (int32 selectionIndex = 0; ; selectionIndex++) {
-		int32 itemIndex = fSearchResults-&gt;CurrentSelection(selectionIndex); 
+		int32 itemIndex = fSearchResults-&gt;CurrentSelection(selectionIndex);
 		BListItem* item = fSearchResults-&gt;ItemAt(itemIndex);
 		if (item == NULL)
 			break;
@@ -1298,7 +1298,7 @@
 			fSearchResults-&gt;ItemAt(index));
 		if (item == NULL)
 			break;
-		
+
 		if (!item-&gt;IsSelected() || item-&gt;OutlineLevel() != 0)
 			continue;
 
@@ -1327,7 +1327,7 @@
 GrepWindow::_OnCopyText()
 {
 	bool onlyCopySelection = true;
-	
+
 	if (fSearchResults-&gt;CurrentSelection() &lt; 0)
 		onlyCopySelection = false;
 
@@ -1352,11 +1352,11 @@
 
 	if (be_clipboard-&gt;Lock()) {
 		be_clipboard-&gt;Clear();
-		
+
 		clip = be_clipboard-&gt;Data();
 
 		clip-&gt;AddData(&quot;text/plain&quot;, B_MIME_TYPE, buffer.String(),
-			buffer.Length());			
+			buffer.Length());
 
 		status = be_clipboard-&gt;Commit();
 
@@ -1408,7 +1408,7 @@
 			continue;
 
 		message.AddRef(&quot;refs&quot;, &amp;file_ref);
-		
+
 		// add parent folder to list of folders to open
 		folderPath.SetTo(filePath.String());
 		if (folderPath.GetParent(&amp;folderPath) == B_OK) {
@@ -1434,7 +1434,7 @@
 			snooze(aShortWhile);
 			_OpenFoldersInTracker(&amp;folderList);
 		}
-	}	
+	}
 
 	if (!_AreAllFoldersOpenInTracker(&amp;folderList)) {
 		BAlert* alert = new BAlert(NULL,
@@ -1448,7 +1448,7 @@
 
 	_SelectFilesInTracker(&amp;folderList, &amp;message);
 
-out:	
+out:
 	// delete folderList contents
 	int32 folderCount = folderList.CountItems();

[... truncated: 645 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="012345.html">[Haiku-commits] r27856 - haiku/trunk/src/apps/showimage
</A></li>
	<LI>Next message: <A HREF="012347.html">[Haiku-commits] r27858 - in haiku/trunk/src: apps/soundrecorder	apps/text_search kits/tracker
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#12346">[ date ]</a>
              <a href="thread.html#12346">[ thread ]</a>
              <a href="subject.html#12346">[ subject ]</a>
              <a href="author.html#12346">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
