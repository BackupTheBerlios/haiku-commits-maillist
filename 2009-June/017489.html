<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r31250 - in haiku/trunk: headers/posix	src/add-ons/accelerants/intel_extreme	src/add-ons/print/drivers/pdf/source	src/apps/cortex/addons/Flanger src/apps/fontdemo	src/apps/icon-o-matic/generic/support	src/apps/icon-o-matic/transformable src/libs/icon/shape	src/libs/icon/transformable src/preferences/screensaver	src/preferences/time src/servers/app src/servers/app/drawing/Painter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31250%20-%20in%20haiku/trunk%3A%20headers/posix%0A%09src/add-ons/accelerants/intel_extreme%0A%09src/add-ons/print/drivers/pdf/source%0A%09src/apps/cortex/addons/Flanger%20src/apps/fontdemo%0A%09src/apps/icon-o-matic/generic/support%0A%09src/apps/icon-o-matic/transformable%20src/libs/icon/shape%0A%09src/libs/icon/transformable%20src/preferences/screensaver%0A%09src/preferences/time%20src/servers/app%20src/servers/app/drawing/Painter&In-Reply-To=%3C200906261158.n5QBwloR029862%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017488.html">
   <LINK REL="Next"  HREF="017490.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r31250 - in haiku/trunk: headers/posix	src/add-ons/accelerants/intel_extreme	src/add-ons/print/drivers/pdf/source	src/apps/cortex/addons/Flanger src/apps/fontdemo	src/apps/icon-o-matic/generic/support	src/apps/icon-o-matic/transformable src/libs/icon/shape	src/libs/icon/transformable src/preferences/screensaver	src/preferences/time src/servers/app src/servers/app/drawing/Painter</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r31250%20-%20in%20haiku/trunk%3A%20headers/posix%0A%09src/add-ons/accelerants/intel_extreme%0A%09src/add-ons/print/drivers/pdf/source%0A%09src/apps/cortex/addons/Flanger%20src/apps/fontdemo%0A%09src/apps/icon-o-matic/generic/support%0A%09src/apps/icon-o-matic/transformable%20src/libs/icon/shape%0A%09src/libs/icon/transformable%20src/preferences/screensaver%0A%09src/preferences/time%20src/servers/app%20src/servers/app/drawing/Painter&In-Reply-To=%3C200906261158.n5QBwloR029862%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r31250 - in haiku/trunk: headers/posix	src/add-ons/accelerants/intel_extreme	src/add-ons/print/drivers/pdf/source	src/apps/cortex/addons/Flanger src/apps/fontdemo	src/apps/icon-o-matic/generic/support	src/apps/icon-o-matic/transformable src/libs/icon/shape	src/libs/icon/transformable src/preferences/screensaver	src/preferences/time src/servers/app src/servers/app/drawing/Painter">axeld at mail.berlios.de
       </A><BR>
    <I>Fri Jun 26 13:58:47 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="017488.html">[Haiku-commits] r31249 - haiku/trunk/src/apps/drivesetup
</A></li>
        <LI>Next message: <A HREF="017490.html">[Haiku-commits] r31251 - in haiku/trunk/src/apps/debugger: arch	debug_info
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17489">[ date ]</a>
              <a href="thread.html#17489">[ thread ]</a>
              <a href="subject.html#17489">[ subject ]</a>
              <a href="author.html#17489">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2009-06-26 13:58:43 +0200 (Fri, 26 Jun 2009)
New Revision: 31250
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=31250&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=31250&amp;view=rev</A>

Modified:
   haiku/trunk/headers/posix/math.h
   haiku/trunk/src/add-ons/accelerants/intel_extreme/overlay.cpp
   haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFText.cpp
   haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFWriter.cpp
   haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFWriter.h
   haiku/trunk/src/apps/cortex/addons/Flanger/FlangerNode.cpp
   haiku/trunk/src/apps/fontdemo/FontDemoView.cpp
   haiku/trunk/src/apps/icon-o-matic/generic/support/support.cpp
   haiku/trunk/src/apps/icon-o-matic/transformable/CanvasTransformBox.cpp
   haiku/trunk/src/apps/icon-o-matic/transformable/ChannelTransform.cpp
   haiku/trunk/src/apps/icon-o-matic/transformable/TransformBox.cpp
   haiku/trunk/src/apps/icon-o-matic/transformable/TransformBoxStates.cpp
   haiku/trunk/src/apps/icon-o-matic/transformable/TransformGradientBox.cpp
   haiku/trunk/src/libs/icon/shape/VectorPath.cpp
   haiku/trunk/src/libs/icon/transformable/Transformable.cpp
   haiku/trunk/src/preferences/screensaver/ScreenCornerSelector.cpp
   haiku/trunk/src/preferences/time/AnalogClock.cpp
   haiku/trunk/src/servers/app/ServerFont.cpp
   haiku/trunk/src/servers/app/drawing/Painter/AGGTextRenderer.cpp
   haiku/trunk/src/servers/app/drawing/Painter/Painter.cpp
Log:
* Removed PI, and PI2 from math.h.
* Replaced all occurences with the standard macros M_PI, and M_PI_2.
* Some coding style cleanup on the touched files, no other changes besides
  adding a missing check for a failed memory allocation.


Modified: haiku/trunk/headers/posix/math.h
===================================================================
--- haiku/trunk/headers/posix/math.h	2009-06-26 11:11:57 UTC (rev 31249)
+++ haiku/trunk/headers/posix/math.h	2009-06-26 11:58:43 UTC (rev 31250)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2001-2006, Haiku.
+ * Copyright 2001-2009, Haiku.
  * Distributed under the terms of the MIT License.
  */
 #ifndef _MATH_H_
@@ -20,9 +20,6 @@
 #define M_SQRT2			1.41421356237309504880	/* sqrt(2) */
 #define M_SQRT1_2		0.70710678118654752440	/* 1/sqrt(2) */
 
-#define PI				M_PI
-#define PI2				M_PI_2
-
 /* platform independent IEEE floating point special values */
 #define	__HUGE_VAL_v	0x7ff0000000000000LL
 #define __huge_val_t	union { unsigned char __c[8]; long long __ll; double __d; }
@@ -34,7 +31,7 @@
 #define __huge_valf_t	union { unsigned char __c[4]; long __l; float __f; }
 #define HUGE_VALF		(((__huge_valf_t) { __l: __HUGE_VALF_v }).__f)
 
-/* ToDo: define HUGE_VALL for long doubles */
+/* TODO: define HUGE_VALL for long doubles */
 
 #define __NAN_VALF_v	0x7fc00000L
 #define NAN				(((__huge_valf_t) { __l: __NAN_VALF_v }).__f)
@@ -79,149 +76,149 @@
 #endif
 
 /* float math functions */
-extern float	acosf(float x);
-extern float	acoshf(float x);
-extern float	asinf(float x);
-extern float	asinhf(float x);
-extern float	atan2f(float y, float x);
-extern float	atanf(float x);
-extern float	atanhf(float x);
-extern float	cbrtf(float x);
-extern float	ceilf(float x);
-extern float	cosf(float x);
-extern float	coshf(float x);
-extern float	expf(float x);
-extern float	expm1f(float x);
-extern float	fabsf(float x);
-extern float	floorf(float x);
-extern float	fmodf(float x, float y);
-extern float	frexpf(float x, int *_exponent);
-extern float	gammaf(float x);
-extern float	hypotf(float x, float y);
-extern float	ldexpf(float x, int exponent);
-extern float	lgammaf(float x);
-extern long long llrintf(float x);
-extern float	log10f(float x);
-extern float	log1pf(float x);
-extern float	logbf(float x);
-extern float	logf(float x);
-extern long	lrintf(float x);
-extern long	lroundf(float x);
-extern float	modff(float x, float *y);
-extern float	nearbyintf(float x);
-extern float	powf(float x, float y);
-extern float	remquof(float x, float y, int *quo);
-extern float	roundf(float x);
-extern float	sinf(float x);
-extern float	sinhf(float x);
-extern float	sqrtf(float x);
-extern float	tanf(float x);
-extern float	tanhf(float x);
+extern float		acosf(float x);
+extern float		acoshf(float x);
+extern float		asinf(float x);
+extern float		asinhf(float x);
+extern float		atan2f(float y, float x);
+extern float		atanf(float x);
+extern float		atanhf(float x);
+extern float		cbrtf(float x);
+extern float		ceilf(float x);
+extern float		cosf(float x);
+extern float		coshf(float x);
+extern float		expf(float x);
+extern float		expm1f(float x);
+extern float		fabsf(float x);
+extern float		floorf(float x);
+extern float		fmodf(float x, float y);
+extern float		frexpf(float x, int *_exponent);
+extern float		gammaf(float x);
+extern float		hypotf(float x, float y);
+extern float		ldexpf(float x, int exponent);
+extern float		lgammaf(float x);
+extern long long	llrintf(float x);
+extern float		log10f(float x);
+extern float		log1pf(float x);
+extern float		logbf(float x);
+extern float		logf(float x);
+extern long			lrintf(float x);
+extern long			lroundf(float x);
+extern float		modff(float x, float *y);
+extern float		nearbyintf(float x);
+extern float		powf(float x, float y);
+extern float		remquof(float x, float y, int *quo);
+extern float		roundf(float x);
+extern float		sinf(float x);
+extern float		sinhf(float x);
+extern float		sqrtf(float x);
+extern float		tanf(float x);
+extern float		tanhf(float x);
 
 /* double math functions */
-extern double	acos(double x);
-extern double	acosh(double x);
-extern double	asin(double x);
-extern double	asinh(double x);
-extern double	atan(double x);
-extern double	atan2(double x, double y);
-extern double	atanh(double x);
-extern double	ceil(double x);
-extern double	cos(double x);
-extern double	cosh(double x);
-extern double	exp(double x);
-extern double	fabs(double x);
-extern double	floor(double x);
-extern double	fmod(double x, double y);
-extern double	frexp(double x, int *_exponent);
-extern double	gamma(double x);
-extern double	ldexp(double x, int exponent);
-extern double	lgamma(double x);
-extern long long llrint(double x);
-extern double	log(double x);
-extern double	log10(double x);
-extern long	lrint(double x);
-extern long	lround(double x);
-extern double	modf(double x, double *y);
-extern double	nearbyint(double x);
-extern double	pow(double x, double y);
-extern double	remquo(double x, double y, int *quo);
-extern double	round(double x);
-extern double	sin(double x);
-extern double	sinh(double x);
-extern double	sqrt(double x);
-extern double	tan(double x);
-extern double	tanh(double x);
-extern double	trunc(double x);
+extern double		acos(double x);
+extern double		acosh(double x);
+extern double		asin(double x);
+extern double		asinh(double x);
+extern double		atan(double x);
+extern double		atan2(double x, double y);
+extern double		atanh(double x);
+extern double		ceil(double x);
+extern double		cos(double x);
+extern double		cosh(double x);
+extern double		exp(double x);
+extern double		fabs(double x);
+extern double		floor(double x);
+extern double		fmod(double x, double y);
+extern double		frexp(double x, int *_exponent);
+extern double		gamma(double x);
+extern double		ldexp(double x, int exponent);
+extern double		lgamma(double x);
+extern long long	llrint(double x);
+extern double		log(double x);
+extern double		log10(double x);
+extern long			lrint(double x);
+extern long			lround(double x);
+extern double		modf(double x, double *y);
+extern double		nearbyint(double x);
+extern double		pow(double x, double y);
+extern double		remquo(double x, double y, int *quo);
+extern double		round(double x);
+extern double		sin(double x);
+extern double		sinh(double x);
+extern double		sqrt(double x);
+extern double		tan(double x);
+extern double		tanh(double x);
+extern double		trunc(double x);
 
 /* long double math functions */
-extern long double 	acosl(long double x);
-extern long double 	acoshl(long double x);
-extern long double 	asinl(long double x);
-extern long double 	atanl(long double x);
-extern long double 	atanhl(long double x);
-extern long double 	atan2l(long double y, long double x);
+extern long double	acosl(long double x);
+extern long double	acoshl(long double x);
+extern long double	asinl(long double x);
+extern long double	atanl(long double x);
+extern long double	atanhl(long double x);
+extern long double	atan2l(long double y, long double x);
 extern long double	lgammal(long double x);
-extern long double 	nearbyintl(long double x);
+extern long double	nearbyintl(long double x);
 extern long long	llrintl(long double x);
-extern long		lrintl(long double x);
-extern long		lroundl(long double x);
-extern long double 	remquol(long double x, long double y, int *quo);
+extern long			lrintl(long double x);
+extern long			lroundl(long double x);
+extern long double	remquol(long double x, long double y, int *quo);
 extern long double	roundl(long double x);
 
 /* some BSD non-ANSI or POSIX math functions */
-extern double	cbrt(double x);
-extern double	erf(double x);
-extern double	erfc(double x);
-extern double	expm1(double x);
-extern double	gamma_r(double x, int *y);
-extern double	hypot(double x, double y);
-extern int		ilogb(double x);
-extern double	j0(double x);
-extern double	j1(double x);
-extern double	jn(int x, double y);
-extern double	lgamma_r(double x, int *y);
-extern double	log1p(double x);
-extern double	logb(double x);
-extern double	nextafter(double x, double y);
-extern double	nexttoward(double x, long double y);
-extern double	remainder(double x, double y);
-extern double	rint(double x);
-extern double	scalb (double x, double y);
-extern double	y0(double x);
-extern double	y1(double x);
-extern double	yn(int x, double y);
+extern double		cbrt(double x);
+extern double		erf(double x);
+extern double		erfc(double x);
+extern double		expm1(double x);
+extern double		gamma_r(double x, int *y);
+extern double		hypot(double x, double y);
+extern int			ilogb(double x);
+extern double		j0(double x);
+extern double		j1(double x);
+extern double		jn(int x, double y);
+extern double		lgamma_r(double x, int *y);
+extern double		log1p(double x);
+extern double		logb(double x);
+extern double		nextafter(double x, double y);
+extern double		nexttoward(double x, long double y);
+extern double		remainder(double x, double y);
+extern double		rint(double x);
+extern double		scalb (double x, double y);
+extern double		y0(double x);
+extern double		y1(double x);
+extern double		yn(int x, double y);
 
 /* other stuff as defined in BeOS */
-extern int		isinff(float value);
-extern int		finitef(float value);
-extern float	dremf(float x, float y);
-extern float	significandf(float x);
-extern float	copysignf(float x, float y);
-extern int		isnanf(float value);
-extern double	significand(double x);
-extern double	copysign(double x, double y);
-extern double 	scalbln(double x, long n);
-extern double	scalbn(double x, int y);
-extern double	drem(double x, double y);
-extern int		finite(double x);
-extern float	j0f(float x);
-extern float	j1f(float x);
-extern float	jnf(int x, float y);
-extern float	y0f(float x);
-extern float	y1f(float x);
-extern float	ynf(int x, float y);
-extern float	erff(float x);
-extern float	erfcf(float x);
-extern float	gammaf_r(float x, int *y);
-extern float	lgammaf_r(float x, int *y);
-extern float	rintf(float x);
-extern float	nextafterf(float x, float y);
-extern float	nexttowardf(float x, long double y);
-extern float	remainderf(float x, float y);
-extern float	scalbf(float x, float n);
-extern float	scalbnf(float x, int n);
-extern int	ilogbf(float x);
+extern int			isinff(float value);
+extern int			finitef(float value);
+extern float		dremf(float x, float y);
+extern float		significandf(float x);
+extern float		copysignf(float x, float y);
+extern int			isnanf(float value);
+extern double		significand(double x);
+extern double		copysign(double x, double y);
+extern double 		scalbln(double x, long n);
+extern double		scalbn(double x, int y);
+extern double		drem(double x, double y);
+extern int			finite(double x);
+extern float		j0f(float x);
+extern float		j1f(float x);
+extern float		jnf(int x, float y);
+extern float		y0f(float x);
+extern float		y1f(float x);
+extern float		ynf(int x, float y);
+extern float		erff(float x);
+extern float		erfcf(float x);
+extern float		gammaf_r(float x, int *y);
+extern float		lgammaf_r(float x, int *y);
+extern float		rintf(float x);
+extern float		nextafterf(float x, float y);
+extern float		nexttowardf(float x, long double y);
+extern float		remainderf(float x, float y);
+extern float		scalbf(float x, float n);
+extern float		scalbnf(float x, int n);
+extern int			ilogbf(float x);
 
 extern long double	nextafterl(long double x, long double y);
 extern long double	nexttowardl(long double x, long double y);
@@ -231,23 +228,23 @@
 extern long double	scalblnl(long double x, long n);
 
 /* prototypes for functions used in the macros below */
-extern int		__fpclassifyf(float value);
-extern int		__signbitf(float value);
-extern int		__finitef(float value);
-extern int		__isnanf(float value);
-extern int		__isinff(float value);
+extern int			__fpclassifyf(float value);
+extern int			__signbitf(float value);
+extern int			__finitef(float value);
+extern int			__isnanf(float value);
+extern int			__isinff(float value);
 
-extern int		__fpclassifyl(long double value);
-extern int		__signbitl(long double value);
-extern int		__finitel(long double value);
-extern int		__isnanl(long double value);
-extern int		__isinfl(long double value);
+extern int			__fpclassifyl(long double value);
+extern int			__signbitl(long double value);
+extern int			__finitel(long double value);
+extern int			__isnanl(long double value);
+extern int			__isinfl(long double value);
 
-extern int		__fpclassify(double value);
-extern int		__signbit(double value);
-extern int		__finite(double value);
-extern int		__isnan(double value);
-extern int		__isinf(double value);
+extern int			__fpclassify(double value);
+extern int			__signbit(double value);
+extern int			__finite(double value);
+extern int			__isnan(double value);
+extern int			__isinf(double value);
 
 /* returns number of classification appropriate for 'value' */
 #define fpclassify(value) \

Modified: haiku/trunk/src/add-ons/accelerants/intel_extreme/overlay.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/intel_extreme/overlay.cpp	2009-06-26 11:11:57 UTC (rev 31249)
+++ haiku/trunk/src/add-ons/accelerants/intel_extreme/overlay.cpp	2009-06-26 11:58:43 UTC (rev 31250)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006-2008, Haiku, Inc. All Rights Reserved.
+ * Copyright 2006-2009, Haiku, Inc. All Rights Reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
@@ -109,14 +109,15 @@
 	int32 num = taps * 16;
 	for (int32 i = 0; i &lt; num * 2; i++) {
 		double sinc;
-		double value = (1.0 / filterCutOff) * taps * PI * (i - num) / (2 * num);
+		double value = (1.0 / filterCutOff) * taps * M_PI * (i - num)
+			/ (2 * num);
 		if (value == 0.0)
 			sinc = 1.0;
 		else
 			sinc = sin(value) / value;
 
 		// Hamming window
-		double window = (0.5 - 0.5 * cos(i * PI / num));
+		double window = (0.5 - 0.5 * cos(i * M_PI / num));
 		rawCoefficients[i] = sinc * window;
 	}
 
@@ -346,10 +347,10 @@
 			bytesPerPixel = 2;
 			break;
 		case B_RGB16:
-			bytesPerPixel = 2; 
+			bytesPerPixel = 2;
 			break;
 		case B_RGB32:
-			bytesPerPixel = 4; 
+			bytesPerPixel = 4;
 			break;
 		case B_YCbCr422:
 			bytesPerPixel = 2;

Modified: haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFText.cpp
===================================================================
--- haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFText.cpp	2009-06-26 11:11:57 UTC (rev 31249)
+++ haiku/trunk/src/add-ons/print/drivers/pdf/source/PDFText.cpp	2009-06-26 11:58:43 UTC (rev 31250)
@@ -1,36 +1,15 @@
 /*
+ * Copyright 2001-2009, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Philippe Houdoin
+ *		Simon Gauvin
+ *		Michael Pfeiffer
+ */
 
-PDF Writer printer driver.
-
-Copyright (c) 2001, 2002 OpenBeOS. 
-
-Authors: 
-	Philippe Houdoin
-	Simon Gauvin	
-	Michael Pfeiffer
-	
-Permission is hereby granted, free of charge, to any person obtaining a copy of
-this software and associated documentation files (the &quot;Software&quot;), to deal in
-the Software without restriction, including without limitation the rights to
-use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-of the Software, and to permit persons to whom the Software is furnished to do
-so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-THE SOFTWARE.
-
-*/
-
 #include &lt;stdio.h&gt;
-#include &lt;string.h&gt;	
+#include &lt;string.h&gt;
 #include &lt;math.h&gt;
 
 #include &lt;Debug.h&gt;
@@ -47,28 +26,26 @@
 #include &quot;Report.h&quot;
 #include &quot;pdflib.h&quot;
 
-typedef struct
-{
+
+typedef struct {
 	uint16 from;
 	uint16 to;
 	int16  length;
 	uint16 *unicodes;
 } unicode_to_encoding;
 
-typedef struct
-{
+typedef struct {
 	uint16 unicode;
 	uint16 cid;
 } unicode_to_cid;
 
-typedef struct
-{
+typedef struct {
 	uint16         length;
-	unicode_to_cid *table;	
+	unicode_to_cid *table;
 } cid_table;
 
 #ifdef UNICODE5_FROM
-  #error check code!
+#	error check code!
 #endif
 
 #define ELEMS(v, e) sizeof(v) / sizeof(e)
@@ -81,8 +58,8 @@
 #include &quot;unicode3.h&quot;
 #include &quot;unicode4.h&quot;
 
-static unicode_to_encoding encodings[] = 
-{
+
+static unicode_to_encoding encodings[] = {
 	{UNICODE0_FROM, UNICODE0_TO, ELEMS(unicode0, uint16), unicode0},
 	{UNICODE1_FROM, UNICODE1_TO, ELEMS(unicode1, uint16), unicode1},
 	{UNICODE2_FROM, UNICODE2_TO, ELEMS(unicode2, uint16), unicode2},
@@ -97,18 +74,40 @@
 #include &quot;korean.h&quot;
 
 
-static cid_table cid_tables[] = 
-{
+static cid_table cid_tables[] = {
 	{ELEMS(japanese, unicode_to_cid), japanese},
 	{ELEMS(CNS1,     unicode_to_cid), CNS1},
 	{ELEMS(GB1,      unicode_to_cid), GB1},
 	{ELEMS(korean,   unicode_to_cid), korean}
 };
 
+static const char* encoding_names[] = {
+	&quot;macroman&quot;,
+	// TrueType
+	&quot;ttenc0&quot;,
+	&quot;ttenc1&quot;,
+	&quot;ttenc2&quot;,
+	&quot;ttenc3&quot;,
+	&quot;ttenc4&quot;,
+	// Type 1
+	&quot;t1enc0&quot;,
+	&quot;t1enc1&quot;,
+	&quot;t1enc2&quot;,
+	&quot;t1enc3&quot;,
+	&quot;t1enc4&quot;,
+	// CJK
+	&quot;UniJIS-UCS2-H&quot;,
+	&quot;UniCNS-UCS2-H&quot;,
+	&quot;UniGB-UCS2-H&quot;,
+	&quot;UniKS-UCS2-H&quot;
+};
 
-// --------------------------------------------------
-static bool 
-find_encoding(uint16 unicode, uint8 &amp;encoding, uint16 &amp;index) 
+
+//	#pragma mark -
+
+
+static bool
+find_encoding(uint16 unicode, uint8 &amp;encoding, uint16 &amp;index)
 {
 	for (unsigned int i = 0; i &lt; ELEMS(encodings, unicode_to_encoding); i++) {
 		if (encodings[i].from &lt;= unicode &amp;&amp; unicode &lt;= encodings[i].to) {
@@ -128,15 +127,15 @@
 				}
 			}
 		    return false;
-		} 
+		}
 	}
 	return false;
 }
 
 
-// --------------------------------------------------
-static bool 
-find_in_cid_tables(uint16 unicode, font_encoding &amp;encoding, uint16 &amp;index, font_encoding* order) 
+static bool
+find_in_cid_tables(uint16 unicode, font_encoding &amp;encoding, uint16 &amp;index,
+	font_encoding* order)
 {
 	for (unsigned int i = 0; i &lt; ELEMS(cid_tables, cid_table); i++) {
 		encoding = order[i];
@@ -161,9 +160,9 @@
 }
 
 
-// --------------------------------------------------
 void
-PDFWriter::MakeUserDefinedEncoding(uint16 unicode, uint8 &amp;enc, uint8 &amp;index) {
+PDFWriter::MakeUserDefinedEncoding(uint16 unicode, uint8 &amp;enc, uint8 &amp;index)
+{
 	if (fUserDefinedEncodings.Get(unicode, enc, index)) {
 		BString s(&quot;user&quot;);
 		s &lt;&lt; (int)enc;
@@ -171,24 +170,25 @@
 	}
 }
 
-// --------------------------------------------------
+
 void
-PDFWriter::RecordFont(const char* family, const char* style, float size) {
+PDFWriter::RecordFont(const char* family, const char* style, float size)
+{
 	const int32 n = fUsedFonts.CountItems();
 	for (int32 i = 0; i &lt; n; i ++) {
 		if (fUsedFonts.ItemAt(i)-&gt;Equals(family, style, size)) return;
 	}
-	
+
 	UsedFont* font;
 	font = new UsedFont(family, style, size);
 	fUsedFonts.AddItem(font);
-	
+
 	REPORT(kInfo, -1, &quot;Used font: \&quot;%s\&quot; \&quot;%s\&quot; %f&quot;, family, style, size);
 }
 
-// --------------------------------------------------
-void 
-PDFWriter::GetFontName(BFont *font, char *fontname) 
+
+void
+PDFWriter::GetFontName(BFont *font, char *fontname)
 {
 	font_family family;
 	font_style  style;
@@ -199,9 +199,10 @@
 	RecordFont(family, style, font-&gt;Size());
 }
 
-// --------------------------------------------------
-void 
-PDFWriter::GetFontName(BFont *font, char *fontname, bool &amp;embed, font_encoding encoding) 
+
+void
+PDFWriter::GetFontName(BFont *font, char *fontname, bool &amp;embed,
+	font_encoding encoding)
 {
 	GetFontName(font, fontname);
 
@@ -219,38 +220,15 @@
 }
 
 
-static const char* encoding_names[] = 
+int
+PDFWriter::FindFont(char* fontName, bool embed, font_encoding encoding)
 {
-	&quot;macroman&quot;,
-	// TrueType
-	&quot;ttenc0&quot;,
-	&quot;ttenc1&quot;,
-	&quot;ttenc2&quot;,
-	&quot;ttenc3&quot;,
-	&quot;ttenc4&quot;,
-	// Type 1
-	&quot;t1enc0&quot;,
-	&quot;t1enc1&quot;,
-	&quot;t1enc2&quot;,
-	&quot;t1enc3&quot;,
-	&quot;t1enc4&quot;,
-	// CJK
-	&quot;UniJIS-UCS2-H&quot;,
-	&quot;UniCNS-UCS2-H&quot;,
-	&quot;UniGB-UCS2-H&quot;,
-	&quot;UniKS-UCS2-H&quot;
-};
-
-
-// --------------------------------------------------
-int 
-PDFWriter::FindFont(char* fontName, bool embed, font_encoding encoding) 
-{
 	static Font* cache = NULL;
-	if (cache &amp;&amp; cache-&gt;encoding == encoding &amp;&amp; strcmp(cache-&gt;name.String(), fontName) == 0) 
+	if (cache &amp;&amp; cache-&gt;encoding == encoding
+		&amp;&amp; strcmp(cache-&gt;name.String(), fontName) == 0)
 		return cache-&gt;font;
 
-	REPORT(kDebug, fPage, &quot;FindFont %s&quot;, fontName); 
+	REPORT(kDebug, fPage, &quot;FindFont %s&quot;, fontName);
 	Font *f = NULL;
 	const int n = fFontCache.CountItems();
 	for (int i = 0; i &lt; n; i++) {
@@ -260,33 +238,34 @@
 			return f-&gt;font;
 		}
 	}
-	
+
 	if (embed) embed = EmbedFont(fontName);
 
 	BString s;
 	const char* encoding_name;
-	if (encoding &lt; user_defined_encoding_start) {	
+	if (encoding &lt; user_defined_encoding_start) {
 		encoding_name = encoding_names[encoding];
 	} else {
 		s = &quot;user&quot;;
 		s &lt;&lt; (int)(encoding - user_defined_encoding_start);
 		encoding_name = s.String();
 	}
-	REPORT(kDebug, fPage, &quot;Create new font, %sembed, encoding %s&quot;, embed ? &quot;&quot; : &quot;do not &quot;, encoding_name);
+	REPORT(kDebug, fPage, &quot;Create new font, %sembed, encoding %s&quot;,
+		embed ? &quot;&quot; : &quot;do not &quot;, encoding_name);
 	int font = PDF_findfont(fPdf, fontName, encoding_name, embed);
 	if (font != -1) {
 		REPORT(kDebug, fPage, &quot;font created&quot;);
 		cache = new Font(fontName, font, encoding);
 		fFontCache.AddItem(cache);
 	} else {
-		REPORT(kError, fPage, &quot;Could not create font '%s': %s&quot;, fontName, PDF_get_errmsg(fPdf));
+		REPORT(kError, fPage, &quot;Could not create font '%s': %s&quot;, fontName,
+			PDF_get_errmsg(fPdf));
 	}
 	return font;
 }
 
 
-// --------------------------------------------------
-void 
+void
 PDFWriter::ToUtf8(uint32 encoding, const char *string, BString &amp;utf8)
 {
 	int32 len = strlen(string);
@@ -296,19 +275,19 @@
 	int32 srcStart = 0;
 
 	do {
-		convert_to_utf8(encoding, &amp;string[srcStart], &amp;srcLen, buffer, &amp;destLen, &amp;state); 
+		convert_to_utf8(encoding, &amp;string[srcStart], &amp;srcLen, buffer, &amp;destLen,
+			&amp;state);
 		srcStart += srcLen;
 		len -= srcLen;
 		srcLen = len;
-		
+
 		utf8.Append(buffer, destLen);
 		destLen = 255;
 	} while (len &gt; 0);
 };
 
 
-// --------------------------------------------------
-void 
+void
 PDFWriter::ToUnicode(const char *string, BString &amp;unicode)
 {
 	int32 len = strlen(string);
@@ -318,87 +297,90 @@
 	int32 srcStart = 0;
 	int i = 0;
 
-	unicode = &quot;&quot;;	
+	unicode = &quot;&quot;;
 	if (len == 0) return;
 
 	do {
-		convert_from_utf8(B_UNICODE_CONVERSION, &amp;string[srcStart], &amp;srcLen, buffer, &amp;destLen, &amp;state); 
+		convert_from_utf8(B_UNICODE_CONVERSION, &amp;string[srcStart], &amp;srcLen,
+			buffer, &amp;destLen, &amp;state);
 		srcStart += srcLen;
 		len -= srcLen;
 		srcLen = len;
 
 		char *b = unicode.LockBuffer(i + destLen);
 		memcpy(&amp;b[i], buffer, destLen);
-		unicode.UnlockBuffer(i + destLen);		
+		unicode.UnlockBuffer(i + destLen);
 		i += destLen;
 		destLen = 255;
 	} while (len &gt; 0);
 }
 
 
-// --------------------------------------------------
-void 
+void
 PDFWriter::ToPDFUnicode(const char *string, BString &amp;unicode)
 {
 	// PDFlib requires BOM at begin and two 0 at end of string
 	char marker[3] = { 0xfe, 0xff, 0}; // byte order marker
 	BString s;
 	ToUnicode(string, s);
-	unicode &lt;&lt; marker; 
-	int32 len = s.Length()+2; 
-	char* buf = unicode.LockBuffer(len + 2); // reserve space for two additional '\0'
+	unicode &lt;&lt; marker;
+	int32 len = s.Length()+2;
+	char* buf = unicode.LockBuffer(len + 2);
+		// reserve space for two additional '\0'
 	memcpy(&amp;buf[2], s.String(), s.Length());
 	buf[len] = buf[len+1] = 0;
 	unicode.UnlockBuffer(len + 2);
 }
 
 
-// --------------------------------------------------
-uint16 
+uint16
 PDFWriter::CodePointSize(const char* s)
 {
 	uint16 i = 1;
-	for (s++; !BeginsChar(*s); s++) i++; 
+	for (s++; !BeginsChar(*s); s++) i++;
 	return i;
 }
 
 
-void PDFWriter::RecordDests(const char* s) {
+void
+PDFWriter::RecordDests(const char* s)
+{
 	::RecordDests record(fXRefDests, &amp;fTextLine, fPage);
 	fXRefs-&gt;Matches(s, &amp;record, true);
 }
 
 
-
-// --------------------------------------------------
 void
 PDFWriter::DrawChar(uint16 unicode, const char* utf8, int16 size)
 {
 	// try to convert from utf8 to MacRoman encoding schema...
 	int32 srcLen  = size;
 	int32 destLen = 1;
-	char dest[3] = &quot;\0\0&quot;; 
-	int32 state = 0; 
+	char dest[3] = &quot;\0\0&quot;;
+	int32 state = 0;
 	bool embed = true;
-	font_encoding encoding = macroman_encoding;	
-	char 	fontName[B_FONT_FAMILY_LENGTH+B_FONT_STYLE_LENGTH+1];
-	
-	if (convert_from_utf8(B_MAC_ROMAN_CONVERSION, utf8, &amp;srcLen, dest, &amp;destLen, &amp;state, 0) != B_OK || dest[0] == 0 ) {
+	font_encoding encoding = macroman_encoding;
+	char fontName[B_FONT_FAMILY_LENGTH+B_FONT_STYLE_LENGTH+1];
+
+	if (convert_from_utf8(B_MAC_ROMAN_CONVERSION, utf8, &amp;srcLen, dest, &amp;destLen,
+			&amp;state, 0) != B_OK || dest[0] == 0) {
 		// could not convert to MacRoman
-		uint8         enc;
-		uint16        index = 0;
 		font_encoding fenc;
+		uint16 index = 0;
+		uint8 enc;
 
 		GetFontName(&amp;fState-&gt;beFont, fontName);
 		embed = EmbedFont(fontName);
-		
+
 		REPORT(kDebug, -1, &quot;find_encoding unicode %d\n&quot;, (int)unicode);
 		if (find_encoding(unicode, enc, index)) {
 			// is code point in the Adobe Glyph List?
-			// Note if rendering the glyphs only would be desired, we could always use
-			// the second method below (MakeUserDefinedEncoding), but extracting text
-			// from the generated PDF would be almost impossible (OCR!)
-			REPORT(kDebug, -1, &quot;encoding for %x -&gt; %d %d&quot;, unicode, (int)enc, (int)index);
+			// Note if rendering the glyphs only would be desired, we could
+			// always use the second method below (MakeUserDefinedEncoding),
+			// but extracting text from the generated PDF would be almost
+			// impossible (OCR!)
+			REPORT(kDebug, -1, &quot;encoding for %x -&gt; %d %d&quot;, unicode, (int)enc,
+				(int)index);
 			// use one of the user pre-defined encodings
 			if (fState-&gt;beFont.FileFormat() == B_TRUETYPE_WINDOWS) {
 				encoding = font_encoding(enc + tt_encoding0);
@@ -415,8 +397,8 @@
 		} else if (find_in_cid_tables(unicode, fenc, index, fFontSearchOrder)) {
 			// font is not embedded use one of the CJK fonts for substitution
 			REPORT(kDebug, -1, &quot;cid table %d index = %d&quot;, (int)fenc, (int)index);
-			dest[0] = unicode / 256; 
-			dest[1] = unicode % 256; 
+			dest[0] = unicode / 256;
+			dest[1] = unicode % 256;
 			destLen = 2;
 			encoding = fenc;
 			embed = false;
@@ -425,33 +407,40 @@
 			REPORT(kDebug, -1, &quot;encoding for %x not found!&quot;, (int)unicode);
 			if (!found) {
 				found = true;
-				REPORT(kError, fPage, &quot;Could not find an encoding for character with unicode %d! Message is not repeated for other unicode values.&quot;, (int)unicode);
+				REPORT(kError, fPage, &quot;Could not find an encoding for character &quot;
+					&quot;with unicode %d! Message is not repeated for other unicode &quot;
+					&quot;values.&quot;, (int)unicode);
 			}
 			*dest = 0; // paint a box (is 0 a box in MacRoman) or
-			return; // simply skip character 
+			return; // simply skip character
 		}
 	} else {
-		REPORT(kDebug, -1, &quot;macroman srcLen=%d destLen=%d dest= %d %d!&quot;, srcLen, destLen, (int)dest[0], (int)dest[1]);
+		REPORT(kDebug, -1, &quot;macroman srcLen=%d destLen=%d dest= %d %d!&quot;, srcLen,
+			destLen, (int)dest[0], (int)dest[1]);
 	}
-	
-	// Note we have to build the user defined encoding before it is used in PDF_find_font!
+
+	// Note we have to build the user defined encoding before it is used in
+	// PDF_find_font!
 	if (!MakesPDF()) return;
-	
+
 	int		font;
 
 	GetFontName(&amp;fState-&gt;beFont, fontName, embed, encoding);
-	font = FindFont(fontName, embed, encoding);	
+	font = FindFont(fontName, embed, encoding);
 	if (font &lt; 0) {
-		REPORT(kWarning, fPage, &quot;**** PDF_findfont(%s) failed, back to default font&quot;, fontName);
+		REPORT(kWarning, fPage, &quot;**** PDF_findfont(%s) failed, back to default &quot;
+			&quot;font&quot;, fontName);
 		font = PDF_findfont(fPdf, &quot;Helvetica&quot;, &quot;macroman&quot;, 0);
 	}
 
 	fState-&gt;font = font;
 
 	uint16 face = fState-&gt;beFont.Face();
-	PDF_set_parameter(fPdf, &quot;underline&quot;, (face &amp; B_UNDERSCORE_FACE) != 0 ? &quot;true&quot; : &quot;false&quot;);
-	PDF_set_parameter(fPdf, &quot;strikeout&quot;, (face &amp; B_STRIKEOUT_FACE) != 0 ? &quot;true&quot; : &quot;false&quot;);
-	PDF_set_value(fPdf, &quot;textrendering&quot;, (face &amp; B_OUTLINED_FACE) != 0 ? 1 : 0); 
+	PDF_set_parameter(fPdf, &quot;underline&quot;, (face &amp; B_UNDERSCORE_FACE) != 0
+		? &quot;true&quot; : &quot;false&quot;);
+	PDF_set_parameter(fPdf, &quot;strikeout&quot;, (face &amp; B_STRIKEOUT_FACE) != 0
+		? &quot;true&quot; : &quot;false&quot;);
+	PDF_set_value(fPdf, &quot;textrendering&quot;, (face &amp; B_OUTLINED_FACE) != 0 ? 1 : 0);
 
 	PDF_setfont(fPdf, fState-&gt;font, scale(fState-&gt;beFont.Size()));
 
@@ -465,7 +454,7 @@
 		PDF_translate(fPdf, x, y);
 		PDF_rotate(fPdf, rotation);
 	    PDF_set_text_pos(fPdf, 0, 0);
-	} else 
+	} else
 	    PDF_set_text_pos(fPdf, x, y);
 
 	PDF_show2(fPdf, dest, destLen);
@@ -476,9 +465,9 @@
 }
 
 
-// --------------------------------------------------
 void
-PDFWriter::ClipChar(BFont* font, const char* unicode, const char* utf8, int16 size, float width)
+PDFWriter::ClipChar(BFont* font, const char* unicode, const char* utf8,
+	int16 size, float width)
 {
 	BShape glyph;
 	bool hasGlyph[1];
@@ -506,12 +495,12 @@
 		glyph.LineTo(BPoint(o.right, o.bottom));
 		glyph.LineTo(BPoint(o.left,  o.bottom));
 		glyph.Close();
-	
+
 		glyph.MoveTo(BPoint(i.left,  i.top));
 		glyph.LineTo(BPoint(i.left,  i.bottom));
 		glyph.LineTo(BPoint(i.right, i.bottom));
 		glyph.LineTo(BPoint(i.right, i.top));
-		glyph.Close();		
+		glyph.Close();
 	}
 
 	BPoint p(fState-&gt;penX, fState-&gt;penY);
@@ -523,12 +512,14 @@
 	PopInternalState();
 }
 
-// --------------------------------------------------
-void	
-PDFWriter::DrawString(char *string, float escapement_nospace, float escapement_space)
+
+void
+PDFWriter::DrawString(char *string, float escapementNoSpace,
+	float escapementSpace)
 {
-	REPORT(kDebug, fPage, &quot;DrawString string=\&quot;%s\&quot;, escapement_nospace=%f, escapement_space=%f, at %f, %f&quot;, \
-			string, escapement_nospace, escapement_space, fState-&gt;penX, fState-&gt;penY);
+	REPORT(kDebug, fPage, &quot;DrawString string=\&quot;%s\&quot;, escapementNoSpace=%f, &quot;
+		&quot;escapementSpace=%f, at %f, %f&quot;, string, escapementNoSpace,
+		escapementSpace, fState-&gt;penX, fState-&gt;penY);
 
 	if (IsDrawing()) {
 		// text color is always the high color and not the pattern!
@@ -541,14 +532,14 @@
 	} else {
 		ToUtf8(fState-&gt;beFont.Encoding()-1, string, utf8);
 	}
-	
+
 	// convert string in UTF8 to unicode UCS2
 	BString unicode;
-	ToUnicode(utf8.String(), unicode);	
+	ToUnicode(utf8.String(), unicode);
 	// need font object to calculate width of utf8 code point
 	BFont font = fState-&gt;beFont;
 	font.SetEncoding(B_UNICODE_UTF8);
-	// constants to calculate position of next character	
+	// constants to calculate position of next character
 	const double rotation = DEGREE2RAD(fState-&gt;beFont.Rotation());
 	const bool rotate = rotation != 0.0;
 	const double cos1 = rotate ? cos(rotation) : 1;
@@ -569,14 +560,14 @@
 		if (MakesPDF() &amp;&amp; IsClipping()) {
 			ClipChar(&amp;font, (char*)u, c, s, w);
 		} else {
-			DrawChar(u[0]*256+u[1], c, s);		
+			DrawChar(u[0]*256+u[1], c, s);
 		}
-				
+
 		// position of next character
 		if (*(unsigned char*)c &lt;= 0x20) { // should test if c is a white-space!
-			w += escapement_space;
+			w += escapementSpace;
 		} else {
-			w += escapement_nospace;
+			w += escapementNoSpace;
 		}
 
 		fState-&gt;penX += w * cos1;
@@ -588,36 +579,30 @@

[... truncated: 7742 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017488.html">[Haiku-commits] r31249 - haiku/trunk/src/apps/drivesetup
</A></li>
	<LI>Next message: <A HREF="017490.html">[Haiku-commits] r31251 - in haiku/trunk/src/apps/debugger: arch	debug_info
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17489">[ date ]</a>
              <a href="thread.html#17489">[ thread ]</a>
              <a href="subject.html#17489">[ subject ]</a>
              <a href="author.html#17489">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
