<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30962 - in haiku/trunk: build/jam	src/add-ons/accelerants src/add-ons/accelerants/ati	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/ati
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30962%20-%20in%20haiku/trunk%3A%20build/jam%0A%09src/add-ons/accelerants%20src/add-ons/accelerants/ati%0A%09src/add-ons/kernel/drivers/graphics%0A%09src/add-ons/kernel/drivers/graphics/ati&In-Reply-To=%3C200906050250.n552oWOq031486%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="017090.html">
   <LINK REL="Next"  HREF="017092.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30962 - in haiku/trunk: build/jam	src/add-ons/accelerants src/add-ons/accelerants/ati	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/ati</H1>
    <B>anevilyak at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30962%20-%20in%20haiku/trunk%3A%20build/jam%0A%09src/add-ons/accelerants%20src/add-ons/accelerants/ati%0A%09src/add-ons/kernel/drivers/graphics%0A%09src/add-ons/kernel/drivers/graphics/ati&In-Reply-To=%3C200906050250.n552oWOq031486%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30962 - in haiku/trunk: build/jam	src/add-ons/accelerants src/add-ons/accelerants/ati	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/ati">anevilyak at mail.berlios.de
       </A><BR>
    <I>Fri Jun  5 04:50:32 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="017090.html">[Haiku-commits] r30961 -	haiku/trunk/src/system/kernel/device_manager
</A></li>
        <LI>Next message: <A HREF="017092.html">[Haiku-commits] r30962 - in haiku/trunk: build/jam	src/add-ons/accelerants src/add-ons/accelerants/ati	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/ati
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17091">[ date ]</a>
              <a href="thread.html#17091">[ thread ]</a>
              <a href="subject.html#17091">[ subject ]</a>
              <a href="author.html#17091">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: anevilyak
Date: 2009-06-05 04:50:25 +0200 (Fri, 05 Jun 2009)
New Revision: 30962
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30962&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30962&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/accelerants/ati/
   haiku/trunk/src/add-ons/accelerants/ati/Jamfile
   haiku/trunk/src/add-ons/accelerants/ati/accelerant.cpp
   haiku/trunk/src/add-ons/accelerants/ati/accelerant.h
   haiku/trunk/src/add-ons/accelerants/ati/cursor.cpp
   haiku/trunk/src/add-ons/accelerants/ati/engine.cpp
   haiku/trunk/src/add-ons/accelerants/ati/hooks.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64.h
   haiku/trunk/src/add-ons/accelerants/ati/mach64_cursor.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64_dpms.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64_draw.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64_init.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64_mode.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mach64_util.cpp
   haiku/trunk/src/add-ons/accelerants/ati/mode.cpp
   haiku/trunk/src/add-ons/accelerants/ati/rage128.h
   haiku/trunk/src/add-ons/accelerants/ati/rage128_cursor.cpp
   haiku/trunk/src/add-ons/accelerants/ati/rage128_dpms.cpp
   haiku/trunk/src/add-ons/accelerants/ati/rage128_draw.cpp
   haiku/trunk/src/add-ons/accelerants/ati/rage128_init.cpp
   haiku/trunk/src/add-ons/accelerants/ati/rage128_mode.cpp
   haiku/trunk/src/add-ons/kernel/drivers/graphics/ati/
   haiku/trunk/src/add-ons/kernel/drivers/graphics/ati/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/graphics/ati/driver.cpp
Removed:
   haiku/trunk/src/add-ons/accelerants/atimach64/
   haiku/trunk/src/add-ons/kernel/drivers/graphics/atimach64/
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/src/add-ons/accelerants/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/graphics/Jamfile
Log:
Imported Gerald Zajac's ATI Mach64 / Rage driver and removed the old GPL-only mach64 driver that wasn't even part of the image anyways. Thanks!



Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/build/jam/HaikuImage	2009-06-05 02:50:25 UTC (rev 30962)
@@ -100,6 +100,7 @@
 	$(X86_ONLY)nvidia.accelerant $(X86_ONLY)matrox.accelerant
 	$(X86_ONLY)neomagic.accelerant $(X86_ONLY)intel_extreme.accelerant
 	$(X86_ONLY)s3.accelerant $(X86_ONLY)vesa.accelerant
+	$(X86_ONLY)ati.accelerant
 	#$(X86_ONLY)via.accelerant
 	#$(X86_ONLY)vmware.accelerant
 ;
@@ -142,6 +143,7 @@
 SYSTEM_ADD_ONS_DRIVERS_GRAPHICS = $(X86_ONLY)radeon $(X86_ONLY)nvidia
 	$(X86_ONLY)neomagic $(X86_ONLY)matrox $(X86_ONLY)intel_extreme
 	$(X86_ONLY)s3 $(X86_ONLY)vesa #$(X86_ONLY)via #$(X86_ONLY)vmware
+	$(X86_ONLY)ati
 ;
 SYSTEM_ADD_ONS_DRIVERS_MIDI = emuxki ;
 SYSTEM_ADD_ONS_DRIVERS_NET = $(X86_ONLY)3com $(X86_ONLY)broadcom440x

Modified: haiku/trunk/src/add-ons/accelerants/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/Jamfile	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/Jamfile	2009-06-05 02:50:25 UTC (rev 30962)
@@ -1,5 +1,6 @@
 SubDir HAIKU_TOP src add-ons accelerants ;
 
+SubInclude HAIKU_TOP src add-ons accelerants ati ;
 SubInclude HAIKU_TOP src add-ons accelerants common ;
 SubInclude HAIKU_TOP src add-ons accelerants et6x00 ;
 SubInclude HAIKU_TOP src add-ons accelerants intel_extreme ;
@@ -13,5 +14,3 @@
 SubInclude HAIKU_TOP src add-ons accelerants vesa ;
 SubInclude HAIKU_TOP src add-ons accelerants via ;
 SubInclude HAIKU_TOP src add-ons accelerants vmware ;
-
-SubIncludeGPL HAIKU_TOP src add-ons accelerants atimach64 ;

Added: haiku/trunk/src/add-ons/accelerants/ati/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/Jamfile	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/Jamfile	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,28 @@
+SubDir HAIKU_TOP src add-ons accelerants ati ;
+
+UsePrivateHeaders graphics ;
+UsePrivateHeaders [ FDirName graphics ati ] ;
+UsePrivateHeaders [ FDirName graphics common ] ;
+
+Addon ati.accelerant :
+	accelerant.cpp
+	cursor.cpp
+	engine.cpp
+	hooks.cpp
+	mode.cpp
+		
+	mach64_cursor.cpp
+	mach64_dpms.cpp
+	mach64_draw.cpp
+	mach64_init.cpp
+	mach64_mode.cpp
+	mach64_util.cpp
+	
+	rage128_cursor.cpp
+	rage128_dpms.cpp
+	rage128_draw.cpp
+	rage128_init.cpp
+	rage128_mode.cpp
+
+	: be libaccelerantscommon.a
+;

Added: haiku/trunk/src/add-ons/accelerants/ati/accelerant.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/accelerant.cpp	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/accelerant.cpp	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,222 @@
+/*
+	Copyright 2007-2009 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2007-2009
+*/
+
+#include &quot;accelerant.h&quot;
+
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+#include &lt;unistd.h&gt;
+
+
+
+AccelerantInfo gInfo;		// global data used by various source files of accelerant.
+
+
+
+static status_t
+InitCommon(int fileDesc)
+{
+	// Initialization function used by primary and cloned accelerants.
+
+	gInfo.deviceFileDesc = fileDesc;
+
+	// Get area ID of shared data from driver.
+
+	area_id sharedArea;
+	status_t result = ioctl(gInfo.deviceFileDesc, ATI_GET_SHARED_DATA,
+		&amp;sharedArea, sizeof(sharedArea));
+	if (result != B_OK)
+		return result;
+
+	gInfo.sharedInfoArea = clone_area(&quot;ATI shared info&quot;, (void**)&amp;(gInfo.sharedInfo),
+		B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, sharedArea);
+	if (gInfo.sharedInfoArea &lt; 0)
+		return gInfo.sharedInfoArea;	// sharedInfoArea has error code
+
+	gInfo.regsArea = clone_area(&quot;ATI regs area&quot;, (void**)&amp;(gInfo.regs),
+		B_ANY_ADDRESS, B_READ_AREA | B_WRITE_AREA, gInfo.sharedInfo-&gt;regsArea);
+	if (gInfo.regsArea &lt; 0) {
+		delete_area(gInfo.sharedInfoArea);
+		return gInfo.regsArea;		// regsArea has error code
+	}
+
+	// Set pointers to various device specific functions.
+
+	if (RAGE128_FAMILY(gInfo.sharedInfo-&gt;chipType))
+		Rage128_SetFunctionPointers();
+	else if (MACH64_FAMILY(gInfo.sharedInfo-&gt;chipType))
+		Mach64_SetFunctionPointers();
+	else
+		return B_ERROR;		// undefined chip type code
+
+	return B_OK;
+}
+
+
+static void
+UninitCommon(void)
+{
+	// This function is used by both primary and cloned accelerants.
+
+	delete_area(gInfo.regsArea);
+	gInfo.regs = 0;
+
+	delete_area(gInfo.sharedInfoArea);
+	gInfo.sharedInfo = 0;
+}
+
+
+status_t
+InitAccelerant(int fileDesc)
+{
+	// Initialize the accelerant.	fileDesc is the file handle of the device
+	// (in /dev/graphics) that has been opened by the app_server.
+
+	TRACE(&quot;Enter InitAccelerant()\n&quot;);
+
+	gInfo.bAccelerantIsClone = false;		// indicate this is primary accelerant
+
+	status_t result = InitCommon(fileDesc);
+	if (result == B_OK) {
+		SharedInfo&amp; si = *gInfo.sharedInfo;
+
+		TRACE(&quot;Vendor ID: 0x%X,  Device ID: 0x%X\n&quot;, si.vendorID, si.deviceID);
+
+		// Ensure that InitAccelerant is executed just once (copies should be clones)
+
+		if (si.bAccelerantInUse) {
+			result = B_NOT_ALLOWED;
+		} else {
+			result = gInfo.ChipInit();	// perform init related to current chip
+			if (result == B_OK) {
+				result = si.engineLock.Init(&quot;ATI engine lock&quot;);
+				if (result == B_OK) {
+					if (gInfo.ShowCursor != NULL)
+						gInfo.ShowCursor(false);
+
+					// ensure that this function won't be executed again
+					// (copies should be clones)
+					si.bAccelerantInUse = true;
+				}
+			}
+		}
+
+		if (result != B_OK)
+			UninitCommon();
+	}
+
+	TRACE(&quot;Leave InitAccelerant(), result: 0x%X\n&quot;, result);
+	return result;
+}
+
+
+ssize_t
+AccelerantCloneInfoSize(void)
+{
+	// Return the number of bytes required to hold the information required
+	// to clone the device.  The information is merely the name of the device;
+	// thus, return the size of the name buffer.
+
+	return B_OS_NAME_LENGTH;
+}
+
+
+void
+GetAccelerantCloneInfo(void* data)
+{
+	// Return the info required to clone the device.  Argument data points to
+	// a buffer which is the size returned by AccelerantCloneInfoSize().
+
+	ioctl(gInfo.deviceFileDesc, ATI_DEVICE_NAME, data, B_OS_NAME_LENGTH);
+}
+
+
+status_t
+CloneAccelerant(void* data)
+{
+	// Initialize a copy of the accelerant as a clone.  Argument data points to
+	// a copy of the data which was returned by GetAccelerantCloneInfo().
+
+	TRACE(&quot;Enter CloneAccelerant()\n&quot;);
+
+	char path[MAXPATHLEN] = &quot;/dev/&quot;;
+	strcat(path, (const char*)data);
+
+	gInfo.deviceFileDesc = open(path, B_READ_WRITE);	// open the device
+	if (gInfo.deviceFileDesc &lt; 0)
+		return errno;
+
+	gInfo.bAccelerantIsClone = true;
+
+	status_t result = InitCommon(gInfo.deviceFileDesc);
+	if (result != B_OK) {
+		close(gInfo.deviceFileDesc);
+		return result;
+	}
+
+	result = gInfo.modeListArea = clone_area(&quot;ATI cloned display_modes&quot;,
+		(void**) &amp;gInfo.modeList, B_ANY_ADDRESS, B_READ_AREA,
+		gInfo.sharedInfo-&gt;modeArea);
+	if (result &lt; 0) {
+		UninitCommon();
+		close(gInfo.deviceFileDesc);
+		return result;
+	}
+
+	TRACE(&quot;Leave CloneAccelerant()\n&quot;);
+	return B_OK;
+}
+
+
+void
+UninitAccelerant(void)
+{
+	delete_area(gInfo.modeListArea);
+	gInfo.modeList = NULL;
+
+	UninitCommon();
+
+	if (gInfo.bAccelerantIsClone)
+		close(gInfo.deviceFileDesc);
+}
+
+
+sem_id
+AccelerantRetraceSemaphore(void)
+{
+	// Return the semaphore id that will be used to signal that a vertical
+	// retrace occured.
+
+	return B_ERROR;
+}
+
+
+status_t
+GetAccelerantDeviceInfo(accelerant_device_info* adi)
+{
+	// Get info about the device.
+
+	SharedInfo&amp; si = *gInfo.sharedInfo;
+
+	adi-&gt;version = 1;
+	strcpy(adi-&gt;name, &quot;ATI chipset&quot;);
+	strcpy(adi-&gt;serial_no, &quot;unknown&quot;);
+	adi-&gt;memory = si.maxFrameBufferSize;
+	adi-&gt;dac_speed = 270;
+
+	// If laptop LCD display or flat panel display (ie, DVI interface), set chip
+	// set name to &quot;VESA&quot; so that Screen Preferences will not show a refresh rate
+	// since we will be using VESA code to set the video mode.
+
+	if (si.displayType == MT_VGA)
+		strcpy(adi-&gt;chipset, si.chipName);
+	else
+		strcpy(adi-&gt;chipset, &quot;VESA&quot;);
+
+	return B_OK;
+}

Added: haiku/trunk/src/add-ons/accelerants/ati/accelerant.h
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/accelerant.h	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/accelerant.h	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,208 @@
+/*
+	Copyright 2007-2009 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2007-2009
+*/
+
+#ifndef _ACCELERANT_H
+#define _ACCELERANT_H
+
+#include &quot;DriverInterface.h&quot;
+
+
+
+#undef TRACE
+
+#ifdef ENABLE_DEBUG_TRACE
+extern &quot;C&quot; void  _sPrintf(const char* format, ...);
+#	define TRACE(x...) _sPrintf(&quot;ati: &quot; x)
+#else
+#	define TRACE(x...) ;
+#endif
+
+
+// Global data used by various source files of the accelerant.
+
+struct AccelerantInfo {
+	int			deviceFileDesc;		// file descriptor of kernel driver
+
+	SharedInfo*	sharedInfo;			// address of info shared between accelerants &amp; driver
+	area_id		sharedInfoArea;		// shared info area ID
+
+	uint8*		regs;				// base address of MMIO register area
+	area_id		regsArea;			// MMIO register area ID
+
+	display_mode* modeList;			// list of standard display modes
+	area_id		modeListArea;		// mode list area ID
+
+	bool		bAccelerantIsClone;	// true if this is a cloned accelerant
+
+	// Pointers to various global accelerant functions.
+	//-------------------------------------------------
+
+	// Pointers to wait handlers.
+	void	(*WaitForFifo)(uint32);
+	void	(*WaitForIdle)();
+
+	// Pointers to DPMS functions.
+	uint32	(*DPMSCapabilities)(void);
+	uint32	(*GetDPMSMode)(void);
+	status_t (*SetDPMSMode)(uint32 dpms_flags);
+
+	// Pointers to cursor functions.
+	bool	(*LoadCursorImage)(int width, int height, uint8* and_mask, uint8* xor_mask);
+	void	(*SetCursorPosition)(int x, int y);
+	void	(*ShowCursor)(bool bShow);
+
+	// Pointers to 2D acceleration functions.
+	void	(*FillRectangle)(engine_token*, uint32 color, fill_rect_params*, uint32 count);
+	void	(*FillSpan)(engine_token*, uint32 color, uint16* list, uint32 count);
+	void	(*InvertRectangle)(engine_token*, fill_rect_params*, uint32 count);
+	void	(*ScreenToScreenBlit)(engine_token*, blit_params*, uint32 count);
+
+	// Pointers to other functions.
+	void	 (*AdjustFrame)(const DisplayModeEx&amp; mode);
+	status_t (*ChipInit)(void);
+	bool	 (*GetColorSpaceParams)(int colorSpace, uint8&amp; bpp, uint32&amp; maxPixelClk);
+	status_t (*SetDisplayMode)(const DisplayModeEx&amp; mode);
+	void	 (*SetIndexedColors)(uint count, uint8 first, uint8* color_data, uint32 flags);
+};
+
+extern AccelerantInfo gInfo;
+
+
+// Prototypes of the interface functions called by the app_server.  Note that
+// the functions that are unique to a particular chip family, will be prefixed
+// with the name of the family, and the functions that are applicable to all
+// chips will have no prefix.
+//================================================================
+
+#if defined(__cplusplus)
+extern &quot;C&quot; {
+#endif
+
+// General
+status_t InitAccelerant(int fd);
+ssize_t  AccelerantCloneInfoSize(void);
+void	 GetAccelerantCloneInfo(void* data);
+status_t CloneAccelerant(void* data);
+void	 UninitAccelerant(void);
+status_t GetAccelerantDeviceInfo(accelerant_device_info* adi);
+sem_id	 AccelerantRetraceSemaphore(void);
+
+// Mode Configuration
+uint32	 AccelerantModeCount(void);
+status_t GetModeList(display_mode* dm);
+status_t ProposeDisplayMode(display_mode* target, const display_mode* low, const display_mode* high);
+status_t SetDisplayMode(display_mode* mode_to_set);
+status_t GetDisplayMode(display_mode* current_mode);
+status_t GetFrameBufferConfig(frame_buffer_config* a_frame_buffer);
+status_t GetPixelClockLimits(display_mode* dm, uint32* low, uint32* high);
+status_t MoveDisplay(uint16 h_display_start, uint16 v_display_start);
+status_t GetTimingConstraints(display_timing_constraints* dtc);
+void	 Mach64_SetIndexedColors(uint count, uint8 first, uint8* color_data, uint32 flags);
+void	 Rage128_SetIndexedColors(uint count, uint8 first, uint8* color_data, uint32 flags);
+status_t GetPreferredDisplayMode(display_mode* preferredMode);
+status_t GetEdidInfo(void* info, size_t size, uint32* _version);
+
+// DPMS
+uint32   Mach64_DPMSCapabilities(void);
+uint32   Mach64_GetDPMSMode(void);
+status_t Mach64_SetDPMSMode(uint32 dpms_flags);
+
+uint32   Rage128_DPMSCapabilities(void);
+uint32   Rage128_GetDPMSMode(void);
+status_t Rage128_SetDPMSMode(uint32 dpms_flags);
+
+// Cursor
+status_t SetCursorShape(uint16 width, uint16 height, uint16 hot_x, uint16 hot_y,
+						uint8* andMask, uint8* xorMask);
+void	 MoveCursor(uint16 x, uint16 y);
+
+// Engine Management
+uint32   AccelerantEngineCount(void);
+status_t AcquireEngine(uint32 capabilities, uint32 max_wait, sync_token* st, engine_token** et);
+status_t ReleaseEngine(engine_token* et, sync_token* st);
+void	 WaitEngineIdle(void);
+status_t GetSyncToken(engine_token* et, sync_token* st);
+status_t SyncToToken(sync_token* st);
+
+// 2D acceleration
+void	 Mach64_FillRectangle(engine_token* et, uint32 color, fill_rect_params* list, uint32 count);
+void	 Mach64_FillSpan(engine_token* et, uint32 color, uint16* list, uint32 count);
+void	 Mach64_InvertRectangle(engine_token* et, fill_rect_params* list, uint32 count);
+void	 Mach64_ScreenToScreenBlit(engine_token* et, blit_params* list, uint32 count);
+
+void	 Rage128_FillRectangle(engine_token* et, uint32 color, fill_rect_params* list, uint32 count);
+void	 Rage128_FillSpan(engine_token* et, uint32 color, uint16* list, uint32 count);
+void	 Rage128_InvertRectangle(engine_token* et, fill_rect_params* list, uint32 count);
+void	 Rage128_ScreenToScreenBlit(engine_token* et, blit_params* list, uint32 count);
+
+#if defined(__cplusplus)
+}
+#endif
+
+
+
+// Prototypes for other functions that are called from source files other than
+// where they are defined.
+//============================================================================
+
+status_t CreateModeList(bool (*checkMode)(const display_mode* mode));
+uint16	 GetVesaModeNumber(const display_mode&amp; mode, uint8 bitsPerPixel);
+bool	 IsModeUsable(const display_mode* mode);
+
+// Mach64 functions.
+
+void	 Mach64_EngineReset(void);
+void	 Mach64_EngineInit(const DisplayModeEx&amp; mode);
+
+bool	 Mach64_LoadCursorImage(int width, int height, uint8* and_mask, uint8* xor_mask);
+void	 Mach64_SetCursorPosition(int x, int y);
+void	 Mach64_ShowCursor(bool bShow);
+
+void	 Mach64_AdjustFrame(const DisplayModeEx&amp; mode);
+status_t Mach64_SetDisplayMode(const DisplayModeEx&amp; mode);
+void	 Mach64_SetFunctionPointers(void);
+
+int		 Mach64_Divide(int numerator, int denom, int shift, const int roundingKind);
+void	 Mach64_ReduceRatio(int *numerator, int *denominator);
+
+
+// Rage128 functions.
+
+void	 Rage128_EngineFlush(void);
+void	 Rage128_EngineReset(void);
+void	 Rage128_EngineInit(const DisplayModeEx&amp; mode);
+
+bool	 Rage128_GetEdidInfo(void);
+
+bool	 Rage128_LoadCursorImage(int width, int height, uint8* and_mask, uint8* xor_mask);
+void	 Rage128_SetCursorPosition(int x, int y);
+void	 Rage128_ShowCursor(bool bShow);
+
+void	 Rage128_AdjustFrame(const DisplayModeEx&amp; mode);
+status_t Rage128_SetDisplayMode(const DisplayModeEx&amp; mode);
+void	 Rage128_SetFunctionPointers(void);
+
+
+// Macros for memory mapped I/O for both Mach64 and Rage128 chips.
+//================================================================
+
+#define INREG8(addr)		*((vuint8*)(gInfo.regs + addr))
+#define INREG16(addr)		*((vuint16*)(gInfo.regs + addr))
+#define INREG(addr)			*((vuint32*)(gInfo.regs + addr))
+
+#define OUTREG8(addr, val)	*((vuint8*)(gInfo.regs + addr)) = val
+#define OUTREG16(addr, val)	*((vuint16*)(gInfo.regs + addr)) = val
+#define OUTREG(addr, val)	*((vuint32*)(gInfo.regs + addr)) = val
+
+// Write a value to an 32-bit reg using a mask.  The mask selects the
+// bits to be modified.
+#define OUTREGM(addr, value, mask)	\
+	(OUTREG(addr, (INREG(addr) &amp; ~mask) | (value &amp; mask)))
+
+
+#endif	// _ACCELERANT_H

Added: haiku/trunk/src/add-ons/accelerants/ati/cursor.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/cursor.cpp	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/cursor.cpp	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,81 @@
+/*
+	Copyright 1999, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+
+	Other authors:
+	Gerald Zajac 2007-2008
+*/
+
+#include &quot;accelerant.h&quot;
+
+
+status_t
+SetCursorShape(uint16 width, uint16 height, uint16 hot_x, uint16 hot_y,
+				uint8* andMask, uint8* xorMask)
+{
+	// NOTE: Currently, for BeOS, cursor width and height must be equal to 16.
+
+	if ((width != 16) || (height != 16)) {
+		return B_ERROR;
+	} else if ((hot_x &gt;= width) || (hot_y &gt;= height)) {
+		return B_ERROR;
+	} else {
+		// Update cursor variables appropriately.
+
+		SharedInfo&amp; si = *gInfo.sharedInfo;
+		si.cursorHotX = hot_x;
+		si.cursorHotY = hot_y;
+
+		if ( ! gInfo.LoadCursorImage(width, height, andMask, xorMask))
+			return B_ERROR;
+	}
+
+	return B_OK;
+}
+
+
+void
+MoveCursor(uint16 xPos, uint16 yPos)
+{
+	// Move the cursor to the specified position on the desktop.  If we're
+	// using some kind of virtual desktop, adjust the display start position
+	// accordingly and position the cursor in the proper &quot;virtual&quot; location.
+
+	int x = xPos;		// use signed int's since chip specific functions
+	int y = yPos;		// need signed int to determine if cursor off screen
+
+	SharedInfo&amp; si = *gInfo.sharedInfo;
+	DisplayModeEx&amp; dm = si.displayMode;
+
+	uint16 hds = dm.h_display_start;	// current horizontal starting pixel
+	uint16 vds = dm.v_display_start;	// current vertical starting line
+
+	// Clamp cursor to virtual display.
+	if (x &gt;= dm.virtual_width)
+		x = dm.virtual_width - 1;
+	if (y &gt;= dm.virtual_height)
+		y = dm.virtual_height - 1;
+
+	// Adjust h/v display start to move cursor onto screen.
+	if (x &gt;= (dm.timing.h_display + hds))
+		hds = x - dm.timing.h_display + 1;
+	else if (x &lt; hds)
+		hds = x;
+
+	if (y &gt;= (dm.timing.v_display + vds))
+		vds = y - dm.timing.v_display + 1;
+	else if (y &lt; vds)
+		vds = y;
+
+	// Reposition the desktop on the display if required.
+	if (hds != dm.h_display_start || vds != dm.v_display_start)
+		MoveDisplay(hds, vds);
+
+	// Put cursor in correct physical position.
+	x -= (hds + si.cursorHotX);
+	y -= (vds + si.cursorHotY);
+
+	// Position the cursor on the display.
+	gInfo.SetCursorPosition(x, y);
+}
+

Added: haiku/trunk/src/add-ons/accelerants/ati/engine.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/engine.cpp	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/engine.cpp	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,78 @@
+/*
+	Copyright 1999, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+
+	Other authors:
+	Gerald Zajac 2007-2008
+*/
+
+#include &quot;accelerant.h&quot;
+
+
+static engine_token engineToken = { 1, B_2D_ACCELERATION, NULL };
+
+
+uint32
+AccelerantEngineCount(void)
+{
+	return 1;
+}
+
+
+status_t
+AcquireEngine(uint32 capabilities, uint32 max_wait,
+						sync_token* st, engine_token** et)
+{
+	(void)capabilities;	// avoid compiler warning for unused arg
+	(void)max_wait;		// avoid compiler warning for unused arg
+
+	if (gInfo.sharedInfo-&gt;engineLock.Acquire() != B_OK)
+		return B_ERROR;
+
+	// Sync if required.
+	if (st)
+		SyncToToken(st);
+
+	// Return an engine token.
+	*et = &engineToken;
+	return B_OK;
+}
+
+
+status_t
+ReleaseEngine(engine_token* et, sync_token* st)
+{
+	// Update the sync token, if any.
+	if (st)
+		GetSyncToken(et, st);
+
+	gInfo.sharedInfo-&gt;engineLock.Release();
+	return B_OK;
+}
+
+
+void
+WaitEngineIdle(void)
+{
+	gInfo.WaitForIdle();	// wait until engine is completely idle
+}
+
+
+status_t
+GetSyncToken(engine_token* et, sync_token* st)
+{
+	st-&gt;engine_id = et-&gt;engine_id;
+	st-&gt;counter = 0;
+	return B_OK;
+}
+
+
+status_t
+SyncToToken(sync_token* st)
+{
+	(void)st;		// avoid compiler warning for unused arg
+
+	WaitEngineIdle();
+	return B_OK;
+}
+

Added: haiku/trunk/src/add-ons/accelerants/ati/hooks.cpp
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/hooks.cpp	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/hooks.cpp	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,67 @@
+/*
+	Copyright 2008 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2008
+*/
+
+#include &quot;accelerant.h&quot;
+
+
+extern &quot;C&quot; void*
+get_accelerant_hook(uint32 feature, void* data)
+{
+	(void)data;		// avoid compiler warning for unused arg
+
+	switch (feature) {
+		// General
+		case B_INIT_ACCELERANT:				return (void*)InitAccelerant;
+		case B_UNINIT_ACCELERANT:			return (void*)UninitAccelerant;
+		case B_CLONE_ACCELERANT:			return (void*)CloneAccelerant;
+		case B_ACCELERANT_CLONE_INFO_SIZE:	return (void*)AccelerantCloneInfoSize;
+		case B_GET_ACCELERANT_CLONE_INFO:	return (void*)GetAccelerantCloneInfo;
+		case B_GET_ACCELERANT_DEVICE_INFO:	return (void*)GetAccelerantDeviceInfo;
+		case B_ACCELERANT_RETRACE_SEMAPHORE: return (void*)AccelerantRetraceSemaphore;
+
+		// Mode Configuration
+		case B_ACCELERANT_MODE_COUNT:	return (void*)AccelerantModeCount;
+		case B_GET_MODE_LIST:			return (void*)GetModeList;
+		case B_PROPOSE_DISPLAY_MODE:	return (void*)ProposeDisplayMode;
+		case B_SET_DISPLAY_MODE:		return (void*)SetDisplayMode;
+		case B_GET_DISPLAY_MODE:		return (void*)GetDisplayMode;
+		case B_GET_PREFERRED_DISPLAY_MODE: return (void*)GetPreferredDisplayMode;
+		case B_GET_EDID_INFO:			return (void*)GetEdidInfo;
+		case B_GET_FRAME_BUFFER_CONFIG:	return (void*)GetFrameBufferConfig;
+		case B_GET_PIXEL_CLOCK_LIMITS:	return (void*)GetPixelClockLimits;
+		case B_MOVE_DISPLAY:			return (void*)MoveDisplay;
+		case B_SET_INDEXED_COLORS:		return (void*)(gInfo.SetIndexedColors);
+		case B_GET_TIMING_CONSTRAINTS:	return (void*)GetTimingConstraints;
+
+		// DPMS
+		case B_DPMS_CAPABILITIES:		return (void*)(gInfo.DPMSCapabilities);
+		case B_DPMS_MODE:				return (void*)(gInfo.GetDPMSMode);
+		case B_SET_DPMS_MODE:			return (void*)(gInfo.SetDPMSMode);
+
+		// Cursor
+		case B_SET_CURSOR_SHAPE:		return (void*)SetCursorShape;
+		case B_MOVE_CURSOR:				return (void*)MoveCursor;
+		case B_SHOW_CURSOR:				return (void*)(gInfo.ShowCursor);
+
+		// Engine Management
+		case B_ACCELERANT_ENGINE_COUNT:	return (void*)AccelerantEngineCount;
+		case B_ACQUIRE_ENGINE:			return (void*)AcquireEngine;
+		case B_RELEASE_ENGINE:			return (void*)ReleaseEngine;
+		case B_WAIT_ENGINE_IDLE:		return (void*)WaitEngineIdle;
+		case B_GET_SYNC_TOKEN:			return (void*)GetSyncToken;
+		case B_SYNC_TO_TOKEN:			return (void*)SyncToToken;
+
+		// 2D acceleration
+		case B_SCREEN_TO_SCREEN_BLIT:	return (void*)(gInfo.ScreenToScreenBlit);
+		case B_FILL_RECTANGLE:			return (void*)(gInfo.FillRectangle);
+		case B_INVERT_RECTANGLE:		return (void*)(gInfo.InvertRectangle);
+		case B_FILL_SPAN:				return (void*)(gInfo.FillSpan);
+	}
+
+	return NULL;	// Return null pointer for any feature not handled above
+}

Added: haiku/trunk/src/add-ons/accelerants/ati/mach64.h
===================================================================
--- haiku/trunk/src/add-ons/accelerants/ati/mach64.h	2009-06-04 21:06:06 UTC (rev 30961)
+++ haiku/trunk/src/add-ons/accelerants/ati/mach64.h	2009-06-05 02:50:25 UTC (rev 30962)
@@ -0,0 +1,476 @@
+/*
+	Haiku ATI video driver adapted from the X.org ATI driver.
+
+	Copyright 1992,1993,1994,1995,1996,1997 by Kevin E. Martin, Chapel Hill, North Carolina.
+
+	Copyright 2009 Haiku, Inc.  All rights reserved.
+	Distributed under the terms of the MIT license.
+
+	Authors:
+	Gerald Zajac 2009
+*/
+
+#ifndef __MACH64_H__
+#define __MACH64_H__
+
+
+#define CURSOR_BYTES	1024		// bytes used for cursor image in video memory
+
+// Memory types for Mach64 chips.
+
+enum Mach64_MemoryType
+{
+    MEM_NONE,
+    MEM_DRAM,
+    MEM_EDO,
+    MEM_PSEUDO_EDO,
+    MEM_SDRAM,
+    MEM_SGRAM,
+    MEM_SGRAM32,
+    MEM_TYPE_7
+};
+
+
+// Macros to get/set a contiguous bit field.  Arguments should not be
+// self-modifying.
+
+#define UnitOf(___Value) (((((___Value) ^ ((___Value) - 1)) + 1) &gt;&gt; 1) \
+						| ((((___Value) ^ ((___Value) - 1)) &gt;&gt; 1) + 1))
+
+#define GetBits(__Value, _Mask) (((__Value) &amp; (_Mask)) / UnitOf(_Mask))
+#define SetBits(__Value, _Mask) (((__Value) * UnitOf(_Mask)) &amp; (_Mask))
+
+
+// Register MMIO addresses - expressed in BYTE offsets.
+//-----------------------------------------------------
+
+#define CRTC_H_TOTAL_DISP		(0x0c00 + 0x0000)	// Dword offset 00
+#define CRTC_H_SYNC_STRT_WID	(0x0c00 + 0x0004)	// Dword offset 01
+#define CRTC_V_TOTAL_DISP		(0x0c00 + 0x0008)	// Dword offset 02
+#define CRTC_V_SYNC_STRT_WID	(0x0c00 + 0x000C)	// Dword offset 03
+#define CRTC_VLINE_CRNT_VLINE	(0x0c00 + 0x0010)	// Dword offset 04
+#define CRTC_OFF_PITCH			(0x0c00 + 0x0014)	// Dword offset 05
+#define CRTC_INT_CNTL			(0x0c00 + 0x0018)	// Dword offset 06
+#define CRTC_GEN_CNTL			(0x0c00 + 0x001C)	// Dword offset 07
+
+#define DSP_CONFIG				(0x0c00 + 0x0020)	// Dword offset 08
+#define DSP_ON_OFF				(0x0c00 + 0x0024)	// Dword offset 09
+
+#define SHARED_CNTL 			(0x0c00 + 0x0038)	// Dword offset 0E
+
+#define OVR_CLR 				(0x0c00 + 0x0040)	// Dword offset 10
+#define OVR_WID_LEFT_RIGHT		(0x0c00 + 0x0044)	// Dword offset 11
+#define OVR_WID_TOP_BOTTOM		(0x0c00 + 0x0048)	// Dword offset 12
+
+#define CUR_CLR0				(0x0c00 + 0x0060)	// Dword offset 18
+#define CUR_CLR1				(0x0c00 + 0x0064)	// Dword offset 19
+#define CUR_OFFSET				(0x0c00 + 0x0068)	// Dword offset 1A
+#define CUR_HORZ_VERT_POSN		(0x0c00 + 0x006C)	// Dword offset 1B
+#define CUR_HORZ_VERT_OFF		(0x0c00 + 0x0070)	// Dword offset 1C
+
+#define HW_DEBUG				(0x0c00 + 0x007C)	// Dword offset 1F
+
+#define SCRATCH_REG0			(0x0c00 + 0x0080)	// Dword offset 20
+#define SCRATCH_REG1			(0x0c00 + 0x0084)	// Dword offset 21
+
+#define CLOCK_CNTL				(0x0c00 + 0x0090)	// Dword offset 24
+
+#define BUS_CNTL				(0x0c00 + 0x00A0)	// Dword offset 28
+
+#define LCD_INDEX				(0x0c00 + 0x00A4)	// Dword offset 29
+#define LCD_DATA				(0x0c00 + 0x00A8)	// Dword offset 2A
+
+#define MEM_CNTL				(0x0c00 + 0x00B0)	// Dword offset 2C
+
+#define MEM_VGA_WP_SEL			(0x0c00 + 0x00B4)	// Dword offset 2D
+#define MEM_VGA_RP_SEL			(0x0c00 + 0x00B8)	// Dword offset 2E
+
+#define DAC_REGS				(0x0c00 + 0x00C0)	// Dword offset 30
+#define DAC_W_INDEX				(DAC_REGS + 0)
+#define DAC_DATA				(DAC_REGS + 1)
+#define DAC_MASK				(DAC_REGS + 2)
+#define DAC_R_INDEX				(DAC_REGS + 3)
+#define DAC_CNTL				(0x0c00 + 0x00C4)	// Dword offset 31
+
+#define GEN_TEST_CNTL			(0x0c00 + 0x00D0)	// Dword offset 34
+
+#define CONFIG_CNTL				(0x0c00 + 0x00DC	// Dword offset 37 (CT, ET, VT)
+#define CONFIG_CHIP_ID			(0x0c00 + 0x00E0)	// Dword offset 38
+#define CONFIG_STAT0			(0x0c00 + 0x00E4)	// Dword offset 39
+#define CONFIG_STAT1			(0x0c00 + 0x00E8)	// Dword offset 3A
+
+#define DST_OFF_PITCH			(0x0c00 + 0x0100)	// Dword offset 40
+#define DST_X					(0x0c00 + 0x0104)	// Dword offset 41
+#define DST_Y					(0x0c00 + 0x0108)	// Dword offset 42
+#define DST_Y_X 				(0x0c00 + 0x010C)	// Dword offset 43
+#define DST_WIDTH				(0x0c00 + 0x0110)	// Dword offset 44
+#define DST_HEIGHT				(0x0c00 + 0x0114)	// Dword offset 45
+#define DST_HEIGHT_WIDTH		(0x0c00 + 0x0118)	// Dword offset 46
+#define DST_X_WIDTH 			(0x0c00 + 0x011C)	// Dword offset 47
+#define DST_BRES_LNTH			(0x0c00 + 0x0120)	// Dword offset 48
+#define DST_BRES_ERR			(0x0c00 + 0x0124)	// Dword offset 49
+#define DST_BRES_INC			(0x0c00 + 0x0128)	// Dword offset 4A
+#define DST_BRES_DEC			(0x0c00 + 0x012C)	// Dword offset 4B
+#define DST_CNTL				(0x0c00 + 0x0130)	// Dword offset 4C
+
+#define SRC_OFF_PITCH			(0x0c00 + 0x0180)	// Dword offset 60
+#define SRC_X					(0x0c00 + 0x0184)	// Dword offset 61
+#define SRC_Y					(0x0c00 + 0x0188)	// Dword offset 62
+#define SRC_Y_X 				(0x0c00 + 0x018C)	// Dword offset 63
+#define SRC_WIDTH1				(0x0c00 + 0x0190)	// Dword offset 64
+#define SRC_HEIGHT1 			(0x0c00 + 0x0194)	// Dword offset 65
+#define SRC_HEIGHT1_WIDTH1		(0x0c00 + 0x0198)	// Dword offset 66
+#define SRC_X_START 			(0x0c00 + 0x019C)	// Dword offset 67
+#define SRC_Y_START 			(0x0c00 + 0x01A0)	// Dword offset 68
+#define SRC_Y_X_START			(0x0c00 + 0x01A4)	// Dword offset 69
+#define SRC_WIDTH2				(0x0c00 + 0x01A8)	// Dword offset 6A
+#define SRC_HEIGHT2 			(0x0c00 + 0x01AC)	// Dword offset 6B
+#define SRC_HEIGHT2_WIDTH2		(0x0c00 + 0x01B0)	// Dword offset 6C
+#define SRC_CNTL				(0x0c00 + 0x01B4)	// Dword offset 6D
+
+#define HOST_DATA0				(0x0c00 + 0x0200)	// Dword offset 80
+#define HOST_DATA1				(0x0c00 + 0x0204)	// Dword offset 81
+#define HOST_DATA2				(0x0c00 + 0x0208)	// Dword offset 82
+#define HOST_DATA3				(0x0c00 + 0x020C)	// Dword offset 83
+#define HOST_DATA4				(0x0c00 + 0x0210)	// Dword offset 84
+#define HOST_DATA5				(0x0c00 + 0x0214)	// Dword offset 85
+#define HOST_DATA6				(0x0c00 + 0x0218)	// Dword offset 86
+#define HOST_DATA7				(0x0c00 + 0x021C)	// Dword offset 87
+#define HOST_DATA8				(0x0c00 + 0x0220)	// Dword offset 88
+#define HOST_DATA9				(0x0c00 + 0x0224)	// Dword offset 89
+#define HOST_DATAA				(0x0c00 + 0x0228)	// Dword offset 8A
+#define HOST_DATAB				(0x0c00 + 0x022C)	// Dword offset 8B
+#define HOST_DATAC				(0x0c00 + 0x0230)	// Dword offset 8C
+#define HOST_DATAD				(0x0c00 + 0x0234)	// Dword offset 8D
+#define HOST_DATAE				(0x0c00 + 0x0238)	// Dword offset 8E
+#define HOST_DATAF				(0x0c00 + 0x023C)	// Dword offset 8F
+#define HOST_CNTL				(0x0c00 + 0x0240)	// Dword offset 90
+
+#define PAT_REG0				(0x0c00 + 0x0280)	// Dword offset A0
+#define PAT_REG1				(0x0c00 + 0x0284)	// Dword offset A1
+#define PAT_CNTL				(0x0c00 + 0x0288)	// Dword offset A2
+
+#define SC_LEFT 				(0x0c00 + 0x02A0)	// Dword offset A8
+#define SC_RIGHT				(0x0c00 + 0x02A4)	// Dword offset A9
+#define SC_LEFT_RIGHT			(0x0c00 + 0x02A8)	// Dword offset AA
+#define SC_TOP					(0x0c00 + 0x02AC)	// Dword offset AB
+#define SC_BOTTOM				(0x0c00 + 0x02B0)	// Dword offset AC
+#define SC_TOP_BOTTOM			(0x0c00 + 0x02B4)	// Dword offset AD
+
+#define DP_BKGD_CLR 			(0x0c00 + 0x02C0)	// Dword offset B0
+#define DP_FRGD_CLR 			(0x0c00 + 0x02C4)	// Dword offset B1
+#define DP_WRITE_MASK			(0x0c00 + 0x02C8)	// Dword offset B2
+#define DP_CHAIN_MASK			(0x0c00 + 0x02CC)	// Dword offset B3
+#define DP_PIX_WIDTH			(0x0c00 + 0x02D0)	// Dword offset B4
+#define DP_MIX					(0x0c00 + 0x02D4)	// Dword offset B5
+#define DP_SRC					(0x0c00 + 0x02D8)	// Dword offset B6
+
+#define CLR_CMP_CLR 			(0x0c00 + 0x0300)	// Dword offset C0
+#define CLR_CMP_MASK			(0x0c00 + 0x0304)	// Dword offset C1
+#define CLR_CMP_CNTL			(0x0c00 + 0x0308)	// Dword offset C2
+
+#define FIFO_STAT				(0x0c00 + 0x0310)	// Dword offset C4
+
+#define CONTEXT_MASK			(0x0c00 + 0x0320)	// Dword offset C8
+#define CONTEXT_LOAD_CNTL		(0x0c00 + 0x032C)	// Dword offset CB
+
+#define GUI_TRAJ_CNTL			(0x0c00 + 0x0330)	// Dword offset CC
+#define GUI_STAT				(0x0c00 + 0x0338)	// Dword offset CE
+
+
+// CRTC control values.
+
+#define CRTC_H_SYNC_NEG			0x00200000
+#define CRTC_V_SYNC_NEG			0x00200000
+
+#define CRTC_DBL_SCAN_EN		0x00000001
+#define CRTC_INTERLACE_EN		0x00000002
+#define CRTC_HSYNC_DIS			0x00000004
+#define CRTC_VSYNC_DIS			0x00000008
+#define CRTC_CSYNC_EN			0x00000010
+#define CRTC_PIX_BY_2_EN		0x00000020
+#define CRTC_DISPLAY_DIS		0x00000040
+#define CRTC_VGA_XOVERSCAN		0x00000080
+
+#define CRTC_PIX_WIDTH			0x00000700
+#define CRTC_PIX_WIDTH_4BPP		0x00000100
+#define CRTC_PIX_WIDTH_8BPP		0x00000200
+#define CRTC_PIX_WIDTH_15BPP	0x00000300
+#define CRTC_PIX_WIDTH_16BPP	0x00000400
+#define CRTC_PIX_WIDTH_24BPP	0x00000500
+#define CRTC_PIX_WIDTH_32BPP	0x00000600
+
+#define CRTC_BYTE_PIX_ORDER		0x00000800
+#define CRTC_PIX_ORDER_MSN_LSN	0x00000000
+#define CRTC_PIX_ORDER_LSN_MSN	0x00000800
+
+#define CRTC_FIFO_LWM			0x000f0000
+#define CRTC2_PIX_WIDTH			0x000e0000
+#define CRTC_VGA_128KAP_PAGING	0x00100000
+#define CRTC_VFC_SYNC_TRISTATE	0x00200000
+#define CRTC2_EN				0x00200000
+#define CRTC_LOCK_REGS			0x00400000
+#define CRTC_SYNC_TRISTATE		0x00800000
+#define CRTC_EXT_DISP_EN		0x01000000
+#define CRTC_EN					0x02000000
+#define CRTC_DISP_REQ_EN		0x04000000
+#define CRTC_VGA_LINEAR			0x08000000
+#define CRTC_VGA_TEXT_132		0x20000000
+#define CRTC_CNT_EN				0x40000000
+#define CRTC_CUR_B_TEST			0x80000000
+
+#define CRTC_CRNT_VLINE			0x07f00000
+#define CRTC_VBLANK				0x00000001
+
+#define CRTC_PITCH				0xffc00000
+
+// DAC control values.
+
+#define DAC_8BIT_EN				0x00000100
+
+// Mix control values.
+
+#define MIX_NOT_DST				0x0000
+#define MIX_0 					0x0001
+#define MIX_1 					0x0002
+#define MIX_DST					0x0003

[... truncated: 4631 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="017090.html">[Haiku-commits] r30961 -	haiku/trunk/src/system/kernel/device_manager
</A></li>
	<LI>Next message: <A HREF="017092.html">[Haiku-commits] r30962 - in haiku/trunk: build/jam	src/add-ons/accelerants src/add-ons/accelerants/ati	src/add-ons/kernel/drivers/graphics	src/add-ons/kernel/drivers/graphics/ati
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#17091">[ date ]</a>
              <a href="thread.html#17091">[ thread ]</a>
              <a href="subject.html#17091">[ subject ]</a>
              <a href="author.html#17091">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
