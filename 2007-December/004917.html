<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23041 - in haiku/vendor/freebsd: . current	current/dev current/dev/em current/dev/fxp current/dev/mii	current/dev/msk current/pci
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23041%20-%20in%20haiku/vendor/freebsd%3A%20.%20current%0A%09current/dev%20current/dev/em%20current/dev/fxp%20current/dev/mii%0A%09current/dev/msk%20current/pci&In-Reply-To=%3C200712011539.lB1Fd1w4004347%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004916.html">
   <LINK REL="Next"  HREF="004918.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23041 - in haiku/vendor/freebsd: . current	current/dev current/dev/em current/dev/fxp current/dev/mii	current/dev/msk current/pci</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23041%20-%20in%20haiku/vendor/freebsd%3A%20.%20current%0A%09current/dev%20current/dev/em%20current/dev/fxp%20current/dev/mii%0A%09current/dev/msk%20current/pci&In-Reply-To=%3C200712011539.lB1Fd1w4004347%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23041 - in haiku/vendor/freebsd: . current	current/dev current/dev/em current/dev/fxp current/dev/mii	current/dev/msk current/pci">axeld at mail.berlios.de
       </A><BR>
    <I>Sat Dec  1 16:39:01 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004916.html">[Haiku-commits] r23040 - haiku/vendor
</A></li>
        <LI>Next message: <A HREF="004918.html">[Haiku-commits] r23042 - haiku/vendor/freebsd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4917">[ date ]</a>
              <a href="thread.html#4917">[ thread ]</a>
              <a href="subject.html#4917">[ subject ]</a>
              <a href="author.html#4917">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-12-01 16:38:33 +0100 (Sat, 01 Dec 2007)
New Revision: 23041
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23041&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23041&amp;view=rev</A>

Added:
   haiku/vendor/freebsd/current/
   haiku/vendor/freebsd/current/dev/
   haiku/vendor/freebsd/current/dev/em/
   haiku/vendor/freebsd/current/dev/em/LICENSE
   haiku/vendor/freebsd/current/dev/em/README
   haiku/vendor/freebsd/current/dev/em/e1000_80003es2lan.c
   haiku/vendor/freebsd/current/dev/em/e1000_80003es2lan.h
   haiku/vendor/freebsd/current/dev/em/e1000_82540.c
   haiku/vendor/freebsd/current/dev/em/e1000_82541.c
   haiku/vendor/freebsd/current/dev/em/e1000_82541.h
   haiku/vendor/freebsd/current/dev/em/e1000_82542.c
   haiku/vendor/freebsd/current/dev/em/e1000_82543.c
   haiku/vendor/freebsd/current/dev/em/e1000_82543.h
   haiku/vendor/freebsd/current/dev/em/e1000_82571.c
   haiku/vendor/freebsd/current/dev/em/e1000_82571.h
   haiku/vendor/freebsd/current/dev/em/e1000_82575.c
   haiku/vendor/freebsd/current/dev/em/e1000_82575.h
   haiku/vendor/freebsd/current/dev/em/e1000_api.c
   haiku/vendor/freebsd/current/dev/em/e1000_api.h
   haiku/vendor/freebsd/current/dev/em/e1000_defines.h
   haiku/vendor/freebsd/current/dev/em/e1000_hw.h
   haiku/vendor/freebsd/current/dev/em/e1000_ich8lan.c
   haiku/vendor/freebsd/current/dev/em/e1000_ich8lan.h
   haiku/vendor/freebsd/current/dev/em/e1000_mac.c
   haiku/vendor/freebsd/current/dev/em/e1000_mac.h
   haiku/vendor/freebsd/current/dev/em/e1000_manage.c
   haiku/vendor/freebsd/current/dev/em/e1000_manage.h
   haiku/vendor/freebsd/current/dev/em/e1000_nvm.c
   haiku/vendor/freebsd/current/dev/em/e1000_nvm.h
   haiku/vendor/freebsd/current/dev/em/e1000_osdep.h
   haiku/vendor/freebsd/current/dev/em/e1000_phy.c
   haiku/vendor/freebsd/current/dev/em/e1000_phy.h
   haiku/vendor/freebsd/current/dev/em/e1000_regs.h
   haiku/vendor/freebsd/current/dev/em/if_em.c
   haiku/vendor/freebsd/current/dev/em/if_em.h
   haiku/vendor/freebsd/current/dev/fxp/
   haiku/vendor/freebsd/current/dev/fxp/if_fxp.c
   haiku/vendor/freebsd/current/dev/fxp/if_fxpreg.h
   haiku/vendor/freebsd/current/dev/fxp/if_fxpvar.h
   haiku/vendor/freebsd/current/dev/fxp/rcvbundl.h
   haiku/vendor/freebsd/current/dev/mii/
   haiku/vendor/freebsd/current/dev/mii/bmtphy.c
   haiku/vendor/freebsd/current/dev/mii/bmtphyreg.h
   haiku/vendor/freebsd/current/dev/mii/brgphyreg.h
   haiku/vendor/freebsd/current/dev/mii/ciphy.c
   haiku/vendor/freebsd/current/dev/mii/ciphyreg.h
   haiku/vendor/freebsd/current/dev/mii/e1000phy.c
   haiku/vendor/freebsd/current/dev/mii/e1000phyreg.h
   haiku/vendor/freebsd/current/dev/mii/exphy.c
   haiku/vendor/freebsd/current/dev/mii/rlphy.c
   haiku/vendor/freebsd/current/dev/mii/ukphy.c
   haiku/vendor/freebsd/current/dev/mii/ukphy_subr.c
   haiku/vendor/freebsd/current/dev/msk/
   haiku/vendor/freebsd/current/dev/msk/if_msk.c
   haiku/vendor/freebsd/current/dev/msk/if_mskreg.h
   haiku/vendor/freebsd/current/pci/
   haiku/vendor/freebsd/current/pci/if_rl.c
   haiku/vendor/freebsd/current/pci/if_rlreg.h
   haiku/vendor/freebsd/current/pci/if_vr.c
   haiku/vendor/freebsd/current/pci/if_vrreg.h
   haiku/vendor/freebsd/current/pci/if_xl.c
   haiku/vendor/freebsd/current/pci/if_xlreg.h
Log:
Added verbatim copies of the FreeBSD 7 drivers we're currently using.


Added: haiku/vendor/freebsd/current/dev/em/LICENSE
===================================================================
--- haiku/vendor/freebsd/current/dev/em/LICENSE	2007-12-01 15:27:56 UTC (rev 23040)
+++ haiku/vendor/freebsd/current/dev/em/LICENSE	2007-12-01 15:38:33 UTC (rev 23041)
@@ -0,0 +1,31 @@
+$FreeBSD: src/sys/dev/em/LICENSE,v 1.6 2007/05/04 00:00:11 jfv Exp $
+
+  Copyright (c) 2001-2007, Intel Corporation 
+  All rights reserved.
+  
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions are met:
+  
+   1. Redistributions of source code must retain the above copyright notice, 
+      this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in the 
+      documentation and/or other materials provided with the distribution.
+  
+   3. Neither the name of the Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived from 
+      this software without specific prior written permission.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+

Added: haiku/vendor/freebsd/current/dev/em/README
===================================================================
--- haiku/vendor/freebsd/current/dev/em/README	2007-12-01 15:27:56 UTC (rev 23040)
+++ haiku/vendor/freebsd/current/dev/em/README	2007-12-01 15:38:33 UTC (rev 23041)
@@ -0,0 +1,405 @@
+$FreeBSD: src/sys/dev/em/README,v 1.15 2007/05/30 23:32:21 jfv Exp $
+FreeBSD* Driver for Intel Network Connection
+=============================================
+
+May 30, 2007
+
+
+Contents
+========
+
+- Overview
+- Identifying Your Adapter
+- Building and Installation
+- Speed and Duplex Configuration
+- Additional Configurations
+- Known Limitations
+- Support
+- License
+
+
+Overview
+========
+
+This file describes the FreeBSD* driver for Intel Network Connection.
+This driver has been developed for use with FreeBSD, Release 7.x.
+
+For questions related to hardware requirements, refer to the documentation
+supplied with your Gigabit adapter. All hardware requirements listed
+apply to use with FreeBSD.
+
+
+Identifying Your Adapter
+========================
+
+For information on how to identify your adapter, go to the Adapter &amp;
+Driver ID Guide at:
+
+<A HREF="http://support.intel.com/support/network/sb/cs-012904.htm">http://support.intel.com/support/network/sb/cs-012904.htm</A>
+
+
+For the latest Intel network drivers for FreeBSD, see:
+
+<A HREF="http://downloadfinder.intel.com/scripts-df-external/support_intel.aspx">http://downloadfinder.intel.com/scripts-df-external/support_intel.aspx</A>
+
+
+NOTE: Mobile adapters are not fully supported.
+NOTE: The Intel(R) 82562v 10/100 Network Connection only provides 10/100
+support.
+
+Building and Installation
+=========================
+
+NOTE: The driver can be installed as a dynamic loadable kernel module or
+      compiled into the kernel. You must have kernel sources installed in
+      order to compile the driver module.
+
+In the instructions below, x.x.x is the driver version as indicated in the
+name of the driver tar file.
+
+1. Move the base driver tar file to the directory of your choice. For
+   example, use /home/username/em or /usr/local/src/em.
+
+2. Untar/unzip the archive:
+
+        tar xzvf em-x.x.x.tar.gz
+
+   This will create an em-x.x.x directory.
+
+3. To create a loadable module, perform the following steps.
+   NOTE: To compile the driver into the kernel, go directly to step 4.
+
+        a. To compile the module
+
+                  cd em-x.x.x
+                  make
+
+        b. To install the compiled module to the system directory:
+
+                  make install
+
+        c. If you want the driver to load automatically when the system is booted:
+
+              1. Edit /boot/loader.conf, and add the following line:
+
+                  if_em_load=&quot;YES&quot;
+
+4. To compile the driver into the kernel, enter:
+
+        cd em-x.x.x/src
+        cp *.[ch] /usr/src/sys/dev/em
+
+        Edit the kernel configuration file (i.e., GENERIC or MYKERNEL) in
+        /usr/src/sys/i386/conf, and ensure the following line is present:
+
+        device em
+
+        Compile and install the kernel. The system must be rebooted for the
+        kernel updates to take effect. For additional information on compiling
+        the kernel, consult the FreeBSD operating system documentation.
+
+5. To assign an IP address to the interface, enter the following:
+
+        ifconfig em&lt;interface_num&gt; &lt;IP_address&gt;
+
+6. Verify that the interface works. Enter the following, where &lt;IP_address&gt;
+   is the IP address for another machine on the same subnet as the interface
+   that is being tested:
+
+        ping &lt;IP_address&gt;
+
+7. To configure the IP address to remain after reboot, edit /etc/rc.conf,
+   and create the appropriate ifconfig_em&lt;interface_num&gt;entry:
+
+        ifconfig_em&lt;interface_num&gt;=&quot;&lt;ifconfig_settings&gt;&quot;
+
+   Example usage:
+
+        ifconfig_em0=&quot;inet 192.168.10.1 netmask 255.255.255.0&quot;
+
+   NOTE: For assistance, see the ifconfig man page.
+
+
+Speed and Duplex Configuration
+==============================
+
+By default, the adapter auto-negotiates the speed and duplex of the
+connection. If there is a specific need, the ifconfig utility can be used to
+configure the speed and duplex settings on the adapter. Example usage:
+
+        ifconfig em&lt;interface_num&gt; &lt;IP_address&gt; media 100baseTX mediaopt
+            full-duplex
+
+   NOTE: Only use mediaopt to set the driver to full-duplex. If mediaopt is
+         not specified and you are not running at gigabit speed, the driver
+         defaults to half-duplex.
+
+If the interface is currently forced to 100 full duplex, in order to change
+to half duplex you must use this command:
+
+        ifconfig em&lt;interface_num&gt; &lt;IP_address&gt; media 100baseTX -mediaopt
+            full-duplex
+
+
+This driver supports the following media type options:
+
+   autoselect      -  Enables auto-negotiation for speed and duplex.
+
+   10baseT/UTP     -  Sets speed to 10 Mbps. Use the ifconfig mediaopt
+                      option to select full-duplex mode.
+
+   100baseTX       -  Sets speed to 100 Mbps. Use the ifconfig mediaopt
+                      option to select full-duplex mode.
+
+   1000baseTX      -  Sets speed to 1000 Mbps. In this case, the driver
+                      supports only full-duplex mode.
+
+   1000baseSX      -  Sets speed to 1000 Mbps. In this case, the driver
+                      supports only full-duplex mode.
+
+For more information on the ifconfig utility, see the ifconfig man page.
+
+
+Additional Configurations
+=========================
+
+The driver supports Transmit/Receive Checksum Offload and Jumbo Frames on
+all but the 82542-based adapters.  For specific adapters, refer to the
+Identifying Your Adapter section.
+
+  Jumbo Frames
+  ------------
+  To enable Jumbo Frames, use the ifconfig utility to set the Maximum
+  Transport Unit (MTU) frame size above its default of 1500 bytes.
+
+  The Jumbo Frames MTU range for Intel Adapters is 1500 to 16110. To modify
+  the setting, enter the following:
+
+        ifconfig em&lt;interface_num&gt; &lt;hostname or IP address&gt; mtu 9000
+
+  To confirm the MTU used between two specific devices, use:
+
+        route get &lt;destination_IP_address&gt;
+
+  Notes:
+
+  - Only enable Jumbo Frames if your network infrastructure supports them.
+
+  - To enable Jumbo Frames, increase the MTU size on the interface beyond
+    1500.
+
+  - The Jumbo Frames setting on the switch must be set to at least 22 bytes
+    larger than that of the MTU.
+
+  - The maximum MTU setting for Jumbo Frames is 16110.  This value coincides
+    with the maximum Jumbo Frames size of 16128.
+
+  - Some Intel gigabit adapters that support Jumbo Frames have a frame size
+    limit of 9238 bytes, with a corresponding MTU size limit of 9216 bytes.
+    The adapters with this limitation are based on the Intel(R) 82571EB,
+    82572EI, 82573L, 82566, 82562, and 80003ES2LAN controller.  These
+    correspond to the following product names:
+     Intel(R) PRO/1000 PT Server Adapter
+     Intel(R) PRO/1000 PT Desktop Adapter
+     Intel(R) PRO/1000 PT Network Connection
+     Intel(R) PRO/1000 PT Dual Port Server Adapter
+     Intel(R) PRO/1000 PT Dual Port Network Connection
+     Intel(R) PRO/1000 PT Quad Port Server Adapter
+     Intel(R) PRO/1000 PF Quad Port Server Adapter
+     Intel(R) PRO/1000 PF Server Adapter
+     Intel(R) PRO/1000 PF Network Connection
+     Intel(R) PRO/1000 PF Dual Port Server Adapter
+     Intel(R) PRO/1000 PB Server Connection
+     Intel(R) PRO/1000 PL Network Connection
+     Intel(R) PRO/1000 EB Network Connection with I/O Acceleration
+     Intel(R) PRO/1000 EB Backplane Connection with I/O Acceleration
+     Intel(R) 82566DM-2 Gigabit Network Connection
+
+  - Adapters based on the Intel(R) 82542 and 82573V/E controller do not
+    support Jumbo Frames. These correspond to the following product names:
+     Intel(R) PRO/1000 Gigabit Server Adapter
+     Intel(R) PRO/1000 PM Network Connection
+
+  - Using Jumbo Frames at 10 or 100 Mbps may result in poor performance or
+    loss of link.
+
+  - The following adapters do not support Jumbo Frames:
+    Intel(R) 82562V 10/100 Network Connection
+    Intel(R) 82566DM Gigabit Network Connection
+    Intel(R) 82566DC Gigabit Network Connection
+    Intel(R) 82566MM Gigabit Network Connection
+    Intel(R) 82566MC Gigabit Network Connection
+    Intel(R) 82562GT 10/100 Network Connection
+    Intel(R) 82562G 10/100 Network Connection
+    Intel(R) 82566DC-2 Gigabit Network Connection
+    Intel(R) 82562V-2 10/100 Network Connection
+    Intel(R) 82562G-2 10/100 Network Connection
+    Intel(R) 82562GT-2 10/100 Network Connection
+
+  VLANs
+  -----
+  To create a new VLAN interface:
+
+        ifconfig &lt;vlan_name&gt; create
+
+  To associate the VLAN interface with a physical interface and
+  assign a VLAN ID, IP address, and netmask:
+
+        ifconfig &lt;vlan_name&gt; &lt;ip_address&gt; netmask &lt;subnet_mask&gt; vlan
+           &lt;vlan_id&gt; vlandev &lt;physical_interface&gt;
+
+  Example:
+
+        ifconfig vlan10 10.0.0.1 netmask 255.255.255.0 vlan 10 vlandev em0
+
+  In this example, all packets will be marked on egress with 802.1Q VLAN
+  tags, specifying a VLAN ID of 10.
+
+  To remove a VLAN interface:
+
+  Intel Network Connection        ifconfig &lt;vlan_name&gt; destroy
+
+
+  Polling
+  -------
+
+  To enable polling in the driver, add the following options to the kernel
+  configuration, and then recompile the kernel:
+
+        options DEVICE_POLLING
+        options HZ=1000
+
+  At runtime use:
+        ifconfig emX polling (to turn polling on)
+  and:
+        ifconfig emX -polling  (to turn it off)
+
+
+  Checksum Offload
+  ----------------
+  Checksum offloading is not supported on 82542 Gigabit adapters.
+
+  Checksum offloading supports both TCP and UDP packets and is
+  supported for both transmit and receive.
+
+  Checksum offloading can be enabled or disabled using ifconfig.
+  Both transmit and receive offloading will be either enabled or
+  disabled together. You cannot enable/disable one without the other.
+
+  To enable checksum offloading:
+
+         ifconfig &lt;interface_num&gt; rxcsum
+
+  To disable checksum offloading:
+
+         ifconfig &lt;interface_num&gt; -rxcsum
+
+  To confirm the current setting:
+
+         ifconfig &lt;interface_num&gt;
+
+  Look for the presence or absence of the following line:
+
+         options=3 &lt;RXCSUM,TXCSUM&gt;
+
+  See the ifconfig man page for further information.
+
+
+  TSO
+  ---
+  The FreeBSD driver offers support for TSO (TCP Segmentation Offload).
+
+  You can enable/disable it in two ways/places:
+
+        -  sysctl net.inet.tcp.tso=0    (or 1 to enable it)
+
+  Doing this disables TSO in the stack and will affect all adapters.
+
+        -  ifconfig emX -tso
+
+  Doing this will disable TSO only for this adapter.
+
+  To enable:
+
+        -  ifconfig emX tso
+
+  NOTES: By default only PCI-Express adapters are ENABLED to do TSO. Others
+  can be enabled by the user at their own risk
+  TSO is not supported on 82547 and 82544-based adapters, as well as older adapters.
+
+
+Known Limitations
+=================
+
+  Detected Tx Unit Hang in Quad Port Adapters
+  -------------------------------------------
+
+  In some cases ports 3 and 4 wont pass traffic. Ports 1 and 2 don't show
+  any errors and will pass traffic.
+
+  This issue MAY be resolved by updating to the latest BIOS. You can
+  check your system's BIOS by downloading the Linux Firmware Developer Kit
+  that can be obtained at <A HREF="http://www.linuxfirmwarekit.org/">http://www.linuxfirmwarekit.org/</A>
+
+
+  There are known performance issues with this driver when running UDP traffic
+  with Jumbo Frames.
+  ----------------------------------------------------------------------------
+
+  82541/82547 can't link or is slow to link with some link partners
+  -----------------------------------------------------------------
+
+  There is a known compatibility issue where time to link is slow or link is not
+  established between 82541/82547 controllers and some switches.  Known switches
+  include:
+        Planex FXG-08TE
+        I-O Data ETG-SH8
+
+  The driver can be compiled with the following changes:
+
+  Edit ./em.x.x.x/src/if_em.h to change the #define EM_MASTER_SLAVE
+  For example, change from:
+
+      #define EM_MASTER_SLAVE   e1000_ms_hw_default
+  to:
+      #define EM_MASTER_SLAVE   2
+
+  Use one of the following options:
+      1 = Master mode
+      2 = Slave mode
+      3 = Auto master/slave
+  Setting 2 is recommended.
+
+  Recompile the module:
+          a. To compile the module
+                cd em-x.x.x
+                make clean
+                make
+
+   b. To install the compiled module in system directory:
+                make install
+
+
+Support
+=======
+
+For general information and support, go to the Intel support website at:
+
+        <A HREF="http://support.intel.com">http://support.intel.com</A>
+
+If an issue is identified, support is through email only at:
<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">+freebsdnic at mailbox.intel.com</A>
+
+
+License
+=======
+
+This software program is released under the terms of a license agreement
+between you ('Licensee') and Intel. Do not use or load this software or any
+associated materials (collectively, the 'Software') until you have carefully
+read the full terms and conditions of the LICENSE located in this software
+package. By loading or using the Software, you agree to the terms of this
+Agreement. If you do not agree with the terms of this Agreement, do not
+install or use the Software.
+
+* Other names and brands may be claimed as the property of others.

Added: haiku/vendor/freebsd/current/dev/em/e1000_80003es2lan.c
===================================================================
--- haiku/vendor/freebsd/current/dev/em/e1000_80003es2lan.c	2007-12-01 15:27:56 UTC (rev 23040)
+++ haiku/vendor/freebsd/current/dev/em/e1000_80003es2lan.c	2007-12-01 15:38:33 UTC (rev 23041)
@@ -0,0 +1,1339 @@
+/*******************************************************************************
+
+  Copyright (c) 2001-2007, Intel Corporation 
+  All rights reserved.
+  
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions are met:
+  
+   1. Redistributions of source code must retain the above copyright notice, 
+      this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in the 
+      documentation and/or other materials provided with the distribution.
+  
+   3. Neither the name of the Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived from 
+      this software without specific prior written permission.
+  
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+/*$FreeBSD: src/sys/dev/em/e1000_80003es2lan.c,v 1.3 2007/05/16 00:14:23 jfv Exp $*/
+
+/* e1000_80003es2lan
+ */
+
+#include &quot;e1000_api.h&quot;
+#include &quot;e1000_80003es2lan.h&quot;
+
+void e1000_init_function_pointers_80003es2lan(struct e1000_hw *hw);
+
+STATIC s32  e1000_init_phy_params_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_init_nvm_params_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_init_mac_params_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_acquire_phy_80003es2lan(struct e1000_hw *hw);
+STATIC void e1000_release_phy_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_acquire_nvm_80003es2lan(struct e1000_hw *hw);
+STATIC void e1000_release_nvm_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_read_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,
+                                                   u32 offset,
+                                                   u16 *data);
+STATIC s32  e1000_write_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw,
+                                                    u32 offset,
+                                                    u16 data);
+STATIC s32  e1000_write_nvm_80003es2lan(struct e1000_hw *hw, u16 offset,
+                                        u16 words, u16 *data);
+STATIC s32  e1000_get_cfg_done_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_phy_force_speed_duplex_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_get_cable_length_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_get_link_up_info_80003es2lan(struct e1000_hw *hw, u16 *speed,
+                                               u16 *duplex);
+STATIC s32  e1000_reset_hw_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_init_hw_80003es2lan(struct e1000_hw *hw);
+STATIC s32  e1000_setup_copper_link_80003es2lan(struct e1000_hw *hw);
+STATIC void e1000_clear_hw_cntrs_80003es2lan(struct e1000_hw *hw);
+static s32  e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask);
+static s32  e1000_cfg_kmrn_10_100_80003es2lan(struct e1000_hw *hw, u16 duplex);
+static s32  e1000_cfg_kmrn_1000_80003es2lan(struct e1000_hw *hw);
+static s32  e1000_copper_link_setup_gg82563_80003es2lan(struct e1000_hw *hw);
+static void e1000_initialize_hw_bits_80003es2lan(struct e1000_hw *hw);
+static void e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask);
+
+/* A table for the GG82563 cable length where the range is defined
+ * with a lower bound at &quot;index&quot; and the upper bound at
+ * &quot;index + 5&quot;.
+ */
+static const
+u16 e1000_gg82563_cable_length_table[] =
+         { 0, 60, 115, 150, 150, 60, 115, 150, 180, 180, 0xFF };
+#define GG82563_CABLE_LENGTH_TABLE_SIZE \
+                (sizeof(e1000_gg82563_cable_length_table) / \
+                 sizeof(e1000_gg82563_cable_length_table[0]))
+
+/**
+ *  e1000_init_phy_params_80003es2lan - Init ESB2 PHY func ptrs.
+ *  @hw: pointer to the HW structure
+ *
+ *  This is a function pointer entry point called by the api module.
+ **/
+STATIC s32
+e1000_init_phy_params_80003es2lan(struct e1000_hw *hw)
+{
+	struct e1000_phy_info *phy = &amp;hw-&gt;phy;
+	struct e1000_functions *func = &amp;hw-&gt;func;
+	s32 ret_val = E1000_SUCCESS;
+
+	DEBUGFUNC(&quot;e1000_init_phy_params_80003es2lan&quot;);
+
+	if (hw-&gt;media_type != e1000_media_type_copper) {
+		phy-&gt;type        = e1000_phy_none;
+		goto out;
+	}
+
+	phy-&gt;addr                = 1;
+	phy-&gt;autoneg_mask        = AUTONEG_ADVERTISE_SPEED_DEFAULT;
+	phy-&gt;reset_delay_us      = 100;
+	phy-&gt;type                = e1000_phy_gg82563;
+
+	func-&gt;acquire_phy        = e1000_acquire_phy_80003es2lan;
+	func-&gt;check_polarity     = e1000_check_polarity_m88;
+	func-&gt;check_reset_block  = e1000_check_reset_block_generic;
+	func-&gt;commit_phy         = e1000_phy_sw_reset_generic;
+	func-&gt;get_cfg_done       = e1000_get_cfg_done_80003es2lan;
+	func-&gt;get_phy_info       = e1000_get_phy_info_m88;
+	func-&gt;release_phy        = e1000_release_phy_80003es2lan;
+	func-&gt;reset_phy          = e1000_phy_hw_reset_generic;
+	func-&gt;set_d3_lplu_state  = e1000_set_d3_lplu_state_generic;
+
+	func-&gt;force_speed_duplex = e1000_phy_force_speed_duplex_80003es2lan;
+	func-&gt;get_cable_length   = e1000_get_cable_length_80003es2lan;
+	func-&gt;read_phy_reg       = e1000_read_phy_reg_gg82563_80003es2lan;
+	func-&gt;write_phy_reg      = e1000_write_phy_reg_gg82563_80003es2lan;
+
+	/* This can only be done after all function pointers are setup. */
+	ret_val = e1000_get_phy_id(hw);
+
+	/* Verify phy id */
+	if (phy-&gt;id != GG82563_E_PHY_ID) {
+		ret_val = -E1000_ERR_PHY;
+		goto out;
+	}
+
+out:
+	return ret_val;
+}
+
+/**
+ *  e1000_init_nvm_params_80003es2lan - Init ESB2 NVM func ptrs.
+ *  @hw: pointer to the HW structure
+ *
+ *  This is a function pointer entry point called by the api module.
+ **/
+STATIC s32
+e1000_init_nvm_params_80003es2lan(struct e1000_hw *hw)
+{
+	struct e1000_nvm_info *nvm = &amp;hw-&gt;nvm;
+	struct e1000_functions *func = &amp;hw-&gt;func;
+	u32 eecd = E1000_READ_REG(hw, E1000_EECD);
+	u16 size;
+
+	DEBUGFUNC(&quot;e1000_init_nvm_params_80003es2lan&quot;);
+
+	nvm-&gt;opcode_bits        = 8;
+	nvm-&gt;delay_usec         = 1;
+	switch (nvm-&gt;override) {
+	case e1000_nvm_override_spi_large:
+		nvm-&gt;page_size    = 32;
+		nvm-&gt;address_bits = 16;
+		break;
+	case e1000_nvm_override_spi_small:
+		nvm-&gt;page_size    = 8;
+		nvm-&gt;address_bits = 8;
+		break;
+	default:
+		nvm-&gt;page_size    = eecd &amp; E1000_EECD_ADDR_BITS ? 32 : 8;
+		nvm-&gt;address_bits = eecd &amp; E1000_EECD_ADDR_BITS ? 16 : 8;
+		break;
+	}
+
+	nvm-&gt;type               = e1000_nvm_eeprom_spi;
+
+	size = (u16)((eecd &amp; E1000_EECD_SIZE_EX_MASK) &gt;&gt;
+	                  E1000_EECD_SIZE_EX_SHIFT);
+
+	/* Added to a constant, &quot;size&quot; becomes the left-shift value
+	 * for setting word_size.
+	 */
+	size += NVM_WORD_SIZE_BASE_SHIFT;
+	nvm-&gt;word_size	= 1 &lt;&lt; size;
+
+	/* Function Pointers */
+	func-&gt;acquire_nvm       = e1000_acquire_nvm_80003es2lan;
+	func-&gt;read_nvm          = e1000_read_nvm_eerd;
+	func-&gt;release_nvm       = e1000_release_nvm_80003es2lan;
+	func-&gt;update_nvm        = e1000_update_nvm_checksum_generic;
+	func-&gt;valid_led_default = e1000_valid_led_default_generic;
+	func-&gt;validate_nvm      = e1000_validate_nvm_checksum_generic;
+	func-&gt;write_nvm         = e1000_write_nvm_80003es2lan;
+
+	return E1000_SUCCESS;
+}
+
+/**
+ *  e1000_init_mac_params_80003es2lan - Init ESB2 MAC func ptrs.
+ *  @hw: pointer to the HW structure
+ *
+ *  This is a function pointer entry point called by the api module.
+ **/
+STATIC s32
+e1000_init_mac_params_80003es2lan(struct e1000_hw *hw)
+{
+	struct e1000_mac_info *mac = &amp;hw-&gt;mac;
+	struct e1000_functions *func = &amp;hw-&gt;func;
+	s32 ret_val = E1000_SUCCESS;
+
+	DEBUGFUNC(&quot;e1000_init_mac_params_80003es2lan&quot;);
+
+	/* Set media type */
+	switch (hw-&gt;device_id) {
+	case E1000_DEV_ID_80003ES2LAN_SERDES_DPT:
+		hw-&gt;media_type = e1000_media_type_internal_serdes;
+		break;
+	default:
+		hw-&gt;media_type = e1000_media_type_copper;
+		break;
+	}
+
+	/* Set mta register count */
+	mac-&gt;mta_reg_count = 128;
+	/* Set rar entry count */
+	mac-&gt;rar_entry_count = E1000_RAR_ENTRIES;
+	/* Set if part includes ASF firmware */
+	mac-&gt;asf_firmware_present = TRUE;
+	/* Set if manageability features are enabled. */
+	mac-&gt;arc_subsystem_valid =
+	        (E1000_READ_REG(hw, E1000_FWSM) &amp; E1000_FWSM_MODE_MASK)
+	                ? TRUE : FALSE;
+
+	/* Function pointers */
+
+	/* bus type/speed/width */
+	func-&gt;get_bus_info = e1000_get_bus_info_pcie_generic;
+	/* reset */
+	func-&gt;reset_hw = e1000_reset_hw_80003es2lan;
+	/* hw initialization */
+	func-&gt;init_hw = e1000_init_hw_80003es2lan;
+	/* link setup */
+	func-&gt;setup_link = e1000_setup_link_generic;
+	/* physical interface link setup */
+	func-&gt;setup_physical_interface =
+	        (hw-&gt;media_type == e1000_media_type_copper)
+	                ? e1000_setup_copper_link_80003es2lan
+	                : e1000_setup_fiber_serdes_link_generic;
+	/* check for link */
+	switch (hw-&gt;media_type) {
+	case e1000_media_type_copper:
+		func-&gt;check_for_link = e1000_check_for_copper_link_generic;
+		break;
+	case e1000_media_type_fiber:
+		func-&gt;check_for_link = e1000_check_for_fiber_link_generic;
+		break;
+	case e1000_media_type_internal_serdes:
+		func-&gt;check_for_link = e1000_check_for_serdes_link_generic;
+		break;
+	default:
+		ret_val = -E1000_ERR_CONFIG;
+		goto out;
+		break;
+	}
+	/* check management mode */
+	func-&gt;check_mng_mode = e1000_check_mng_mode_generic;
+	/* multicast address update */
+	func-&gt;mc_addr_list_update = e1000_mc_addr_list_update_generic;
+	/* writing VFTA */
+	func-&gt;write_vfta = e1000_write_vfta_generic;
+	/* clearing VFTA */
+	func-&gt;clear_vfta = e1000_clear_vfta_generic;
+	/* setting MTA */
+	func-&gt;mta_set = e1000_mta_set_generic;
+	/* blink LED */
+	func-&gt;blink_led = e1000_blink_led_generic;
+	/* setup LED */
+	func-&gt;setup_led = e1000_setup_led_generic;
+	/* cleanup LED */
+	func-&gt;cleanup_led = e1000_cleanup_led_generic;
+	/* turn on/off LED */
+	func-&gt;led_on = e1000_led_on_generic;
+	func-&gt;led_off = e1000_led_off_generic;
+	/* remove device */
+	func-&gt;remove_device = e1000_remove_device_generic;
+	/* clear hardware counters */
+	func-&gt;clear_hw_cntrs = e1000_clear_hw_cntrs_80003es2lan;
+	/* link info */
+	func-&gt;get_link_up_info = e1000_get_link_up_info_80003es2lan;
+
+out:
+	return ret_val;
+}
+
+/**
+ *  e1000_init_function_pointers_80003es2lan - Init ESB2 func ptrs.
+ *  @hw: pointer to the HW structure
+ *
+ *  The only function explicitly called by the api module to initialize
+ *  all function pointers and parameters.
+ **/
+void
+e1000_init_function_pointers_80003es2lan(struct e1000_hw *hw)
+{
+	DEBUGFUNC(&quot;e1000_init_function_pointers_80003es2lan&quot;);
+
+	hw-&gt;func.init_mac_params = e1000_init_mac_params_80003es2lan;
+	hw-&gt;func.init_nvm_params = e1000_init_nvm_params_80003es2lan;
+	hw-&gt;func.init_phy_params = e1000_init_phy_params_80003es2lan;
+}
+
+/**
+ *  e1000_acquire_phy_80003es2lan - Acquire rights to access PHY
+ *  @hw: pointer to the HW structure
+ *
+ *  A wrapper to acquire access rights to the correct PHY.  This is a
+ *  function pointer entry point called by the api module.
+ **/
+STATIC s32
+e1000_acquire_phy_80003es2lan(struct e1000_hw *hw)
+{
+	u16 mask;
+
+	DEBUGFUNC(&quot;e1000_acquire_phy_80003es2lan&quot;);
+
+	mask = hw-&gt;bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;
+
+	return e1000_acquire_swfw_sync_80003es2lan(hw, mask);
+}
+
+/**
+ *  e1000_release_phy_80003es2lan - Release rights to access PHY
+ *  @hw: pointer to the HW structure
+ *
+ *  A wrapper to release access rights to the correct PHY.  This is a
+ *  function pointer entry point called by the api module.
+ **/
+STATIC void
+e1000_release_phy_80003es2lan(struct e1000_hw *hw)
+{
+	u16 mask;
+
+	DEBUGFUNC(&quot;e1000_release_phy_80003es2lan&quot;);
+
+	mask = hw-&gt;bus.func ? E1000_SWFW_PHY1_SM : E1000_SWFW_PHY0_SM;
+	e1000_release_swfw_sync_80003es2lan(hw, mask);
+}
+
+/**
+ *  e1000_acquire_nvm_80003es2lan - Acquire rights to access NVM
+ *  @hw: pointer to the HW structure
+ *
+ *  Acquire the semaphore to access the EEPROM.  This is a function
+ *  pointer entry point called by the api module.
+ **/
+STATIC s32
+e1000_acquire_nvm_80003es2lan(struct e1000_hw *hw)
+{
+	s32 ret_val;
+
+	DEBUGFUNC(&quot;e1000_acquire_nvm_80003es2lan&quot;);
+
+	ret_val = e1000_acquire_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);
+	if (ret_val)
+		goto out;
+
+	ret_val = e1000_acquire_nvm_generic(hw);
+
+	if (ret_val)
+		e1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);
+
+out:
+	return ret_val;
+}
+
+/**
+ *  e1000_release_nvm_80003es2lan - Relinquish rights to access NVM
+ *  @hw: pointer to the HW structure
+ *
+ *  Release the semaphore used to access the EEPROM.  This is a
+ *  function pointer entry point called by the api module.
+ **/
+STATIC void
+e1000_release_nvm_80003es2lan(struct e1000_hw *hw)
+{
+	DEBUGFUNC(&quot;e1000_release_nvm_80003es2lan&quot;);
+
+	e1000_release_nvm_generic(hw);
+	e1000_release_swfw_sync_80003es2lan(hw, E1000_SWFW_EEP_SM);
+}
+
+/**
+ *  e1000_acquire_swfw_sync_80003es2lan - Acquire SW/FW semaphore
+ *  @hw: pointer to the HW structure
+ *  @mask: specifies which semaphore to acquire
+ *
+ *  Acquire the SW/FW semaphore to access the PHY or NVM.  The mask
+ *  will also specify which port we're acquiring the lock for.
+ **/
+static s32
+e1000_acquire_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)
+{
+	u32 swfw_sync;
+	u32 swmask = mask;
+	u32 fwmask = mask &lt;&lt; 16;
+	s32 ret_val = E1000_SUCCESS;
+	s32 i = 0, timeout = 200;
+
+	DEBUGFUNC(&quot;e1000_acquire_swfw_sync_80003es2lan&quot;);
+
+	while (i &lt; timeout) {
+		if (e1000_get_hw_semaphore_generic(hw)) {
+			ret_val = -E1000_ERR_SWFW_SYNC;
+			goto out;
+		}
+
+		swfw_sync = E1000_READ_REG(hw, E1000_SW_FW_SYNC);
+		if (!(swfw_sync &amp; (fwmask | swmask)))
+			break;
+
+		/* Firmware currently using resource (fwmask)
+		 * or other software thread using resource (swmask) */
+		e1000_put_hw_semaphore_generic(hw);
+		msec_delay_irq(5);
+		i++;
+	}
+
+	if (i == timeout) {
+		DEBUGOUT(&quot;Driver can't access resource, SW_FW_SYNC timeout.\n&quot;);
+		ret_val = -E1000_ERR_SWFW_SYNC;
+		goto out;
+	}
+
+	swfw_sync |= swmask;
+	E1000_WRITE_REG(hw, E1000_SW_FW_SYNC, swfw_sync);
+
+	e1000_put_hw_semaphore_generic(hw);
+
+out:
+	return ret_val;
+}
+
+/**
+ *  e1000_release_swfw_sync_80003es2lan - Release SW/FW semaphore
+ *  @hw: pointer to the HW structure
+ *  @mask: specifies which semaphore to acquire
+ *
+ *  Release the SW/FW semaphore used to access the PHY or NVM.  The mask
+ *  will also specify which port we're releasing the lock for.
+ **/
+static void
+e1000_release_swfw_sync_80003es2lan(struct e1000_hw *hw, u16 mask)
+{
+	u32 swfw_sync;
+
+	DEBUGFUNC(&quot;e1000_release_swfw_sync_80003es2lan&quot;);
+
+	while (e1000_get_hw_semaphore_generic(hw) != E1000_SUCCESS);
+	/* Empty */
+
+	swfw_sync = E1000_READ_REG(hw, E1000_SW_FW_SYNC);
+	swfw_sync &amp;= ~mask;
+	E1000_WRITE_REG(hw, E1000_SW_FW_SYNC, swfw_sync);
+
+	e1000_put_hw_semaphore_generic(hw);
+}
+
+/**
+ *  e1000_read_phy_reg_gg82563_80003es2lan - Read GG82563 PHY register
+ *  @hw: pointer to the HW structure
+ *  @offset: offset of the register to read
+ *  @data: pointer to the data returned from the operation
+ *
+ *  Read the GG82563 PHY register.  This is a function pointer entry
+ *  point called by the api module.
+ **/
+STATIC s32
+e1000_read_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw, u32 offset,
+                                       u16 *data)
+{
+	s32 ret_val;
+	u32 page_select;
+	u16 temp;
+
+	DEBUGFUNC(&quot;e1000_read_phy_reg_gg82563_80003es2lan&quot;);
+
+	/* Select Configuration Page */
+	if ((offset &amp; MAX_PHY_REG_ADDRESS) &lt; GG82563_MIN_ALT_REG)
+		page_select = GG82563_PHY_PAGE_SELECT;
+	else {
+		/* Use Alternative Page Select register to access
+		 * registers 30 and 31
+		 */
+		page_select = GG82563_PHY_PAGE_SELECT_ALT;
+	}
+
+	temp = (u16)((u16)offset &gt;&gt; GG82563_PAGE_SHIFT);
+	ret_val = e1000_write_phy_reg_m88(hw, page_select, temp);
+	if (ret_val)
+		goto out;
+
+	/* The &quot;ready&quot; bit in the MDIC register may be incorrectly set
+	 * before the device has completed the &quot;Page Select&quot; MDI
+	 * transaction.  So we wait 200us after each MDI command...
+	 */
+	usec_delay(200);
+
+	/* ...and verify the command was successful. */
+	ret_val = e1000_read_phy_reg_m88(hw, page_select, &amp;temp);
+
+	if (((u16)offset &gt;&gt; GG82563_PAGE_SHIFT) != temp) {
+		ret_val = -E1000_ERR_PHY;
+		goto out;
+	}
+
+	usec_delay(200);
+
+	ret_val = e1000_read_phy_reg_m88(hw,
+	                                 MAX_PHY_REG_ADDRESS &amp; offset,
+	                                 data);
+
+	usec_delay(200);
+
+out:
+	return ret_val;
+}
+
+/**
+ *  e1000_write_phy_reg_gg82563_80003es2lan - Write GG82563 PHY register
+ *  @hw: pointer to the HW structure
+ *  @offset: offset of the register to read
+ *  @data: value to write to the register
+ *
+ *  Write to the GG82563 PHY register.  This is a function pointer entry
+ *  point called by the api module.
+ **/
+STATIC s32
+e1000_write_phy_reg_gg82563_80003es2lan(struct e1000_hw *hw, u32 offset,
+                                        u16 data)
+{
+	s32 ret_val;
+	u32 page_select;
+	u16 temp;
+
+	DEBUGFUNC(&quot;e1000_write_phy_reg_gg82563_80003es2lan&quot;);
+
+	/* Select Configuration Page */
+	if ((offset &amp; MAX_PHY_REG_ADDRESS) &lt; GG82563_MIN_ALT_REG)
+		page_select = GG82563_PHY_PAGE_SELECT;
+	else {
+		/* Use Alternative Page Select register to access

[... truncated: 50312 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004916.html">[Haiku-commits] r23040 - haiku/vendor
</A></li>
	<LI>Next message: <A HREF="004918.html">[Haiku-commits] r23042 - haiku/vendor/freebsd
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4917">[ date ]</a>
              <a href="thread.html#4917">[ thread ]</a>
              <a href="subject.html#4917">[ subject ]</a>
              <a href="author.html#4917">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
