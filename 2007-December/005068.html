<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23144 - in haiku/trunk/src/apps: . bsnow
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23144%20-%20in%20haiku/trunk/src/apps%3A%20.%20bsnow&In-Reply-To=%3C200712202329.lBKNT9UY015637%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005067.html">
   <LINK REL="Next"  HREF="005069.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23144 - in haiku/trunk/src/apps: . bsnow</H1>
    <B>mmu_man at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23144%20-%20in%20haiku/trunk/src/apps%3A%20.%20bsnow&In-Reply-To=%3C200712202329.lBKNT9UY015637%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23144 - in haiku/trunk/src/apps: . bsnow">mmu_man at mail.berlios.de
       </A><BR>
    <I>Fri Dec 21 00:29:09 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="005067.html">[Haiku-commits] r23143 -	haiku/trunk/src/add-ons/kernel/generic/ide_adapter
</A></li>
        <LI>Next message: <A HREF="005069.html">[Haiku-commits] r23145 - haiku/trunk/src/apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5068">[ date ]</a>
              <a href="thread.html#5068">[ thread ]</a>
              <a href="subject.html#5068">[ subject ]</a>
              <a href="author.html#5068">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmu_man
Date: 2007-12-21 00:29:09 +0100 (Fri, 21 Dec 2007)
New Revision: 23144
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23144&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23144&amp;view=rev</A>

Added:
   haiku/trunk/src/apps/bsnow/
   haiku/trunk/src/apps/bsnow/BSnow.rdef
   haiku/trunk/src/apps/bsnow/Flakes.cpp
   haiku/trunk/src/apps/bsnow/Flakes.h
   haiku/trunk/src/apps/bsnow/Jamfile
   haiku/trunk/src/apps/bsnow/README.html
   haiku/trunk/src/apps/bsnow/SnowApp.cpp
   haiku/trunk/src/apps/bsnow/SnowView.cpp
   haiku/trunk/src/apps/bsnow/SnowView.h
   haiku/trunk/src/apps/bsnow/makefile
Log:
A small demo app I wrote that is quite appropriate for the season :)


Added: haiku/trunk/src/apps/bsnow/BSnow.rdef
===================================================================
--- haiku/trunk/src/apps/bsnow/BSnow.rdef	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/BSnow.rdef	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,91 @@
+/*
+** BSnow.rdef
+**
+** Automatically generated by BResourceParser on
+** Friday, December 21, 2007 at 00:15:36.
+**
+*/
+
+resource(1, &quot;BEOS:APP_FLAGS&quot;) (#'APPF') $&quot;00000000&quot;;
+
+resource(1, &quot;BEOS:APP_VERSION&quot;) #'APPV' array {
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000000000000000000000000000000000000000000000000000&quot;
+	$&quot;0000000000000000&quot;
+};
+
+resource(101, &quot;BEOS:L:STD_ICON&quot;) #'ICON' array {
+	$&quot;FFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFF3FFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFF3F3F3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFFFFFF&quot;
+	$&quot;FFFF3FFF3FFF3FFFFFFFFFFFFFFFFF3FFF3FFFFFFFFFFFFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3F3F3FFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFF3FFFFFFFFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFFFF3FFFFFFF&quot;
+	$&quot;FFFFFFFFFF3FFF3FFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFFFFFFFF3F3F3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFF3FFF3FFF3FFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFF3FFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFF0000FFFF0000FFFFFF00FFFF00FFFFFF00FFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFF00FF00FF00FF00FF00FF00FF00FF00FFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFF0000FFFF00FF00FFFF00FFFFFF00FF00FFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFF3FFFFFFFFFFFFF3FFF3FFF3FFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFFFFFFFFFF3F3F3FFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF3FFF3FFF3FFFFFFFFFFFFF3F&quot;
+	$&quot;FFFFFFFF3F3F3F3F3F3F3F3F3F3F3FFFFFFFFFFFFFFF3FFFFFFFFFFFFF3F3F3F&quot;
+	$&quot;FFFF3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3FFFFFFFFFFFFFFF3F3F3F3F3F&quot;
+	$&quot;FF3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F&quot;
+	$&quot;3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F&quot;
+};
+
+resource(101, &quot;BEOS:M:STD_ICON&quot;) #'MICN' array {
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFFFF3FFFFFFFFFFFFFFF3FFFFFFF&quot;
+	$&quot;FFFF3FFF3FFF3FFFFFFFFF3FFF3FFFFF&quot;
+	$&quot;FFFFFF3F3F3FFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFF3FFF3FFF3FFFFF3FFF3FFFFFFFFF&quot;
+	$&quot;FFFFFFFF3FFFFFFFFFFF3FFFFFFFFFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFF3FFF3FFFFFFFFF&quot;
+	$&quot;FFFF0000FFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FF0000FFFFFFFFFFFFFFFFFFFFFFFFFF&quot;
+	$&quot;FFFF0000FF0013FF0000FF001313FFFF&quot;
+	$&quot;FF0000FFFF0000FF0000FFFF0000FFFF&quot;
+	$&quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFF3F3F&quot;
+	$&quot;FFFF3F3F3F3F3F3F3F3F3FFFFF3F3F3F&quot;
+	$&quot;FF3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F&quot;
+	$&quot;3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F3F&quot;
+};
+
+resource(1, &quot;BEOS:APP_SIG&quot;) (#'MIMS') &quot;application/x-vnd.mmu_man.BSnow&quot;;
+

Added: haiku/trunk/src/apps/bsnow/Flakes.cpp
===================================================================
--- haiku/trunk/src/apps/bsnow/Flakes.cpp	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/Flakes.cpp	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,40 @@
+#include &quot;Flakes.h&quot;
+
+#define TRAN 0xFF
+#define WHIT 0x3F
+
+const char gFlakeBits[NUM_PATTERNS][64] = {
+{
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, WHIT, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN 
+},
+{
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, WHIT, TRAN, TRAN, TRAN, TRAN, 
+TRAN, WHIT, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, 
+TRAN, TRAN, WHIT, WHIT, WHIT, TRAN, TRAN, TRAN, 
+TRAN, WHIT, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, 
+TRAN, TRAN, TRAN, WHIT, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN 
+}
+/*
+{
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, WHIT, TRAN, TRAN, TRAN, WHIT, TRAN, TRAN, 
+TRAN, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, TRAN, 
+TRAN, WHIT, WHIT, WHIT, WHIT, WHIT, TRAN, TRAN, 
+TRAN, TRAN, WHIT, TRAN, WHIT, TRAN, TRAN, TRAN, 
+TRAN, WHIT, TRAN, TRAN, TRAN, WHIT, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, 
+TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN, TRAN 
+}
+*/
+};
+

Added: haiku/trunk/src/apps/bsnow/Flakes.h
===================================================================
--- haiku/trunk/src/apps/bsnow/Flakes.h	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/Flakes.h	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,12 @@
+#ifndef _FLAKES_H
+#define _FLAKES_H
+#include &lt;GraphicsDefs.h&gt;
+
+#define NUM_PATTERNS 2
+
+#define PAT_HOTSPOT 3,3
+
+extern const char gFlakeBits[NUM_PATTERNS][64];
+
+
+#endif

Added: haiku/trunk/src/apps/bsnow/Jamfile
===================================================================
--- haiku/trunk/src/apps/bsnow/Jamfile	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/Jamfile	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,11 @@
+SubDir HAIKU_TOP src apps bsnow ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+Application BSnow :
+	Flakes.cpp
+	SnowView.cpp
+	SnowApp.cpp
+	: be
+	: BSnow.rdef
+	;

Added: haiku/trunk/src/apps/bsnow/README.html
===================================================================
--- haiku/trunk/src/apps/bsnow/README.html	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/README.html	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,38 @@
+&lt;html lang=&quot;en-US&quot;&gt;
+&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
+&lt;head&gt;
+&lt;title&gt;BSnow - winter weather for BeOS&lt;/title&gt;
+&lt;/head&gt;
+&lt;body bgcolor=&quot;#52F6F4&quot; text=&quot;#000000&quot;&gt;
+&lt;font size=+3 color=&quot;#ffffff&quot;&gt;
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&lt;br&gt;
+&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+&lt;nobr&gt;BSnow&nbsp;-&nbsp;winter&nbsp;weather&nbsp;for&nbsp;&lt;font color=&quot;#0000ff&quot;&gt;B&lt;/font&gt;&lt;font color=&quot;#ff0000&quot;&gt;e&lt;/font&gt;OS,&lt;/nobr&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&lt;br&gt;
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&lt;br&gt;
+
+&lt;/font&gt;
+&lt;br&gt;
+&lt;br&gt;
+&lt;br&gt;
+&lt;br&gt;
+
+&copy; 2003 &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">revol at free.fr</A>&quot;&gt;Fran&ccedil;ois Revol&lt;/a&gt;.
+&lt;br&gt;
+&lt;br&gt;
+Features:
+&lt;ul&gt;
+&lt;li&gt; adapts the number of snow flakes to the CPU frequency to avoid hogging it,
+&lt;li&gt; random wind change,
+&lt;li&gt; the fallen snow accumulates on the windows and bottom of the screen,
+&lt;/ul&gt;
+&lt;br&gt;
+&lt;br&gt;
+Limitations:
+&lt;ul&gt;
+&lt;li&gt; lot of flicker,
+&lt;li&gt; it needs to set the desktop view flags to B_DRAW_ON_CHILDREN, which might gives weird drawing with some replicants afterwards,
+&lt;/ul&gt;
+&lt;br&gt;
+Sources released under the MIT licence.
+&lt;/body&gt;
+&lt;/html&gt;

Added: haiku/trunk/src/apps/bsnow/SnowApp.cpp
===================================================================
--- haiku/trunk/src/apps/bsnow/SnowApp.cpp	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/SnowApp.cpp	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,23 @@
+#include &lt;Application.h&gt;
+#include &lt;Dragger.h&gt;
+#include &lt;Window.h&gt;
+#include &quot;SnowView.h&quot;
+
+int main(int argc, char **argv)
+{
+	BApplication app(APP_SIG);
+	BWindow *win;
+	bool draggersShown = BDragger::AreDraggersDrawn();
+	win = new BWindow(BRect(SNOW_VIEW_RECT), &quot;BSnow&quot;, B_TITLED_WINDOW, B_QUIT_ON_WINDOW_CLOSE|B_NOT_RESIZABLE);
+	SnowView *view = new SnowView();
+	win-&gt;AddChild(view);
+	win-&gt;MoveTo(50, 50);
+	win-&gt;Show();
+	win-&gt;SetPulseRate(500000);
+	BDragger::ShowAllDraggers();
+	app.Run();
+	if (!draggersShown)
+		BDragger::HideAllDraggers();
+	return 0;
+}
+

Added: haiku/trunk/src/apps/bsnow/SnowView.cpp
===================================================================
--- haiku/trunk/src/apps/bsnow/SnowView.cpp	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/SnowView.cpp	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,618 @@
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;Alert.h&gt;
+#include &lt;Message.h&gt;
+#include &lt;MessageRunner.h&gt;
+#include &lt;OS.h&gt;
+#include &lt;Screen.h&gt;
+#include &quot;SnowView.h&quot;
+#include &quot;Flakes.h&quot;
+#include &lt;Region.h&gt;
+
+#include &lt;MessageFilter.h&gt;
+
+#define FORWARD_TO_PARENT
+
+SnowView::SnowView()
+ : BView(BRect(SNOW_VIEW_RECT), &quot;BSnow&quot;, B_FOLLOW_NONE, B_WILL_DRAW|B_PULSE_NEEDED)
+{
+	fAttached = false;
+	fMsgRunner = NULL;
+	fCachedParent = NULL;
+	fFallenBmp = NULL;
+	fFallenView = NULL;
+	fFallenReg = NULL;
+	fInvalidator = -1;
+	fShowClickMe = false;
+	for (int i = 0; i &lt; WORKSPACES_COUNT; i++)
+		fFlakes[i] = NULL;
+	for (int i = 0; i &lt; NUM_PATTERNS; i++)
+		fFlakeBitmaps[i] = NULL;
+	BRect r(Frame());
+	r.left = r.right - 7;
+	r.top = r.bottom - 7;
+	fDragger = new BDragger(r, this);
+	AddChild(fDragger);
+	SetHighColor(255,255,255);
+}
+/*
+filter_result msgfilter(BMessage *message, BHandler **target, BMessageFilter *filter)
+{
+	switch (message-&gt;what) {
+	case B_MOUSE_DOWN:
+	case B_MOUSE_UP:
+	case B_MOUSE_MOVED:
+	case '_EVP':
+	case '_UPD':
+	case '_PUL':
+	case 'NTCH':
+	case 'NMDN':
+		break;
+	default:
+		printf(&quot;For: 0x%08lx: %s\n&quot;, *target, (*target)-&gt;Name());
+		message-&gt;PrintToStream();
+	}
+	return B_DISPATCH_MESSAGE;
+}
+*/
+
+SnowView::SnowView(BMessage *archive)
+ : BView(archive)
+{
+	system_info si;
+	//printf(&quot;SnowView()\n&quot;);
+	//archive-&gt;PrintToStream();
+	fDragger = NULL;
+	fAttached = false;
+	fMsgRunner = NULL;
+	fFallenBmp = NULL;
+	fFallenView = NULL;
+	fFallenReg = NULL;
+	fCachedParent = NULL;
+	fShowClickMe = false;
+	SetFlags(Flags() &amp; ~B_PULSE_NEEDED); /* it's only used when in the app */
+	get_system_info(&amp;si);
+	fNumFlakes = ((int32)(si.cpu_clock_speed/1000000)) * si.cpu_count / 3; //;
+	printf(&quot;BSnow: using %d flakes\n&quot;, fNumFlakes);
+	for (int i = 0; i &lt; WORKSPACES_COUNT; i++) {
+		fFlakes[i] = new flake[fNumFlakes];
+		memset(fFlakes[i], 0, fNumFlakes * sizeof(flake));
+	}
+	for (int i = 0; i &lt; NUM_PATTERNS; i++) {
+		fFlakeBitmaps[i] = new BBitmap(BRect(0,0,7,7), B_CMAP8);
+		fFlakeBitmaps[i]-&gt;SetBits(gFlakeBits[i], 8*8, 0, B_CMAP8);
+	}
+	fCurrentWorkspace = 0;
+	SetHighColor(255,255,255);
+	SetDrawingMode(B_OP_OVER);
+}
+
+SnowView::~SnowView()
+{
+	for (int i = 0; i &lt; WORKSPACES_COUNT; i++)
+		if (fFlakes[i])
+			delete [] fFlakes[i];
+	if (fFallenBmp)
+		delete fFallenBmp; /* the view goes away with it */
+}
+
+BArchivable *SnowView::Instantiate(BMessage *data)
+{
+	return new SnowView(data);
+}
+
+status_t SnowView::Archive(BMessage *data, bool deep) const
+{
+	status_t err;
+	err = BView::Archive(data, deep);
+	if (err &lt; B_OK)
+		return err;
+	data-&gt;AddString(&quot;add_on&quot;, APP_SIG);
+	return B_OK;
+}
+
+void SnowView::AttachedToWindow()
+{
+	BView *p;
+	rgb_color col;
+	fAttached = true;
+/*	if (!fMsgRunner)
+		fMsgRunner = new BMessageRunner(BMessenger(this), 
+					new BMessage(MSG_PULSE_ME), 
+					INTERVAL);
+*/
+	p = Parent();
+	if (p)
+		col = B_TRANSPARENT_32_BIT;//Parent()-&gt;ViewColor();
+	else
+		col = ui_color(B_PANEL_BACKGROUND_COLOR);
+	SetViewColor(col);
+//	BScreen bs;
+//	fCachedWsWidth = bs.Frame().IntegerWidth();
+//	fCachedWsHeight = bs.Frame().IntegerHeight();
+	fDragger = dynamic_cast&lt;BDragger *&gt;(FindView(&quot;_dragger_&quot;));
+	if (fDragger &amp;&amp; p) {
+		fCachedParent = p;
+		fCachedWsWidth = p-&gt;Frame().IntegerWidth();
+		fCachedWsHeight = p-&gt;Frame().IntegerHeight();
+		fDragger-&gt;SetViewColor(col);
+		if (fDragger-&gt;InShelf()) {
+			p-&gt;SetFlags(p-&gt;Flags() | B_DRAW_ON_CHILDREN);
+			ResizeTo(p-&gt;Bounds().Width(), p-&gt;Bounds().Height());
+			MoveTo(0,0);
+			fDragger-&gt;MoveTo(p-&gt;Bounds().Width()-7, p-&gt;Bounds().Height()-7);
+		}
+		BRect fallenRect(p-&gt;Bounds());
+		fallenRect.top = fallenRect.bottom - FALLEN_HEIGHT;
+		fFallenBmp = new BBitmap(fallenRect, B_BITMAP_ACCEPTS_VIEWS, B_CMAP8);
+		memset(fFallenBmp-&gt;Bits(), B_TRANSPARENT_MAGIC_CMAP8, (size_t)(fallenRect.Height()*fFallenBmp-&gt;BytesPerRow()));
+		fFallenView = new BView(fallenRect, &quot;offscreen fallen snow&quot;, B_FOLLOW_NONE, 0);
+		fFallenBmp-&gt;AddChild(fFallenView);
+		fFallenReg = new BRegion;
+		fInvalidator = spawn_thread(SnowMakerThread, INVALIDATOR_THREAD_NAME, B_LOW_PRIORITY, (void *)this);
+		resume_thread(fInvalidator);
+		printf(&quot;BSnow: OK: ws = %ld x %ld\n&quot;, fCachedWsWidth, fCachedWsHeight);
+		//Window()-&gt;AddCommonFilter(new BMessageFilter(B_ANY_DELIVERY, B_ANY_SOURCE, msgfilter));
+	}
+}
+
+void SnowView::DetachedFromWindow()
+{
+	fAttached = false;
+/*
+	if (Parent()) {
+		Parent()-&gt;Invalidate(Parent()-&gt;Bounds());
+	}
+*/
+	if (fMsgRunner)
+		delete fMsgRunner;
+	fMsgRunner = NULL;
+	status_t err;
+	fCachedParent = NULL;
+	if (fInvalidator &gt; B_OK)
+		wait_for_thread(fInvalidator, &amp;err);
+	fInvalidator = -1;
+	if (fFallenReg)
+		delete fFallenReg;
+}
+
+void SnowView::MessageReceived(BMessage *msg)
+{
+	BAlert *info;
+	//msg-&gt;PrintToStream();
+	switch (msg-&gt;what) {
+	case MSG_PULSE_ME:
+		if (Parent()) {
+			Calc();
+			InvalFlakes();
+		}
+		break;
+	case B_ABOUT_REQUESTED:
+		info = new BAlert(&quot;BSnow info&quot;, 
+			&quot;BSnow, just in case you don't have real one...\n&quot;
+			&quot;&quot; B_UTF8_COPYRIGHT &quot; 2003, Fran&#231;ois Revol.&quot;, 
+			&quot;Where is Santa ??&quot;);
+		info-&gt;SetFeel(B_NORMAL_WINDOW_FEEL);
+		info-&gt;SetLook(B_FLOATING_WINDOW_LOOK);
+		info-&gt;SetFlags(info-&gt;Flags()|B_NOT_ZOOMABLE);
+		info-&gt;Go(NULL);
+		break;
+	default:
+//#ifdef FORWARD_TO_PARENT
+/*
+		if (fAttached &amp;&amp; Parent())
+			Parent()-&gt;MessageReceived(msg);
+		else
+*/
+//#endif
+			BView::MessageReceived(msg);
+	}
+}
+
+void SnowView::Draw(BRect ur)
+{
+	int i;
+	if (!fCachedParent) {
+		if (!fShowClickMe) { /* show &quot;drag me&quot; */
+			SetLowColor(ViewColor());
+			SetHighColor(0,0,0);
+			SetFontSize(12);
+			DrawString(MSG_DRAG_ME, BPoint(15,25));
+			BPoint arrowHead(Bounds().RightBottom()+BPoint(-10,-10));
+			StrokeLine(arrowHead, arrowHead - BPoint(7,0));
+			StrokeLine(arrowHead, arrowHead - BPoint(0,7));
+			StrokeLine(arrowHead, arrowHead - BPoint(12,12));
+			return;
+		} else {
+			SetLowColor(ViewColor());
+			SetHighColor(0,0,0);
+			SetFontSize(12);
+			DrawString(MSG_CLICK_ME, BPoint(15,25));
+			return;
+		}
+	}
+	//printf(&quot;Draw()\n&quot;);
+	uint32 cw = fCurrentWorkspace;
+	if (fFlakes[cw] == NULL)
+		return;
+	/* draw the snow already fallen */
+//	BRect fallenRect(Bounds());
+//	fallenRect.top = fallenRect.bottom - FALLEN_HEIGHT;
+//	if (ur.Intersects(fallenRect)) {
+		//if (fFallenBmp-&gt;Lock()) {
+		//	DrawBitmap(fFallenBmp, fallenRect);
+		//	fFallenBmp-&gt;Unlock();
+		//}
+		int32 cnt = fFallenReg-&gt;CountRects();
+//		drawing_mode oldmode = DrawingMode();
+//		SetDrawingMode(B_OP_ADD);
+
+		for (i=0; i&lt;cnt; i++) {
+			BRect r = fFallenReg-&gt;RectAt(i);
+//			SetHighColor(245, 245, 245, 200);
+//			FillRect(r);
+//			SetHighColor(255, 255, 255, 255);
+//			r.InsetBy(1,1);
+			FillRect(r);
+		}
+//		SetDrawingMode(oldmode);
+//	}
+	/* draw our flakes */
+	for (i=0; i&lt;fNumFlakes; i++) {
+		int pat;
+		if (!ur.Contains(BRect(fFlakes[cw][i].pos-BPoint(4,4), fFlakes[cw][i].pos+BPoint(4,4))))
+			continue;
+		if (fFlakes[cw][i].weight == 0)
+			continue;
+		pat = (fFlakes[cw][i].weight&gt;3)?1:0;
+		//FillRect(BRect(fFlakes[cw][i].pos-BPoint(PAT_HOTSPOT),fFlakes[cw][i].pos-BPoint(PAT_HOTSPOT)+BPoint(7,7)), gFlakePatterns[pat]);
+/*
+		StrokeLine(fFlakes[cw][i].pos+BPoint(-1,-1), 
+				fFlakes[cw][i].pos+BPoint(1,1));
+		StrokeLine(fFlakes[cw][i].pos+BPoint(-1,1), 
+				fFlakes[cw][i].pos+BPoint(1,-1));
+*/
+		DrawBitmap(fFlakeBitmaps[pat], fFlakes[cw][i].pos-BPoint(PAT_HOTSPOT));
+	}
+}
+
+void SnowView::Pulse()
+{
+	if (fShowClickMe)
+		return; /* done */
+	if (fCachedParent)
+		return; /* we are in Tracker! */
+	BMessenger msgr(&quot;application/x-vnd.Be-TRAK&quot;);
+	BMessage msg(B_GET_PROPERTY), reply;
+	msg.AddSpecifier(&quot;Frame&quot;);
+	msg.AddSpecifier(&quot;View&quot;, &quot;BSnow&quot;);
+	msg.AddSpecifier(&quot;Window&quot;, 1); /* 0 is Twitcher */
+	if (msgr.SendMessage(&amp;msg, &amp;reply) == B_OK &amp;&amp; reply.what == B_REPLY) {
+		//reply.PrintToStream();
+		Invalidate(Bounds());
+		fShowClickMe = true;
+	}
+}
+
+void SnowView::Calc()
+{
+	int i;
+	uint32 cw = fCurrentWorkspace;
+
+	/* check if the parent changed size */
+	BRect pFrame = fCachedParent-&gt;Frame();
+	if (fCachedWsWidth != pFrame.Width() || fCachedWsHeight != pFrame.Height()) {
+		fCachedWsWidth = pFrame.IntegerWidth();
+		fCachedWsHeight = pFrame.IntegerHeight();
+		printf(&quot;BSnow: Parent resized to %ld %ld\n&quot;, fCachedWsWidth, fCachedWsHeight);
+		fFallenReg-&gt;MakeEmpty(); /* remove all the fallen snow */
+		ResizeTo(pFrame.IntegerWidth(), pFrame.IntegerHeight());
+		fDragger-&gt;MoveTo(pFrame.IntegerWidth()-7, pFrame.IntegerHeight()-7);
+	}
+
+	/* make new flakes */
+	for (i=0; i&lt;fNumFlakes; i++) {
+		if (fFlakes[cw][i].weight == 0) {
+			fFlakes[cw][i].weight = ((float)(rand() % WEIGHT_SPAN)) / WEIGHT_GRAN;
+			fFlakes[cw][i].weight = MAX(fFlakes[cw][i].weight, 0.5);
+			fFlakes[cw][i].pos.y = rand() % 5 - 2;
+			fFlakes[cw][i].pos.x = (rand()%(fCachedWsWidth+2*fCachedWsHeight))-fCachedWsHeight;
+			if (fFlakes[cw][i].pos.x &lt; -10) {
+				fFlakes[cw][i].pos.y = -fFlakes[cw][i].pos.x;
+				if (fWind &gt; 0)
+					fFlakes[cw][i].pos.x = 0;
+				else
+					fFlakes[cw][i].pos.x = fCachedWsWidth;
+			}
+			if (fFlakes[cw][i].pos.x &gt; fCachedWsWidth+10) {
+				fFlakes[cw][i].pos.y = fFlakes[cw][i].pos.x - fCachedWsWidth;
+				if (fWind &gt; 0)
+					fFlakes[cw][i].pos.x = 0;
+				else
+					fFlakes[cw][i].pos.x = fCachedWsWidth;
+			}
+		}
+	}
+	
+	/* like a candle in the wind... */
+	if (fWindDuration &lt; system_time()) {
+		fWindDuration = system_time() + ((((bigtime_t)rand())*1000) % WIND_MAX_DURATION);
+		fWind = (rand() % WIND_SPAN) - WIND_SPAN/2;
+		printf(&quot;BSnow: wind change: %f\n&quot;, fWind);
+	}
+	
+
+//	if (fFallenView-&gt;LockLooperWithTimeout(5000)) {
+//	if (fFallenBmp) {
+//		uint8 *fallenBits = (uint8 *)fFallenBmp-&gt;Bits();
+		
+		BRegion desktopReg;
+		GetClippingRegion(&amp;desktopReg);
+
+		/* let's add some gravity and wind */
+		for (i=0; i&lt;fNumFlakes; i++) {
+			float yinc;
+			if (fFlakes[cw][i].weight == 0)
+				continue;
+			fFlakes[cw][i].opos = fFlakes[cw][i].pos;
+			
+			yinc = fFlakes[cw][i].weight - (rand() % 3);
+			yinc = MAX(yinc, 0.5);
+			fFlakes[cw][i].pos.y += yinc;
+
+//			if (fFlakes[cw][i].pos.y &gt; (fCachedWsHeight-FALLEN_HEIGHT)) {
+
+			bool fallen = false;
+			bool keepfalling = false;
+			
+			/* fallen on the flour */
+			if (fFlakes[cw][i].pos.y &gt; fCachedWsHeight-2)
+				fallen = true;
+			/* fallon on another fallen flake */
+			else if (fFallenReg-&gt;Intersects(BRect(fFlakes[cw][i].pos - BPoint(0,1), 
+											fFlakes[cw][i].pos + BPoint(0,1)))) {
+				/* don't accumulate too much */
+				if ((fFlakes[cw][i].pos.y &gt; fCachedWsHeight-30) || 
+									!desktopReg.Intersects(
+									BRect(fFlakes[cw][i].pos + BPoint(0,6), 
+									fFlakes[cw][i].pos + BPoint(0,10))))
+					fallen = true;
+			/* fallen on a window */
+			} else if (!desktopReg.Intersects(
+							BRect(fFlakes[cw][i].pos + BPoint(-1,-1-2), 
+							fFlakes[cw][i].pos + BPoint(1,1-1))) &amp;&amp; 
+					desktopReg.Intersects(
+							BRect(fFlakes[cw][i].pos + BPoint(-1,-1-3), 
+							fFlakes[cw][i].pos + BPoint(1,1-3)))) {
+				//printf(&quot;fallen3 @ %f %f\n&quot;, fFlakes[cw][i].pos.x, fFlakes[cw][i].pos.y);
+				fFlakes[cw][i].pos = fFlakes[cw][i].opos;
+				fallen = true;
+				keepfalling = true; /* but keep one falling */
+			}
+			
+/*			else if (fallenBits[ (long)(fFlakes[cw][i].pos.y
+					 * fFallenBmp-&gt;BytesPerRow()
+					 + fFlakes[cw][i].pos.y
+					 - (fCachedWsHeight-FALLEN_HEIGHT)) ] != B_TRANSPARENT_MAGIC_CMAP8) {
+				fallen = true;
+			}*/
+
+//			if (fallen) {
+//				int pat = (fFlakes[cw][i].weight&gt;3)?1:0;
+//				if (fFlakes[cw][i].pos.y &gt; fCachedWsHeight-1)
+//					fFlakes[cw][i].pos.y = fCachedWsHeight-(rand()%4);
+				//fFallenView-&gt;DrawBitmap(fFlakeBitmaps[pat], fFlakes[cw][i].pos-BPoint(PAT_HOTSPOT));
+//				fallenBits[ (long)(fFlakes[cw][i].pos.y * fFallenBmp-&gt;BytesPerRow()
+//					+ fFlakes[cw][i].pos.y-(fCachedWsHeight-FALLEN_HEIGHT)) ] = 0x56;
+//				printf(&quot;fallen @ %f, %f\n&quot;, fFlakes[cw][i].pos.x, fFlakes[cw][i].pos.y);
+//			}
+			if (fallen) {
+				if (!keepfalling)
+					fFlakes[cw][i].weight = 0;
+				fFallenReg-&gt;Include(BRect(fFlakes[cw][i].pos - BPoint(2,0), 
+										fFlakes[cw][i].pos + BPoint(2,2)));
+				if (keepfalling) {
+					fFlakes[cw][i].pos += BPoint(0,10);
+					/* except if under the desktop */
+					if (fFlakes[cw][i].pos.y &gt; fCachedWsHeight-1)
+						fFlakes[cw][i].weight = 0;
+				}
+			}
+			
+			/* cleanup, when a window hides the snow */
+			fFallenReg-&gt;IntersectWith(&amp;desktopReg);
+			
+			/* cleanup, when a window is moved */
+			/* seems to lockup Tracker */
+/*
+			int32 cnt = fFallenReg-&gt;CountRects();
+			for (i=0; i&lt;cnt; i++) {
+				BRect r = fFallenReg-&gt;RectAt(i);
+				if (desktopReg.Intersects(r.OffsetByCopy(0,15))) {
+					fFallenReg-&gt;Exclude(r);
+					cnt--;
+				}
+			}
+*/			
+			/* add the effect of the wind */
+			fFlakes[cw][i].pos.x += fWind + (rand() % 6 - 3);
+			if ((fFlakes[cw][i].pos.x &gt; fCachedWsWidth+50)||(fFlakes[cw][i].pos.x &lt; -50))
+				fFlakes[cw][i].weight = 0;
+		}
+//		fFallenView-&gt;UnlockLooper();
+//	}
+#if 0
+	for (i=0; i&lt;10; i++)
+		printf(&quot;f[%d] = {%f, %f}, {%f, %f}, %d\n&quot;, i,
+			fFlakes[cw][i].opos.x, fFlakes[cw][i].opos.y,
+			fFlakes[cw][i].pos.x, fFlakes[cw][i].pos.y,
+			fFlakes[cw][i].weight);
+#endif
+}
+
+void SnowView::InvalFlakes()
+{
+	int i;
+	BView *p = Parent();
+	if (!p)
+		return;
+	//printf(&quot;InvalFlakes()\n&quot;);
+	uint32 cw = fCurrentWorkspace;
+	
+	for (i=0; i&lt;fNumFlakes; i++) {
+		if (fFlakes[cw][i].weight)
+			Invalidate(BRect(fFlakes[cw][i].opos-BPoint(PAT_HOTSPOT), fFlakes[cw][i].opos-BPoint(PAT_HOTSPOT)+BPoint(7,7)));
+	}
+}
+
+void SnowView::MouseDown(BPoint where)
+{
+#ifdef FORWARD_TO_PARENT
+	if (fAttached &amp;&amp; Parent())
+		Parent()-&gt;MouseDown(where);
+#endif
+}
+
+void SnowView::MouseUp(BPoint where)
+{
+#ifdef FORWARD_TO_PARENT
+	if (fAttached &amp;&amp; Parent())
+		Parent()-&gt;MouseUp(where);
+#endif
+	if (fCachedParent)
+		return; /* we are *inside* the Tracker,
+				 * don't even try talking to ourselve
+				 * with the window locked
+				 */
+	BMessenger msgr(&quot;application/x-vnd.Be-TRAK&quot;);
+	BMessage msg(B_DELETE_PROPERTY), reply;
+	msg.AddSpecifier(&quot;Replicant&quot;, &quot;BSnow&quot;);
+	msg.AddSpecifier(&quot;Shelf&quot;);
+	msg.AddSpecifier(&quot;View&quot;, &quot;PoseView&quot;);
+	msg.AddSpecifier(&quot;Window&quot;, 1); /* 0 is Twitcher */
+	if ((msgr.SendMessage(&amp;msg, &amp;reply) == B_OK) &amp;&amp; 
+				(reply.what == B_NO_REPLY || reply.what == B_REPLY)) {
+		//reply.PrintToStream();
+		fShowClickMe = false;
+		Invalidate(Bounds());
+	}
+	/*
+	BMessage: what = JAHA (0x4a414841, or 1245792321)
+    entry          index, type='LONG', c=1, size= 4, data[0]: 0x2 (2, '')
+    entry           when, type='LLNG', c=1, size= 8, data[0]: 0xf6a1b09ac (66204666284, '')
+    entry         source, type='PNTR', c=1, size= 4,
+    entry      be:sender, type='MSNG', c=1, size=24,
+    */
+}
+
+void SnowView::MouseMoved(BPoint where, uint32 code, const BMessage *a_message)
+{
+#ifdef FORWARD_TO_PARENT
+	if (fAttached &amp;&amp; Parent())
+		Parent()-&gt;MouseMoved(where, code, a_message);
+#endif
+}
+
+void SnowView::KeyDown(const char *bytes, int32 numBytes)
+{
+#ifdef FORWARD_TO_PARENT
+	if (fAttached &amp;&amp; Parent())
+		Parent()-&gt;KeyDown(bytes, numBytes);
+#endif
+}
+
+void SnowView::KeyUp(const char *bytes, int32 numBytes)
+{
+#ifdef FORWARD_TO_PARENT
+	if (fAttached &amp;&amp; Parent())
+		Parent()-&gt;KeyUp(bytes, numBytes);
+#endif
+}
+
+#define PORTION_GRAN 20
+
+int32 SnowView::SnowMakerThread(void *p_this)
+{
+	SnowView *_this = (SnowView *)p_this;
+	bigtime_t nextDraw = 0LL;
+	int current=0;
+	BView *p = _this-&gt;Parent();
+	BRect portion(0,0,(_this-&gt;fCachedWsWidth/PORTION_GRAN)-1, (_this-&gt;fCachedWsHeight/PORTION_GRAN)-1);
+	int nf = _this-&gt;fNumFlakes;
+	BRegion reg(BRect(-1,-1,-1,-1));
+	while (p &amp;&amp; _this-&gt;fAttached) {
+		snooze(INTERVAL/(10*(nf?nf:1)));
+		int32 cw = _this-&gt;fCurrentWorkspace;
+		bool drawThisOne = false;
+//printf(&quot;processing flake %d...\n&quot;, current);
+		//for (; (current%(fNumFlakes/4); current++)
+		if (reg.Intersects(portion)) {
+			for (int i = 0; !drawThisOne &amp;&amp; i &lt; nf; i++) {
+				/* if we find at least one flake in this rect, draw it */
+				if ((_this-&gt;fFlakes[cw][i].weight) &amp;&amp; (
+					portion.Intersects(BRect(_this-&gt;fFlakes[cw][i].opos - BPoint(4,4), _this-&gt;fFlakes[cw][i].opos + BPoint(4,4))) || 
+					portion.Intersects(BRect(_this-&gt;fFlakes[cw][i].pos - BPoint(4,4), _this-&gt;fFlakes[cw][i].pos + BPoint(4,4))))) {
+						drawThisOne = true;
+				}
+			}
+		}
+		//if (!drawThisOne)
+			//printf(&quot;!Invalidate(%f, %f, %f, %f)\n&quot;, portion.left, portion.top, portion.right, portion.bottom);
+		/* avoid deadlock on exit */
+		if (drawThisOne &amp;&amp; (_this-&gt;LockLooperWithTimeout(2000) == B_OK)) {
+//			printf(&quot;Invalidate(%f, %f, %f, %f)\n&quot;, portion.left, portion.top, portion.right, portion.bottom);
+			p-&gt;Invalidate(portion);
+			_this-&gt;UnlockLooper();
+		}
+		portion.OffsetBy(_this-&gt;fCachedWsWidth/PORTION_GRAN, 0);
+		if (portion.left &gt;= _this-&gt;fCachedWsWidth) { /* right wrap */
+			//printf(&quot;rigth wrap to %ld\n&quot;, _this-&gt;fCachedWsWidth);
+			portion.OffsetTo(0, portion.top+(_this-&gt;fCachedWsHeight/PORTION_GRAN));
+		}
+		if (portion.top &gt;= _this-&gt;fCachedWsHeight) {
+			portion.OffsetTo(0,0);
+			/* avoid deadlock on exit */
+			if (_this-&gt;LockLooperWithTimeout(5000) == B_OK) {
+//printf(&quot;calculating flakes...\n&quot;);
+				_this-&gt;Calc();
+//printf(&quot;done calculating flakes.\n&quot;);
+				_this-&gt;GetClippingRegion(&amp;reg);
+				//printf(&quot;Region:\n&quot;);
+				//reg.PrintToStream();
+				_this-&gt;UnlockLooper();
+			}
+		}	
+	}
+#if 0
+	BView *p = _this-&gt;Parent();
+	while (p &amp;&amp; _this-&gt;fAttached) {
+		snooze(INTERVAL/_this-&gt;fNumFlakes);
+//printf(&quot;processing flake %d...\n&quot;, current);
+		//for (; (current%(fNumFlakes/4); current++)
+		/* avoid deadlock on exit */
+		if (_this-&gt;LockLooperWithTimeout(2000) == B_OK) {
+			if (_this-&gt;fFlakes[_this-&gt;fCurrentWorkspace][current].weight) {
+				p-&gt;Invalidate(BRect(_this-&gt;fFlakes[_this-&gt;fCurrentWorkspace][current].opos - BPoint(4,4),
+									_this-&gt;fFlakes[_this-&gt;fCurrentWorkspace][current].opos + BPoint(4,4)));
+				p-&gt;Invalidate(BRect(_this-&gt;fFlakes[_this-&gt;fCurrentWorkspace][current].pos - BPoint(4,4),
+									_this-&gt;fFlakes[_this-&gt;fCurrentWorkspace][current].pos + BPoint(4,4)));
+			}
+			_this-&gt;UnlockLooper();
+			current++;
+			current %= _this-&gt;fNumFlakes;
+			if (!current) {
+				/* avoid deadlock on exit */
+				if (_this-&gt;LockLooperWithTimeout(2000) == B_OK) {
+printf(&quot;calculating flakes...\n&quot;);
+					_this-&gt;Calc();
+printf(&quot;done calculating flakes.\n&quot;);
+					_this-&gt;UnlockLooper();
+				}
+			}	
+		}
+	}
+#endif
+	return B_OK;
+}

Added: haiku/trunk/src/apps/bsnow/SnowView.h
===================================================================
--- haiku/trunk/src/apps/bsnow/SnowView.h	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/SnowView.h	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,79 @@
+#ifndef _SNOW_VIEW_H
+#define _SNOW_VIEW_H
+#include &lt;Bitmap.h&gt;
+#include &lt;Dragger.h&gt;
+#include &lt;List.h&gt;
+#include &lt;OS.h&gt;
+#include &lt;View.h&gt;
+#include &lt;MessageRunner.h&gt;
+#include &quot;Flakes.h&quot;
+
+#define APP_SIG &quot;application/x-vnd.mmu_man.BSnow&quot;
+#define SNOW_VIEW_RECT 0,0,200,40
+#define NUM_FLAKES 200
+#define INTERVAL 200000
+#define MSG_PULSE_ME 'PulS'
+#define MSG_DRAW_ME 'DraW'
+#define WORKSPACES_COUNT 32
+#define WEIGHT_SPAN 50
+#define WEIGHT_GRAN 10
+#define WIND_SPAN 25
+#define WIND_MAX_DURATION 10000000
+#define FALLEN_HEIGHT 30
+#define INVALIDATOR_THREAD_NAME &quot;You're Neo? I'm the Snow Maker!&quot;
+
+
+#define MSG_DRAG_ME &quot;Drag me on your desktop...&quot;
+#define MSG_CLICK_ME &quot;Click me to remove BSnow...&quot;
+
+typedef struct flake {
+	BPoint pos;
+	BPoint opos;
+	float weight;
+} flake;
+
+class SnowView : public BView
+{
+public:
+	SnowView();
+	SnowView(BMessage *archive);
+	~SnowView();
+static  BArchivable	*Instantiate(BMessage *data);
+virtual status_t	Archive(BMessage *data, bool deep = true) const;
+void	AttachedToWindow();
+void	DetachedFromWindow();
+void	MessageReceived(BMessage *msg);
+void	Draw(BRect ur);
+void	Pulse();
+
+virtual void	MouseDown(BPoint where);
+virtual void	MouseUp(BPoint where);
+virtual void	MouseMoved(BPoint where, uint32 code, const BMessage *a_message);
+virtual void	KeyDown(const char *bytes, int32 numBytes);
+virtual void	KeyUp(const char *bytes, int32 numBytes);
+
+static int32	SnowMakerThread(void *p_this);
+void	Calc();
+void	InvalFlakes();
+private:
+	BMessageRunner *fMsgRunner;
+	BDragger	*fDragger;
+	long fNumFlakes;
+	flake *fFlakes[WORKSPACES_COUNT];
+	BList *fFallenFlakes[WORKSPACES_COUNT];
+	uint32 fCurrentWorkspace;
+	uint32 fCachedWsWidth;
+	uint32 fCachedWsHeight;
+	float fWind;
+	bigtime_t fWindDuration;
+	bool fAttached;
+	BBitmap *fFlakeBitmaps[NUM_PATTERNS];
+	thread_id fInvalidator;
+	BView *fCachedParent;
+	BBitmap *fFallenBmp;
+	BView *fFallenView;
+	BRegion *fFallenReg;
+	bool fShowClickMe;
+};
+
+#endif

Added: haiku/trunk/src/apps/bsnow/makefile
===================================================================
--- haiku/trunk/src/apps/bsnow/makefile	2007-12-19 22:22:23 UTC (rev 23143)
+++ haiku/trunk/src/apps/bsnow/makefile	2007-12-20 23:29:09 UTC (rev 23144)
@@ -0,0 +1,120 @@
+## BeOS Generic Makefile v2.2 ##
+
+## Fill in this file to specify the project being created, and the referenced
+## makefile-engine will do all of the hard work for you.  This handles both
+## Intel and PowerPC builds of the BeOS.
+
+## Application Specific Settings ---------------------------------------------
+
+# specify the name of the binary
+NAME= BSnow
+
+# specify the type of binary
+#	APP:	Application
+#	SHARED:	Shared library or add-on
+#	STATIC:	Static library archive
+#	DRIVER: Kernel Driver
+TYPE= APP
+
+#	add support for new Pe and Eddie features
+#	to fill in generic makefile
+
+#%{
+# @src-&gt;@ 
+
+#	specify the source files to use
+#	full paths or paths relative to the makefile can be included
+# 	all files, regardless of directory, will have their object
+#	files created in the common object directory.
+#	Note that this means this makefile will not work correctly
+#	if two source files with the same name (source.c or source.cpp)
+#	are included from different directories.  Also note that spaces
+#	in folder names do not work well with this makefile.
+SRCS= SnowApp.cpp SnowView.cpp Flakes.cpp
+
+#	specify the resource files to use

[... truncated: 86 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005067.html">[Haiku-commits] r23143 -	haiku/trunk/src/add-ons/kernel/generic/ide_adapter
</A></li>
	<LI>Next message: <A HREF="005069.html">[Haiku-commits] r23145 - haiku/trunk/src/apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5068">[ date ]</a>
              <a href="thread.html#5068">[ thread ]</a>
              <a href="subject.html#5068">[ subject ]</a>
              <a href="author.html#5068">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
