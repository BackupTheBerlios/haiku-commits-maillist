<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23124 - in	haiku/trunk/src/add-ons/kernel/drivers/network: .	broadcom_bcm570x broadcom_bcm570x/dev	broadcom_bcm570x/dev/bge broadcom_bcm570x/dev/mii nforce	nforce/dev nforce/dev/mii nforce/dev/nfe
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-December/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23124%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%0A%09broadcom_bcm570x%20broadcom_bcm570x/dev%0A%09broadcom_bcm570x/dev/bge%20broadcom_bcm570x/dev/mii%20nforce%0A%09nforce/dev%20nforce/dev/mii%20nforce/dev/nfe&In-Reply-To=%3C200712161056.lBGAue1N029576%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005039.html">
   <LINK REL="Next"  HREF="005043.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23124 - in	haiku/trunk/src/add-ons/kernel/drivers/network: .	broadcom_bcm570x broadcom_bcm570x/dev	broadcom_bcm570x/dev/bge broadcom_bcm570x/dev/mii nforce	nforce/dev nforce/dev/mii nforce/dev/nfe</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23124%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%0A%09broadcom_bcm570x%20broadcom_bcm570x/dev%0A%09broadcom_bcm570x/dev/bge%20broadcom_bcm570x/dev/mii%20nforce%0A%09nforce/dev%20nforce/dev/mii%20nforce/dev/nfe&In-Reply-To=%3C200712161056.lBGAue1N029576%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23124 - in	haiku/trunk/src/add-ons/kernel/drivers/network: .	broadcom_bcm570x broadcom_bcm570x/dev	broadcom_bcm570x/dev/bge broadcom_bcm570x/dev/mii nforce	nforce/dev nforce/dev/mii nforce/dev/nfe">axeld at mail.berlios.de
       </A><BR>
    <I>Sun Dec 16 11:56:40 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="005039.html">[Haiku-commits] r23123 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="005043.html">[Haiku-commits] r23124 -	in	haiku/trunk/src/add-ons/kernel/drivers/network: .	broadcom_bcm570x	broadcom_bcm570x/dev	broadcom_bcm570x/dev/bge broadcom_bcm570x/dev/mii	nforce	nforce/dev nforce/dev/mii nforce/dev/nfe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5040">[ date ]</a>
              <a href="thread.html#5040">[ thread ]</a>
              <a href="subject.html#5040">[ subject ]</a>
              <a href="author.html#5040">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-12-16 11:56:30 +0100 (Sun, 16 Dec 2007)
New Revision: 23124
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23124&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23124&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/if_bge.c
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/if_bgereg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/brgphyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/miidevs.h
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/mii/ukphy_subr.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/ciphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/ciphyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/miidevs.h
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/mii/ukphy_subr.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/if_nfe.c
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/if_nfereg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/nforce/dev/nfe/if_nfevar.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
Log:
* Added Broadcom BCM570x driver from FreeBSD (bge). Does not compile yet, needs
  a bit more work on the compatibility layer.
* Added nVidia nForce MCP driver (nfe) from FreeBSD. Compiles and might even
  work - please test. It would also be nice to know if your PHY is detected
  correctly (see syslog output).


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2007-12-16 10:56:30 UTC (rev 23124)
@@ -12,10 +12,12 @@
 SubInclude HAIKU_TOP src add-ons kernel drivers network vlance ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network wb840 ;
 
-# FreeBSD 6.2 drivers
+# FreeBSD 7 drivers
 SubInclude HAIKU_TOP src add-ons kernel drivers network 3com ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network ipro100 ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network marvell_yukon ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network nforce ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network pcnet ;
 
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm440x ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/Jamfile	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/Jamfile	2007-12-16 10:56:30 UTC (rev 23124)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x dev ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/Jamfile	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/Jamfile	2007-12-16 10:56:30 UTC (rev 23124)
@@ -0,0 +1,4 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x dev bge ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x dev mii ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/Jamfile	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/Jamfile	2007-12-16 10:56:30 UTC (rev 23124)
@@ -0,0 +1,18 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network broadcom_bcm570x dev bge ;
+
+SubDirCcFlags -Wall ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(SUBDIR) .. mii ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 ] ;
+
+KernelAddon broadcom_bcm570x :
+	if_bge.c
+	glue.c
+	: libfreebsd_network.a broadcom_bcm570x_mii.a
+	;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/glue.c	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/glue.c	2007-12-16 10:56:30 UTC (rev 23124)
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include &lt;sys/bus.h&gt;
+
+
+HAIKU_FBSD_DRIVER_GLUE(broadcom_bcm570x, bge, pci);
+HAIKU_DRIVER_REQUIREMENTS(FBSD_TASKQUEUES | FBSD_SWI_TASKQUEUE);
+
+
+extern driver_t *DRIVER_MODULE_NAME(ukphy, miibus);
+
+
+driver_t *
+__haiku_select_miibus_driver(device_t dev)
+{
+	driver_t *drivers[] = {
+		DRIVER_MODULE_NAME(ukphy, miibus),
+		NULL
+	};
+
+	return __haiku_probe_miibus(dev, drivers);
+}
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/if_bge.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/if_bge.c	2007-12-14 21:21:55 UTC (rev 23123)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/broadcom_bcm570x/dev/bge/if_bge.c	2007-12-16 10:56:30 UTC (rev 23124)
@@ -0,0 +1,4539 @@
+/*-
+ * Copyright (c) 2001 Wind River Systems
+ * Copyright (c) 1997, 1998, 1999, 2001
+ *	Bill Paul &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wpaul at windriver.com</A>&gt;.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Bill Paul.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/bge/if_bge.c,v 1.198 2007/09/30 11:05:14 marius Exp $&quot;);
+
+/*
+ * Broadcom BCM570x family gigabit ethernet driver for FreeBSD.
+ *
+ * The Broadcom BCM5700 is based on technology originally developed by
+ * Alteon Networks as part of the Tigon I and Tigon II gigabit ethernet
+ * MAC chips. The BCM5700, sometimes refered to as the Tigon III, has
+ * two on-board MIPS R4000 CPUs and can have as much as 16MB of external
+ * SSRAM. The BCM5700 supports TCP, UDP and IP checksum offload, jumbo
+ * frames, highly configurable RX filtering, and 16 RX and TX queues
+ * (which, along with RX filter rules, can be used for QOS applications).
+ * Other features, such as TCP segmentation, may be available as part
+ * of value-added firmware updates. Unlike the Tigon I and Tigon II,
+ * firmware images can be stored in hardware and need not be compiled
+ * into the driver.
+ *
+ * The BCM5700 supports the PCI v2.2 and PCI-X v1.0 standards, and will
+ * function in a 32-bit/64-bit 33/66Mhz bus, or a 64-bit/133Mhz bus.
+ *
+ * The BCM5701 is a single-chip solution incorporating both the BCM5700
+ * MAC and a BCM5401 10/100/1000 PHY. Unlike the BCM5700, the BCM5701
+ * does not support external SSRAM.
+ *
+ * Broadcom also produces a variation of the BCM5700 under the &quot;Altima&quot;
+ * brand name, which is functionally similar but lacks PCI-X support.
+ *
+ * Without external SSRAM, you can only have at most 4 TX rings,
+ * and the use of the mini RX ring is disabled. This seems to imply
+ * that these features are simply not available on the BCM5701. As a
+ * result, this driver does not implement any support for the mini RX
+ * ring.
+ */
+
+#ifdef HAVE_KERNEL_OPTION_HEADERS
+#include &quot;opt_device_polling.h&quot;
+#endif
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/endian.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/sockio.h&gt;
+#include &lt;sys/mbuf.h&gt;
+#include &lt;sys/malloc.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/sysctl.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;net/if_arp.h&gt;
+#include &lt;net/ethernet.h&gt;
+#include &lt;net/if_dl.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;net/bpf.h&gt;
+
+#include &lt;net/if_types.h&gt;
+#include &lt;net/if_vlan_var.h&gt;
+
+#include &lt;netinet/in_systm.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;netinet/ip.h&gt;
+
+#include &lt;machine/bus.h&gt;
+#include &lt;machine/resource.h&gt;
+#include &lt;sys/bus.h&gt;
+#include &lt;sys/rman.h&gt;
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+#include &quot;miidevs.h&quot;
+#include &lt;dev/mii/brgphyreg.h&gt;
+
+#ifdef __sparc64__
+#include &lt;dev/ofw/ofw_bus.h&gt;
+#include &lt;dev/ofw/openfirm.h&gt;
+#include &lt;machine/ofw_machdep.h&gt;
+#include &lt;machine/ver.h&gt;
+#endif
+
+#include &lt;dev/pci/pcireg.h&gt;
+#include &lt;dev/pci/pcivar.h&gt;
+
+#include &lt;dev/bge/if_bgereg.h&gt;
+
+#define	BGE_CSUM_FEATURES	(CSUM_IP | CSUM_TCP | CSUM_UDP)
+#define	ETHER_MIN_NOPAD		(ETHER_MIN_LEN - ETHER_CRC_LEN) /* i.e., 60 */
+
+MODULE_DEPEND(bge, pci, 1, 1, 1);
+MODULE_DEPEND(bge, ether, 1, 1, 1);
+MODULE_DEPEND(bge, miibus, 1, 1, 1);
+
+/* &quot;device miibus&quot; required.  See GENERIC if you get errors here. */
+#include &quot;miibus_if.h&quot;
+
+/*
+ * Various supported device vendors/types and their names. Note: the
+ * spec seems to indicate that the hardware still has Alteon's vendor
+ * ID burned into it, though it will always be overriden by the vendor
+ * ID in the EEPROM. Just to be safe, we cover all possibilities.
+ */
+static struct bge_type {
+	uint16_t	bge_vid;
+	uint16_t	bge_did;
+} bge_devs[] = {
+	{ ALTEON_VENDORID,	ALTEON_DEVICEID_BCM5700 },
+	{ ALTEON_VENDORID,	ALTEON_DEVICEID_BCM5701 },
+
+	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC1000 },
+	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC1002 },
+	{ ALTIMA_VENDORID,	ALTIMA_DEVICE_AC9100 },
+
+	{ APPLE_VENDORID,	APPLE_DEVICE_BCM5701 },
+
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5700 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5701 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702_ALT },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5702X },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703_ALT },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5703X },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704C },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704S },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5704S_ALT },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705F },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705K },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5705M_ALT },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5714C },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5714S },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5715 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5715S },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5720 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5721 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5750 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5750M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751F },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5751M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5752 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5752M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753F },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5753M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5754 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5754M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5755 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5755M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5780 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5780S },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5781 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5782 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5786 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5787 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5787M },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5788 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5789 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5901 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5901A2 },
+	{ BCOM_VENDORID,	BCOM_DEVICEID_BCM5903M },
+
+	{ SK_VENDORID,		SK_DEVICEID_ALTIMA },
+
+	{ TC_VENDORID,		TC_DEVICEID_3C996 },
+
+	{ 0, 0 }
+};
+
+static const struct bge_vendor {
+	uint16_t	v_id;
+	const char	*v_name;
+} bge_vendors[] = {
+	{ ALTEON_VENDORID,	&quot;Alteon&quot; },
+	{ ALTIMA_VENDORID,	&quot;Altima&quot; },
+	{ APPLE_VENDORID,	&quot;Apple&quot; },
+	{ BCOM_VENDORID,	&quot;Broadcom&quot; },
+	{ SK_VENDORID,		&quot;SysKonnect&quot; },
+	{ TC_VENDORID,		&quot;3Com&quot; },
+
+	{ 0, NULL }
+};
+	
+static const struct bge_revision {
+	uint32_t	br_chipid;
+	const char	*br_name;
+} bge_revisions[] = {
+	{ BGE_CHIPID_BCM5700_A0,	&quot;BCM5700 A0&quot; },
+	{ BGE_CHIPID_BCM5700_A1,	&quot;BCM5700 A1&quot; },
+	{ BGE_CHIPID_BCM5700_B0,	&quot;BCM5700 B0&quot; },
+	{ BGE_CHIPID_BCM5700_B1,	&quot;BCM5700 B1&quot; },
+	{ BGE_CHIPID_BCM5700_B2,	&quot;BCM5700 B2&quot; },
+	{ BGE_CHIPID_BCM5700_B3,	&quot;BCM5700 B3&quot; },
+	{ BGE_CHIPID_BCM5700_ALTIMA,	&quot;BCM5700 Altima&quot; },
+	{ BGE_CHIPID_BCM5700_C0,	&quot;BCM5700 C0&quot; },
+	{ BGE_CHIPID_BCM5701_A0,	&quot;BCM5701 A0&quot; },
+	{ BGE_CHIPID_BCM5701_B0,	&quot;BCM5701 B0&quot; },
+	{ BGE_CHIPID_BCM5701_B2,	&quot;BCM5701 B2&quot; },
+	{ BGE_CHIPID_BCM5701_B5,	&quot;BCM5701 B5&quot; },
+	{ BGE_CHIPID_BCM5703_A0,	&quot;BCM5703 A0&quot; },
+	{ BGE_CHIPID_BCM5703_A1,	&quot;BCM5703 A1&quot; },
+	{ BGE_CHIPID_BCM5703_A2,	&quot;BCM5703 A2&quot; },
+	{ BGE_CHIPID_BCM5703_A3,	&quot;BCM5703 A3&quot; },
+	{ BGE_CHIPID_BCM5703_B0,	&quot;BCM5703 B0&quot; },
+	{ BGE_CHIPID_BCM5704_A0,	&quot;BCM5704 A0&quot; },
+	{ BGE_CHIPID_BCM5704_A1,	&quot;BCM5704 A1&quot; },
+	{ BGE_CHIPID_BCM5704_A2,	&quot;BCM5704 A2&quot; },
+	{ BGE_CHIPID_BCM5704_A3,	&quot;BCM5704 A3&quot; },
+	{ BGE_CHIPID_BCM5704_B0,	&quot;BCM5704 B0&quot; },
+	{ BGE_CHIPID_BCM5705_A0,	&quot;BCM5705 A0&quot; },
+	{ BGE_CHIPID_BCM5705_A1,	&quot;BCM5705 A1&quot; },
+	{ BGE_CHIPID_BCM5705_A2,	&quot;BCM5705 A2&quot; },
+	{ BGE_CHIPID_BCM5705_A3,	&quot;BCM5705 A3&quot; },
+	{ BGE_CHIPID_BCM5750_A0,	&quot;BCM5750 A0&quot; },
+	{ BGE_CHIPID_BCM5750_A1,	&quot;BCM5750 A1&quot; },
+	{ BGE_CHIPID_BCM5750_A3,	&quot;BCM5750 A3&quot; },
+	{ BGE_CHIPID_BCM5750_B0,	&quot;BCM5750 B0&quot; },
+	{ BGE_CHIPID_BCM5750_B1,	&quot;BCM5750 B1&quot; },
+	{ BGE_CHIPID_BCM5750_C0,	&quot;BCM5750 C0&quot; },
+	{ BGE_CHIPID_BCM5750_C1,	&quot;BCM5750 C1&quot; },
+	{ BGE_CHIPID_BCM5750_C2,	&quot;BCM5750 C2&quot; },
+	{ BGE_CHIPID_BCM5714_A0,	&quot;BCM5714 A0&quot; },
+	{ BGE_CHIPID_BCM5752_A0,	&quot;BCM5752 A0&quot; },
+	{ BGE_CHIPID_BCM5752_A1,	&quot;BCM5752 A1&quot; },
+	{ BGE_CHIPID_BCM5752_A2,	&quot;BCM5752 A2&quot; },
+	{ BGE_CHIPID_BCM5714_B0,	&quot;BCM5714 B0&quot; },
+	{ BGE_CHIPID_BCM5714_B3,	&quot;BCM5714 B3&quot; },
+	{ BGE_CHIPID_BCM5715_A0,	&quot;BCM5715 A0&quot; },
+	{ BGE_CHIPID_BCM5715_A1,	&quot;BCM5715 A1&quot; },
+	{ BGE_CHIPID_BCM5715_A3,	&quot;BCM5715 A3&quot; },
+	{ BGE_CHIPID_BCM5755_A0,	&quot;BCM5755 A0&quot; },
+	{ BGE_CHIPID_BCM5755_A1,	&quot;BCM5755 A1&quot; },
+	{ BGE_CHIPID_BCM5755_A2,	&quot;BCM5755 A2&quot; },
+	/* 5754 and 5787 share the same ASIC ID */
+	{ BGE_CHIPID_BCM5787_A0,	&quot;BCM5754/5787 A0&quot; }, 
+	{ BGE_CHIPID_BCM5787_A1,	&quot;BCM5754/5787 A1&quot; },
+	{ BGE_CHIPID_BCM5787_A2,	&quot;BCM5754/5787 A2&quot; },
+
+	{ 0, NULL }
+};
+
+/*
+ * Some defaults for major revisions, so that newer steppings
+ * that we don't know about have a shot at working.
+ */
+static const struct bge_revision bge_majorrevs[] = {
+	{ BGE_ASICREV_BCM5700,		&quot;unknown BCM5700&quot; },
+	{ BGE_ASICREV_BCM5701,		&quot;unknown BCM5701&quot; },
+	{ BGE_ASICREV_BCM5703,		&quot;unknown BCM5703&quot; },
+	{ BGE_ASICREV_BCM5704,		&quot;unknown BCM5704&quot; },
+	{ BGE_ASICREV_BCM5705,		&quot;unknown BCM5705&quot; },
+	{ BGE_ASICREV_BCM5750,		&quot;unknown BCM5750&quot; },
+	{ BGE_ASICREV_BCM5714_A0,	&quot;unknown BCM5714&quot; },
+	{ BGE_ASICREV_BCM5752,		&quot;unknown BCM5752&quot; },
+	{ BGE_ASICREV_BCM5780,		&quot;unknown BCM5780&quot; },
+	{ BGE_ASICREV_BCM5714,		&quot;unknown BCM5714&quot; },
+	{ BGE_ASICREV_BCM5755,		&quot;unknown BCM5755&quot; },
+	/* 5754 and 5787 share the same ASIC ID */
+	{ BGE_ASICREV_BCM5787,		&quot;unknown BCM5754/5787&quot; },
+
+	{ 0, NULL }
+};
+
+#define	BGE_IS_JUMBO_CAPABLE(sc)	((sc)-&gt;bge_flags &amp; BGE_FLAG_JUMBO)
+#define	BGE_IS_5700_FAMILY(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5700_FAMILY)
+#define	BGE_IS_5705_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5705_PLUS)
+#define	BGE_IS_5714_FAMILY(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_5714_FAMILY)
+#define	BGE_IS_575X_PLUS(sc)		((sc)-&gt;bge_flags &amp; BGE_FLAG_575X_PLUS)
+
+const struct bge_revision * bge_lookup_rev(uint32_t);
+const struct bge_vendor * bge_lookup_vendor(uint16_t);
+static int bge_probe(device_t);
+static int bge_attach(device_t);
+static int bge_detach(device_t);
+static int bge_suspend(device_t);
+static int bge_resume(device_t);
+static void bge_release_resources(struct bge_softc *);
+static void bge_dma_map_addr(void *, bus_dma_segment_t *, int, int);
+static int bge_dma_alloc(device_t);
+static void bge_dma_free(struct bge_softc *);
+
+static void bge_txeof(struct bge_softc *);
+static void bge_rxeof(struct bge_softc *);
+
+static void bge_asf_driver_up (struct bge_softc *);
+static void bge_tick(void *);
+static void bge_stats_update(struct bge_softc *);
+static void bge_stats_update_regs(struct bge_softc *);
+static int bge_encap(struct bge_softc *, struct mbuf **, uint32_t *);
+
+static void bge_intr(void *);
+static void bge_start_locked(struct ifnet *);
+static void bge_start(struct ifnet *);
+static int bge_ioctl(struct ifnet *, u_long, caddr_t);
+static void bge_init_locked(struct bge_softc *);
+static void bge_init(void *);
+static void bge_stop(struct bge_softc *);
+static void bge_watchdog(struct bge_softc *);
+static void bge_shutdown(device_t);
+static int bge_ifmedia_upd_locked(struct ifnet *);
+static int bge_ifmedia_upd(struct ifnet *);
+static void bge_ifmedia_sts(struct ifnet *, struct ifmediareq *);
+
+static uint8_t bge_eeprom_getbyte(struct bge_softc *, int, uint8_t *);
+static int bge_read_eeprom(struct bge_softc *, caddr_t, int, int);
+
+static void bge_setpromisc(struct bge_softc *);
+static void bge_setmulti(struct bge_softc *);
+static void bge_setvlan(struct bge_softc *);
+
+static int bge_newbuf_std(struct bge_softc *, int, struct mbuf *);
+static int bge_newbuf_jumbo(struct bge_softc *, int, struct mbuf *);
+static int bge_init_rx_ring_std(struct bge_softc *);
+static void bge_free_rx_ring_std(struct bge_softc *);
+static int bge_init_rx_ring_jumbo(struct bge_softc *);
+static void bge_free_rx_ring_jumbo(struct bge_softc *);
+static void bge_free_tx_ring(struct bge_softc *);
+static int bge_init_tx_ring(struct bge_softc *);
+
+static int bge_chipinit(struct bge_softc *);
+static int bge_blockinit(struct bge_softc *);
+
+static int bge_has_eeprom(struct bge_softc *);
+static uint32_t bge_readmem_ind(struct bge_softc *, int);
+static void bge_writemem_ind(struct bge_softc *, int, int);
+#ifdef notdef
+static uint32_t bge_readreg_ind(struct bge_softc *, int);
+#endif
+static void bge_writemem_direct(struct bge_softc *, int, int);
+static void bge_writereg_ind(struct bge_softc *, int, int);
+
+static int bge_miibus_readreg(device_t, int, int);
+static int bge_miibus_writereg(device_t, int, int, int);
+static void bge_miibus_statchg(device_t);
+#ifdef DEVICE_POLLING
+static void bge_poll(struct ifnet *ifp, enum poll_cmd cmd, int count);
+#endif
+
+#define	BGE_RESET_START 1
+#define	BGE_RESET_STOP  2
+static void bge_sig_post_reset(struct bge_softc *, int);
+static void bge_sig_legacy(struct bge_softc *, int);
+static void bge_sig_pre_reset(struct bge_softc *, int);
+static int bge_reset(struct bge_softc *);
+static void bge_link_upd(struct bge_softc *);
+
+/*
+ * The BGE_REGISTER_DEBUG option is only for low-level debugging.  It may
+ * leak information to untrusted users.  It is also known to cause alignment
+ * traps on certain architectures.
+ */
+#ifdef BGE_REGISTER_DEBUG
+static int bge_sysctl_debug_info(SYSCTL_HANDLER_ARGS);
+static int bge_sysctl_reg_read(SYSCTL_HANDLER_ARGS);
+static int bge_sysctl_mem_read(SYSCTL_HANDLER_ARGS);
+#endif
+static void bge_add_sysctls(struct bge_softc *);
+static int bge_sysctl_stats(SYSCTL_HANDLER_ARGS);
+
+static device_method_t bge_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		bge_probe),
+	DEVMETHOD(device_attach,	bge_attach),
+	DEVMETHOD(device_detach,	bge_detach),
+	DEVMETHOD(device_shutdown,	bge_shutdown),
+	DEVMETHOD(device_suspend,	bge_suspend),
+	DEVMETHOD(device_resume,	bge_resume),
+
+	/* bus interface */
+	DEVMETHOD(bus_print_child,	bus_generic_print_child),
+	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	bge_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	bge_miibus_writereg),
+	DEVMETHOD(miibus_statchg,	bge_miibus_statchg),
+
+	{ 0, 0 }
+};
+
+static driver_t bge_driver = {
+	&quot;bge&quot;,
+	bge_methods,
+	sizeof(struct bge_softc)
+};
+
+static devclass_t bge_devclass;
+
+DRIVER_MODULE(bge, pci, bge_driver, bge_devclass, 0, 0);
+DRIVER_MODULE(miibus, bge, miibus_driver, miibus_devclass, 0, 0);
+
+static int bge_allow_asf = 1;
+
+TUNABLE_INT(&quot;hw.bge.allow_asf&quot;, &amp;bge_allow_asf);
+
+SYSCTL_NODE(_hw, OID_AUTO, bge, CTLFLAG_RD, 0, &quot;BGE driver parameters&quot;);
+SYSCTL_INT(_hw_bge, OID_AUTO, allow_asf, CTLFLAG_RD, &amp;bge_allow_asf, 0,
+	&quot;Allow ASF mode if available&quot;);
+
+#define	SPARC64_BLADE_1500_MODEL	&quot;SUNW,Sun-Blade-1500&quot;
+#define	SPARC64_BLADE_1500_PATH_BGE	&quot;/<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pci at 1f</A>,700000/<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">network at 2</A>&quot;
+#define	SPARC64_BLADE_2500_MODEL	&quot;SUNW,Sun-Blade-2500&quot;
+#define	SPARC64_BLADE_2500_PATH_BGE	&quot;/<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">pci at 1c</A>,600000/<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">network at 3</A>&quot;
+#define	SPARC64_OFW_SUBVENDOR		&quot;subsystem-vendor-id&quot;
+
+static int
+bge_has_eeprom(struct bge_softc *sc)
+{
+#ifdef __sparc64__
+	char buf[sizeof(SPARC64_BLADE_1500_PATH_BGE)];
+	device_t dev;
+	uint32_t subvendor;
+
+	dev = sc-&gt;bge_dev;
+
+	/*
+	 * The on-board BGEs found in sun4u machines aren't fitted with
+	 * an EEPROM which means that we have to obtain the MAC address
+	 * via OFW and that some tests will always fail. We distinguish
+	 * such BGEs by the subvendor ID, which also has to be obtained
+	 * from OFW instead of the PCI configuration space as the latter
+	 * indicates Broadcom as the subvendor of the netboot interface.
+	 * For early Blade 1500 and 2500 we even have to check the OFW
+	 * device path as the subvendor ID always defaults to Broadcom
+	 * there.
+	 */
+	if (OF_getprop(ofw_bus_get_node(dev), SPARC64_OFW_SUBVENDOR,
+	    &amp;subvendor, sizeof(subvendor)) == sizeof(subvendor) &amp;&amp;
+	    subvendor == SUN_VENDORID)
+		return (0);
+	memset(buf, 0, sizeof(buf));
+	if (OF_package_to_path(ofw_bus_get_node(dev), buf, sizeof(buf)) &gt; 0) {
+		if (strcmp(sparc64_model, SPARC64_BLADE_1500_MODEL) == 0 &amp;&amp;
+		    strcmp(buf, SPARC64_BLADE_1500_PATH_BGE) == 0)
+			return (0);
+		if (strcmp(sparc64_model, SPARC64_BLADE_2500_MODEL) == 0 &amp;&amp;
+		    strcmp(buf, SPARC64_BLADE_2500_PATH_BGE) == 0)
+			return (0);
+	}
+#endif
+	return (1);
+}
+
+static uint32_t
+bge_readmem_ind(struct bge_softc *sc, int off)
+{
+	device_t dev;
+	uint32_t val;
+
+	dev = sc-&gt;bge_dev;
+
+	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, off, 4);
+	val = pci_read_config(dev, BGE_PCI_MEMWIN_DATA, 4);
+	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, 0, 4);
+	return (val);
+}
+
+static void
+bge_writemem_ind(struct bge_softc *sc, int off, int val)
+{
+	device_t dev;
+
+	dev = sc-&gt;bge_dev;
+
+	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, off, 4);
+	pci_write_config(dev, BGE_PCI_MEMWIN_DATA, val, 4);
+	pci_write_config(dev, BGE_PCI_MEMWIN_BASEADDR, 0, 4);
+}
+
+#ifdef notdef
+static uint32_t
+bge_readreg_ind(struct bge_softc *sc, int off)
+{
+	device_t dev;
+
+	dev = sc-&gt;bge_dev;
+
+	pci_write_config(dev, BGE_PCI_REG_BASEADDR, off, 4);
+	return (pci_read_config(dev, BGE_PCI_REG_DATA, 4));
+}
+#endif
+
+static void
+bge_writereg_ind(struct bge_softc *sc, int off, int val)
+{
+	device_t dev;
+
+	dev = sc-&gt;bge_dev;
+
+	pci_write_config(dev, BGE_PCI_REG_BASEADDR, off, 4);
+	pci_write_config(dev, BGE_PCI_REG_DATA, val, 4);
+}
+
+static void
+bge_writemem_direct(struct bge_softc *sc, int off, int val)
+{
+	CSR_WRITE_4(sc, off, val);
+}
+
+/*
+ * Map a single buffer address.
+ */
+
+static void
+bge_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)
+{
+	struct bge_dmamap_arg *ctx;
+
+	if (error)
+		return;
+
+	ctx = arg;
+
+	if (nseg &gt; ctx-&gt;bge_maxsegs) {
+		ctx-&gt;bge_maxsegs = 0;
+		return;
+	}
+
+	ctx-&gt;bge_busaddr = segs-&gt;ds_addr;
+}
+
+/*
+ * Read a byte of data stored in the EEPROM at address 'addr.' The
+ * BCM570x supports both the traditional bitbang interface and an
+ * auto access interface for reading the EEPROM. We use the auto
+ * access method.
+ */
+static uint8_t
+bge_eeprom_getbyte(struct bge_softc *sc, int addr, uint8_t *dest)
+{
+	int i;
+	uint32_t byte = 0;
+
+	/*
+	 * Enable use of auto EEPROM access so we can avoid
+	 * having to use the bitbang method.
+	 */
+	BGE_SETBIT(sc, BGE_MISC_LOCAL_CTL, BGE_MLC_AUTO_EEPROM);
+
+	/* Reset the EEPROM, load the clock period. */
+	CSR_WRITE_4(sc, BGE_EE_ADDR,
+	    BGE_EEADDR_RESET | BGE_EEHALFCLK(BGE_HALFCLK_384SCL));
+	DELAY(20);
+
+	/* Issue the read EEPROM command. */
+	CSR_WRITE_4(sc, BGE_EE_ADDR, BGE_EE_READCMD | addr);
+
+	/* Wait for completion */
+	for(i = 0; i &lt; BGE_TIMEOUT * 10; i++) {
+		DELAY(10);
+		if (CSR_READ_4(sc, BGE_EE_ADDR) &amp; BGE_EEADDR_DONE)
+			break;
+	}
+
+	if (i == BGE_TIMEOUT * 10) {
+		device_printf(sc-&gt;bge_dev, &quot;EEPROM read timed out\n&quot;);
+		return (1);
+	}
+
+	/* Get result. */
+	byte = CSR_READ_4(sc, BGE_EE_DATA);
+
+	*dest = (byte &gt;&gt; ((addr % 4) * 8)) &amp; 0xFF;
+
+	return (0);
+}
+
+/*
+ * Read a sequence of bytes from the EEPROM.
+ */
+static int
+bge_read_eeprom(struct bge_softc *sc, caddr_t dest, int off, int cnt)
+{
+	int i, error = 0;
+	uint8_t byte = 0;
+
+	for (i = 0; i &lt; cnt; i++) {
+		error = bge_eeprom_getbyte(sc, off + i, &amp;byte);
+		if (error)
+			break;
+		*(dest + i) = byte;
+	}
+
+	return (error ? 1 : 0);
+}
+
+static int
+bge_miibus_readreg(device_t dev, int phy, int reg)
+{
+	struct bge_softc *sc;
+	uint32_t val, autopoll;
+	int i;
+
+	sc = device_get_softc(dev);
+
+	/*
+	 * Broadcom's own driver always assumes the internal
+	 * PHY is at GMII address 1. On some chips, the PHY responds
+	 * to accesses at all addresses, which could cause us to
+	 * bogusly attach the PHY 32 times at probe type. Always
+	 * restricting the lookup to address 1 is simpler than
+	 * trying to figure out which chips revisions should be
+	 * special-cased.
+	 */
+	if (phy != 1)
+		return (0);
+
+	/* Reading with autopolling on may trigger PCI errors */
+	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
+	if (autopoll &amp; BGE_MIMODE_AUTOPOLL) {
+		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
+		DELAY(40);
+	}
+
+	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_READ | BGE_MICOMM_BUSY |
+	    BGE_MIPHY(phy) | BGE_MIREG(reg));
+
+	for (i = 0; i &lt; BGE_TIMEOUT; i++) {
+		DELAY(10);
+		val = CSR_READ_4(sc, BGE_MI_COMM);
+		if (!(val &amp; BGE_MICOMM_BUSY))
+			break;
+	}
+
+	if (i == BGE_TIMEOUT) {
+		device_printf(sc-&gt;bge_dev, &quot;PHY read timed out\n&quot;);
+		val = 0;
+		goto done;
+	}
+
+	val = CSR_READ_4(sc, BGE_MI_COMM);
+
+done:
+	if (autopoll &amp; BGE_MIMODE_AUTOPOLL) {
+		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
+		DELAY(40);
+	}
+
+	if (val &amp; BGE_MICOMM_READFAIL)
+		return (0);
+
+	return (val &amp; 0xFFFF);
+}
+
+static int
+bge_miibus_writereg(device_t dev, int phy, int reg, int val)
+{
+	struct bge_softc *sc;
+	uint32_t autopoll;
+	int i;
+
+	sc = device_get_softc(dev);
+
+	/* Reading with autopolling on may trigger PCI errors */
+	autopoll = CSR_READ_4(sc, BGE_MI_MODE);
+	if (autopoll &amp; BGE_MIMODE_AUTOPOLL) {
+		BGE_CLRBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
+		DELAY(40);
+	}
+
+	CSR_WRITE_4(sc, BGE_MI_COMM, BGE_MICMD_WRITE | BGE_MICOMM_BUSY |
+	    BGE_MIPHY(phy) | BGE_MIREG(reg) | val);
+
+	for (i = 0; i &lt; BGE_TIMEOUT; i++) {
+		DELAY(10);
+		if (!(CSR_READ_4(sc, BGE_MI_COMM) &amp; BGE_MICOMM_BUSY))
+			break;
+	}
+
+	if (i == BGE_TIMEOUT) {
+		device_printf(sc-&gt;bge_dev, &quot;PHY write timed out\n&quot;);
+		return (0);
+	}
+
+	if (autopoll &amp; BGE_MIMODE_AUTOPOLL) {
+		BGE_SETBIT(sc, BGE_MI_MODE, BGE_MIMODE_AUTOPOLL);
+		DELAY(40);
+	}
+
+	return (0);
+}
+
+static void
+bge_miibus_statchg(device_t dev)
+{
+	struct bge_softc *sc;
+	struct mii_data *mii;
+	sc = device_get_softc(dev);
+	mii = device_get_softc(sc-&gt;bge_miibus);
+
+	BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_PORTMODE);
+	if (IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_1000_T)
+		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_GMII);
+	else
+		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_PORTMODE_MII);
+
+	if ((mii-&gt;mii_media_active &amp; IFM_GMASK) == IFM_FDX)
+		BGE_CLRBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
+	else
+		BGE_SETBIT(sc, BGE_MAC_MODE, BGE_MACMODE_HALF_DUPLEX);
+}
+
+/*
+ * Intialize a standard receive ring descriptor.
+ */
+static int
+bge_newbuf_std(struct bge_softc *sc, int i, struct mbuf *m)
+{
+	struct mbuf *m_new = NULL;
+	struct bge_rx_bd *r;
+	struct bge_dmamap_arg ctx;
+	int error;
+
+	if (m == NULL) {
+		m_new = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
+		if (m_new == NULL)
+			return (ENOBUFS);
+		m_new-&gt;m_len = m_new-&gt;m_pkthdr.len = MCLBYTES;
+	} else {
+		m_new = m;
+		m_new-&gt;m_len = m_new-&gt;m_pkthdr.len = MCLBYTES;
+		m_new-&gt;m_data = m_new-&gt;m_ext.ext_buf;
+	}
+
+	if ((sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG) == 0)
+		m_adj(m_new, ETHER_ALIGN);
+	sc-&gt;bge_cdata.bge_rx_std_chain[i] = m_new;
+	r = &amp;sc-&gt;bge_ldata.bge_rx_std_ring[i];
+	ctx.bge_maxsegs = 1;
+	ctx.sc = sc;
+	error = bus_dmamap_load(sc-&gt;bge_cdata.bge_mtag,
+	    sc-&gt;bge_cdata.bge_rx_std_dmamap[i], mtod(m_new, void *),
+	    m_new-&gt;m_len, bge_dma_map_addr, &amp;ctx, BUS_DMA_NOWAIT);
+	if (error || ctx.bge_maxsegs == 0) {
+		if (m == NULL) {
+			sc-&gt;bge_cdata.bge_rx_std_chain[i] = NULL;
+			m_freem(m_new);
+		}
+		return (ENOMEM);
+	}
+	r-&gt;bge_addr.bge_addr_lo = BGE_ADDR_LO(ctx.bge_busaddr);
+	r-&gt;bge_addr.bge_addr_hi = BGE_ADDR_HI(ctx.bge_busaddr);
+	r-&gt;bge_flags = BGE_RXBDFLAG_END;
+	r-&gt;bge_len = m_new-&gt;m_len;
+	r-&gt;bge_idx = i;
+
+	bus_dmamap_sync(sc-&gt;bge_cdata.bge_mtag,
+	    sc-&gt;bge_cdata.bge_rx_std_dmamap[i],
+	    BUS_DMASYNC_PREREAD);
+
+	return (0);
+}
+
+/*
+ * Initialize a jumbo receive ring descriptor. This allocates
+ * a jumbo buffer from the pool managed internally by the driver.
+ */
+static int
+bge_newbuf_jumbo(struct bge_softc *sc, int i, struct mbuf *m)
+{
+	bus_dma_segment_t segs[BGE_NSEG_JUMBO];
+	struct bge_extrx_bd *r;
+	struct mbuf *m_new = NULL;
+	int nsegs;
+	int error;
+
+	if (m == NULL) {
+		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
+		if (m_new == NULL)
+			return (ENOBUFS);
+
+		m_cljget(m_new, M_DONTWAIT, MJUM9BYTES);
+		if (!(m_new-&gt;m_flags &amp; M_EXT)) {
+			m_freem(m_new);
+			return (ENOBUFS);
+		}
+		m_new-&gt;m_len = m_new-&gt;m_pkthdr.len = MJUM9BYTES;
+	} else {
+		m_new = m;
+		m_new-&gt;m_len = m_new-&gt;m_pkthdr.len = MJUM9BYTES;
+		m_new-&gt;m_data = m_new-&gt;m_ext.ext_buf;
+	}
+
+	if ((sc-&gt;bge_flags &amp; BGE_FLAG_RX_ALIGNBUG) == 0)
+		m_adj(m_new, ETHER_ALIGN);
+
+	error = bus_dmamap_load_mbuf_sg(sc-&gt;bge_cdata.bge_mtag_jumbo,
+	    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i],
+	    m_new, segs, &amp;nsegs, BUS_DMA_NOWAIT);
+	if (error) {
+		if (m == NULL)
+			m_freem(m_new);
+		return (error);
+	}
+	sc-&gt;bge_cdata.bge_rx_jumbo_chain[i] = m_new;
+
+	/*
+	 * Fill in the extended RX buffer descriptor.
+	 */
+	r = &amp;sc-&gt;bge_ldata.bge_rx_jumbo_ring[i];
+	r-&gt;bge_flags = BGE_RXBDFLAG_JUMBO_RING | BGE_RXBDFLAG_END;
+	r-&gt;bge_idx = i;
+	r-&gt;bge_len3 = r-&gt;bge_len2 = r-&gt;bge_len1 = 0;
+	switch (nsegs) {
+	case 4:
+		r-&gt;bge_addr3.bge_addr_lo = BGE_ADDR_LO(segs[3].ds_addr);
+		r-&gt;bge_addr3.bge_addr_hi = BGE_ADDR_HI(segs[3].ds_addr);
+		r-&gt;bge_len3 = segs[3].ds_len;
+	case 3:
+		r-&gt;bge_addr2.bge_addr_lo = BGE_ADDR_LO(segs[2].ds_addr);
+		r-&gt;bge_addr2.bge_addr_hi = BGE_ADDR_HI(segs[2].ds_addr);
+		r-&gt;bge_len2 = segs[2].ds_len;
+	case 2:
+		r-&gt;bge_addr1.bge_addr_lo = BGE_ADDR_LO(segs[1].ds_addr);
+		r-&gt;bge_addr1.bge_addr_hi = BGE_ADDR_HI(segs[1].ds_addr);
+		r-&gt;bge_len1 = segs[1].ds_len;
+	case 1:
+		r-&gt;bge_addr0.bge_addr_lo = BGE_ADDR_LO(segs[0].ds_addr);
+		r-&gt;bge_addr0.bge_addr_hi = BGE_ADDR_HI(segs[0].ds_addr);
+		r-&gt;bge_len0 = segs[0].ds_len;
+		break;
+	default:
+		panic(&quot;%s: %d segments\n&quot;, __func__, nsegs);
+	}
+
+	bus_dmamap_sync(sc-&gt;bge_cdata.bge_mtag,
+	    sc-&gt;bge_cdata.bge_rx_jumbo_dmamap[i],
+	    BUS_DMASYNC_PREREAD);
+
+	return (0);
+}
+
+/*
+ * The standard receive ring has 512 entries in it. At 2K per mbuf cluster,
+ * that's 1MB or memory, which is a lot. For now, we fill only the first
+ * 256 ring entries and hope that our CPU is fast enough to keep up with
+ * the NIC.
+ */
+static int
+bge_init_rx_ring_std(struct bge_softc *sc)
+{
+	int i;
+
+	for (i = 0; i &lt; BGE_SSLOTS; i++) {
+		if (bge_newbuf_std(sc, i, NULL) == ENOBUFS)
+			return (ENOBUFS);
+	};
+
+	bus_dmamap_sync(sc-&gt;bge_cdata.bge_rx_std_ring_tag,
+	    sc-&gt;bge_cdata.bge_rx_std_ring_map,
+	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+	sc-&gt;bge_std = i - 1;
+	CSR_WRITE_4(sc, BGE_MBX_RX_STD_PROD_LO, sc-&gt;bge_std);
+
+	return (0);
+}
+
+static void
+bge_free_rx_ring_std(struct bge_softc *sc)
+{
+	int i;
+
+	for (i = 0; i &lt; BGE_STD_RX_RING_CNT; i++) {

[... truncated: 11911 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005039.html">[Haiku-commits] r23123 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="005043.html">[Haiku-commits] r23124 -	in	haiku/trunk/src/add-ons/kernel/drivers/network: .	broadcom_bcm570x	broadcom_bcm570x/dev	broadcom_bcm570x/dev/bge broadcom_bcm570x/dev/mii	nforce	nforce/dev nforce/dev/mii nforce/dev/nfe
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5040">[ date ]</a>
              <a href="thread.html#5040">[ thread ]</a>
              <a href="subject.html#5040">[ subject ]</a>
              <a href="author.html#5040">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
