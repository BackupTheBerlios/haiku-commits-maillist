<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r19897 - in	haiku/trunk/src/add-ons/kernel/file_systems: . ntfs ntfs/libntfs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r19897%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/file_systems%3A%20.%20ntfs%20ntfs/libntfs&In-Reply-To=%3C200701220813.l0M8DHPE021239%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000365.html">
   <LINK REL="Next"  HREF="000367.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r19897 - in	haiku/trunk/src/add-ons/kernel/file_systems: . ntfs ntfs/libntfs</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r19897%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/file_systems%3A%20.%20ntfs%20ntfs/libntfs&In-Reply-To=%3C200701220813.l0M8DHPE021239%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r19897 - in	haiku/trunk/src/add-ons/kernel/file_systems: . ntfs ntfs/libntfs">axeld at mail.berlios.de
       </A><BR>
    <I>Mon Jan 22 09:13:17 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000365.html">[Haiku-commits] r19896 - haiku/trunk/src/kits/tracker
</A></li>
        <LI>Next message: <A HREF="000367.html">[Haiku-commits] r19898 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#366">[ date ]</a>
              <a href="thread.html#366">[ thread ]</a>
              <a href="subject.html#366">[ subject ]</a>
              <a href="author.html#366">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-01-22 09:13:07 +0100 (Mon, 22 Jan 2007)
New Revision: 19897
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=19897&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=19897&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/Jamfile
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/Jamfile
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/attrib.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/attrib.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/attrlist.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/attrlist.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/bitmap.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/bitmap.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/bootsect.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/bootsect.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/collate.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/collate.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/compat.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/compat.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/compress.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/compress.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/config.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/debug.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/debug.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/device.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/device.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/device_io.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/device_io.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/dir.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/endians.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/index.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/index.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/inode.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/layout.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/lcnalloc.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/lcnalloc.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/list.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/logfile.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/logfile.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/logging.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/logging.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/mft.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/mft.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/misc.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/misc.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/mst.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/mst.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/ntfstime.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/runlist.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/runlist.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/security.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/security.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/support.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/types.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/unistr.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/unistr.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/unix_io.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/version.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/version.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/volume.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/libntfs/win32_io.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/lock.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/mime_table.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/mime_table.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/ntfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/ntfsdir.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/ntfsdir.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/utils.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/utils.h
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/volume_util.c
   haiku/trunk/src/add-ons/kernel/file_systems/ntfs/volume_util.h
Modified:
   haiku/trunk/src/add-ons/kernel/file_systems/Jamfile
Log:
Added NTFS file system add-on written by Troeglazov Gerasim (a.k.a. 3dEyes**).
It's based on ntfs-3g-0.20070102-BETA, and therefore under the GPL license.
Writing is currently disabled for safety reasons, and you'll have to mount
it manually, as the identify hooks are not yet implemented.
Thanks a lot for your work!


Modified: haiku/trunk/src/add-ons/kernel/file_systems/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/Jamfile	2007-01-21 21:02:45 UTC (rev 19896)
+++ haiku/trunk/src/add-ons/kernel/file_systems/Jamfile	2007-01-22 08:13:07 UTC (rev 19897)
@@ -6,3 +6,5 @@
 SubInclude HAIKU_TOP src add-ons kernel file_systems iso9660 ;
 SubInclude HAIKU_TOP src add-ons kernel file_systems nfs ;
 SubInclude HAIKU_TOP src add-ons kernel file_systems udf ;
+
+SubIncludeGPL HAIKU_TOP src add-ons kernel file_systems ntfs ;

Added: haiku/trunk/src/add-ons/kernel/file_systems/ntfs/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ntfs/Jamfile	2007-01-21 21:02:45 UTC (rev 19896)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ntfs/Jamfile	2007-01-22 08:13:07 UTC (rev 19897)
@@ -0,0 +1,28 @@
+SubDir HAIKU_TOP src add-ons kernel file_systems ntfs ;
+
+SubDirHdrs [ FDirName $(SUBDIR) libntfs ] ;
+
+SubDirCcFlags -DHAVE_CONFIG_H=1 -D_READ_ONLY_=1 ;
+SubDirC++Flags -DHAVE_CONFIG_H=1 -D_READ_ONLY_=1 ;
+
+UsePrivateHeaders kernel ;
+
+KernelAddon ntfs :
+	attributes.c
+	mime_table.c
+	utils.c
+	ntfsdir.c
+	volume_util.c
+	fs_func.c
+	kernel_interface.cpp
+	kernel_cpp.cpp
+	:
+	libntfs.a
+	;
+
+SEARCH on [ FGristFiles
+		kernel_cpp.cpp
+	] = [ FDirName $(HAIKU_TOP) src system kernel util ] ;
+
+SubIncludeGPL HAIKU_TOP src add-ons kernel file_systems ntfs libntfs ;
+

Added: haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.c	2007-01-21 21:02:45 UTC (rev 19896)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.c	2007-01-22 08:13:07 UTC (rev 19897)
@@ -0,0 +1,336 @@
+/*
+	Copyright 1999-2001, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+*/
+/* attributes.c
+ * handles mime type information for ntfs
+ * gets/sets mime information in vnode
+ */
+
+
+#define MIME_STRING_TYPE 'MIMS'
+
+#include &lt;SupportDefs.h&gt;
+#include &lt;KernelExport.h&gt;
+
+#include &lt;dirent.h&gt;
+#include &lt;fs_attr.h&gt;
+#include &lt;string.h&gt;
+#include &lt;malloc.h&gt;
+
+#include &quot;ntfs.h&quot;
+#include &quot;attributes.h&quot;
+#include &quot;mime_table.h&quot;
+
+int32 kBeOSTypeCookie = 0x1234;
+
+status_t set_mime(vnode *node, const char *filename)
+{
+	struct ext_mime *p;
+	int32 namelen, ext_len;
+
+	ERRPRINT(&quot;set_mime - for [%s]\n&quot;, filename);
+
+	node-&gt;mime = NULL;
+
+	namelen = strlen(filename);
+
+	for (p=mimes;p-&gt;extension;p++) {
+		ext_len = strlen(p-&gt;extension);
+
+		if (namelen &lt;= ext_len)
+			continue;
+
+		if (filename[namelen-ext_len-1] != '.')
+			continue;
+		
+		if (!strcasecmp(filename + namelen - ext_len, p-&gt;extension))
+			break;
+	}
+
+	node-&gt;mime = p-&gt;mime;
+
+	return B_NO_ERROR;
+}
+
+
+status_t 
+fs_open_attrib_dir(void *_ns, void *_node, void **_cookie)
+{
+	nspace *ns = (nspace *)_ns;
+	int	result = B_NO_ERROR;
+
+	ERRPRINT(&quot;fs_open_attrdir - ENTER\n&quot;);
+
+	LOCK_VOL(ns);
+
+	if ((*_cookie = malloc(sizeof(uint32))) == NULL) {
+		result = ENOMEM;
+		goto	exit;
+	}
+	
+	*(int32 *)(*_cookie) = 0;
+	
+exit:
+
+	ERRPRINT(&quot;fs_open_attrdir - EXIT, result is %s\n&quot;, strerror(result));
+	
+	UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+status_t 
+fs_close_attrib_dir(void *_ns, void *_node, void *_cookie)
+{
+	nspace *ns = (nspace *)_ns;
+	
+	ERRPRINT(&quot;fs_close_attrdir - ENTER\n&quot;);
+
+	LOCK_VOL(ns);
+
+	*(int32 *)_cookie = 1;
+	
+	ERRPRINT(&quot;fs_close_attrdir - EXIT\n&quot;);
+	
+	UNLOCK_VOL(ns);
+	
+	return B_NO_ERROR;
+}
+
+
+status_t 
+fs_free_attrib_dir_cookie(void *_ns, void *_node, void *_cookie)
+{
+	nspace *ns = (nspace *)_ns;
+	int	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+		
+	ERRPRINT(&quot;fs_free_attrib_dir_cookie - ENTER\n&quot;);
+
+	if (_cookie == NULL) {
+		ERRPRINT(&quot;fs_free_attrib_dir_cookie - error: called with null cookie\n&quot;);
+		result =  EINVAL;
+		goto	exit;
+	}
+	
+	*(int32 *)_cookie = 0x87654321;
+	free(_cookie);
+
+exit:
+
+	ERRPRINT(&quot;fs_free_attrib_dir_cookie - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+
+status_t 
+fs_rewind_attrib_dir(void *_ns, void *_node, void *_cookie)
+{
+	nspace *ns = (nspace *)_ns;
+	int	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_rewind_attrcookie  - ENTER\n&quot;);
+
+	if (_cookie == NULL) {
+		ERRPRINT(&quot;fs_rewind_attrcookie - error: fs_rewind_attrcookie called with null cookie\n&quot;);
+		result =  EINVAL;
+		goto	exit;
+	}
+	
+	*(uint32 *)_cookie = 0;
+
+exit:
+
+	ERRPRINT(&quot;fs_rewind_attrcookie - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+
+status_t 
+fs_read_attrib_dir(void *_ns, void *_node, void *_cookie, struct dirent *entry, size_t bufsize, uint32 *num)
+{
+	nspace *ns = (nspace *)_ns;
+	vnode *node = (vnode *)_node;
+	int32 *cookie = (int32 *)_cookie;
+
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_read_attrdir - ENTER\n&quot;);
+
+	*num = 0;
+
+	if ((*cookie == 0) &amp;&amp; (node-&gt;mime)) {
+		*num = 1;
+		
+		entry-&gt;d_ino = node-&gt;vnid;
+		entry-&gt;d_dev = ns-&gt;id;
+		entry-&gt;d_reclen = 10;
+		strcpy(entry-&gt;d_name, &quot;BEOS:TYPE&quot;);
+	}
+
+	*cookie = 1;
+
+	ERRPRINT(&quot;fs_read_attrdir - EXIT\n&quot;);
+
+	UNLOCK_VOL(ns);
+	
+	return B_NO_ERROR;
+}
+
+
+status_t
+fs_open_attrib(void *_ns, void *_node, const char *name, int openMode, fs_cookie *_cookie)
+{
+	nspace *ns = (nspace *)_ns;
+	vnode *node = (vnode *)_node;
+	int	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_open_attrib - ENTER\n&quot;);
+
+	if (strcmp(name, &quot;BEOS:TYPE&quot;)) {
+		result = ENOENT;
+		goto	exit;
+	}
+	
+	if (node-&gt;mime == NULL)	{
+		result = ENOENT;
+		goto	exit;
+	}
+
+	*_cookie = &kBeOSTypeCookie;
+	
+exit:
+
+	ERRPRINT(&quot;fs_open_attrib - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+		
+	return result;
+}
+
+
+status_t
+fs_close_attrib(void *_ns, void *_node, fs_cookie cookie)
+{
+	return B_NO_ERROR;
+}
+
+
+status_t
+fs_free_attrib_cookie(void *_ns, void *_node, fs_cookie cookie)
+{
+	return B_NO_ERROR;
+}
+
+
+status_t 
+fs_read_attrib_stat(void *_ns, void *_node, fs_cookie _cookie, struct stat *stat)
+{
+	nspace *ns = (nspace *)_ns;
+	vnode *node = (vnode *)_node;
+	int	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_read_attr_stat - ENTER\n&quot;);
+
+	if (_cookie != &amp;kBeOSTypeCookie) {
+		result = ENOENT;
+		goto	exit;
+	}
+
+	if (node-&gt;mime == NULL) {
+		result = ENOENT;
+		goto	exit;
+	}
+	
+	stat-&gt;st_type = MIME_STRING_TYPE;
+	stat-&gt;st_size = strlen(node-&gt;mime) + 1;
+
+exit:
+
+	ERRPRINT(&quot;fs_read_attrib_stat - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+	
+	return B_NO_ERROR;
+}
+
+
+status_t 
+fs_read_attrib(void *_ns, void *_node, fs_cookie _cookie, off_t pos, void *buffer, size_t *_length)
+{
+	nspace *ns = (nspace *)_ns;
+	vnode *node = (vnode *)_node;
+	int	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_read_attr - ENTER\n&quot;);
+
+	if (_cookie != &amp;kBeOSTypeCookie) {
+		result = ENOENT;
+		goto	exit;
+	}
+			
+	if (node-&gt;mime == NULL) {
+		result = ENOENT;
+		goto	exit;
+	}
+	
+	if ((pos &lt; 0) || (pos &gt; strlen(node-&gt;mime))) {
+		result = EINVAL;
+		goto	exit;
+	}
+
+	strncpy(buffer, node-&gt;mime + pos, *_length - 1);
+	((char *)buffer)[*_length - 1] = 0;
+	*_length = strlen(buffer) + 1;
+	
+exit:
+	
+	ERRPRINT(&quot;fs_read_attr - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+
+status_t
+fs_write_attrib(void *_ns, void *_node, fs_cookie _cookie, off_t pos,
+	const void *buffer, size_t *_length)
+{
+	nspace *ns = (nspace *)_ns;
+	int	result = B_NO_ERROR;
+	
+	LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_write_attr - ENTER\n&quot;);
+
+	*_length = 0;
+
+	if (_cookie != &amp;kBeOSTypeCookie) {
+		result = ENOSYS;
+		goto	exit;
+	}
+exit:
+	
+	ERRPRINT(&quot;fs_write_attrib - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+		
+	return result;
+}

Added: haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.h	2007-01-21 21:02:45 UTC (rev 19896)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ntfs/attributes.h	2007-01-22 08:13:07 UTC (rev 19897)
@@ -0,0 +1,29 @@
+/*
+	Copyright 1999-2001, Be Incorporated.   All Rights Reserved.
+	This file may be used under the terms of the Be Sample Code License.
+*/
+/* attributes.h
+ * handles mime type information for ntfs
+ * gets/sets mime information in vnode
+ */
+ 
+#ifndef _fs_ATTR_H_
+#define _fs_ATTR_H_
+
+#include &lt;fs_attr.h&gt;
+
+status_t set_mime(vnode *node, const char *filename);
+
+status_t fs_open_attrib_dir(void *_vol, void *_node, void **_cookie);
+status_t fs_close_attrib_dir(void *_vol, void *_node, void *_cookie);
+status_t fs_free_attrib_dir_cookie(void *_vol, void *_node, void *_cookie);
+status_t fs_rewind_attrib_dir(void *_vol, void *_node, void *_cookie);
+status_t fs_read_attrib_dir(void *_vol, void *_node, void *_cookie, struct dirent *buf, size_t bufsize, uint32 *num);
+status_t fs_open_attrib(void *_vol, void *_node, const char *name, int openMode,fs_cookie *_cookie);
+status_t fs_close_attrib(void *_vol, void *_node, fs_cookie cookie);
+status_t fs_free_attrib_cookie(void *_vol, void *_node, fs_cookie cookie);
+status_t fs_read_attrib_stat(void *_vol, void *_node, fs_cookie _cookie, struct stat *stat);
+status_t fs_read_attrib(void *_vol, void *_node, fs_cookie _cookie, off_t pos,void *buffer, size_t *_length);
+status_t fs_write_attrib(void *_vol, void *_node, fs_cookie _cookie, off_t pos,	const void *buffer, size_t *_length);
+
+#endif

Added: haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c	2007-01-21 21:02:45 UTC (rev 19896)
+++ haiku/trunk/src/add-ons/kernel/file_systems/ntfs/fs_func.c	2007-01-22 08:13:07 UTC (rev 19897)
@@ -0,0 +1,1701 @@
+/*
+ * Copyright (c) 2000-2004 Anton Altaparmakov
+ * Copyright (c) 2002-2006 Szabolcs Szakacsits
+ *
+ * Copyright (c) 2006 Troeglazov Gerasim (3dEyes**)
+ *
+ * This program/include file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program/include file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+ * Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program (in the main directory of the Linux-NTFS distribution in the
+ * file COPYING); if not, write to the Free Software Foundation,Inc., 59 Temple
+ * Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+ 
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+#include &lt;time.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;dirent.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;KernelExport.h&gt;
+#include &lt;time.h&gt;
+#include &lt;malloc.h&gt;
+
+#include &lt;KernelExport.h&gt;
+#include &lt;NodeMonitor.h&gt;
+#include &lt;fs_interface.h&gt;
+#include &lt;fs_cache.h&gt;
+#include &lt;fs_attr.h&gt;
+#include &lt;fs_info.h&gt;
+#include &lt;fs_index.h&gt;
+#include &lt;fs_query.h&gt;
+#include &lt;fs_volume.h&gt;
+
+#include &quot;ntfs.h&quot;
+#include &quot;attributes.h&quot;
+#include &quot;lock.h&quot;
+#include &quot;volume_util.h&quot;
+
+status_t	fs_mount( mount_id nsid, const char *device, ulong flags, const char *args, void **data, vnode_id *vnid );
+status_t	fs_unmount(void *_ns);
+status_t	fs_rfsstat(void *_ns, struct fs_info *);
+status_t  	fs_wfsstat(void *_vol, const struct fs_info *fss, uint32 mask);
+status_t 	fs_sync(void *_ns);
+status_t	fs_walk(void *_ns, void *_base, const char *file, vnode_id *vnid,int *_type);
+status_t	fs_get_vnode_name(void *_ns, void *_node, char *buffer, size_t bufferSize);
+status_t	fs_read_vnode(void *_ns, vnode_id vnid, void **_node, bool reenter);
+status_t	fs_write_vnode(void *_ns, void *_node, bool reenter);
+status_t    fs_remove_vnode( void *_ns, void *_node, bool reenter );
+status_t	fs_access( void *ns, void *node, int mode );
+status_t	fs_rstat(void *_ns, void *_node, struct stat *st);
+status_t	fs_wstat(void *_vol, void *_node, const struct stat *st, uint32 mask);
+status_t   	fs_create(void *_ns, void *_dir, const char *name, int omode, int perms, void **_cookie, vnode_id *_vnid);
+status_t	fs_open(void *_ns, void *_node, int omode, void **cookie);
+status_t	fs_close(void *ns, void *node, void *cookie);
+status_t	fs_free_cookie(void *ns, void *node, void *cookie);
+status_t	fs_read(void *_ns, void *_node, void *cookie, off_t pos, void *buf, size_t *len);
+status_t	fs_write(void *ns, void *node, void *cookie, off_t pos, const void *buf, size_t *len);
+status_t	fs_mkdir(void *_ns, void *_node, const char *name,	int perms, vnode_id *_vnid);
+status_t 	fs_rmdir(void *_ns, void *dir, const char *name);
+status_t	fs_opendir(void* _ns, void* _node, void** cookie);
+status_t  	fs_readdir( void *_ns, void *_node, void *_cookie, struct dirent *buf, size_t bufsize, uint32 *num );
+status_t	fs_rewinddir(void *_ns, void *_node, void *cookie);
+status_t	fs_closedir(void *_ns, void *_node, void *cookie);
+status_t	fs_free_dircookie(void *_ns, void *_node, void *cookie);
+status_t 	fs_readlink(void *_ns, void *_node, char *buf, size_t *bufsize);
+status_t 	fs_fsync(void *_ns, void *_node);
+status_t    fs_rename(void *_ns, void *_odir, const char *oldname, void *_ndir, const char *newname);
+status_t    fs_unlink(void *_ns, void *_node, const char *name);
+status_t	fs_create_symlink(void *_ns, void *_dir, const char *name, const char *target, int mode);
+
+void 		fs_free_identify_partition_cookie(partition_data *partition, void *_cookie);
+status_t	fs_scan_partition(int fd, partition_data *partition, void *_cookie);
+float		fs_identify_partition(int fd, partition_data *partition, void **_cookie);
+
+#ifndef _READ_ONLY_
+static status_t do_unlink(nspace *vol, vnode *dir, const char *name, bool isdir);
+#endif
+
+//not emplemented now
+float
+fs_identify_partition(int fd, partition_data *partition, void **_cookie)
+{
+	return 0.0f;
+}
+
+//not emplemented now
+status_t
+fs_scan_partition(int fd, partition_data *partition, void *_cookie)
+{
+	return B_OK;
+}
+
+//not emplemented now
+void
+fs_free_identify_partition_cookie(partition_data *partition, void *_cookie)
+{
+}
+
+
+status_t 
+fs_mount( mount_id nsid, const char *device, ulong flags, const char *args, void **data, vnode_id *vnid )
+{
+	nspace		*ns;
+	vnode		*newNode = NULL;
+	char 		lockname[32];
+	status_t	result = B_NO_ERROR;
+
+	ERRPRINT(&quot;fs_mount - ENTER\n&quot;);
+			
+	ns = ntfs_malloc(sizeof(nspace));
+	if (!ns) {
+		result = ENOMEM;
+		goto	exit;
+	}
+			
+	*ns = (nspace) {
+		.state = NF_FreeClustersOutdate | NF_FreeMFTOutdate,
+		.uid = 0,
+		.gid = 0,
+		.fmask = 0177,
+		.dmask = 0777,
+		.show_sys_files = false,
+	};
+		
+	strcpy(ns-&gt;devicePath,device);
+		
+	sprintf(lockname, &quot;ntfs_lock %lx&quot;, ns-&gt;id);
+	if ((result = recursive_lock_init(&amp;(ns-&gt;vlock), lockname)) != 0) {
+			ERRPRINT(&quot;fs_mount - error creating lock (%s)\n&quot;, strerror(result));
+			goto exit;
+	}
+	
+	ns-&gt;ntvol=utils_mount_volume(device,0,true);
+	if(ns-&gt;ntvol!=NULL)
+		result = B_NO_ERROR;
+	else
+		result = errno;
+				
+	if (result == B_NO_ERROR) {
+		*vnid = FILE_root;
+		*data = (void*)ns;
+		ns-&gt;id = nsid;
+		
+		newNode = (vnode*)ntfs_calloc( sizeof(vnode) );
+		if ( newNode == NULL )
+			result = ENOMEM;
+		else {
+			
+			newNode-&gt;vnid = *vnid;
+			newNode-&gt;parent_vnid = -1;
+			
+			result = publish_vnode( nsid, *vnid, (void*)newNode );
+			if ( result != B_NO_ERROR )	{
+				free( ns );
+				result = EINVAL;
+				goto	exit;
+			}
+			else {
+				result = B_NO_ERROR;
+				ntfs_mark_free_space_outdated(ns);	
+				ntfs_calc_free_space(ns);				
+			}			
+		}
+	}
+		
+exit:
+
+	ERRPRINT(&quot;fs_mount - EXIT, result code is %s\n&quot;, strerror(result));
+	
+	return result;
+}
+
+status_t 
+fs_unmount(void *_ns)
+{
+	nspace		*ns = (nspace*)_ns;
+	status_t	result = B_NO_ERROR;
+	
+	ERRPRINT(&quot;fs_unmount - ENTER\n&quot;);
+	
+	ntfs_device_umount( ns-&gt;ntvol, true );
+	
+	recursive_lock_destroy(&amp;(ns-&gt;vlock));
+	
+	free( ns );
+
+	ERRPRINT(&quot;fs_unmount - EXIT, result is %s\n&quot;, strerror(result));
+	
+	return result;
+}
+
+status_t
+fs_rfsstat( void *_ns, struct fs_info * fss )
+{
+	nspace	*ns = (nspace*)_ns;
+	int 	i;
+	
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_rfsstat - ENTER\n&quot;);
+	
+	ntfs_calc_free_space(ns);
+		
+	fss-&gt;dev = ns-&gt;id;
+	fss-&gt;root = FILE_root;
+	fss-&gt;flags = B_FS_IS_PERSISTENT|B_FS_HAS_MIME|B_FS_HAS_ATTR;
+	fss-&gt;block_size = ns-&gt;ntvol-&gt;cluster_size;
+	fss-&gt;io_size = 65536;
+	fss-&gt;total_blocks = ns-&gt;ntvol-&gt;nr_clusters;
+	fss-&gt;free_blocks = ns-&gt;free_clusters;
+	strncpy( fss-&gt;device_name, ns-&gt;devicePath, sizeof(fss-&gt;device_name));
+	strncpy( fss-&gt;volume_name, ns-&gt;ntvol-&gt;vol_name, sizeof(fss-&gt;volume_name) );
+	
+	for (i = strlen(fss-&gt;volume_name)-1; i &gt;=0 ; i--)
+		if (fss-&gt;volume_name[i] != ' ')
+			break;	
+	if (i &lt; 0)
+		strcpy(fss-&gt;volume_name, &quot;NTFS Untitled&quot;);
+	else
+		fss-&gt;volume_name[i + 1] = 0;
+					
+	strcpy( fss-&gt;fsh_name, &quot;NTFS&quot; );
+
+	ERRPRINT(&quot;fs_rfsstat - EXIT\n&quot;);
+
+	UNLOCK_VOL(ns);
+
+	return B_NO_ERROR;
+}
+
+#ifndef _READ_ONLY_
+status_t
+fs_wfsstat(void *_vol, const struct fs_info * fss, uint32 mask)
+{
+	nspace* 	ns = (nspace*)_vol;
+	status_t	result = B_NO_ERROR;
+
+	LOCK_VOL(ns);
+
+	if (mask &amp; FS_WRITE_FSINFO_NAME) {	
+		result = ntfs_change_label( ns-&gt;ntvol,  (char*)fss-&gt;volume_name );
+		goto exit;
+	}
+	
+exit:
+
+	UNLOCK_VOL(ns);
+
+	return result;
+}
+#endif
+
+status_t
+fs_walk(void *_ns, void *_base, const char *file, vnode_id *vnid,int *_type)
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode		*baseNode = (vnode*)_base;
+	vnode		*newNode = NULL;
+	ntfschar 	*unicode = NULL;
+	ntfs_inode 	*bi = NULL;
+	status_t	result = B_NO_ERROR;
+	int			len;
+
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_walk - ENTER : find for \&quot;%s\&quot;\n&quot;,file);
+
+	if(ns == NULL || _base == NULL || file == NULL || vnid == NULL) {
+	  result = EINVAL;
+	  goto	exit;
+	 }
+
+	if ( !strcmp( file, &quot;.&quot; ) )	{
+		*vnid = baseNode-&gt;vnid;
+		if ( get_vnode( ns-&gt;id, *vnid, (void**)&amp;newNode ) != 0 )
+			result = ENOENT;
+	} else if ( !strcmp( file, &quot;..&quot; ) &amp;&amp; baseNode-&gt;vnid != FILE_root ) {
+		*vnid = baseNode-&gt;parent_vnid;
+		if ( get_vnode( ns-&gt;id, *vnid, (void**)&amp;newNode ) != 0 )
+			result = ENOENT;
+	} else {
+			unicode = ntfs_calloc(MAX_PATH);
+			len = ntfs_mbstoucs(file, &amp;unicode, MAX_PATH);
+			if (len &lt; 0) {
+				result = EILSEQ;
+				goto exit;
+		 	}
+		
+			bi = ntfs_inode_open(ns-&gt;ntvol, baseNode-&gt;vnid);
+			if(!bi) {
+				result = ENOENT;
+				goto exit;
+			}
+						
+			*vnid = MREF( ntfs_inode_lookup_by_name(bi, unicode, len) );
+			
+			ntfs_inode_close(bi);				
+			free(unicode);
+		
+			if ( *vnid == (u64) -1 ) {
+				result = EINVAL;
+				goto exit;
+			}
+
+			if( get_vnode( ns-&gt;id, *vnid, (void**)&amp;newNode ) !=0 )
+				result = ENOENT;
+	}
+
+exit:
+
+	ERRPRINT(&quot;fs_walk - EXIT, result is %s\n&quot;, strerror(result));
+
+	UNLOCK_VOL(ns);
+
+	return result;
+}
+
+
+status_t
+fs_get_vnode_name(void *_ns, void *_node, char *buffer, size_t bufferSize)
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode   	*node = (vnode*)_node;
+	ntfs_inode	*ni=NULL;
+	status_t	result = B_NO_ERROR;
+	
+	char 	path[MAX_PATH];
+	char 	*name;	
+	
+	LOCK_VOL(ns);
+	
+	ni = ntfs_inode_open(ns-&gt;ntvol, node-&gt;vnid);		
+	if(ni==NULL) {
+			result = ENOENT;
+			goto exit;
+	}	
+	
+	if(utils_inode_get_name(ni, path, MAX_PATH)==0) {
+		result = EINVAL;
+		goto	exit;
+	}
+	name = strrchr(path, '/');
+	name++;
+	
+	strlcpy(buffer, name, bufferSize);
+	
+exit:
+
+	if(ni)
+		ntfs_inode_close(ni);
+		
+	UNLOCK_VOL(ns);
+
+	return result;
+}
+
+
+
+
+status_t 
+fs_read_vnode(void *_ns, vnode_id vnid, void **node, bool reenter)
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode		*newNode = NULL;
+	ntfs_inode	*ni=NULL;
+	status_t	result = B_NO_ERROR;
+	
+	if ( !reenter )
+		LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_read_vnode - ENTER\n&quot;);
+	
+	newNode = (vnode*)ntfs_calloc( sizeof(vnode) );
+	if ( newNode != NULL ) {
+		char *name = NULL;
+		
+		ni = ntfs_inode_open(ns-&gt;ntvol, vnid);		
+		if(ni==NULL) {
+			result = ENOENT;
+			goto exit;
+		 }	
+		 
+		newNode-&gt;vnid = vnid;
+		newNode-&gt;parent_vnid = ntfs_get_parent_ref(ni);
+		
+		if( ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY )
+			set_mime(newNode, &quot;.***&quot;);
+		else {		
+			name = (char*)malloc(MAX_PATH);
+			if(name!=NULL) {			
+				if(utils_inode_get_name(ni, name,MAX_PATH)==1)
+					set_mime(newNode, name);
+				free(name);
+			}
+		}		
+		
+		*node = (void*)newNode;
+	}
+	else
+		result = ENOMEM;
+exit:
+	
+	if(ni)
+		ntfs_inode_close(ni);
+		
+	ERRPRINT(&quot;fs_read_vnode - EXIT, result is %s\n&quot;, strerror(result));
+	
+	if ( !reenter )
+		UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+status_t
+fs_write_vnode( void *_ns, void *_node, bool reenter )
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode		*node = (vnode*)_node;
+	status_t	result = B_NO_ERROR;
+	
+	if ( !reenter )
+		LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_write_vnode - ENTER (%Ld)\n&quot;, node-&gt;vnid);
+
+	if (node)
+		free( node );
+	
+	ERRPRINT(&quot;fs_write_vnode - EXIT\n&quot;);
+	
+	if ( !reenter )
+		UNLOCK_VOL(ns);
+	
+	return result;
+}
+
+#ifndef _READ_ONLY_
+status_t
+fs_remove_vnode( void *_ns, void *_node, bool reenter )
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode		*node = (vnode*)_node;
+	status_t	result = B_NO_ERROR;
+	
+	if ( !reenter )
+		LOCK_VOL(ns);
+	
+	ERRPRINT(&quot;fs_remove_vnode - ENTER (%Ld)\n&quot;, node-&gt;vnid);
+			
+	if(node)
+		free(node);
+				
+	ERRPRINT(&quot;fs_remove_vnode - EXIT, result is %s\n&quot;, strerror(result));
+	
+	if ( !reenter )
+	 	UNLOCK_VOL(ns);
+	
+	return result;
+}
+#endif
+ 
+status_t
+fs_rstat( void *_ns, void *_node, struct stat *stbuf )
+{
+	nspace		*ns = (nspace*)_ns;
+	vnode		*node = (vnode*)_node;
+	ntfs_inode 	*ni = NULL;
+	ntfs_attr 	*na;
+	status_t	result = B_NO_ERROR;	
+	
+	LOCK_VOL(ns);
+
+	ERRPRINT(&quot;fs_rstat - ENTER:\n&quot;);	
+			
+	if(ns==NULL || node ==NULL ||stbuf==NULL) {
+		result = ENOENT;
+		goto exit;		
+	}
+	
+	ni = ntfs_inode_open(ns-&gt;ntvol, node-&gt;vnid);		
+	if(ni==NULL) {
+		result = ENOENT;
+		goto exit;
+	}
+	
+	stbuf-&gt;st_dev = ns-&gt;id;
+	stbuf-&gt;st_ino = MREF(ni-&gt;mft_no);
+	
+	if ( ni-&gt;mrec-&gt;flags &amp; MFT_RECORD_IS_DIRECTORY ) {
+		stbuf-&gt;st_mode = S_IFDIR | (0777 &amp; ~ns-&gt;dmask);
+		na = ntfs_attr_open(ni, AT_INDEX_ALLOCATION, NTFS_INDEX_I30, 4);
+		if (na) {
+			stbuf-&gt;st_size = na-&gt;data_size;
+			ntfs_attr_close(na);
+		} else {
+			stbuf-&gt;st_size = 0;
+		}
+		stbuf-&gt;st_nlink = 1; // Needed for correct find work. 
+	} else {
+		// Regular or Interix (INTX) file. 
+		stbuf-&gt;st_mode = S_IFREG;
+		stbuf-&gt;st_size = ni-&gt;data_size;
+		stbuf-&gt;st_nlink = le16_to_cpu(ni-&gt;mrec-&gt;link_count);
+
+		na = ntfs_attr_open(ni, AT_DATA, NULL,0);
+		if (!na) {
+			result = ENOENT;
+			goto exit;
+		}
+
+		stbuf-&gt;st_size = na-&gt;data_size;
+
+		if (!ni-&gt;flags &amp; FILE_ATTR_HIDDEN) {
+			if (na-&gt;data_size == 0)
+			stbuf-&gt;st_mode = S_IFIFO;
+		}
+
+		if (na-&gt;data_size &lt;= sizeof(INTX_FILE_TYPES) + sizeof(ntfschar) * MAX_PATH &amp;&amp; na-&gt;data_size &gt;sizeof(INTX_FILE_TYPES)) {
+			INTX_FILE *intx_file;
+
+			intx_file = ntfs_malloc(na-&gt;data_size);
+			if (!intx_file)	{
+				result = EINVAL;
+				ntfs_attr_close(na);
+				goto exit;
+			}
+			if (ntfs_attr_pread(na, 0, na-&gt;data_size,intx_file) != na-&gt;data_size) {
+				result = EINVAL;
+				free(intx_file);
+				ntfs_attr_close(na);
+				goto exit;
+			}
+			if (intx_file-&gt;magic == INTX_SYMBOLIC_LINK)
+				stbuf-&gt;st_mode = S_IFLNK;
+			free(intx_file);
+		}
+		ntfs_attr_close(na);
+		stbuf-&gt;st_mode |= (0777 &amp; ~ns-&gt;fmask);
+	}
+	stbuf-&gt;st_uid = ns-&gt;uid;
+	stbuf-&gt;st_gid = ns-&gt;gid;
+	stbuf-&gt;st_atime = ni-&gt;last_access_time;
+	stbuf-&gt;st_ctime = ni-&gt;last_mft_change_time;
+	stbuf-&gt;st_mtime = ni-&gt;last_data_change_time;
+	
+exit:
+
+	if(ni)
+		ntfs_inode_close(ni);
+		
+	ERRPRINT(&quot;fs_rstat - EXIT, result is %s\n&quot;, strerror(result));
+	
+	UNLOCK_VOL(ns);
+	
+	return result;
+
+}
+
+#ifndef _READ_ONLY_
+status_t

[... truncated: 33046 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000365.html">[Haiku-commits] r19896 - haiku/trunk/src/kits/tracker
</A></li>
	<LI>Next message: <A HREF="000367.html">[Haiku-commits] r19898 - haiku/trunk/src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#366">[ date ]</a>
              <a href="thread.html#366">[ thread ]</a>
              <a href="subject.html#366">[ subject ]</a>
              <a href="author.html#366">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
