<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22040 - in haiku/trunk/src: kits/tracker	preferences/backgrounds
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22040%20-%20in%20haiku/trunk/src%3A%20kits/tracker%0A%09preferences/backgrounds&In-Reply-To=%3C200708221501.l7MF1epQ010230%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003655.html">
   <LINK REL="Next"  HREF="003657.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22040 - in haiku/trunk/src: kits/tracker	preferences/backgrounds</H1>
    <B>stippi at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22040%20-%20in%20haiku/trunk/src%3A%20kits/tracker%0A%09preferences/backgrounds&In-Reply-To=%3C200708221501.l7MF1epQ010230%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22040 - in haiku/trunk/src: kits/tracker	preferences/backgrounds">stippi at mail.berlios.de
       </A><BR>
    <I>Wed Aug 22 17:01:40 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003655.html">[Haiku-commits] r22039 - haiku/trunk/src/kits/interface
</A></li>
        <LI>Next message: <A HREF="003657.html">[Haiku-commits] r22041 - in haiku/trunk: build/jam	src/add-ons/kernel/drivers/disk/ahci
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3656">[ date ]</a>
              <a href="thread.html#3656">[ thread ]</a>
              <a href="subject.html#3656">[ subject ]</a>
              <a href="author.html#3656">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2007-08-22 17:01:38 +0200 (Wed, 22 Aug 2007)
New Revision: 22040
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22040&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22040&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/tracker/Background.h
   haiku/trunk/src/kits/tracker/BackgroundImage.cpp
   haiku/trunk/src/kits/tracker/BackgroundImage.h
   haiku/trunk/src/kits/tracker/Pose.cpp
   haiku/trunk/src/kits/tracker/PoseView.cpp
   haiku/trunk/src/kits/tracker/PoseView.h
   haiku/trunk/src/kits/tracker/TextWidget.cpp
   haiku/trunk/src/kits/tracker/TextWidget.h
   haiku/trunk/src/kits/tracker/Tracker.cpp
   haiku/trunk/src/kits/tracker/TrackerInitialState.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundImage.h
   haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundsView.h
Log:
changed the meaning of the &quot;icon view label background&quot; Tracker setting:
* it is replaced by a &quot;icon view label outline&quot; feature that renders a black
  or white outline around the text of a label under an icon. This can be used
  for background images that have a lot of contrast and is visually more
  pleasing (IMHO) than the text box in the workspace color (but the outline
  could of course still be improved as well)
  the outline or &quot;false bold width&quot; feature is a new BFont feature in Haiku
* Tracker appeared to have a disabled feature to install default background
  images, I enabled this feature and rewrote it a bit to use our big logo
  from the artwork folder, the placement is for 800x600, so not optimal for
  larger desktops, but at least it is shown by default on new installations
  or rather &quot;fresh&quot; images
* changed the way the dotted underline is rendered under links, accidentally,
  this fixes the bug that it was not dotted at all since a while, which is
  a bug in app_server or BView not tracking the need to update the drawing
  pattern in certain situations (this bug needs to be fixed too of course)


Modified: haiku/trunk/src/kits/tracker/Background.h
===================================================================
--- haiku/trunk/src/kits/tracker/Background.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/Background.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -45,11 +45,12 @@
 /*----------------------------------------------------------------*/
 /*-----  Tracker background BMessage entries  --------------------*/
 
-#define B_BACKGROUND_IMAGE		&quot;be:bgndimginfopath&quot;		// string path
-#define B_BACKGROUND_MODE		&quot;be:bgndimginfomode&quot;		// int32, the enum below
-#define B_BACKGROUND_ORIGIN		&quot;be:bgndimginfooffset&quot;		// BPoint
-#define B_BACKGROUND_ERASE_TEXT	&quot;be:bgndimginfoerasetext&quot;	// bool
-#define B_BACKGROUND_WORKSPACES	&quot;be:bgndimginfoworkspaces&quot;	// uint32
+#define B_BACKGROUND_IMAGE			&quot;be:bgndimginfopath&quot;		// string path
+#define B_BACKGROUND_MODE			&quot;be:bgndimginfomode&quot;		// int32, the enum below
+#define B_BACKGROUND_ORIGIN			&quot;be:bgndimginfooffset&quot;		// BPoint
+#define B_BACKGROUND_TEXT_OUTLINE	&quot;be:bgndimginfoerasetext&quot;	// bool
+	// NOTE: the actual attribute name is kept for backwards compatible settings
+#define B_BACKGROUND_WORKSPACES		&quot;be:bgndimginfoworkspaces&quot;	// uint32
 
 /*----------------------------------------------------------------*/
 /*-----  Background mode values  ---------------------------------*/

Modified: haiku/trunk/src/kits/tracker/BackgroundImage.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/BackgroundImage.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/BackgroundImage.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -44,17 +44,19 @@
 #include &lt;fs_attr.h&gt;
 
 #include &quot;BackgroundImage.h&quot;
+
+#include &quot;Background.h&quot;
 #include &quot;Commands.h&quot;
 #include &quot;PoseView.h&quot;
 
 namespace BPrivate {
 
-const char *kBackgroundImageInfo 			= &quot;be:bgndimginfo&quot;;
-const char *kBackgroundImageInfoOffset 		= &quot;be:bgndimginfooffset&quot;;
-const char *kBackgroundImageInfoEraseText	= &quot;be:bgndimginfoerasetext&quot;;
-const char *kBackgroundImageInfoMode 		= &quot;be:bgndimginfomode&quot;;
-const char *kBackgroundImageInfoWorkspaces 	= &quot;be:bgndimginfoworkspaces&quot;;
-const char *kBackgroundImageInfoPath 		= &quot;be:bgndimginfopath&quot;;
+const char *kBackgroundImageInfo 			= B_BACKGROUND_INFO;
+const char *kBackgroundImageInfoOffset 		= B_BACKGROUND_ORIGIN;
+const char *kBackgroundImageInfoTextOutline	= B_BACKGROUND_TEXT_OUTLINE;
+const char *kBackgroundImageInfoMode 		= B_BACKGROUND_MODE;
+const char *kBackgroundImageInfoWorkspaces 	= B_BACKGROUND_WORKSPACES;
+const char *kBackgroundImageInfoPath 		= B_BACKGROUND_IMAGE;
 
 }
 
@@ -82,7 +84,7 @@
 		const char *path;
 		uint32 workspaces = B_ALL_WORKSPACES;
 		Mode mode = kTiled;
-		bool eraseTextWidgetBackground = true;
+		bool textWidgetLabelOutline = false;
 		BPoint offset;
 		
 		if (container.FindString(kBackgroundImageInfoPath, index, &amp;path) != B_OK)
@@ -96,12 +98,12 @@
 		
 		container.FindInt32(kBackgroundImageInfoWorkspaces, index, (int32 *)&amp;workspaces);
 		container.FindInt32(kBackgroundImageInfoMode, index, (int32 *)&amp;mode);
-		container.FindBool(kBackgroundImageInfoEraseText, index, &amp;eraseTextWidgetBackground);
+		container.FindBool(kBackgroundImageInfoTextOutline, index, &amp;textWidgetLabelOutline);
 		container.FindPoint(kBackgroundImageInfoOffset, index, &amp;offset);
 		
 		BackgroundImage::BackgroundImageInfo *imageInfo = new
 			BackgroundImage::BackgroundImageInfo(workspaces, bitmap, mode, offset,
-				eraseTextWidgetBackground);
+				textWidgetLabelOutline);
 
 		if (!result) 
 			result = new BackgroundImage(node, isDesktop);
@@ -113,12 +115,12 @@
 
 
 BackgroundImage::BackgroundImageInfo::BackgroundImageInfo(uint32 workspaces,
-	BBitmap *bitmap, Mode mode, BPoint offset, bool eraseTextWidget)
+	BBitmap *bitmap, Mode mode, BPoint offset, bool textWidgetOutline)
 	:	fWorkspace(workspaces),
 		fBitmap(bitmap),
 		fMode(mode),
 		fOffset(offset),
-		fEraseTextWidgetBackground(eraseTextWidget)
+		fTextWidgetOutline(textWidgetOutline)
 {
 }
 
@@ -158,7 +160,7 @@
 	if (info) {
 		BPoseView *poseView = dynamic_cast&lt;BPoseView *&gt;(fView);
 		if (poseView)
-			poseView-&gt;SetEraseWidgetTextBackground(info-&gt;fEraseTextWidgetBackground);
+			poseView-&gt;SetWidgetTextOutline(info-&gt;fTextWidgetOutline);
 		Show(info, fView);
 	}
 }
@@ -205,7 +207,7 @@
 	
 	BPoseView *poseView = dynamic_cast&lt;BPoseView *&gt;(view);
 	if (poseView)
-		poseView-&gt;SetEraseWidgetTextBackground(info-&gt;fEraseTextWidgetBackground);
+		poseView-&gt;SetWidgetTextOutline(info-&gt;fTextWidgetOutline);
 	
 	// switch to the bitmap and force a redraw
 	view-&gt;SetViewBitmap(info-&gt;fBitmap, bitmapBounds, destinationBitmapBounds,
@@ -224,7 +226,7 @@
 		BPoseView *poseView = dynamic_cast&lt;BPoseView *&gt;(fView);
 		// make sure text widgets draw the default way, erasing their background
 		if (poseView)
-			poseView-&gt;SetEraseWidgetTextBackground(true);
+			poseView-&gt;SetWidgetTextOutline(true);
 	}
 	fShowingBitmap = NULL;
 }
@@ -271,7 +273,7 @@
 			Show(info, view);
 		else {
 			if (BPoseView *poseView = dynamic_cast&lt;BPoseView *&gt;(view))
-				poseView-&gt;SetEraseWidgetTextBackground(true);
+				poseView-&gt;SetWidgetTextOutline(true);
 			view-&gt;ClearViewBitmap();
 			view-&gt;Invalidate();
 		}

Modified: haiku/trunk/src/kits/tracker/BackgroundImage.h
===================================================================
--- haiku/trunk/src/kits/tracker/BackgroundImage.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/BackgroundImage.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -52,7 +52,7 @@
 
 extern const char *kBackgroundImageInfo;
 extern const char *kBackgroundImageInfoOffset;
-extern const char *kBackgroundImageInfoEraseText;
+extern const char *kBackgroundImageInfoTextOutline;
 extern const char *kBackgroundImageInfoMode;
 extern const char *kBackgroundImageInfoWorkspaces;
 extern const char *kBackgroundImageInfoPath;
@@ -77,14 +77,14 @@
 		// element of the per-workspace list
 	public:
 		BackgroundImageInfo(uint32 workspace, BBitmap *bitmap, Mode mode, BPoint offset,
-			bool eraseTextWidget);
+			bool textWidgetOutline);
 		~BackgroundImageInfo();
 
 		uint32 fWorkspace;
 		BBitmap *fBitmap;
 		Mode fMode;
 		BPoint fOffset;
-		bool fEraseTextWidgetBackground;
+		bool fTextWidgetOutline;
 	};
 
 	static BackgroundImage *GetBackgroundImage(const BNode *, bool isDesktop);

Modified: haiku/trunk/src/kits/tracker/Pose.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/Pose.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/Pose.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -581,7 +581,7 @@
 						widget-&gt;RecalculateText(poseView);
 					
 					bool selectDuringDraw = directDraw &amp;&amp; selected
-						&amp;&amp; (windowActive &amp;&amp; !poseView-&gt;EraseWidgetTextBackground());
+						&amp;&amp; (windowActive &amp;&amp; !poseView-&gt;WidgetTextOutline());
 					
 					if (index == 0 &amp;&amp; selectDuringDraw) {
 						//draw with dark background to select text
@@ -638,7 +638,7 @@
 
 		bool selectDuringDraw = directDraw &amp;&amp; selected
 			&amp;&amp; (poseView-&gt;IsDesktopWindow()
-			|| (windowActive &amp;&amp; !poseView-&gt;EraseWidgetTextBackground()));
+			|| (windowActive &amp;&amp; !poseView-&gt;WidgetTextOutline()));
 			
 		if (selectDuringDraw) {
 			// draw with dark background to select text

Modified: haiku/trunk/src/kits/tracker/PoseView.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/PoseView.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/PoseView.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -196,7 +196,7 @@
 	fRefFilter(NULL),
 	fAutoScrollInc(20),
 	fAutoScrollState(kAutoScrollOff),
-	fEraseWidgetBackground(true),
+	fWidgetTextOutline(false),
 	fSelectionPivotPose(NULL),
 	fRealPivotPose(NULL),
 	fKeyRunner(NULL),
@@ -2873,7 +2873,7 @@
 						|| bounds.Contains(poseRect.LeftBottom())
 						|| bounds.Contains(poseRect.RightBottom())
 						|| bounds.Contains(poseRect.RightTop())) {
-						if (!EraseWidgetTextBackground()
+						if (!WidgetTextOutline()
 							|| clipNode-&gt;moveMode == kMoveSelectionTo)
 							Invalidate(poseRect);
 						else
@@ -3432,7 +3432,7 @@
 				poseRect = pose-&gt;CalcRect(loc, this);
 
 			if (bounds.Intersects(poseRect)) {
-				if (EraseWidgetTextBackground())
+				if (WidgetTextOutline())
 					Invalidate(poseRect);
 				else
 					pose-&gt;Draw(poseRect, this, false);
@@ -6871,7 +6871,7 @@
 										// using a vector class instead of BList
 
 			if ((selected != pose-&gt;IsSelected()) &amp;&amp; poseRect.Intersects(bounds)) {
-				if (pose-&gt;IsSelected() || EraseWidgetTextBackground())
+				if (pose-&gt;IsSelected() || WidgetTextOutline())
 					pose-&gt;Draw(poseRect, this, false);
 				else
 					Invalidate(poseRect);
@@ -6900,7 +6900,7 @@
 			BRect poseRect(pose-&gt;CalcRect(loc, this));
 
 			if (poseRect.Intersects(bounds)) {
-				if (pose-&gt;IsSelected() || EraseWidgetTextBackground())
+				if (pose-&gt;IsSelected() || WidgetTextOutline())
 					pose-&gt;Draw(poseRect, this, false);
 				else
 					Invalidate(poseRect);
@@ -6939,7 +6939,7 @@
 				newList-&gt;AddItem((void *)index);
 
 				if ((selected != pose-&gt;IsSelected()) &amp;&amp; poseRect.Intersects(bounds)) {
-					if (pose-&gt;IsSelected() || EraseWidgetTextBackground())
+					if (pose-&gt;IsSelected() || WidgetTextOutline())
 						pose-&gt;Draw(poseRect, this, false);
 					else
 						Invalidate(poseRect);
@@ -6967,7 +6967,7 @@
 			BRect poseRect(pose-&gt;CalcRect(this));
 
 			if (poseRect.Intersects(bounds)) {
-				if (pose-&gt;IsSelected() || EraseWidgetTextBackground())
+				if (pose-&gt;IsSelected() || WidgetTextOutline())
 					pose-&gt;Draw(poseRect, this, false);
 				else
 					Invalidate(poseRect);
@@ -7725,7 +7725,7 @@
 				if (pose-&gt;IsSelected()) {
 					pose-&gt;Select(false);
 					BRect poseRect(pose-&gt;CalcRect(loc, this, false));
-					if (EraseWidgetTextBackground())
+					if (WidgetTextOutline())
 						pose-&gt;Draw(poseRect, this, false);
 					else
 						Invalidate(poseRect);
@@ -7744,7 +7744,7 @@
 					if (pose-&gt;IsSelected()) {
 						pose-&gt;Select(false);
 						BRect poseRect(pose-&gt;CalcRect(this));
-						if (EraseWidgetTextBackground())
+						if (WidgetTextOutline())
 							pose-&gt;Draw(poseRect, this, false);
 						else
 							Invalidate(poseRect);
@@ -7807,7 +7807,7 @@
 						if (pose-&gt;IsSelected() != show || fShowSelectionWhenInactive) {
 							if (!fShowSelectionWhenInactive)
 								pose-&gt;Select(show);
-							if (show &amp;&amp; EraseWidgetTextBackground())
+							if (show &amp;&amp; WidgetTextOutline())
 								pose-&gt;Draw(pose-&gt;CalcRect(this), this, false);
 							else
 								Invalidate(pose-&gt;CalcRect(this));
@@ -7850,7 +7850,7 @@
 	pose-&gt;Select(select);
 
 	// update display
-	if (EraseWidgetTextBackground())
+	if (WidgetTextOutline())
 		DrawPose(pose, index, false);
 	else
 		Invalidate(pose-&gt;CalcRect(this));
@@ -8887,7 +8887,7 @@
 			BPose *pose = fVSPoseList-&gt;ItemAt(index);
 			if (pose) {
 				if (pose == fDropTarget) {
-					if (!hiliteState &amp;&amp; !EraseWidgetTextBackground())
+					if (!hiliteState &amp;&amp; !WidgetTextOutline())
 						// deselecting an icon with widget drawn over background
 						// have to be a little tricky here - draw just the icon,
 						// invalidate the widget
@@ -9210,16 +9210,16 @@
 
 
 bool
-BPoseView::EraseWidgetTextBackground() const
+BPoseView::WidgetTextOutline() const
 {
-	return fEraseWidgetBackground;
+	return fWidgetTextOutline;
 }
 
 
 void
-BPoseView::SetEraseWidgetTextBackground(bool on)
+BPoseView::SetWidgetTextOutline(bool on)
 {
-	fEraseWidgetBackground = on;
+	fWidgetTextOutline = on;
 }
 
 

Modified: haiku/trunk/src/kits/tracker/PoseView.h
===================================================================
--- haiku/trunk/src/kits/tracker/PoseView.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/PoseView.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -207,8 +207,8 @@
 		rgb_color DeskTextColor() const;
 		rgb_color DeskTextBackColor() const;
 
-		bool EraseWidgetTextBackground() const;
-		void SetEraseWidgetTextBackground(bool);
+		bool WidgetTextOutline() const;
+		void SetWidgetTextOutline(bool);
 			// used to not erase when we have a background image and
 			// invalidate instead
 
@@ -627,7 +627,7 @@
 		float fAutoScrollInc;
 		int32 fAutoScrollState;
 		std::set&lt;thread_id&gt; fAddPosesThreads;
-		bool fEraseWidgetBackground;
+		bool fWidgetTextOutline;
 		const BPose *fSelectionPivotPose;
 		const BPose *fRealPivotPose;
 		BMessageRunner *fKeyRunner;

Modified: haiku/trunk/src/kits/tracker/TextWidget.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/TextWidget.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/TextWidget.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -477,12 +477,22 @@
 BTextWidget::Draw(BRect eraseRect, BRect textRect, float, BPoseView *view,
 	BView *drawView, bool selected, uint32 clipboardMode, BPoint offset, bool direct)
 {
+	textRect.OffsetBy(offset);
+
 	if (direct) {
+#if __HAIKU__
+		// draw selection box if selected
+		if (selected) {
+#else
 		// erase area we're going to draw in
-		if (view-&gt;EraseWidgetTextBackground() || selected) {
+		// NOTE: WidgetTextOutline() is reused for
+		// erasing background on R5 here
+		if (view-&gt;WidgetTextOutline() || selected) {
+#endif
 			drawView-&gt;SetDrawingMode(B_OP_COPY);
 			eraseRect.OffsetBy(offset);
-			drawView-&gt;FillRect(eraseRect, B_SOLID_LOW);
+//			drawView-&gt;FillRect(eraseRect, B_SOLID_LOW);
+			drawView-&gt;FillRect(textRect, B_SOLID_LOW);
 		} else
 			drawView-&gt;SetDrawingMode(B_OP_OVER);	
 
@@ -493,34 +503,74 @@
 				highColor = kWhite;
 			else
 				highColor = view-&gt;DeskTextColor();
-		} else if (selected &amp;&amp; view-&gt;Window()-&gt;IsActive() &amp;&amp; !view-&gt;EraseWidgetTextBackground()) {
+		} else if (selected &amp;&amp; view-&gt;Window()-&gt;IsActive()) {
 			highColor = kWhite;
 		} else
 			highColor = kBlack;
 
 		if (clipboardMode == kMoveSelectionTo &amp;&amp; !selected) {
-			view-&gt;SetDrawingMode(B_OP_ALPHA);
-			view-&gt;SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);
+			drawView-&gt;SetDrawingMode(B_OP_ALPHA);
+			drawView-&gt;SetBlendingMode(B_PIXEL_ALPHA, B_ALPHA_OVERLAY);
 			highColor.alpha = 64;
 		}
 		drawView-&gt;SetHighColor(highColor);
 	}
 
 	BPoint loc;
-	textRect.OffsetBy(offset);
-
 	loc.y = textRect.bottom - view-&gt;FontInfo().descent;
 	loc.x = textRect.left + 1;
 
-	drawView-&gt;MovePenTo(loc);
-	drawView-&gt;DrawString(fText-&gt;FittingText(view));
+	const char* fittingText = fText-&gt;FittingText(view);
 
+#if __HAIKU__
+	if (!selected &amp;&amp; view-&gt;WidgetTextOutline()) {
+		// draw a halo around the text by using the &quot;false bold&quot;
+		// feature for text rendering. Either black or white is used for
+		// the glow (whatever acts as contrast) with a some alpha value,
+		// two passes are used to achive a blur effect
+		drawView-&gt;SetDrawingMode(B_OP_ALPHA);
+		drawView-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_OVERLAY);
+
+		BFont font;
+		drawView-&gt;GetFont(&amp;font);
+// NOTE: commented out first pass for halo, since just a plain
+// outline looks better IMHO -stippi
+//		font.SetFalseBoldWidth(2.0);
+//		drawView-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);
+		rgb_color textColor = drawView-&gt;HighColor();
+		rgb_color glow = textColor.red
+			+ textColor.green + textColor.blue &gt; 128 * 3 ? kBlack : kWhite;
+//		glow.alpha = 40;
+//		drawView-&gt;SetHighColor(glow);
+
+//		drawView-&gt;DrawString(fittingText, loc);
+
+		font.SetFalseBoldWidth(1.0);
+		drawView-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);
+		glow.alpha = 220;
+		drawView-&gt;SetHighColor(glow);
+
+		drawView-&gt;DrawString(fittingText, loc);
+
+		font.SetFalseBoldWidth(0.0);
+		drawView-&gt;SetFont(&amp;font, B_FONT_FALSE_BOLD_WIDTH);
+		drawView-&gt;SetHighColor(textColor);
+	}
+#endif // __HAIKU__
+
+	drawView-&gt;DrawString(fittingText, loc);
+
 	if (fSymLink &amp;&amp; (fAttrHash == view-&gt;FirstColumn()-&gt;AttrHash())) {
 		// ToDo:
 		// this should be exported to the WidgetAttribute class, probably
 		// by having a per widget kind style
-		if (direct) 
-			drawView-&gt;SetHighColor(125, 125, 125);
+		if (direct) {
+			rgb_color underlineColor = drawView-&gt;HighColor();
+			underlineColor.alpha = 180;
+			drawView-&gt;SetHighColor(underlineColor);
+			drawView-&gt;SetDrawingMode(B_OP_ALPHA);
+			drawView-&gt;SetBlendingMode(B_CONSTANT_ALPHA, B_ALPHA_OVERLAY);
+		}
 
 		textRect.right = textRect.left + fText-&gt;Width(view);
 			// only underline text part

Modified: haiku/trunk/src/kits/tracker/TextWidget.h
===================================================================
--- haiku/trunk/src/kits/tracker/TextWidget.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/TextWidget.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -86,7 +86,7 @@
 	void SetActive(bool);
 	
 	const char *Text() const;
-		// returns the untrucated version of the text
+		// returns the untruncated version of the text
 	float TextWidth(const BPoseView *) const;
 	float PreferredWidth(const BPoseView *) const;
 	int	Compare(const BTextWidget &amp;, BPoseView *) const;

Modified: haiku/trunk/src/kits/tracker/Tracker.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/Tracker.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/Tracker.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -1280,6 +1280,7 @@
 	InitMimeTypes();
 	InstallDefaultTemplates();
 	InstallIndices();
+	InstallTemporaryBackgroundImages();
 	
 	HideVarDir();
 

Modified: haiku/trunk/src/kits/tracker/TrackerInitialState.cpp
===================================================================
--- haiku/trunk/src/kits/tracker/TrackerInitialState.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/kits/tracker/TrackerInitialState.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -41,6 +41,7 @@
 #include &lt;Message.h&gt;
 #include &lt;Node.h&gt;
 #include &lt;Path.h&gt;
+#include &lt;Screen.h&gt;
 #include &lt;VolumeRoster.h&gt;
 
 #include &lt;fs_attr.h&gt;
@@ -429,24 +430,24 @@
 
 static void
 AddTemporaryBackgroundImages(BMessage *message, const char *imagePath,
-	BackgroundImage::Mode mode, BPoint offset, uint32 workspaces, bool eraseTextWidgets)
+	BackgroundImage::Mode mode, BPoint offset, uint32 workspaces, bool textWidgetOutlines)
 {
 	message-&gt;AddString(kBackgroundImageInfoPath, imagePath);
 	message-&gt;AddInt32(kBackgroundImageInfoWorkspaces, (int32)workspaces);
 	message-&gt;AddInt32(kBackgroundImageInfoMode, mode);
-	message-&gt;AddBool(kBackgroundImageInfoEraseText, eraseTextWidgets);
+	message-&gt;AddBool(kBackgroundImageInfoTextOutline, textWidgetOutlines);
 	message-&gt;AddPoint(kBackgroundImageInfoOffset, offset);
 }
 
 static void
 InstallTemporaryBackgroundImagesIfNeeded(BNode *node, const char *imagePath,
-	BackgroundImage::Mode mode, BPoint offset, uint32 workspaces, bool eraseTextWidgets)
+	BackgroundImage::Mode mode, BPoint offset, uint32 workspaces, bool textWidgetOutlines)
 {
 	attr_info info;
 	if (node-&gt;GetAttrInfo(kBackgroundImageInfo, &amp;info) != B_OK) {
 		BMessage message;
 		AddTemporaryBackgroundImages(&amp;message, imagePath, mode, offset, workspaces,
-			eraseTextWidgets);
+			textWidgetOutlines);
 		InstallTemporaryBackgroundImages(node, &amp;message);
 	}
 }
@@ -454,97 +455,39 @@
 void 
 TTracker::InstallTemporaryBackgroundImages()
 {
-	// TODO: make the large Haiku Logo the default background
+	// make the large Haiku Logo the default background
 
-	BPath path;
-	FSFindTrackerSettingsDir(&amp;path, false);
-	BString defaultFolderPath(path.Path());
-	defaultFolderPath &lt;&lt; '/' &lt;&lt; kDefaultFolderTemplate &lt;&lt; '/';
-	
+//	BPath path;
+	BPath path(&quot;/boot/beos/etc/artwork&quot;);
+//	FSFindTrackerSettingsDir(&amp;path, false);
+//	path.Append(kDefaultFolderTemplate);
+
+	BString defaultBackgroundImage(&quot;/HAIKU logo - white on blue - big.png&quot;);
+	BString defaultBackgroundTexture(&quot;/backgroundTexture.tga&quot;);
+
 	BNode node;
-	if (BContainerWindow::DefaultStateSourceNode(kDefaultFolderTemplate, &amp;node, true))
+	if (BContainerWindow::DefaultStateSourceNode(kDefaultFolderTemplate, &amp;node, true)) {
+		// install a default background texture for folders in icon view mode
 		InstallTemporaryBackgroundImagesIfNeeded(&amp;node,
-			(BString(defaultFolderPath) &lt;&lt; &quot;backgroundTexture.tga&quot;).String(),
+			(BString(path.Path()) &lt;&lt; defaultBackgroundTexture).String(),
 			BackgroundImage::kTiled,
 			BPoint(0, 0), 0xffffffff, false);
+	}
 
 	BDirectory dir;
 	if (FSGetBootDeskDir(&amp;dir) == B_OK) {
+		// install a default background if there is no background defined yet
 		attr_info info;
 		if (dir.GetAttrInfo(kBackgroundImageInfo, &amp;info) != B_OK) {
+			BScreen screen(B_MAIN_SCREEN_ID);
+			BPoint logoPos;
+			logoPos.x = floorf((screen.Frame().Width() - 605) * (sqrtf(5) - 1) / 2);
+			logoPos.y = floorf((screen.Frame().Height() - 190) * 0.9);
 			BMessage message;
 			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bgdefault.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0xffffffff, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg1.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000001, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg2.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000002, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg3.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000004, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg4.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000008, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg5.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000010, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg6.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000020, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg7.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000040, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg8.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000080, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg9.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000100, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg10.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000200, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg11.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000400, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg12.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00000800, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg12.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00001000, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg13.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00002000, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg14.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00002000, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg15.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00004000, true);
-			AddTemporaryBackgroundImages(&amp;message,
-				(BString(defaultFolderPath) &lt;&lt; &quot;bg16.tga&quot;).String(),
-				BackgroundImage::kScaledToFit,
-				BPoint(0, 0), 0x00008000, true);
+				(BString(path.Path()) &lt;&lt; defaultBackgroundImage).String(),
+				BackgroundImage::kAtOffset,
+				logoPos, 0xffffffff, false);
 			::InstallTemporaryBackgroundImages(&amp;dir, &amp;message);
 		}
 	}

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -57,7 +57,11 @@
 
 const char *kBackgroundImageInfo 			= &quot;be:bgndimginfo&quot;;
 const char *kBackgroundImageInfoOffset 		= &quot;be:bgndimginfooffset&quot;;
-const char *kBackgroundImageInfoEraseText	= &quot;be:bgndimginfoerasetext&quot;;
+//const char *kBackgroundImageInfoTextOutline	= &quot;be:bgndimginfotextoutline&quot;;
+const char *kBackgroundImageInfoTextOutline	= &quot;be:bgndimginfoerasetext&quot;;
+// NOTE: the attribute keeps the old name for backwards compatibility,
+// just in case some users spend time configuring a few windows with
+// this feature on or off...
 const char *kBackgroundImageInfoMode 		= &quot;be:bgndimginfomode&quot;;
 const char *kBackgroundImageInfoWorkspaces 	= &quot;be:bgndimginfoworkspaces&quot;;
 const char *kBackgroundImageInfoPath 		= &quot;be:bgndimginfopath&quot;;
@@ -107,7 +111,7 @@
 		const char *path;
 		uint32 workspaces = B_ALL_WORKSPACES;
 		Mode mode = kTiled;
-		bool eraseTextWidgetBackground = true;
+		bool textWidgetLabelOutline = false;
 		BPoint offset;
 		uint32 imageSet = 0;
 		uint32 cacheMode = 0;
@@ -122,8 +126,8 @@
 		container.FindInt32(kBackgroundImageInfoWorkspaces, index,
 			(int32 *)&amp;workspaces);
 		container.FindInt32(kBackgroundImageInfoMode, index, (int32 *)&amp;mode);
-		container.FindBool(kBackgroundImageInfoEraseText, index,
-			&amp;eraseTextWidgetBackground);
+		container.FindBool(kBackgroundImageInfoTextOutline, index,
+			&amp;textWidgetLabelOutline);
 		container.FindPoint(kBackgroundImageInfoOffset, index, &amp;offset);
 
 		if (isDesktop) {
@@ -135,7 +139,7 @@
 
 		BackgroundImage::BackgroundImageInfo *imageInfo = new
 			BackgroundImage::BackgroundImageInfo(workspaces, imageIndex,
-				mode, offset, eraseTextWidgetBackground, imageSet, cacheMode);
+				mode, offset, textWidgetLabelOutline, imageSet, cacheMode);
 
 		//imageInfo-&gt;UnloadBitmap(globalCacheMode);
 
@@ -159,14 +163,14 @@
 
 
 BackgroundImage::BackgroundImageInfo::BackgroundImageInfo(uint32 workspaces,
-	int32 imageIndex, Mode mode, BPoint offset, bool eraseTextWidget,
+	int32 imageIndex, Mode mode, BPoint offset, bool textWidgetLabelOutline,
 	uint32 imageSet, uint32 cacheMode)
 	:
 	fWorkspace(workspaces),
 	fImageIndex(imageIndex),
 	fMode(mode),
 	fOffset(offset),
-	fEraseTextWidgetBackground(eraseTextWidget),
+	fTextWidgetLabelOutline(textWidgetLabelOutline),
 	fImageSet(imageSet),
 	fCacheMode(cacheMode)
 {
@@ -239,7 +243,7 @@
 	if (info) {
 		/*BPoseView *poseView = dynamic_cast&lt;BPoseView *&gt;(fView);
 		if (poseView)
-			poseView-&gt;SetEraseWidgetTextBackground(info-&gt;fEraseTextWidgetBackground);*/
+			poseView-&gt;SetEraseWidgetTextBackground(info-&gt;fTextWidgetLabelOutline);*/
 		Show(info, fView);
 	}
 }
@@ -425,8 +429,8 @@
 		if (fBackgroundsView-&gt;GetImage(info-&gt;fImageIndex) == NULL)
 			continue;
 
-		container.AddBool(kBackgroundImageInfoEraseText,
-			info-&gt;fEraseTextWidgetBackground);
+		container.AddBool(kBackgroundImageInfoTextOutline,
+			info-&gt;fTextWidgetLabelOutline);
 		container.AddString(kBackgroundImageInfoPath,
 			fBackgroundsView-&gt;GetImage(info-&gt;fImageIndex)-&gt;GetPath().Path());
 		container.AddInt32(kBackgroundImageInfoWorkspaces, info-&gt;fWorkspace);

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundImage.h
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundImage.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundImage.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -83,7 +83,7 @@
 				// element of the per-workspace list
 			public:
 				BackgroundImageInfo(uint32 workspace, int32 imageIndex, Mode mode,
-					BPoint offset, bool eraseTextWidget, uint32 imageSet,
+					BPoint offset, bool textWidgetLabelOutline, uint32 imageSet,
 					uint32 cacheMode);
 				~BackgroundImageInfo();
 
@@ -94,7 +94,7 @@
 				int32 fImageIndex;
 				Mode fMode;
 				BPoint fOffset;
-				bool fEraseTextWidgetBackground;
+				bool fTextWidgetLabelOutline;
 				uint32 fImageSet;
 				uint32 fCacheMode;		// image cache strategy (0 cache , 1 no cache)
 		};

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp	2007-08-22 15:01:38 UTC (rev 22040)
@@ -42,7 +42,7 @@
 static const uint32 kMsgManualPlacement = 'mnpl';
 static const uint32 kMsgScalePlacement = 'scpl';
 static const uint32 kMsgTilePlacement = 'tlpl';
-static const uint32 kMsgIconLabelBackground = 'ilcb';
+static const uint32 kMsgIconLabelOutline = 'ilol';
 
 static const uint32 kMsgImagePlacement = 'xypl';
 static const uint32 kMsgUpdatePreviewPlacement = 'pvpl';
@@ -207,18 +207,18 @@
 	rightbox-&gt;AddChild(placementMenuField);
 
 	rect.OffsetBy(offset, placementMenuField-&gt;Bounds().Height() + 5);
-	fIconLabelBackground = new BCheckBox(rect, &quot;iconLabelBackground&quot;,
-		&quot;Icon label background&quot;, new BMessage(kMsgIconLabelBackground));
-	fIconLabelBackground-&gt;SetValue(B_CONTROL_ON);
-	fIconLabelBackground-&gt;ResizeToPreferred();
-	rightbox-&gt;AddChild(fIconLabelBackground);
+	fIconLabelOutline = new BCheckBox(rect, &quot;iconLabelOutline&quot;,
+		&quot;Icon label outline&quot;, new BMessage(kMsgIconLabelOutline));
+	fIconLabelOutline-&gt;SetValue(B_CONTROL_OFF);
+	fIconLabelOutline-&gt;ResizeToPreferred();
+	rightbox-&gt;AddChild(fIconLabelOutline);
 
-	rect.top += fIconLabelBackground-&gt;Bounds().Height() + 15;
+	rect.top += fIconLabelOutline-&gt;Bounds().Height() + 15;
 	fPicker = new BColorControl(BPoint(10, rect.top), B_CELLS_32x8, 5.0, &quot;Picker&quot;,
 		new BMessage(kMsgUpdateColor));
 	rightbox-&gt;AddChild(fPicker);
 
-	float xDelta = max_c(fIconLabelBackground-&gt;Frame().right, fPicker-&gt;Frame().right)
+	float xDelta = max_c(fIconLabelOutline-&gt;Frame().right, fPicker-&gt;Frame().right)
 		+ 10.0f - rightbox-&gt;Bounds().Width();
 	delta = fPicker-&gt;Frame().bottom + 10.0f - rightbox-&gt;Bounds().Height();
 
@@ -273,7 +273,7 @@
 	fWorkspaceMenu-&gt;SetTargetForItems(this);
 	fXPlacementText-&gt;SetTarget(this);
 	fYPlacementText-&gt;SetTarget(this);
-	fIconLabelBackground-&gt;SetTarget(this);
+	fIconLabelOutline-&gt;SetTarget(this);
 	fPicker-&gt;SetTarget(this);
 	fApply-&gt;SetTarget(this);
 	fRevert-&gt;SetTarget(this);
@@ -326,7 +326,7 @@
 			UpdateButtons();
 			break;
 
-		case kMsgIconLabelBackground:
+		case kMsgIconLabelOutline:
 			UpdateButtons();
 			break;
 
@@ -507,8 +507,9 @@
 	if (!fCurrentInfo) {
 		fImageMenu-&gt;FindItem(kMsgNoImage)-&gt;SetMarked(true);
 		fPlacementMenu-&gt;FindItem(kMsgManualPlacement)-&gt;SetMarked(true);
+		fIconLabelOutline-&gt;SetValue(B_CONTROL_OFF);
 	} else {
-		fIconLabelBackground-&gt;SetValue(fCurrentInfo-&gt;fEraseTextWidgetBackground
+		fIconLabelOutline-&gt;SetValue(fCurrentInfo-&gt;fTextWidgetLabelOutline
 			? B_CONTROL_ON : B_CONTROL_OFF);
 
 		BString xtext, ytext;
@@ -557,18 +558,18 @@
 void
 BackgroundsView::Save()
 {
-	bool eraseTextWidgetBackground =
-		fIconLabelBackground-&gt;Value() == B_CONTROL_ON;
+	bool textWidgetLabelOutline =
+		fIconLabelOutline-&gt;Value() == B_CONTROL_ON;
 	BackgroundImage::Mode mode = FindPlacementMode();
 	BPoint offset(atoi(fXPlacementText-&gt;Text()), atoi(fYPlacementText-&gt;Text()));
 
 	if (!fCurrent-&gt;IsDesktop()) {
 		if (fCurrentInfo == NULL) {
 			fCurrentInfo = new BackgroundImage::BackgroundImageInfo(B_ALL_WORKSPACES,
-				fLastImageIndex, mode, offset, eraseTextWidgetBackground, 0, 0);
+				fLastImageIndex, mode, offset, textWidgetLabelOutline, 0, 0);
 			fCurrent-&gt;Add(fCurrentInfo);
 		} else {
-			fCurrentInfo-&gt;fEraseTextWidgetBackground = eraseTextWidgetBackground;
+			fCurrentInfo-&gt;fTextWidgetLabelOutline = textWidgetLabelOutline;
 			fCurrentInfo-&gt;fMode = mode;
 			if (fCurrentInfo-&gt;fMode == BackgroundImage::kAtOffset)
 				fCurrentInfo-&gt;fOffset = offset;
@@ -588,14 +589,14 @@
 					if (fLastImageIndex &gt; -1) {
 						fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
 							workspaceMask, fLastImageIndex, mode, offset,
-							eraseTextWidgetBackground, fCurrentInfo-&gt;fImageSet,
+							textWidgetLabelOutline, fCurrentInfo-&gt;fImageSet,
 							fCurrentInfo-&gt;fCacheMode);
 						fCurrent-&gt;Add(fCurrentInfo);
 					}
 				} else {
 					if (fLastImageIndex &gt; -1) {
-						fCurrentInfo-&gt;fEraseTextWidgetBackground =
-							eraseTextWidgetBackground;
+						fCurrentInfo-&gt;fTextWidgetLabelOutline =
+							textWidgetLabelOutline;
 						fCurrentInfo-&gt;fMode = mode;
 						if (fCurrentInfo-&gt;fMode == BackgroundImage::kAtOffset)
 							fCurrentInfo-&gt;fOffset = offset;
@@ -610,7 +611,7 @@
 				fCurrent-&gt;RemoveAll();
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
 					B_ALL_WORKSPACES, fLastImageIndex, mode, offset,
-					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(),
+					textWidgetLabelOutline, fCurrent-&gt;GetShowingImageSet(),
 					fCurrentInfo-&gt;fCacheMode);
 				fCurrent-&gt;Add(fCurrentInfo);
 			}
@@ -618,12 +619,12 @@
 			if (fWorkspaceMenu-&gt;FindItem(kMsgCurrentWorkspace)-&gt;IsMarked()) {
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
 					workspaceMask, fLastImageIndex, mode, offset,
-					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(), 0);
+					textWidgetLabelOutline, fCurrent-&gt;GetShowingImageSet(), 0);
 			} else {
 				fCurrent-&gt;RemoveAll();
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
 					B_ALL_WORKSPACES, fLastImageIndex, mode, offset,
-					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(), 0);
+					textWidgetLabelOutline, fCurrent-&gt;GetShowingImageSet(), 0);
 			}
 			fCurrent-&gt;Add(fCurrentInfo);
 		}
@@ -836,8 +837,8 @@
 	bool imageEnabled = !(fImageMenu-&gt;FindItem(kMsgNoImage)-&gt;IsMarked());
 	if (fPlacementMenu-&gt;IsEnabled() ^ imageEnabled)
 		fPlacementMenu-&gt;SetEnabled(imageEnabled);
-	if (fIconLabelBackground-&gt;IsEnabled() ^ imageEnabled)
-		fIconLabelBackground-&gt;SetEnabled(imageEnabled);
+	if (fIconLabelOutline-&gt;IsEnabled() ^ imageEnabled)
+		fIconLabelOutline-&gt;SetEnabled(imageEnabled);
 
 	bool textEnabled = (fPlacementMenu-&gt;FindItem(kMsgManualPlacement)-&gt;IsMarked())
 		&amp;&amp; imageEnabled;
@@ -870,7 +871,7 @@
 				new BackgroundImage::BackgroundImageInfo(0, index,
 					FindPlacementMode(), BPoint(atoi(fXPlacementText-&gt;Text()),
 						atoi(fYPlacementText-&gt;Text())),
-					fIconLabelBackground-&gt;Value() == B_CONTROL_ON, 0, 0);
+					fIconLabelOutline-&gt;Value() == B_CONTROL_ON, 0, 0);
 			if (info-&gt;fMode == BackgroundImage::kAtOffset) {
 				fPreView-&gt;SetEnabled(true);
 				fPreView-&gt;fPoint.x = atoi(fXPlacementText-&gt;Text());
@@ -923,8 +924,8 @@
 		&amp;&amp; fPicker-&gt;ValueAsColor() != BScreen().DesktopColor()) {
 		hasChanged = true;
 	} else if (fCurrentInfo) {
-		if ((fIconLabelBackground-&gt;Value() == B_CONTROL_ON) ^
-			fCurrentInfo-&gt;fEraseTextWidgetBackground) {
+		if ((fIconLabelOutline-&gt;Value() == B_CONTROL_ON) ^
+			fCurrentInfo-&gt;fTextWidgetLabelOutline) {
 			hasChanged = true;
 		} else if (FindPlacementMode() != fCurrentInfo-&gt;fMode) {
 			hasChanged = true;

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundsView.h
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundsView.h	2007-08-22 14:53:24 UTC (rev 22039)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundsView.h	2007-08-22 15:01:38 UTC (rev 22040)
@@ -118,7 +118,7 @@
 
 		BColorControl *fPicker;			// color picker
 		BButton *fApply, *fRevert;		// apply and revert buttons
-		BCheckBox *fIconLabelBackground;	// label ckeckbox
+		BCheckBox *fIconLabelOutline;	// label ckeckbox
 		BMenu* fPlacementMenu, *fImageMenu, *fWorkspaceMenu;	// the three comboboxes
 		BTextControl *fXPlacementText, *fYPlacementText;		// x and y textboxes
 		PreView *fPreView;				// the view for previewing the result


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003655.html">[Haiku-commits] r22039 - haiku/trunk/src/kits/interface
</A></li>
	<LI>Next message: <A HREF="003657.html">[Haiku-commits] r22041 - in haiku/trunk: build/jam	src/add-ons/kernel/drivers/disk/ahci
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3656">[ date ]</a>
              <a href="thread.html#3656">[ thread ]</a>
              <a href="subject.html#3656">[ subject ]</a>
              <a href="author.html#3656">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
