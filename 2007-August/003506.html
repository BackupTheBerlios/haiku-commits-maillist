<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21930 - in haiku/trunk:	headers/private/graphics/radeon src/add-ons/accelerants/radeon	src/add-ons/kernel/drivers/graphics/radeon
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21930%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/radeon%20src/add-ons/accelerants/radeon%0A%09src/add-ons/kernel/drivers/graphics/radeon&In-Reply-To=%3C200708131722.l7DHMY7L018999%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003512.html">
   <LINK REL="Next"  HREF="003510.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21930 - in haiku/trunk:	headers/private/graphics/radeon src/add-ons/accelerants/radeon	src/add-ons/kernel/drivers/graphics/radeon</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21930%20-%20in%20haiku/trunk%3A%0A%09headers/private/graphics/radeon%20src/add-ons/accelerants/radeon%0A%09src/add-ons/kernel/drivers/graphics/radeon&In-Reply-To=%3C200708131722.l7DHMY7L018999%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21930 - in haiku/trunk:	headers/private/graphics/radeon src/add-ons/accelerants/radeon	src/add-ons/kernel/drivers/graphics/radeon">axeld at mail.berlios.de
       </A><BR>
    <I>Mon Aug 13 19:22:34 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003512.html">[Haiku-commits] r21929 - in haiku/trunk/src/servers/app/drawing: . Painter Painter/drawing_modes
</A></li>
        <LI>Next message: <A HREF="003510.html">[Haiku-commits] r21930 - in haiku/trunk: headers/private/graphics/radeon src/add-ons/accelerants/radeon src/add-ons/kernel/drivers/graphics/radeon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3506">[ date ]</a>
              <a href="thread.html#3506">[ thread ]</a>
              <a href="subject.html#3506">[ subject ]</a>
              <a href="author.html#3506">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-08-13 19:22:32 +0200 (Mon, 13 Aug 2007)
New Revision: 21930
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21930&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21930&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/graphics/radeon/fp_regs.h
   haiku/trunk/headers/private/graphics/radeon/radeon_interface.h
   haiku/trunk/src/add-ons/accelerants/radeon/ProposeDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/radeon/SetDisplayMode.c
   haiku/trunk/src/add-ons/accelerants/radeon/flat_panel.c
   haiku/trunk/src/add-ons/accelerants/radeon/monitor_detection.c
   haiku/trunk/src/add-ons/accelerants/radeon/monitor_routing.c
   haiku/trunk/src/add-ons/accelerants/radeon/radeon_accelerant.h
   haiku/trunk/src/add-ons/accelerants/radeon/set_mode.h
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/bios.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/init.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/radeon_driver.h
Log:
Committed patch by Euan Kirkhope to improve routing problems with Radeon cards;
this should fix bug #1293.
I've tested it here on two machines, one works better now, the other stayed the
same (Radeon 9250, and a laptop FireGL (id 4c66) version). This apparently also
fixed bug #1394.


Modified: haiku/trunk/headers/private/graphics/radeon/fp_regs.h
===================================================================
--- haiku/trunk/headers/private/graphics/radeon/fp_regs.h	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/headers/private/graphics/radeon/fp_regs.h	2007-08-13 17:22:32 UTC (rev 21930)
@@ -35,6 +35,7 @@
 #       define RADEON_FP2_PANEL_FORMAT          (1 &lt;&lt;  3)
 #       define RADEON_FP2_SOURCE_SEL_MASK       (3 &lt;&lt; 10)
 #       define RADEON_FP2_SOURCE_SEL_CRTC2      (1 &lt;&lt; 10)
+#       define RADEON_FP2_SOURCE_SEL_RMX        (2 &lt;&lt; 10) 
 #       define RADEON_FP2_SRC_SEL_MASK          (3 &lt;&lt; 13)
 #       define RADEON_FP2_SRC_SEL_CRTC2         (1 &lt;&lt; 13)
 #       define RADEON_FP2_FP_POL                (1 &lt;&lt; 16)
@@ -68,6 +69,12 @@
 #       define RADEON_VERT_STRETCH_BLEND       (1     &lt;&lt; 26)
 #       define RADEON_VERT_AUTO_RATIO_EN       (1     &lt;&lt; 27)
 #       define RADEON_VERT_STRETCH_RESERVED    0xf1000000
+
+#define RADEON_TMDS_PLL_CNTL                0x02a8
+#define RADEON_TMDS_TRANSMITTER_CNTL        0x02a4
+#       define RADEON_TMDS_TRANSMITTER_PLLEN  1
+#       define RADEON_TMDS_TRANSMITTER_PLLRST 2
+
 #define RADEON_FP_H_SYNC_STRT_WID           0x02c4
 #define RADEON_FP_V_SYNC_STRT_WID           0x02c8
 
@@ -80,6 +87,9 @@
 #       define RADEON_LVDS_DIGON            (1   &lt;&lt; 18)
 #       define RADEON_LVDS_BLON             (1   &lt;&lt; 19)
 #       define RADEON_LVDS_SEL_CRTC2        (1   &lt;&lt; 23)
+#define RADEON_LVDS_PLL_CNTL                0x02d4
+#       define RADEON_HSYNC_DELAY_SHIFT     28
+#       define RADEON_HSYNC_DELAY_MASK      (0xf &lt;&lt; 28)
 
 #define RADEON_FP_CRTC2_H_TOTAL_DISP        0x0350
 #define RADEON_FP_CRTC2_V_TOTAL_DISP        0x0354

Modified: haiku/trunk/headers/private/graphics/radeon/radeon_interface.h
===================================================================
--- haiku/trunk/headers/private/graphics/radeon/radeon_interface.h	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/headers/private/graphics/radeon/radeon_interface.h	2007-08-13 17:22:32 UTC (rev 21930)
@@ -348,6 +348,11 @@
 	uint32 best_vco;			// preferred VCO frequency (0 for don't care)
 } pll_info;
 
+// info for ext tmds pll
+typedef struct {
+	uint32 freq;
+	uint32 value;
+} tmds_pll_info;
 
 // one overlay buffer
 typedef struct overlay_buffer_node {
@@ -520,24 +525,24 @@
 	uint16		device_id;		// PCI device id
 	uint8		revision;		// PCI device revision
 	
-	//bool 		has_crtc2;		// has second CRTC
 	radeon_type	asic;			// ASIC version
-	bool		is_mobility;	// mobility version
-	bool		is_igp;			//	might need to know if it's an integrated chip
+	bool		is_mobility;		// mobility version
+	bool		is_igp;			// might need to know if it's an integrated chip
 	bool		is_atombios;
-	tv_chip_type tv_chip;		// type of TV-Out encoder
+
+	tv_chip_type 	tv_chip;		// type of TV-Out encoder
 	bool		new_pll;		// r300 style PLL
-	bool		has_no_i2c; 	// I2C is broken
-	uint16		panel_pwr_delay;// delay for LCD backlight to stabilise
-	uint8		theatre_channel;// VIP channel of Rage Theatre (if applicable)
+	bool		has_no_i2c; 		// I2C is broken
+	uint16		panel_pwr_delay;	// delay for LCD backlight to stabilise
+	uint8		theatre_channel;	// VIP channel of Rage Theatre (if applicable)
 		
 	general_pll_info	pll;
-	
+	tmds_pll_info		tmds_pll[4];
+
 	area_id		regs_area;		// area of memory mapped registers
 	area_id		ROM_area;		// area of ROM
-	//area_id		fb_area;	// area of frame buffer
 	void		*framebuffer_pci;	// physical address of frame buffer (aka local memory)
-								// this is a hack needed by BeOS
+							// this is a hack needed by BeOS
 
 	crtc_info	crtc[2];		// info about each crtc
 	uint8		num_crtc;		// number of physical heads
@@ -557,6 +562,8 @@
 	uint32	active_vc;			// currently selected virtual card in terms of 2D acceleration
 		
 	uint32	dac_cntl2;			// content of dac_cntl2 register
+	uint32	tmds_pll_cntl;			// undocumented here be dragons
+	uint32	tmds_transmitter_cntl;		// undocumented here be dragons
 
 	overlay_info	pending_overlay;	// overlay to be shown
 	overlay_info	active_overlay;		// overlay shown

Modified: haiku/trunk/src/add-ons/accelerants/radeon/ProposeDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/ProposeDisplayMode.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/ProposeDisplayMode.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -148,6 +148,10 @@
 	int eff_virtual_width;
 	fp_info *flatpanel = &amp;si-&gt;flatpanels[crtc-&gt;flatpanel_port];
 
+	SHOW_FLOW( 4, &quot;CRTC %d, DVI %d&quot;, (crtc == &amp;si-&gt;crtc[0]) ? 0 : 1, crtc-&gt;flatpanel_port );
+	SHOW_FLOW( 4, &quot;X %d, virtX %d&quot;, target-&gt;timing.h_display,  target-&gt;virtual_width);
+	SHOW_FLOW( 4, &quot;fpRes %dx%d&quot;, flatpanel-&gt;panel_xres,  flatpanel-&gt;panel_yres);
+
 	// save refresh rate - we want to leave this (artifical) value untouched
 	// don't use floating point, we are in kernel mode
 	target_refresh = 
@@ -163,7 +167,7 @@
 	// for flat panels, check maximum resolution;
 	// all the other tricks (like fixed resolution and resulting scaling)
 	// are done automagically by set_display_mode
-    if( (crtc-&gt;chosen_displays &amp; (dd_lvds | dd_dvi | dd_dvi_ext)) != 0 ) {
+    if( (crtc-&gt;chosen_displays &amp; (dd_lvds | dd_dvi)) != 0 ) {
 		if( target-&gt;timing.h_display &gt; flatpanel-&gt;panel_xres )
 			target-&gt;timing.h_display = flatpanel-&gt;panel_xres;
 		
@@ -171,6 +175,17 @@
 			target-&gt;timing.v_display = flatpanel-&gt;panel_yres;
 	}
 
+	// for secondary flat panels there is no RMX unit for
+	// scaling up lower resolutions.  Until we can do centered timings
+	// we need to disable the screen unless it is the native resolution.
+	// if the DVI input has a scaler we would need to know about it somehow...
+    if( (crtc-&gt;chosen_displays &amp; dd_dvi_ext) != 0 ) {
+		SHOW_FLOW0( 4, &quot;external (secondary) DVI cannot support non-native resolutions&quot; );
+		if( ( target-&gt;timing.h_display != flatpanel-&gt;panel_xres ) ||
+			( target-&gt;timing.v_display != flatpanel-&gt;panel_yres ) )
+			return B_ERROR;
+	}
+
 /*
 	// the TV-Out encoder can &quot;only&quot; handle up to 1024x768
 	if( (head-&gt;chosen_displays &amp; (dd_ctv | dd_stv)) != 0 ) {
@@ -325,7 +340,7 @@
 	if( target-&gt;timing.pixel_clock / 10 &gt; pll-&gt;max_pll_freq || 
 		target-&gt;timing.pixel_clock / 10 * 12 &lt; pll-&gt;min_pll_freq ) 
 	{
-		SHOW_ERROR( 2, &quot;pixel_clock (%ld) out of range (%d, %d)&quot;, target-&gt;timing.pixel_clock, 
+		SHOW_ERROR( 4, &quot;pixel_clock (%ld) out of range (%d, %d)&quot;, target-&gt;timing.pixel_clock, 
 			pll-&gt;max_pll_freq * 10, pll-&gt;min_pll_freq / 12 );
 		return B_ERROR;
 	}
@@ -371,7 +386,7 @@
 
 	// make sure we haven't shrunk virtual height too much
 	if (target-&gt;virtual_height &lt; target-&gt;timing.v_display) {
-		SHOW_ERROR( 2, &quot;not enough memory for this mode (could show only %d of %d lines)&quot;, 
+		SHOW_ERROR( 4, &quot;not enough memory for this mode (could show only %d of %d lines)&quot;, 
 			target-&gt;virtual_height, target-&gt;timing.v_display );
 		return B_ERROR;
 	}
@@ -516,11 +531,11 @@
 {
 	shared_info *si = ai-&gt;si;
 	
-	fp_info *fp_info = &amp;si-&gt;flatpanels[0];
+	fp_info *fp_info = &amp;si-&gt;flatpanels[0];	//todo fix the hardcoding what about ext dvi?
 	
-    if( (ai-&gt;vc-&gt;connected_displays &amp; (dd_dvi | dd_lvds)) != 0 ) {
+    if( (ai-&gt;vc-&gt;connected_displays &amp; (dd_dvi | dd_dvi_ext | dd_lvds)) != 0 ) {
     	display_mode mode;
-    	
+    	SHOW_FLOW0( 2, &quot;&quot; );
 		mode.virtual_width = mode.timing.h_display = fp_info-&gt;panel_xres;
 		mode.virtual_height = mode.timing.v_display = fp_info-&gt;panel_yres;
 		
@@ -631,14 +646,14 @@
 	Radeon_DetectMultiMode( vc, target );
 	Radeon_VerifyMultiMode( vc, si, target );
 	
-	SHOW_FLOW0( 3, &quot;wished:&quot; );
-	SHOW_FLOW( 3, &quot;H: %4d %4d %4d %4d (v=%4d)&quot;, 
+	SHOW_FLOW0( 2, &quot;wished:&quot; );
+	SHOW_FLOW( 2, &quot;H: %4d %4d %4d %4d (v=%4d)&quot;, 
 		target-&gt;timing.h_display, target-&gt;timing.h_sync_start, 
 		target-&gt;timing.h_sync_end, target-&gt;timing.h_total, target-&gt;virtual_width );
-	SHOW_FLOW( 3, &quot;V: %4d %4d %4d %4d (h=%4d)&quot;, 
+	SHOW_FLOW( 2, &quot;V: %4d %4d %4d %4d (h=%4d)&quot;, 
 		target-&gt;timing.v_display, target-&gt;timing.v_sync_start, 
 		target-&gt;timing.v_sync_end, target-&gt;timing.v_total, target-&gt;virtual_height );
-	SHOW_FLOW( 3, &quot;clk: %ld&quot;, target-&gt;timing.pixel_clock );
+	SHOW_FLOW( 2, &quot;clk: %ld&quot;, target-&gt;timing.pixel_clock );
 	
 	// we must assure that each ProposeMode call doesn't tweak the mode in
 	// a way that it cannot be handled by the other port anymore
@@ -659,14 +674,14 @@
 		result2 = B_OK;
 	}
 	
-	SHOW_INFO0( 4, &quot;got:&quot; );
-	SHOW_INFO( 4, &quot;H: %4d %4d %4d %4d (v=%4d)&quot;, 
+	SHOW_INFO0( 2, &quot;got:&quot; );
+	SHOW_INFO( 2, &quot;H: %4d %4d %4d %4d (v=%4d)&quot;, 
 		target-&gt;timing.h_display, target-&gt;timing.h_sync_start, 
 		target-&gt;timing.h_sync_end, target-&gt;timing.h_total, target-&gt;virtual_width );
-	SHOW_INFO( 4, &quot;V: %4d %4d %4d %4d (h=%4d)&quot;, 
+	SHOW_INFO( 2, &quot;V: %4d %4d %4d %4d (h=%4d)&quot;, 
 		target-&gt;timing.v_display, target-&gt;timing.v_sync_start, 
 		target-&gt;timing.v_sync_end, target-&gt;timing.v_total, target-&gt;virtual_height );
-	SHOW_INFO( 4, &quot;clk: %ld&quot;, target-&gt;timing.pixel_clock );
+	SHOW_INFO( 2, &quot;clk: %ld&quot;, target-&gt;timing.pixel_clock );
 
 	Radeon_HideMultiMode( vc, target );
 	

Modified: haiku/trunk/src/add-ons/accelerants/radeon/SetDisplayMode.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/SetDisplayMode.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/SetDisplayMode.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -23,11 +23,20 @@
 #include &quot;fp_regs.h&quot;
 #include &quot;gpiopad_regs.h&quot;
 
+#include &quot;pll_regs.h&quot;
+#include &quot;tv_out_regs.h&quot;
+#include &quot;config_regs.h&quot;
+#include &quot;ddc_regs.h&quot;
+#include &quot;pll_access.h&quot;
+#include &quot;theatre_regs.h&quot;
 #include &quot;set_mode.h&quot;
+#include &quot;ddc.h&quot;
 
+#include &quot;set_mode.h&quot;
+
 #include &lt;string.h&gt;
 
-void Radeon_SetMode( 
+status_t Radeon_SetMode( 
 	accelerator_info *ai, crtc_info *crtc, display_mode *mode, impactv_params *tv_params );
 
 // round virtual width up to next valid size
@@ -94,7 +103,7 @@
 
 // set display mode of one head;
 // port restrictions, like fixed-sync TFTs connected to it, are taken care of
-void Radeon_SetMode( 
+status_t Radeon_SetMode( 
 	accelerator_info *ai, crtc_info *crtc, display_mode *mode, impactv_params *tv_params )
 {
 	virtual_card *vc = ai-&gt;vc;
@@ -126,11 +135,26 @@
 	// is determined by the physical resolution; 
 	// also, all timing is fixed
 	if( (disp_devices &amp; (dd_lvds | dd_dvi | dd_dvi_ext)) != 0 ) {
+		SHOW_FLOW0( 0, &quot;requested resolution higher than native panel&quot; );
 		if( mode-&gt;timing.h_display &gt; fp_info-&gt;panel_xres )
 			mode-&gt;timing.h_display = fp_info-&gt;panel_xres;
 		if(	mode-&gt;timing.v_display &gt; fp_info-&gt;panel_yres )
 			mode-&gt;timing.v_display = fp_info-&gt;panel_yres;
 		
+		if( (disp_devices &amp; dd_dvi_ext) != 0 ) {
+			SHOW_FLOW0( 0, &quot;requested resolution less than second native panel&quot; );
+			if( mode-&gt;timing.h_display &lt; fp_info-&gt;panel_xres )
+				mode-&gt;timing.h_display = fp_info-&gt;panel_xres;
+			if(	mode-&gt;timing.v_display &lt; fp_info-&gt;panel_yres )
+				mode-&gt;timing.v_display = fp_info-&gt;panel_yres;
+
+			//TODO at this point we know we are going to do centered timing
+			//need to set flags to a. blank the unused memory, b.center screen
+			//for now it's in the top corner, and surrounded by garbage.
+			// although if the DVI panels are the same size and we are cloning
+			// we can switch the FP2 source to RMX, and drive both screens from
+			// the RMX unit.
+		}
 		mode-&gt;timing.h_total = mode-&gt;timing.h_display + fp_info-&gt;h_blank;
 		mode-&gt;timing.h_sync_start = mode-&gt;timing.h_display + fp_info-&gt;h_over_plus;
 		mode-&gt;timing.h_sync_end = mode-&gt;timing.h_sync_start + fp_info-&gt;h_sync_width;
@@ -254,6 +278,28 @@
 			Radeon_TheatreProgramTVRegisters( ai, &amp;impactv_values );
 	}
 
+	// spit out some debug stuff in a radeontool stylee
+	SHOW_FLOW0( 0, &quot;&quot; );
+	SHOW_FLOW( 0, &quot;RADEON_DAC_CNTL %08X &quot;, INREG( regs, RADEON_DAC_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_DAC_CNTL2 %08X &quot;, INREG( regs, RADEON_DAC_CNTL2 ));
+	SHOW_FLOW( 0, &quot;RADEON_TV_DAC_CNTL %08X &quot;, INREG( regs, RADEON_TV_DAC_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_DISP_OUTPUT_CNTL %08X &quot;, INREG( regs, RADEON_DISP_OUTPUT_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_AUX_SC_CNTL %08X &quot;, INREG( regs, RADEON_AUX_SC_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_CRTC_EXT_CNTL %08X &quot;, INREG( regs, RADEON_CRTC_EXT_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_CRTC_GEN_CNTL %08X &quot;, INREG( regs, RADEON_CRTC_GEN_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_CRTC2_GEN_CNTL %08X &quot;, INREG( regs, RADEON_CRTC2_GEN_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_DISP_MISC_CNTL %08X &quot;, INREG( regs, RADEON_DISP_MISC_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_FP_GEN_CNTL %08X &quot;, INREG( regs, RADEON_FP_GEN_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_FP2_GEN_CNTL %08X &quot;, INREG( regs, RADEON_FP2_GEN_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_LVDS_GEN_CNTL %08X &quot;, INREG( regs, RADEON_LVDS_GEN_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_TMDS_PLL_CNTL %08X &quot;, INREG( regs, RADEON_TMDS_PLL_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_TMDS_TRANSMITTER_CNTL %08X &quot;, INREG( regs, RADEON_TMDS_TRANSMITTER_CNTL ));
+	SHOW_FLOW( 0, &quot;RADEON_FP_H_SYNC_STRT_WID %08X &quot;, INREG( regs, RADEON_FP_H_SYNC_STRT_WID ));
+	SHOW_FLOW( 0, &quot;RADEON_FP_V_SYNC_STRT_WID %08X &quot;, INREG( regs, RADEON_FP_V_SYNC_STRT_WID ));
+	SHOW_FLOW( 0, &quot;RADEON_FP_H2_SYNC_STRT_WID %08X &quot;, INREG( regs, RADEON_FP_H2_SYNC_STRT_WID ));
+	SHOW_FLOW( 0, &quot;RADEON_FP_V2_SYNC_STRT_WID %08X &quot;, INREG( regs, RADEON_FP_V2_SYNC_STRT_WID ));
+	// spit end
+
 	crtc-&gt;active_displays = disp_devices;
 	
 	// programming is over, so hardware can be used again
@@ -263,6 +309,8 @@
 	// TBD: this won't work if another virtual card was using it,
 	// but currently, virtual cards don't work anyway...
 	si-&gt;active_overlay.crtc_idx = -1;
+
+	return B_OK;
 }
 
 
@@ -432,6 +480,8 @@
 	{
 		routing_regs routing_values;
 		impactv_params tv_params;
+		status_t err1 , err2;
+		err1 = err2 = B_OK;
 	
 		// we first switch off all output, so the monitor(s) won't get invalid signals
 		if( vc-&gt;assigned_crtc[0] ) {
@@ -451,10 +501,14 @@
 	
 		// then change the mode
 		if( vc-&gt;used_crtc[0] )
-			Radeon_SetMode( ai, &amp;si-&gt;crtc[0], &amp;mode, &amp;tv_params );
+			err1 = Radeon_SetMode( ai, &amp;si-&gt;crtc[0], &amp;mode, &amp;tv_params );
 		if( vc-&gt;used_crtc[1] )
-			Radeon_SetMode( ai, &amp;si-&gt;crtc[1], &amp;mode, &amp;tv_params );
+			err2 = Radeon_SetMode( ai, &amp;si-&gt;crtc[1], &amp;mode, &amp;tv_params );
 			
+		
+		SHOW_FLOW( 2, &quot;SetModes 1=%s, 2=%s&quot;, 
+			(err1 == B_OK) ? &quot;OK&quot; : &quot;FAIL&quot;, (err2 == B_OK) ? &quot;OK&quot; : &quot;FAIL&quot;);
+
 		// setup signal routing
 		Radeon_ReadMonitorRoutingRegs( ai, &amp;routing_values );
 		Radeon_CalcMonitorRouting( ai, &amp;tv_params, &amp;routing_values );
@@ -462,9 +516,9 @@
 	   	
 		// finally, switch display(s) on
 		if( vc-&gt;used_crtc[0] )
-			Radeon_SetDPMS( ai, 0, B_DPMS_ON );
+			Radeon_SetDPMS( ai, 0, (err1 == B_OK) ? B_DPMS_ON : B_DPMS_SUSPEND );
 		if( vc-&gt;used_crtc[1] )
-			Radeon_SetDPMS( ai, 1, B_DPMS_ON );
+			Radeon_SetDPMS( ai, 1, (err2 == B_OK) ? B_DPMS_ON : B_DPMS_SUSPEND );
 			
 		OUTREGP( ai-&gt;regs, RADEON_CRTC_EXT_CNTL, 0, ~RADEON_CRTC_DISPLAY_DIS );
 	}

Modified: haiku/trunk/src/add-ons/accelerants/radeon/flat_panel.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/flat_panel.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/flat_panel.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -108,7 +108,7 @@
 	accelerator_info *ai, fp_regs *values )
 {
 	vuint8 *regs = ai-&gt;regs;
-
+	SHOW_FLOW0( 2, &quot;&quot; );
 	OUTREG( regs, RADEON_FP_HORZ_STRETCH, values-&gt;fp_horz_stretch );
 	OUTREG( regs, RADEON_FP_VERT_STRETCH, values-&gt;fp_vert_stretch );
 }
@@ -119,9 +119,11 @@
 {
 	vuint8 *regs = ai-&gt;regs;
 
-    values-&gt;fp_gen_cntl = INREG( regs, RADEON_FP_GEN_CNTL );
-    values-&gt;fp2_gen_cntl = INREG( regs, RADEON_FP2_GEN_CNTL );
-    values-&gt;lvds_gen_cntl = INREG( regs, RADEON_LVDS_GEN_CNTL );
+	values-&gt;fp_gen_cntl = INREG( regs, RADEON_FP_GEN_CNTL );
+	values-&gt;fp2_gen_cntl = INREG( regs, RADEON_FP2_GEN_CNTL );
+	values-&gt;lvds_gen_cntl = INREG( regs, RADEON_LVDS_GEN_CNTL );
+	values-&gt;tmds_pll_cntl = INREG( regs, RADEON_TMDS_PLL_CNTL );
+	values-&gt;tmds_trans_cntl = INREG( regs, RADEON_TMDS_TRANSMITTER_CNTL );
 	values-&gt;fp_h_sync_strt_wid = INREG( regs, RADEON_FP_H_SYNC_STRT_WID );
 	values-&gt;fp_v_sync_strt_wid = INREG( regs, RADEON_FP_V_SYNC_STRT_WID );
 	values-&gt;fp2_h_sync_strt_wid = INREG( regs, RADEON_FP_H2_SYNC_STRT_WID );
@@ -130,9 +132,14 @@
 	values-&gt;bios_5_scratch =  INREG( regs, RADEON_BIOS_5_SCRATCH );
 	values-&gt;bios_6_scratch =  INREG( regs, RADEON_BIOS_6_SCRATCH );
 
-    SHOW_FLOW( 2, &quot;before: fp_gen_cntl=%08lx, horz=%08lx, vert=%08lx, lvds_gen_cntl=%08lx&quot;,
-    	values-&gt;fp_gen_cntl, values-&gt;fp_horz_stretch, values-&gt;fp_vert_stretch, 
-    	values-&gt;lvds_gen_cntl );
+	if (ai-&gt;si-&gt;asic == rt_rv280) {
+		// bit 22 of TMDS_PLL_CNTL is read-back inverted
+		values-&gt;tmds_pll_cntl ^= (1 &lt;&lt; 22);
+	}
+
+	SHOW_FLOW( 2, &quot;before: fp_gen_cntl=%08lx, horz=%08lx, vert=%08lx, lvds_gen_cntl=%08lx&quot;,
+    		values-&gt;fp_gen_cntl, values-&gt;fp_horz_stretch, values-&gt;fp_vert_stretch, 
+    		values-&gt;lvds_gen_cntl );
 }
 
 // calculcate flat panel crtc registers;
@@ -141,20 +148,27 @@
 	accelerator_info *ai, crtc_info *crtc, 
 	fp_info *fp_port, crtc_regs *crtc_values, fp_regs *values )
 {
+	int i;
+	uint32 tmp = values-&gt;tmds_pll_cntl &amp; 0xfffff;
+
 	// setup synchronization position
 	// (most values are ignored according to fp_gen_cntl, but at least polarity
 	//  and pixel precise horizontal sync position are always used)
 	if( fp_port-&gt;is_fp2 ) {
+		SHOW_FLOW0( 2, &quot;is_fp2&quot; );
 		values-&gt;fp2_h_sync_strt_wid = crtc_values-&gt;crtc_h_sync_strt_wid;
 		values-&gt;fp2_v_sync_strt_wid = crtc_values-&gt;crtc_v_sync_strt_wid;
 	} else {
+		SHOW_FLOW0( 2, &quot;fp1&quot; );
 		values-&gt;fp_h_sync_strt_wid = crtc_values-&gt;crtc_h_sync_strt_wid;
 		values-&gt;fp_v_sync_strt_wid = crtc_values-&gt;crtc_v_sync_strt_wid;
 	}
 
-	if( fp_port-&gt;is_fp2 )
-		values-&gt;fp2_gen_cntl = 0;
-	else {
+	if( fp_port-&gt;is_fp2 ) {
+		// should retain POST values (esp bit 28)
+		values-&gt;fp2_gen_cntl &amp;= (0xFFFF0000);
+
+	} else {
 		// setup magic CRTC shadowing 	
 		values-&gt;fp_gen_cntl &amp;= 
 			~(RADEON_FP_RMX_HVSYNC_CONTROL_EN |
@@ -169,29 +183,64 @@
 			RADEON_FP_CRTC_DONT_SHADOW_HEND;
 	}
 	
+	for (i = 0; i &lt; 4; i++) {
+		if (ai-&gt;si-&gt;tmds_pll[i].freq == 0) 
+			break;
+		if ((uint32)(fp_port-&gt;dot_clock) &lt; ai-&gt;si-&gt;tmds_pll[i].freq) {
+			tmp = ai-&gt;si-&gt;tmds_pll[i].value ;
+			break;
+		}
+	}
+
+	if (IS_R300_VARIANT || (ai-&gt;si-&gt;asic == rt_rv280)) {
+		if (tmp &amp; 0xfff00000) {
+			values-&gt;tmds_pll_cntl = tmp;
+		} else {
+			values-&gt;tmds_pll_cntl = ai-&gt;si-&gt;tmds_pll_cntl &amp; 0xfff00000;
+			values-&gt;tmds_pll_cntl |= tmp;
+		}
+	} else {
+		values-&gt;tmds_pll_cntl = tmp;
+	}
+
+	values-&gt;tmds_trans_cntl = ai-&gt;si-&gt;tmds_transmitter_cntl 
+		&amp; ~(RADEON_TMDS_TRANSMITTER_PLLRST);
+
+	if (IS_R300_VARIANT || (ai-&gt;si-&gt;asic == rt_r200) || (ai-&gt;si-&gt;num_crtc == 1))
+		values-&gt;tmds_trans_cntl &amp;= ~(RADEON_TMDS_TRANSMITTER_PLLEN);
+	else // weird, RV chips got this bit reversed?
+		values-&gt;tmds_trans_cntl |= (RADEON_TMDS_TRANSMITTER_PLLEN);
+
+
 	// enable proper transmitter	
 	if( (crtc-&gt;chosen_displays &amp; dd_lvds) != 0 ) {
 		// using LVDS means there cannot be a DVI monitor
+		SHOW_FLOW0( 2, &quot;lvds&quot; );
 		values-&gt;lvds_gen_cntl |= (RADEON_LVDS_ON | RADEON_LVDS_BLON);
 		values-&gt;fp_gen_cntl &amp;= ~(RADEON_FP_FPON | RADEON_FP_TMDS_EN);
 		
 	} else if( !fp_port-&gt;is_fp2 ) {
 		// DVI on internal transmitter
+		SHOW_FLOW0( 2, &quot;DVI INT&quot; );
 		values-&gt;fp_gen_cntl |= RADEON_FP_FPON | RADEON_FP_TMDS_EN;
 		// enabling 8 bit data may be dangerous; BIOS should have taken care of that
 		values-&gt;fp_gen_cntl |= RADEON_FP_PANEL_FORMAT;
 		
 	} else {
 		// DVI on external transmitter
+		SHOW_FLOW0( 2, &quot;DVI EXT&quot; );
 		values-&gt;fp2_gen_cntl |= RADEON_FP2_FPON | RADEON_FP_PANEL_FORMAT;
 		values-&gt;fp2_gen_cntl &amp;= ~RADEON_FP2_BLANK_EN;
 		
+		//hack in missing bits test...
+		//values-&gt;fp2_gen_cntl |= (1 &lt;&lt; 22) | (1 &lt;&lt; 28);
+
 		if( ai-&gt;si-&gt;asic &gt;= rt_r200 )
 			values-&gt;fp2_gen_cntl |= RADEON_FP2_DV0_EN;
 	}
 		
-    SHOW_FLOW( 2, &quot;after: fp_gen_cntl=%08lx, horz=%08lx, vert=%08lx, lvds_gen_cntl=%08lx&quot;,
-    	values-&gt;fp_gen_cntl, values-&gt;fp_horz_stretch, values-&gt;fp_vert_stretch, 
+    SHOW_FLOW( 2, &quot;after: fp_gen_cntl=%08lx, fp2_gen_cntl=%08lx, horz=%08lx, vert=%08lx, lvds_gen_cntl=%08lx&quot;,
+    	values-&gt;fp_gen_cntl, values-&gt;fp2_gen_cntl, values-&gt;fp_horz_stretch, values-&gt;fp_vert_stretch, 
     	values-&gt;lvds_gen_cntl );
 }
 
@@ -209,11 +258,15 @@
 	OUTREGP( regs, RADEON_FP_GEN_CNTL, values-&gt;fp_gen_cntl, RADEON_FP_SEL_CRTC2 );
 
 	if( fp_port-&gt;is_fp2 ) {
+		SHOW_FLOW0( 2, &quot;is_fp2&quot; );
 		OUTREGP( regs, RADEON_FP2_GEN_CNTL, values-&gt;fp2_gen_cntl, 
+			~(RADEON_FP2_SOURCE_SEL_MASK | RADEON_FP2_SRC_SEL_MASK));
+		OUTREGP( regs, RADEON_FP2_GEN_CNTL, values-&gt;fp2_gen_cntl, 
 			RADEON_FP2_SOURCE_SEL_CRTC2 | RADEON_FP2_SRC_SEL_CRTC2 );
 		OUTREG( regs, RADEON_FP_H2_SYNC_STRT_WID, values-&gt;fp2_h_sync_strt_wid );
 		OUTREG( regs, RADEON_FP_V2_SYNC_STRT_WID, values-&gt;fp2_v_sync_strt_wid );
 	} else {
+		SHOW_FLOW0( 2, &quot;is_fp1&quot; );
 		OUTREG( regs, RADEON_FP_H_SYNC_STRT_WID, values-&gt;fp_h_sync_strt_wid );
 		OUTREG( regs, RADEON_FP_V_SYNC_STRT_WID, values-&gt;fp_v_sync_strt_wid );
 	}

Modified: haiku/trunk/src/add-ons/accelerants/radeon/monitor_detection.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/monitor_detection.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/monitor_detection.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -269,19 +269,19 @@
     	RADEON_DAC_FORCE_DATA_SEL_RGB |
     	(0x1b6 &lt;&lt; RADEON_DAC_FORCE_DATA_SHIFT ));
     	
-    old_dac_cntl2 = INREG( regs, RADEON_DAC_CNTL2 );
+	old_dac_cntl2 = INREG( regs, RADEON_DAC_CNTL2 );
 
 	// enable CRT mode of TV-DAC and enable comparator    
-    tmp = old_dac_cntl2 | RADEON_DAC2_CLK_SEL_CRT | RADEON_DAC2_CMP_EN;
+	tmp = old_dac_cntl2 | RADEON_DAC2_CLK_SEL_CRT | RADEON_DAC2_CMP_EN;
     
-    OUTREG( regs, RADEON_DAC_CNTL2, tmp );
+	OUTREG( regs, RADEON_DAC_CNTL2, tmp );
     
-    snooze( 10000 );
+	snooze( 10000 );
     
-    // check connection of blue data signal to see whether there is a CRT
+	// check connection of blue data signal to see whether there is a CRT
 	found = (INREG( regs, RADEON_DAC_CNTL2 ) &amp; RADEON_DAC2_CMP_OUT_B) != 0;
     
-    // clean up the mess
+	// clean up the mess
 	OUTREG( regs, RADEON_DAC_CNTL2, old_dac_cntl2 );
 	OUTREG( regs, RADEON_DAC_EXT_CNTL, 0 );
 	OUTREG( regs, RADEON_TV_DAC_CNTL, old_tv_dac_cntl );
@@ -289,7 +289,7 @@
 
 	OUTREGP( regs, RADEON_GPIOPAD_A, old_radeon_gpiopad_a, ~1 );
     
-    return found;
+	return found;
 }
 
 
@@ -800,9 +800,9 @@
 }
 	
 // read edid data of flat panel and setup its timing accordingly
-static status_t Radeon_StoreFPEDID( accelerator_info *ai, const edid1_info *edid )
+static status_t Radeon_StoreFPEDID( accelerator_info *ai, int port, const edid1_info *edid )
 {
-	fp_info *fp = &amp;ai-&gt;si-&gt;flatpanels[0];
+	fp_info *fp = &amp;ai-&gt;si-&gt;flatpanels[port];
 	uint32 max_hsize, max_vsize;
 
 	//SHOW_FLOW0( 2, &quot;EDID data read from DVI port via DDC2:&quot; );
@@ -954,10 +954,12 @@
 	// use DDC to detect monitors - if we can read DDC, there must be a monitor
 	for ( i = 0; i &lt; 2; i++ )
 	{
-		if (routes-&gt;port_info[i].mon_type != mt_unknown ) {
-			SHOW_FLOW0( 2, &quot;known type, skpping detection&quot; );	
-			continue;
-		}
+		//TODO could skip edid reading instead if we already have it, but what
+		//if monitors have been hot swapped?  Also rely on edid for DVI-D detection
+		//if (routes-&gt;port_info[i].mon_type != mt_unknown ) {
+		//	SHOW_FLOW0( 2, &quot;known type, skpping detection&quot; );	
+		//	continue;
+		//}
 		
 		memset( &amp;routes-&gt;port_info[i].edid , 0, sizeof(edid1_info) );
 		switch ( routes-&gt;port_info[i].ddc_type ) {
@@ -993,9 +995,10 @@
 				// both LDVS and TMDS are disable, we still need to treat it as a LVDS panel.
 				if ( routes-&gt;port_info[i].tmds_type == tmds_ext ){
 					// store info about DVI-connected flat-panel
-					if( Radeon_StoreFPEDID( ai, &amp;routes-&gt;port_info[i].edid ) == B_OK ) {
+					if( Radeon_StoreFPEDID( ai, i, &amp;routes-&gt;port_info[i].edid ) == B_OK ) {
 						SHOW_INFO0( 2, &quot;Found Ext Laptop DVI&quot; );
 						routes-&gt;port_info[i].mon_type = mt_dfp;
+						ai-&gt;si-&gt;flatpanels[i].is_fp2 = true;
 						displays |= dd_dvi_ext;
 					} else {
 						SHOW_ERROR0( 2, &quot;Disabled Ext DVI - invalid EDID&quot; );
@@ -1003,7 +1006,7 @@
 				} else {
 					if( INREG( ai-&gt;regs, RADEON_FP_GEN_CNTL) &amp; (1 &lt;&lt; 7) || ( !si-&gt;is_mobility ) ) {
 						// store info about DVI-connected flat-panel
-						if( Radeon_StoreFPEDID( ai, &amp;routes-&gt;port_info[i].edid ) == B_OK ) {
+						if( Radeon_StoreFPEDID( ai, i, &amp;routes-&gt;port_info[i].edid ) == B_OK ) {
 							SHOW_INFO0( 2, &quot;Found DVI&quot; );
 							routes-&gt;port_info[i].mon_type = mt_dfp;
 							displays |= dd_dvi;
@@ -1015,6 +1018,7 @@
 						routes-&gt;port_info[i].mon_type = mt_lcd;
 						displays |= dd_lvds;
 					}
+					ai-&gt;si-&gt;flatpanels[1].is_fp2 = FALSE;
 				}
 			} else {
 				// must be the analog portion of DVI
@@ -1049,7 +1053,7 @@
 		if ( si-&gt;is_mobility &amp;&amp; (INREG( ai-&gt;regs, RADEON_FP2_GEN_CNTL) &amp; RADEON_FP2_FPON)) {
 			SHOW_INFO0( 2, &quot;Found Ext Laptop DVI&quot; );
 			routes-&gt;port_info[1].mon_type = mt_dfp;
-			displays |= dd_dvi;
+			displays |= dd_dvi_ext;
 		}
 	}
 	

Modified: haiku/trunk/src/add-ons/accelerants/radeon/monitor_routing.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/monitor_routing.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/monitor_routing.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -634,9 +634,12 @@
 		else if( ai-&gt;si-&gt;num_crtc &gt; 1 &amp;&amp; (crtc2_displays &amp; ~(dd_stv | dd_ctv)) == 0 &amp;&amp; vc-&gt;assigned_crtc[1] )
 			crtc2_displays |= dd_tv_crt;
 	}
+
+	if( (display_devices &amp; dd_dvi_ext) != 0 )
+		crtc2_displays |= dd_dvi_ext;
+
+	SHOW_FLOW( 2, &quot;CRTC1: 0x%x, CRTC2: 0x%x&quot;, crtc1_displays, crtc2_displays );
 	
-	SHOW_FLOW( 3, &quot;CRTC1: 0x%x, CRTC2: 0x%x&quot;, crtc1_displays, crtc2_displays );
-	
 	*crtc1 = crtc1_displays;
 	*crtc2 = crtc2_displays;
 }
@@ -651,7 +654,7 @@
 	shared_info *si = ai-&gt;si;
 	display_device_e display_devices = vc-&gt;connected_displays;
 
-	if (ai-&gt;si-&gt;settings.force_lcd) {	
+	if (ai-&gt;si-&gt;settings.force_lcd) {
 		use_laptop_panel = true;
 		SHOW_FLOW0( 2, 	&quot;LCD Forced Used by Kernel Settings&quot;);
 	}

Modified: haiku/trunk/src/add-ons/accelerants/radeon/radeon_accelerant.h
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/radeon_accelerant.h	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/radeon_accelerant.h	2007-08-13 17:22:32 UTC (rev 21930)
@@ -32,7 +32,7 @@
 
 #define DEBUG_MSG_PREFIX &quot;Radeon - &quot;
 
-#define DEBUG_MAX_LEVEL_FLOW 2
+#define DEBUG_MAX_LEVEL_FLOW 3
 
 #include &quot;debug_ext.h&quot;
 

Modified: haiku/trunk/src/add-ons/accelerants/radeon/set_mode.h
===================================================================
--- haiku/trunk/src/add-ons/accelerants/radeon/set_mode.h	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/accelerants/radeon/set_mode.h	2007-08-13 17:22:32 UTC (rev 21930)
@@ -98,17 +98,19 @@
 typedef struct {
 	uint32		fp_gen_cntl;
 	uint32		fp_panel_cntl;
-    uint32		lvds_gen_cntl;
+	uint32		lvds_gen_cntl;
+	uint32		tmds_pll_cntl;
+	uint32		tmds_trans_cntl;
 	uint32		fp_h_sync_strt_wid;
 	uint32		fp_v_sync_strt_wid;
 	uint32		fp2_gen_cntl;
     
-    uint32		fp2_h_sync_strt_wid;
+	uint32		fp2_h_sync_strt_wid;
 	uint32		fp2_v_sync_strt_wid;
 	
 	// RMX registers
 	uint32		fp_horz_stretch;
-    uint32		fp_vert_stretch;
+	uint32		fp_vert_stretch;
 
 	// Bios values used by Mobility Asics
 	uint32		bios_4_scratch;

Modified: haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/bios.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/bios.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/bios.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -31,14 +31,33 @@
 
 #define RADEON_BIOS8(v) 	 (di-&gt;rom.rom_ptr[v])
 #define RADEON_BIOS16(v) 	((di-&gt;rom.rom_ptr[v]) | \
-						  	 (di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8))
+				(di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8))
 #define RADEON_BIOS32(v) 	((di-&gt;rom.rom_ptr[v]) | \
-							 (di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8) \
-							 (di-&gt;rom.rom_ptr[(v) + 2] &lt;&lt; 16) \
-							 (di-&gt;rom.rom_ptr[(v) + 3] &lt;&lt; 24))
+				(di-&gt;rom.rom_ptr[(v) + 1] &lt;&lt; 8) | \
+				(di-&gt;rom.rom_ptr[(v) + 2] &lt;&lt; 16) | \
+				(di-&gt;rom.rom_ptr[(v) + 3] &lt;&lt; 24))
 
 static const char ati_rom_sig[] = &quot;761295520&quot;;
 
+static const tmds_pll_info default_tmds_pll[14][4] =
+{
+    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// r100
+    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rv100
+    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},						// rs100
+    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rv200
+    {{12000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// rs200
+    {{15000, 0xa1b}, {0xffffffff, 0xa3f}, {0, 0}, {0, 0}},			// r200
+    {{15500, 0x81b}, {0xffffffff, 0x83f}, {0, 0}, {0, 0}},			// rv250
+    {{0, 0}, {0, 0}, {0, 0}, {0, 0}},						// rs300
+    {{13000, 0x400f4}, {15000, 0x400f7}, {0xffffffff, 0x40111}, {0, 0}}, 	// rv280
+    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r300
+    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r350
+    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},			// rv350
+    {{15000, 0xb0155}, {0xffffffff, 0xb01cb}, {0, 0}, {0, 0}},			// rv380
+    {{0xffffffff, 0xb01cb}, {0, 0}, {0, 0}, {0, 0}},				// r420
+};
+
+
 // find address of ROM;
 // this code is really nasty as maintaining the radeon signatures
 // is almost impossible (the signatures provided by ATI are always out-dated);
@@ -691,7 +710,109 @@
 		&gt;&gt; RADEON_CRTC_V_SYNC_WID_SHIFT);
 }
 
+//snaffled from X.org hope it works...
+static void Radeon_GetTMDSInfoFromBios( device_info *di )
+{
+    uint32 tmp, maxfreq;
+    uint32 found = FALSE;
+    int i, n;
+    uint16 bios_header;
 
+    bios_header = RADEON_BIOS16( 0x48 );
+
+	for (i = 0; i &lt; 4; i++) {
+        di-&gt;tmds_pll[i].value = 0;
+        di-&gt;tmds_pll[i].freq = 0;
+    }
+    
+	if (di-&gt;is_atombios)
+	{
+		int master_data_start;
+		master_data_start = RADEON_BIOS16( bios_header + 32 );
+		
+		if((tmp = RADEON_BIOS16 (master_data_start + 18))) {
+	
+		    maxfreq = RADEON_BIOS16(tmp + 4);
+		    
+		    for (i = 0; i &lt; 4; i++) {
+				di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + i * 6 + 6);
+				// This assumes each field in TMDS_PLL has 6 bit as in R300/R420
+				di-&gt;tmds_pll[i].value = ((RADEON_BIOS8(tmp + i * 6 + 8) &amp; 0x3f) |
+				   ((RADEON_BIOS8(tmp + i * 6 + 10) &amp; 0x3f) &lt;&lt; 6) |
+				   ((RADEON_BIOS8(tmp + i * 6 +  9) &amp; 0xf) &lt;&lt; 12) |
+				   ((RADEON_BIOS8(tmp + i * 6 + 11) &amp; 0xf) &lt;&lt; 16));
+				SHOW_ERROR( 2, &quot;TMDS PLL from BIOS: %ld %lx&quot;, 
+				   di-&gt;tmds_pll[i].freq, di-&gt;tmds_pll[i].value);
+				       
+				if (maxfreq == di-&gt;tmds_pll[i].freq) {
+				    di-&gt;tmds_pll[i].freq = 0xffffffff;
+				    break;
+				}
+		    }
+		    found = TRUE;
+		}
+    } else {
+
+		tmp = RADEON_BIOS16(bios_header + 0x34);
+		if (tmp) {
+		    SHOW_ERROR( 2, &quot;DFP table revision: %d&quot;, RADEON_BIOS8(tmp));
+		    if (RADEON_BIOS8(tmp) == 3) {
+				n = RADEON_BIOS8(tmp + 5) + 1;
+				if (n &gt; 4) 
+					n = 4;
+				for (i = 0; i &lt; n; i++) {
+					di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + i * 10 + 0x08);
+					di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + i * 10 + 0x10);
+				}
+				found = TRUE;
+		    } else if (RADEON_BIOS8(tmp) == 4) {
+		        int stride = 0;
+				n = RADEON_BIOS8(tmp + 5) + 1;
+				if (n &gt; 4) 
+					n = 4;
+				for (i = 0; i &lt; n; i++) {
+				    di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + stride + 0x08);
+				    di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + stride + 0x10);
+				    if (i == 0) 
+				    	stride += 10;
+				    else 
+				    	stride += 6;
+				}
+				found = TRUE;
+		    }
+	
+		    // revision 4 has some problem as it appears in RV280, 
+		    // comment it off for now, use default instead    
+			/*
+				else if (RADEON_BIOS8(tmp) == 4) {
+				int stride = 0;
+				n = RADEON_BIOS8(tmp + 5) + 1;
+				if (n &gt; 4) n = 4;
+				for (i = 0; i &lt; n; i++) {
+					di-&gt;tmds_pll[i].value = RADEON_BIOS32(tmp + stride + 0x08);
+					di-&gt;tmds_pll[i].freq = RADEON_BIOS16(tmp + stride + 0x10);
+					if (i == 0) 
+						stride += 10;
+					else 
+						stride += 6;
+				}
+				found = TRUE;
+			}
+			*/
+		    
+		}
+    }
+    
+    if (found == FALSE) {
+    	for (i = 0; i &lt; 4; i++) {
+	        di-&gt;tmds_pll[i].value = default_tmds_pll[di-&gt;asic][i].value;
+	        di-&gt;tmds_pll[i].freq = default_tmds_pll[di-&gt;asic][i].freq;
+	        SHOW_ERROR( 2, &quot;TMDS PLL from DEFAULTS: %ld %lx&quot;, 
+				di-&gt;tmds_pll[i].freq, di-&gt;tmds_pll[i].value);
+    	}
+    }
+}
+
 /*
 // get everything in terms of monitors connected to the card
 static void Radeon_GetBIOSMon( device_info *di )
@@ -964,6 +1085,12 @@
 	di-&gt;routing.port_info[0].dac_type = dac_unknown;
 	di-&gt;routing.port_info[0].tmds_type = tmds_unknown;
 	di-&gt;routing.port_info[0].connector_type = connector_none;
+
+	di-&gt;routing.port_info[1].mon_type = mt_unknown;
+	di-&gt;routing.port_info[1].ddc_type = ddc_none_detected;
+	di-&gt;routing.port_info[1].dac_type = dac_unknown;
+	di-&gt;routing.port_info[1].tmds_type = tmds_unknown;
+	di-&gt;routing.port_info[1].connector_type = connector_none;
 	
 	if ( !Radeon_GetConnectorInfoFromBIOS( di ) )
 	{
@@ -981,6 +1108,7 @@
 
 	}
 	Radeon_GetFPData( di );
+	Radeon_GetTMDSInfoFromBios( di );
 	Radeon_DetectRAM( di );
 	
 	Radeon_UnmapDevice( di );

Modified: haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/init.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/init.c	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/init.c	2007-08-13 17:22:32 UTC (rev 21930)
@@ -15,6 +15,7 @@
 */
 
 #include &quot;dac_regs.h&quot;
+#include &quot;tv_out_regs.h&quot;
 #include &quot;fp_regs.h&quot;
 #include &quot;mmio.h&quot;
 #include &quot;radeon_driver.h&quot;
@@ -266,20 +267,17 @@
 	// so we let the first accelerant take care of it
 	si-&gt;theatre_channel = -1;
 	
-/*	si-&gt;ports[0].disp_type = di-&gt;disp_type[0];
-	si-&gt;ports[1].disp_type = di-&gt;disp_type[1];*/
 	si-&gt;crtc[0].crtc_idx = 0;
 	si-&gt;crtc[0].flatpanel_port = 0;
 	si-&gt;crtc[1].crtc_idx = 1;
 	si-&gt;crtc[1].flatpanel_port = 1;
 	si-&gt;num_crtc = di-&gt;num_crtc;
 	
-	si-&gt;flatpanels[0] = di-&gt;fp_info;
+	if (di-&gt;is_mobility)
+		si-&gt;flatpanels[0] = di-&gt;fp_info;
+
 	si-&gt;pll = di-&gt;pll;
-/*	si-&gt;ram = di-&gt;ram;
-	strcpy( si-&gt;ram_type, di-&gt;ram_type );*/
-	//si-&gt;local_mem_size = di-&gt;local_mem_size;
-		
+
 	// create virtual card info; don't allow access by apps -
 	// they'll clone it 
 	sprintf( buffer, &quot;%04X_%04X_%02X%02X%02X virtual card 0&quot;,
@@ -306,7 +304,7 @@
 	di-&gt;vc-&gt;assigned_crtc[0] = true;
 	di-&gt;vc-&gt;assigned_crtc[1] = si-&gt;num_crtc &gt; 1;
 	di-&gt;vc-&gt;controlled_displays = 
-		dd_tv_crt | dd_crt | dd_lvds | dd_dvi | dd_ctv | dd_stv;
+		dd_tv_crt | dd_crt | dd_lvds | dd_dvi | dd_dvi_ext | dd_ctv | dd_stv;
 
 	di-&gt;vc-&gt;fb_mem_handle = 0;
 	di-&gt;vc-&gt;cursor.mem_handle = 0;
@@ -324,13 +322,21 @@
 	if( di-&gt;asic == rt_rv100 &amp;&amp; di-&gt;is_mobility)
 		di-&gt;dac2_cntl = INREG( di-&gt;regs, RADEON_DAC_CNTL2 );
 	
+	memcpy(&amp;si-&gt;tmds_pll, &amp;di-&gt;tmds_pll, sizeof(di-&gt;tmds_pll));
+	si-&gt;tmds_pll_cntl = INREG( di-&gt;regs, RADEON_TMDS_PLL_CNTL);
+	si-&gt;tmds_transmitter_cntl = INREG( di-&gt;regs, RADEON_TMDS_TRANSMITTER_CNTL);
+
 	// print these out to capture bios status...
-	if ( di-&gt;is_mobility ) {
-		SHOW_INFO0( 4, &quot;Copy of Laptop Display Regs for Reference:&quot;);
-		SHOW_INFO( 4, &quot;LVDS CNTL = %8lx&quot;, INREG( di-&gt;regs, RADEON_LVDS_GEN_CNTL ));
-		SHOW_INFO( 4, &quot;FP1  CNTL = %8lx&quot;, INREG( di-&gt;regs, RADEON_FP_GEN_CNTL ));
-		SHOW_INFO( 4, &quot;FP2  CNTL = %8lx&quot;, INREG( di-&gt;regs, RADEON_FP2_GEN_CNTL ));
-	}
+//	if ( di-&gt;is_mobility ) {
+		SHOW_INFO0( 2, &quot;Copy of Laptop Display Regs for Reference:&quot;);
+		SHOW_INFO( 2, &quot;LVDS GEN = %8lx&quot;, INREG( di-&gt;regs, RADEON_LVDS_GEN_CNTL ));
+		SHOW_INFO( 2, &quot;LVDS PLL = %8lx&quot;, INREG( di-&gt;regs, RADEON_LVDS_PLL_CNTL ));
+		SHOW_INFO( 2, &quot;TMDS PLL = %8lx&quot;, INREG( di-&gt;regs, RADEON_TMDS_PLL_CNTL ));
+		SHOW_INFO( 2, &quot;TMDS TRANS = %8lx&quot;, INREG( di-&gt;regs, RADEON_TMDS_TRANSMITTER_CNTL ));
+		SHOW_INFO( 2, &quot;FP1 GEN = %8lx&quot;, INREG( di-&gt;regs, RADEON_FP_GEN_CNTL ));
+		SHOW_INFO( 2, &quot;FP2 GEN = %8lx&quot;, INREG( di-&gt;regs, RADEON_FP2_GEN_CNTL ));
+		SHOW_INFO( 2, &quot;TV DAC = %8lx&quot;, INREG( di-&gt;regs, RADEON_TV_DAC_CNTL )); //not setup right when ext dvi
+//	}
 	
 	result = Radeon_InitPCIGART( di );
 	if( result &lt; 0 )

Modified: haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/radeon_driver.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/radeon_driver.h	2007-08-13 17:09:20 UTC (rev 21929)
+++ haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/radeon_driver.h	2007-08-13 17:22:32 UTC (rev 21930)
@@ -116,6 +116,7 @@
 	disp_entity	routing;
 	
 	general_pll_info pll;
+	tmds_pll_info 	 tmds_pll[4];
 	ram_info	ram;	
 	char		ram_type[32];	// human-readable name of ram type
 	uint32		local_mem_size;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003512.html">[Haiku-commits] r21929 - in haiku/trunk/src/servers/app/drawing: . Painter Painter/drawing_modes
</A></li>
	<LI>Next message: <A HREF="003510.html">[Haiku-commits] r21930 - in haiku/trunk: headers/private/graphics/radeon src/add-ons/accelerants/radeon src/add-ons/kernel/drivers/graphics/radeon
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3506">[ date ]</a>
              <a href="thread.html#3506">[ thread ]</a>
              <a href="subject.html#3506">[ subject ]</a>
              <a href="author.html#3506">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
