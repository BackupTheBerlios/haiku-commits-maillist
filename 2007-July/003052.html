<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21615 - haiku/trunk/docs/user/drivers
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21615%20-%20haiku/trunk/docs/user/drivers&In-Reply-To=%3C200707151331.l6FDV3V6032060%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003051.html">
   <LINK REL="Next"  HREF="003055.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21615 - haiku/trunk/docs/user/drivers</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21615%20-%20haiku/trunk/docs/user/drivers&In-Reply-To=%3C200707151331.l6FDV3V6032060%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21615 - haiku/trunk/docs/user/drivers">axeld at mail.berlios.de
       </A><BR>
    <I>Sun Jul 15 15:31:03 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003051.html">[Haiku-commits] r21614 - haiku/trunk/src/system/kernel/fs
</A></li>
        <LI>Next message: <A HREF="003055.html">[Haiku-commits] r21615 - haiku/trunk/docs/user/drivers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3052">[ date ]</a>
              <a href="thread.html#3052">[ thread ]</a>
              <a href="subject.html#3052">[ subject ]</a>
              <a href="author.html#3052">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-07-15 15:31:02 +0200 (Sun, 15 Jul 2007)
New Revision: 21615
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21615&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21615&amp;view=rev</A>

Modified:
   haiku/trunk/docs/user/drivers/fs_interface.dox
Log:
* Removed deprecated functions.
* The documented the notify_*() functions - only notify_listener() was deprecated
  among them.
* Replaced spaces with tabs - there is no reason to deviate from the standard we're
  using everywhere else.
* Completed the docs here and there.


Modified: haiku/trunk/docs/user/drivers/fs_interface.dox
===================================================================
--- haiku/trunk/docs/user/drivers/fs_interface.dox	2007-07-15 12:38:13 UTC (rev 21614)
+++ haiku/trunk/docs/user/drivers/fs_interface.dox	2007-07-15 13:31:02 UTC (rev 21615)
@@ -1,179 +1,168 @@
-&#65279;/*
+/*
  * Copyright 2007 Haiku Inc. All rights reserved.
  * Distributed under the terms of the MIT License.
  *
  * Authors:
- *   Ingo Weinhold 
- *   Niels Sascha Reedijk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">niels.reedijk at gmail.com</A>&gt;
+ *		Ingo Weinhold 
+ *		Niels Sascha Reedijk &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">niels.reedijk at gmail.com</A>&gt;
+ *		Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de</A>
+ *
  * Corresponds to:
- *   /trunk/headers/os/drivers/fs_interface.h rev 21568
+ *		/trunk/headers/os/drivers/fs_interface.h rev 21568
  */
 
-/*!
-  \file fs_interface.h
-  \ingroup drivers
-  \brief Provides an interface for file system modules.
-  
-  See the \ref fs_modules &quot;introduction to file system modules&quot; for a guide on
-  how to get started with writing file system modules.
-*/
-
-///// Typedefs /////
-
-/*! 
-  \typedef typedef void *fs_volume
-  \brief Private data structure for the filesystem to store data associated
-    with volumes.
-*/
-
 /*!
-  \typedef typedef void *fs_cookie
-  \brief Private data structure that is passed to the filesystem when it is
-    called.
-*/
+	\file fs_interface.h
+	\ingroup drivers
+	\brief Provides an interface for file system modules.
 
-/*!
-  \typedef typedef void *fs_vnode
-  \brief Private data structure that is passed to the filesystem when it is
-    operating on vnodes.
+	See the \ref fs_modules &quot;introduction to file system modules&quot; for a guide on
+	how to get started with writing file system modules.
 */
 
 ///// write_stat_mask //////
 
 /*!
-  \enum write_stat_mask
-  \brief This mask is used in file_system_module_info::write_stat() to
-    determine which values need to be written.
+	\enum write_stat_mask
+	\brief This mask is used in file_system_module_info::write_stat() to
+		determine which values need to be written.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_MODE
-  \brief The mode parameter should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_MODE
+	\brief The mode parameter should be updated.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_UID
-  \brief The UID field should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_UID
+	\brief The UID field should be updated.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_GID
-  \brief The GID field should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_GID
+	\brief The GID field should be updated.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_SIZE
-  \brief The size field should be updated. If the actual size is less than the
-    new provided file size, the file should be set to the new size and the
-    extra space should be filled with zeros. 
+	\var write_stat_mask::FS_WRITE_STAT_SIZE
+	\brief The size field should be updated. If the actual size is less than the
+		new provided file size, the file should be set to the new size and the
+		extra space should be filled with zeros. 
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_ATIME
-  \brief The access time should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_ATIME
+	\brief The access time should be updated.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_MTIME
-  \brief The 'last modified' field should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_MTIME
+	\brief The 'last modified' field should be updated.
 */
 
 /*!
-  \var write_stat_mask::FS_WRITE_STAT_CRTIME
-  \brief The 'creation time' should be updated.
+	\var write_stat_mask::FS_WRITE_STAT_CRTIME
+	\brief The 'creation time' should be updated.
 */
 
 ///// FS_WRITE_FSINFO_NAME /////
 
 /*!
-  \def FS_WRITE_FSINFO_NAME
-  \brief Passed to file_system_module_info::write_fs_info().
+	\def FS_WRITE_FSINFO_NAME
+	\brief Passed to file_system_module_info::write_fs_info().
 */
 
 ///// file_io_vec /////
 
 /*!
-  \struct file_io_vec
-  \brief Structure that describes the io vector of a file.
+	\struct file_io_vec
+	\brief Structure that describes the io vector of a file.
 */
 
 /*!
-  \var off_t file_io_vec::offset
-  \brief The offset within the file.
+	\var off_t file_io_vec::offset
+	\brief The offset within the file.
 */
 
 /*!
-  \var off_t file_io_vec::length
-  \brief The length of the vector.
+	\var off_t file_io_vec::length
+	\brief The length of the vector.
 */
 
 ///// B_CURRENT_FS_API_VERSION /////
 
 /*!
-  \def B_CURRENT_FS_API_VERSION
-  \brief Constant that defines the version of the filesystem API that your
-    filesystem conforms to.
+	\def B_CURRENT_FS_API_VERSION
+	\brief Constant that defines the version of the file system API that your
+		filesystem conforms to.
+	
+	The module name that exports the interface to your file system has to
+	end with this constant as in:
+	\code &quot;file_systems/myfs&quot; B_CURRENT_FS_API_VERSION
 */
 
 ///// file_system_module_info /////
 
 
 /*!
-  \struct file_system_module_info
-  \brief Kernel module interface for file systems.
-  
-  See the \ref fs_modules &quot;introduction to file system modules&quot; for an
-  introduction to writing file systems.
+	\struct file_system_module_info
+	\brief Kernel module interface for file systems.
+  
+	See the \ref fs_modules &quot;introduction to file system modules&quot; for an
+	introduction to writing file systems.
 */
 
 /*!
-  \name Data members
+	\name Data members
 */
 
 //! @{
 
 /*!
-  \var module_info file_system_module_info::info
-  \brief Your module_info object which is required for all modules.
+	\var module_info file_system_module_info::info
+	\brief Your module_info object which is required for all modules.
 */
 
 /*!
-  \var const char *file_system_module_info::pretty_name
-  \brief A NULL-terminated string with a 'pretty' name for you file system.
+	\var const char *file_system_module_info::pretty_name
+	\brief A NULL-terminated string with a 'pretty' name for you file system.
+
+	Note, if a system wide disk device type constant exists for your file system,
+	it should equal this identifier.
 */
 
 //! @}
 
 /*!
-  \name Scanning
+	\name Scanning
 */
 
 //! @{
 
 /*!
-  \fn float (*file_system_module_info::identify_partition)(int fd, partition_data *partition, void **cookie)
-  \brief Undocumented. TODO.
+	\fn float (*file_system_module_info::identify_partition)(int fd, partition_data *partition, void **cookie)
+	\brief Undocumented. TODO.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::scan_partition)(int fd, partition_data *partition, void *cookie)
-  \brief Undocumented. TODO.
+	\fn status_t (*file_system_module_info::scan_partition)(int fd, partition_data *partition, void *cookie)
+	\brief Undocumented. TODO.
 */
 
 /*!
-  \fn void (*file_system_module_info::free_identify_partition_cookie)(partition_data *partition, void *cookie)
-  \brief Undocumented. TODO.
+	\fn void (*file_system_module_info::free_identify_partition_cookie)(partition_data *partition, void *cookie)
+	\brief Undocumented. TODO.
 */
 
 /*!
-  \fn void (*file_system_module_info::free_partition_content_cookie)(partition_data *partition)
-  \brief Undocumented. TODO.
+	\fn void (*file_system_module_info::free_partition_content_cookie)(partition_data *partition)
+	\brief Undocumented. TODO.
 */
 
 //! @}
 
 /*!
-  \name General Operations
+	\name General Operations
 */
 
 //! @{
@@ -259,33 +248,33 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::write_fs_info)(fs_volume fs, const
+  \fn status_t (*file_system_module_info::write_fs_info)(fs_volume fs, const
     struct fs_info *info, uint32 mask)
-  \brief Update filesystem information on the volume.
-  
-  You are requested to update certain information on the volume \a fs. The
-  supplied \a info contains the new values filled in for the \a mask.
-  Currently, the only possible mask is solely the \c FS_WRITE_FSINFO_NAME,
-  which asks you to update the volume name represented by the value
-  \c volume_name in the \c fs_info struct.
-
-  \param fs The cookie your filesystem supplied to the volume that should be
-    updated.
-  \param info The structure that contains the new data.
-  \param mask The values of the \a info that need to be updated.
+  \brief Update filesystem information on the volume.
+  
+  You are requested to update certain information on the volume \a fs. The
+  supplied \a info contains the new values filled in for the \a mask.
+  Currently, the only possible mask is solely the \c FS_WRITE_FSINFO_NAME,
+  which asks you to update the volume name represented by the value
+  \c volume_name in the \c fs_info struct.
+
+  \param fs The cookie your filesystem supplied to the volume that should be
+    updated.
+  \param info The structure that contains the new data.
+  \param mask The values of the \a info that need to be updated.
   \return \c B_OK if everything went fine, if not, one of the error codes.
 */
 
 /*!
   \fn status_t (*file_system_module_info::sync)(fs_volume fs)
-  \brief Synchronize the cached data with the contents of the disk.
-  
-  The VFS layer sometimes wants you to synchronize any cached values with the
-  data on the device.
-  
-  TODO: WHEN IS THIS CALLED AND FOR WHAT PURPOSE?
-  
-  \param fs The cookie your filesystem supplied to the volume that should be
+  \brief Synchronize the cached data with the contents of the disk.
+  
+  The VFS layer sometimes wants you to synchronize any cached values with the
+  data on the device.
+  
+  TODO: WHEN IS THIS CALLED AND FOR WHAT PURPOSE?
+  
+  \param fs The cookie your filesystem supplied to the volume that should be
     updated.
 */
 
@@ -330,15 +319,15 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::get_vnode_name)(fs_volume fs,
+  \fn status_t (*file_system_module_info::get_vnode_name)(fs_volume fs,
     fs_vnode vnode, char *buffer, size_t bufferSize)
-  \brief Return the file name of a vnode.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param vnode The file system provided cookie associated with this vnode.
-  \param buffer The buffer that the name can be copied into.
-  \param bufferSize The size of the buffer.
-  \retval B_OK You successfully copied the file name into the \a buffer.
+  \brief Return the file name of a vnode.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param vnode The file system provided cookie associated with this vnode.
+  \param buffer The buffer that the name can be copied into.
+  \param bufferSize The size of the buffer.
+  \retval B_OK You successfully copied the file name into the \a buffer.
   \retval &quot;other errors&quot; There was some error looking up or copying the name.
 */
 
@@ -399,9 +388,9 @@
 
 /*!
   \fn bool (*file_system_module_info::can_page)(fs_volume fs, fs_vnode vnode, fs_cookie cookie)
-  \brief Undocumented. TODO.
-  
-  TODO: In both the dos and the bfs implementations this thing simply returns
+  \brief Undocumented. TODO.
+  
+  TODO: In both the dos and the bfs implementations this thing simply returns
   false... Is there anything more to it?
 */
 
@@ -442,64 +431,64 @@
 //! @{
 
 /*!
-  \fn status_t (*file_system_module_info::ioctl)(fs_volume fs, fs_vnode vnode,
+  \fn status_t (*file_system_module_info::ioctl)(fs_volume fs, fs_vnode vnode,
     fs_cookie cookie, ulong op, void *buffer, size_t length)
-  \brief Perform file system specific operations.
-  
-  You can implement a customized API using this call. This can be extremely
-  handy for debugging purposes. There are no obligatory operations for you to
-  implement.
-  
-  If you don't want to use this feature, you don't have to implement it.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param vnode The file system provided cookie associated with the vnode (if
-    applicable).
-  \param cookie The file system provided cookie associated with, for example,
-    an open file (if applicable).
-  \param op The operation code. You will have to define them yourself.
-  \param buffer A buffer (if applicable).
-  \param length The size of the buffer. 
+  \brief Perform file system specific operations.
+  
+  You can implement a customized API using this call. This can be extremely
+  handy for debugging purposes. There are no obligatory operations for you to
+  implement.
+  
+  If you don't want to use this feature, you don't have to implement it.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param vnode The file system provided cookie associated with the vnode (if
+    applicable).
+  \param cookie The file system provided cookie associated with, for example,
+    an open file (if applicable).
+  \param op The operation code. You will have to define them yourself.
+  \param buffer A buffer (if applicable).
+  \param length The size of the buffer. 
   \return You should return any of your status codes.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::set_flags)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::set_flags)(fs_volume fs, fs_vnode
     vnode, fs_cookie cookie, int flags)
-  \brief Set the open mode flags for an opened file.
-  
-  This function should change the open flags for an opened file. 
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param vnode The file system provided cookie associated with the vnode.
-  \param cookie The file system provided cookie associated with the opened
-    file.
-  \param flags The new flags.
+  \brief Set the open mode flags for an opened file.
+  
+  This function should change the open flags for an opened file. 
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param vnode The file system provided cookie associated with the vnode.
+  \param cookie The file system provided cookie associated with the opened
+    file.
+  \param flags The new flags.
   \return \c B_OK if the operation succeeded, or else an error code.
 */
 
 /*!
   \fn status_t (*file_system_module_info::select)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
 				uint8 event, uint32 ref, selectsync *sync)
-  \brief Undocumented. TODO.
-  
+  \brief Undocumented. TODO.
+  
   TODO: What should this do?
 */
 
 /*!
   \fn status_t (*file_system_module_info::deselect)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
 				uint8 event, selectsync *sync)
-  \brief Undocumented. TODO.
-  
+  \brief Undocumented. TODO.
+  
   TODO: What should this do?
 */
 
 /*!
   \fn status_t (*file_system_module_info::fsync)(fs_volume fs, fs_vnode vnode)
-  \brief Synchronize the buffers with the on disk data.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param vnode The file system provided cookie associated with the vnode.
+  \brief Synchronize the buffers with the on disk data.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param vnode The file system provided cookie associated with the vnode.
   \return \c B_OK if the operation succeeded, or else an error code.
 */
 
@@ -526,84 +515,84 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::create_symlink)(fs_volume fs,
+  \fn status_t (*file_system_module_info::create_symlink)(fs_volume fs,
     fs_vnode dir, const char *name, const char *path, int mode)
-  \brief Create a new symbolic link.
-  
-  Your implementation should check if the user has permission to perform this
-  operation.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param dir The file system provided cookie associated with the directory
-    the symbolic link should be created in.
-  \param name The name of the new symbolic link.
-  \param path The path of the original inode the symbolic link should refer to.
-  \param mode The mode that this symbolic link should be created in. (TODO
-    what exactly?)
+  \brief Create a new symbolic link.
+  
+  Your implementation should check if the user has permission to perform this
+  operation.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param dir The file system provided cookie associated with the directory
+    the symbolic link should be created in.
+  \param name The name of the new symbolic link.
+  \param path The path of the original inode the symbolic link should refer to.
+  \param mode The mode that this symbolic link should be created in. (TODO
+    what exactly?)
   \return \c B_OK if you succeeded, or an error code if you failed.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::link)(fs_volume fs, fs_vnode dir, 
+  \fn status_t (*file_system_module_info::link)(fs_volume fs, fs_vnode dir, 
     const char *name, fs_vnode vnode)
-  \brief Create a new hard link.
-  
-  You should make sure the user has the proper permissions.
-  
-  The virtual file system will request the creation of symbolic links with
-  create_symlink().
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param dir The cookie associated to the directory where the link should be
-    saved.
-  \param name The name the link should have.
-  \param vnode The vnode the new link should resolve to.
-  \retval B_OK The hard link is properly created.
-  \retval B_NOT_ALLOWED The user does not have the proper permissions.
-  \retval &quot;other errors&quot; Another error occured.
+  \brief Create a new hard link.
+  
+  You should make sure the user has the proper permissions.
+  
+  The virtual file system will request the creation of symbolic links with
+  create_symlink().
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param dir The cookie associated to the directory where the link should be
+    saved.
+  \param name The name the link should have.
+  \param vnode The vnode the new link should resolve to.
+  \retval B_OK The hard link is properly created.
+  \retval B_NOT_ALLOWED The user does not have the proper permissions.
+  \retval &quot;other errors&quot; Another error occured.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::unlink)(fs_volume fs, fs_vnode dir,
+  \fn status_t (*file_system_module_info::unlink)(fs_volume fs, fs_vnode dir,
     const char *name)
-  \brief Remove a node or directory.
-  
-  You should make sure the user has the proper permissions.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param dir The parent directory of the node that should be removed.
-  \param name The name of the node that should be deleted.
-  \retval B_OK Removal succeeded.
-  \retval B_ENTRY_NOT_FOUND The entry does not exist.
-  \retval B_NOT_ALLOWED The user does not have the proper permissions.
-  \retval B_DIRECTORY_NOT_EMPTY The \a name refers to a directory. The virtual
-    file system expects directories to be emptied before they can be unlinked.
+  \brief Remove a node or directory.
+  
+  You should make sure the user has the proper permissions.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param dir The parent directory of the node that should be removed.
+  \param name The name of the node that should be deleted.
+  \retval B_OK Removal succeeded.
+  \retval B_ENTRY_NOT_FOUND The entry does not exist.
+  \retval B_NOT_ALLOWED The user does not have the proper permissions.
+  \retval B_DIRECTORY_NOT_EMPTY The \a name refers to a directory. The virtual
+    file system expects directories to be emptied before they can be unlinked.
   \retval &quot;other errors&quot; Another error occured.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::rename)(fs_volume fs, fs_vnode 
+  \fn status_t (*file_system_module_info::rename)(fs_volume fs, fs_vnode 
     fromDir, const char *fromName, fs_vnode toDir, const char *toName)
-  \brief Rename and/or relocate a vnode.
-  
-  The virtual file system merely relays the request, so make sure the user is
-  not changing the file name to something like '.', '..' or anything starting
-  with '/'. 
-  
-  This also means that it if the node is a directory, that it should not be
-  moved into one of its own children.
-  
-  You should also make sure the user has the proper permissions.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param fromDir The cookie of the parent directory the vnode should be moved
-    from.
-  \param fromName The old name of the node.
-  \param toDir The cookie of the parent directory the vnode should be moved to.
-  \param toName The new name of the node.
-  \retval B_OK The renaming and relocating succeeded.
-  \retval B_BAD_VALUE One of the supplied parameters were invalid.
-  \retval B_NOT_ALLOWED The user does not have the proper permissions.
+  \brief Rename and/or relocate a vnode.
+  
+  The virtual file system merely relays the request, so make sure the user is
+  not changing the file name to something like '.', '..' or anything starting
+  with '/'. 
+  
+  This also means that it if the node is a directory, that it should not be
+  moved into one of its own children.
+  
+  You should also make sure the user has the proper permissions.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param fromDir The cookie of the parent directory the vnode should be moved
+    from.
+  \param fromName The old name of the node.
+  \param toDir The cookie of the parent directory the vnode should be moved to.
+  \param toName The new name of the node.
+  \retval B_OK The renaming and relocating succeeded.
+  \retval B_BAD_VALUE One of the supplied parameters were invalid.
+  \retval B_NOT_ALLOWED The user does not have the proper permissions.
   \retval &quot;other errors&quot; Another error condition was encountered.
 */
 
@@ -658,20 +647,20 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::write_stat)(fs_volume fs, fs_vnode 
+  \fn status_t (*file_system_module_info::write_stat)(fs_volume fs, fs_vnode 
     vnode, const struct stat *stat, uint32 statMask)
-  \brief Update the stats for a vnode.
-  
-  You should make sure that the new values are valid and that the user has the
-  proper permissions to update the stats.
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The cookie to the vnode.
-  \param stat The structure with the updated values.
-  \param statMask One of the #write_stat_mask enumeration, which forms a mask
-    of which of the values in \a stat should actually be updated.
-  \retval B_OK The update succeeded.
-  \retval B_NOT_ALLOWED The user does not have the proper permissions.
+  \brief Update the stats for a vnode.
+  
+  You should make sure that the new values are valid and that the user has the
+  proper permissions to update the stats.
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The cookie to the vnode.
+  \param stat The structure with the updated values.
+  \param statMask One of the #write_stat_mask enumeration, which forms a mask
+    of which of the values in \a stat should actually be updated.
+  \retval B_OK The update succeeded.
+  \retval B_NOT_ALLOWED The user does not have the proper permissions.
   \retval &quot;other errors&quot; Another error condition occured.
 */
 
@@ -684,30 +673,30 @@
 //! @{
 
 /*!
-  \fn status_t (*file_system_module_info::create)(fs_volume fs, fs_vnode dir,
+  \fn status_t (*file_system_module_info::create)(fs_volume fs, fs_vnode dir,
     const char *name, int openMode, int perms, fs_cookie *_cookie, 
     ino_t *_newVnodeID)
-  \brief Create a new file.
-  
-  Your implementation shall check whether it is possible to create the node.
-  You will need to take the user's permissions into account. When you create
-  a new file, you will also have to open it. This means also checking the
-  permissions the user requires to open the file according to the \a mode.
-  See \link file_system_module_info::open() open() \endlink for the possible
-  values of \a mode. 
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param dir The file system provided cookie associated with the directory
-    where the file should appear.
-  \param name The name of the new file.
-  \param openMode The mode associated to the file.
-  \param perms The permissions the new file should have.
-  \param[out] _cookie In case of success, the you can store your file system
-    data for this node in this variable.
-  \param[out] _newVnodeID In case of success, you can store the new vnode id
-    in this variable.
-  \return You should return \c B_OK if creating the new node succeeded, and if
-    you put data in both \a _cookie and \a _newVnodeID. Else you should return
+  \brief Create a new file.
+  
+  Your implementation shall check whether it is possible to create the node.
+  You will need to take the user's permissions into account. When you create
+  a new file, you will also have to open it. This means also checking the
+  permissions the user requires to open the file according to the \a mode.
+  See \link file_system_module_info::open() open() \endlink for the possible
+  values of \a mode. 
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param dir The file system provided cookie associated with the directory
+    where the file should appear.
+  \param name The name of the new file.
+  \param openMode The mode associated to the file.
+  \param perms The permissions the new file should have.
+  \param[out] _cookie In case of success, the you can store your file system
+    data for this node in this variable.
+  \param[out] _newVnodeID In case of success, you can store the new vnode id
+    in this variable.
+  \return You should return \c B_OK if creating the new node succeeded, and if
+    you put data in both \a _cookie and \a _newVnodeID. Else you should return
     an error code.
 */
 
@@ -799,29 +788,29 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::write)(fs_volume fs, fs_vnode vnode, 
+  \fn status_t (*file_system_module_info::write)(fs_volume fs, fs_vnode vnode, 
     fs_cookie cookie, off_t pos, const void *buffer, size_t *length)
-  \brief Write data to a file.
-  
-  This function should fail if
-  - the node is not a file,
-  - the cookie has not been opened for writing,
-  - \a pos is negative, or
-  - some other error occurs while trying to read the data, and no data have
-    been read at all.
-
-  The number of bytes to be written is stored in the variable pointed to by
-  \a length.
-  
-  TODO: What to do if we were to write less than the \a length? Should this
-  function fail? 
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param vnode The file system provided cookie associated with the vnode.
-  \param cookie The file system provided cookie associated with the file.
-  \param pos The position to start writing.
-  \param buffer The buffer that contains the data that will need to be written.
-  \param length The length of the data that needs to be written.
+  \brief Write data to a file.
+  
+  This function should fail if
+  - the node is not a file,
+  - the cookie has not been opened for writing,
+  - \a pos is negative, or
+  - some other error occurs while trying to read the data, and no data have
+    been read at all.
+
+  The number of bytes to be written is stored in the variable pointed to by
+  \a length.
+  
+  TODO: What to do if we were to write less than the \a length? Should this
+  function fail? 
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param vnode The file system provided cookie associated with the vnode.
+  \param cookie The file system provided cookie associated with the file.
+  \param pos The position to start writing.
+  \param buffer The buffer that contains the data that will need to be written.
+  \param length The length of the data that needs to be written.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
@@ -832,45 +821,45 @@
 */
 
 /*!
-  \fn status_t (*file_system_module_info::create_dir)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::create_dir)(fs_volume fs, fs_vnode
     parent, const char *name, int perms, ino_t *_newVnodeID)
-  \brief Create a new directory.
-  
-  Your implementation should make sure that the directory actually can be
-  created in the \a parent directory. You will have to check if the user has
-  permissions to actually write to the \a parent. If not, this function should
-  fail (probably with \c B_NOT_ALLOWED, or in case of a read-only filesystem,
-  with \c B_READ_ONLY_DEVICE). If the operation succeeds, you should put the
-  new vnode id in \a _newVnodeID. 
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param parent The file system provided cookie associated with the parent
-    node.
-  \param name The name the new directory should have.
-  \param perms The permissions the new directory should have.
-  \param[out] _newVnodeID If creating the directory succeeds, than you should
-    put the new vnode id in this variable.
-  \return If the operation succeeds and the \a _newVnodeID is populated with
-    the new vnode, then you should return \c B_OK. Else you should return with
+  \brief Create a new directory.
+  
+  Your implementation should make sure that the directory actually can be
+  created in the \a parent directory. You will have to check if the user has
+  permissions to actually write to the \a parent. If not, this function should
+  fail (probably with \c B_NOT_ALLOWED, or in case of a read-only filesystem,
+  with \c B_READ_ONLY_DEVICE). If the operation succeeds, you should put the
+  new vnode id in \a _newVnodeID. 
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param parent The file system provided cookie associated with the parent
+    node.
+  \param name The name the new directory should have.
+  \param perms The permissions the new directory should have.
+  \param[out] _newVnodeID If creating the directory succeeds, than you should
+    put the new vnode id in this variable.
+  \return If the operation succeeds and the \a _newVnodeID is populated with
+    the new vnode, then you should return \c B_OK. Else you should return with
     an error code.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::remove_dir)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::remove_dir)(fs_volume fs, fs_vnode
     parent, const char *name)
-  \brief Remove a directory.
-  
-  You should make sure the user has the proper permissions. You should also
-  check that the directory is empty.
-  
-  \param fs The file system provided cookie associated with this volume.
-  \param parent The file system provided cookie associated with the parent
-    node.
-  \param name The \a name of the directory that needs to be removed.
-  \retval B_OK Operation succeeded.
-  \retval B_DIRECTORY_NOT_EMPTY The directory is not empty.
-  \retval B_ENTRY_NOT_FOUND There is no directory with this \a name. 
-  \retval B_NOT_A_DIRECTORY The entry is not a directory.
+  \brief Remove a directory.
+  
+  You should make sure the user has the proper permissions. You should also
+  check that the directory is empty.
+  
+  \param fs The file system provided cookie associated with this volume.
+  \param parent The file system provided cookie associated with the parent
+    node.
+  \param name The \a name of the directory that needs to be removed.
+  \retval B_OK Operation succeeded.
+  \retval B_DIRECTORY_NOT_EMPTY The directory is not empty.
+  \retval B_ENTRY_NOT_FOUND There is no directory with this \a name. 
+  \retval B_NOT_A_DIRECTORY The entry is not a directory.
   \retval &quot;other errors&quot; Other errors occured.
 */
 
@@ -987,63 +976,63 @@
 //! @{
 
 /*!
-  \fn status_t (*file_system_module_info::open_attr_dir)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::open_attr_dir)(fs_volume fs, fs_vnode
     vnode, fs_cookie *_cookie)
-  \brief Open a 'directory' of attributes for a \a vnode.
-  
-  See \ref concepts &quot;Generic Concepts&quot; on directories and iterators. Basically,
-  the VFS uses the same way of traversing through attributes as it traverses
-  through a directory. 
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The vnode on which the file system wants to read the attributes.
-  \param[out] _cookie Pointer where the file system can store a directory
-    cookie if the attribute directory is succesfully opened.
+  \brief Open a 'directory' of attributes for a \a vnode.
+  
+  See \ref concepts &quot;Generic Concepts&quot; on directories and iterators. Basically,
+  the VFS uses the same way of traversing through attributes as it traverses
+  through a directory. 
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The vnode on which the file system wants to read the attributes.
+  \param[out] _cookie Pointer where the file system can store a directory
+    cookie if the attribute directory is succesfully opened.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::close_attr_dir)(fs_volume fs,
+  \fn status_t (*file_system_module_info::close_attr_dir)(fs_volume fs,
     fs_vnode vnode, fs_cookie cookie)
-  \brief Close a 'directory' of attributes for a \a vnode.
-  
-  Note that you should free the cookie in the free_attr_dir_cookie() call.
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The vnode on which the 'directory' was opened.
-  \param cookie The cookie associated with this 'directory'.
+  \brief Close a 'directory' of attributes for a \a vnode.
+  
+  Note that you should free the cookie in the free_attr_dir_cookie() call.
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The vnode on which the 'directory' was opened.
+  \param cookie The cookie associated with this 'directory'.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::free_attr_dir_cookie)(fs_volume fs,
+  \fn status_t (*file_system_module_info::free_attr_dir_cookie)(fs_volume fs,
     fs_vnode vnode, fs_cookie cookie)
-  \brief Free the \a cookie to an attribute 'directory'. 
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The vnode on which the 'directory' was opened.
-  \param cookie The cookie associated that should be freed.
+  \brief Free the \a cookie to an attribute 'directory'. 
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The vnode on which the 'directory' was opened.
+  \param cookie The cookie associated that should be freed.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::read_attr_dir)(fs_volume fs, fs_vnode
-    vnode, fs_cookie cookie, struct dirent *buffer, size_t bufferSize,
+  \fn status_t (*file_system_module_info::read_attr_dir)(fs_volume fs, fs_vnode
+    vnode, fs_cookie cookie, struct dirent *buffer, size_t bufferSize,
     uint32 *_num)
-  \brief Read the next one or more attribute directory entries.
-  
-  This method should perform the same tasks as read_dir(), except that the '.'
+  \brief Read the next one or more attribute directory entries.
+  
+  This method should perform the same tasks as read_dir(), except that the '.'
   and '..' entries do not have to be present. 
 */
 
 /*!
-  \fn status_t (*file_system_module_info::rewind_attr_dir)(fs_volume fs,
+  \fn status_t (*file_system_module_info::rewind_attr_dir)(fs_volume fs,
     fs_vnode vnode, fs_cookie cookie)
-  \brief Rewind the attribute directory iterator to the first entry.
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The vnode on which the 'directory' was opened.
-  \param cookie The cookie associated with this 'directory'.
+  \brief Rewind the attribute directory iterator to the first entry.
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The vnode on which the 'directory' was opened.
+  \param cookie The cookie associated with this 'directory'.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
@@ -1056,154 +1045,154 @@
 //! @{
 
 /*!
-  \fn status_t (*file_system_module_info::create_attr)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::create_attr)(fs_volume fs, fs_vnode
     vnode, const char *name, uint32 type, int openMode, fs_cookie *_cookie)
-  \brief Create a new attribute. 
-  
-  If the attribute already exists, you should open it in truncated mode. 
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The file system provided cookie to the vnode.
-  \param name The name of the attribute.
-  \param type The \c type_code of the attribute.
-  \param openMode The openMode of the associated attribute.
-  \param[out] _cookie A pointer where you can store an associated file system
-    cookie.
+  \brief Create a new attribute. 
+  
+  If the attribute already exists, you should open it in truncated mode. 
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The file system provided cookie to the vnode.
+  \param name The name of the attribute.
+  \param type The \c type_code of the attribute.
+  \param openMode The openMode of the associated attribute.
+  \param[out] _cookie A pointer where you can store an associated file system
+    cookie.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::open_attr)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::open_attr)(fs_volume fs, fs_vnode
     vnode, const char *name, int openMode, fs_cookie *_cookie)
-  \brief Open an existing attribute.
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The file system provided cookie to the vnode.
-  \param name The name of the attribute.
-  \param openMode The mode in which you want to open the attribute data.
-  \param[out] _cookie A pointer where you can store an associated file system
-    cookie.
+  \brief Open an existing attribute.
+  
+  \param fs The file system provided cookie to the volume.
+  \param vnode The file system provided cookie to the vnode.
+  \param name The name of the attribute.
+  \param openMode The mode in which you want to open the attribute data.
+  \param[out] _cookie A pointer where you can store an associated file system
+    cookie.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::close_attr)(fs_volume fs, fs_vnode
+  \fn status_t (*file_system_module_info::close_attr)(fs_volume fs, fs_vnode
     vnode, fs_cookie cookie)
-  \brief Close access to an attribute.
-  
-  Note that you should not delete the cookie yet, you should do that when the
-  VFS calls free_attr_cookie(). 
-
-  \param fs The file system provided cookie to the volume.
-  \param vnode The file system provided cookie to the vnode.
-  \param cookie The cookie you associated to this attribute.
+  \brief Close access to an attribute.
+  
+  Note that you should not delete the cookie yet, you should do that when the
+  VFS calls free_attr_cookie(). 
+
+  \param fs The file system provided cookie to the volume.
+  \param vnode The file system provided cookie to the vnode.
+  \param cookie The cookie you associated to this attribute.
   \return \c B_OK if everything went fine, another error code otherwise.
 */
 
 /*!
-  \fn status_t (*file_system_module_info::free_attr_cookie)(fs_volume fs,
+  \fn status_t (*file_system_module_info::free_attr_cookie)(fs_volume fs,
     fs_vnode vnode, fs_cookie cookie)
-  \brief Free the cookie of an attribute.
-  
-  The VFS calls this hook when all operations on the attribute have ceased.
-  
-  \param fs The file system provided cookie to the volume.
-  \param vnode The file system provided cookie to the vnode.
-  \param cookie The cookie to the attribute that should be freed.
+  \brief Free the cookie of an attribute.

[... truncated: 841 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003051.html">[Haiku-commits] r21614 - haiku/trunk/src/system/kernel/fs
</A></li>
	<LI>Next message: <A HREF="003055.html">[Haiku-commits] r21615 - haiku/trunk/docs/user/drivers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3052">[ date ]</a>
              <a href="thread.html#3052">[ thread ]</a>
              <a href="subject.html#3052">[ subject ]</a>
              <a href="author.html#3052">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
