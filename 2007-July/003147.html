<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21685 - in haiku/trunk: headers/private/app	src/servers/app src/servers/app/drawing	src/servers/app/drawing/Painter	src/servers/app/drawing/Painter/font_support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21685%20-%20in%20haiku/trunk%3A%20headers/private/app%0A%09src/servers/app%20src/servers/app/drawing%0A%09src/servers/app/drawing/Painter%0A%09src/servers/app/drawing/Painter/font_support&In-Reply-To=%3C200707221948.l6MJmTUv022230%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003146.html">
   <LINK REL="Next"  HREF="003152.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21685 - in haiku/trunk: headers/private/app	src/servers/app src/servers/app/drawing	src/servers/app/drawing/Painter	src/servers/app/drawing/Painter/font_support</H1>
    <B>stippi at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21685%20-%20in%20haiku/trunk%3A%20headers/private/app%0A%09src/servers/app%20src/servers/app/drawing%0A%09src/servers/app/drawing/Painter%0A%09src/servers/app/drawing/Painter/font_support&In-Reply-To=%3C200707221948.l6MJmTUv022230%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21685 - in haiku/trunk: headers/private/app	src/servers/app src/servers/app/drawing	src/servers/app/drawing/Painter	src/servers/app/drawing/Painter/font_support">stippi at mail.berlios.de
       </A><BR>
    <I>Sun Jul 22 21:48:29 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003146.html">[Haiku-commits] r21684 - haiku/trunk/src/kits/interface
</A></li>
        <LI>Next message: <A HREF="003152.html">[Haiku-commits] r21685 - in haiku/trunk: headers/private/app src/servers/app src/servers/app/drawing src/servers/app/drawing/Painter src/servers/app/drawing/Painter/font_support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3147">[ date ]</a>
              <a href="thread.html#3147">[ thread ]</a>
              <a href="subject.html#3147">[ subject ]</a>
              <a href="author.html#3147">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2007-07-22 21:48:27 +0200 (Sun, 22 Jul 2007)
New Revision: 21685
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21685&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21685&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/app/ServerProtocol.h
   haiku/trunk/src/servers/app/DefaultDecorator.cpp
   haiku/trunk/src/servers/app/ProfileMessageSupport.cpp
   haiku/trunk/src/servers/app/RGBColor.h
   haiku/trunk/src/servers/app/ServerApp.cpp
   haiku/trunk/src/servers/app/ServerFont.cpp
   haiku/trunk/src/servers/app/ServerPicture.cpp
   haiku/trunk/src/servers/app/ServerWindow.cpp
   haiku/trunk/src/servers/app/ViewLayer.cpp
   haiku/trunk/src/servers/app/WindowLayer.h
   haiku/trunk/src/servers/app/drawing/DrawingEngine.cpp
   haiku/trunk/src/servers/app/drawing/DrawingEngine.h
   haiku/trunk/src/servers/app/drawing/Painter/Painter.cpp
   haiku/trunk/src/servers/app/drawing/Painter/Painter.h
   haiku/trunk/src/servers/app/drawing/Painter/font_support/AGGTextRenderer.cpp
   haiku/trunk/src/servers/app/drawing/Painter/font_support/AGGTextRenderer.h
Log:
* completed my changes to DrawState handling, the current DrawingState
  of the active ViewLayer is now always mirrored in the Painter instance
  of a ServerWindow, so that it doesn't need to be synced on every drawing
  command, this was previously incomplete for font handling
* removed the DrawState parameter from all the DrawingEngine functions
* adjusted ServerWindow and ServerPicture accordingly
* made sure that string related functions used by non-drawing related
  parts (ServerApp, Decorator) don't interfere with the current drawing
  state
* moved AS_SYNC handling from _DispatchViewMessage to _DispatchMessage,
  it is actually a window message and doesn't require fCurrentLayer to
  be valid
* fixed bug #1300, fCurrentLayer was not updated when a ViewLayer was
  deleted by client request which happened to be fCurrentLayer (I am now
  handling it so that the parent becomes the current layer, could be
  wrong)
* AGGTextRenderer is no longer using it's own scanline, which should save
  a few bytes RAM, the Painter already had such an object
* StringWidth() in AGGTextRenderer is now taking the escapement_delta into
  account
* Painter::StrokeLine() doesn't need to check the clipping as much, since
  that is already done in DrawingEngine
* if a ServerWindow message is not handled because fCurrentLayer is NULL,
  a reply is sent in case the messages needs it (client window could
  freeze otherwise, waiting for the reply for ever)
* removed unused AS_SET_FONT and AS_SET_FONT_SIZE
* added automatic RGBColor -&gt; rgb_color conversion to RGBColor.h
* minor cleanup for 80 char/line limit



Modified: haiku/trunk/headers/private/app/ServerProtocol.h
===================================================================
--- haiku/trunk/headers/private/app/ServerProtocol.h	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/headers/private/app/ServerProtocol.h	2007-07-22 19:48:27 UTC (rev 21685)
@@ -212,8 +212,6 @@
 	AS_FILL_TRIANGLE,
 
 	AS_DRAW_STRING,
-	AS_SET_FONT,
-	AS_SET_FONT_SIZE,
 
 	AS_SYNC,
 

Modified: haiku/trunk/src/servers/app/DefaultDecorator.cpp
===================================================================
--- haiku/trunk/src/servers/app/DefaultDecorator.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/DefaultDecorator.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -639,8 +639,9 @@
 			fMinTabSize += offset + size;
 
 		// fMaxTabSize contains fMinWidth + the width required for the title
-		fMaxTabSize = fDrawingEngine ? ceilf(fDrawingEngine-&gt;StringWidth(Title(), strlen(Title()),
-			&amp;fDrawState)) : 0.0;
+		fMaxTabSize = fDrawingEngine ?
+			ceilf(fDrawingEngine-&gt;StringWidth(Title(), strlen(Title()),
+				fDrawState.Font())) : 0.0;
 		if (fMaxTabSize &gt; 0.0)
 			fMaxTabSize += fTextOffset;
 		fMaxTabSize += fMinTabSize;
@@ -967,8 +968,9 @@
 {
 	STRACE((&quot;_DrawTitle(%f,%f,%f,%f)\n&quot;, r.left, r.top, r.right, r.bottom));
 
-	fDrawState.SetHighColor(fTextColor);
-	fDrawState.SetLowColor(fTabColor);
+	fDrawingEngine-&gt;SetHighColor(fTextColor.GetColor32());
+	fDrawingEngine-&gt;SetLowColor(fTabColor.GetColor32());
+	fDrawingEngine-&gt;SetFont(fDrawState.Font());
 
 	// figure out position of text
 	font_height fontHeight;
@@ -987,7 +989,8 @@
 			: fTabRect.bottom - fTextOffset;
 	}
 
-	fDrawingEngine-&gt;DrawString(fTruncatedTitle.String(), fTruncatedTitleLength, titlePos, &amp;fDrawState);
+	fDrawingEngine-&gt;DrawString(fTruncatedTitle.String(), fTruncatedTitleLength,
+		titlePos);
 }
 
 // _DrawZoom

Modified: haiku/trunk/src/servers/app/ProfileMessageSupport.cpp
===================================================================
--- haiku/trunk/src/servers/app/ProfileMessageSupport.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ProfileMessageSupport.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -200,8 +200,6 @@
 		case AS_FILL_TRIANGLE: string = &quot;AS_FILL_TRIANGLE&quot;; break;
 
 		case AS_DRAW_STRING: string = &quot;AS_DRAW_STRING&quot;; break;
-		case AS_SET_FONT: string = &quot;AS_SET_FONT&quot;; break;
-		case AS_SET_FONT_SIZE: string = &quot;AS_SET_FONT_SIZE&quot;; break;
 
 		case AS_SYNC: string = &quot;AS_SYNC&quot;; break;
 

Modified: haiku/trunk/src/servers/app/RGBColor.h
===================================================================
--- haiku/trunk/src/servers/app/RGBColor.h	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/RGBColor.h	2007-07-22 19:48:27 UTC (rev 21685)
@@ -53,6 +53,10 @@
 			bool				operator==(const RGBColor&amp; color) const;
 			bool				operator!=(const rgb_color&amp; color) const;
 			bool				operator!=(const RGBColor&amp; color) const;
+
+			// conversion to rgb_color
+								operator rgb_color() const
+									{ return fColor32; }
 	
 			bool				IsTransparentMagic() const;
 	

Modified: haiku/trunk/src/servers/app/ServerApp.cpp
===================================================================
--- haiku/trunk/src/servers/app/ServerApp.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ServerApp.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -1401,7 +1401,8 @@
 			int32 lengthArray[numStrings];
 			char *stringArray[numStrings];
 			for (int32 i = 0; i &lt; numStrings; i++) {
-				// This version of ReadString allocates the strings, we free them below
+				// This version of ReadString allocates the strings, we free
+				// them below
 				link.ReadString(&amp;stringArray[i], (size_t *)&amp;lengthArray[i]);
 			}
 
@@ -1415,13 +1416,14 @@
 					if (!stringArray[i] || lengthArray[i] &lt;= 0)
 						widthArray[i] = 0.0;
 					else {
-						widthArray[i] = fDesktop-&gt;GetDrawingEngine()-&gt;StringWidth(stringArray[i], lengthArray[i], font);
-						// NOTE: The line below will return the exact same thing. However,
-						// the line above uses the AGG rendering backend, for which glyph caching
-						// actually works. It is about 20 times faster!
-						// TODO: I've disabled the AGG version for now, as it produces a dead lock
-						//	(font use), that I am currently too lazy to investigate...
-//						widthArray[i] = font.StringWidth(stringArray[i], lengthArray[i]);
+						widthArray[i] = fDesktop-&gt;GetDrawingEngine()-&gt;
+							StringWidth(stringArray[i], lengthArray[i], font);
+						// NOTE: The line below will return the exact same thing.
+						// However, the line above uses the AGG rendering backend,
+						// for which glyph caching actually works. It is about
+						// 20 times faster!
+//						widthArray[i] = font.StringWidth(stringArray[i],
+//							lengthArray[i]);
 					}
 				}
 

Modified: haiku/trunk/src/servers/app/ServerFont.cpp
===================================================================
--- haiku/trunk/src/servers/app/ServerFont.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ServerFont.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -339,6 +339,7 @@
 		FT_Set_Transform(face, &amp;smatrix, NULL);
 	}
 
+	// fStyle will be unlocked in PutTransformedFace()
 	return face;
 }
 
@@ -433,7 +434,8 @@
 
 status_t
 ServerFont::GetEscapements(const char charArray[], int32 numChars,
-	escapement_delta delta, BPoint escapementArray[], BPoint offsetArray[]) const
+	escapement_delta delta, BPoint escapementArray[],
+	BPoint offsetArray[]) const
 {
 	if (!charArray || numChars &lt;= 0 || !escapementArray)
 		return B_BAD_DATA;

Modified: haiku/trunk/src/servers/app/ServerPicture.cpp
===================================================================
--- haiku/trunk/src/servers/app/ServerPicture.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ServerPicture.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -131,7 +131,7 @@
 		}
 
 		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawShape(frame, opCount, opList, ptCount, ptList,
-				view-&gt;CurrentState(), filled);
+				filled);
 	}
 }
 
@@ -182,7 +182,7 @@
 {
 	view-&gt;ConvertToScreenForDrawing(&amp;start);
 	view-&gt;ConvertToScreenForDrawing(&amp;end);	
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;StrokeLine(start, end, view-&gt;CurrentState());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;StrokeLine(start, end);
 }
 
 
@@ -190,7 +190,7 @@
 stroke_rect(ViewLayer *view, BRect rect)
 {
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);	
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;StrokeRect(rect, view-&gt;CurrentState());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;StrokeRect(rect);
 }
 
 
@@ -198,7 +198,7 @@
 fill_rect(ViewLayer *view, BRect rect)
 {
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);			
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;FillRect(rect, view-&gt;CurrentState());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;FillRect(rect);
 }
 
 
@@ -206,7 +206,8 @@
 stroke_round_rect(ViewLayer *view, BRect rect, BPoint radii)
 {
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);	
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawRoundRect(rect, radii.x, radii.y, view-&gt;CurrentState(), false);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawRoundRect(rect, radii.x, radii.y,
+		false);
 }
 
 
@@ -214,7 +215,8 @@
 fill_round_rect(ViewLayer *view, BRect rect, BPoint radii)
 {
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);	
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawRoundRect(rect, radii.x, radii.y, view-&gt;CurrentState(), true);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawRoundRect(rect, radii.x, radii.y,
+		true);
 }
 
 
@@ -224,7 +226,7 @@
 	BPoint points[4];
 	view-&gt;ConvertToScreenForDrawing(points, viewPoints, 4);
 
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBezier(points, view-&gt;CurrentState(), false);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBezier(points, false);
 }
 
 
@@ -234,7 +236,7 @@
 	BPoint points[4];
 	view-&gt;ConvertToScreenForDrawing(points, viewPoints, 4);
 
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBezier(points, view-&gt;CurrentState(), true);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBezier(points, true);
 }
 
 
@@ -245,7 +247,7 @@
 	BRect rect(center.x - radii.x, center.y - radii.y, center.x + radii.x,
 			center.y + radii.y);
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawArc(rect, startTheta, arcTheta, view-&gt;CurrentState(), false);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawArc(rect, startTheta, arcTheta, false);
 }
 
 
@@ -256,7 +258,7 @@
 	BRect rect(center.x - radii.x, center.y - radii.y, center.x + radii.x,
 			center.y + radii.y);
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawArc(rect, startTheta, arcTheta, view-&gt;CurrentState(), true);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawArc(rect, startTheta, arcTheta, true);
 }
 
 
@@ -266,7 +268,7 @@
 	BRect rect(center.x - radii.x, center.y - radii.y, center.x + radii.x,
 			center.y + radii.y);
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawEllipse(rect, view-&gt;CurrentState(), false);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawEllipse(rect, false);
 }
 
 
@@ -276,7 +278,7 @@
 	BRect rect(center.x - radii.x, center.y - radii.y, center.x + radii.x,
 			center.y + radii.y);
 	view-&gt;ConvertToScreenForDrawing(&amp;rect);
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawEllipse(rect, view-&gt;CurrentState(), true);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawEllipse(rect, true);
 }
 
 
@@ -295,9 +297,8 @@
 		BRect polyFrame;
 		get_polygon_frame(points, numPoints, &amp;polyFrame);
 
-		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame, 
-														view-&gt;CurrentState(), false,
-														isClosed &amp;&amp; numPoints &gt; 2);
+		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame,
+			false, isClosed &amp;&amp; numPoints &gt; 2);
 	} else {
 		 // avoid constructor/destructor calls by using malloc instead of new []
 		BPoint *points = (BPoint *)malloc(numPoints * sizeof(BPoint));
@@ -310,8 +311,7 @@
 		get_polygon_frame(points, numPoints, &amp;polyFrame);
 
 		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame, 
-														view-&gt;CurrentState(), false,
-														isClosed &amp;&amp; numPoints &gt; 2);
+			false, isClosed &amp;&amp; numPoints &gt; 2);
 		free(points);
 	}
 }
@@ -333,7 +333,7 @@
 		get_polygon_frame(points, numPoints, &amp;polyFrame);
 
 		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame, 
-														view-&gt;CurrentState(), true, true);
+			true, true);
 	} else {
 		 // avoid constructor/destructor calls by using malloc instead of new []
 		BPoint *points = (BPoint *)malloc(numPoints * sizeof(BPoint)); 
@@ -346,7 +346,7 @@
 		get_polygon_frame(points, numPoints, &amp;polyFrame);
 
 		view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawPolygon(points, numPoints, polyFrame, 
-														view-&gt;CurrentState(), true, true);
+			true, true);
 		free(points);
 	}
 }
@@ -373,13 +373,14 @@
 
 
 static void
-draw_string(ViewLayer *view, const char *string, float deltaSpace, float deltaNonSpace)
+draw_string(ViewLayer *view, const char *string, float deltaSpace,
+	float deltaNonSpace)
 {
 	BPoint location = view-&gt;CurrentState()-&gt;PenLocation();
 	escapement_delta delta = {deltaSpace, deltaNonSpace };
 	view-&gt;ConvertToScreenForDrawing(&amp;location);
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawString(string, strlen(string), location,
-		view-&gt;CurrentState(), &amp;delta);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawString(string, strlen(string),
+		location, &amp;delta);
 	// TODO: Update pen location ?
 	
 }
@@ -399,7 +400,7 @@
 
 	view-&gt;ConvertToScreenForDrawing(&amp;dest);
 	
-	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBitmap(&amp;bitmap, src, dest, view-&gt;CurrentState());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;DrawBitmap(&amp;bitmap, src, dest);
 }
 
 
@@ -434,6 +435,11 @@
 pop_state(ViewLayer *view)
 {
 	view-&gt;PopState();
+
+	IntPoint p = view-&gt;ScrollingOffset();
+	p += IntPoint(view-&gt;CurrentState()-&gt;Origin());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetDrawState(
+		view-&gt;CurrentState(), p.x, p.y);
 }
 
 
@@ -476,6 +482,12 @@
 set_pen_location(ViewLayer *view, BPoint pt)
 {
 	view-&gt;CurrentState()-&gt;SetPenLocation(pt);
+
+	// TODO: faster version
+	IntPoint p = view-&gt;ScrollingOffset();
+	p += IntPoint(view-&gt;CurrentState()-&gt;Origin());
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetDrawState(
+		view-&gt;CurrentState(), p.x, p.y);
 }
 
 
@@ -483,6 +495,7 @@
 set_drawing_mode(ViewLayer *view, drawing_mode mode)
 {
 	view-&gt;CurrentState()-&gt;SetDrawingMode(mode);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetDrawingMode(mode);
 }
 
 
@@ -493,6 +506,7 @@
 	state-&gt;SetLineCapMode(capMode);
 	state-&gt;SetLineJoinMode(joinMode);
 	state-&gt;SetMiterLimit(miterLimit);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetStrokeMode(capMode, joinMode, miterLimit);
 }
 
 
@@ -500,6 +514,7 @@
 set_pen_size(ViewLayer *view, float size)
 {
 	view-&gt;CurrentState()-&gt;SetPenSize(size);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetPenSize(size);
 }
 
 
@@ -507,6 +522,7 @@
 set_fore_color(ViewLayer *view, rgb_color color)
 {
 	view-&gt;CurrentState()-&gt;SetHighColor(RGBColor(color));
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetHighColor(color);
 }
 
 
@@ -514,13 +530,15 @@
 set_back_color(ViewLayer *view, rgb_color color)
 {
 	view-&gt;CurrentState()-&gt;SetLowColor(RGBColor(color));
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetLowColor(color);
 }
 
 
 static void
 set_stipple_pattern(ViewLayer *view, pattern p)
 {
-	printf(&quot;SetStipplePattern\n&quot;);
+	view-&gt;CurrentState()-&gt;SetPattern(Pattern(p));
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetPattern(p);
 }
 
 
@@ -558,13 +576,17 @@
 	ServerFont font;
 	font.SetSize(size);
 	view-&gt;CurrentState()-&gt;SetFont(font, B_FONT_SIZE);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetFont(view-&gt;CurrentState()-&gt;Font());
 }
 
 
 static void
 set_font_rotate(ViewLayer *view, float rotation)
 {
-	printf(&quot;SetFontRotate(%.2f)\n&quot;, rotation);
+	ServerFont font;
+	font.SetRotation(rotation);
+	view-&gt;CurrentState()-&gt;SetFont(font, B_FONT_ROTATION);
+	view-&gt;Window()-&gt;GetDrawingEngine()-&gt;SetFont(view-&gt;CurrentState()-&gt;Font());
 }
 
 

Modified: haiku/trunk/src/servers/app/ServerWindow.cpp
===================================================================
--- haiku/trunk/src/servers/app/ServerWindow.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ServerWindow.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -1034,6 +1034,16 @@
 			// at the fRedrawRequested member variable in _MessageLooper().
 			break;
 
+		case AS_SYNC:
+			// the synchronisation works by the fact that the client
+			// window is waiting for this reply, after having received it,
+			// client and server queues are in sync (earlier, the client
+			// may have pushed drawing commands at the server and now it
+			// knows they have all been carried out)
+			fLink.StartMessage(B_OK);
+			fLink.Flush();
+			break;
+
 		case AS_BEGIN_UPDATE:
 			DTRACE((&quot;ServerWindowo %s: AS_BEGIN_UPDATE\n&quot;, Title()));
 			fWindowLayer-&gt;BeginUpdate(fLink);
@@ -1161,7 +1171,15 @@
 			// and take appropriate actions, then checking for fCurrentLayer-&gt;CurrentState()
 			// is unnecessary
 			if (fCurrentLayer == NULL || fCurrentLayer-&gt;CurrentState() == NULL) {
-				printf(&quot;ServerWindow %s received unexpected code - message offset %ld before top_view attached.\n&quot;, Title(), code - B_OK);
+				BString codeName;
+				string_for_message_code(code, codeName);
+				printf(&quot;ServerWindow %s received unexpected code - &quot;
+					&quot;message '%s' before top_view attached.\n&quot;,
+					Title(), codeName.String());
+				if (link.NeedsReply()) {
+					fLink.StartMessage(B_ERROR);
+					fLink.Flush();
+				}
 				return;
 			}
 
@@ -1231,8 +1249,10 @@
 						fDesktop-&gt;EventDispatcher().RemoveListener(EventTarget(),
 							token);
 					}
+					if (fCurrentLayer == view)
+						_SetCurrentLayer(parent);
 					delete view;
-				}
+				} // else we don't delete the root view
 			}
 			break;
 		}
@@ -1251,7 +1271,9 @@
 		{
 			DTRACE((&quot;ServerWindow %s: Message AS_LAYER_SET_FONT_STATE: ViewLayer name: %s\n&quot;, fTitle, fCurrentLayer-&gt;Name()));
 			fCurrentLayer-&gt;CurrentState()-&gt;ReadFontFromLink(link);
-			_UpdateDrawState(fCurrentLayer);
+//			_UpdateDrawState(fCurrentLayer);
+			fWindowLayer-&gt;GetDrawingEngine()-&gt;SetFont(
+				fCurrentLayer-&gt;CurrentState()-&gt;Font());
 			break;
 		}
 		case AS_LAYER_GET_STATE:
@@ -1466,7 +1488,9 @@
 			fCurrentLayer-&gt;CurrentState()-&gt;SetLineJoinMode((join_mode)lineJoin);
 			fCurrentLayer-&gt;CurrentState()-&gt;SetMiterLimit(miterLimit);
 
-			_UpdateDrawState(fCurrentLayer);
+			fWindowLayer-&gt;GetDrawingEngine()-&gt;SetStrokeMode((cap_mode)lineCap,
+				(join_mode)lineJoin, miterLimit);
+//			_UpdateDrawState(fCurrentLayer);
 
 			break;
 		}
@@ -1606,8 +1630,10 @@
 			link.Read&lt;int8&gt;(&amp;alphaFunc);
 			
 			fCurrentLayer-&gt;CurrentState()-&gt;SetBlendingMode((source_alpha)srcAlpha,
-											(alpha_function)alphaFunc);
-			_UpdateDrawState(fCurrentLayer);
+				(alpha_function)alphaFunc);
+			//_UpdateDrawState(fCurrentLayer);
+			fWindowLayer-&gt;GetDrawingEngine()-&gt;SetBlendingMode((source_alpha)srcAlpha,
+				(alpha_function)alphaFunc);
 			break;
 		}
 		case AS_LAYER_GET_BLENDING_MODE:
@@ -1856,30 +1882,6 @@
 			fWindowLayer-&gt;GetDrawingEngine()-&gt;SetPattern(pat);
 			break;
 		}
-		case AS_SET_FONT:
-		{
-			DTRACE((&quot;ServerWindow %s: Message AS_SET_FONT\n&quot;, Title()));
-			// TODO: Implement AS_SET_FONT?
-			// Confusing!! But it works already!
-			break;
-		}
-		case AS_SET_FONT_SIZE:
-		{
-			DTRACE((&quot;ServerWindow %s: Message AS_SET_FONT_SIZE\n&quot;, Title()));
-			// TODO: Implement AS_SET_FONT_SIZE?
-			break;
-		}
-		case AS_SYNC:
-		{
-			// the synchronisation works by the fact that the client
-			// window is waiting for this reply, after having received it,
-			// client and server queues are in sync (earlier, the client
-			// may have pushed drawing commands at the server and now it
-			// knows they have all been carried out)
-			fLink.StartMessage(B_OK);
-			fLink.Flush();
-			break;
-		}
 		case AS_LAYER_DRAG_IMAGE:
 		{
 			// TODO: flesh out AS_LAYER_DRAG_IMAGE
@@ -2052,7 +2054,7 @@
 			BPoint penPos = p2;
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;p1);
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;p2);
-			drawingEngine-&gt;StrokeLine(p1, p2, fCurrentLayer-&gt;CurrentState());
+			drawingEngine-&gt;StrokeLine(p1, p2);
 			
 			// We update the pen here because many DrawingEngine calls which do not update the
 			// pen position actually call StrokeLine
@@ -2086,7 +2088,7 @@
 			BRect rect(left,top,right,bottom);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;rect);
-			drawingEngine-&gt;StrokeRect(rect, fCurrentLayer-&gt;CurrentState());
+			drawingEngine-&gt;StrokeRect(rect);
 			break;
 		}
 		case AS_FILL_RECT:
@@ -2097,7 +2099,7 @@
 			link.Read&lt;BRect&gt;(&amp;rect);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;rect);
-			drawingEngine-&gt;FillRect(rect, fCurrentLayer-&gt;CurrentState());
+			drawingEngine-&gt;FillRect(rect);
 			break;
 		}
 		case AS_LAYER_DRAW_BITMAP:
@@ -2114,7 +2116,7 @@
 			if (bitmap) {
 				fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;dstRect);
 
-				drawingEngine-&gt;DrawBitmap(bitmap, srcRect, dstRect, fCurrentLayer-&gt;CurrentState());
+				drawingEngine-&gt;DrawBitmap(bitmap, srcRect, dstRect);
 			}
 
 			break;
@@ -2132,8 +2134,7 @@
 			link.Read&lt;float&gt;(&amp;span);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;r);
-			drawingEngine-&gt;DrawArc(r, angle, span, fCurrentLayer-&gt;CurrentState(),
-								   code == AS_FILL_ARC);
+			drawingEngine-&gt;DrawArc(r, angle, span, code == AS_FILL_ARC);
 			break;
 		}
 		case AS_STROKE_BEZIER:
@@ -2147,8 +2148,7 @@
 				fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;pts[i]);
 			}
 
-			drawingEngine-&gt;DrawBezier(pts, fCurrentLayer-&gt;CurrentState(),
-									  code == AS_FILL_BEZIER);
+			drawingEngine-&gt;DrawBezier(pts, code == AS_FILL_BEZIER);
 			break;
 		}
 		case AS_STROKE_ELLIPSE:
@@ -2160,7 +2160,7 @@
 			link.Read&lt;BRect&gt;(&amp;rect);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;rect);
-			drawingEngine-&gt;DrawEllipse(rect, fCurrentLayer-&gt;CurrentState(), code == AS_FILL_ELLIPSE);
+			drawingEngine-&gt;DrawEllipse(rect, code == AS_FILL_ELLIPSE);
 			break;
 		}
 		case AS_STROKE_ROUNDRECT:
@@ -2175,7 +2175,7 @@
 			link.Read&lt;float&gt;(&amp;yrad);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;rect);
-			drawingEngine-&gt;DrawRoundRect(rect, xrad, yrad, fCurrentLayer-&gt;CurrentState(), code == AS_FILL_ROUNDRECT);
+			drawingEngine-&gt;DrawRoundRect(rect, xrad, yrad, code == AS_FILL_ROUNDRECT);
 			break;
 		}
 		case AS_STROKE_TRIANGLE:
@@ -2194,7 +2194,7 @@
 			link.Read&lt;BRect&gt;(&amp;rect);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;rect);
-			drawingEngine-&gt;DrawTriangle(pts, rect, fCurrentLayer-&gt;CurrentState(), code == AS_FILL_TRIANGLE);
+			drawingEngine-&gt;DrawTriangle(pts, rect, code == AS_FILL_TRIANGLE);
 			break;
 		}
 		case AS_STROKE_POLYGON:
@@ -2218,8 +2218,7 @@
 				fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;polyFrame);
 
 				drawingEngine-&gt;DrawPolygon(pointList, pointCount, polyFrame,
-					fCurrentLayer-&gt;CurrentState(), code == AS_FILL_POLYGON,
-					isClosed &amp;&amp; pointCount &gt; 2);
+					code == AS_FILL_POLYGON, isClosed &amp;&amp; pointCount &gt; 2);
 			}
 			delete[] pointList;
 			break;
@@ -2246,7 +2245,7 @@
 					fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;ptList[i]);
 
 				drawingEngine-&gt;DrawShape(shapeFrame, opCount, opList, ptCount, ptList,
-					fCurrentLayer-&gt;CurrentState(), code == AS_FILL_SHAPE);
+					code == AS_FILL_SHAPE);
 			}
 
 			delete[] opList;
@@ -2262,7 +2261,7 @@
 				break;
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;region);
-			drawingEngine-&gt;FillRegion(region, fCurrentLayer-&gt;CurrentState());
+			drawingEngine-&gt;FillRegion(region);
 
 			break;
 		}
@@ -2292,8 +2291,7 @@
 					fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;index-&gt;pt1);
 					fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;index-&gt;pt2);
 				}
-				drawingEngine-&gt;StrokeLineArray(lineCount, lineData,
-					fCurrentLayer-&gt;CurrentState());
+				drawingEngine-&gt;StrokeLineArray(lineCount, lineData);
 			}
 			break;
 		}
@@ -2311,11 +2309,12 @@
 			link.ReadString(&amp;string);
 
 			fCurrentLayer-&gt;ConvertToScreenForDrawing(&amp;location);
-			BPoint penLocation = drawingEngine-&gt;DrawString(string, length, location,
-				fCurrentLayer-&gt;CurrentState(), &amp;delta);
+			BPoint penLocation = drawingEngine-&gt;DrawString(string, length,
+				location, &amp;delta);
 
 			fCurrentLayer-&gt;ConvertFromScreenForDrawing(&amp;penLocation);
 			fCurrentLayer-&gt;CurrentState()-&gt;SetPenLocation(penLocation);
+			// pen location has changed, update DrawingEngine
 			// TODO: optimize with flags
 			_UpdateDrawState(fCurrentLayer);
 

Modified: haiku/trunk/src/servers/app/ViewLayer.cpp
===================================================================
--- haiku/trunk/src/servers/app/ViewLayer.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/ViewLayer.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -1212,16 +1212,14 @@
 			if (rect.IsValid()/* &amp;&amp; drawingEngine-&gt;Lock()*/) {
 				drawingEngine-&gt;ConstrainClippingRegion(redraw);
 
-				DrawState defaultDrawState;
-
 				if (fBitmapOptions &amp; B_TILE_BITMAP) {
 					// tile across entire view
 
 					float start = rect.left;
 					while (rect.top &lt; redraw-&gt;Frame().bottom) {
 						while (rect.left &lt; redraw-&gt;Frame().right) {
-							drawingEngine-&gt;DrawBitmap(fViewBitmap, fBitmapSource,
-								rect, &amp;defaultDrawState);
+							drawingEngine-&gt;DrawBitmap(fViewBitmap,
+								fBitmapSource, rect);
 							rect.OffsetBy(rect.Width() + 1, 0.0);
 						}
 						rect.OffsetBy(start - rect.left, rect.Height() + 1);
@@ -1233,7 +1231,7 @@
 
 					while (rect.left &lt; redraw-&gt;Frame().right) {
 						drawingEngine-&gt;DrawBitmap(fViewBitmap, fBitmapSource,
-							rect, &amp;defaultDrawState);
+							rect);
 						rect.OffsetBy(rect.Width() + 1, 0.0);
 					}
 					// remove horizontal stripe from clipping
@@ -1245,7 +1243,7 @@
 
 					while (rect.top &lt; redraw-&gt;Frame().bottom) {
 						drawingEngine-&gt;DrawBitmap(fViewBitmap, fBitmapSource,
-							rect, &amp;defaultDrawState);
+							rect);
 						rect.OffsetBy(0.0, rect.Height() + 1);
 					}
 					// remove vertical stripe from clipping
@@ -1256,7 +1254,7 @@
 					// no tiling at all
 
 					drawingEngine-&gt;DrawBitmap(fViewBitmap, fBitmapSource,
-						rect, &amp;defaultDrawState);
+						rect);
 					redraw-&gt;Exclude(rect);
 				}
 

Modified: haiku/trunk/src/servers/app/WindowLayer.h
===================================================================
--- haiku/trunk/src/servers/app/WindowLayer.h	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/WindowLayer.h	2007-07-22 19:48:27 UTC (rev 21685)
@@ -84,7 +84,6 @@
 			ViewLayer*			TopLayer() const { return fTopLayer; }
 				// TODO: only used for WorkspacesLayer, can go away if we do
 				//	this differently one day
-
 			ViewLayer*			ViewAt(const BPoint&amp; where);
 
 	virtual	bool				IsOffscreenWindow() const { return false; }

Modified: haiku/trunk/src/servers/app/drawing/DrawingEngine.cpp
===================================================================
--- haiku/trunk/src/servers/app/drawing/DrawingEngine.cpp	2007-07-22 19:33:08 UTC (rev 21684)
+++ haiku/trunk/src/servers/app/drawing/DrawingEngine.cpp	2007-07-22 19:48:27 UTC (rev 21685)
@@ -13,6 +13,7 @@
 #include &lt;algo.h&gt;
 #include &lt;stack.h&gt;
 
+#include &quot;AGGTextRenderer.h&quot;
 #include &quot;DrawState.h&quot;
 #include &quot;Painter.h&quot;
 #include &quot;PNGDump.h&quot;
@@ -46,10 +47,10 @@
 
 // extend_by_stroke_width
 static inline void
-extend_by_stroke_width(BRect&amp; rect, const DrawState* context)
+extend_by_stroke_width(BRect&amp; rect, float penSize)
 {
 	// &quot;- 0.5&quot; because if stroke width == 1, we don't need to extend
-	float inset = -ceilf(context-&gt;PenSize() / 2.0 - 0.5);
+	float inset = -ceilf(penSize / 2.0 - 0.5);
 	rect.InsetBy(inset, inset);
 }
 
@@ -184,7 +185,7 @@
 void
 DrawingEngine::SetDrawState(const DrawState* state, int32 xOffset, int32 yOffset)
 {
-	fPainter-&gt;SetDrawState(state, false, xOffset, yOffset);	
+	fPainter-&gt;SetDrawState(state, true, xOffset, yOffset);	
 }
 
 
@@ -210,10 +211,23 @@
 
 
 void
+DrawingEngine::SetStrokeMode(cap_mode lineCap, join_mode joinMode,
+								float miterLimit)
+{
+	fPainter-&gt;SetStrokeMode(lineCap, joinMode, miterLimit);	
+}
+
+
+void
+DrawingEngine::SetBlendingMode(source_alpha srcAlpha, alpha_function alphaFunc)
+{
+	fPainter-&gt;SetBlendingMode(srcAlpha, alphaFunc);	
+}
+
+
+void
 DrawingEngine::SetPattern(const struct pattern&amp; pattern)
 {
-	// TODO: doing it like this prevents an optimization
-	// for font rendering (special &quot;solid&quot; drawing mode)
 	fPainter-&gt;SetPattern(pattern, false);	
 }
 
@@ -225,6 +239,13 @@
 }
 
 
+void
+DrawingEngine::SetFont(const ServerFont&amp; font)
+{
+	fPainter-&gt;SetFont(font);	
+}
+
+
 // #pragma mark -
 
 
@@ -505,8 +526,7 @@
 // DrawBitmap
 void
 DrawingEngine::DrawBitmap(ServerBitmap *bitmap,
-						  const BRect &amp;source, const BRect &amp;dest,
-						  const DrawState *d)
+						  const BRect &amp;source, const BRect &amp;dest)
 {
 	CRASH_IF_NOT_LOCKED
 
@@ -514,7 +534,6 @@
 	if (clipped.IsValid()) {
 		bool cursorTouched = fGraphicsCard-&gt;HideSoftwareCursor(clipped);
 
-//		fPainter-&gt;SetDrawState(d);
 		fPainter-&gt;DrawBitmap(bitmap, source, dest);
 
 		fGraphicsCard-&gt;Invalidate(clipped);
@@ -526,21 +545,18 @@
 // DrawArc
 void
 DrawingEngine::DrawArc(BRect r, const float &amp;angle,
-					   const float &amp;span, const DrawState *d,
-					   bool filled)
+					   const float &amp;span, bool filled)
 {
 	CRASH_IF_NOT_LOCKED
 
 	make_rect_valid(r);
 	BRect clipped(r);
 	if (!filled)
-		extend_by_stroke_width(clipped, d);
+		extend_by_stroke_width(clipped, fPainter-&gt;PenSize());
 	clipped = fPainter-&gt;ClipRect(r);
 	if (clipped.IsValid()) {
 		bool cursorTouched = fGraphicsCard-&gt;HideSoftwareCursor(clipped);
 
-//		fPainter-&gt;SetDrawState(d);
-
 		float xRadius = r.Width() / 2.0;
 		float yRadius = r.Height() / 2.0;
 		BPoint center(r.left + xRadius,
@@ -559,14 +575,13 @@
 
 // DrawBezier
 void
-DrawingEngine::DrawBezier(BPoint *pts, const DrawState *d, bool filled)
+DrawingEngine::DrawBezier(BPoint *pts, bool filled)
 {
 	CRASH_IF_NOT_LOCKED
 
 	// TODO: figure out bounds and hide cursor depending on that
 	fGraphicsCard-&gt;HideSoftwareCursor();
 
-//	fPainter-&gt;SetDrawState(d);
 	BRect touched = fPainter-&gt;DrawBezier(pts, filled);
 
 	fGraphicsCard-&gt;Invalidate(touched);
@@ -575,7 +590,7 @@
 
 // DrawEllipse
 void
-DrawingEngine::DrawEllipse(BRect r, const DrawState *d, bool filled)
+DrawingEngine::DrawEllipse(BRect r, bool filled)
 {
 	CRASH_IF_NOT_LOCKED
 
@@ -584,7 +599,7 @@
 	fPainter-&gt;AlignEllipseRect(&amp;clipped, filled);
 
 	if (!filled)
-		extend_by_stroke_width(clipped, d);
+		extend_by_stroke_width(clipped, fPainter-&gt;PenSize());
 
 	clipped.left = floorf(clipped.left);
 	clipped.top = floorf(clipped.top);
@@ -596,7 +611,6 @@
 	if (clipped.IsValid()) {
 		bool cursorTouched = fGraphicsCard-&gt;HideSoftwareCursor(clipped);
 
-//		fPainter-&gt;SetDrawState(d);
 		fPainter-&gt;DrawEllipse(r, filled);
 
 		fGraphicsCard-&gt;Invalidate(clipped);
@@ -608,19 +622,17 @@
 // DrawPolygon
 void
 DrawingEngine::DrawPolygon(BPoint* ptlist, int32 numpts,
-						   BRect bounds, const DrawState* d,
-						   bool filled, bool closed)
+						   BRect bounds, bool filled, bool closed)
 {
 	CRASH_IF_NOT_LOCKED
 
 	make_rect_valid(bounds);
 	if (!filled)
-		extend_by_stroke_width(bounds, d);
+		extend_by_stroke_width(bounds, fPainter-&gt;PenSize());
 	bounds = fPainter-&gt;ClipRect(bounds);
 	if (bounds.IsValid()) {
 		bool cursorTouched = fGraphicsCard-&gt;HideSoftwareCursor(bounds);
 
-//		fPainter-&gt;SetDrawState(d);
 		fPainter-&gt;DrawPolygon(ptlist, numpts, filled, closed);
 
 		fGraphicsCard-&gt;Invalidate(bounds);
@@ -756,20 +768,19 @@
 // #pragma mark - DrawState
 
 void
-DrawingEngine::StrokeRect(BRect r, const DrawState *d)
+DrawingEngine::StrokeRect(BRect r)
 {
 	CRASH_IF_NOT_LOCKED
 
 	// support invalid rects
 	make_rect_valid(r);
 	BRect clipped(r);
-	extend_by_stroke_width(clipped, d);
+	extend_by_stroke_width(clipped, fPainter-&gt;PenSize());
 	clipped = fPainter-&gt;ClipRect(clipped);
 	if (clipped.IsValid()) {
 
 		bool cursorTouched = fGraphicsCard-&gt;HideSoftwareCursor(clipped);
 
-//		fPainter-&gt;SetDrawState(d);
 		fPainter-&gt;StrokeRect(r);
 
 		fGraphicsCard-&gt;Invalidate(clipped);
@@ -780,7 +791,7 @@
 
 
 void
-DrawingEngine::FillRect(BRect r, const DrawState *d)
+DrawingEngine::FillRect(BRect r)
 {
 	CRASH_IF_NOT_LOCKED
 
@@ -794,20 +805,20 @@
 			// try hardware optimized version first
 			// if the rect is large enough
 			if ((fAvailableHWAccleration &amp; HW_ACC_FILL_REGION) != 0) {
-				if (d-&gt;GetPattern() == B_SOLID_HIGH
-					&amp;&amp; (d-&gt;GetDrawingMode() == B_OP_COPY
-						|| d-&gt;GetDrawingMode() == B_OP_OVER)) {
+				if (fPainter-&gt;Pattern() == B_SOLID_HIGH
+					&amp;&amp; (fPainter-&gt;DrawingMode() == B_OP_COPY
+						|| fPainter-&gt;DrawingMode() == B_OP_OVER)) {
 					BRegion region(r);
 					region.IntersectWith(fPainter-&gt;ClippingRegion());
-					fGraphicsCard-&gt;FillRegion(region, d-&gt;HighColor(),
+					fGraphicsCard-&gt;FillRegion(region, fPainter-&gt;HighColor(),
 											  fSuspendSyncLevel == 0
 											  || cursorTouched);
 					doInSoftware = false;
-				} else if (d-&gt;GetPattern() == B_SOLID_LOW
-						   &amp;&amp; d-&gt;GetDrawingMode() == B_OP_COPY) {
+				} else if (fPainter-&gt;Pattern() == B_SOLID_LOW
+						   &amp;&amp; fPainter-&gt;DrawingMode() == B_OP_COPY) {
 					BRegion region(r);
 					region.IntersectWith(fPainter-&gt;ClippingRegion());
-					fGraphicsCard-&gt;FillRegion(region, d-&gt;LowColor(),
+					fGraphicsCard-&gt;FillRegion(region, fPainter-&gt;LowColor(),
 											  fSuspendSyncLevel == 0
 											  || cursorTouched);
 					doInSoftware = false;
@@ -815,7 +826,6 @@
 			}
 		}
 		if (doInSoftware) {
-//			fPainter-&gt;SetDrawState(d);
 			fPainter-&gt;FillRect(r);
 
 			fGraphicsCard-&gt;Invalidate(r);
@@ -828,7 +838,7 @@
 
 
 void
-DrawingEngine::FillRegion(BRegion&amp; r, const DrawState *d)
+DrawingEngine::FillRegion(BRegion&amp; r)
 {
 	CRASH_IF_NOT_LOCKED
 
@@ -839,18 +849,18 @@
 		bool doInSoftware = true;
 		// try hardware optimized version first
 		if ((fAvailableHWAccleration &amp; HW_ACC_FILL_REGION) != 0) {
-			if (d-&gt;GetPattern() == B_SOLID_HIGH
-				&amp;&amp; (d-&gt;GetDrawingMode() == B_OP_COPY
-					|| d-&gt;GetDrawingMode() == B_OP_OVER)) {
+			if (fPainter-&gt;Pattern() == B_SOLID_HIGH

[... truncated: 702 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003146.html">[Haiku-commits] r21684 - haiku/trunk/src/kits/interface
</A></li>
	<LI>Next message: <A HREF="003152.html">[Haiku-commits] r21685 - in haiku/trunk: headers/private/app src/servers/app src/servers/app/drawing src/servers/app/drawing/Painter src/servers/app/drawing/Painter/font_support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3147">[ date ]</a>
              <a href="thread.html#3147">[ thread ]</a>
              <a href="subject.html#3147">[ subject ]</a>
              <a href="author.html#3147">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
