<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21719 - in haiku/trunk: headers/os/drivers	headers/private/kernel/disk_device_manager	src/system/kernel/disk_device_manager	src/system/kernel/disk_device_manager/jobs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21719%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/kernel/disk_device_manager%0A%09src/system/kernel/disk_device_manager%0A%09src/system/kernel/disk_device_manager/jobs&In-Reply-To=%3C200707271212.l6RCCcxm001509%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003214.html">
   <LINK REL="Next"  HREF="003220.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21719 - in haiku/trunk: headers/os/drivers	headers/private/kernel/disk_device_manager	src/system/kernel/disk_device_manager	src/system/kernel/disk_device_manager/jobs</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21719%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/kernel/disk_device_manager%0A%09src/system/kernel/disk_device_manager%0A%09src/system/kernel/disk_device_manager/jobs&In-Reply-To=%3C200707271212.l6RCCcxm001509%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21719 - in haiku/trunk: headers/os/drivers	headers/private/kernel/disk_device_manager	src/system/kernel/disk_device_manager	src/system/kernel/disk_device_manager/jobs">bonefish at mail.berlios.de
       </A><BR>
    <I>Fri Jul 27 14:12:38 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003214.html">[Haiku-commits] r21718 - haiku/trunk/src/bin/strace
</A></li>
        <LI>Next message: <A HREF="003220.html">[Haiku-commits] r21720 -	haiku/trunk/src/system/kernel/disk_device_manager/jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3219">[ date ]</a>
              <a href="thread.html#3219">[ thread ]</a>
              <a href="subject.html#3219">[ subject ]</a>
              <a href="author.html#3219">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2007-07-27 14:12:35 +0200 (Fri, 27 Jul 2007)
New Revision: 21719
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21719&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21719&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/drivers/disk_device_manager.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KDiskDeviceJob.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KDiskSystem.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KFileSystem.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KPartition.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KPartitioningSystem.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KPhysicalPartition.h
   haiku/trunk/headers/private/kernel/disk_device_manager/KShadowPartition.h
   haiku/trunk/src/system/kernel/disk_device_manager/Jamfile
   haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJobFactory.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/KPartitioningSystem.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/ddm_userland_interface.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KCreateChildJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KCreateChildJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KDefragmentJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KDefragmentJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KDeleteChildJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KDeleteChildJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KInitializeJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KInitializeJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KMoveJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KMoveJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KRepairJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KRepairJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KResizeJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KScanPartitionJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KScanPartitionJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KSetParametersJob.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KSetParametersJob.h
   haiku/trunk/src/system/kernel/disk_device_manager/jobs/KUninitializeJob.h
Log:
Addition of write support to the disk device manager. Courtesy of Tomas
Kucera and Jan Matejek.


Modified: haiku/trunk/headers/os/drivers/disk_device_manager.h
===================================================================
--- haiku/trunk/headers/os/drivers/disk_device_manager.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/os/drivers/disk_device_manager.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -14,9 +14,11 @@
 extern &quot;C&quot; {
 #endif
 
-// C API partition representation
-// Fields marked [sys] are set by the system and are not to be changed by
-// the disk system modules.
+/** 	\brief C API partition representation
+ *
+ * 	Fields marked [sys] are set by the system and are not to be changed by
+ * 	the disk system modules.
+ */
 typedef struct partition_data {
 	partition_id	id;				// [sys]
 	off_t			offset;

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KDiskDeviceJob.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KDiskDeviceJob.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KDiskDeviceJob.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -4,6 +4,7 @@
 #define _K_DISK_DEVICE_JOB_H
 
 #include &quot;disk_device_manager.h&quot;
+#include &lt;KPartitionVisitor.h&gt;
 
 struct user_disk_device_job_info;
 
@@ -12,19 +13,41 @@
 
 class KDiskDeviceJobQueue;
 
+/**
+ * Represents some action executed on the disk device.
+ * 
+ * - 
+ */
 class KDiskDeviceJob {
 public:
+	/**
+	 * Creates a new job
+	 * 
+	 * \param type actual type of the job (see DiskDeviceDefs.h for details)
+	 * \param partitionID the partition/device on which the action should be executed
+	 * \param scopeID partition/device which is the highest in the hierarchy (i.e. closest
+	 * to the root) that can be affected by the action
+ * 		- every descendant of this partition is marked busy and all ancestors are marked descendant-
+	busy
+	 */
 	KDiskDeviceJob(uint32 type, partition_id partitionID,
 				   partition_id scopeID = -1);
 	virtual ~KDiskDeviceJob();
 
+	/**
+	 * Unique identification of the job
+	 */
 	disk_job_id ID() const;
 
 	void SetJobQueue(KDiskDeviceJobQueue *queue);
 	KDiskDeviceJobQueue *JobQueue() const;
 
+	/**
+	 * Gets actual type of the action
+	 */
 	uint32 Type() const;
 
+	
 	void SetStatus(uint32 status);
 	uint32 Status() const;
 
@@ -54,9 +77,25 @@
 		// triggers a notification
 	float Progress() const;
 
+	
 	status_t GetInfo(user_disk_device_job_info *info);
 	status_t GetProgressInfo(disk_device_job_progress_info *info);
 
+	/**
+	 * Do the actual work of the job.
+	 * 
+	 * - is supposed to be implemented in descendants
+	 * - doesn't have any parameter - every operation needs different ones -&gt; they're passed
+	 * 		to the constructor
+	 * - the implementations will 
+	 * 		- check the parameters given in constructor (e.g. if given partition exists...)
+	 * 		- check whether the partition has needed disk system (its own or parent - depends
+	 * 			on the operation)
+	 * 		- using the disk system, validate the operation for given params
+	 * 		- finally execute the action
+	 * 
+	 * \return B_OK when everything went OK, some error otherwise
+	 */
 	virtual status_t Do() = 0;
 
 private:
@@ -76,6 +115,29 @@
 	float				fProgress;
 
 	static disk_job_id	fNextID;
+	
+private:
+	/**
+	 * Visitor which checks if every descendant of given partition is busy or descendant-busy
+	 */
+	struct IsNotBusyVisitor	: KPartitionVisitor {
+		virtual bool VisitPre(KPartition * partition);
+	};
+	IsNotBusyVisitor fNotBusyVisitor;
+	
+protected: 
+	//some stuff useful for all descendants
+		
+	/**
+	 * Checks if there's any descendant which is not busy/descendant-busy.
+	 * 
+	 * - the condition of busy descendant is common for many disk device operations -&gt;
+	 * 		many jobs can use this
+	 * 
+	 * \param partition the root of checked subtree of the whole partition hieararchy
+	 */
+	bool isPartitionNotBusy( KPartition * partition );	
+	
 };
 
 } // namespace DiskDevice

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KDiskSystem.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KDiskSystem.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KDiskSystem.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -13,6 +13,7 @@
 class KDiskDeviceJob;
 class KPartition;
 
+///	\brief Common ancestor for disk system add-on wrappers
 class KDiskSystem {
 public:
 	KDiskSystem(const char *name);

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KFileSystem.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KFileSystem.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KFileSystem.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -13,6 +13,7 @@
 namespace BPrivate {
 namespace DiskDevice {
 
+///	\brief Wrapper for the C interface of a filesystem add-on.
 class KFileSystem : public KDiskSystem {
 public:
 	KFileSystem(const char *name);

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KPartition.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KPartition.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KPartition.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -21,6 +21,7 @@
 class KPhysicalPartition;
 class KShadowPartition;
 
+///	\brief Class representing a single partition.
 class KPartition {
 public:
 	KPartition(partition_id id = -1);

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KPartitioningSystem.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KPartitioningSystem.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KPartitioningSystem.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -10,6 +10,11 @@
 namespace BPrivate {
 namespace DiskDevice {
 
+/**
+ * 	\brief Wrapper for the C interface of a partitioning system add-on.
+ *
+ * 	See \ref ddm_modules.h for better description of the interface.
+ */
 class KPartitioningSystem : public KDiskSystem {
 public:
 	KPartitioningSystem(const char *name);
@@ -19,7 +24,9 @@
 
 	// Scanning
 
+	/// Try to identify a given partition
 	virtual float Identify(KPartition *partition, void **cookie);
+	/// Scan the partition
 	virtual status_t Scan(KPartition *partition, void *cookie);
 	virtual void FreeIdentifyCookie(KPartition *partition, void *cookie);
 	virtual void FreeCookie(KPartition *partition);
@@ -27,88 +34,132 @@
 
 	// Querying
 
+	/// Check whether the add-on supports repairing this partition.
 	virtual bool SupportsRepairing(KPartition *partition, bool checkOnly,
 								   bool *whileMounted);
+	/// Check whether the add-on supports resizing this partition.
 	virtual bool SupportsResizing(KPartition *partition, bool *whileMounted);
+	/// Check whether the add-on supports resizing children of this partition.
 	virtual bool SupportsResizingChild(KPartition *child);
+	/// Check whether the add-on supports moving this partition.
 	virtual bool SupportsMoving(KPartition *partition, bool *isNoOp);
+	/// Check whether the add-on supports moving children of this partition.
 	virtual bool SupportsMovingChild(KPartition *child);
+	/// Check whether the add-on supports setting name of this partition.
 	virtual bool SupportsSettingName(KPartition *partition);
+	/// Check whether the add-on supports setting name to content of this partition.
 	virtual bool SupportsSettingContentName(KPartition *partition,
 											bool *whileMounted);
+	/// Check whether the add-on supports setting type of this partition.
 	virtual bool SupportsSettingType(KPartition *partition);
+	/// Check whether the add-on supports setting parameters of this partition.
 	virtual bool SupportsSettingParameters(KPartition *partition);
+	/// Check whether the add-on supports setting parameters to content of this partition.
 	virtual bool SupportsSettingContentParameters(KPartition *partition,
 												  bool *whileMounted);
+	/// Check whether the add-on supports initializing this partition.
 	virtual bool SupportsInitializing(KPartition *partition);
+	/// Check whether the add-on supports initializing a child of this partition.
 	virtual bool SupportsInitializingChild(KPartition *child,
 										   const char *diskSystem);
+	/// Check whether the add-on supports creating children of this partition.
 	virtual bool SupportsCreatingChild(KPartition *partition);
+	/// Check whether the add-on supports deleting children of this partition.
 	virtual bool SupportsDeletingChild(KPartition *child);
+	/// Check whether the add-on is a subsystem for a given partition.
 	virtual bool IsSubSystemFor(KPartition *partition);
 
+	/// Validates parameters for resizing a partition
 	virtual bool ValidateResize(KPartition *partition, off_t *size);
+	/// Validates parameters for resizing a child partition
 	virtual bool ValidateResizeChild(KPartition *child, off_t *size);
+	/// Validates parameters for moving a partition
 	virtual bool ValidateMove(KPartition *partition, off_t *start);
+	/// Validates parameters for moving a child partition
 	virtual bool ValidateMoveChild(KPartition *child, off_t *start);
+	/// Validates parameters for setting name of a partition
 	virtual bool ValidateSetName(KPartition *partition, char *name);
+	/// Validates parameters for setting name to content of a partition
 	virtual bool ValidateSetContentName(KPartition *partition, char *name);
+	/// Validates parameters for setting type of a partition
 	virtual bool ValidateSetType(KPartition *partition, const char *type);
+	/// Validates parameters for setting parameters of a partition
 	virtual bool ValidateSetParameters(KPartition *partition,
 									   const char *parameters);
+	/// Validates parameters for setting parameters to content of a partition
 	virtual bool ValidateSetContentParameters(KPartition *parameters,
 											  const char *parameters);
+	/// Validates parameters for initializing a partition
 	virtual bool ValidateInitialize(KPartition *partition, char *name,
 									const char *parameters);
+	/// Validates parameters for creating child of a partition
 	virtual bool ValidateCreateChild(KPartition *partition, off_t *start,
 									 off_t *size, const char *type,
 									 const char *parameters, int32 *index);
+	/// Counts partitionable spaces on a partition
 	virtual int32 CountPartitionableSpaces(KPartition *partition);
+	/// Retrieves a list of partitionable spaces on a partition
 	virtual status_t GetPartitionableSpaces(KPartition *partition,
 											partitionable_space_data *buffer,
 											int32 count,
 											int32 *actualCount = NULL);
 
+	/// Iterates through supported partition types
 	virtual status_t GetNextSupportedType(KPartition *partition, int32 *cookie,
 										  char *type);
+	/// Translates the &quot;pretty&quot; content type to an internal type
 	virtual status_t GetTypeForContentType(const char *contentType,
 										   char *type);
 
 	// Shadow partition modification
 
+	/// Calls for additional modifications when shadow partition is changed
 	virtual status_t ShadowPartitionChanged(KPartition *partition,
 											uint32 operation);
 
 	// Writing
 
+	/// Repairs a partition
 	virtual status_t Repair(KPartition *partition, bool checkOnly,
 							KDiskDeviceJob *job);
+	/// Resizes a partition
 	virtual status_t Resize(KPartition *partition, off_t size,
 							KDiskDeviceJob *job);
+	/// Resizes child of a partition
 	virtual status_t ResizeChild(KPartition *child, off_t size,
 								 KDiskDeviceJob *job);
+	/// Moves a partition
 	virtual status_t Move(KPartition *partition, off_t offset,
 						  KDiskDeviceJob *job);
+	/// Moves child of a partition
 	virtual status_t MoveChild(KPartition *child, off_t offset,
 							   KDiskDeviceJob *job);
+	/// Sets name to a partition
 	virtual status_t SetName(KPartition *partition, char *name,
 							 KDiskDeviceJob *job);
+	/// Sets name to content of a partition
 	virtual status_t SetContentName(KPartition *partition, char *name,
 									KDiskDeviceJob *job);
+	/// Sets type of a partition
 	virtual status_t SetType(KPartition *partition, char *type,
 							 KDiskDeviceJob *job);
+	/// Sets parameters of a partition
 	virtual status_t SetParameters(KPartition *partition,
 								   const char *parameters,
 								   KDiskDeviceJob *job);
+	/// Sets parameters to content of a partition
 	virtual status_t SetContentParameters(KPartition *partition,
 										  const char *parameters,
 										  KDiskDeviceJob *job);
+	/// Creates a child partition
 	virtual status_t CreateChild(KPartition *partition, off_t offset,
 								 off_t size, const char *type,
 								 const char *parameters, KDiskDeviceJob *job,
 								 KPartition **child = NULL,
 								 partition_id childID = -1);
+	/// Deletes a child partition
 	virtual status_t DeleteChild(KPartition *child, KDiskDeviceJob *job);
+	/// Initializes a partition with this partitioning system
 	virtual status_t Initialize(KPartition *partition, const char *name,
 								const char *parameters, KDiskDeviceJob *job);
 

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KPhysicalPartition.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KPhysicalPartition.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KPhysicalPartition.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -12,6 +12,7 @@
 class KDiskSystem;
 class KShadowPartition;
 
+/// \brief Class representing an existing partition.
 class KPhysicalPartition : public KPartition {
 public:
 	KPhysicalPartition(partition_id id = -1);

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/KShadowPartition.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/KShadowPartition.h	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/KShadowPartition.h	2007-07-27 12:12:35 UTC (rev 21719)
@@ -11,6 +11,9 @@
 
 class KPhysicalPartition;
 
+///	\brief Class representing a shadow of an existing partition.
+///
+///	See \ref path_kernel_structures for more information.
 class KShadowPartition : public KPartition, private KPartitionListener {
 public:
 	KShadowPartition(KPhysicalPartition *physicalPartition);

Modified: haiku/trunk/src/system/kernel/disk_device_manager/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/Jamfile	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/Jamfile	2007-07-27 12:12:35 UTC (rev 21719)
@@ -42,7 +42,9 @@
 	KRepairJob.cpp
 	KResizeJob.cpp
 	KScanPartitionJob.cpp
+	KSetNameJob.cpp
 	KSetParametersJob.cpp
+	KSetTypeJob.cpp
 	KUninitializeJob.cpp
 
 	# utilities

Modified: haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJob.cpp
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJob.cpp	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJob.cpp	2007-07-27 12:12:35 UTC (rev 21719)
@@ -243,3 +243,17 @@
 // fNextID
 disk_job_id KDiskDeviceJob::fNextID = 0;
 
+
+// IsNotBusyVisitor
+bool KDiskDeviceJob::IsNotBusyVisitor::VisitPre( KPartition * partition ) {
+	return !(partition-&gt;IsBusy() || partition-&gt;IsDescendantBusy());
+}
+
+
+bool KDiskDeviceJob::isPartitionNotBusy( KPartition * partition ) {
+	if( !partition ) {
+		return false; 
+	}
+	
+	return partition-&gt;VisitEachDescendant(&amp;fNotBusyVisitor);
+}

Modified: haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJobFactory.cpp
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJobFactory.cpp	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/KDiskDeviceJobFactory.cpp	2007-07-27 12:12:35 UTC (rev 21719)
@@ -10,8 +10,18 @@
 
 #include &quot;KDiskDeviceJob.h&quot;
 #include &quot;KDiskDeviceJobFactory.h&quot;
+
+#include &quot;KCreateChildJob.h&quot;
+#include &quot;KDefragmentJob.h&quot;
+#include &quot;KDeleteChildJob.h&quot;
+#include &quot;KInitializeJob.h&quot;
+#include &quot;KMoveJob.h&quot;
+#include &quot;KRepairJob.h&quot;
 #include &quot;KResizeJob.h&quot;
 #include &quot;KScanPartitionJob.h&quot;
+#include &quot;KSetNameJob.h&quot;
+#include &quot;KSetParametersJob.h&quot;
+#include &quot;KSetTypeJob.h&quot;
 #include &quot;KUninitializeJob.h&quot;
 
 using namespace std;
@@ -30,8 +40,7 @@
 KDiskDeviceJob *
 KDiskDeviceJobFactory::CreateDefragmentJob(partition_id partitionID)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KDefragmentJob(partitionID);
 }
 
 
@@ -39,8 +48,7 @@
 KDiskDeviceJobFactory::CreateRepairJob(partition_id partitionID,
 	bool checkOnly)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KRepairJob(partitionID, checkOnly);
 }
 
 
@@ -56,8 +64,8 @@
 KDiskDeviceJobFactory::CreateMoveJob(partition_id parentID, partition_id partitionID,
 	off_t offset, const partition_id *contentsToMove, int32 contentsToMoveCount)
 {
-	// not implemented
-	return NULL;
+	// TODO: this is wierd, what in hell are contentsToMove etc?
+	return new(nothrow) KMoveJob(parentID, partitionID, offset);
 }
 
 
@@ -65,8 +73,7 @@
 KDiskDeviceJobFactory::CreateSetNameJob(partition_id parentID,
 	partition_id partitionID, const char *name)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KSetNameJob(parentID, partitionID, name, 0);
 }
 
 
@@ -74,8 +81,7 @@
 KDiskDeviceJobFactory::CreateSetContentNameJob(partition_id partitionID,
 	const char *name)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KSetNameJob(0, partitionID, 0, name);
 }
 
 
@@ -83,8 +89,7 @@
 KDiskDeviceJobFactory::CreateSetTypeJob(partition_id parentID,
 	partition_id partitionID, const char *type)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KSetTypeJob(parentID, partitionID, type);
 }
 
 
@@ -92,8 +97,7 @@
 KDiskDeviceJobFactory::CreateSetParametersJob(partition_id parentID,
 	partition_id partitionID, const char *parameters)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KSetParametersJob(parentID, partitionID, parameters, 0);
 }
 
 
@@ -101,8 +105,7 @@
 KDiskDeviceJobFactory::CreateSetContentParametersJob(partition_id partitionID,
 	const char *parameters)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KSetParametersJob(0, partitionID, 0, parameters);
 }
 
 
@@ -110,8 +113,7 @@
 KDiskDeviceJobFactory::CreateInitializeJob(partition_id partitionID,
 	disk_system_id diskSystemID, const char *name, const char *parameters)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KInitializeJob(partitionID, diskSystemID, name, parameters);
 }
 
 
@@ -127,8 +129,7 @@
 	partition_id childID, off_t offset, off_t size, const char *type,
 	const char *parameters)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KCreateChildJob(partitionID, childID, offset, size, type, parameters);
 }
 
 
@@ -136,8 +137,7 @@
 KDiskDeviceJobFactory::CreateDeleteChildJob(partition_id parentID,
 	partition_id partitionID)
 {
-	// not implemented
-	return NULL;
+	return new(nothrow) KDeleteChildJob(parentID, partitionID);
 }
 
 

Modified: haiku/trunk/src/system/kernel/disk_device_manager/KPartitioningSystem.cpp
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/KPartitioningSystem.cpp	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/KPartitioningSystem.cpp	2007-07-27 12:12:35 UTC (rev 21719)
@@ -1,4 +1,7 @@
-// KPartitioningSystem.cpp
+/**	\file KPartitioningSystem.cpp
+ *
+ * 	\brief Implementation of \ref KPartitioningSystem class
+ */
 
 #include &lt;fcntl.h&gt;
 #include &lt;stdlib.h&gt;
@@ -499,17 +502,17 @@
 		return B_ENTRY_NOT_FOUND;
 	// lock partition and open partition device
 	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
-	KPartition *_partition = manager-&gt;ReadLockPartition(partition-&gt;ID());
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
 	if (!_partition)
 		return B_ERROR;
 	int fd = -1;
 	{
 		PartitionRegistrar registrar(_partition, true);
 		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
-		DeviceReadLocker locker(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
 		if (partition != _partition)
 			return B_ERROR;
-		status_t result = partition-&gt;Open(O_RDONLY, &amp;fd);
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
 		if (result != B_OK)
 			return result;
 	}
@@ -526,25 +529,24 @@
 								 KDiskDeviceJob *job)
 {
 	// check parameters
-	if (!child || !job || size &lt; 0)
+	if (!child || !job || !child-&gt;Parent() || size &lt; 0)
 		return B_BAD_VALUE;
 	if (!fModule-&gt;resize_child)
 		return B_ENTRY_NOT_FOUND;
 	// lock partition and open (parent) partition device
 	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
-	KPartition *_partition = manager-&gt;ReadLockPartition(child-&gt;ID());
+	KPartition *_partition = manager-&gt;WriteLockPartition(child-&gt;ID());
+	KPartition *_parent = manager-&gt;WriteLockPartition(child-&gt;Parent()-&gt;ID());
 	if (!_partition)
 		return B_ERROR;
 	int fd = -1;
 	{
 		PartitionRegistrar registrar(_partition, true);
 		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
-		DeviceReadLocker locker(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
 		if (child != _partition)
 			return B_ERROR;
-		if (!child-&gt;Parent())
-			return B_BAD_VALUE;
-		status_t result = child-&gt;Parent()-&gt;Open(O_RDONLY, &amp;fd);
+		status_t result = child-&gt;Parent()-&gt;Open(O_RDWR, &amp;fd);
 		if (result != B_OK)
 			return result;
 	}
@@ -560,8 +562,32 @@
 KPartitioningSystem::Move(KPartition *partition, off_t offset,
 						  KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;move)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;move(fd, partition-&gt;ID(), offset, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // MoveChild
@@ -569,8 +595,33 @@
 KPartitioningSystem::MoveChild(KPartition *child, off_t offset,
 							   KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!child || !job || !child-&gt;Parent())
+		return B_BAD_VALUE;
+	if (!fModule-&gt;move_child)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open (parent) partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(child-&gt;ID());
+	KPartition *_parent = manager-&gt;WriteLockPartition(child-&gt;Parent()-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (child != _partition)
+			return B_ERROR;
+		status_t result = child-&gt;Parent()-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;move_child(fd, child-&gt;Parent()-&gt;ID(), child-&gt;ID(), offset, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // SetName
@@ -578,8 +629,32 @@
 KPartitioningSystem::SetName(KPartition *partition, char *name,
 							 KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !name)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;set_name)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;set_name(fd, partition-&gt;ID(), name, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // SetContentName
@@ -587,8 +662,32 @@
 KPartitioningSystem::SetContentName(KPartition *partition, char *name,
 									KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !name)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;set_content_name)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;set_content_name(fd, partition-&gt;ID(), name, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // SetType
@@ -596,8 +695,32 @@
 KPartitioningSystem::SetType(KPartition *partition, char *type,
 							 KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !type)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;set_type)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;set_type(fd, partition-&gt;ID(), type, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // SetParameters
@@ -605,8 +728,32 @@
 KPartitioningSystem::SetParameters(KPartition *partition,
 								   const char *parameters, KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !parameters)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;set_parameters)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;set_parameters(fd, partition-&gt;ID(), parameters, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // SetContentParameters
@@ -615,8 +762,32 @@
 										  const char *parameters,
 										  KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !parameters)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;set_content_parameters)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;set_content_parameters(fd, partition-&gt;ID(), parameters, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // Initialize
@@ -624,8 +795,32 @@
 KPartitioningSystem::Initialize(KPartition *partition, const char *name,
 								const char *parameters, KDiskDeviceJob *job)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !name /*|| !parameters*/)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;initialize)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;initialize(fd, partition-&gt;ID(), name, parameters, job-&gt;ID());
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // CreateChild
@@ -635,8 +830,37 @@
 								 const char *parameters, KDiskDeviceJob *job,
 								 KPartition **child, partition_id childID)
 {
-	// to be implemented
-	return B_ERROR;
+	// check parameters
+	if (!partition || !job || !type /*|| !parameters*/ || !child)
+		return B_BAD_VALUE;
+	if (!fModule-&gt;create_child)
+		return B_ENTRY_NOT_FOUND;
+	// lock partition and open partition device
+	KDiskDeviceManager *manager = KDiskDeviceManager::Default();
+	KPartition *_partition = manager-&gt;WriteLockPartition(partition-&gt;ID());
+	if (!_partition)
+		return B_ERROR;
+	int fd = -1;
+	{
+		PartitionRegistrar registrar(_partition, true);
+		PartitionRegistrar deviceRegistrar(_partition-&gt;Device(), true);
+		DeviceWriteLocker locker(_partition-&gt;Device(), true);
+		if (partition != _partition)
+			return B_ERROR;
+		status_t result = partition-&gt;Open(O_RDWR, &amp;fd);
+		if (result != B_OK)
+			return result;
+	}
+	// let the module do its job
+	status_t result = fModule-&gt;create_child(fd, partition-&gt;ID(), offset, size,
+														type, parameters, job-&gt;ID(), &amp;childID);
+
+	// find and return the child
+	*child = manager-&gt;FindPartition(childID, false);
+
+	// cleanup and return
+	close(fd);
+	return result;
 }
 
 // DeleteChild

Modified: haiku/trunk/src/system/kernel/disk_device_manager/ddm_userland_interface.cpp
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/ddm_userland_interface.cpp	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/ddm_userland_interface.cpp	2007-07-27 12:12:35 UTC (rev 21719)
@@ -1,4 +1,7 @@
-// ddm_userland_interface.cpp
+/** 	\file ddm_userland_interface.cpp
+ *
+ * 	\brief Interface for userspace calls.
+ */
 
 #include &lt;stdlib.h&gt;
 
@@ -721,7 +724,7 @@
 									  int32 changeCounter,
 									  const char *_diskSystemName)
 {
-	if (_diskSystemName)
+	if (!_diskSystemName)
 		return false;
 	char diskSystemName[B_DISK_SYSTEM_NAME_LENGTH];
 	status_t error = ddm_strlcpy(diskSystemName, _diskSystemName, B_DISK_SYSTEM_NAME_LENGTH);
@@ -969,10 +972,10 @@
 		error = validate_initialize_partition(partition, changeCounter,
 											  diskSystemName, name, parameters);
 	}
-	if (!error)
-		error = ddm_strlcpy(_name, name, B_DISK_DEVICE_NAME_LENGTH);
+	if (!error) 
+		error = ddm_strlcpy(name, _name, B_DISK_DEVICE_NAME_LENGTH);
 	free(parameters);
-	return error;											  
+	return error;
 }
 
 // _user_validate_create_child_partition
@@ -1548,6 +1551,7 @@
 			}
 			if (!error) {
 				partition-&gt;Changed(B_PARTITION_CHANGED_CONTENT_PARAMETERS);
+				partition-&gt;Changed(B_PARTITION_CHANGED_INITIALIZATION);
 				// implicit content disk system changes
 				error = partition-&gt;DiskSystem()-&gt;ShadowPartitionChanged(
 					partition, B_PARTITION_INITIALIZE);

Modified: haiku/trunk/src/system/kernel/disk_device_manager/jobs/KCreateChildJob.cpp
===================================================================
--- haiku/trunk/src/system/kernel/disk_device_manager/jobs/KCreateChildJob.cpp	2007-07-27 09:40:26 UTC (rev 21718)
+++ haiku/trunk/src/system/kernel/disk_device_manager/jobs/KCreateChildJob.cpp	2007-07-27 12:12:35 UTC (rev 21719)
@@ -1,3 +1,114 @@
 // KCreateChildJob.cpp
 
 #include &quot;KCreateChildJob.h&quot;
+
+
+#include &lt;KernelExport.h&gt;
+#include &lt;DiskDeviceDefs.h&gt;
+#include &lt;KDiskDevice.h&gt;
+#include &lt;KDiskDeviceManager.h&gt;
+#include &lt;KDiskDeviceUtils.h&gt;
+#include &lt;KDiskSystem.h&gt;
+#include &lt;KPartition.h&gt;
+#include &lt;KPartitionVisitor.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ddm_operation_validation.h&quot;
+
+
+
+KCreateChildJob::KCreateChildJob(partition_id partition, partition_id child, off_t offset,
+				off_t size, const char *type, const char *parameters) 
+	: KDiskDeviceJob( B_DISK_DEVICE_JOB_CREATE, partition, partition ),
+	fChildID( child ), fOffset( offset ), fSize( size ),
+	fType ( !type ? NULL : strcpy ( new char[strlen(type)+1], type ) ),
+	fParameters( !parameters ? NULL : strcpy( new char[strlen(parameters)+1], parameters ) )		
+{
+	SetDescription( &quot;creating child of the partition&quot; );
+}
+				
+KCreateChildJob::~KCreateChildJob() {}
+
+/**

[... truncated: 1047 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003214.html">[Haiku-commits] r21718 - haiku/trunk/src/bin/strace
</A></li>
	<LI>Next message: <A HREF="003220.html">[Haiku-commits] r21720 -	haiku/trunk/src/system/kernel/disk_device_manager/jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3219">[ date ]</a>
              <a href="thread.html#3219">[ thread ]</a>
              <a href="subject.html#3219">[ subject ]</a>
              <a href="author.html#3219">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
