<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21760 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . es1370
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21760%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97%3A%20.%20es1370&In-Reply-To=%3C200707302335.l6UNZ2Iq007963%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003287.html">
   <LINK REL="Next"  HREF="003280.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21760 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . es1370</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21760%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/audio/ac97%3A%20.%20es1370&In-Reply-To=%3C200707302335.l6UNZ2Iq007963%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21760 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . es1370">korli at mail.berlios.de
       </A><BR>
    <I>Tue Jul 31 01:35:02 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="003287.html">[Haiku-commits] r21759 - haiku/trunk/src/preferences/media
</A></li>
        <LI>Next message: <A HREF="003280.html">[Haiku-commits] r21760 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . es1370
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3278">[ date ]</a>
              <a href="thread.html#3278">[ thread ]</a>
              <a href="subject.html#3278">[ subject ]</a>
              <a href="author.html#3278">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2007-07-31 01:35:00 +0200 (Tue, 31 Jul 2007)
New Revision: 21760
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21760&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21760&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/config.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.settings
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370reg.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/io.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/io.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/multi.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/multi.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/queue.h
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.c
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/util.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile
Log:
ES1370 audio driver for QEmu, first version.


Modified: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/Jamfile	2007-07-30 23:35:00 UTC (rev 21760)
@@ -2,5 +2,6 @@
 
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 auich ;
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 auvia ;
+SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 es1370 ;
 SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 ich ;
 # SubInclude HAIKU_TOP src add-ons kernel drivers audio ac97 ichaudio ;

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/Jamfile	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/Jamfile	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,14 @@
+SubDir HAIKU_TOP src add-ons kernel drivers audio ac97 es1370 ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+UsePrivateHeaders media ;
+
+KernelAddon es1370 :
+	debug.c
+	es1370.c
+	io.c
+	multi.c
+	util.c
+;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.c	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.c	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,296 @@
+/*
+ * Auich BeOS Driver for Intel Southbridge audio
+ *
+ * Copyright (c) 2003, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
+ *
+ * Original code : BeOS Driver for Intel ICH AC'97 Link interface
+ * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
+ *
+ * All rights reserved.
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, 
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation 
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include &lt;OS.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;MediaDefs.h&gt;
+#include &quot;ac97.h&quot;
+
+#define REVERSE_EAMP_POLARITY 0
+
+#include &quot;debug.h&quot;
+#include &quot;io.h&quot;
+
+#define B_UTF8_REGISTERED	&quot;\xC2\xAE&quot;
+
+const char * stereo_enhancement_technique[] =
+{
+	&quot;No 3D Stereo Enhancement&quot;,
+	&quot;Analog Devices&quot;,
+	&quot;Creative Technology&quot;,
+	&quot;National Semiconductor&quot;,
+	&quot;Yamaha&quot;,
+	&quot;BBE Sound&quot;,
+	&quot;Crystal Semiconductor&quot;,
+	&quot;Qsound Labs&quot;,
+	&quot;Spatializer Audio Laboratories&quot;,
+	&quot;SRS Labs&quot;,
+	&quot;Platform Tech&quot;,
+	&quot;AKM Semiconductor&quot;,
+	&quot;Aureal&quot;,
+	&quot;Aztech Labs&quot;,
+	&quot;Binaura&quot;,
+	&quot;ESS Technology&quot;,
+	&quot;Harman International&quot;,
+	&quot;Nvidea&quot;,
+	&quot;Philips&quot;,
+	&quot;Texas Instruments&quot;,
+	&quot;VLSI Technology&quot;,
+	&quot;TriTech&quot;,
+	&quot;Realtek&quot;,
+	&quot;Samsung&quot;,
+	&quot;Wolfson Microelectronics&quot;,
+	&quot;Delta Integration&quot;,
+	&quot;SigmaTel&quot;,
+	&quot;KS Waves&quot;,
+	&quot;Rockwell&quot;,
+	&quot;Unknown (29)&quot;,
+	&quot;Unknown (30)&quot;,
+	&quot;Unknown (31)&quot;
+};
+
+typedef void (* codec_init)(device_config *);
+typedef void (* codec_amp_enable)(device_config *, bool);
+
+typedef struct codec_ops_tag
+{
+	codec_init init;
+	codec_amp_enable amp_enable;
+} codec_ops;
+
+typedef struct codec_table_tag
+{
+	uint32 id;
+	uint32 mask;
+	codec_ops *ops;
+	const char *info;
+} codec_table;
+
+void default_init(device_config *);
+void ad1886_init(device_config *);
+
+void default_amp_enable(device_config *, bool);
+void cs4299_amp_enable(device_config *, bool);
+
+codec_ops default_ops = { default_init, default_amp_enable };
+codec_ops ad1886_ops = { ad1886_init, default_amp_enable };
+codec_ops cs4299_ops = { default_init, cs4299_amp_enable };
+
+codec_table codecs[] = 
+{
+	/* Vendor ID and description imported from FreeBSD src/sys/dev/sound/pcm/ac97.c */
+	{ 0x414b4d00, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4540&quot; },
+	{ 0x414b4d01, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4542&quot; },
+	{ 0x414b4d02, 0xffffffff, &amp;default_ops, &quot;Asahi Kasei AK4543&quot; },
+	{ 0x43525900, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525903, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297&quot; },
+	{ 0x43525913, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297A&quot; },
+	{ 0x43525914, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4297B&quot; },
+	{ 0x43525923, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4294C&quot; },
+	{ 0x4352592b, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4298C&quot; },
+	{ 0x43525931, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299A&quot; },
+	{ 0x43525933, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299C&quot; },
+	{ 0x43525934, 0xffffffff, &amp;cs4299_ops,  &quot;Cirrus Logic CS4299D&quot; },
+	{ 0x43525941, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4201A&quot; },
+	{ 0x43525951, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4205A&quot; },
+	{ 0x43525961, 0xffffffff, &amp;default_ops, &quot;Cirrus Logic CS4291A&quot; },
+	{ 0x45838308, 0xffffffff, &amp;default_ops, &quot;ESS Technology ES1921&quot; },
+	{ 0x49434511, 0xffffffff, &amp;default_ops, &quot;ICEnsemble ICE1232&quot; },
+	{ 0x4e534331, 0xffffffff, &amp;default_ops, &quot;National Semiconductor LM4549&quot; },
+	{ 0x83847600, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9700/9783/9784&quot; },
+	{ 0x83847604, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9701/9703/9704/9705&quot; },
+	{ 0x83847605, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9704&quot; },
+	{ 0x83847608, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9708/9711&quot; },
+	{ 0x83847609, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9721/9723&quot; },
+	{ 0x83847644, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9744&quot; },
+	{ 0x83847656, 0xffffffff, &amp;default_ops, &quot;SigmaTel STAC9756/9757&quot; },
+	{ 0x53494c22, 0xffffffff, &amp;default_ops, &quot;Silicon Laboratory Si3036&quot; },
+	{ 0x53494c23, 0xffffffff, &amp;default_ops, &quot;Silicon Laboratory Si3038&quot; },
+	{ 0x54524103, 0xffffffff, &amp;default_ops, &quot;TriTech TR?????&quot; },
+	{ 0x54524106, 0xffffffff, &amp;default_ops, &quot;TriTech TR28026&quot; },
+	{ 0x54524108, 0xffffffff, &amp;default_ops, &quot;TriTech TR28028&quot; },
+	{ 0x54524123, 0xffffffff, &amp;default_ops, &quot;TriTech TR28602&quot; },
+	{ 0x574d4c00, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9701A&quot; },
+	{ 0x574d4c03, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9703/9704&quot; },
+	{ 0x574d4c04, 0xffffffff, &amp;default_ops, &quot;Wolfson WM9704 (quad)&quot; },
+	/* Assembled from datasheets: */
+	{ 0x41445303, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1819B SoundPort&quot;B_UTF8_REGISTERED },
+	{ 0x41445340, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1881 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445348, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1881A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445360, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1885 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445361, 0xffffffff, &amp;ad1886_ops,  &quot;Analog Devices AD1886 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445362, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1887 SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445363, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1886A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445371, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x41445372, 0xffffffff, &amp;default_ops, &quot;Analog Devices AD1981A SoundMAX&quot;B_UTF8_REGISTERED },
+	{ 0x414c4320, 0xfffffff0, &amp;default_ops, &quot;Avance Logic (Realtek) ALC100/ALC100P, RL5383/RL5522&quot; },
+	{ 0x414c4730, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC101&quot; },
+#if 0
+	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC200/ALC200A&quot; }, /* datasheet says id2 = 4710 */
+	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC201/ALC201A&quot; }, /* 4710 or 4720 */
+	{ 0x414c4720, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC650&quot; }, /* datasheet says id2 = 4720 */
+#else
+	{ 0x414c4710, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC200/ALC200A or ALC201/ALC201A&quot; },
+	{ 0x414c4720, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC650 or ALC201/ALC201A&quot; },
+#endif
+	{ 0x414c4740, 0xffffffff, &amp;default_ops, &quot;Avance Logic (Realtek) ALC202/ALC202A&quot; },
+	/* Vendors only: */
+	{ 0x41445300, 0xffffff00, &amp;default_ops, &quot;Analog Devices&quot; },
+	{ 0x414b4d00, 0xffffff00, &amp;default_ops, &quot;Asahi Kasei&quot; },
+	{ 0x414c4700, 0xffffff00, &amp;default_ops, &quot;Avance Logic (Realtek)&quot; },
+	{ 0x43525900, 0xffffff00, &amp;default_ops, &quot;Cirrus Logic&quot; },
+	{ 0x45838300, 0xffffff00, &amp;default_ops, &quot;ESS Technology&quot; },
+	{ 0x49434500, 0xffffff00, &amp;default_ops, &quot;ICEnsemble&quot; },
+	{ 0x4e534300, 0xffffff00, &amp;default_ops, &quot;National Semiconductor&quot; },
+	{ 0x83847600, 0xffffff00, &amp;default_ops, &quot;SigmaTel&quot; },
+	{ 0x53494c00, 0xffffff00, &amp;default_ops, &quot;Silicon Laboratory&quot; },
+	{ 0x54524100, 0xffffff00, &amp;default_ops, &quot;TriTech&quot; },
+	{ 0x574d4c00, 0xffffff00, &amp;default_ops, &quot;Wolfson&quot; },
+	{ 0x00000000, 0x00000000, &amp;default_ops, &quot;Unknown&quot; } /* must be last one, matches every codec */
+};
+
+static codec_table *
+find_codec_table(uint32 codecid)
+{
+	codec_table *codec;
+	for (codec = codecs; codec-&gt;id; codec++)
+		if ((codec-&gt;id &amp; codec-&gt;mask) == (codecid &amp; codec-&gt;mask))
+			break;
+	return codec;
+}
+
+const char *
+ac97_get_3d_stereo_enhancement(device_config *config)
+{
+	uint16 data;
+	data = auich_codec_read(config, AC97_RESET);
+	data = (data &gt;&gt; 10) &amp; 31;
+	return stereo_enhancement_technique[data];
+}
+
+const char *
+ac97_get_vendor_id_description(device_config *config)
+{
+	uint32 id = ac97_get_vendor_id(config);
+	codec_table *codec = find_codec_table(id);
+	char f = (id &gt;&gt; 24) &amp; 0xff;
+	char s = (id &gt;&gt; 16) &amp; 0xff;
+	char t = (id &gt;&gt;  8) &amp; 0xff;
+	if (f == 0) f = '?';
+	if (s == 0) s = '?';
+	if (t == 0) t = '?';
+	LOG((&quot;codec %c%c%c %u\n&quot;,f,s,t,id &amp; 0xff));
+	LOG((&quot;info: %s\n&quot;,codec-&gt;info));
+	return codec-&gt;info;
+}
+
+uint32
+ac97_get_vendor_id(device_config *config)
+{
+	uint16 data1;
+	uint16 data2;
+	data1 = auich_codec_read(config, AC97_VENDOR_ID1);
+	data2 = auich_codec_read(config, AC97_VENDOR_ID2);
+	return (((uint32)data1) &lt;&lt; 16) | data2;
+}
+
+void
+ac97_amp_enable(device_config *config, bool yesno)
+{
+	codec_table *codec;
+	LOG((&quot;ac97_amp_enable\n&quot;));
+	codec = find_codec_table(ac97_get_vendor_id(config));
+	codec-&gt;ops-&gt;amp_enable(config, yesno);
+}
+
+void
+ac97_init(device_config *config)
+{
+	codec_table *codec;
+	LOG((&quot;ac97_init\n&quot;));
+	codec = find_codec_table(ac97_get_vendor_id(config));
+	codec-&gt;ops-&gt;init(config);
+	
+	auich_codec_write(config, AC97_EXTENDED_AUDIO_STATUS,
+		auich_codec_read(config, AC97_EXTENDED_AUDIO_STATUS) | 1);
+		
+}
+
+void default_init(device_config *config)
+{
+	LOG((&quot;default_init\n&quot;));
+}
+
+void ad1886_init(device_config *config)
+{
+	LOG((&quot;ad1886_init\n&quot;));
+	auich_codec_write(config, 0x72, 0x0010);
+}
+
+void default_amp_enable(device_config *config, bool yesno)
+{
+	LOG((&quot;default_amp_enable\n&quot;));
+	LOG((&quot;powerdown register was = %#04x\n&quot;,auich_codec_read(config, AC97_POWERDOWN)));
+	#if REVERSE_EAMP_POLARITY
+		yesno = !yesno;
+		LOG((&quot;using reverse eamp polarity\n&quot;));
+	#endif
+	if (yesno)
+		auich_codec_write(config, AC97_POWERDOWN, auich_codec_read(config, AC97_POWERDOWN) &amp; ~0x8000); /* switch on (low active) */
+	else
+		auich_codec_write(config, AC97_POWERDOWN, auich_codec_read(config, AC97_POWERDOWN) | 0x8000); /* switch off */
+	LOG((&quot;powerdown register is = %#04x\n&quot;, auich_codec_read(config, AC97_POWERDOWN)));
+}
+
+void cs4299_amp_enable(device_config *config, bool yesno)
+{
+	LOG((&quot;cs4299_amp_enable\n&quot;));
+	if (yesno)
+		auich_codec_write(config, 0x68, 0x8004);
+	else
+		auich_codec_write(config, 0x68, 0);
+}
+
+const ac97_source_info source_info[] = {
+	{ &quot;Recording&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO|B_MIX_RECORDMUX, 100, AC97_RECORD_GAIN, 0x8000, 4, 0, 1, 0, 0.0, 22.5, 1.5 },
+	{ &quot;Master&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 101, AC97_MASTER_VOLUME, 0x8000, 5, 0, 1, 1,-46.5, 0.0, 1.5 },
+	//{ &quot;Bass/Treble&quot;, B_MIX_GAIN|B_MIX_STEREO, 102, AC97_MASTER_TONE, 0x0f0f, 4, 0, 1, 1,-12.0, 10.5, 1.5 },
+	//{ &quot;Aux Out&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 103, AC97_AUX_OUT_VOLUME, 0x8000, 5, 0, 1, 1,-46.5, 0.0, 1.5 },
+	{ &quot;PCM Out&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 104, AC97_PCM_OUT_VOLUME, 0x8808, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	{ &quot;CD&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 105, AC97_CD_VOLUME, 0x8808, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	{ &quot;Aux In&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 106, AC97_AUX_IN_VOLUME, 0x8808, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	{ &quot;TAD&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_MONO, 107, AC97_PHONE_VOLUME, 0x8008, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	{ &quot;Mic&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_MONO|B_MIX_MICBOOST, 108, AC97_MIC_VOLUME, 0x8008, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	{ &quot;Line In&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 109, AC97_LINE_IN_VOLUME, 0x8808, 5, 0, 1, 1,-34.5, 12.0, 1.5 },
+	//{ &quot;Center/Lfe&quot;, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 111, AC97_CENTER_LFE_VOLUME, 0x8080, 5, 0, 1, 1,-46.5, 0.0, 1.5 },
+	{ &quot;Center/Lfe&quot; /* should be &quot;Surround&quot; but no */, B_MIX_GAIN|B_MIX_MUTE|B_MIX_STEREO, 110, AC97_SURROUND_VOLUME, 0x8080, 5, 0, 1, 1,-46.5, 0.0, 1.5 }
+};
+
+const int32 source_info_size = (sizeof(source_info)/sizeof(source_info[0]));

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.h	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/ac97.h	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,107 @@
+/*
+ * Auich BeOS Driver for Intel Southbridge audio
+ *
+ * Copyright (c) 2003, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
+ *
+ * Original code : BeOS Driver for Intel ICH AC'97 Link interface
+ * Copyright (c) 2002, Marcus Overhagen &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>&gt;
+ *
+ * All rights reserved.
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice, 
+ *   this list of conditions and the following disclaimer.
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ *   this list of conditions and the following disclaimer in the documentation 
+ *   and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+ * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef _AC97_H_
+#define _AC97_H_
+
+#include &quot;config.h&quot;
+
+enum AC97_REGISTER {
+	AC97_RESET				= 0x00,
+	AC97_MASTER_VOLUME		= 0x02,
+	AC97_AUX_OUT_VOLUME		= 0x04,
+	AC97_MONO_VOLUME		= 0x06,
+	AC97_MASTER_TONE		= 0x08,
+	AC97_PC_BEEP_VOLUME		= 0x0A,
+	AC97_PHONE_VOLUME		= 0x0C,
+	AC97_MIC_VOLUME			= 0x0E,
+	AC97_LINE_IN_VOLUME		= 0x10,
+	AC97_CD_VOLUME			= 0x12,
+	AC97_VIDEO_VOLUME		= 0x14,
+	AC97_AUX_IN_VOLUME		= 0x16,
+	AC97_PCM_OUT_VOLUME		= 0x18,
+	AC97_RECORD_SELECT		= 0x1A,
+	AC97_RECORD_GAIN		= 0x1C,
+	AC97_RECORD_GAIN_MIC	= 0x1E,
+	AC97_GENERAL_PURPOSE	= 0x20,
+	AC97_3D_CONTROL			= 0x22,
+	AC97_PAGING				= 0x24,
+	AC97_POWERDOWN			= 0x26,
+	AC97_EXTENDED_AUDIO_ID 	= 0x28,
+	AC97_EXTENDED_AUDIO_STATUS	= 0x2A,
+	AC97_PCM_FRONT_DAC_RATE	= 0x2C,
+	AC97_PCM_SURR_DAC_RATE	= 0x2E,
+	AC97_PCM_LFE_DAC_RATE	= 0x30,
+	AC97_PCM_LR_ADC_RATE	= 0x32,
+	AC97_MIC_ADC_RATE		= 0x34,
+	AC97_CENTER_LFE_VOLUME	= 0x36,
+	AC97_SURROUND_VOLUME	= 0x38,
+	AC97_SPDIF_CONTROL		= 0x3A,
+	AC97_VENDOR_ID1			= 0x7C,
+	AC97_VENDOR_ID2			= 0x7E
+};
+
+const char *	ac97_get_3d_stereo_enhancement(device_config *config);
+const char *	ac97_get_vendor_id_description(device_config *config);
+uint32			ac97_get_vendor_id(device_config *config);
+void			ac97_init(device_config *config);
+
+void ac97_amp_enable(device_config *config, bool yesno);
+
+typedef enum {
+	B_MIX_GAIN = 1 &lt;&lt; 0,
+	B_MIX_MUTE = 1 &lt;&lt; 1,
+	B_MIX_MONO = 1 &lt;&lt; 2,
+	B_MIX_STEREO = 1 &lt;&lt; 3,
+	B_MIX_MUX = 1 &lt;&lt; 4,
+	B_MIX_MICBOOST = 1 &lt;&lt; 5,
+	B_MIX_RECORDMUX = 1 &lt;&lt; 6
+} ac97_mixer_type;
+
+typedef struct _ac97_source_info {
+	const char *name;
+	ac97_mixer_type  type;
+	
+	int32	id;
+	uint8	reg;
+	uint16	default_value;
+	uint8 	bits:3;
+	uint8	ofs:4;
+	uint8	mute:1;
+	uint8	polarity:1; // max_gain -&gt; 0
+	float	min_gain;
+	float	max_gain;
+	float	granularity;
+} ac97_source_info;
+
+extern const ac97_source_info source_info[];
+extern const int32 source_info_size;
+
+#endif

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/config.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/config.h	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/config.h	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,24 @@
+/*
+ * ES1370 Haiku Driver for ES1370 audio
+ *
+ * Copyright 2002-2007, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Marcus Overhagen, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>
+ *		Jerome Duval, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>
+ */
+#ifndef _CONFIG_H_
+#define _CONFIG_H_
+
+#define NUM_CARDS 3
+#define DEVNAME 32
+
+typedef struct
+{
+	uint32	base;
+	uint32	irq;
+	uint32	type;
+} device_config;
+
+#endif

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.c	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.c	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,76 @@
+/*
+ * ES1370 Haiku Driver for ES1370 audio
+ *
+ * Copyright 2002-2007, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Marcus Overhagen, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>
+ *		Jerome Duval, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>
+ */
+#include &lt;KernelExport.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;OS.h&gt;
+#include &quot;debug.h&quot;
+#include &quot;es1370.h&quot;
+
+#if DEBUG &gt; 0
+static const char * logfile=&quot;/boot/home/es1370.log&quot;;
+static sem_id loglock;
+#endif
+
+void debug_printf(const char *text,...);
+void log_printf(const char *text,...);
+void log_create(void);
+
+void debug_printf(const char *text,...)
+{
+	char buf[1024];
+	va_list ap;
+
+	va_start(ap,text);
+	vsprintf(buf,text,ap);
+	va_end(ap);
+
+	dprintf(DRIVER_NAME &quot;: %s&quot;,buf);
+}
+
+void log_create()
+{
+#if DEBUG &gt; 0
+	int fd = open(logfile, O_WRONLY | O_CREAT | O_TRUNC, 0666);
+	const char *text = DRIVER_NAME &quot;, &quot; VERSION &quot;\n&quot;;
+	loglock = create_sem(1,&quot;logfile sem&quot;);
+	write(fd,text,strlen(text));
+	close(fd);
+#endif
+}
+
+void log_printf(const char *text,...)
+{
+#if DEBUG &gt; 0
+	int fd;
+	char buf[1024];
+	va_list ap;
+
+	va_start(ap,text);
+	vsprintf(buf,text,ap);
+	va_end(ap);
+
+	dprintf(DRIVER_NAME &quot;: %s&quot;,buf);
+
+	acquire_sem(loglock);
+	fd = open(logfile, O_WRONLY | O_APPEND);
+	write(fd,buf,strlen(buf));
+	close(fd);
+	release_sem(loglock);
+
+	#if DEBUG &gt; 1
+		snooze(150000);
+	#endif
+#endif
+}
+

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.h	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/debug.h	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,51 @@
+/*
+ * ES1370 Haiku Driver for ES1370 audio
+ *
+ * Copyright 2002-2007, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Marcus Overhagen, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">marcus at overhagen.de</A>
+ *		Jerome Duval, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>
+ */
+
+#ifndef _DEBUG_H_
+#define _DEBUG_H_
+
+/*
+ * PRINT() executes dprintf if DEBUG = 0 (disabled), or expands to LOG() when DEBUG &gt; 0
+ * TRACE() executes dprintf if DEBUG &gt; 0
+ * LOG()   executes dprintf and writes to the logfile if DEBUG &gt; 0
+ */
+
+/* DEBUG == 0, no debugging, PRINT writes to syslog
+ * DEBUG == 1, TRACE &amp; LOG, PRINT 
+ * DEBUG == 2, TRACE &amp; LOG, PRINT with snooze()
+ */
+#ifndef DEBUG
+	#define DEBUG 1
+#endif
+
+#undef PRINT
+#undef TRACE
+#undef ASSERT
+
+#if DEBUG &gt; 0
+	#define PRINT(a)		log_printf a
+	#define TRACE(a) 		debug_printf a
+	#define LOG(a)			log_printf a
+	#define LOG_CREATE()	log_create()
+	#define ASSERT(a)		if (a) {} else LOG((&quot;ASSERT failed! file = %s, line = %d\n&quot;,__FILE__,__LINE__))
+	void log_create();
+	void log_printf(const char *text,...);
+	void debug_printf(const char *text,...);
+#else
+	void debug_printf(const char *text,...);
+	#define PRINT(a)	debug_printf a
+	#define TRACE(a)	((void)(0))
+	#define ASSERT(a)	((void)(0))
+	#define LOG(a)		((void)(0))
+	#define LOG_CREATE()
+#endif
+
+#endif

Added: haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.c	2007-07-30 21:53:01 UTC (rev 21759)
+++ haiku/trunk/src/add-ons/kernel/drivers/audio/ac97/es1370/es1370.c	2007-07-30 23:35:00 UTC (rev 21760)
@@ -0,0 +1,613 @@
+/*
+ * ES1370 Haiku Driver for ES1370 audio
+ *
+ * Copyright 2002-2007, Haiku, Inc.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jerome Duval, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>
+ */
+ 
+#include &lt;KernelExport.h&gt;
+#include &lt;PCI.h&gt;
+#include &lt;driver_settings.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;es1370.h&quot;
+#include &quot;debug.h&quot;
+#include &quot;config.h&quot;
+#include &quot;util.h&quot;
+#include &quot;io.h&quot;
+#include &lt;fcntl.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;malloc.h&gt;
+
+status_t init_hardware(void);
+status_t init_driver(void);
+void uninit_driver(void);
+const char ** publish_devices(void);
+device_hooks * find_device(const char *);
+status_t es1370_init(es1370_dev * card);
+
+static char pci_name[] = B_PCI_MODULE_NAME;
+pci_module_info	*pci;
+
+int32 num_cards;
+es1370_dev cards[NUM_CARDS];
+int32 num_names;
+char * names[NUM_CARDS*20+1];
+
+extern device_hooks multi_hooks;
+
+es1370_settings current_settings = {
+	44100,	// sample rate
+	512,	// buffer frames
+	2,	// buffer count
+};
+
+
+/* es1370 Memory management */
+
+static es1370_mem *
+es1370_mem_new(es1370_dev *card, size_t size)
+{
+	es1370_mem *mem;
+
+	if ((mem = malloc(sizeof(*mem))) == NULL)
+		return (NULL);
+
+	mem-&gt;area = alloc_mem(&amp;mem-&gt;phy_base, &amp;mem-&gt;log_base, size, &quot;es1370 buffer&quot;);
+	mem-&gt;size = size;
+	if (mem-&gt;area &lt; B_OK) {
+		free(mem);
+		return NULL;
+	}
+	return mem;
+}
+
+static void
+es1370_mem_delete(es1370_mem *mem)
+{
+	if(mem-&gt;area &gt; B_OK)
+		delete_area(mem-&gt;area);
+	free(mem);
+}
+
+static void *
+es1370_mem_alloc(es1370_dev *card, size_t size)
+{
+	es1370_mem *mem;
+	
+	mem = es1370_mem_new(card, size);
+	if (mem == NULL)
+		return (NULL);
+
+	LIST_INSERT_HEAD(&amp;(card-&gt;mems), mem, next);
+
+	return mem;
+}
+
+static void
+es1370_mem_free(es1370_dev *card, void *ptr)
+{
+	es1370_mem 		*mem;
+	
+	LIST_FOREACH(mem, &amp;card-&gt;mems, next) {
+		if (mem-&gt;log_base != ptr)
+			continue;
+		LIST_REMOVE(mem, next);
+		
+		es1370_mem_delete(mem);
+		break;
+	}
+}
+
+/*	es1370 stream functions */
+
+status_t
+es1370_stream_set_audioparms(es1370_stream *stream, uint8 channels,
+     uint8 b16, uint32 sample_rate)
+{
+	uint8 			sample_size, frame_size;
+	LOG((&quot;es1370_stream_set_audioparms\n&quot;));
+
+	if ((stream-&gt;channels == channels) &amp;&amp;
+		(stream-&gt;b16 == b16) &amp;&amp; 
+		(stream-&gt;sample_rate == sample_rate))
+		return B_OK;
+	
+	if(stream-&gt;buffer)
+		es1370_mem_free(stream-&gt;card, stream-&gt;buffer-&gt;log_base);
+		
+	stream-&gt;b16 = b16;
+	stream-&gt;sample_rate = sample_rate;
+	stream-&gt;channels = channels;
+	
+	sample_size = stream-&gt;b16 + 1;
+	frame_size = sample_size * stream-&gt;channels;
+	
+	stream-&gt;buffer = es1370_mem_alloc(stream-&gt;card, stream-&gt;bufframes * frame_size * stream-&gt;bufcount);
+	
+	stream-&gt;trigblk = 0;	/* This shouldn't be needed */
+	stream-&gt;blkmod = stream-&gt;bufcount;
+	stream-&gt;blksize = stream-&gt;bufframes * frame_size;
+		
+	return B_OK;
+}
+
+status_t
+es1370_stream_commit_parms(es1370_stream *stream)
+{
+	uint8 			sample_size, frame_size;
+	uint32	ctrl;
+	es1370_dev *card = stream-&gt;card;
+	LOG((&quot;es1370_stream_commit_parms\n&quot;));
+	
+	ctrl = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_CONTROL) &amp; ~CTRL_PCLKDIV;
+	ctrl |= DAC2_SRTODIV((uint16)stream-&gt;sample_rate) &lt;&lt; CTRL_SH_PCLKDIV;
+	es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_CONTROL, ctrl);
+	
+	sample_size = stream-&gt;b16 + 1;
+	frame_size = sample_size * stream-&gt;channels;
+
+	if (stream-&gt;use &amp; ES1370_USE_RECORD) {
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_MEMPAGE, 0xd);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_ADC_FRAMEADR &amp; 0xff, (uint32)stream-&gt;buffer-&gt;phy_base);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_ADC_FRAMECNT &amp; 0xff, ((stream-&gt;blksize * stream-&gt;bufcount) &gt;&gt; 2) - 1);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_ADC_SCOUNT &amp; 0xff, stream-&gt;bufframes - 1);
+	} else {
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_MEMPAGE, 0xc);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_DAC2_FRAMEADR &amp; 0xff, (uint32)stream-&gt;buffer-&gt;phy_base);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_DAC2_FRAMECNT &amp; 0xff, ((stream-&gt;blksize * stream-&gt;bufcount) &gt;&gt; 2) - 1);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_DAC2_SCOUNT &amp; 0xff, stream-&gt;bufframes - 1);
+		LOG((&quot;es1370_stream_commit_parms %ld %ld\n&quot;, ((stream-&gt;blksize * stream-&gt;bufcount) &gt;&gt; 2) - 1, (stream-&gt;blksize / frame_size) - 1));
+	}
+
+	return B_OK;
+}
+
+status_t
+es1370_stream_get_nth_buffer(es1370_stream *stream, uint8 chan, uint8 buf, 
+					char** buffer, size_t *stride)
+{
+	uint8 			sample_size, frame_size;
+	LOG((&quot;es1370_stream_get_nth_buffer\n&quot;));
+	
+	sample_size = stream-&gt;b16 + 1;
+	frame_size = sample_size * stream-&gt;channels;
+	
+	*buffer = stream-&gt;buffer-&gt;log_base + (buf * stream-&gt;bufframes * frame_size)
+		+ chan * sample_size;
+	*stride = frame_size;
+	
+	return B_OK;
+}
+
+static uint32
+es1370_stream_curaddr(es1370_stream *stream)
+{
+	es1370_dev *card = stream-&gt;card;
+	uint32 reg = 0, cnt = 0;
+	if (stream-&gt;use &amp; ES1370_USE_RECORD) {
+		reg = ES1370_REG_ADC_FRAMECNT;
+	} else {
+		reg = ES1370_REG_DAC2_FRAMECNT;
+	}
+	es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_MEMPAGE, reg &gt;&gt; 8);
+	cnt = es1370_reg_read_32(&amp;card-&gt;config, reg &amp; 0xff) &gt;&gt; 16;
+	//TRACE((&quot;stream_curaddr %lx\n&quot;, (cnt &lt;&lt; 2) / stream-&gt;blksize));
+	return (cnt &lt;&lt; 2) / stream-&gt;blksize;
+}
+
+void
+es1370_stream_start(es1370_stream *stream, void (*inth) (void *), void *inthparam)
+{
+	uint32 sctrl = 0, ctrl = 0;
+	es1370_dev *card = stream-&gt;card;
+	LOG((&quot;es1370_stream_start\n&quot;));
+	
+	stream-&gt;inth = inth;
+	stream-&gt;inthparam = inthparam;
+		
+	stream-&gt;state |= ES1370_STATE_STARTED;
+
+	sctrl = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL);
+	ctrl = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_CONTROL);
+	
+	if (stream-&gt;use &amp; ES1370_USE_RECORD) {
+		sctrl &amp;= ~(SCTRL_R1SEB | SCTRL_R1SMB);
+		if (stream-&gt;b16)
+			sctrl |= SCTRL_R1SEB;
+		if (stream-&gt;channels == 2)
+			sctrl |= SCTRL_R1SMB;
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl &amp; ~SCTRL_R1INTEN);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl | SCTRL_R1INTEN);
+
+		ctrl |= CTRL_ADC_EN;
+	} else {
+		sctrl &amp;= ~(SCTRL_P2SEB | SCTRL_P2SMB | 0x003f0000);
+		if (stream-&gt;b16)
+			sctrl |= SCTRL_P2SEB;
+		if (stream-&gt;channels == 2)
+			sctrl |= SCTRL_P2SMB;
+		sctrl |= (stream-&gt;b16 + 1) &lt;&lt; SCTRL_SH_P2ENDINC;
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl &amp; ~SCTRL_P2INTEN);
+		es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl | SCTRL_P2INTEN);
+
+		ctrl |= CTRL_DAC2_EN;
+	}
+
+	es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl);
+	es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_CONTROL, ctrl);
+	
+#ifdef DEBUG
+	//dump_hardware_regs(&amp;stream-&gt;card-&gt;config);
+#endif
+}
+
+void
+es1370_stream_halt(es1370_stream *stream)
+{
+	uint32 ctrl;
+	es1370_dev *card = stream-&gt;card;
+	LOG((&quot;es1370_stream_halt\n&quot;));
+			
+	stream-&gt;state &amp;= ~ES1370_STATE_STARTED;
+
+	ctrl = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_CONTROL);
+	if (stream-&gt;use &amp; ES1370_USE_RECORD)
+		ctrl &amp;= ~CTRL_ADC_EN;
+	else
+		ctrl &amp;= ~CTRL_DAC2_EN;
+	es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_CONTROL, ctrl);
+}
+
+es1370_stream *
+es1370_stream_new(es1370_dev *card, uint8 use, uint32 bufframes, uint8 bufcount)
+{
+	es1370_stream *stream;
+	cpu_status status;
+	LOG((&quot;es1370_stream_new\n&quot;));
+
+	stream = malloc(sizeof(es1370_stream));
+	if (stream == NULL)
+		return (NULL);
+	stream-&gt;card = card;
+	stream-&gt;use = use;
+	stream-&gt;state = !ES1370_STATE_STARTED;
+	stream-&gt;b16 = 0;
+	stream-&gt;sample_rate = 0;
+	stream-&gt;channels = 0;
+	stream-&gt;bufframes = bufframes;
+	stream-&gt;bufcount = bufcount;
+	stream-&gt;inth = NULL;
+	stream-&gt;inthparam = NULL;
+	stream-&gt;buffer = NULL;
+	stream-&gt;blksize = 0;
+	stream-&gt;trigblk = 0;
+	stream-&gt;blkmod = 0;
+	
+	stream-&gt;buffer_cycle = 0;
+	stream-&gt;frames_count = 0;
+	stream-&gt;real_time = 0;
+	stream-&gt;update_needed = false;
+	
+	status = lock();
+	LIST_INSERT_HEAD((&amp;card-&gt;streams), stream, next);
+	unlock(status);
+	
+	return stream;
+}
+
+void
+es1370_stream_delete(es1370_stream *stream)
+{
+	cpu_status status;
+	int32 i;
+	LOG((&quot;es1370_stream_delete\n&quot;));
+	
+	es1370_stream_halt(stream);
+			
+	if(stream-&gt;buffer)
+		es1370_mem_free(stream-&gt;card, stream-&gt;buffer-&gt;log_base);
+	
+	status = lock();
+	LIST_REMOVE(stream, next);
+	unlock(status);
+	
+	free(stream);
+}
+
+/* es1370 interrupt */
+
+static int32 
+es1370_int(void *arg)
+{
+	es1370_dev	 	*card = arg;
+	bool 			gotone 	= false;
+	uint32       	curblk;
+	es1370_stream 	*stream = NULL;
+	uint32		sta, sctrl;
+	
+	// TRACE((&quot;es1370_int(%p)\n&quot;, card));
+	
+	sta = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_STATUS);
+	if (sta &amp; card-&gt;interrupt_mask) {
+		
+		//TRACE((&quot;interrupt !! %x\n&quot;, sta));
+		sctrl = es1370_reg_read_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL);
+		
+		LIST_FOREACH(stream, &amp;card-&gt;streams, next) {
+			if (stream-&gt;use &amp; ES1370_USE_RECORD) {
+				if ((sta &amp; STAT_ADC) == 0)
+					continue;
+				es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl &amp; ~SCTRL_R1INTEN);
+				es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl | SCTRL_R1INTEN);
+			} else {
+				if ((sta &amp; STAT_DAC2) == 0)
+					continue;
+				es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl &amp; ~SCTRL_P2INTEN);
+				es1370_reg_write_32(&amp;card-&gt;config, ES1370_REG_SERIAL_CONTROL, sctrl | SCTRL_P2INTEN);
+			}
+
+			curblk = es1370_stream_curaddr(stream);
+			// TRACE((&quot;INTR at trigblk %lu, stream-&gt;trigblk %lu\n&quot;, curblk, stream-&gt;trigblk));
+			if (curblk == stream-&gt;trigblk) {
+				stream-&gt;trigblk++;
+				stream-&gt;trigblk = stream-&gt;trigblk % stream-&gt;blkmod;
+				if (stream-&gt;inth)
+					stream-&gt;inth(stream-&gt;inthparam);
+			}
+			gotone = true;
+		}
+	} else {
+		//TRACE((&quot;interrupt masked %x, &quot;, card-&gt;interrupt_mask));
+		//TRACE((&quot;sta %x\n&quot;, sta));
+	}
+	
+	if (gotone)
+		return B_INVOKE_SCHEDULER;
+
+	//TRACE((&quot;Got unhandled interrupt\n&quot;));
+	return B_UNHANDLED_INTERRUPT;
+}
+
+
+/*	es1370 driver functions */
+
+

[... truncated: 2363 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003287.html">[Haiku-commits] r21759 - haiku/trunk/src/preferences/media
</A></li>
	<LI>Next message: <A HREF="003280.html">[Haiku-commits] r21760 - in	haiku/trunk/src/add-ons/kernel/drivers/audio/ac97: . es1370
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3278">[ date ]</a>
              <a href="thread.html#3278">[ thread ]</a>
              <a href="subject.html#3278">[ subject ]</a>
              <a href="author.html#3278">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
