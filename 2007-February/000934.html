<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r20243 - haiku/trunk/src/preferences/backgrounds
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20243%20-%20haiku/trunk/src/preferences/backgrounds&In-Reply-To=%3C200702270031.l1R0VVA0019442%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000933.html">
   <LINK REL="Next"  HREF="000936.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r20243 - haiku/trunk/src/preferences/backgrounds</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20243%20-%20haiku/trunk/src/preferences/backgrounds&In-Reply-To=%3C200702270031.l1R0VVA0019442%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r20243 - haiku/trunk/src/preferences/backgrounds">korli at mail.berlios.de
       </A><BR>
    <I>Tue Feb 27 01:31:32 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000933.html">[Haiku-commits] r20242 - haiku/trunk/data/settings/kernel/drivers
</A></li>
        <LI>Next message: <A HREF="000936.html">[Haiku-commits] r20244 - in haiku/trunk: headers/private/kernel	src/system/kernel/arch/generic src/system/kernel/arch/x86	src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#934">[ date ]</a>
              <a href="thread.html#934">[ thread ]</a>
              <a href="subject.html#934">[ subject ]</a>
              <a href="author.html#934">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2007-02-27 01:31:31 +0100 (Tue, 27 Feb 2007)
New Revision: 20243
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=20243&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=20243&amp;view=rev</A>

Modified:
   haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundImage.h
   haiku/trunk/src/preferences/backgrounds/Backgrounds.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp
   haiku/trunk/src/preferences/backgrounds/BackgroundsView.h
   haiku/trunk/src/preferences/backgrounds/ImageFilePanel.cpp
   haiku/trunk/src/preferences/backgrounds/ImageFilePanel.h
Log:
fixing indenting style issues


Modified: haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp	2007-02-27 00:27:23 UTC (rev 20242)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundImage.cpp	2007-02-27 00:31:31 UTC (rev 20243)
@@ -69,7 +69,7 @@
 
 
 BackgroundImage *
-BackgroundImage::GetBackgroundImage(const BNode *node, bool isDesktop, 
+BackgroundImage::GetBackgroundImage(const BNode *node, bool isDesktop,
 	BackgroundsView* view)
 {
 	BackgroundImage *result = new BackgroundImage(node, isDesktop, view);
@@ -80,7 +80,7 @@
 	BMessage container;
 	char *buffer = new char [info.size];
 
-	status_t error = node-&gt;ReadAttr(kBackgroundImageInfo, info.type, 0, buffer, 
+	status_t error = node-&gt;ReadAttr(kBackgroundImageInfo, info.type, 0, buffer,
 		(size_t)info.size);
 	if (error == info.size)
 		error = container.Unflatten(buffer);
@@ -119,22 +119,22 @@
 		if (imageIndex &lt; 0)
 			imageIndex = -imageIndex - 1;
 
-		container.FindInt32(kBackgroundImageInfoWorkspaces, index, 
+		container.FindInt32(kBackgroundImageInfoWorkspaces, index,
 			(int32 *)&amp;workspaces);
 		container.FindInt32(kBackgroundImageInfoMode, index, (int32 *)&amp;mode);
-		container.FindBool(kBackgroundImageInfoEraseText, index, 
+		container.FindBool(kBackgroundImageInfoEraseText, index,
 			&amp;eraseTextWidgetBackground);
 		container.FindPoint(kBackgroundImageInfoOffset, index, &amp;offset);
 
 		if (isDesktop) {
-			container.FindInt32(kBackgroundImageInfoSet, index, 
+			container.FindInt32(kBackgroundImageInfoSet, index,
 				(int32 *)&amp;imageSet);
-			container.FindInt32(kBackgroundImageInfoCacheMode, index, 
+			container.FindInt32(kBackgroundImageInfoCacheMode, index,
 				(int32 *)&amp;cacheMode);
 		}
 
 		BackgroundImage::BackgroundImageInfo *imageInfo = new
-			BackgroundImage::BackgroundImageInfo(workspaces, imageIndex, 
+			BackgroundImage::BackgroundImageInfo(workspaces, imageIndex,
 				mode, offset, eraseTextWidgetBackground, imageSet, cacheMode);
 
 		//imageInfo-&gt;UnloadBitmap(globalCacheMode);
@@ -151,7 +151,7 @@
 		result-&gt;fImageSetPeriod = imageSetPeriod;
 		result-&gt;fCacheMode = globalCacheMode;
 		if (result-&gt;fImageSetCount &gt; 1)
-			result-&gt;fShowingImageSet = random()%result-&gt;fImageSetCount;
+			result-&gt;fShowingImageSet = random() % result-&gt;fImageSetCount;
 	}
 
 	return result;
@@ -159,7 +159,7 @@
 
 
 BackgroundImage::BackgroundImageInfo::BackgroundImageInfo(uint32 workspaces,
-	int32 imageIndex, Mode mode, BPoint offset, bool eraseTextWidget, 
+	int32 imageIndex, Mode mode, BPoint offset, bool eraseTextWidget,
 	uint32 imageSet, uint32 cacheMode)
 	:
 	fWorkspace(workspaces),
@@ -203,14 +203,14 @@
 }
 
 
-void 
+void
 BackgroundImage::Add(BackgroundImageInfo *info)
 {
 	fBitmapForWorkspaceList.AddItem(info);
 }
 
 
-void 
+void
 BackgroundImage::Remove(BackgroundImageInfo *info)
 {
 	fBitmapForWorkspaceList.RemoveItem(info);
@@ -230,7 +230,7 @@
 }
 
 
-void 
+void
 BackgroundImage::Show(BView *view, int32 workspace)
 {
 	fView = view;
@@ -245,10 +245,10 @@
 }
 
 
-void 
+void
 BackgroundImage::Show(BackgroundImageInfo *info, BView *view)
 {
-	BBitmap *bitmap = fBackgroundsView-&gt;GetImage(info-&gt;fImageIndex)-&gt;GetBitmap();	
+	BBitmap *bitmap = fBackgroundsView-&gt;GetImage(info-&gt;fImageIndex)-&gt;GetBitmap();
 
 	if (!bitmap)
 		return;
@@ -289,16 +289,16 @@
 			}
 			// else fall thru
 		case kAtOffset:
-			{
-				destinationBitmapBounds.OffsetTo(offset);
-				break;
-			}
+		{
+			destinationBitmapBounds.OffsetTo(offset);
+			break;
+		}
 		case kTiled:
 			// Original Backgrounds Preferences center the tiled paper but the Tracker don't do that
 			//if (fIsDesktop) {
-				destinationBitmapBounds.OffsetBy(
-					(viewBounds.Width() - destinationBitmapBounds.Width()) / 2,
-					(viewBounds.Height() - destinationBitmapBounds.Height()) / 2);
+			destinationBitmapBounds.OffsetBy(
+				(viewBounds.Width() - destinationBitmapBounds.Width()) / 2,
+				(viewBounds.Height() - destinationBitmapBounds.Height()) / 2);
 			//}
 			tile = B_TILE_BITMAP;
 			break;
@@ -317,7 +317,7 @@
 }
 
 
-void 
+void
 BackgroundImage::Remove()
 {
 	if (fShowingBitmap) {
@@ -359,12 +359,12 @@
 		} else
 			return info;
 	}
-	
+
 	return result;
 }
 
 
-void 
+void
 BackgroundImage::WorkspaceActivated(BView *view, int32 workspace, bool state)
 {
 	if (!fIsDesktop) {
@@ -392,7 +392,7 @@
 }
 
 
-void 
+void
 BackgroundImage::ScreenChanged(BRect, color_space)
 {
 	if (!fIsDesktop || !fShowingBitmap)
@@ -440,7 +440,7 @@
 	PRINT_OBJECT(container);
 
 	size_t flattenedSize = container.FlattenedSize();
-	char* buffer = new (std::nothrow) char[flattenedSize];
+	char* buffer = new(std::nothrow) char[flattenedSize];
 	if (buffer == NULL)
 		return B_NO_MEMORY;
 
@@ -469,7 +469,7 @@
 		oldBackgroundImage-&gt;Remove();
 		delete oldBackgroundImage;
 	}
-	
+
 	BackgroundImage *result = GetBackgroundImage(fromNode, desktop);
 	if (result &amp;&amp; poseView-&gt;ViewMode() != kListMode)
 		result-&gt;Show(poseView, current_workspace());
@@ -477,7 +477,7 @@
 }
 
 
-void 
+void
 BackgroundImage::ChangeImageSet(BPoseView *poseView)
 {
 	if(fRandomChange) {
@@ -492,7 +492,7 @@
 		if(fShowingImageSet &gt; fImageSetCount - 1)
 			fShowingImageSet = 0;
 	}
-	
+
 	this-&gt;Show(poseView, current_workspace());
 }*/
 

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundImage.h
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundImage.h	2007-02-27 00:27:23 UTC (rev 20242)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundImage.h	2007-02-27 00:31:31 UTC (rev 20243)
@@ -66,92 +66,92 @@
 const uint32 kChangeBackgroundImage = 'Cbgr';
 
 class BackgroundImage {
-	// This class knows everything about which bitmap to use for a given
-	// view and how.
-	// Unlike other windows, the Desktop window can have different backgrounds
-	// for each workspace
-public:
-	
-	enum Mode {
-		kAtOffset,
-		kCentered,			// only works on Desktop
-		kScaledToFit,		// only works on Desktop
-		kTiled
-	};
-	
-	class BackgroundImageInfo {
-		// element of the per-workspace list
+		// This class knows everything about which bitmap to use for a given
+		// view and how.
+		// Unlike other windows, the Desktop window can have different backgrounds
+		// for each workspace
 	public:
-		BackgroundImageInfo(uint32 workspace, int32 imageIndex, Mode mode, 
-			BPoint offset, bool eraseTextWidget, uint32 imageSet, 
-			uint32 cacheMode);
-		~BackgroundImageInfo();
-		
-		void LoadBitmap();
-		void UnloadBitmap(uint32 globalCacheMode);
 
-		uint32 fWorkspace;
-		int32 fImageIndex;
-		Mode fMode;
-		BPoint fOffset;
-		bool fEraseTextWidgetBackground;
-		uint32 fImageSet;
-		uint32 fCacheMode;		// image cache strategy (0 cache , 1 no cache)
-	};
-	
-	static BackgroundImage *GetBackgroundImage(const BNode *node,
-		bool isDesktop, BackgroundsView* view);
+		enum Mode {
+			kAtOffset,
+			kCentered,			// only works on Desktop
+			kScaledToFit,		// only works on Desktop
+			kTiled
+		};
+
+		class BackgroundImageInfo {
+				// element of the per-workspace list
+			public:
+				BackgroundImageInfo(uint32 workspace, int32 imageIndex, Mode mode,
+					BPoint offset, bool eraseTextWidget, uint32 imageSet,
+					uint32 cacheMode);
+				~BackgroundImageInfo();
+
+				void LoadBitmap();
+				void UnloadBitmap(uint32 globalCacheMode);
+
+				uint32 fWorkspace;
+				int32 fImageIndex;
+				Mode fMode;
+				BPoint fOffset;
+				bool fEraseTextWidgetBackground;
+				uint32 fImageSet;
+				uint32 fCacheMode;		// image cache strategy (0 cache , 1 no cache)
+		};
+
+		static BackgroundImage *GetBackgroundImage(const BNode *node,
+			bool isDesktop, BackgroundsView* view);
 		// create a BackgroundImage object by reading it from a node
 
-	virtual ~BackgroundImage();
+		virtual ~BackgroundImage();
 
-	void Show(BView *view, int32 workspace);
+		void Show(BView *view, int32 workspace);
 		// display the right background for a given workspace
-	void Remove();
+		void Remove();
 		// remove the background from it's current view
 
-	void WorkspaceActivated(BView *view, int32 workspace, bool state);
+		void WorkspaceActivated(BView *view, int32 workspace, bool state);
 		// respond to a workspace change
-	void ScreenChanged(BRect rect, color_space space);
+		void ScreenChanged(BRect rect, color_space space);
 		// respond to a screen size change
-	/*static BackgroundImage *Refresh(BackgroundImage *oldBackgroundImage,
-		const BNode *fromNode, bool desktop, BPoseView *poseView);
-		// respond to a background image setting change
-	void ChangeImageSet(BPoseView *poseView);
-		// change to the next imageSet if any, no refresh*/
-	BackgroundImageInfo *ImageInfoForWorkspace(int32) const;
-	
+		/*static BackgroundImage *Refresh(BackgroundImage *oldBackgroundImage,
+			const BNode *fromNode, bool desktop, BPoseView *poseView);
+			// respond to a background image setting change
+		void ChangeImageSet(BPoseView *poseView);
+			// change to the next imageSet if any, no refresh*/
+		BackgroundImageInfo *ImageInfoForWorkspace(int32) const;
+
 		// return fIsDesktop
-	bool IsDesktop() { return fIsDesktop;}
-	
-	status_t SetBackgroundImage(BNode *node);
-	
-	void Show(BackgroundImageInfo *, BView *view);
-	
-	uint32 GetShowingImageSet() { return fShowingImageSet; }
-	
-	void Add(BackgroundImageInfo *);
-	void Remove(BackgroundImageInfo *);
-	void RemoveAll();
+		bool IsDesktop() { return fIsDesktop;}
 
-private:
-	BackgroundImage(const BNode *node, bool isDesktop, BackgroundsView* view);
+		status_t SetBackgroundImage(BNode *node);
+
+		void Show(BackgroundImageInfo *, BView *view);
+
+		uint32 GetShowingImageSet() { return fShowingImageSet; }
+
+		void Add(BackgroundImageInfo *);
+		void Remove(BackgroundImageInfo *);
+		void RemoveAll();
+
+	private:
+		BackgroundImage(const BNode *node, bool isDesktop, BackgroundsView* view);
 		// no public constructor, GetBackgroundImage factory function is
 		// used instead
 
-	bool fIsDesktop;
-	BNode fDefinedByNode;
-	BView *fView;
-	BackgroundsView* fBackgroundsView;
-	BackgroundImageInfo *fShowingBitmap;
-		
-	BObjectList&lt;BackgroundImageInfo&gt; fBitmapForWorkspaceList;
-	
-	uint32 fImageSetPeriod;		// period between imagesets, 0 if none
-	uint32 fShowingImageSet;	// current imageset
-	uint32 fImageSetCount;		// imageset count
-	uint32 fCacheMode;// image cache strategy (0 all, 1 none, 2 own strategy)
-	bool fRandomChange; 		// random or sequential change
+		bool fIsDesktop;
+		BNode fDefinedByNode;
+		BView *fView;
+		BackgroundsView* fBackgroundsView;
+		BackgroundImageInfo *fShowingBitmap;
+
+		BObjectList&lt;BackgroundImageInfo&gt; fBitmapForWorkspaceList;
+
+		uint32 fImageSetPeriod;		// period between imagesets, 0 if none
+		uint32 fShowingImageSet;	// current imageset
+		uint32 fImageSetCount;		// imageset count
+		uint32 fCacheMode;// image cache strategy (0 all, 1 none, 2 own strategy)
+		bool fRandomChange; 		// random or sequential change
 };
 
 class Image {
@@ -159,7 +159,7 @@
 	public:
 		Image(BPath path);
 		~Image();
-		
+
 		void UnloadBitmap();
 		const char* GetName() {return name.String();}
 		BBitmap* GetBitmap();

Modified: haiku/trunk/src/preferences/backgrounds/Backgrounds.cpp
===================================================================
--- haiku/trunk/src/preferences/backgrounds/Backgrounds.cpp	2007-02-27 00:27:23 UTC (rev 20242)
+++ haiku/trunk/src/preferences/backgrounds/Backgrounds.cpp	2007-02-27 00:31:31 UTC (rev 20243)
@@ -53,9 +53,9 @@
 
 
 BackgroundsWindow::BackgroundsWindow(BRect frame, bool standalone)
-	: BWindow(frame, &quot;Backgrounds&quot;, B_TITLED_WINDOW, 
+	: BWindow(frame, &quot;Backgrounds&quot;, B_TITLED_WINDOW,
 		B_NOT_RESIZABLE | B_NOT_ZOOMABLE, B_ALL_WORKSPACES),
-		fIsStandalone(standalone)
+	fIsStandalone(standalone)
 {
 	fBackgroundsView = new BackgroundsView(Bounds(), &quot;BackgroundsView&quot;,
 		B_FOLLOW_ALL, B_WILL_DRAW);
@@ -87,7 +87,7 @@
 }
 
 
-void 
+void
 BackgroundsWindow::ProcessRefs(entry_ref dir, BMessage* refs)
 {
 	fBackgroundsView-&gt;ProcessRefs(dir, refs);

Modified: haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp
===================================================================
--- haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp	2007-02-27 00:27:23 UTC (rev 20242)
+++ haiku/trunk/src/preferences/backgrounds/BackgroundsView.cpp	2007-02-27 00:31:31 UTC (rev 20243)
@@ -51,44 +51,44 @@
 const uint8 kHandCursorData[68] = {
 	16, 1, 2, 2,
 
-	0,0,		// 0000000000000000
-	7,128,		// 0000011110000000
-	61,112,		// 0011110101110000
-	37,40,		// 0010010100101000
-	36,168,		// 0010010010101000
-	18,148,		// 0001001010010100
-	18,84,		// 0001001001010100
-	9,42,		// 0000100100101010
-	8,1,		// 0000100000000001
-	60,1,		// 0011110000000001
-	76,1,		// 0100110000000001
-	66,1,		// 0100001000000001
-	48,1,		// 0011000000000001
-	12,1,		// 0000110000000001
-	2,0,		// 0000001000000000
-	1,0,		// 0000000100000000
+	0, 0,		// 0000000000000000
+	7, 128,		// 0000011110000000
+	61, 112,		// 0011110101110000
+	37, 40,		// 0010010100101000
+	36, 168,		// 0010010010101000
+	18, 148,		// 0001001010010100
+	18, 84,		// 0001001001010100
+	9, 42,		// 0000100100101010
+	8, 1,		// 0000100000000001
+	60, 1,		// 0011110000000001
+	76, 1,		// 0100110000000001
+	66, 1,		// 0100001000000001
+	48, 1,		// 0011000000000001
+	12, 1,		// 0000110000000001
+	2, 0,		// 0000001000000000
+	1, 0,		// 0000000100000000
 
-	0,0,		// 0000000000000000
-	7,128,		// 0000011110000000
-	63,240,		// 0011111111110000
-	63,248,		// 0011111111111000
-	63,248,		// 0011111111111000
-	31,252,		// 0001111111111100
-	31,252,		// 0001111111111100
-	15,254,		// 0000111111111110
-	15,255,		// 0000111111111111
-	63,255,		// 0011111111111111
-	127,255,	// 0111111111111111
-	127,255,	// 0111111111111111
-	63,255,		// 0011111111111111
-	15,255,		// 0000111111111111
-	3,254,		// 0000001111111110
-	1,248		// 0000000111111000
+	0, 0,		// 0000000000000000
+	7, 128,		// 0000011110000000
+	63, 240,		// 0011111111110000
+	63, 248,		// 0011111111111000
+	63, 248,		// 0011111111111000
+	31, 252,		// 0001111111111100
+	31, 252,		// 0001111111111100
+	15, 254,		// 0000111111111110
+	15, 255,		// 0000111111111111
+	63, 255,		// 0011111111111111
+	127, 255,	// 0111111111111111
+	127, 255,	// 0111111111111111
+	63, 255,		// 0011111111111111
+	15, 255,		// 0000111111111111
+	3, 254,		// 0000001111111110
+	1, 248		// 0000000111111000
 };
 
 
 BackgroundsView::BackgroundsView(BRect frame, const char *name, int32 resize,
-		int32 flags)
+	int32 flags)
 	: BBox(frame, name, resize, flags | B_WILL_DRAW | B_FRAME_EVENTS, B_NO_BORDER),
 	fCurrent(NULL),
 	fCurrentInfo(NULL),
@@ -100,16 +100,16 @@
 
 	BMenuItem *menuItem;
 	fWorkspaceMenu = new BPopUpMenu(&quot;pick one&quot;);
-	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;All Workspaces&quot;, 
+	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;All Workspaces&quot;,
 		new BMessage(kMsgAllWorkspaces)));
-	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Current Workspace&quot;, 
+	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Current Workspace&quot;,
 		new BMessage(kMsgCurrentWorkspace)));
 	menuItem-&gt;SetMarked(true);
 	fLastWorkspaceIndex = fWorkspaceMenu-&gt;IndexOf(fWorkspaceMenu-&gt;FindMarked());
 	fWorkspaceMenu-&gt;AddSeparatorItem();
-	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Default folder&quot;, 
+	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Default folder&quot;,
 		new BMessage(kMsgDefaultFolder)));
-	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Other folder&quot; B_UTF8_ELLIPSIS, 
+	fWorkspaceMenu-&gt;AddItem(menuItem = new BMenuItem(&quot;Other folder&quot; B_UTF8_ELLIPSIS,
 		new BMessage(kMsgOtherFolder)));
 
 	BMenuField *workspaceMenuField = new BMenuField(BRect(0, 0, 130, 18),
@@ -129,7 +129,7 @@
 	AddChild(fPreview);
 
 	BRect rect(10, fPreview-&gt;Bounds().bottom - 30, 70, fPreview-&gt;Bounds().bottom - 10);
-	fXPlacementText = new BTextControl(rect, &quot;xPlacementText&quot;, &quot;X:&quot;, NULL, 
+	fXPlacementText = new BTextControl(rect, &quot;xPlacementText&quot;, &quot;X:&quot;, NULL,
 		new BMessage(kMsgImagePlacement), B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);
 	fXPlacementText-&gt;SetDivider(fXPlacementText-&gt;StringWidth(fXPlacementText-&gt;Label()) + 4.0f);
 	fXPlacementText-&gt;TextView()-&gt;SetMaxBytes(5);
@@ -141,7 +141,7 @@
 	fPreview-&gt;AddChild(fXPlacementText);
 
 	rect.OffsetBy(70, delta);
-	fYPlacementText = new BTextControl(rect, &quot;yPlacementText&quot;, &quot;Y:&quot;, NULL, 
+	fYPlacementText = new BTextControl(rect, &quot;yPlacementText&quot;, &quot;Y:&quot;, NULL,
 		new BMessage(kMsgImagePlacement), B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);
 	fYPlacementText-&gt;SetDivider(fYPlacementText-&gt;StringWidth(fYPlacementText-&gt;Label()) + 4.0f);
 	fYPlacementText-&gt;TextView()-&gt;SetMaxBytes(5);
@@ -155,7 +155,7 @@
 		}
 	}
 
-	fPreView = new PreView(BRect(15, 25, 135, 115), &quot;preView&quot;, 
+	fPreView = new PreView(BRect(15, 25, 135, 115), &quot;preView&quot;,
 		B_FOLLOW_LEFT | B_FOLLOW_TOP, B_WILL_DRAW | B_SUBPIXEL_PRECISE);
 	fPreview-&gt;AddChild(fPreView);
 
@@ -181,7 +181,7 @@
 	fImageMenu-&gt;AddSeparatorItem();
 	fImageMenu-&gt;AddItem(new BMenuItem(&quot;Other&quot; B_UTF8_ELLIPSIS, new BMessage(kMsgOtherImage)));
 
-	BMenuField *imageMenuField = new BMenuField(rect, &quot;imageMenuField&quot;, 
+	BMenuField *imageMenuField = new BMenuField(rect, &quot;imageMenuField&quot;,
 		&quot;Image:&quot;, fImageMenu);
 	imageMenuField-&gt;SetDivider(offset);
 	imageMenuField-&gt;SetAlignment(B_ALIGN_RIGHT);
@@ -189,13 +189,13 @@
 	rightbox-&gt;AddChild(imageMenuField);
 
 	fPlacementMenu = new BPopUpMenu(&quot;pick one&quot;);
-	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Manual&quot;, 
+	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Manual&quot;,
 		new BMessage(kMsgManualPlacement)));
-	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Center&quot;, 
+	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Center&quot;,
 		new BMessage(kMsgCenterPlacement)));
-	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Scale to fit&quot;, 
+	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Scale to fit&quot;,
 		new BMessage(kMsgScalePlacement)));
-	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Tile&quot;, 
+	fPlacementMenu-&gt;AddItem(new BMenuItem(&quot;Tile&quot;,
 		new BMessage(kMsgTilePlacement)));
 
 	rect.OffsetBy(0, imageMenuField-&gt;Bounds().Height() + 5);
@@ -207,14 +207,14 @@
 	rightbox-&gt;AddChild(placementMenuField);
 
 	rect.OffsetBy(offset, placementMenuField-&gt;Bounds().Height() + 5);
-	fIconLabelBackground = new BCheckBox(rect, &quot;iconLabelBackground&quot;, 
+	fIconLabelBackground = new BCheckBox(rect, &quot;iconLabelBackground&quot;,
 		&quot;Icon label background&quot;, new BMessage(kMsgIconLabelBackground));
 	fIconLabelBackground-&gt;SetValue(B_CONTROL_ON);
 	fIconLabelBackground-&gt;ResizeToPreferred();
 	rightbox-&gt;AddChild(fIconLabelBackground);
 
 	rect.top += fIconLabelBackground-&gt;Bounds().Height() + 15;
-	fPicker = new BColorControl(BPoint(10, rect.top), B_CELLS_32x8, 5.0, &quot;Picker&quot;, 
+	fPicker = new BColorControl(BPoint(10, rect.top), B_CELLS_32x8, 5.0, &quot;Picker&quot;,
 		new BMessage(kMsgUpdateColor));
 	rightbox-&gt;AddChild(fPicker);
 
@@ -278,11 +278,11 @@
 	fApply-&gt;SetTarget(this);
 	fRevert-&gt;SetTarget(this);
 
-	fPanel = new ImageFilePanel(B_OPEN_PANEL, new BMessenger(this), NULL, 
+	fPanel = new ImageFilePanel(B_OPEN_PANEL, new BMessenger(this), NULL,
 		B_FILE_NODE, false, NULL, new CustomRefFilter(true));
 	fPanel-&gt;SetButtonLabel(B_DEFAULT_BUTTON, &quot;Select&quot;);
 
-	fFolderPanel = new BFilePanel(B_OPEN_PANEL, new BMessenger(this), NULL, 
+	fFolderPanel = new BFilePanel(B_OPEN_PANEL, new BMessenger(this), NULL,
 		B_DIRECTORY_NODE, false, NULL, new CustomRefFilter(false));
 	fFolderPanel-&gt;SetButtonLabel(B_DEFAULT_BUTTON, &quot;Select&quot;);
 
@@ -372,7 +372,7 @@
 			if (pointer == fPanel) {
 				if (fLastImageIndex &gt;= 0)
 					FindImageItem(fLastImageIndex)-&gt;SetMarked(true);
-				else 
+				else
 					fImageMenu-&gt;ItemAt(0)-&gt;SetMarked(true);
 			} else if (pointer == fFolderPanel) {
 				if (fLastWorkspaceIndex &gt;= 0)
@@ -524,10 +524,10 @@
 				cmd = kMsgManualPlacement;
 				xtext &lt;&lt; (int)fCurrentInfo-&gt;fOffset.x;
 				ytext &lt;&lt; (int)fCurrentInfo-&gt;fOffset.y;
-				break;	
+				break;
 			case BackgroundImage::kTiled:
 				cmd = kMsgTilePlacement;
-			break;
+				break;
 		}
 
 		if (cmd != 0)
@@ -557,14 +557,14 @@
 void
 BackgroundsView::Save()
 {
-	bool eraseTextWidgetBackground = 
+	bool eraseTextWidgetBackground =
 		fIconLabelBackground-&gt;Value() == B_CONTROL_ON;
 	BackgroundImage::Mode mode = FindPlacementMode();
 	BPoint offset(atoi(fXPlacementText-&gt;Text()), atoi(fYPlacementText-&gt;Text()));
 
 	if (!fCurrent-&gt;IsDesktop()) {
 		if (fCurrentInfo == NULL) {
-			fCurrentInfo = new BackgroundImage::BackgroundImageInfo(B_ALL_WORKSPACES, 
+			fCurrentInfo = new BackgroundImage::BackgroundImageInfo(B_ALL_WORKSPACES,
 				fLastImageIndex, mode, offset, eraseTextWidgetBackground, 0, 0);
 			fCurrent-&gt;Add(fCurrentInfo);
 		} else {
@@ -583,12 +583,12 @@
 		if (fCurrentInfo != NULL) {
 			if (fWorkspaceMenu-&gt;FindItem(kMsgCurrentWorkspace)-&gt;IsMarked()) {
 				if (fCurrentInfo-&gt;fWorkspace != workspaceMask) {
-					fCurrentInfo-&gt;fWorkspace = fCurrentInfo-&gt;fWorkspace 
+					fCurrentInfo-&gt;fWorkspace = fCurrentInfo-&gt;fWorkspace
 						^ workspaceMask;
 					if (fLastImageIndex &gt; -1) {
 						fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
-							workspaceMask, fLastImageIndex, mode, offset, 
-							eraseTextWidgetBackground, fCurrentInfo-&gt;fImageSet, 
+							workspaceMask, fLastImageIndex, mode, offset,
+							eraseTextWidgetBackground, fCurrentInfo-&gt;fImageSet,
 							fCurrentInfo-&gt;fCacheMode);
 						fCurrent-&gt;Add(fCurrentInfo);
 					}
@@ -599,7 +599,7 @@
 						fCurrentInfo-&gt;fMode = mode;
 						if (fCurrentInfo-&gt;fMode == BackgroundImage::kAtOffset)
 							fCurrentInfo-&gt;fOffset = offset;
-	
+
 						fCurrentInfo-&gt;fImageIndex = fLastImageIndex;
 					} else {
 						fCurrent-&gt;Remove(fCurrentInfo);
@@ -609,7 +609,7 @@
 			} else if (fLastImageIndex &gt; -1) {
 				fCurrent-&gt;RemoveAll();
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
-					B_ALL_WORKSPACES, fLastImageIndex, mode, offset, 
+					B_ALL_WORKSPACES, fLastImageIndex, mode, offset,
 					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(),
 					fCurrentInfo-&gt;fCacheMode);
 				fCurrent-&gt;Add(fCurrentInfo);
@@ -617,12 +617,12 @@
 		} else if (fLastImageIndex &gt; -1) {
 			if (fWorkspaceMenu-&gt;FindItem(kMsgCurrentWorkspace)-&gt;IsMarked()) {
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
-					workspaceMask, fLastImageIndex, mode, offset, 
+					workspaceMask, fLastImageIndex, mode, offset,
 					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(), 0);
 			} else {
 				fCurrent-&gt;RemoveAll();
 				fCurrentInfo = new BackgroundImage::BackgroundImageInfo(
-					B_ALL_WORKSPACES, fLastImageIndex, mode, offset, 
+					B_ALL_WORKSPACES, fLastImageIndex, mode, offset,
 					eraseTextWidgetBackground, fCurrent-&gt;GetShowingImageSet(), 0);
 			}
 			fCurrent-&gt;Add(fCurrentInfo);
@@ -630,7 +630,7 @@
 
 		if (!fWorkspaceMenu-&gt;FindItem(kMsgCurrentWorkspace)-&gt;IsMarked()) {
 			for (int32 i = 0; i &lt; count_workspaces(); i++) {
-					BScreen().SetDesktopColor(fPicker-&gt;ValueAsColor(), i, true);
+				BScreen().SetDesktopColor(fPicker-&gt;ValueAsColor(), i, true);
 			}
 		} else
 			BScreen().SetDesktopColor(fPicker-&gt;ValueAsColor(), true);
@@ -655,13 +655,13 @@
 		tracker.SendMessage(new BMessage(B_RESTORE_BACKGROUND_IMAGE));
 	} else {
 		int32 i = -1;
-		BMessage reply; 
+		BMessage reply;
 		int32 err;
 		BEntry currentEntry(&amp;fCurrentRef);
 		BPath currentPath(&amp;currentEntry);
 		bool isCustomFolder = !fWorkspaceMenu-&gt;FindItem(kMsgDefaultFolder)-&gt;IsMarked();
 
-		do { 
+		do {
 			BMessage msg(B_GET_PROPERTY);
 			i++;
 
@@ -692,7 +692,7 @@
 				continue;
 
 			if (isCustomFolder) {
-           		// found a window with poses, ask for its path
+				// found a window with poses, ask for its path
 				msg.MakeEmpty();
 				msg.what = B_GET_PROPERTY;
 				msg.AddSpecifier(&quot;Path&quot;);
@@ -702,7 +702,7 @@
 				reply.MakeEmpty();
 				tracker.SendMessage(&amp;msg, &amp;reply);
 
-           		// go on with the next if this din't have a path
+				// go on with the next if this din't have a path
 				if (reply.what == B_MESSAGE_NOT_UNDERSTOOD)
 					continue;
 
@@ -742,13 +742,13 @@
 		BFile file(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
 
 		BPoint point = Window()-&gt;Frame().LeftTop();
-		if (fSettings.ReplacePoint(&quot;pos&quot;, point)!=B_OK)
+		if (fSettings.ReplacePoint(&quot;pos&quot;, point) != B_OK)
 			fSettings.AddPoint(&quot;pos&quot;, point);
 
 		entry_ref ref;
 		BEntry entry;
 		BPath path;
-		
+
 		fPanel-&gt;GetPanelDirectory(&amp;ref);
 		entry.SetTo(&amp;ref);
 		entry.GetPath(&amp;path);
@@ -803,7 +803,7 @@
 	if (fSettings.FindString(&quot;folderpaneldir&quot;, &amp;string) == B_OK)
 		fFolderPanel-&gt;SetPanelDirectory(string.String());
 
-	int32 index = 0;	
+	int32 index = 0;
 	while (fSettings.FindString(&quot;recentfolder&quot;, index, &amp;string) == B_OK) {
 		if (index == 0)
 			fWorkspaceMenu-&gt;AddSeparatorItem();
@@ -812,9 +812,9 @@
 		int32 i = AddPath(path);
 		BString s;
 		s &lt;&lt; &quot;Folder: &quot; &lt;&lt; path.Leaf();
-		BMenuItem *item = new BMenuItem(s.String(), 
+		BMenuItem *item = new BMenuItem(s.String(),
 			new BMessage(kMsgFolderSelected));
-		fWorkspaceMenu-&gt;AddItem(item, -i-1+6);
+		fWorkspaceMenu-&gt;AddItem(item, -i - 1 + 6);
 		index++;
 	}
 	fWorkspaceMenu-&gt;SetTargetForItems(this);
@@ -866,10 +866,10 @@
 	if (index &gt;= 0) {
 		BBitmap *bitmap = GetImage(index)-&gt;GetBitmap();
 		if (bitmap) {
-			BackgroundImage::BackgroundImageInfo *info = 
-				new BackgroundImage::BackgroundImageInfo(0, index, 
-					FindPlacementMode(), BPoint(atoi(fXPlacementText-&gt;Text()), 
-					atoi(fYPlacementText-&gt;Text())), 
+			BackgroundImage::BackgroundImageInfo *info =
+				new BackgroundImage::BackgroundImageInfo(0, index,
+					FindPlacementMode(), BPoint(atoi(fXPlacementText-&gt;Text()),
+						atoi(fYPlacementText-&gt;Text())),
 					fIconLabelBackground-&gt;Value() == B_CONTROL_ON, 0, 0);
 			if (info-&gt;fMode == BackgroundImage::kAtOffset) {
 				fPreView-&gt;SetEnabled(true);
@@ -891,7 +891,7 @@
 
 BackgroundImage::Mode
 BackgroundsView::FindPlacementMode()
-{	
+{
 	BackgroundImage::Mode mode = BackgroundImage::kAtOffset;
 
 	if (fPlacementMenu-&gt;FindItem(kMsgCenterPlacement)-&gt;IsMarked())
@@ -910,7 +910,7 @@
 #ifndef __HAIKU__
 inline bool operator!=(const rgb_color&amp; x, const rgb_color&amp; y)
 {
-	return (x.red!=y.red || x.blue!=y.blue || x.green!=y.green);
+	return (x.red != y.red || x.blue != y.blue || x.green != y.green);
 }
 #endif
 
@@ -923,14 +923,14 @@
 		&amp;&amp; fPicker-&gt;ValueAsColor() != BScreen().DesktopColor()) {
 		hasChanged = true;
 	} else if (fCurrentInfo) {
-		if ((fIconLabelBackground-&gt;Value() == B_CONTROL_ON) ^ 
-				fCurrentInfo-&gt;fEraseTextWidgetBackground) {
+		if ((fIconLabelBackground-&gt;Value() == B_CONTROL_ON) ^
+			fCurrentInfo-&gt;fEraseTextWidgetBackground) {
 			hasChanged = true;
 		} else if (FindPlacementMode() != fCurrentInfo-&gt;fMode) {
 			hasChanged = true;
-		} else if (fCurrentInfo-&gt;fImageIndex != 
-				((BGImageMenuItem*)fImageMenu-&gt;FindMarked())-&gt;ImageIndex()) {
-			hasChanged = true; 
+		} else if (fCurrentInfo-&gt;fImageIndex !=
+			((BGImageMenuItem*)fImageMenu-&gt;FindMarked())-&gt;ImageIndex()) {
+			hasChanged = true;
 		} else if (fCurrent-&gt;IsDesktop()
 			&amp;&amp; ((fCurrentInfo-&gt;fWorkspace != B_ALL_WORKSPACES)
 				^ (fWorkspaceMenu-&gt;FindItem(kMsgCurrentWorkspace)-&gt;IsMarked()))) {
@@ -956,7 +956,7 @@
 }
 
 
-void 
+void
 BackgroundsView::RefsReceived(BMessage *msg)
 {
 	entry_ref ref;
@@ -964,7 +964,7 @@
 	BMimeType imageType(&quot;image&quot;);
 	BPath desktopPath;
 	find_directory(B_DESKTOP_DIRECTORY, &amp;desktopPath);
-	
+
 	while (msg-&gt;FindRef(&quot;refs&quot;, i++, &amp;ref) == B_OK) {
 		BPath path;
 		BEntry entry(&amp;ref, true);
@@ -987,12 +987,12 @@
 				item = FindImageItem(index);
 				fLastImageIndex = index;
 			} else {
-				const char* name = GetImage(-index-1)-&gt;GetName();
-				item = new BGImageMenuItem(name, -index-1, 
+				const char* name = GetImage(-index - 1)-&gt;GetName();
+				item = new BGImageMenuItem(name, -index - 1,
 					new BMessage(kMsgImageSelected));
 				AddItem(item);
 				item-&gt;SetTarget(this);
-				fLastImageIndex = -index-1;
+				fLastImageIndex = -index - 1;
 			}
 
 			item-&gt;SetMarked(true);
@@ -1014,9 +1014,9 @@
 				BString s;
 				s &lt;&lt; &quot;Folder: &quot; &lt;&lt; path.Leaf();
 				item = new BMenuItem(s.String(), new BMessage(kMsgFolderSelected));
-				fWorkspaceMenu-&gt;AddItem(item, -index-1+6);
+				fWorkspaceMenu-&gt;AddItem(item, -index - 1 + 6);
 				item-&gt;SetTarget(this);
-				fLastWorkspaceIndex = -index-1 + 6;
+				fLastWorkspaceIndex = -index - 1 + 6;
 			}
 
 			item-&gt;SetMarked(true);
@@ -1031,7 +1031,7 @@
 {
 	int32 count = fPathList.CountItems();
 	int32 index = 0;
-	for(; index &lt; count; index++) {
+	for (; index &lt; count; index++) {
 		BPath *p = fPathList.ItemAt(index);
 		int c = BString(p-&gt;Path()).ICompare(path.Path());
 		if (c == 0)
@@ -1041,7 +1041,7 @@
 			break;
 	}
 	fPathList.AddItem(new BPath(path), index);
-	return -index-1;	
+	return -index - 1;
 }
 
 
@@ -1050,14 +1050,14 @@
 {
 	int32 count = fImageList.CountItems();
 	int32 index = 0;
-	for(; index &lt; count; index++) {
+	for (; index &lt; count; index++) {
 		Image *image = fImageList.ItemAt(index);
 		if (image-&gt;GetPath() == path)
 			return index;
 	}
 
 	fImageList.AddItem(new Image(path));
-	return -index-1;	
+	return -index - 1;
 }
 
 
@@ -1147,7 +1147,7 @@
 	if (IsEnabled() &amp;&amp; Bounds().Contains(point)) {
 		uint32 buttons;
 		GetMouse(&amp;point, &amp;buttons);
-	 	if(buttons &amp; B_PRIMARY_MOUSE_BUTTON) {
+		if (buttons &amp; B_PRIMARY_MOUSE_BUTTON) {
 			fOldPoint = point;
 			SetTracking(true);
 			BScreen().GetMode(&amp;mode);
@@ -1171,15 +1171,15 @@
 void
 PreView::MouseMoved(BPoint point, uint32 transit, const BMessage *message)
 {
-	if (IsEnabled()) 
+	if (IsEnabled())
 		SetViewCursor(&amp;fMoveHandCursor);
 	else
 		SetViewCursor(B_CURSOR_SYSTEM_DEFAULT);
 
 	if (IsTracking()) {
 		float x, y;
-		x = fPoint.x + (point.x - fOldPoint.x)/ x_ratio;
-		y = fPoint.y + (point.y - fOldPoint.y)/ y_ratio;
+		x = fPoint.x + (point.x - fOldPoint.x) / x_ratio;
+		y = fPoint.y + (point.y - fOldPoint.y) / y_ratio;
 		bool min, max, mustSend = false;
 		min = (x &gt; -fImageBounds.Width());
 		max = (x &lt; mode.virtual_width);
@@ -1198,7 +1198,7 @@
 				fOldPoint.x = point.x - (x - fPoint.x) * x_ratio;
 				mustSend = true;
 			}
-		}				
+		}
 
 		min = (y &gt; -fImageBounds.Height());
 		max = (y &lt; mode.virtual_height);
@@ -1245,42 +1245,42 @@
 	rgb_color color = HighColor();
 
 	SetHighColor(LowColor());
-	FillRect(BRect(9,19,141,127));
+	FillRect(BRect(9, 19, 141, 127));
 
-	if (fIsDesktop) {				
+	if (fIsDesktop) {
 		BPoint points[] = {
-			BPoint(11,19), BPoint(139,19), BPoint(141,21), 
-			BPoint(141,119), BPoint(139,121), BPoint(118,121), 
-			BPoint(118,126), BPoint(117,127), BPoint(33,127),
-			BPoint(32,126), BPoint(32,121),BPoint(11,121),
-			BPoint(9,119),BPoint(9,21),BPoint(11,19)
+			BPoint(11, 19), BPoint(139, 19), BPoint(141, 21),
+			BPoint(141, 119), BPoint(139, 121), BPoint(118, 121),
+			BPoint(118, 126), BPoint(117, 127), BPoint(33, 127),
+			BPoint(32, 126), BPoint(32, 121), BPoint(11, 121),
+			BPoint(9, 119), BPoint(9, 21), BPoint(11, 19)
 		};
-		SetHighColor(184,184,184);
+		SetHighColor(184, 184, 184);
 		FillPolygon(points, 15);
-		SetHighColor(96,96,96);
+		SetHighColor(96, 96, 96);
 		StrokePolygon(points, 15);
-		FillRect(BRect(107,121,111,123));
-		SetHighColor(0,0,0);
-		StrokeRect(BRect(14,24,136,116));
-		SetHighColor(0,255,0);
-		FillRect(BRect(101,122,103,123));
+		FillRect(BRect(107, 121, 111, 123));
+		SetHighColor(0, 0, 0);
+		StrokeRect(BRect(14, 24, 136, 116));
+		SetHighColor(0, 255, 0);
+		FillRect(BRect(101, 122, 103, 123));
 	} else {
-		SetHighColor(152,152,152);
-		StrokeLine(BPoint(11,13), BPoint(67,13));
-		StrokeLine(BPoint(67,21));
-		StrokeLine(BPoint(139,21));
-		StrokeLine(BPoint(139,119));
-		StrokeLine(BPoint(11,119));
-		StrokeLine(BPoint(11,13));
-		StrokeRect(BRect(14,24,136,116));
-		SetHighColor(255,203,0);
-		FillRect(BRect(12,14,66,21));
-		SetHighColor(240,240,240);
-		StrokeRect(BRect(12,22,137,117));
-		StrokeLine(BPoint(138,22), BPoint(138,22));
-		StrokeLine(BPoint(12,118), BPoint(12,118));
-		SetHighColor(200,200,200);
-		StrokeRect(BRect(13,23,138,118));
+		SetHighColor(152, 152, 152);
+		StrokeLine(BPoint(11, 13), BPoint(67, 13));
+		StrokeLine(BPoint(67, 21));
+		StrokeLine(BPoint(139, 21));
+		StrokeLine(BPoint(139, 119));
+		StrokeLine(BPoint(11, 119));
+		StrokeLine(BPoint(11, 13));
+		StrokeRect(BRect(14, 24, 136, 116));
+		SetHighColor(255, 203, 0);
+		FillRect(BRect(12, 14, 66, 21));
+		SetHighColor(240, 240, 240);
+		StrokeRect(BRect(12, 22, 137, 117));
+		StrokeLine(BPoint(138, 22), BPoint(138, 22));
+		StrokeLine(BPoint(12, 118), BPoint(12, 118));

[... truncated: 162 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000933.html">[Haiku-commits] r20242 - haiku/trunk/data/settings/kernel/drivers
</A></li>
	<LI>Next message: <A HREF="000936.html">[Haiku-commits] r20244 - in haiku/trunk: headers/private/kernel	src/system/kernel/arch/generic src/system/kernel/arch/x86	src/system/kernel/vm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#934">[ date ]</a>
              <a href="thread.html#934">[ thread ]</a>
              <a href="subject.html#934">[ subject ]</a>
              <a href="author.html#934">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
