<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30810 - in haiku/vendor/mesa/current/src: main	math shader shader/slang swrast
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30810%20-%20in%20haiku/vendor/mesa/current/src%3A%20main%0A%09math%20shader%20shader/slang%20swrast&In-Reply-To=%3C200905211040.n4LAe1ao011091%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016865.html">
   <LINK REL="Next"  HREF="016867.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30810 - in haiku/vendor/mesa/current/src: main	math shader shader/slang swrast</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30810%20-%20in%20haiku/vendor/mesa/current/src%3A%20main%0A%09math%20shader%20shader/slang%20swrast&In-Reply-To=%3C200905211040.n4LAe1ao011091%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30810 - in haiku/vendor/mesa/current/src: main	math shader shader/slang swrast">korli at mail.berlios.de
       </A><BR>
    <I>Thu May 21 12:40:01 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="016865.html">[Haiku-commits] r30809 - haiku/trunk/build/jam
</A></li>
        <LI>Next message: <A HREF="016867.html">[Haiku-commits] r30811 - haiku/vendor/mesa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16866">[ date ]</a>
              <a href="thread.html#16866">[ thread ]</a>
              <a href="subject.html#16866">[ subject ]</a>
              <a href="author.html#16866">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2009-05-21 12:39:58 +0200 (Thu, 21 May 2009)
New Revision: 30810
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30810&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30810&amp;view=rev</A>

Modified:
   haiku/vendor/mesa/current/src/main/attrib.c
   haiku/vendor/mesa/current/src/main/drawpix.c
   haiku/vendor/mesa/current/src/main/ffvertex_prog.c
   haiku/vendor/mesa/current/src/main/glheader.h
   haiku/vendor/mesa/current/src/main/hash.c
   haiku/vendor/mesa/current/src/main/light.c
   haiku/vendor/mesa/current/src/main/readpix.c
   haiku/vendor/mesa/current/src/main/teximage.c
   haiku/vendor/mesa/current/src/main/texparam.c
   haiku/vendor/mesa/current/src/main/texstate.c
   haiku/vendor/mesa/current/src/main/version.h
   haiku/vendor/mesa/current/src/math/m_matrix.c
   haiku/vendor/mesa/current/src/shader/arbprogparse.c
   haiku/vendor/mesa/current/src/shader/prog_execute.c
   haiku/vendor/mesa/current/src/shader/prog_parameter.c
   haiku/vendor/mesa/current/src/shader/program.c
   haiku/vendor/mesa/current/src/shader/slang/slang_builtin.c
   haiku/vendor/mesa/current/src/shader/slang/slang_link.c
   haiku/vendor/mesa/current/src/swrast/s_points.c
   haiku/vendor/mesa/current/src/swrast/s_span.c
   haiku/vendor/mesa/current/src/swrast/s_texfilter.c
Log:
updating mesa vendor with version 7.4.2


Modified: haiku/vendor/mesa/current/src/main/attrib.c
===================================================================
--- haiku/vendor/mesa/current/src/main/attrib.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/attrib.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -1176,7 +1176,7 @@
 
                /* restore clip planes */
                for (i = 0; i &lt; MAX_CLIP_PLANES; i++) {
-                  const GLuint mask = 1 &lt;&lt; 1;
+                  const GLuint mask = 1 &lt;&lt; i;
                   const GLfloat *eyePlane = xform-&gt;EyeUserPlane[i];
                   COPY_4V(ctx-&gt;Transform.EyeUserPlane[i], eyePlane);
                   if (xform-&gt;ClipPlanesEnabled &amp; mask) {

Modified: haiku/vendor/mesa/current/src/main/drawpix.c
===================================================================
--- haiku/vendor/mesa/current/src/main/drawpix.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/drawpix.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -77,28 +77,30 @@
    }
 
    if (ctx-&gt;RenderMode == GL_RENDER) {
-      /* Round, to satisfy conformance tests (matches SGI's OpenGL) */
-      GLint x = IROUND(ctx-&gt;Current.RasterPos[0]);
-      GLint y = IROUND(ctx-&gt;Current.RasterPos[1]);
+      if (width &gt; 0 &amp;&amp; height &gt; 0) {
+         /* Round, to satisfy conformance tests (matches SGI's OpenGL) */
+         GLint x = IROUND(ctx-&gt;Current.RasterPos[0]);
+         GLint y = IROUND(ctx-&gt;Current.RasterPos[1]);
 
-      if (ctx-&gt;Unpack.BufferObj-&gt;Name) {
-         /* unpack from PBO */
-         if (!_mesa_validate_pbo_access(2, &amp;ctx-&gt;Unpack, width, height, 1,
-                                        format, type, pixels)) {
-            _mesa_error(ctx, GL_INVALID_OPERATION,
-                        &quot;glDrawPixels(invalid PBO access)&quot;);
-            return;
+         if (ctx-&gt;Unpack.BufferObj-&gt;Name) {
+            /* unpack from PBO */
+            if (!_mesa_validate_pbo_access(2, &amp;ctx-&gt;Unpack, width, height, 1,
+                                           format, type, pixels)) {
+               _mesa_error(ctx, GL_INVALID_OPERATION,
+                           &quot;glDrawPixels(invalid PBO access)&quot;);
+               return;
+            }
+            if (ctx-&gt;Unpack.BufferObj-&gt;Pointer) {
+               /* buffer is mapped - that's an error */
+               _mesa_error(ctx, GL_INVALID_OPERATION,
+                           &quot;glDrawPixels(PBO is mapped)&quot;);
+               return;
+            }
          }
-         if (ctx-&gt;Unpack.BufferObj-&gt;Pointer) {
-            /* buffer is mapped - that's an error */
-            _mesa_error(ctx, GL_INVALID_OPERATION,
-                        &quot;glDrawPixels(PBO is mapped)&quot;);
-            return;
-         }
+
+         ctx-&gt;Driver.DrawPixels(ctx, x, y, width, height, format, type,
+                                &amp;ctx-&gt;Unpack, pixels);
       }
-
-      ctx-&gt;Driver.DrawPixels(ctx, x, y, width, height, format, type,
-			     &amp;ctx-&gt;Unpack, pixels);
    }
    else if (ctx-&gt;RenderMode == GL_FEEDBACK) {
       /* Feedback the current raster pos info */
@@ -159,10 +161,12 @@
 
    if (ctx-&gt;RenderMode == GL_RENDER) {
       /* Round to satisfy conformance tests (matches SGI's OpenGL) */
-      GLint destx = IROUND(ctx-&gt;Current.RasterPos[0]);
-      GLint desty = IROUND(ctx-&gt;Current.RasterPos[1]);
-      ctx-&gt;Driver.CopyPixels( ctx, srcx, srcy, width, height, destx, desty,
-			      type );
+      if (width &gt; 0 &amp;&amp; height &gt; 0) {
+         GLint destx = IROUND(ctx-&gt;Current.RasterPos[0]);
+         GLint desty = IROUND(ctx-&gt;Current.RasterPos[1]);
+         ctx-&gt;Driver.CopyPixels( ctx, srcx, srcy, width, height, destx, desty,
+                                 type );
+      }
    }
    else if (ctx-&gt;RenderMode == GL_FEEDBACK) {
       FLUSH_CURRENT( ctx, 0 );

Modified: haiku/vendor/mesa/current/src/main/ffvertex_prog.c
===================================================================
--- haiku/vendor/mesa/current/src/main/ffvertex_prog.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/ffvertex_prog.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -1104,6 +1104,9 @@
 
    if (twoside) {
       if (!p-&gt;state-&gt;material_shininess_is_zero) {
+         /* Note that we negate the back-face specular exponent here.
+          * The negation will be un-done later in the back-face code below.
+          */
          struct ureg shininess = get_material(p, 1, STATE_SHININESS);
          emit_op1(p, OPCODE_MOV, dots, WRITEMASK_Z, 
                   negate(swizzle1(shininess,X)));
@@ -1309,6 +1312,11 @@
 	       mask1 = 0;
 	    }
 
+            /* For the back face we need to negate the X and Y component
+             * dot products.  dots.Z has the negated back-face specular
+             * exponent.  We swizzle that into the W position.  This
+             * negation makes the back-face specular term positive again.
+             */
             dots = negate(swizzle(dots,X,Y,W,Z));
 
 	    if (!is_undef(att)) {
@@ -1327,8 +1335,10 @@
 
 	    emit_op3(p, OPCODE_MAD, res0, mask0, swizzle1(lit,Y), diffuse, _bfc0);
 	    emit_op3(p, OPCODE_MAD, res1, mask1, swizzle1(lit,Z), specular, _bfc1);
-            /* restore negate flag for next lighting */
-            dots = negate(dots);
+            /* restore dots to its original state for subsequent lights
+             * by negating and swizzling again.
+             */
+            dots = negate(swizzle(dots,X,Y,W,Z));
 
 	    release_temp(p, ambient);
 	    release_temp(p, diffuse);

Modified: haiku/vendor/mesa/current/src/main/glheader.h
===================================================================
--- haiku/vendor/mesa/current/src/main/glheader.h	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/glheader.h	2009-05-21 10:39:58 UTC (rev 30810)
@@ -145,7 +145,10 @@
 #if defined(__linux__)
 #include &lt;byteswap.h&gt;
 #define CPU_TO_LE32( x )	bswap_32( x )
-#else /*__linux__*/
+#elif defined(__APPLE__)
+#include &lt;CoreFoundation/CFByteOrder.h&gt;
+#define CPU_TO_LE32( x )	CFSwapInt32HostToLittle( x )
+#else /*__linux__ __APPLE__*/
 #include &lt;sys/endian.h&gt;
 #define CPU_TO_LE32( x )	bswap32( x )
 #endif /*__linux__*/

Modified: haiku/vendor/mesa/current/src/main/hash.c
===================================================================
--- haiku/vendor/mesa/current/src/main/hash.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/hash.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -63,6 +63,7 @@
    struct HashEntry *Table[TABLE_SIZE];  /**&lt; the lookup table */
    GLuint MaxKey;                        /**&lt; highest key inserted so far */
    _glthread_Mutex Mutex;                /**&lt; mutual exclusion lock */
+   _glthread_Mutex WalkMutex;            /**&lt; for _mesa_HashWalk() */
    GLboolean InDeleteAll;                /**&lt; Debug check */
 };
 
@@ -79,6 +80,7 @@
    struct _mesa_HashTable *table = CALLOC_STRUCT(_mesa_HashTable);
    if (table) {
       _glthread_INIT_MUTEX(table-&gt;Mutex);
+      _glthread_INIT_MUTEX(table-&gt;WalkMutex);
    }
    return table;
 }
@@ -111,6 +113,7 @@
       }
    }
    _glthread_DESTROY_MUTEX(table-&gt;Mutex);
+   _glthread_DESTROY_MUTEX(table-&gt;WalkMutex);
    _mesa_free(table);
 }
 
@@ -285,6 +288,11 @@
 
 /**
  * Walk over all entries in a hash table, calling callback function for each.
+ * Note: we use a separate mutex in this function to avoid a recursive
+ * locking deadlock (in case the callback calls _mesa_HashRemove()) and to
+ * prevent multiple threads/contexts from getting tangled up.
+ * A lock-less version of this function could be used when the table will
+ * not be modified.
  * \param table  the hash table to walk
  * \param callback  the callback function
  * \param userData  arbitrary pointer to pass along to the callback
@@ -300,14 +308,16 @@
    GLuint pos;
    ASSERT(table);
    ASSERT(callback);
-   _glthread_LOCK_MUTEX(table2-&gt;Mutex);
+   _glthread_LOCK_MUTEX(table2-&gt;WalkMutex);
    for (pos = 0; pos &lt; TABLE_SIZE; pos++) {
-      struct HashEntry *entry;
-      for (entry = table-&gt;Table[pos]; entry; entry = entry-&gt;Next) {
+      struct HashEntry *entry, *next;
+      for (entry = table-&gt;Table[pos]; entry; entry = next) {
+         /* save 'next' pointer now in case the callback deletes the entry */
+         next = entry-&gt;Next;
          callback(entry-&gt;Key, entry-&gt;Data, userData);
       }
    }
-   _glthread_UNLOCK_MUTEX(table2-&gt;Mutex);
+   _glthread_UNLOCK_MUTEX(table2-&gt;WalkMutex);
 }
 
 

Modified: haiku/vendor/mesa/current/src/main/light.c
===================================================================
--- haiku/vendor/mesa/current/src/main/light.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/light.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -209,7 +209,6 @@
 	 _math_matrix_analyse(ctx-&gt;ModelviewMatrixStack.Top);
       }
       TRANSFORM_DIRECTION(temp, params, ctx-&gt;ModelviewMatrixStack.Top-&gt;m);
-      NORMALIZE_3FV(temp);
       params = temp;
       break;
    case GL_SPOT_EXPONENT:
@@ -1137,12 +1136,18 @@
       }
 
       if (light-&gt;_Flags &amp; LIGHT_SPOT) {
+         /* Note: we normalize the spot direction now */
+
 	 if (ctx-&gt;_NeedEyeCoords) {
 	    COPY_3V( light-&gt;_NormDirection, light-&gt;EyeDirection );
+            NORMALIZE_3FV( light-&gt;_NormDirection );
 	 }
          else {
+            GLfloat spotDir[3];
+            COPY_3V(spotDir, light-&gt;EyeDirection);
+            NORMALIZE_3FV(spotDir);
 	    TRANSFORM_NORMAL( light-&gt;_NormDirection,
-			      light-&gt;EyeDirection,
+			      spotDir,
 			      ctx-&gt;ModelviewMatrixStack.Top-&gt;m);
 	 }
 

Modified: haiku/vendor/mesa/current/src/main/readpix.c
===================================================================
--- haiku/vendor/mesa/current/src/main/readpix.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/readpix.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -170,6 +170,9 @@
       return;
    }
 
+   if (width == 0 || height == 0)
+      return; /* nothing to do */
+
    if (ctx-&gt;Pack.BufferObj-&gt;Name) {
       if (!_mesa_validate_pbo_access(2, &amp;ctx-&gt;Pack, width, height, 1,
                                      format, type, pixels)) {

Modified: haiku/vendor/mesa/current/src/main/teximage.c
===================================================================
--- haiku/vendor/mesa/current/src/main/teximage.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/teximage.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -50,6 +50,17 @@
 
 
 /**
+ * State changes which we care about for glCopyTex[Sub]Image() calls.
+ * In particular, we care about pixel transfer state and buffer state
+ * (such as glReadBuffer to make sure we read from the right renderbuffer).
+ */
+#define NEW_COPY_TEX_STATE (_IMAGE_NEW_TRANSFER_STATE | \
+                            _NEW_BUFFERS | \
+                            _NEW_PIXEL)
+
+
+
+/**
  * We allocate texture memory on 512-byte boundaries so we can use MMX/SSE
  * elsewhere.
  */
@@ -2918,7 +2929,7 @@
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx-&gt;NewState &amp; _IMAGE_NEW_TRANSFER_STATE)
+   if (ctx-&gt;NewState &amp; NEW_COPY_TEX_STATE)
       _mesa_update_state(ctx);
 
 #if FEATURE_convolve
@@ -2983,7 +2994,7 @@
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx-&gt;NewState &amp; _IMAGE_NEW_TRANSFER_STATE)
+   if (ctx-&gt;NewState &amp; NEW_COPY_TEX_STATE)
       _mesa_update_state(ctx);
 
 #if FEATURE_convolve
@@ -3051,7 +3062,7 @@
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx-&gt;NewState &amp; _IMAGE_NEW_TRANSFER_STATE)
+   if (ctx-&gt;NewState &amp; NEW_COPY_TEX_STATE)
       _mesa_update_state(ctx);
 
    if (copytexsubimage_error_check1(ctx, 1, target, level))
@@ -3106,7 +3117,7 @@
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx-&gt;NewState &amp; _IMAGE_NEW_TRANSFER_STATE)
+   if (ctx-&gt;NewState &amp; NEW_COPY_TEX_STATE)
       _mesa_update_state(ctx);
 
    if (copytexsubimage_error_check1(ctx, 2, target, level))
@@ -3161,7 +3172,7 @@
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END_AND_FLUSH(ctx);
 
-   if (ctx-&gt;NewState &amp; _IMAGE_NEW_TRANSFER_STATE)
+   if (ctx-&gt;NewState &amp; NEW_COPY_TEX_STATE)
       _mesa_update_state(ctx);
 
    if (copytexsubimage_error_check1(ctx, 3, target, level))

Modified: haiku/vendor/mesa/current/src/main/texparam.c
===================================================================
--- haiku/vendor/mesa/current/src/main/texparam.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/texparam.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -139,8 +139,11 @@
 }
 
 
-/** Set an integer-valued texture parameter */
-static void
+/**
+ * Set an integer-valued texture parameter
+ * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
+ */
+static GLboolean
 set_tex_parameteri(GLcontext *ctx,
                    struct gl_texture_object *texObj,
                    GLenum pname, const GLint *params)
@@ -148,13 +151,13 @@
    switch (pname) {
    case GL_TEXTURE_MIN_FILTER:
       if (texObj-&gt;MinFilter == params[0])
-         return;
+         return GL_FALSE;
       switch (params[0]) {
       case GL_NEAREST:
       case GL_LINEAR:
          flush(ctx, texObj);
          texObj-&gt;MinFilter = params[0];
-         return;
+         return GL_TRUE;
       case GL_NEAREST_MIPMAP_NEAREST:
       case GL_LINEAR_MIPMAP_NEAREST:
       case GL_NEAREST_MIPMAP_LINEAR:
@@ -162,77 +165,80 @@
          if (texObj-&gt;Target != GL_TEXTURE_RECTANGLE_NV) {
             flush(ctx, texObj);
             texObj-&gt;MinFilter = params[0];
-            return;
+            return GL_TRUE;
          }
          /* fall-through */
       default:
          _mesa_error( ctx, GL_INVALID_VALUE, &quot;glTexParameter(param)&quot; );
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_MAG_FILTER:
       if (texObj-&gt;MagFilter == params[0])
-         return;
+         return GL_FALSE;
       switch (params[0]) {
       case GL_NEAREST:
       case GL_LINEAR:
          flush(ctx, texObj);
          texObj-&gt;MagFilter = params[0];
-         return;
+         return GL_TRUE;
       default:
          _mesa_error( ctx, GL_INVALID_VALUE, &quot;glTexParameter(param)&quot; );
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_S:
       if (texObj-&gt;WrapS == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj-&gt;Target, params[0])) {
          flush(ctx, texObj);
          texObj-&gt;WrapS = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_T:
       if (texObj-&gt;WrapT == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj-&gt;Target, params[0])) {
          flush(ctx, texObj);
          texObj-&gt;WrapT = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_WRAP_R:
       if (texObj-&gt;WrapR == params[0])
-         return;
+         return GL_FALSE;
       if (validate_texture_wrap_mode(ctx, texObj-&gt;Target, params[0])) {
          flush(ctx, texObj);
          texObj-&gt;WrapR = params[0];
+         return GL_TRUE;
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_BASE_LEVEL:
       if (texObj-&gt;BaseLevel == params[0])
-         return;
+         return GL_FALSE;
       if (params[0] &lt; 0 ||
           (texObj-&gt;Target == GL_TEXTURE_RECTANGLE_ARB &amp;&amp; params[0] != 0)) {
          _mesa_error(ctx, GL_INVALID_VALUE, &quot;glTexParameter(param)&quot;);
-         return;
+         return GL_FALSE;
       }
       flush(ctx, texObj);
       texObj-&gt;BaseLevel = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_LEVEL:
       if (texObj-&gt;MaxLevel == params[0])
-         return;
+         return GL_FALSE;
       if (params[0] &lt; 0 || texObj-&gt;Target == GL_TEXTURE_RECTANGLE_ARB) {
          _mesa_error(ctx, GL_INVALID_OPERATION, &quot;glTexParameter(param)&quot;);
-         return;
+         return GL_FALSE;
       }
       flush(ctx, texObj);
       texObj-&gt;MaxLevel = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_COMPARE_SGIX:
       if (ctx-&gt;Extensions.SGIX_shadow) {
@@ -243,7 +249,7 @@
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(pname=GL_TEXTURE_COMPARE_SGIX)&quot;);
       }
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_COMPARE_OPERATOR_SGIX:
       if (ctx-&gt;Extensions.SGIX_shadow &amp;&amp;
@@ -256,20 +262,22 @@
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(GL_TEXTURE_COMPARE_OPERATOR_SGIX)&quot;);
       }
-      return;
+      return GL_TRUE;
 
    case GL_GENERATE_MIPMAP_SGIS:
       if (ctx-&gt;Extensions.SGIS_generate_mipmap) {
          if (texObj-&gt;GenerateMipmap != params[0]) {
             flush(ctx, texObj);
             texObj-&gt;GenerateMipmap = params[0] ? GL_TRUE : GL_FALSE;
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(pname=GL_GENERATE_MIPMAP_SGIS)&quot;);
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_MODE_ARB:
       if (ctx-&gt;Extensions.ARB_shadow &amp;&amp;
@@ -278,24 +286,26 @@
          if (texObj-&gt;CompareMode != params[0]) {
             flush(ctx, texObj);
             texObj-&gt;CompareMode = params[0];
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(GL_TEXTURE_COMPARE_MODE_ARB)&quot;);
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_FUNC_ARB:
       if (ctx-&gt;Extensions.ARB_shadow) {
          if (texObj-&gt;CompareFunc == params[0])
-            return;
+            return GL_FALSE;
          switch (params[0]) {
          case GL_LEQUAL:
          case GL_GEQUAL:
             flush(ctx, texObj);
             texObj-&gt;CompareFunc = params[0];
-            return;
+            return GL_TRUE;
          case GL_EQUAL:
          case GL_NOTEQUAL:
          case GL_LESS:
@@ -305,7 +315,7 @@
             if (ctx-&gt;Extensions.EXT_shadow_funcs) {
                flush(ctx, texObj);
                texObj-&gt;CompareFunc = params[0];
-               return;
+               return GL_TRUE;
             }
             /* fall-through */
          default:
@@ -316,7 +326,7 @@
       else {
          _mesa_error(ctx, GL_INVALID_ENUM, &quot;glTexParameter(param)&quot;);
       }
-      return;
+      return GL_FALSE;
 
    case GL_DEPTH_TEXTURE_MODE_ARB:
       if (ctx-&gt;Extensions.ARB_depth_texture &amp;&amp;
@@ -326,13 +336,14 @@
          if (texObj-&gt;DepthMode != params[0]) {
             flush(ctx, texObj);
             texObj-&gt;DepthMode = params[0];
+            return GL_TRUE;
          }
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(GL_DEPTH_TEXTURE_MODE_ARB)&quot;);
       }
-      return;
+      return GL_FALSE;
 
 #ifdef FEATURE_OES_draw_texture
    case GL_TEXTURE_CROP_RECT_OES:
@@ -340,17 +351,21 @@
       texObj-&gt;CropRect[1] = params[1];
       texObj-&gt;CropRect[2] = params[2];
       texObj-&gt;CropRect[3] = params[3];
-      break;
+      return GL_TRUE;
 #endif
 
    default:
       _mesa_error(ctx, GL_INVALID_ENUM, &quot;glTexParameter(pname=0x%x)&quot;, pname);
    }
+   return GL_FALSE;
 }
 
 
-/** Set a float-valued texture parameter */
-static void
+/**
+ * Set a float-valued texture parameter
+ * \return GL_TRUE if legal AND the value changed, GL_FALSE otherwise
+ */
+static GLboolean
 set_tex_parameterf(GLcontext *ctx,
                    struct gl_texture_object *texObj,
                    GLenum pname, const GLfloat *params)
@@ -358,54 +373,56 @@
    switch (pname) {
    case GL_TEXTURE_MIN_LOD:
       if (texObj-&gt;MinLod == params[0])
-         return;
+         return GL_FALSE;
       flush(ctx, texObj);
       texObj-&gt;MinLod = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_LOD:
       if (texObj-&gt;MaxLod == params[0])
-         return;
+         return GL_FALSE;
       flush(ctx, texObj);
       texObj-&gt;MaxLod = params[0];
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_PRIORITY:
       flush(ctx, texObj);
       texObj-&gt;Priority = CLAMP(params[0], 0.0F, 1.0F);
-      return;
+      return GL_TRUE;
 
    case GL_TEXTURE_MAX_ANISOTROPY_EXT:
       if (ctx-&gt;Extensions.EXT_texture_filter_anisotropic) {
          if (texObj-&gt;MaxAnisotropy == params[0])
-            return;
+            return GL_FALSE;
          if (params[0] &lt; 1.0) {
             _mesa_error(ctx, GL_INVALID_VALUE, &quot;glTexParameter(param)&quot; );
-            return;
+            return GL_FALSE;
          }
          flush(ctx, texObj);
          /* clamp to max, that's what NVIDIA does */
          texObj-&gt;MaxAnisotropy = MIN2(params[0],
                                       ctx-&gt;Const.MaxTextureMaxAnisotropy);
+         return GL_TRUE;
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(pname=GL_TEXTURE_MAX_ANISOTROPY_EXT)&quot;);
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_COMPARE_FAIL_VALUE_ARB:
       if (ctx-&gt;Extensions.SGIX_shadow_ambient) {
          if (texObj-&gt;ShadowAmbient != params[0]) {
             flush(ctx, texObj);
             texObj-&gt;ShadowAmbient = CLAMP(params[0], 0.0F, 1.0F);
+            return GL_TRUE;
          }
       }
       else {
          _mesa_error(ctx, GL_INVALID_ENUM,
                      &quot;glTexParameter(pname=GL_SHADOW_AMBIENT_SGIX)&quot;);
       }
-      return;
+      return GL_FALSE;
 
    case GL_TEXTURE_LOD_BIAS:
       /* NOTE: this is really part of OpenGL 1.4, not EXT_texture_lod_bias */
@@ -413,7 +430,9 @@
          if (texObj-&gt;LodBias != params[0]) {
             flush(ctx, texObj);
             texObj-&gt;LodBias = params[0];
+            return GL_TRUE;
          }
+         return GL_FALSE;
       }
       break;
 
@@ -427,17 +446,19 @@
       UNCLAMPED_FLOAT_TO_CHAN(texObj-&gt;_BorderChan[GCOMP], params[1]);
       UNCLAMPED_FLOAT_TO_CHAN(texObj-&gt;_BorderChan[BCOMP], params[2]);
       UNCLAMPED_FLOAT_TO_CHAN(texObj-&gt;_BorderChan[ACOMP], params[3]);
-      return;
+      return GL_TRUE;
 
    default:
       _mesa_error(ctx, GL_INVALID_ENUM, &quot;glTexParameter(pname=0x%x)&quot;, pname);
    }
+   return GL_FALSE;
 }
 
 
 void GLAPIENTRY
 _mesa_TexParameterf(GLenum target, GLenum pname, GLfloat param)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -463,15 +484,15 @@
       {
          /* convert float param to int */
          GLint p = (GLint) param;
-         set_tex_parameteri(ctx, texObj, pname, &amp;p);
+         need_update = set_tex_parameteri(ctx, texObj, pname, &amp;p);
       }
-      return;
+      break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameterf(ctx, texObj, pname, &amp;param);
+      need_update = set_tex_parameterf(ctx, texObj, pname, &amp;param);
    }
 
-   if (ctx-&gt;Driver.TexParameter &amp;&amp; ctx-&gt;ErrorValue == GL_NO_ERROR) {
+   if (ctx-&gt;Driver.TexParameter &amp;&amp; need_update) {
       ctx-&gt;Driver.TexParameter(ctx, target, texObj, pname, &amp;param);
    }
 }
@@ -480,6 +501,7 @@
 void GLAPIENTRY
 _mesa_TexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -505,7 +527,7 @@
       {
          /* convert float param to int */
          GLint p = (GLint) params[0];
-         set_tex_parameteri(ctx, texObj, pname, &amp;p);
+         need_update = set_tex_parameteri(ctx, texObj, pname, &amp;p);
       }
       break;
 
@@ -518,17 +540,17 @@
          iparams[1] = (GLint) params[1];
          iparams[2] = (GLint) params[2];
          iparams[3] = (GLint) params[3];
-         set_tex_parameteri(ctx, target, iparams);
+         need_update = set_tex_parameteri(ctx, target, iparams);
       }
       break;
 #endif
 
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameterf(ctx, texObj, pname, params);
+      need_update = set_tex_parameterf(ctx, texObj, pname, params);
    }
 
-   if (ctx-&gt;Driver.TexParameter &amp;&amp; ctx-&gt;ErrorValue == GL_NO_ERROR) {
+   if (ctx-&gt;Driver.TexParameter &amp;&amp; need_update) {
       ctx-&gt;Driver.TexParameter(ctx, target, texObj, pname, params);
    }
 }
@@ -537,6 +559,7 @@
 void GLAPIENTRY
 _mesa_TexParameteri(GLenum target, GLenum pname, GLint param)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -555,15 +578,15 @@
       {
          GLfloat fparam = (GLfloat) param;
          /* convert int param to float */
-         set_tex_parameterf(ctx, texObj, pname, &amp;fparam);
+         need_update = set_tex_parameterf(ctx, texObj, pname, &amp;fparam);
       }
       break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameteri(ctx, texObj, pname, &amp;param);
+      need_update = set_tex_parameteri(ctx, texObj, pname, &amp;param);
    }
 
-   if (ctx-&gt;Driver.TexParameter &amp;&amp; ctx-&gt;ErrorValue == GL_NO_ERROR) {
+   if (ctx-&gt;Driver.TexParameter &amp;&amp; need_update) {
       GLfloat fparam = (GLfloat) param;
       ctx-&gt;Driver.TexParameter(ctx, target, texObj, pname, &amp;fparam);
    }
@@ -573,6 +596,7 @@
 void GLAPIENTRY
 _mesa_TexParameteriv(GLenum target, GLenum pname, const GLint *params)
 {
+   GLboolean need_update;
    struct gl_texture_object *texObj;
    GET_CURRENT_CONTEXT(ctx);
    ASSERT_OUTSIDE_BEGIN_END(ctx);
@@ -590,7 +614,7 @@
          fparams[1] = INT_TO_FLOAT(params[1]);
          fparams[2] = INT_TO_FLOAT(params[2]);
          fparams[3] = INT_TO_FLOAT(params[3]);
-         set_tex_parameterf(ctx, texObj, pname, fparams);
+         need_update = set_tex_parameterf(ctx, texObj, pname, fparams);
       }
       break;
    case GL_TEXTURE_MIN_LOD:
@@ -602,15 +626,15 @@
       {
          /* convert int param to float */
          GLfloat fparam = (GLfloat) params[0];
-         set_tex_parameterf(ctx, texObj, pname, &amp;fparam);
+         need_update = set_tex_parameterf(ctx, texObj, pname, &amp;fparam);
       }
       break;
    default:
       /* this will generate an error if pname is illegal */
-      set_tex_parameteri(ctx, texObj, pname, params);
+      need_update = set_tex_parameteri(ctx, texObj, pname, params);
    }
 
-   if (ctx-&gt;Driver.TexParameter &amp;&amp; ctx-&gt;ErrorValue == GL_NO_ERROR) {
+   if (ctx-&gt;Driver.TexParameter &amp;&amp; need_update) {
       GLfloat fparams[4];
       fparams[0] = INT_TO_FLOAT(params[0]);
       if (pname == GL_TEXTURE_BORDER_COLOR ||

Modified: haiku/vendor/mesa/current/src/main/texstate.c
===================================================================
--- haiku/vendor/mesa/current/src/main/texstate.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/texstate.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -802,6 +802,9 @@
    /* unreference current textures */
    for (u = 0; u &lt; MAX_TEXTURE_IMAGE_UNITS; u++) {
       struct gl_texture_unit *unit = ctx-&gt;Texture.Unit + u;
+      /* The _Current texture could account for another reference */
+      _mesa_reference_texobj(&amp;ctx-&gt;Texture.Unit[u]._Current, NULL);
+
       for (tgt = 0; tgt &lt; NUM_TEXTURE_TARGETS; tgt++) {
          _mesa_reference_texobj(&amp;unit-&gt;CurrentTex[tgt], NULL);
       }

Modified: haiku/vendor/mesa/current/src/main/version.h
===================================================================
--- haiku/vendor/mesa/current/src/main/version.h	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/main/version.h	2009-05-21 10:39:58 UTC (rev 30810)
@@ -1,8 +1,9 @@
 /*
  * Mesa 3-D graphics library
- * Version:  7.4
+ * Version:  7.4.2
  *
  * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
+ * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the &quot;Software&quot;),
@@ -30,8 +31,8 @@
 /* Mesa version */
 #define MESA_MAJOR 7
 #define MESA_MINOR 4
-#define MESA_PATCH 0
-#define MESA_VERSION_STRING &quot;7.4&quot;
+#define MESA_PATCH 2
+#define MESA_VERSION_STRING &quot;7.4.2&quot;
 
 /* To make version comparison easy */
 #define MESA_VERSION(a,b,c) (((a) &lt;&lt; 16) + ((b) &lt;&lt; 8) + (c))

Modified: haiku/vendor/mesa/current/src/math/m_matrix.c
===================================================================
--- haiku/vendor/mesa/current/src/math/m_matrix.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/math/m_matrix.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -1379,11 +1379,10 @@
 
    if (mat-&gt;inv &amp;&amp; (mat-&gt;flags &amp; MAT_DIRTY_INVERSE)) {
       matrix_invert( mat );
+      mat-&gt;flags &amp;= ~MAT_DIRTY_INVERSE;
    }
 
-   mat-&gt;flags &amp;= ~(MAT_DIRTY_FLAGS|
-		   MAT_DIRTY_TYPE|
-		   MAT_DIRTY_INVERSE);
+   mat-&gt;flags &amp;= ~(MAT_DIRTY_FLAGS | MAT_DIRTY_TYPE);
 }
 
 /*@}*/

Modified: haiku/vendor/mesa/current/src/shader/arbprogparse.c
===================================================================
--- haiku/vendor/mesa/current/src/shader/arbprogparse.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/shader/arbprogparse.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -1496,10 +1496,16 @@
    curr = vc_head;
    while (curr) {
       if (curr-&gt;type == vt_attrib) {
-         if (curr-&gt;attrib_is_generic)
-            genericAttrib[ curr-&gt;attrib_binding ] = GL_TRUE;
-         else
+         if (curr-&gt;attrib_is_generic) {
+            GLuint attr = (curr-&gt;attrib_binding == 0)
+               ? 0 : (curr-&gt;attrib_binding - VERT_ATTRIB_GENERIC0);
+            assert(attr &lt; MAX_VERTEX_PROGRAM_ATTRIBS);
+            genericAttrib[attr] = GL_TRUE;
+         }
+         else {
+            assert(curr-&gt;attrib_binding &lt; MAX_VERTEX_PROGRAM_ATTRIBS);
             explicitAttrib[ curr-&gt;attrib_binding ] = GL_TRUE;
+         }
       }
 
       curr = curr-&gt;next;
@@ -1823,7 +1829,6 @@
                if (param_var-&gt;param_binding_begin == ~0U)
                   param_var-&gt;param_binding_begin = idx;
                param_var-&gt;param_binding_length++;
-               Program-&gt;Base.NumParameters++;
             }
          }
          else {
@@ -1832,7 +1837,6 @@
             if (param_var-&gt;param_binding_begin == ~0U)
                param_var-&gt;param_binding_begin = idx;
             param_var-&gt;param_binding_length++;
-            Program-&gt;Base.NumParameters++;
          }
          break;
 
@@ -1843,7 +1847,6 @@
          if (param_var-&gt;param_binding_begin == ~0U)
             param_var-&gt;param_binding_begin = idx;
          param_var-&gt;param_binding_length++;
-         Program-&gt;Base.NumParameters++;
 
          /* Check if there is more: 0 -&gt; we're done, else its an integer */
          if (**inst) {
@@ -1879,7 +1882,6 @@
                idx = _mesa_add_state_reference(Program-&gt;Base.Parameters,
                                                state_tokens);
                param_var-&gt;param_binding_length++;
-               Program-&gt;Base.NumParameters++;
             }
          }
          else {
@@ -1897,7 +1899,6 @@
             param_var-&gt;param_binding_begin = idx;
          param_var-&gt;param_binding_type = PROGRAM_CONSTANT;
          param_var-&gt;param_binding_length++;
-         Program-&gt;Base.NumParameters++;
          break;
 
       default:
@@ -1906,12 +1907,14 @@
          return 1;
    }
 
+   Program-&gt;Base.NumParameters = Program-&gt;Base.Parameters-&gt;NumParameters;
+
    /* Make sure we haven't blown past our parameter limits */
    if (((Program-&gt;Base.Target == GL_VERTEX_PROGRAM_ARB) &amp;&amp;
-        (Program-&gt;Base.NumParameters &gt;=
+        (Program-&gt;Base.NumParameters &gt;
          ctx-&gt;Const.VertexProgram.MaxLocalParams))
        || ((Program-&gt;Base.Target == GL_FRAGMENT_PROGRAM_ARB)
-           &amp;&amp; (Program-&gt;Base.NumParameters &gt;=
+           &amp;&amp; (Program-&gt;Base.NumParameters &gt;
                ctx-&gt;Const.FragmentProgram.MaxLocalParams))) {
       program_error(ctx, Program-&gt;Position, &quot;Too many parameter variables&quot;);
       return 1;

Modified: haiku/vendor/mesa/current/src/shader/prog_execute.c
===================================================================
--- haiku/vendor/mesa/current/src/shader/prog_execute.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/shader/prog_execute.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -873,7 +873,7 @@
                 * result.z = result.x * APPX(result.y)
                 * We do what the ARB extension says.
                 */
-               q[2] = (GLfloat) pow(2.0, t[0]);
+               q[2] = (GLfloat) _mesa_pow(2.0, t[0]);
             }
             q[1] = t[0] - floor_t0;
             q[3] = 1.0F;
@@ -986,7 +986,7 @@
                if (a[1] == 0.0 &amp;&amp; a[3] == 0.0)
                   result[2] = 1.0;
                else
-                  result[2] = EXPF(a[3] * LOGF(a[1]));
+                  result[2] = (GLfloat) _mesa_pow(a[1], a[3]);
             }
             else {
                result[2] = 0.0;
@@ -1577,8 +1577,8 @@
       case OPCODE_TXB:         /* GL_ARB_fragment_program only */
          /* Texel lookup with LOD bias */
          {
-            const struct gl_texture_unit *texUnit
-               = &amp;ctx-&gt;Texture.Unit[inst-&gt;TexSrcUnit];
+            const GLuint unit = machine-&gt;Samplers[inst-&gt;TexSrcUnit];
+            const struct gl_texture_unit *texUnit = &amp;ctx-&gt;Texture.Unit[unit];
             GLfloat texcoord[4], color[4], lodBias;
 
             fetch_vector4(&amp;inst-&gt;SrcReg[0], machine, texcoord);

Modified: haiku/vendor/mesa/current/src/shader/prog_parameter.c
===================================================================
--- haiku/vendor/mesa/current/src/shader/prog_parameter.c	2009-05-21 09:55:40 UTC (rev 30809)
+++ haiku/vendor/mesa/current/src/shader/prog_parameter.c	2009-05-21 10:39:58 UTC (rev 30810)
@@ -178,15 +178,20 @@
                          const char *name, const GLfloat values[4],
                          GLuint size)
 {
-#if 0 /* disable this for now -- we need to save the name! */
+   /* first check if this is a duplicate constant */
    GLint pos;
-   GLuint swizzle;
-   ASSERT(size == 4); /* XXX future feature */
-   /* check if we already have this constant */
-   if (_mesa_lookup_parameter_constant(paramList, values, 4, &amp;pos, &amp;swizzle)) {
-      return pos;
+   for (pos = 0; pos &lt; paramList-&gt;NumParameters; pos++) {
+      const GLfloat *pvals = paramList-&gt;ParameterValues[pos];
+      if (pvals[0] == values[0] &amp;&amp;
+          pvals[1] == values[1] &amp;&amp;
+          pvals[2] == values[2] &amp;&amp;
+          pvals[3] == values[3] &amp;&amp;
+          _mesa_strcmp(paramList-&gt;Parameters[pos].Name, name) == 0) {
+         /* Same name and value is already in the param list - reuse it */
+         return pos;
+      }
    }
-#endif

[... truncated: 147 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016865.html">[Haiku-commits] r30809 - haiku/trunk/build/jam
</A></li>
	<LI>Next message: <A HREF="016867.html">[Haiku-commits] r30811 - haiku/vendor/mesa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16866">[ date ]</a>
              <a href="thread.html#16866">[ thread ]</a>
              <a href="subject.html#16866">[ subject ]</a>
              <a href="author.html#16866">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
