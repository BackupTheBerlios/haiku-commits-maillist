<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30855 - in haiku/trunk: headers/os/translation	src/kits/translation
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30855%20-%20in%20haiku/trunk%3A%20headers/os/translation%0A%09src/kits/translation&In-Reply-To=%3C200905252351.n4PNpIQg013261%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016931.html">
   <LINK REL="Next"  HREF="016933.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30855 - in haiku/trunk: headers/os/translation	src/kits/translation</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30855%20-%20in%20haiku/trunk%3A%20headers/os/translation%0A%09src/kits/translation&In-Reply-To=%3C200905252351.n4PNpIQg013261%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30855 - in haiku/trunk: headers/os/translation	src/kits/translation">bonefish at mail.berlios.de
       </A><BR>
    <I>Tue May 26 01:51:18 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="016931.html">[Haiku-commits] r30854 - in haiku/trunk: headers/os/translation	src/kits/translation
</A></li>
        <LI>Next message: <A HREF="016933.html">[Haiku-commits] r30856 - haiku/trunk/src/kits/translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16932">[ date ]</a>
              <a href="thread.html#16932">[ thread ]</a>
              <a href="subject.html#16932">[ subject ]</a>
              <a href="author.html#16932">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-05-26 01:51:16 +0200 (Tue, 26 May 2009)
New Revision: 30855
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30855&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30855&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/translation/TranslatorRoster.h
   haiku/trunk/src/kits/translation/TranslatorRoster.cpp
Log:
Style cleanup.


Modified: haiku/trunk/headers/os/translation/TranslatorRoster.h
===================================================================
--- haiku/trunk/headers/os/translation/TranslatorRoster.h	2009-05-25 23:32:53 UTC (rev 30854)
+++ haiku/trunk/headers/os/translation/TranslatorRoster.h	2009-05-25 23:51:16 UTC (rev 30855)
@@ -5,10 +5,10 @@
 #ifndef _TRANSLATOR_ROSTER_H
 #define _TRANSLATOR_ROSTER_H
 
-
 #include &lt;Archivable.h&gt;
 #include &lt;TranslationDefs.h&gt;
 
+
 struct translation_format;
 
 class BBitmap;
@@ -23,88 +23,104 @@
 
 
 class BTranslatorRoster : public BArchivable {
-	public:
-		BTranslatorRoster();
-		BTranslatorRoster(BMessage* model);
-		virtual ~BTranslatorRoster();
+public:
+								BTranslatorRoster();
+								BTranslatorRoster(BMessage* model);
+	virtual						~BTranslatorRoster();
 
-		static BTranslatorRoster *Default();
+	static	BTranslatorRoster*	Default();
 
-		virtual status_t Archive(BMessage* into, bool deep = true) const;
-		static BArchivable* Instantiate(BMessage* from);
+	virtual	status_t			Archive(BMessage* into, bool deep = true) const;
+	static	BArchivable*		Instantiate(BMessage* from);
 
-		status_t AddTranslators(const char* loadPath = NULL);
-		status_t AddTranslator(BTranslator* translator);
+			status_t			AddTranslators(const char* loadPath = NULL);
+			status_t			AddTranslator(BTranslator* translator);
 
-		virtual status_t Identify(BPositionIO* source, BMessage* ioExtension,
-			translator_info* _info, uint32 hintType = 0,
-			const char* hintMIME = NULL, uint32 wantType = 0);
+	virtual	status_t			Identify(BPositionIO* source,
+									BMessage* ioExtension,
+									translator_info* _info, uint32 hintType = 0,
+									const char* hintMIME = NULL,
+									uint32 wantType = 0);
 
-		virtual status_t GetTranslators(BPositionIO* source,
-			BMessage* ioExtension, translator_info** _info, int32* _numInfo,
-			uint32 hintType = 0, const char* hintMIME = NULL,
-			uint32 wantType = 0);
+	virtual	status_t			GetTranslators(BPositionIO* source,
+									BMessage* ioExtension,
+									translator_info** _info, int32* _numInfo,
+									uint32 hintType = 0,
+									const char* hintMIME = NULL,
+									uint32 wantType = 0);
 
-		virtual status_t GetAllTranslators(translator_id** _list,
-			int32* _count);
+	virtual	status_t			GetAllTranslators(translator_id** _list,
+									int32* _count);
 
-		virtual	status_t GetTranslatorInfo(translator_id translatorID,
-			const char** _name, const char** _info, int32* _version);
+	virtual	status_t			GetTranslatorInfo(translator_id translatorID,
+									const char** _name, const char** _info,
+									int32* _version);
 
-		virtual status_t GetInputFormats(translator_id translatorID,
-			const translation_format** _formats, int32* _numFormats);
+	virtual	status_t			GetInputFormats(translator_id translatorID,
+									const translation_format** _formats,
+									int32* _numFormats);
 
-		virtual	status_t GetOutputFormats(translator_id translatorID,
-			const translation_format** _formats, int32* _numFormats);
+	virtual	status_t			GetOutputFormats(translator_id translatorID,
+									const translation_format** _formats,
+									int32* _numFormats);
 
-		virtual	status_t Translate(BPositionIO* source,
-			const translator_info* info, BMessage* ioExtension,
-			BPositionIO* destination, uint32 wantOutType,
-			uint32 hintType = 0, const char* hintMIME = NULL);
+	virtual	status_t			Translate(BPositionIO* source,
+									const translator_info* info,
+									BMessage* ioExtension,
+									BPositionIO* destination,
+									uint32 wantOutType, uint32 hintType = 0,
+									const char* hintMIME = NULL);
 
-		virtual	status_t Translate(translator_id translatorID,
-			BPositionIO* source, BMessage* ioExtension,
-			BPositionIO* destination, uint32 wantOutType);
+	virtual	status_t			Translate(translator_id translatorID,
+									BPositionIO* source, BMessage* ioExtension,
+									BPositionIO* destination,
+									uint32 wantOutType);
 
-		virtual status_t MakeConfigurationView(translator_id translatorID,
-			BMessage* ioExtension, BView** _view, BRect* _extent);
+	virtual	status_t			MakeConfigurationView(
+									translator_id translatorID,
+									BMessage* ioExtension, BView** _view,
+									BRect* _extent);
 
-		virtual	status_t GetConfigurationMessage(translator_id translatorID,
-			BMessage* ioExtension);
+	virtual	status_t			GetConfigurationMessage(
+									translator_id translatorID,
+									BMessage* ioExtension);
 
-		status_t GetRefFor(translator_id translatorID, entry_ref* ref);
-		bool IsTranslator(entry_ref* ref);
+			status_t			GetRefFor(translator_id translatorID,
+									entry_ref* ref);
+			bool				IsTranslator(entry_ref* ref);
 
-		status_t StartWatching(BMessenger target);
-		status_t StopWatching(BMessenger target);
+			status_t			StartWatching(BMessenger target);
+			status_t			StopWatching(BMessenger target);
 
-		class Private;
+			class Private;
 
-	private:
-		// unimplemented
-		BTranslatorRoster(const BTranslatorRoster&amp; other);
-		BTranslatorRoster&amp; operator=(const BTranslatorRoster&amp; other);
+private:
+			// unimplemented
+								BTranslatorRoster(
+									const BTranslatorRoster&amp; other);
+			BTranslatorRoster&amp;	operator=(const BTranslatorRoster&amp; other);
 
-		virtual	void ReservedTranslatorRoster1();
-		virtual	void ReservedTranslatorRoster2();
-		virtual	void ReservedTranslatorRoster3();
-		virtual	void ReservedTranslatorRoster4();
-		virtual	void ReservedTranslatorRoster5();
-		virtual	void ReservedTranslatorRoster6();
+	virtual	void					ReservedTranslatorRoster1();
+	virtual	void					ReservedTranslatorRoster2();
+	virtual	void					ReservedTranslatorRoster3();
+	virtual	void					ReservedTranslatorRoster4();
+	virtual	void					ReservedTranslatorRoster5();
+	virtual	void					ReservedTranslatorRoster6();
 
-		void _Initialize();
+			void					_Initialize();
 
-		static const char* Version(int32* outCurVersion, int32* outMinVersion,
-			int32 inAppVersion);
+	static	const char*				Version(int32* outCurVersion,
+										int32* outMinVersion,
+										int32 inAppVersion);
 				// for backward compatiblity only
 
-	private:
-		friend class Private;
+private:
+			friend class Private;
 
-		Private*	fPrivate;
-		int32		fUnused[6];
+			Private*				fPrivate;
+			int32					fUnused[6];
 
-		static BTranslatorRoster* sDefaultRoster;
+	static	BTranslatorRoster*		sDefaultRoster;
 };
 
 #endif	/* _TRANSLATOR_ROSTER_H */

Modified: haiku/trunk/src/kits/translation/TranslatorRoster.cpp
===================================================================
--- haiku/trunk/src/kits/translation/TranslatorRoster.cpp	2009-05-25 23:32:53 UTC (rev 30854)
+++ haiku/trunk/src/kits/translation/TranslatorRoster.cpp	2009-05-25 23:51:16 UTC (rev 30855)
@@ -13,14 +13,13 @@
 	object with the translators that the apps need to access.
 */
 
+#include &lt;TranslatorRoster.h&gt;
 
-#include &quot;FuncTranslator.h&quot;
-#include &quot;TranslatorRosterPrivate.h&quot;
+#include &lt;new&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
 
-#include &lt;driver_settings.h&gt;
-#include &lt;image.h&gt;
-#include &lt;safemode_defs.h&gt;
-
 #include &lt;Application.h&gt;
 #include &lt;Autolock.h&gt;
 #include &lt;Directory.h&gt;
@@ -28,23 +27,26 @@
 #include &lt;NodeMonitor.h&gt;
 #include &lt;Path.h&gt;
 #include &lt;String.h&gt;
-#include &lt;TranslatorRoster.h&gt;
 
-#include &lt;new&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
+#include &lt;driver_settings.h&gt;
+#include &lt;image.h&gt;
+#include &lt;safemode_defs.h&gt;
 
+#include &quot;FuncTranslator.h&quot;
+#include &quot;TranslatorRosterPrivate.h&quot;
+
+
 #ifdef HAIKU_TARGET_PLATFORM_HAIKU
-extern &quot;C&quot; status_t _kern_get_safemode_option(const char *parameter,
-        char *buffer, size_t *_bufferSize);
+extern &quot;C&quot; status_t _kern_get_safemode_option(const char* parameter,
+        char* buffer, size_t* _bufferSize);
 #else
-extern &quot;C&quot; status_t _kget_safemode_option_(const char *parameter,
-        char *buffer, size_t *_bufferSize);
+extern &quot;C&quot; status_t _kget_safemode_option_(const char* parameter,
+        char* buffer, size_t* _bufferSize);
 #endif
 
 
-#if !defined(HAIKU_TARGET_PLATFORM_HAIKU) &amp;&amp; !defined(HAIKU_TARGET_PLATFORM_LIBBE_TEST)
+#if !defined(HAIKU_TARGET_PLATFORM_HAIKU) \
+	&amp;&amp; !defined(HAIKU_TARGET_PLATFORM_LIBBE_TEST)
 // building under R5 or Dano/Zeta
 enum {
 	B_TRANSLATOR_ADDED			= '_ART',
@@ -55,17 +57,18 @@
 namespace BPrivate {
 
 class QuarantineTranslatorImage {
-	public:
-		QuarantineTranslatorImage(BTranslatorRoster::Private&amp; privateRoster);
-		~QuarantineTranslatorImage();
+public:
+								QuarantineTranslatorImage(
+									BTranslatorRoster::Private&amp; privateRoster);
+								~QuarantineTranslatorImage();
 
-		void Put(const entry_ref&amp; ref);
-		void Remove();
+			void				Put(const entry_ref&amp; ref);
+			void				Remove();
 
-	private:
-		BTranslatorRoster::Private&amp; fRoster;
-		entry_ref	fRef;
-		bool		fRemove;
+private:
+			BTranslatorRoster::Private&amp; fRoster;
+			entry_ref			fRef;
+			bool				fRemove;
 };
 
 }	// namespace BPrivate
@@ -91,14 +94,16 @@
 
 /*!
 	The purpose of this class is to put a translator entry_ref into - and remove
-	it from the list of translators on destruction (if Remove() was called before).
+	it from the list of translators on destruction (if Remove() was called
+	before).
 
 	This is used in Private::CreateTranslators() in case a translator hides a
-	previous one (ie. if you install a translator in the user's translators directory
-	that has the same name as one in the system's directory, it will hide this
-	entry).
+	previous one (ie. if you install a translator in the user's translators
+	directory that has the same name as one in the system's directory, it will
+	hide this entry).
 */
-QuarantineTranslatorImage::QuarantineTranslatorImage(BTranslatorRoster::Private&amp; privateRoster)
+QuarantineTranslatorImage::QuarantineTranslatorImage(
+	BTranslatorRoster::Private&amp; privateRoster)
 	:
 	fRoster(privateRoster),
 	fRemove(false)
@@ -135,7 +140,8 @@
 
 
 BTranslatorRoster::Private::Private()
-	: BHandler(&quot;translator roster&quot;), BLocker(&quot;translator list&quot;),
+	:
+	BHandler(&quot;translator roster&quot;), BLocker(&quot;translator list&quot;),
 	fNextID(1),
 	fLazyScanning(true),
 	fSafeMode(false)
@@ -145,9 +151,11 @@
 	size_t parameterLength = sizeof(parameter);
 
 #ifdef HAIKU_TARGET_PLATFORM_HAIKU
-	if (_kern_get_safemode_option(B_SAFEMODE_SAFE_MODE, parameter, &amp;parameterLength) == B_OK)
+	if (_kern_get_safemode_option(B_SAFEMODE_SAFE_MODE, parameter,
+			&amp;parameterLength) == B_OK)
 #else
-	if (_kget_safemode_option_(B_SAFEMODE_SAFE_MODE, parameter, &amp;parameterLength) == B_OK)
+	if (_kget_safemode_option_(B_SAFEMODE_SAFE_MODE, parameter,
+			&amp;parameterLength) == B_OK)
 #endif
 	{
 		if (!strcasecmp(parameter, &quot;enabled&quot;) || !strcasecmp(parameter, &quot;on&quot;)
@@ -157,9 +165,11 @@
 	}
 
 #ifdef HAIKU_TARGET_PLATFORM_HAIKU
-	if (_kern_get_safemode_option(B_SAFEMODE_DISABLE_USER_ADD_ONS, parameter, &amp;parameterLength) == B_OK)
+	if (_kern_get_safemode_option(B_SAFEMODE_DISABLE_USER_ADD_ONS, parameter,
+			&amp;parameterLength) == B_OK)
 #else
-	if (_kget_safemode_option_(B_SAFEMODE_DISABLE_USER_ADD_ONS, parameter, &amp;parameterLength) == B_OK)
+	if (_kget_safemode_option_(B_SAFEMODE_DISABLE_USER_ADD_ONS, parameter,
+			&amp;parameterLength) == B_OK)
 #endif
 	{
 		if (!strcasecmp(parameter, &quot;enabled&quot;) || !strcasecmp(parameter, &quot;on&quot;)
@@ -235,13 +245,15 @@
 					const char* name;
 					node_ref nodeRef;
 					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK
-						|| message-&gt;FindInt64(&quot;directory&quot;, &amp;nodeRef.node) != B_OK
+						|| message-&gt;FindInt64(&quot;directory&quot;, &amp;nodeRef.node)
+							!= B_OK
 						|| message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)
 						break;
 
 					// TODO: make this better (possible under Haiku)
 					snooze(100000);
-						// let the font be written completely before trying to open it
+						// let the font be written completely before trying to
+						// open it
 
 					_EntryAdded(nodeRef, name);
 					break;
@@ -249,17 +261,20 @@
 
 				case B_ENTRY_MOVED:
 				{
-					// has the entry been moved into a monitored directory or has
-					// it been removed from one?
+					// has the entry been moved into a monitored directory or
+					// has it been removed from one?
 					const char* name;
 					node_ref toNodeRef;
 					node_ref fromNodeRef;
 					node_ref nodeRef;
 
 					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK
-						|| message-&gt;FindInt64(&quot;to directory&quot;, &amp;toNodeRef.node) != B_OK
-						|| message-&gt;FindInt64(&quot;from directory&quot;, (int64 *)&amp;fromNodeRef.node) != B_OK
-						|| message-&gt;FindInt64(&quot;node&quot;, (int64 *)&amp;nodeRef.node) != B_OK
+						|| message-&gt;FindInt64(&quot;to directory&quot;, &amp;toNodeRef.node)
+							!= B_OK
+						|| message-&gt;FindInt64(&quot;from directory&quot;,
+							(int64*)&amp;fromNodeRef.node) != B_OK
+						|| message-&gt;FindInt64(&quot;node&quot;, (int64*)&amp;nodeRef.node)
+							!= B_OK
 						|| message-&gt;FindString(&quot;name&quot;, &amp;name) != B_OK)
 						break;
 
@@ -287,9 +302,9 @@
 
 					if (_IsKnownDirectory(fromNodeRef)
 						&amp;&amp; _IsKnownDirectory(toNodeRef)) {
-						// TODO: we should rescan for the name, there might be name
-						//	clashes with translators in other directories
-						//	(as well as old ones revealed)
+						// TODO: we should rescan for the name, there might be
+						// name clashes with translators in other directories
+						// (as well as old ones revealed)
 						break;
 					}
 					break;
@@ -300,7 +315,8 @@
 					node_ref nodeRef;
 					uint64 directoryNode;
 					if (message-&gt;FindInt32(&quot;device&quot;, &amp;nodeRef.device) != B_OK
-						|| message-&gt;FindInt64(&quot;directory&quot;, (int64 *)&amp;directoryNode) != B_OK
+						|| message-&gt;FindInt64(&quot;directory&quot;,
+							(int64*)&amp;directoryNode) != B_OK
 						|| message-&gt;FindInt64(&quot;node&quot;, &amp;nodeRef.node) != B_OK)
 						break;
 
@@ -330,7 +346,8 @@
 		B_BEOS_ADDONS_DIRECTORY,
 	};
 
-	for (uint32 i = fSafeMode ? 1 : 0; i &lt; sizeof(paths) / sizeof(paths[0]); i++) {
+	for (uint32 i = fSafeMode ? 1 : 0; i &lt; sizeof(paths) / sizeof(paths[0]);
+			i++) {
 		BPath path;
 		status_t status = find_directory(paths[i], &amp;path, true);
 		if (status == B_OK &amp;&amp; path.Append(&quot;Translators&quot;) == B_OK) {
@@ -487,7 +504,8 @@
 
 
 status_t
-BTranslatorRoster::Private::GetTranslatorData(image_id image, translator_data&amp; data)
+BTranslatorRoster::Private::GetTranslatorData(image_id image,
+	translator_data&amp; data)
 {
 	// If this is a translator add-on, it is in the C format
 	memset(&amp;data, 0, sizeof(translator_data));
@@ -495,28 +513,38 @@
 	// find all the symbols
 
 	int32* version;
-	if (get_image_symbol(image, &quot;translatorName&quot;, B_SYMBOL_TYPE_DATA, (void**)&amp;data.name) &lt; B_OK
-		|| get_image_symbol(image, &quot;translatorInfo&quot;, B_SYMBOL_TYPE_DATA, (void**)&amp;data.info) &lt; B_OK
-		|| get_image_symbol(image, &quot;translatorVersion&quot;, B_SYMBOL_TYPE_DATA, (void**)&amp;version) &lt; B_OK || version == NULL
-		|| get_image_symbol(image, &quot;inputFormats&quot;, B_SYMBOL_TYPE_DATA, (void**)&amp;data.input_formats) &lt; B_OK
-		|| get_image_symbol(image, &quot;outputFormats&quot;, B_SYMBOL_TYPE_DATA, (void**)&amp;data.output_formats) &lt; B_OK
-		|| get_image_symbol(image, &quot;Identify&quot;, B_SYMBOL_TYPE_TEXT, (void**)&amp;data.identify_hook) &lt; B_OK
-		|| get_image_symbol(image, &quot;Translate&quot;, B_SYMBOL_TYPE_TEXT, (void**)&amp;data.translate_hook) &lt; B_OK)
+	if (get_image_symbol(image, &quot;translatorName&quot;, B_SYMBOL_TYPE_DATA,
+			(void**)&amp;data.name) &lt; B_OK
+		|| get_image_symbol(image, &quot;translatorInfo&quot;, B_SYMBOL_TYPE_DATA,
+			(void**)&amp;data.info) &lt; B_OK
+		|| get_image_symbol(image, &quot;translatorVersion&quot;, B_SYMBOL_TYPE_DATA,
+			(void**)&amp;version) &lt; B_OK || version == NULL
+		|| get_image_symbol(image, &quot;inputFormats&quot;, B_SYMBOL_TYPE_DATA,
+			(void**)&amp;data.input_formats) &lt; B_OK
+		|| get_image_symbol(image, &quot;outputFormats&quot;, B_SYMBOL_TYPE_DATA,
+			(void**)&amp;data.output_formats) &lt; B_OK
+		|| get_image_symbol(image, &quot;Identify&quot;, B_SYMBOL_TYPE_TEXT,
+			(void**)&amp;data.identify_hook) &lt; B_OK
+		|| get_image_symbol(image, &quot;Translate&quot;, B_SYMBOL_TYPE_TEXT,
+			(void**)&amp;data.translate_hook) &lt; B_OK) {
 		return B_BAD_TYPE;
+	}
 
 	data.version = *version;
 
 	// those calls are optional
-	get_image_symbol(image, &quot;MakeConfig&quot;, B_SYMBOL_TYPE_TEXT, (void**)&amp;data.make_config_hook);
-	get_image_symbol(image, &quot;GetConfigMessage&quot;, B_SYMBOL_TYPE_TEXT, (void**)&amp;data.get_config_message_hook);
+	get_image_symbol(image, &quot;MakeConfig&quot;, B_SYMBOL_TYPE_TEXT,
+		(void**)&amp;data.make_config_hook);
+	get_image_symbol(image, &quot;GetConfigMessage&quot;, B_SYMBOL_TYPE_TEXT,
+		(void**)&amp;data.get_config_message_hook);
 
 	return B_OK;
 }
 
 
 status_t
-BTranslatorRoster::Private::CreateTranslators(const entry_ref&amp; ref, int32&amp; count,
-	BMessage* update)
+BTranslatorRoster::Private::CreateTranslators(const entry_ref&amp; ref,
+	int32&amp; count, BMessage* update)
 {
 	BAutolock locker(this);
 
@@ -556,7 +584,8 @@
 		// until MakeNthTranslator stops returning them.
 		BTranslator* translator = NULL;
 		int32 created = 0;
-		for (int32 n = 0; (translator = makeNthTranslator(n, image, 0)) != NULL; n++) {
+		for (int32 n = 0; (translator = makeNthTranslator(n, image, 0)) != NULL;
+				n++) {
 			if (AddTranslator(translator, image, &amp;ref, nodeRef.node) == B_OK) {
 				if (update)
 					update-&gt;AddInt32(&quot;translator_id&quot;, translator-&gt;fID);
@@ -582,7 +611,8 @@
 	// add this translator to the list
 	BPrivate::BFuncTranslator* translator = NULL;
 	if (status == B_OK) {
-		translator = new (std::nothrow) BPrivate::BFuncTranslator(translatorData);
+		translator = new (std::nothrow) BPrivate::BFuncTranslator(
+			translatorData);
 		if (translator == NULL)
 			status = B_NO_MEMORY;
 	}
@@ -688,13 +718,15 @@
 			return pos &lt; 0 ? (status_t)pos : B_IO_ERROR;
 
 		int32 formatsCount = 0;
-		const translation_format* formats = translator.InputFormats(&amp;formatsCount);
-		const translation_format* format = _CheckHints(formats, formatsCount, hintType,
-			hintMIME);
+		const translation_format* formats = translator.InputFormats(
+			&amp;formatsCount);
+		const translation_format* format = _CheckHints(formats, formatsCount,
+			hintType, hintMIME);
 
 		BMessage extension(baseExtension);
 		translator_info info;
-		if (translator.Identify(source, format, &amp;extension, &amp;info, wantType) == B_OK) {
+		if (translator.Identify(source, format, &amp;extension, &amp;info, wantType)
+				== B_OK) {
 			float weight = info.quality * info.capability;
 			if (weight &gt; bestWeight) {
 				if (ioExtension != NULL)
@@ -743,12 +775,14 @@
 		}
 
 		int32 formatsCount = 0;
-		const translation_format* formats = translator.InputFormats(&amp;formatsCount);
-		const translation_format* format = _CheckHints(formats, formatsCount, hintType,
-			hintMIME);
+		const translation_format* formats = translator.InputFormats(
+			&amp;formatsCount);
+		const translation_format* format = _CheckHints(formats, formatsCount,
+			hintType, hintMIME);
 
 		translator_info info;
-		if (translator.Identify(source, format, ioExtension, &amp;info, wantType) == B_OK) {
+		if (translator.Identify(source, format, ioExtension, &amp;info, wantType)
+				== B_OK) {
 			info.translator = iterator-&gt;first;
 			array[count++] = info;
 		}
@@ -758,7 +792,8 @@
 
 	*_info = array;
 	*_numInfo = count;
-	qsort(array, count, sizeof(translator_info), BTranslatorRoster::Private::_CompareSupport);
+	qsort(array, count, sizeof(translator_info),
+		BTranslatorRoster::Private::_CompareSupport);
 		// translators are sorted by best support
 
 	return B_OK;
@@ -766,7 +801,8 @@
 
 
 status_t
-BTranslatorRoster::Private::GetAllTranslators(translator_id** _ids, int32* _count)
+BTranslatorRoster::Private::GetAllTranslators(translator_id** _ids,
+	int32* _count)
 {
 	BAutolock locker(this);
 
@@ -971,8 +1007,8 @@
 	chosen.
 */
 int32
-BTranslatorRoster::Private::_CompareTranslatorDirectoryPriority(const entry_ref&amp; a,
-	const entry_ref&amp; b) const
+BTranslatorRoster::Private::_CompareTranslatorDirectoryPriority(
+	const entry_ref&amp; a, const entry_ref&amp; b) const
 {
 	// priority is determined by the order in the list
 
@@ -1057,7 +1093,8 @@
 
 
 void
-BTranslatorRoster::Private::_EntryAdded(const node_ref&amp; nodeRef, const char* name)
+BTranslatorRoster::Private::_EntryAdded(const node_ref&amp; nodeRef,
+	const char* name)
 {
 	entry_ref ref;
 	ref.device = nodeRef.device;
@@ -1123,7 +1160,8 @@
 
 	if (model) {
 		const char* path;
-		for (int32 i = 0; model-&gt;FindString(&quot;be:translator_path&quot;, i, &amp;path) == B_OK; i++) {
+		for (int32 i = 0;
+			model-&gt;FindString(&quot;be:translator_path&quot;, i, &amp;path) == B_OK; i++) {
 			BEntry entry(path);
 			entry_ref ref;
 			if (entry.GetRef(&amp;ref) == B_OK) {
@@ -1165,7 +1203,7 @@
 }
 
 
-BArchivable *
+BArchivable*
 BTranslatorRoster::Instantiate(BMessage* from)
 {
 	if (!from || !validate_instantiation(from, &quot;BTranslatorRoster&quot;))
@@ -1175,7 +1213,7 @@
 }
 
 
-BTranslatorRoster *
+BTranslatorRoster*
 BTranslatorRoster::Default()
 {
 	static int32 lock = 0;
@@ -1265,7 +1303,7 @@
 		return false;
 
 	// Function pointer used to create post R4.5 style translators
-	BTranslator *(*makeNthTranslator)(int32 n, image_id you, uint32 flags, ...);
+	BTranslator* (*makeNthTranslator)(int32 n, image_id you, uint32 flags, ...);
 
 	status_t status = get_image_symbol(image, &quot;make_nth_translator&quot;,
 		B_SYMBOL_TYPE_TEXT, (void**)&amp;makeNthTranslator);
@@ -1305,7 +1343,8 @@
 	if (source == NULL || _info == NULL)
 		return B_BAD_VALUE;
 
-	return fPrivate-&gt;Identify(source, ioExtension, hintType, hintMIME, wantType, _info);
+	return fPrivate-&gt;Identify(source, ioExtension, hintType, hintMIME, wantType,
+		_info);
 }
 
 
@@ -1509,8 +1548,8 @@
 	BTranslator* translator = fPrivate-&gt;FindTranslator(info-&gt;translator);
 	if (translator != NULL) {
 		translator-&gt;Acquire();
-			// make sure this translator is not removed while we're playing with it;
-			// translating shouldn't be serialized!
+			// make sure this translator is not removed while we're playing with
+			// it; translating shouldn't be serialized!
 	}
 
 	fPrivate-&gt;Unlock();
@@ -1561,8 +1600,8 @@
 	BTranslator* translator = fPrivate-&gt;FindTranslator(id);
 	if (translator != NULL) {
 		translator-&gt;Acquire();
-			// make sure this translator is not removed while we're playing with it;
-			// translating shouldn't be serialized!
+			// make sure this translator is not removed while we're playing with
+			// it; translating shouldn't be serialized!
 	}
 
 	fPrivate-&gt;Unlock();
@@ -1574,14 +1613,15 @@
 	off_t pos = source-&gt;Seek(0, SEEK_SET);
 	if (pos == 0) {
 		translator_info info;
-		status = translator-&gt;Identify(source, NULL, ioExtension, &amp;info, wantOutType);
+		status = translator-&gt;Identify(source, NULL, ioExtension, &amp;info,
+			wantOutType);
 		if (status &gt;= B_OK) {
 			off_t pos = source-&gt;Seek(0, SEEK_SET);
 			if (pos != 0)
 				status = pos &lt; 0 ? (status_t)pos : B_IO_ERROR;
 			else {
-				status = translator-&gt;Translate(source, &amp;info, ioExtension, wantOutType,
-					destination);
+				status = translator-&gt;Translate(source, &amp;info, ioExtension,
+					wantOutType, destination);
 			}
 		}
 	} else
@@ -1606,8 +1646,8 @@
 		B_NO_TRANSLATOR, \id didn't identify an existing translator
 */
 status_t
-BTranslatorRoster::MakeConfigurationView(translator_id id, BMessage* ioExtension,
-	BView** _view, BRect* _extent)
+BTranslatorRoster::MakeConfigurationView(translator_id id,
+	BMessage* ioExtension, BView** _view, BRect* _extent)
 {
 	if (_view == NULL || _extent == NULL)
 		return B_BAD_VALUE;
@@ -1634,7 +1674,8 @@
 		B_NO_TRANSLATOR, \id didn't identify an existing translator
 */
 status_t
-BTranslatorRoster::GetConfigurationMessage(translator_id id, BMessage* ioExtension)
+BTranslatorRoster::GetConfigurationMessage(translator_id id,
+	BMessage* ioExtension)
 {
 	if (!ioExtension)
 		return B_BAD_VALUE;
@@ -1713,9 +1754,9 @@
 	static char vDate[] = __DATE__;
 	if (!vString[0]) {
 		sprintf(vString, &quot;Translation Kit v%d.%d.%d %s\n&quot;,
-			static_cast&lt;int&gt;(B_TRANSLATION_MAJOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),
-			static_cast&lt;int&gt;(B_TRANSLATION_MINOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),
-			static_cast&lt;int&gt;(B_TRANSLATION_REVISION_VERSION(B_TRANSLATION_CURRENT_VERSION)),
+			int(B_TRANSLATION_MAJOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),
+			int(B_TRANSLATION_MINOR_VERSION(B_TRANSLATION_CURRENT_VERSION)),
+			int(B_TRANSLATION_REVISION_VERSION(B_TRANSLATION_CURRENT_VERSION)),
 			vDate);
 	}
 	*outCurVersion = B_TRANSLATION_CURRENT_VERSION;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016931.html">[Haiku-commits] r30854 - in haiku/trunk: headers/os/translation	src/kits/translation
</A></li>
	<LI>Next message: <A HREF="016933.html">[Haiku-commits] r30856 - haiku/trunk/src/kits/translation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16932">[ date ]</a>
              <a href="thread.html#16932">[ thread ]</a>
              <a href="subject.html#16932">[ subject ]</a>
              <a href="author.html#16932">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
