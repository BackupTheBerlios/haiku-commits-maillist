<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30631 - haiku/trunk/src/system/kernel
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30631%20-%20haiku/trunk/src/system/kernel&In-Reply-To=%3C200905051005.n45A5CdX003907%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016502.html">
   <LINK REL="Next"  HREF="016504.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30631 - haiku/trunk/src/system/kernel</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30631%20-%20haiku/trunk/src/system/kernel&In-Reply-To=%3C200905051005.n45A5CdX003907%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30631 - haiku/trunk/src/system/kernel">axeld at mail.berlios.de
       </A><BR>
    <I>Tue May  5 12:05:12 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="016502.html">[Haiku-commits] r30630 - haiku/trunk/src/bin/bemail_utils
</A></li>
        <LI>Next message: <A HREF="016504.html">[Haiku-commits] r30632 - haiku/trunk/src/system/kernel/cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16503">[ date ]</a>
              <a href="thread.html#16503">[ thread ]</a>
              <a href="subject.html#16503">[ subject ]</a>
              <a href="author.html#16503">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2009-05-05 12:05:11 +0200 (Tue, 05 May 2009)
New Revision: 30631
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30631&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30631&amp;view=rev</A>

Modified:
   haiku/trunk/src/system/kernel/heap.cpp
Log:
* Style cleanup, mostly 80 character limit per line.


Modified: haiku/trunk/src/system/kernel/heap.cpp
===================================================================
--- haiku/trunk/src/system/kernel/heap.cpp	2009-05-05 01:31:01 UTC (rev 30630)
+++ haiku/trunk/src/system/kernel/heap.cpp	2009-05-05 10:05:11 UTC (rev 30631)
@@ -8,6 +8,7 @@
  * Copyright 2001, Travis Geiselbrecht. All rights reserved.
  * Distributed under the terms of the NewOS License.
  */
+
 #include &lt;arch/debug.h&gt;
 #include &lt;debug.h&gt;
 #include &lt;elf.h&gt;
@@ -284,9 +285,9 @@
 	for (addr_t *temp = page-&gt;free_list; temp != NULL; temp = (addr_t *)*temp)
 		count++;
 
-	dprintf(&quot;\t\tpage %p: bin_index: %u; free_count: %u; empty_index: %u; free_list %p (%lu entr%s)\n&quot;,
-		page, page-&gt;bin_index, page-&gt;free_count, page-&gt;empty_index,
-		page-&gt;free_list, count, count == 1 ? &quot;y&quot; : &quot;ies&quot;);
+	dprintf(&quot;\t\tpage %p: bin_index: %u; free_count: %u; empty_index: %u; &quot;
+		&quot;free_list %p (%lu entr%s)\n&quot;, page, page-&gt;bin_index, page-&gt;free_count,
+		page-&gt;empty_index, page-&gt;free_list, count, count == 1 ? &quot;y&quot; : &quot;ies&quot;);
 }
 
 
@@ -315,10 +316,10 @@
 {
 	heap_area *area = heap-&gt;all_areas;
 	while (area) {
-		dprintf(&quot;\tarea %p: area: %ld; base: 0x%08lx; size: %lu; page_count: %lu; free_pages: %p (%lu entr%s)\n&quot;,
-			area, area-&gt;area, area-&gt;base, area-&gt;size, area-&gt;page_count,
-			area-&gt;free_pages, area-&gt;free_page_count,
-			area-&gt;free_page_count == 1 ? &quot;y&quot; : &quot;ies&quot;);
+		dprintf(&quot;\tarea %p: area: %ld; base: 0x%08lx; size: %lu; page_count: &quot;
+			&quot;%lu; free_pages: %p (%lu entr%s)\n&quot;, area, area-&gt;area, area-&gt;base,
+			area-&gt;size, area-&gt;page_count, area-&gt;free_pages,
+			area-&gt;free_page_count, area-&gt;free_page_count == 1 ? &quot;y&quot; : &quot;ies&quot;);
 		area = area-&gt;all_next;
 	}
 
@@ -329,8 +330,9 @@
 static void
 dump_allocator(heap_allocator *heap, bool areas, bool bins)
 {
-	dprintf(&quot;allocator %p: name: %s; page_size: %lu; bin_count: %lu; pages: %lu; free_pages: %lu; empty_areas: %lu\n&quot;, heap,
-		heap-&gt;name, heap-&gt;page_size, heap-&gt;bin_count, heap-&gt;total_pages,
+	dprintf(&quot;allocator %p: name: %s; page_size: %lu; bin_count: %lu; pages: &quot;
+		&quot;%lu; free_pages: %lu; empty_areas: %lu\n&quot;, heap, heap-&gt;name,
+		heap-&gt;page_size, heap-&gt;bin_count, heap-&gt;total_pages,
 		heap-&gt;total_free_pages, heap-&gt;empty_areas);
 
 	if (areas)
@@ -410,11 +412,14 @@
 				if (page-&gt;bin_index &lt; heap-&gt;bin_count) {
 					// page is used by a small allocation bin
 					uint32 elementCount = page-&gt;empty_index;
-					size_t elementSize = heap-&gt;bins[page-&gt;bin_index].element_size;
-					for (uint32 j = 0; j &lt; elementCount; j++, base += elementSize) {
+					size_t elementSize
+						= heap-&gt;bins[page-&gt;bin_index].element_size;
+					for (uint32 j = 0; j &lt; elementCount;
+							j++, base += elementSize) {
 						// walk the free list to see if this element is in use
 						bool elementInUse = true;
-						for (addr_t *temp = page-&gt;free_list; temp != NULL; temp = (addr_t *)*temp) {
+						for (addr_t *temp = page-&gt;free_list; temp != NULL;
+								temp = (addr_t *)*temp) {
 							if ((addr_t)temp == base) {
 								elementInUse = false;
 								break;
@@ -447,8 +452,10 @@
 					uint32 pageCount = 1;
 					while (i + pageCount &lt; area-&gt;page_count
 						&amp;&amp; area-&gt;page_table[i + pageCount].in_use
-						&amp;&amp; area-&gt;page_table[i + pageCount].bin_index == heap-&gt;bin_count
-						&amp;&amp; area-&gt;page_table[i + pageCount].allocation_id == page-&gt;allocation_id)
+						&amp;&amp; area-&gt;page_table[i + pageCount].bin_index
+							== heap-&gt;bin_count
+						&amp;&amp; area-&gt;page_table[i + pageCount].allocation_id
+							== page-&gt;allocation_id)
 						pageCount++;
 
 					info = (heap_leak_check_info *)(base + pageCount
@@ -786,16 +793,18 @@
 			if ((addr_t)&amp;area-&gt;page_table[page-&gt;index] != (addr_t)page)
 				panic(&quot;used page index does not lead to target page\n&quot;);
 
-			if (page-&gt;prev != lastPage)
-				panic(&quot;used page entry has invalid prev link (%p vs %p bin %lu)\n&quot;,
-					page-&gt;prev, lastPage, i);
+			if (page-&gt;prev != lastPage) {
+				panic(&quot;used page entry has invalid prev link (%p vs %p bin &quot;
+					&quot;%lu)\n&quot;, page-&gt;prev, lastPage, i);
+			}
 
 			if (!page-&gt;in_use)
 				panic(&quot;used page marked as not in use\n&quot;);
 
-			if (page-&gt;bin_index != i)
+			if (page-&gt;bin_index != i) {
 				panic(&quot;used page with bin index %u in page list of bin %lu\n&quot;,
 					page-&gt;bin_index, i);
+			}
 
 			if (page-&gt;free_count &lt; lastFreeCount)
 				panic(&quot;ordering of bin page list broken\n&quot;);
@@ -817,9 +826,10 @@
 			}
 
 			uint32 slotCount = bin-&gt;max_free_count;
-			if (page-&gt;empty_index &gt; slotCount)
+			if (page-&gt;empty_index &gt; slotCount) {
 				panic(&quot;empty index beyond slot count (%u with %lu slots)\n&quot;,
 					page-&gt;empty_index, slotCount);
+			}
 
 			freeSlotsCount += (slotCount - page-&gt;empty_index);
 			if (freeSlotsCount &gt; slotCount)
@@ -919,8 +929,9 @@
 
 	mutex_unlock(&amp;heap-&gt;lock);
 
-	dprintf(&quot;heap_add_area: area %ld added to %s heap %p - usable range 0x%08lx - 0x%08lx\n&quot;,
-		area-&gt;area, heap-&gt;name, heap, area-&gt;base, area-&gt;base + area-&gt;size);
+	dprintf(&quot;heap_add_area: area %ld added to %s heap %p - usable range 0x%08lx &quot;
+		&quot;- 0x%08lx\n&quot;, area-&gt;area, heap-&gt;name, heap, area-&gt;base,
+		area-&gt;base + area-&gt;size);
 }
 
 
@@ -970,8 +981,9 @@
 	if (!locked)
 		mutex_unlock(&amp;heap-&gt;lock);
 
-	dprintf(&quot;heap_remove_area: area %ld with range 0x%08lx - 0x%08lx removed from %s heap %p\n&quot;,
-		area-&gt;area, area-&gt;base, area-&gt;base + area-&gt;size, heap-&gt;name, heap);
+	dprintf(&quot;heap_remove_area: area %ld with range 0x%08lx - 0x%08lx removed &quot;
+		&quot;from %s heap %p\n&quot;, area-&gt;area, area-&gt;base, area-&gt;base + area-&gt;size,
+		heap-&gt;name, heap);
 	return B_OK;
 }
 
@@ -1311,7 +1323,8 @@
 
 	void *address = heap_raw_alloc(heap, size, binIndex);
 
-	TRACE((&quot;memalign(): asked to allocate %lu bytes, returning pointer %p\n&quot;, size, address));
+	TRACE((&quot;memalign(): asked to allocate %lu bytes, returning pointer %p\n&quot;,
+		size, address));
 
 #if KERNEL_HEAP_LEAK_CHECK
 	size -= sizeof(heap_leak_check_info);
@@ -1375,7 +1388,8 @@
 	heap_page *page = &amp;area-&gt;page_table[((addr_t)address - area-&gt;base)
 		/ heap-&gt;page_size];
 
-	TRACE((&quot;free(): page %p: bin_index %d, free_count %d\n&quot;, page, page-&gt;bin_index, page-&gt;free_count));
+	TRACE((&quot;free(): page %p: bin_index %d, free_count %d\n&quot;, page,
+		page-&gt;bin_index, page-&gt;free_count));
 
 	if (page-&gt;bin_index &gt; heap-&gt;bin_count) {
 		panic(&quot;free(): page %p: invalid bin_index %d\n&quot;, page, page-&gt;bin_index);
@@ -1389,7 +1403,8 @@
 		heap_bin *bin = &amp;heap-&gt;bins[page-&gt;bin_index];
 		if (((addr_t)address - area-&gt;base - page-&gt;index
 			* heap-&gt;page_size) % bin-&gt;element_size != 0) {
-			panic(&quot;free(): passed invalid pointer %p supposed to be in bin for element size %ld\n&quot;, address, bin-&gt;element_size);
+			panic(&quot;free(): passed invalid pointer %p supposed to be in bin for &quot;
+				&quot;element size %ld\n&quot;, address, bin-&gt;element_size);
 			mutex_unlock(&amp;heap-&gt;lock);
 			return B_ERROR;
 		}
@@ -1398,9 +1413,11 @@
 		if (((uint32 *)address)[1] == 0xdeadbeef) {
 			// This block looks like it was freed already, walk the free list
 			// on this page to make sure this address doesn't exist.
-			for (addr_t *temp = page-&gt;free_list; temp != NULL; temp = (addr_t *)*temp) {
+			for (addr_t *temp = page-&gt;free_list; temp != NULL;
+					temp = (addr_t *)*temp) {
 				if (temp == address) {
-					panic(&quot;free(): address %p already exists in page free list\n&quot;, address);
+					panic(&quot;free(): address %p already exists in page free &quot;
+						&quot;list\n&quot;, address);
 					mutex_unlock(&amp;heap-&gt;lock);
 					return B_ERROR;
 				}
@@ -1409,12 +1426,14 @@
 
 		uint32 *dead = (uint32 *)address;
 		if (bin-&gt;element_size % 4 != 0) {
-			panic(&quot;free(): didn't expect a bin element size that is not a multiple of 4\n&quot;);
+			panic(&quot;free(): didn't expect a bin element size that is not a &quot;
+				&quot;multiple of 4\n&quot;);
 			mutex_unlock(&amp;heap-&gt;lock);
 			return B_ERROR;
 		}
 
-		// the first 4 bytes are overwritten with the next free list pointer later
+		// the first 4 bytes are overwritten with the next free list pointer
+		// later
 		for (uint32 i = 1; i &lt; bin-&gt;element_size / sizeof(uint32); i++)
 			dead[i] = 0xdeadbeef;
 #endif
@@ -1521,7 +1540,8 @@
 	heap_page *page = &amp;area-&gt;page_table[((addr_t)address - area-&gt;base)
 		/ heap-&gt;page_size];
 	if (page-&gt;bin_index &gt; heap-&gt;bin_count) {
-		panic(&quot;realloc(): page %p: invalid bin_index %d\n&quot;, page, page-&gt;bin_index);
+		panic(&quot;realloc(): page %p: invalid bin_index %d\n&quot;, page,
+			page-&gt;bin_index);
 		mutex_unlock(&amp;heap-&gt;lock);
 		return B_ERROR;
 	}
@@ -1671,7 +1691,7 @@
 			// one to make some room.
 			TRACE((&quot;heap_grower: grow heaps will run out of memory soon\n&quot;));
 			if (heap_create_new_heap_area(sGrowHeap, &quot;additional grow heap&quot;,
-				HEAP_DEDICATED_GROW_SIZE) != B_OK)
+					HEAP_DEDICATED_GROW_SIZE) != B_OK)
 				dprintf(&quot;heap_grower: failed to create new grow heap area\n&quot;);
 		}
 
@@ -1684,7 +1704,7 @@
 				// allocation cannot be fulfilled due to lack of contiguous
 				// pages)
 				if (heap_create_new_heap_area(heap, &quot;additional heap&quot;,
-					HEAP_GROW_SIZE) != B_OK)
+						HEAP_GROW_SIZE) != B_OK)
 					dprintf(&quot;heap_grower: failed to create new heap area\n&quot;);
 				sLastHandledGrowRequest[i] = sLastGrowRequest[i];
 			}
@@ -1768,7 +1788,8 @@
 		B_ANY_KERNEL_BLOCK_ADDRESS, HEAP_DEDICATED_GROW_SIZE, B_FULL_LOCK,
 		B_KERNEL_READ_AREA | B_KERNEL_WRITE_AREA);
 	if (growHeapArea &lt; B_OK) {
-		panic(&quot;heap_init_post_thread(): couldn't allocate dedicate grow heap area&quot;);
+		panic(&quot;heap_init_post_thread(): couldn't allocate dedicate grow heap &quot;
+			&quot;area&quot;);
 		return growHeapArea;
 	}
 
@@ -1947,7 +1968,8 @@
 			&amp;&amp; info-&gt;size == areaInfo.size &amp;&amp; info-&gt;base == areaInfo.address
 			&amp;&amp; info-&gt;allocation_size &lt; areaInfo.size) {
 			delete_area(area);
-			TRACE((&quot;free(): freed huge allocation by deleting area %ld\n&quot;, area));
+			TRACE((&quot;free(): freed huge allocation by deleting area %ld\n&quot;,
+				area));
 			return;
 		}
 	}
@@ -2002,8 +2024,8 @@
 
 			if (available &gt;= newSize) {
 				// there is enough room available for the newSize
-				TRACE((&quot;realloc(): new size %ld fits in old area %ld with %ld available\n&quot;,
-					newSize, area, available));
+				TRACE((&quot;realloc(): new size %ld fits in old area %ld with %ld &quot;
+					&quot;available\n&quot;, newSize, area, available));
 				return address;
 			}
 
@@ -2017,13 +2039,14 @@
 
 			memcpy(newAddress, address, min_c(newSize, info-&gt;allocation_size));
 			delete_area(area);
-			TRACE((&quot;realloc(): allocated new block %p for size %ld and deleted old area %ld\n&quot;,
-				newAddress, newSize, area));
+			TRACE((&quot;realloc(): allocated new block %p for size %ld and deleted &quot;
+				&quot;old area %ld\n&quot;, newAddress, newSize, area));
 			return newAddress;
 		}
 	}
 
-	panic(&quot;realloc(): failed to realloc address %p to size %lu\n&quot;, address, newSize);
+	panic(&quot;realloc(): failed to realloc address %p to size %lu\n&quot;, address,
+		newSize);
 	return NULL;
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016502.html">[Haiku-commits] r30630 - haiku/trunk/src/bin/bemail_utils
</A></li>
	<LI>Next message: <A HREF="016504.html">[Haiku-commits] r30632 - haiku/trunk/src/system/kernel/cache
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16503">[ date ]</a>
              <a href="thread.html#16503">[ thread ]</a>
              <a href="subject.html#16503">[ subject ]</a>
              <a href="author.html#16503">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
