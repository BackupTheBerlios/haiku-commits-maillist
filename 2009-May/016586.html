<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30683 - in haiku/trunk: headers/private/interface	src/kits/interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30683%20-%20in%20haiku/trunk%3A%20headers/private/interface%0A%09src/kits/interface&In-Reply-To=%3C200905091847.n49IlMnh009047%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016585.html">
   <LINK REL="Next"  HREF="016587.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30683 - in haiku/trunk: headers/private/interface	src/kits/interface</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30683%20-%20in%20haiku/trunk%3A%20headers/private/interface%0A%09src/kits/interface&In-Reply-To=%3C200905091847.n49IlMnh009047%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30683 - in haiku/trunk: headers/private/interface	src/kits/interface">bonefish at mail.berlios.de
       </A><BR>
    <I>Sat May  9 20:47:22 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="016585.html">[Haiku-commits] r30682 -	haiku/trunk/src/apps/debuganalyzer/gui/table
</A></li>
        <LI>Next message: <A HREF="016587.html">[Haiku-commits] r30684 -	haiku/trunk/src/apps/debuganalyzer/gui/table
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16586">[ date ]</a>
              <a href="thread.html#16586">[ thread ]</a>
              <a href="subject.html#16586">[ subject ]</a>
              <a href="author.html#16586">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-05-09 20:47:19 +0200 (Sat, 09 May 2009)
New Revision: 30683
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30683&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30683&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/interface/ColumnListView.h
   haiku/trunk/src/kits/interface/ColumnListView.cpp
Log:
* Introduced methods ResizeColumnToPreferred() and
  ResizeAllColumnsToPreferred().
* Automatic white space cleanup.


Modified: haiku/trunk/headers/private/interface/ColumnListView.h
===================================================================
--- haiku/trunk/headers/private/interface/ColumnListView.h	2009-05-09 18:30:20 UTC (rev 30682)
+++ haiku/trunk/headers/private/interface/ColumnListView.h	2009-05-09 18:47:19 UTC (rev 30683)
@@ -96,14 +96,14 @@
 	B_COLOR_HEADER_TEXT			= 9,
 	B_COLOR_SEPARATOR_LINE		= 10,
 	B_COLOR_SEPARATOR_BORDER	= 11,
-	
+
 	B_COLOR_TOTAL				= 12
 };
 
 enum ColumnListViewFont {
 	B_FONT_ROW					= 0,
 	B_FONT_HEADER				= 1,
-	
+
 	B_FONT_TOTAL				= 2
 };
 
@@ -144,7 +144,7 @@
 			BPrivate::
 			BRowContainer*		fChildList;
 			bool				fIsExpanded;
-			float				fHeight;	
+			float				fHeight;
 			BRow*				fNextSelected;
 			BRow*				fPrevSelected;
 			BRow*				fParent;
@@ -166,7 +166,7 @@
 									float maxWidth,
 									alignment align = B_ALIGN_LEFT);
 	virtual 					~BColumn();
-	
+
 			float				Width() const;
 			void				SetWidth(float width);
 			float				MinWidth() const;
@@ -176,7 +176,7 @@
 	virtual	void				DrawField(BField* field, BRect rect,
 									BView* targetView);
 	virtual	int					CompareFields(BField* field1, BField* field2);
-	
+
 	virtual void				MouseMoved(BColumnListView* parent, BRow* row,
 									BField* field, BRect fieldRect,
 									BPoint point, uint32 buttons, int32 code);
@@ -185,25 +185,25 @@
 									BPoint point, uint32 buttons);
 	virtual	void				MouseUp(BColumnListView* parent, BRow* row,
 									BField* field);
-		
+
 	virtual	void				GetColumnName(BString* into) const;
 	virtual	float				GetPreferredWidth(BField* field,
 									BView* parent) const;
-	
+
 			bool				IsVisible() const;
 			void				SetVisible(bool);
-		
+
 			bool				WantsEvents() const;
 			void				SetWantsEvents(bool);
-			
+
 			bool				ShowHeading() const;
 			void				SetShowHeading(bool);
-		
+
 			alignment			Alignment() const;
 			void				SetAlignment(alignment);
 
 			int32				LogicalFieldNum() const;
-			
+
 	/*!
 		\param field The BField derivative to validate.
 
@@ -219,10 +219,10 @@
 			logical field index where it occured.
 
 			\note Do not call the inherited version of this, it just returns
-			true; 
+			true;
 	  */
 	virtual	bool				AcceptsField(const BField* field) const;
-		
+
 private:
 			float				fWidth;
 			float 				fMinWidth;
@@ -234,7 +234,7 @@
 			bool				fWantsEvents;
 			bool				fShowHeading;
 			alignment			fAlignment;
-		
+
 	friend class BPrivate::OutlineView;
 	friend class BColumnListView;
 	friend class BPrivate::TitleView;
@@ -265,8 +265,8 @@
 			void 				SetFocusRow(int32 index, bool select = false);
 			void 				SetFocusRow(BRow* row, bool select = false);
 			void 				SetMouseTrackingEnabled(bool);
-	
-	// Selection 
+
+	// Selection
 			list_view_type		SelectionMode() const;
 			void 				Deselect(BRow* row);
 			void 				AddToSelection(BRow* row);
@@ -276,7 +276,7 @@
 	virtual	void				SetSelectionMessage(BMessage* message);
 			BMessage*			SelectionMessage();
 			uint32				SelectionCommand() const;
-			void				SetSelectionMode(list_view_type type); 
+			void				SetSelectionMode(list_view_type type);
 				// list_view_type is defined in ListView.h.
 
 	// Sorting
@@ -290,7 +290,7 @@
 			void				AddStatusView(BView* view);
 			BView*				RemoveStatusView();
 
-	// Column Manipulation	
+	// Column Manipulation
 			void				AddColumn(BColumn* column,
 									int32 logicalFieldIndex);
 			void				MoveColumn(BColumn* column, int32 index);
@@ -299,9 +299,11 @@
 			BColumn*			ColumnAt(int32 index) const;
 			void				SetColumnVisible(BColumn* column,
 									bool isVisible);
-			void				SetColumnVisible(int32, bool);	
+			void				SetColumnVisible(int32, bool);
 			bool				IsColumnVisible(int32) const;
 			void				SetColumnFlags(column_flags flags);
+			void				ResizeColumnToPreferred(int32 index);
+			void				ResizeAllColumnsToPreferred();
 
 	// Row manipulation
 			const BRow*			RowAt(int32 index, BRow *parent = 0) const;
@@ -316,14 +318,14 @@
 			void				AddRow(BRow* row, BRow* parent = NULL);
 			void				AddRow(BRow* row, int32 index,
 									BRow* parent = NULL);
-		
+
 			void				ScrollTo(const BRow* Row);
 			void				ScrollTo(BPoint point);
-			
+
 	// Does not delete row or children at this time.
 	// todo: Make delete row and children
 			void				RemoveRow(BRow* row);
-			
+
 			void				UpdateRow(BRow* row);
 			void				Clear();
 
@@ -334,12 +336,12 @@
 									uint32 mask = B_FONT_ALL);
 	virtual	void				SetHighColor(rgb_color);
 			void				SetSelectionColor(rgb_color);
-			void				SetBackgroundColor(rgb_color); 
+			void				SetBackgroundColor(rgb_color);
 			void				SetEditColor(rgb_color);
 			const rgb_color		SelectionColor() const;
 			const rgb_color		BackgroundColor() const;
 			const rgb_color		EditColor() const;
-	
+
 	// Appearance (NEW STYLE)
 			void				SetColor(ColumnListViewColor colorIndex,
 									rgb_color color);
@@ -349,10 +351,10 @@
 			rgb_color			Color(ColumnListViewColor colorIndex) const;
 			void				GetFont(ColumnListViewFont fontIndex,
 									BFont* font) const;
-			
+
 			BPoint				SuggestTextPosition(const BRow* row,
 									const BColumn* column = NULL) const;
-	
+
 			void				SetLatchWidth(float width);
 			float				LatchWidth() const;
 	virtual	void				DrawLatch(BView* view, BRect frame,

Modified: haiku/trunk/src/kits/interface/ColumnListView.cpp
===================================================================
--- haiku/trunk/src/kits/interface/ColumnListView.cpp	2009-05-09 18:30:20 UTC (rev 30682)
+++ haiku/trunk/src/kits/interface/ColumnListView.cpp	2009-05-09 18:47:19 UTC (rev 30683)
@@ -219,6 +219,7 @@
 	virtual						~TitleView();
 
 			void				ColumnAdded(BColumn* column);
+			void				ColumnResized(BColumn* column, float oldWidth);
 			void				SetColumnVisible(BColumn* column, bool visible);
 
 	virtual	void				Draw(BRect updateRect);
@@ -229,7 +230,7 @@
 									const BMessage* dragMessage);
 	virtual	void				MouseUp(BPoint where);
 	virtual	void				FrameResized(float width, float height);
-	
+
 			void				MoveColumn(BColumn* column, int32 index);
 			void				SetColumnFlags(column_flags flags);
 
@@ -253,7 +254,7 @@
 			BList*				fSortColumns;
 			float				fColumnsWidth;
 			BRect				fVisibleRect;
-	
+
 #if DOUBLE_BUFFERED_COLUMN_RESIZE
 			BBitmap*			fDrawBuffer;
 			BView*				fDrawBufferView;
@@ -281,7 +282,7 @@
 			float				fRightDragBoundry;
 			BPoint				fCurrentDragPosition;
 
-	
+
 			BBitmap*			fUpSortArrow;
 			BBitmap*			fDownSortArrow;
 
@@ -306,7 +307,7 @@
 									bool isFirstColumn);
 			void 				StartSorting();
 			float				GetColumnPreferredWidth(BColumn* column);
-	
+
 			void				AddRow(BRow*, int32 index, BRow* TheRow);
 			BRow*				CurrentSelection(BRow* lastSelected) const;
 			void 				ToggleFocusRowSelection(bool selectRange);
@@ -388,10 +389,10 @@
 				ROW_CLICKED,
 				DRAGGING_ROWS
 			};
-	
+
 			CurrentState		fCurrentState;
-	
 
+
 			BColumnListView*	fMasterView;
 			list_view_type		fSelectionMode;
 			bool				fTrackMouse;
@@ -502,9 +503,9 @@
 		BField* field = (BField*) fFields.RemoveItem(0L);
 		if (field == 0)
 			break;
-		
+
 		delete field;
-	}		
+	}
 }
 
 
@@ -541,14 +542,14 @@
 {
 	if (fFields.ItemAt(logicalFieldIndex) != 0)
 		delete (BField*)fFields.RemoveItem(logicalFieldIndex);
-	
+
 	if (NULL != fList) {
 		ValidateField(field, logicalFieldIndex);
 		BRect inv;
 		fList-&gt;GetRowRect(this, &amp;inv);
 		fList-&gt;Invalidate(inv);
 	}
-	
+
 	fFields.AddItem(field, logicalFieldIndex);
 }
 
@@ -567,7 +568,7 @@
 }
 
 
-void 
+void
 BRow::ValidateFields() const
 {
 	for (int32 i = 0; i &lt; CountFields(); i++)
@@ -575,7 +576,7 @@
 }
 
 
-void 
+void
 BRow::ValidateField(const BField* field, int32 logicalFieldIndex) const
 {
 	// The Fields may be moved by the user, but the logicalFieldIndexes
@@ -588,7 +589,7 @@
 		if( col-&gt;LogicalFieldNum() == logicalFieldIndex )
 			break;
 	}
-	
+
 	if (NULL == col) {
 		BString dbmessage(&quot;\n\n\tThe parent BColumnListView does not have &quot;
 		                  &quot;\n\ta BColumn at the logical field index &quot;);
@@ -753,7 +754,7 @@
 }
 
 
-bool 
+bool
 BColumn::AcceptsField(const BField*) const
 {
 	return true;
@@ -882,7 +883,7 @@
 void
 BColumnListView::SetMouseTrackingEnabled(bool Enabled)
 {
-	fOutlineView-&gt;SetMouseTrackingEnabled(Enabled);	
+	fOutlineView-&gt;SetMouseTrackingEnabled(Enabled);
 }
 
 
@@ -934,7 +935,7 @@
 {
 	if (fSelectionMessage == message)
 		return;
-		
+
 	delete fSelectionMessage;
 	fSelectionMessage = message;
 }
@@ -952,7 +953,7 @@
 {
 	if (fSelectionMessage)
 		return fSelectionMessage-&gt;what;
-		
+
 	return 0;
 }
 
@@ -993,7 +994,7 @@
 		fSortColumns.AddItem(column);
 
 	column-&gt;fSortAscending = ascending;
-	fTitleView-&gt;Invalidate();	
+	fTitleView-&gt;Invalidate();
 	fOutlineView-&gt;StartSorting();
 }
 
@@ -1028,7 +1029,7 @@
 		viewRect.OffsetBy(1, -1);
 	else if (fBorderStyle == B_FANCY_BORDER)
 		viewRect.OffsetBy(2, -2);
-	
+
 	view-&gt;SetResizingMode(B_FOLLOW_LEFT | B_FOLLOW_BOTTOM);
 	view-&gt;ResizeTo(viewRect.Width(), viewRect.Height());
 	view-&gt;MoveTo(viewRect.left, viewRect.top);
@@ -1149,11 +1150,43 @@
 }
 
 
+void
+BColumnListView::ResizeColumnToPreferred(int32 index)
+{
+	BColumn* column = ColumnAt(index);
+	if (column == NULL)
+		return;
+
+	// get the preferred column width
+	float width = fOutlineView-&gt;GetColumnPreferredWidth(column);
+	if (width &lt; column-&gt;MinWidth())
+		width = column-&gt;MinWidth();
+	else if (width &gt; column-&gt;MaxWidth())
+		width = column-&gt;MaxWidth();
+
+	// set it
+	float oldWidth = column-&gt;Width();
+	column-&gt;SetWidth(width);
+
+	fTitleView-&gt;ColumnResized(column, oldWidth);
+	fOutlineView-&gt;Invalidate();
+}
+
+
+void
+BColumnListView::ResizeAllColumnsToPreferred()
+{
+	int32 count = CountColumns();
+	for (int32 i = 0; i &lt; count; i++)
+		ResizeColumnToPreferred(i);
+}
+
+
 const BRow*
 BColumnListView::RowAt(int32 Index, BRow* parentRow) const
 {
 	if (parentRow == 0)
-		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);	
+		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);
 
 	return parentRow-&gt;fChildList ? parentRow-&gt;fChildList-&gt;ItemAt(Index) : NULL;
 }
@@ -1163,7 +1196,7 @@
 BColumnListView::RowAt(int32 Index, BRow* parentRow)
 {
 	if (parentRow == 0)
-		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);	
+		return fOutlineView-&gt;RowList()-&gt;ItemAt(Index);
 
 	return parentRow-&gt;fChildList ? parentRow-&gt;fChildList-&gt;ItemAt(Index) : 0;
 }
@@ -1212,7 +1245,7 @@
 BColumnListView::CountRows(BRow* parentRow) const
 {
 	if (parentRow == 0)
-		return fOutlineView-&gt;RowList()-&gt;CountItems();	
+		return fOutlineView-&gt;RowList()-&gt;CountItems();
 	if (parentRow-&gt;fChildList)
 		return parentRow-&gt;fChildList-&gt;CountItems();
 	else
@@ -1290,14 +1323,14 @@
 		case B_FONT_ROW:
 			fOutlineView-&gt;SetFont(font, mask);
 			break;
-		  
+
 		case B_FONT_HEADER:
 			fTitleView-&gt;SetFont(font, mask);
 			break;
-			
+
 		default:
 			ASSERT(false);
-			break;	
+			break;
 	}
 }
 
@@ -1309,14 +1342,14 @@
 		case B_FONT_ROW:
 			fOutlineView-&gt;GetFont(font);
 			break;
-		  
+
 		case B_FONT_HEADER:
 			fTitleView-&gt;GetFont(font);
 			break;
-			
+
 		default:
 			ASSERT(false);
-			break;	
+			break;
 	}
 }
 
@@ -1327,13 +1360,13 @@
 	if ((int)color_num &lt; 0) {
 		ASSERT(false);
 		color_num = (ColumnListViewColor) 0;
-	}	
-		
+	}
+
 	if ((int)color_num &gt;= (int)B_COLOR_TOTAL) {
 		ASSERT(false);
 		color_num = (ColumnListViewColor) (B_COLOR_TOTAL - 1);
 	}
-  
+
 	fColorList[color_num] = color;
 }
 
@@ -1344,13 +1377,13 @@
 	if ((int)color_num &lt; 0) {
 		ASSERT(false);
 		color_num = (ColumnListViewColor) 0;
-	}	
-		
+	}
+
 	if ((int)color_num &gt;= (int)B_COLOR_TOTAL) {
 		ASSERT(false);
 		color_num = (ColumnListViewColor) (B_COLOR_TOTAL - 1);
 	}
-  
+
 	return fColorList[color_num];
 }
 
@@ -1421,17 +1454,17 @@
 			BColumn* column = (BColumn*) fColumns.ItemAt(index);
 			if (!column-&gt;IsVisible())
 				continue;
-			
+
 			if (column == inColumn) {
 				rect.left = leftEdge;
 				rect.right = rect.left + column-&gt;Width();
 				break;
 			}
-			
+
 			leftEdge += column-&gt;Width() + 1;
 		}
 	}
-	
+
 	font_height fh;
 	fOutlineView-&gt;GetFontHeight(&amp;fh);
 	float baseline = floor(rect.top + fh.ascent
@@ -1458,27 +1491,27 @@
 BColumnListView::DrawLatch(BView* view, BRect rect, LatchType position, BRow*)
 {
 	const int32 rectInset = 4;
-	
+
 	view-&gt;SetHighColor(0, 0, 0);
-	
+
 	// Make Square
 	int32 sideLen = rect.IntegerWidth();
 	if (sideLen &gt; rect.IntegerHeight())
 		sideLen = rect.IntegerHeight();
-	
+
 	// Make Center
 	int32 halfWidth  = rect.IntegerWidth() / 2;
 	int32 halfHeight = rect.IntegerHeight() / 2;
 	int32 halfSide   = sideLen / 2;
-	
+
 	float left = rect.left + halfWidth  - halfSide;
 	float top  = rect.top  + halfHeight - halfSide;
-	
+
 	BRect itemRect(left, top, left + sideLen, top + sideLen);
-	
+
 	// Why it is a pixel high? I don't know.
 	itemRect.OffsetBy(0, -1);
-	
+
 	itemRect.InsetBy(rectInset, rectInset);
 
 	// Make it an odd number of pixels wide, the latch looks better this way
@@ -1486,7 +1519,7 @@
 		itemRect.right += 1;
 		itemRect.bottom += 1;
 	}
-		
+
 	switch (position) {
 		case B_OPEN_LATCH:
 			view-&gt;StrokeRect(itemRect);
@@ -1496,7 +1529,7 @@
 				BPoint(itemRect.right - 2,
 					(itemRect.top + itemRect.bottom) / 2));
 			break;
-			
+
 		case B_PRESSED_LATCH:
 			view-&gt;StrokeRect(itemRect);
 			view-&gt;StrokeLine(
@@ -1511,7 +1544,7 @@
 					itemRect.bottom - 2));
 			view-&gt;InvertRect(itemRect);
 			break;
-			
+
 		case B_CLOSED_LATCH:
 			view-&gt;StrokeRect(itemRect);
 			view-&gt;StrokeLine(
@@ -1525,7 +1558,7 @@
 				BPoint((itemRect.left + itemRect.right) / 2,
 					itemRect.bottom - 2));
 			break;
-	
+
 		case B_NO_LATCH:
 			// No drawing
 			break;
@@ -1571,7 +1604,7 @@
 {
 	char c = bytes[0];
 	switch (c) {
-		case B_RIGHT_ARROW: 
+		case B_RIGHT_ARROW:
 		case B_LEFT_ARROW:
 		{
 			float  minVal, maxVal;
@@ -1606,7 +1639,7 @@
 				(modifiers() &amp; B_CONTROL_KEY) == 0,
 				(modifiers() &amp; B_SHIFT_KEY) != 0);
 			break;
-		
+
 		case B_PAGE_UP:
 		case B_PAGE_DOWN:
 		{
@@ -1616,26 +1649,26 @@
 			fVerticalScrollBar-&gt;GetSteps(&amp;smallStep, &amp;largeStep);
 			float currentValue = fVerticalScrollBar-&gt;Value();
 			float newValue = currentValue;
-			
+
 			if (c == B_PAGE_UP)
 				newValue -= largeStep;
 			else
 				newValue += largeStep;
-			
+
 			if (newValue &gt; maxValue)
 				newValue = maxValue;
 			else if (newValue &lt; minValue)
 				newValue = minValue;
-				
+
 			fVerticalScrollBar-&gt;SetValue(newValue);
 
 			// Option + pgup or pgdn scrolls and changes the selection.
 			if (modifiers() &amp; B_OPTION_KEY)
 				fOutlineView-&gt;MoveFocusToVisibleRect();
-			
+
 			break;
 		}
-			
+
 		case B_ENTER:
 			Invoke();
 			break;
@@ -1646,7 +1679,7 @@
 			break;
 
 		case '+':
-			fOutlineView-&gt;ToggleFocusRowOpen();			
+			fOutlineView-&gt;ToggleFocusRowOpen();
 			break;
 
 		default:
@@ -1660,8 +1693,8 @@
 {
 	if (!Messenger().IsValid())
 		SetTarget(Window());
-		
-	if (SortingEnabled()) fOutlineView-&gt;StartSorting();	
+
+	if (SortingEnabled()) fOutlineView-&gt;StartSorting();
 }
 
 
@@ -1718,9 +1751,9 @@
 	BRect cornerRect(rect.right - B_V_SCROLL_BAR_WIDTH,
 		rect.bottom - B_H_SCROLL_BAR_HEIGHT, rect.right, rect.bottom);
 	if (fBorderStyle == B_PLAIN_BORDER) {
-		BView::SetHighColor(0, 0, 0); 
+		BView::SetHighColor(0, 0, 0);
 		StrokeRect(rect);
-		cornerRect.OffsetBy(-1, -1); 
+		cornerRect.OffsetBy(-1, -1);
 	} else if (fBorderStyle == B_FANCY_BORDER) {
 		bool isFocus = IsFocus() &amp;&amp; Window()-&gt;IsActive();
 
@@ -1735,12 +1768,12 @@
 			BView::SetHighColor(184, 184, 184);
 		else
 			BView::SetHighColor(152, 152, 152);
-			
+
 		rect.InsetBy(1,1);
 		StrokeRect(rect);
 		cornerRect.OffsetBy(-2, -2);
 	}
-	
+
 	BView::SetHighColor(ui_color(B_PANEL_BACKGROUND_COLOR));
 		// fills lower right rect between scroll bars
 	FillRect(cornerRect);
@@ -1889,7 +1922,7 @@
 	fVerticalScrollBar-&gt;MoveTo(vScrollBarRect.LeftTop());
 	fVerticalScrollBar-&gt;ResizeTo(vScrollBarRect.Width(),
 		vScrollBarRect.Height());
-	
+
 	fHorizontalScrollBar-&gt;MoveTo(hScrollBarRect.LeftTop());
 	fHorizontalScrollBar-&gt;ResizeTo(hScrollBarRect.Width(),
 		hScrollBarRect.Height());
@@ -2016,7 +2049,7 @@
 		| B_ALLOW_COLUMN_POPUP | B_ALLOW_COLUMN_REMOVE)
 {
 	SetViewColor(B_TRANSPARENT_COLOR);
-	
+
 #if DOUBLE_BUFFERED_COLUMN_RESIZE
 	// xxx this needs to be smart about the size of the backbuffer.
 	BRect doubleBufferRect(0, 0, 600, 35);
@@ -2047,7 +2080,7 @@
 {
 	delete fColumnPop;
 	fColumnPop = NULL;
-	
+
 #if DOUBLE_BUFFERED_COLUMN_RESIZE
 	delete fDrawBuffer;
 #endif
@@ -2071,6 +2104,15 @@
 
 
 void
+TitleView::ColumnResized(BColumn* column, float oldWidth)
+{
+	fColumnsWidth += column-&gt;Width() - oldWidth;
+	FixScrollBar(false);
+	Invalidate();
+}
+
+
+void
 TitleView::SetColumnVisible(BColumn* column, bool visible)
 {
 	if (column-&gt;fVisible == visible)
@@ -2080,18 +2122,18 @@
 	// to invalidate.  If hiding it, do it last.
 	if (visible)
 		column-&gt;fVisible = visible;
-		
+
 	BRect titleInvalid;
 	GetTitleRect(column, &amp;titleInvalid);
 
-	// Now really set the visibility	
+	// Now really set the visibility
 	column-&gt;fVisible = visible;
-	
+
 	if (visible)
 		fColumnsWidth += column-&gt;Width();
 	else
 		fColumnsWidth -= column-&gt;Width();
-	
+
 	BRect outlineInvalid(fOutlineView-&gt;VisibleRect());
 	outlineInvalid.left = titleInvalid.left;
 	titleInvalid.right = outlineInvalid.right;
@@ -2116,7 +2158,7 @@
 				fVisibleRect.bottom);
 			return;
 		}
-		
+
 		leftEdge += column-&gt;Width() + 1;
 	}
 
@@ -2209,11 +2251,11 @@
 TitleView::MoveColumn(BColumn* column, int32 index)
 {
 	fColumns-&gt;RemoveItem((void*) column);
-	
+
 	if (-1 == index) {
 		// Re-add the column at the end of the list.
 		fColumns-&gt;AddItem((void*) column);
-	} else { 
+	} else {
 		fColumns-&gt;AddItem((void*) column, index);
 	}
 }
@@ -2231,8 +2273,8 @@
 {
 	float minWidth = fSelectedColumn-&gt;MinWidth();
 	float maxWidth = fSelectedColumn-&gt;MaxWidth();
-	
-	float originalEdge = fSelectedColumnRect.left + fSelectedColumn-&gt;Width(); 
+
+	float originalEdge = fSelectedColumnRect.left + fSelectedColumn-&gt;Width();
 	if (preferred) {
 		float width = fOutlineView-&gt;GetColumnPreferredWidth(fSelectedColumn);
 		if (width &lt; minWidth)
@@ -2283,7 +2325,7 @@
 		fOutlineView-&gt;CopyBits(slaveSource, slaveDest);
 		fOutlineView-&gt;RedrawColumn(fSelectedColumn, fSelectedColumnRect.left,
 			fResizingFirstColumn);
-	
+
 		fColumnsWidth += dX;
 
 		// Update the cursor
@@ -2291,7 +2333,7 @@
 			SetViewCursor(fMinResizeCursor, true);
 		else if (fSelectedColumn-&gt;Width() == maxWidth)
 			SetViewCursor(fMaxResizeCursor, true);
-		else			
+		else
 			SetViewCursor(fResizeCursor, true);
 	}
 }
@@ -2302,7 +2344,7 @@
 {
 	float previousColumnLeftEdge = -1000000.0;
 	float nextColumnRightEdge = 1000000.0;
-	
+
 	bool foundColumn = false;
 	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());
 	int32 numColumns = fColumns-&gt;CountItems();
@@ -2310,8 +2352,8 @@
 		BColumn* column = (BColumn*) fColumns-&gt;ItemAt(index);
 		if (!column-&gt;IsVisible())
 			continue;
-	
-		if (column == findColumn) { 
+
+		if (column == findColumn) {
 			foundColumn = true;
 			continue;
 		}
@@ -2324,9 +2366,9 @@
 
 		leftEdge += column-&gt;Width() + 1;
 	}
-	
-	float rightEdge = leftEdge + findColumn-&gt;Width();		
 
+	float rightEdge = leftEdge + findColumn-&gt;Width();
+
 	fLeftDragBoundry = MIN(previousColumnLeftEdge + findColumn-&gt;Width(),
 		leftEdge);
 	fRightDragBoundry = MAX(nextColumnRightEdge, rightEdge);
@@ -2372,10 +2414,10 @@
 
 	font_height fh;
 	GetFontHeight(&amp;fh);
-	
+
 	float baseline = floor(drawRect.top + fh.ascent
 		+ (drawRect.Height() + 1 - (fh.ascent + fh.descent)) / 2);
-				   
+
 	if (be_control_look != NULL) {
 		BRect bgRect = rect;
 
@@ -2399,7 +2441,7 @@
 	} else {
 
 		view-&gt;SetHighColor(borderColor);
-		view-&gt;StrokeRect(rect);	
+		view-&gt;StrokeRect(rect);
 		view-&gt;BeginLineArray(4);
 		view-&gt;AddLine(BPoint(rect.left + 1, rect.top + 1),
 			BPoint(rect.right - 1, rect.top + 1), bevelHigh);
@@ -2408,7 +2450,7 @@
 		view-&gt;AddLine(BPoint(rect.right - 1, rect.top + 1),
 			BPoint(rect.right - 1, rect.bottom - 1), bevelLow);
 		view-&gt;AddLine(BPoint(rect.left + 2, rect.bottom-1),
-			BPoint(rect.right - 1, rect.bottom - 1), bevelLow);	
+			BPoint(rect.right - 1, rect.bottom - 1), bevelLow);
 		view-&gt;EndLineArray();
 
 		view-&gt;SetHighColor(backgroundColor);
@@ -2420,7 +2462,7 @@
 	// If no column given, nothing else to draw.
 	if (!column)
 		return;
-	
+
 	view-&gt;SetHighColor(fMasterView-&gt;Color(B_COLOR_HEADER_TEXT));
 
 	BFont font;
@@ -2431,13 +2473,13 @@
 	if (sortIndex &gt;= 0) {
 		// Draw sort notation.
 		BPoint upperLeft(drawRect.right - kSortIndicatorWidth, baseline);
-	
+
 		if (fSortColumns-&gt;CountItems() &gt; 1) {
 			char str[256];
 			sprintf(str, &quot;%d&quot;, sortIndex + 1);
 			const float w = view-&gt;StringWidth(str);
 			upperLeft.x -= w;
-			
+
 			view-&gt;SetDrawingMode(B_OP_COPY);
 			view-&gt;MovePenTo(BPoint(upperLeft.x + kSortIndicatorWidth,
 				baseline));
@@ -2445,13 +2487,13 @@
 		}
 
 		float bmh = fDownSortArrow-&gt;Bounds().Height()+1;
-		
+
 		view-&gt;SetDrawingMode(B_OP_OVER);
-		
+
 		if (column-&gt;fSortAscending) {
 			BPoint leftTop(upperLeft.x, drawRect.top + (drawRect.IntegerHeight()
 				- fDownSortArrow-&gt;Bounds().IntegerHeight()) / 2);
-			view-&gt;DrawBitmapAsync(fDownSortArrow, leftTop); 
+			view-&gt;DrawBitmapAsync(fDownSortArrow, leftTop);
 		} else {
 			BPoint leftTop(upperLeft.x, drawRect.top + (drawRect.IntegerHeight()
 				- fUpSortArrow-&gt;Bounds().IntegerHeight()) / 2);
@@ -2497,7 +2539,7 @@
 
 		if (columnLeftEdge &gt; invalidRect.right)
 			break;
-			
+
 		if (columnLeftEdge + column-&gt;Width() &gt;= invalidRect.left) {
 			BRect titleRect(columnLeftEdge, 0,
 				columnLeftEdge + column-&gt;Width(), fVisibleRect.Height());
@@ -2524,14 +2566,14 @@
 		DrawTitle(this, titleRect, NULL, false);
 	}
 
-#if DRAG_TITLE_OUTLINE	
-	// (Internal) Column Drag Indicator 
+#if DRAG_TITLE_OUTLINE
+	// (Internal) Column Drag Indicator
 	if (fCurrentState == DRAG_COLUMN_INSIDE_TITLE) {
 		BRect dragRect(fSelectedColumnRect);
 		dragRect.OffsetTo(fCurrentDragPosition.x - fClickPoint.x, 0);
 		if (dragRect.Intersects(invalidRect)) {
 			SetHighColor(0, 0, 255);
-			StrokeRect(dragRect);	
+			StrokeRect(dragRect);
 		}
 	}
 #endif
@@ -2584,7 +2626,7 @@
 {
 	if(fEditMode)
 		return;
-		
+
 	int32 buttons = 1;
 	Window()-&gt;CurrentMessage()-&gt;FindInt32(&quot;buttons&quot;, &amp;buttons);
 	if (buttons == B_SECONDARY_MOUSE_BUTTON
@@ -2611,7 +2653,7 @@
 		fColumnPop-&gt;Go(ConvertToScreen(position), true, false, sticky, true);
 		return;
 	}
-	
+
 	fResizingFirstColumn = true;
 	float leftEdge = MAX(kLeftMargin, fMasterView-&gt;LatchWidth());
 	for (int index = 0; index &lt; fColumns-&gt;CountItems(); index++) {
@@ -2623,7 +2665,7 @@
 			break;
 
 		//	Check for resizing a column
-		float rightEdge = leftEdge + column-&gt;Width();			
+		float rightEdge = leftEdge + column-&gt;Width();
 
 		if (column-&gt;ShowHeading()) {
 			if (position.x &gt; rightEdge - kColumnResizeAreaWidth / 2
@@ -2650,7 +2692,7 @@
 			fResizingFirstColumn = false;
 
 			//	Check for clicking on a column.
-			if (position.x &gt; leftEdge &amp;&amp; position.x &lt; rightEdge) {		
+			if (position.x &gt; leftEdge &amp;&amp; position.x &lt; rightEdge) {
 				fCurrentState = PRESSING_COLUMN;
 				fSelectedColumn = column;
 				fSelectedColumnRect.Set(leftEdge, 0, rightEdge,
@@ -2706,7 +2748,7 @@
 						fCurrentState = DRAG_COLUMN_OUTSIDE_TITLE;
 						fSelectedColumn-&gt;SetVisible(false);
 						BRect dragRect(fSelectedColumnRect);
-		
+
 						// There is a race condition where the mouse may have
 						// moved by the time we get to handle this message.
 						// If the user drags a column very quickly, this
@@ -2728,7 +2770,7 @@
 
 			break;
 		}
-			
+
 		case DRAG_COLUMN_INSIDE_TITLE: {
 			if (transit == B_EXITED_VIEW
 				&amp;&amp; (fColumnFlags &amp; B_ALLOW_COLUMN_REMOVE)) {
@@ -2749,7 +2791,7 @@
 				DragSelectedColumn(position);
 			}
 
-#if DRAG_TITLE_OUTLINE		
+#if DRAG_TITLE_OUTLINE
 			// Set up the invalid rect to include the rect for the previous
 			// position of the drag rect, as well as the new one.
 			BRect invalidRect(fSelectedColumnRect);
@@ -2758,13 +2800,13 @@
 				invalidRect.left -= fCurrentDragPosition.x - position.x;
 			else

[... truncated: 884 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016585.html">[Haiku-commits] r30682 -	haiku/trunk/src/apps/debuganalyzer/gui/table
</A></li>
	<LI>Next message: <A HREF="016587.html">[Haiku-commits] r30684 -	haiku/trunk/src/apps/debuganalyzer/gui/table
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16586">[ date ]</a>
              <a href="thread.html#16586">[ thread ]</a>
              <a href="subject.html#16586">[ subject ]</a>
              <a href="author.html#16586">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
