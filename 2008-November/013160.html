<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28416 - in haiku/trunk: headers/private/input	src/add-ons/input_server/devices	src/add-ons/input_server/devices/touchpad	src/add-ons/kernel/bus_managers/ps2 src/preferences	src/preferences/touchpad
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28416%20-%20in%20haiku/trunk%3A%20headers/private/input%0A%09src/add-ons/input_server/devices%0A%09src/add-ons/input_server/devices/touchpad%0A%09src/add-ons/kernel/bus_managers/ps2%20src/preferences%0A%09src/preferences/touchpad&In-Reply-To=%3C200811011048.mA1AmnfV008779%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013159.html">
   <LINK REL="Next"  HREF="013165.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28416 - in haiku/trunk: headers/private/input	src/add-ons/input_server/devices	src/add-ons/input_server/devices/touchpad	src/add-ons/kernel/bus_managers/ps2 src/preferences	src/preferences/touchpad</H1>
    <B>stippi at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28416%20-%20in%20haiku/trunk%3A%20headers/private/input%0A%09src/add-ons/input_server/devices%0A%09src/add-ons/input_server/devices/touchpad%0A%09src/add-ons/kernel/bus_managers/ps2%20src/preferences%0A%09src/preferences/touchpad&In-Reply-To=%3C200811011048.mA1AmnfV008779%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28416 - in haiku/trunk: headers/private/input	src/add-ons/input_server/devices	src/add-ons/input_server/devices/touchpad	src/add-ons/kernel/bus_managers/ps2 src/preferences	src/preferences/touchpad">stippi at mail.berlios.de
       </A><BR>
    <I>Sat Nov  1 11:48:49 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="013159.html">[Haiku-commits] r28415 - haiku/trunk/src/kits/media
</A></li>
        <LI>Next message: <A HREF="013165.html">[Haiku-commits] r28416 - in haiku/trunk: headers/private/input src/add-ons/input_server/devices	src/add-ons/input_server/devices/touchpad src/add-ons/kernel/bus_managers/ps2 src/preferences	src/preferences/touchpad
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13160">[ date ]</a>
              <a href="thread.html#13160">[ thread ]</a>
              <a href="subject.html#13160">[ subject ]</a>
              <a href="author.html#13160">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2008-11-01 11:48:35 +0100 (Sat, 01 Nov 2008)
New Revision: 28416
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28416&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28416&amp;view=rev</A>

Added:
   haiku/trunk/headers/private/input/touchpad_driver.h
   haiku/trunk/headers/private/input/touchpad_settings.h
   haiku/trunk/src/add-ons/input_server/devices/touchpad/
   haiku/trunk/src/add-ons/input_server/devices/touchpad/Jamfile
   haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.cpp
   haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/movement_maker.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/movement_maker.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_standart_mouse.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_standart_mouse.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_synaptics.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_synaptics.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_trackpoint.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_trackpoint.h
   haiku/trunk/src/preferences/touchpad/
   haiku/trunk/src/preferences/touchpad/Jamfile
   haiku/trunk/src/preferences/touchpad/Touchpad.rdef
   haiku/trunk/src/preferences/touchpad/TouchpadPref.cpp
   haiku/trunk/src/preferences/touchpad/TouchpadPref.h
   haiku/trunk/src/preferences/touchpad/TouchpadPrefView.cpp
   haiku/trunk/src/preferences/touchpad/TouchpadPrefView.h
   haiku/trunk/src/preferences/touchpad/main.cpp
Modified:
   haiku/trunk/headers/private/input/kb_mouse_driver.h
   haiku/trunk/src/add-ons/input_server/devices/Jamfile
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/Jamfile
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_common.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_common.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_defs.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_dev.c
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_dev.h
   haiku/trunk/src/add-ons/kernel/bus_managers/ps2/ps2_mouse.c
   haiku/trunk/src/preferences/Jamfile
Log:
Patch by Clemens Zeilder:
* Implemented Synaptics touchpad support in the PS2 bus_manager by
  refactoring/splitting the structure some and adding touchpad device
  handling.
* Implemented Touchpad input_server device add-on
* Created Touchpad preflet for configuring advances Synaptics touchpad
  options like scroll region (both horizontal and vertical) as well
  as other neat stuff

Thanks a lot, Clemens!


Modified: haiku/trunk/headers/private/input/kb_mouse_driver.h
===================================================================
--- haiku/trunk/headers/private/input/kb_mouse_driver.h	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/headers/private/input/kb_mouse_driver.h	2008-11-01 10:48:35 UTC (rev 28416)
@@ -62,6 +62,8 @@
 	MS_GET_CLICKSPEED,
 	MS_SET_CLICKSPEED,
 	MS_NUM_SERIAL_MICE,
+	MS_IS_TOUCHPAD,
+	MS_SET_TOUCHPAD_SETTINGS,
 	
 	IIC_WRITE = B_DEVICE_OP_CODES_END + 200, 
 	RESTART_SYSTEM,
@@ -117,6 +119,25 @@
   float		tilt_y;
 } tablet_movement;
 
+#define B_ONE_FINGER	0x01
+#define B_TWO_FINGER	0x02
+#define B_MULTI_FINGER	0x04
+#define B_PEN			0x08
+
+typedef struct
+{
+	uint8		buttons;
+	uint32		xPosition;
+	uint32		yPosition;
+	uint8		zPressure;
+	uint8		fingers;
+	bool		gesture;
+	uint8		fingerWidth;
+	// 1 - 4	normal width
+	// 5 - 11	very wide finger or palm
+	// 12		maximum reportable width; extrem wide contact
+} touchpad_movement;
+
 #ifdef __cplusplus
 }
 #endif

Added: haiku/trunk/headers/private/input/touchpad_driver.h
===================================================================
--- haiku/trunk/headers/private/input/touchpad_driver.h	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/headers/private/input/touchpad_driver.h	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,38 @@
+//
+// kb_mouse_driver.h
+//
+#ifndef _TOUCHPAD_DRIVER_H
+#define _TOUCHPAD_DRIVER_H
+
+#include &lt;SupportDefs.h&gt;
+#include &lt;Drivers.h&gt;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define B_ONE_FINGER	0x01
+#define B_TWO_FINGER	0x02
+#define B_MULTI_FINGER	0x04
+#define B_PEN			0x08
+
+typedef struct {
+	uint8		buttons;
+	uint32		xPosition;
+	uint32		yPosition;
+	uint8		zPressure;
+	uint8		fingers;
+	bool		gesture;
+	uint8		fingerWidth;
+	// 1 - 4	normal width
+	// 5 - 11	very wide finger or palm
+	// 12		maximum reportable width; extrem wide contact
+} touchpad_movement;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+

Added: haiku/trunk/headers/private/input/touchpad_settings.h
===================================================================
--- haiku/trunk/headers/private/input/touchpad_settings.h	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/headers/private/input/touchpad_settings.h	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2001-2008, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef TOUCHPAD_SETTINGS_H
+#define TOUCHPAD_SETTINGS_H
+
+#include &lt;SupportDefs.h&gt;
+
+
+typedef struct {
+	bool	scroll_twofinger;
+	bool	scroll_multifinger;
+	float	scroll_rightrange;		// from 0 to 1
+	float	scroll_bottomrange;		// from 0 to 1
+	uint16	scroll_xstepsize;
+	uint16	scroll_ystepsize;
+	uint8	scroll_acceleration;	// from 0 to 20
+
+	uint8	tapgesture_sensibility;	// 0 : no tapgesture
+									// 20: very light tip is enough (default)
+} touchpad_settings;
+
+
+const static touchpad_settings kDefaultTouchpadSettings = {
+	true,
+	true,
+	0.15,
+	0.15,
+	7,
+	10,
+	10,
+	20
+};
+
+#define TOUCHPAD_SETTINGS_FILE &quot;Touchpad_settings&quot;
+
+
+#endif	/* TOUCHPAD_SETTINGS_H */

Modified: haiku/trunk/src/add-ons/input_server/devices/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/input_server/devices/Jamfile	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/input_server/devices/Jamfile	2008-11-01 10:48:35 UTC (rev 28416)
@@ -5,5 +5,6 @@
 SubInclude HAIKU_TOP src add-ons input_server devices mouse ;
 #SubInclude HAIKU_TOP src add-ons input_server devices serial_mouse ;
 #SubInclude HAIKU_TOP src add-ons input_server devices tablet ;
+SubInclude HAIKU_TOP src add-ons input_server devices touchpad ;
 SubInclude HAIKU_TOP src add-ons input_server devices wacom ;
 

Added: haiku/trunk/src/add-ons/input_server/devices/touchpad/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/input_server/devices/touchpad/Jamfile	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/input_server/devices/touchpad/Jamfile	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,13 @@
+SubDir HAIKU_TOP src add-ons input_server devices touchpad ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+UsePrivateHeaders input ;
+
+Addon &lt;input&gt;touchpad :
+	TouchpadInputDevice.cpp
+	: be input_server ;
+
+Package haiku-inputkit-cvs :
+        &lt;input&gt;touchpad :
+        boot home config add-ons input_server devices ;

Added: haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.cpp
===================================================================
--- haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.cpp	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.cpp	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,685 @@
+/*
+ * Copyright 2004-2007, Haiku.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Stefano Ceccherini (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">stefano.ceccherini at gmail.com</A>)
+ *		J&#233;r&#244;me Duval
+ *		Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de</A>
+ */
+
+
+#include &quot;TouchpadInputDevice.h&quot;
+#include &quot;kb_mouse_driver.h&quot;
+#include &quot;kb_mouse_settings.h&quot;
+#include &quot;touchpad_settings.h&quot;
+
+#include &lt;Debug.h&gt;
+#include &lt;Directory.h&gt;
+#include &lt;Entry.h&gt;
+#include &lt;File.h&gt;
+#include &lt;FindDirectory.h&gt;
+#include &lt;NodeMonitor.h&gt;
+#include &lt;Path.h&gt;
+#include &lt;String.h&gt;
+#include &lt;View.h&gt;
+
+#include &lt;errno.h&gt;
+#include &lt;new&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+
+#if DEBUG
+FILE *TouchpadInputDevice::sLogFile = NULL;
+#	define LOG_ERR(text...) LOG(text)
+#else
+#	define LOG(text...)
+#	define LOG_ERR(text...) fprintf(stderr, text)
+#endif
+
+#define CALLED() LOG(&quot;%s\n&quot;, __PRETTY_FUNCTION__)
+
+const static uint32 kMouseThreadPriority = B_FIRST_REAL_TIME_PRIORITY + 4;
+
+// &quot;/dev/&quot; is automatically prepended by StartMonitoringDevice()
+const static char *kTouchpadDevicesDirectoryPS2 = &quot;input/touchpad/ps2&quot;;
+
+
+class TouchpadDevice {
+	public:
+		TouchpadDevice(BInputServerDevice&amp; target, const char* path);
+		~TouchpadDevice();
+
+		status_t Start();
+		void Stop();
+
+		status_t UpdateSettings();
+
+		const char* Path() const { return fPath.String(); }
+		input_device_ref* DeviceRef() { return &fDeviceRef; }
+
+		bool IsTouchpad() { return fIsTouchpad; }
+		status_t ReadTouchpadSettingsMsg(BMessage* msg);
+		status_t UpdateTouchpadSettings();
+
+	private:
+		void _Run();
+		static status_t _ThreadFunction(void *arg);
+
+		BMessage* _BuildMouseMessage(uint32 what, uint64 when, uint32 buttons,
+					int32 deltaX, int32 deltaY) const;
+		void _ComputeAcceleration(const mouse_movement&amp; movements,
+					int32&amp; deltaX, int32&amp; deltaY) const;
+		uint32 _RemapButtons(uint32 buttons) const;
+
+		char* _BuildShortName() const;
+
+		status_t GetSettingsPath(BPath &amp;path);
+
+	private:
+		BInputServerDevice&amp; fTarget;
+		BString	fPath;
+		int fDevice;
+
+		input_device_ref fDeviceRef;
+		mouse_settings fSettings;
+		bool fDeviceRemapsButtons;
+
+		thread_id fThread;
+		volatile bool fActive;
+
+		bool fIsTouchpad;
+		touchpad_settings fTouchpadSettings;
+};
+
+
+#if DEBUG
+inline void
+LOG(const char *fmt, ...)
+{
+	char buf[1024];
+	va_list ap;
+	va_start(ap, fmt);
+	vsprintf(buf, fmt, ap); va_end(ap);
+	fputs(buf, TouchpadInputDevice::sLogFile); fflush(TouchpadInputDevice::sLogFile);
+}
+#endif
+
+
+extern &quot;C&quot; BInputServerDevice *
+instantiate_input_device()
+{
+	return new (std::nothrow) TouchpadInputDevice();
+}
+
+
+//	#pragma mark -
+
+
+TouchpadDevice::TouchpadDevice(BInputServerDevice&amp; target, const char *driverPath)
+	:
+	fTarget(target),
+	fDevice(-1),
+	fThread(-1),
+	fActive(false),
+	fIsTouchpad(false)
+{
+	fPath = driverPath;
+
+	fDeviceRef.name = _BuildShortName();
+	fDeviceRef.type = B_POINTING_DEVICE;
+	fDeviceRef.cookie = this;
+
+#ifdef HAIKU_TARGET_PLATFORM_HAIKU
+	fSettings.map.button[0] = B_PRIMARY_MOUSE_BUTTON;
+	fSettings.map.button[1] = B_SECONDARY_MOUSE_BUTTON;
+	fSettings.map.button[2] = B_TERTIARY_MOUSE_BUTTON;
+#endif
+
+	fDeviceRemapsButtons = false;
+};
+
+
+TouchpadDevice::~TouchpadDevice()
+{
+	if (fActive)
+		Stop();
+
+	free(fDeviceRef.name);
+}
+
+
+status_t
+TouchpadDevice::GetSettingsPath(BPath &amp;path)
+{
+	status_t status = find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path);
+	if(status &lt; B_OK)
+		return status;
+	path.Append(TOUCHPAD_SETTINGS_FILE);
+	return B_OK;
+}
+
+
+status_t
+TouchpadDevice::Start()
+{
+	fDevice = open(fPath.String(), O_RDWR);
+	if (fDevice &lt; 0)
+		return errno;
+
+	// touchpad settings
+	if(ioctl(fDevice, MS_IS_TOUCHPAD, NULL) == B_OK){
+		LOG(&quot;is touchpad %s\n&quot;, fPath.String());
+		fIsTouchpad = true;
+	}
+
+	fTouchpadSettings = kDefaultTouchpadSettings;
+
+	BPath path;
+	status_t status = GetSettingsPath(path);
+	BFile settingsFile(path.Path(), B_READ_ONLY);
+	if(status == B_OK &amp;&amp; settingsFile.InitCheck() == B_OK){
+		if(settingsFile.Read(&amp;fTouchpadSettings, sizeof(touchpad_settings))
+			!= sizeof(touchpad_settings))
+		{
+			LOG(&quot;failed to load settings\n&quot;);
+		}
+	}
+
+	UpdateTouchpadSettings();
+
+	UpdateSettings();
+
+	char threadName[B_OS_NAME_LENGTH];
+	snprintf(threadName, B_OS_NAME_LENGTH, &quot;%s watcher&quot;, fDeviceRef.name);
+
+	fThread = spawn_thread(_ThreadFunction, threadName,
+		kMouseThreadPriority, (void *)this);
+
+	if (fThread &lt; B_OK)
+		status = fThread;
+	else {
+		fActive = true;
+		status = resume_thread(fThread);
+	}
+
+	if (status &lt; B_OK) {
+		LOG_ERR(&quot;%s: can't spawn/resume watching thread: %s\n&quot;,
+			fDeviceRef.name, strerror(status));
+		close(fDevice);
+		return status;
+	}
+
+	return B_OK;
+}
+
+
+void
+TouchpadDevice::Stop()
+{
+	fActive = false;
+		// this will stop the thread as soon as it reads the next packet
+
+	if (fThread &gt;= B_OK) {
+		// unblock the thread, which might wait on a semaphore.
+		suspend_thread(fThread);
+		resume_thread(fThread);
+
+		status_t dummy;
+		wait_for_thread(fThread, &amp;dummy);
+	}
+
+	close(fDevice);
+}
+
+
+status_t
+TouchpadDevice::UpdateSettings()
+{
+	CALLED();
+
+	// retrieve current values
+
+	if (get_mouse_map(&amp;fSettings.map) != B_OK)
+		LOG_ERR(&quot;error when get_mouse_map\n&quot;);
+	else
+		fDeviceRemapsButtons = ioctl(fDevice, MS_SET_MAP, &amp;fSettings.map) == B_OK;
+
+	if (get_click_speed(&amp;fSettings.click_speed) != B_OK)
+		LOG_ERR(&quot;error when get_click_speed\n&quot;);
+	else
+		ioctl(fDevice, MS_SET_CLICKSPEED, &amp;fSettings.click_speed);
+
+	if (get_mouse_speed(&amp;fSettings.accel.speed) != B_OK)
+		LOG_ERR(&quot;error when get_mouse_speed\n&quot;);
+	else {
+		if (get_mouse_acceleration(&amp;fSettings.accel.accel_factor) != B_OK)
+			LOG_ERR(&quot;error when get_mouse_acceleration\n&quot;);
+		else {
+			mouse_accel accel;
+			ioctl(fDevice, MS_GET_ACCEL, &amp;accel);
+			accel.speed = fSettings.accel.speed;
+			accel.accel_factor = fSettings.accel.accel_factor;
+			ioctl(fDevice, MS_SET_ACCEL, &amp;fSettings.accel);
+		}
+	}
+
+	if (get_mouse_type(&amp;fSettings.type) != B_OK)
+		LOG_ERR(&quot;error when get_mouse_type\n&quot;);
+	else
+		ioctl(fDevice, MS_SET_TYPE, &amp;fSettings.type);
+
+	return B_OK;
+
+}
+
+
+status_t
+TouchpadDevice::ReadTouchpadSettingsMsg(BMessage* msg)
+{
+	msg-&gt;FindBool(&quot;scroll_twofinger&quot;, &amp;(fTouchpadSettings.scroll_twofinger));
+	msg-&gt;FindBool(&quot;scroll_multifinger&quot;, &amp;(fTouchpadSettings.scroll_multifinger));
+	msg-&gt;FindFloat(&quot;scroll_rightrange&quot;, &amp;(fTouchpadSettings.scroll_rightrange));
+	msg-&gt;FindFloat(&quot;scroll_bottomrange&quot;, &amp;(fTouchpadSettings.scroll_bottomrange));
+	msg-&gt;FindInt16(&quot;scroll_xstepsize&quot;, (int16*)&amp;(fTouchpadSettings.scroll_xstepsize));
+	msg-&gt;FindInt16(&quot;scroll_ystepsize&quot;, (int16*)&amp;(fTouchpadSettings.scroll_ystepsize));
+	msg-&gt;FindInt8(&quot;scroll_acceleration&quot;, (int8*)&amp;(fTouchpadSettings.scroll_acceleration));
+	msg-&gt;FindInt8(&quot;tapgesture_sensibility&quot;, (int8*)&amp;(fTouchpadSettings.tapgesture_sensibility));
+
+	return B_OK;
+}
+
+
+status_t
+TouchpadDevice::UpdateTouchpadSettings()
+{
+	if(fIsTouchpad){
+		ioctl(fDevice, MS_SET_TOUCHPAD_SETTINGS, &amp;fTouchpadSettings);
+		return B_OK;
+	}
+	return B_ERROR;
+}
+
+
+void
+TouchpadDevice::_Run()
+{
+	uint32 lastButtons = 0;
+
+	while (fActive) {
+		mouse_movement movements;
+		memset(&amp;movements, 0, sizeof(movements));
+
+		if (ioctl(fDevice, MS_READ, &amp;movements) != B_OK)
+			return;
+
+		uint32 buttons = lastButtons ^ movements.buttons;
+
+		uint32 remappedButtons = _RemapButtons(movements.buttons);
+		int32 deltaX, deltaY;
+		_ComputeAcceleration(movements, deltaX, deltaY);
+
+	  /*LOG(&quot;%s: buttons: 0x%lx, x: %ld, y: %ld, clicks:%ld, wheel_x:%ld, wheel_y:%ld\n&quot;,
+			device-&gt;device_ref.name, movements.buttons, movements.xdelta, movements.ydelta,
+			movements.clicks, movements.wheel_xdelta, movements.wheel_ydelta);
+		LOG(&quot;%s: x: %ld, y: %ld\n&quot;, device-&gt;device_ref.name, deltaX, deltaY);*/
+
+		BMessage *message = NULL;
+
+		// Send single messages for each event
+
+		if (buttons != 0) {
+			bool pressedButton = (buttons &amp; movements.buttons) &gt; 0;
+			BMessage* message = _BuildMouseMessage(
+				pressedButton ? B_MOUSE_DOWN : B_MOUSE_UP,
+				movements.timestamp, remappedButtons, deltaX, deltaY);
+			if (message != NULL) {
+				if (pressedButton) {
+					message-&gt;AddInt32(&quot;clicks&quot;, movements.clicks);
+					LOG(&quot;B_MOUSE_DOWN\n&quot;);
+				} else
+					LOG(&quot;B_MOUSE_UP\n&quot;);
+
+				fTarget.EnqueueMessage(message);
+				lastButtons = movements.buttons;
+			}
+		}
+
+		if (movements.xdelta != 0 || movements.ydelta != 0) {
+			BMessage* message = _BuildMouseMessage(B_MOUSE_MOVED,
+				movements.timestamp, remappedButtons, deltaX, deltaY);
+			if (message != NULL)
+				fTarget.EnqueueMessage(message);
+		}
+
+		if ((movements.wheel_ydelta != 0) || (movements.wheel_xdelta != 0)) {
+			message = new BMessage(B_MOUSE_WHEEL_CHANGED);
+			if (message == NULL)
+				continue;
+
+			if (message-&gt;AddInt64(&quot;when&quot;, movements.timestamp) == B_OK
+				&amp;&amp; message-&gt;AddFloat(&quot;be:wheel_delta_x&quot;, movements.wheel_xdelta) == B_OK
+				&amp;&amp; message-&gt;AddFloat(&quot;be:wheel_delta_y&quot;, movements.wheel_ydelta) == B_OK)
+				fTarget.EnqueueMessage(message);
+			else
+				delete message;
+		}
+	}
+}
+
+
+status_t
+TouchpadDevice::_ThreadFunction(void* arg)
+{
+	TouchpadDevice* device = (TouchpadDevice *)arg;
+	device-&gt;_Run();
+	return B_OK;
+}
+
+
+BMessage*
+TouchpadDevice::_BuildMouseMessage(uint32 what, uint64 when, uint32 buttons,
+	int32 deltaX, int32 deltaY) const
+{
+	BMessage* message = new BMessage(what);
+	if (message == NULL)
+		return NULL;
+
+	if (message-&gt;AddInt64(&quot;when&quot;, when) &lt; B_OK
+		|| message-&gt;AddInt32(&quot;buttons&quot;, buttons) &lt; B_OK
+		|| message-&gt;AddInt32(&quot;x&quot;, deltaX) &lt; B_OK
+		|| message-&gt;AddInt32(&quot;y&quot;, deltaY) &lt; B_OK) {
+		delete message;
+		return NULL;
+	}
+
+	return message;
+}
+
+
+void
+TouchpadDevice::_ComputeAcceleration(const mouse_movement&amp; movements,
+	int32&amp; deltaX, int32&amp; deltaY) const
+{
+	// basic mouse speed
+	deltaX = movements.xdelta * fSettings.accel.speed &gt;&gt; 16;
+	deltaY = movements.ydelta * fSettings.accel.speed &gt;&gt; 16;
+
+	// acceleration
+	double acceleration = 1;
+	if (fSettings.accel.accel_factor) {
+		acceleration = 1 + sqrt(deltaX * deltaX + deltaY * deltaY)
+			* fSettings.accel.accel_factor / 524288.0;
+	}
+
+	// make sure that we move at least one pixel (if there was a movement)
+	if (deltaX &gt; 0)
+		deltaX = (int32)floor(deltaX * acceleration);
+	else
+		deltaX = (int32)ceil(deltaX * acceleration);
+
+	if (deltaY &gt; 0)
+		deltaY = (int32)floor(deltaY * acceleration);
+	else
+		deltaY = (int32)ceil(deltaY * acceleration);
+}
+
+
+uint32
+TouchpadDevice::_RemapButtons(uint32 buttons) const
+{
+	if (fDeviceRemapsButtons)
+		return buttons;
+
+	uint32 newButtons = 0;
+	for (int32 i = 0; buttons; i++) {
+		if (buttons &amp; 0x1) {
+#if defined(HAIKU_TARGET_PLATFORM_HAIKU) || defined(HAIKU_TARGET_PLATFORM_DANO)
+			newButtons |= fSettings.map.button[i];
+#else
+			if (i == 0)
+				newButtons |= fSettings.map.left;
+			if (i == 1)
+				newButtons |= fSettings.map.right;
+			if (i == 2)
+				newButtons |= fSettings.map.middle;
+#endif
+		}
+		buttons &gt;&gt;= 1;
+	}
+
+	return newButtons;
+}
+
+
+char *
+TouchpadDevice::_BuildShortName() const
+{
+	BString string(fPath);
+	BString name;
+
+	int32 slash = string.FindLast(&quot;/&quot;);
+	string.CopyInto(name, slash + 1, string.Length() - slash);
+	//int32 index = atoi(name.String()) + 1;
+
+	BString final = &quot;Touchpad_&quot;;
+	final+= name;
+
+	LOG(&quot;NAME %s, %s\n&quot;, final.String(), fPath.String());
+
+	return strdup(final.String());
+}
+
+
+//	#pragma mark -
+
+
+TouchpadInputDevice::TouchpadInputDevice()
+{
+#if DEBUG
+	sLogFile = fopen(&quot;/var/log/mouse_device_log.log&quot;, &quot;a&quot;);
+#endif
+	CALLED();
+
+	StartMonitoringDevice(kTouchpadDevicesDirectoryPS2);
+
+	_RecursiveScan(kTouchpadDevicesDirectoryPS2);
+}
+
+
+TouchpadInputDevice::~TouchpadInputDevice()
+{
+	CALLED();
+	StopMonitoringDevice(kTouchpadDevicesDirectoryPS2);
+
+	int32 count = fDevices.CountItems();
+	while (count-- &gt; 0) {
+		delete (TouchpadDevice *)fDevices.RemoveItem(count);
+	}
+
+#if DEBUG
+	fclose(sLogFile);
+#endif
+}
+
+
+status_t
+TouchpadInputDevice::InitCheck()
+{
+	CALLED();
+	return BInputServerDevice::InitCheck();
+}
+
+
+status_t
+TouchpadInputDevice::Start(const char *name, void *cookie)
+{
+	LOG(&quot;%s(%s)\n&quot;, __PRETTY_FUNCTION__, name);
+	TouchpadDevice* device = (TouchpadDevice*)cookie;
+
+	return device-&gt;Start();
+}
+
+
+status_t
+TouchpadInputDevice::Stop(const char *name, void *cookie)
+{
+	LOG(&quot;%s(%s)\n&quot;, __PRETTY_FUNCTION__, name);
+	TouchpadDevice* device = (TouchpadDevice*)cookie;
+
+	device-&gt;Stop();
+	return B_OK;
+}
+
+
+status_t
+TouchpadInputDevice::Control(const char* name, void* cookie,
+	uint32 command, BMessage* message)
+{
+	LOG(&quot;%s(%s, code: %lu)\n&quot;, __PRETTY_FUNCTION__, name, command);
+	TouchpadDevice* device = (TouchpadDevice*)cookie;
+
+	if (command == MS_SET_TOUCHPAD_SETTINGS){
+		device-&gt;ReadTouchpadSettingsMsg(message);
+		return device-&gt;UpdateTouchpadSettings();
+	}
+
+	if (command == B_NODE_MONITOR)
+		return _HandleMonitor(message);
+
+	if (command &gt;= B_MOUSE_TYPE_CHANGED
+		&amp;&amp; command &lt;= B_MOUSE_ACCELERATION_CHANGED)
+		return device-&gt;UpdateSettings();
+
+	return B_BAD_VALUE;
+}
+
+
+// TODO: Test this. USB doesn't work on my machine
+status_t
+TouchpadInputDevice::_HandleMonitor(BMessage* message)
+{
+	CALLED();
+
+	int32 opcode;
+	if (message-&gt;FindInt32(&quot;opcode&quot;, &amp;opcode) &lt; B_OK)
+		return B_BAD_VALUE;
+
+	if (opcode != B_ENTRY_CREATED &amp;&amp; opcode != B_ENTRY_REMOVED)
+		return B_OK;
+
+	BEntry entry;
+	BPath path;
+	dev_t device;
+	ino_t directory;
+	const char *name;
+
+	if (message-&gt;FindInt32(&quot;device&quot;, &amp;device) &lt; B_OK
+		|| message-&gt;FindInt64(&quot;directory&quot;, &amp;directory) &lt; B_OK
+		|| message-&gt;FindString(&quot;name&quot;, &amp;name) &lt; B_OK)
+		return B_BAD_VALUE;
+
+	entry_ref ref(device, directory, name);
+	status_t status;
+
+	if ((status = entry.SetTo(&amp;ref)) != B_OK)
+		return status;
+	if ((status = entry.GetPath(&amp;path)) != B_OK)
+		return status;
+	if ((status = path.InitCheck()) != B_OK)
+		return status;
+
+	if (opcode == B_ENTRY_CREATED)
+		status = _AddDevice(path.Path());
+	else
+		status = _RemoveDevice(path.Path());
+
+	return status;
+}
+
+
+TouchpadDevice*
+TouchpadInputDevice::_FindDevice(const char *path)
+{
+	CALLED();
+
+	for (int32 i = fDevices.CountItems(); i-- &gt; 0;) {
+		TouchpadDevice* device = (TouchpadDevice*)fDevices.ItemAt(i);
+		if (!strcmp(device-&gt;Path(), path))
+			return device;
+	}
+
+	return NULL;
+}
+
+
+status_t
+TouchpadInputDevice::_AddDevice(const char *path)
+{
+	CALLED();
+
+	TouchpadDevice* device = new (std::nothrow) TouchpadDevice(*this, path);
+	if (!device) {
+		LOG(&quot;No memory\n&quot;);
+		return B_NO_MEMORY;
+	}
+
+	if (!fDevices.AddItem(device)) {
+		delete device;
+		return B_NO_MEMORY;
+	}
+
+	input_device_ref *devices[2];
+	devices[0] = device-&gt;DeviceRef();
+	devices[1] = NULL;
+
+	return RegisterDevices(devices);
+}
+
+
+status_t
+TouchpadInputDevice::_RemoveDevice(const char *path)
+{
+	CALLED();
+
+	TouchpadDevice* device = _FindDevice(path);
+	if (device == NULL)
+		return B_ENTRY_NOT_FOUND;
+
+	fDevices.RemoveItem(device);
+
+	input_device_ref *devices[2];
+	devices[0] = device-&gt;DeviceRef();
+	devices[1] = NULL;
+
+	UnregisterDevices(devices);
+
+	delete device;
+	return B_OK;
+}
+
+
+void
+TouchpadInputDevice::_RecursiveScan(const char* directory)
+{
+	CALLED();
+
+	BEntry entry;
+	BDirectory dir(directory);
+	while (dir.GetNextEntry(&amp;entry) == B_OK) {
+		BPath path;
+		entry.GetPath(&amp;path);
+
+		if (!strcmp(path.Leaf(), &quot;serial&quot;)) {
+			// skip serial
+			continue;
+		}
+
+		if (entry.IsDirectory())
+			_RecursiveScan(path.Path());
+		else
+			_AddDevice(path.Path());
+	}
+}
+

Added: haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.h
===================================================================
--- haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.h	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/input_server/devices/touchpad/TouchpadInputDevice.h	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2004-2006, Haiku.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Stefano Ceccherini
+ */
+#ifndef MOUSE_INPUT_DEVICE_H
+#define MOUSE_INPUT_DEVICE_H
+
+
+#include &lt;InputServerDevice.h&gt;
+#include &lt;InterfaceDefs.h&gt;
+#include &lt;List.h&gt;
+
+#include &lt;stdio.h&gt;
+#define DEBUG 1
+
+class TouchpadDevice;
+
+class TouchpadInputDevice : public BInputServerDevice {
+	public:
+		TouchpadInputDevice();
+		~TouchpadInputDevice();
+
+		virtual status_t InitCheck();
+
+		virtual status_t Start(const char* name, void* cookie);
+		virtual status_t Stop(const char* name, void* cookie);
+
+		virtual status_t Control(const char* name, void* cookie,
+							uint32 command, BMessage* message);
+
+	private:
+		status_t _HandleMonitor(BMessage* message);
+		void _RecursiveScan(const char* directory);
+
+		TouchpadDevice* _FindDevice(const char* path);
+		status_t _AddDevice(const char* path);
+		status_t _RemoveDevice(const char* path);
+
+		BList fDevices;
+#ifdef DEBUG
+public:
+	static FILE *sLogFile;
+#endif
+};
+
+extern &quot;C&quot; BInputServerDevice* instantiate_input_device();
+
+#endif	// MOUSE_INPUT_DEVICE_H

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/ps2/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ps2/Jamfile	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ps2/Jamfile	2008-11-01 10:48:35 UTC (rev 28416)
@@ -9,6 +9,9 @@
 	ps2_dev.c
 	ps2_keyboard.c
 	ps2_module.c
-	ps2_mouse.c
+	ps2_standart_mouse.c
+	ps2_synaptics.c
+	ps2_trackpoint.c
 	ps2_service.c
+	movement_maker.c
 	;

Added: haiku/trunk/src/add-ons/kernel/bus_managers/ps2/movement_maker.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/ps2/movement_maker.c	2008-10-31 22:36:49 UTC (rev 28415)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/ps2/movement_maker.c	2008-11-01 10:48:35 UTC (rev 28416)
@@ -0,0 +1,278 @@
+#include &quot;movement_maker.h&quot;
+
+#include &lt;Debug.h&gt;
+#if 1
+#	define INFO(x...) dprintf(x)
+#else
+#	define INFO(x...)
+#endif
+
+typedef union
+{
+  float value;
+  /* FIXME: Assumes 32 bit int.  */
+  unsigned int word;
+} ieee_float_shape_type;
+
+/* Get a 32 bit int from a float.  */
+
+#define GET_FLOAT_WORD(i,d)					\
+do {								\
+  ieee_float_shape_type gf_u;					\
+  gf_u.value = (d);						\
+  (i) = gf_u.word;						\
+} while (0)
+
+/* Set a float from a 32 bit int.  */
+
+#define SET_FLOAT_WORD(d,i)					\
+do {								\
+  ieee_float_shape_type sf_u;					\
+  sf_u.word = (i);						\
+  (d) = sf_u.value;						\
+} while (0)
+
+static const float huge = 1.0e30;
+
+float
+floorf(float x)
+{
+	int32 i0,j0;
+	uint32 i;
+	GET_FLOAT_WORD(i0,x);
+	j0 = ((i0&gt;&gt;23)&amp;0xff)-0x7f;
+	if(j0&lt;23) {
+	    if(j0&lt;0) { 	/* raise inexact if x != 0 */
+		if(huge+x&gt;(float)0.0) {/* return 0*sign(x) if |x|&lt;1 */
+		    if(i0&gt;=0) {i0=0;}
+		    else if((i0&amp;0x7fffffff)!=0)
+			{ i0=0xbf800000;}
+		}
+	    } else {
+		i = (0x007fffff)&gt;&gt;j0;
+		if((i0&amp;i)==0) return x; /* x is integral */
+		if(huge+x&gt;(float)0.0) {	/* raise inexact flag */
+		    if(i0&lt;0) i0 += (0x00800000)&gt;&gt;j0;
+		    i0 &amp;= (~i);
+		}
+	    }
+	} else {
+	    if(j0==0x80) return x+x;	/* inf or NaN */
+	    else return x;		/* x is integral */
+	}
+	SET_FLOAT_WORD(x,i0);
+	return x;
+}
+
+
+float
+ceilf(float x)
+{
+	int32 i0,j0;

[... truncated: 3812 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013159.html">[Haiku-commits] r28415 - haiku/trunk/src/kits/media
</A></li>
	<LI>Next message: <A HREF="013165.html">[Haiku-commits] r28416 - in haiku/trunk: headers/private/input src/add-ons/input_server/devices	src/add-ons/input_server/devices/touchpad src/add-ons/kernel/bus_managers/ps2 src/preferences	src/preferences/touchpad
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13160">[ date ]</a>
              <a href="thread.html#13160">[ thread ]</a>
              <a href="subject.html#13160">[ subject ]</a>
              <a href="author.html#13160">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
