<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r28506 - in haiku/trunk/src/apps: aboutsystem	deskcalc deskcalc/mapm_4.9.5
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28506%20-%20in%20haiku/trunk/src/apps%3A%20aboutsystem%0A%09deskcalc%20deskcalc/mapm_4.9.5&In-Reply-To=%3C200811042047.mA4KlvpR015370%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="013270.html">
   <LINK REL="Next"  HREF="013275.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r28506 - in haiku/trunk/src/apps: aboutsystem	deskcalc deskcalc/mapm_4.9.5</H1>
    <B>stippi at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r28506%20-%20in%20haiku/trunk/src/apps%3A%20aboutsystem%0A%09deskcalc%20deskcalc/mapm_4.9.5&In-Reply-To=%3C200811042047.mA4KlvpR015370%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r28506 - in haiku/trunk/src/apps: aboutsystem	deskcalc deskcalc/mapm_4.9.5">stippi at mail.berlios.de
       </A><BR>
    <I>Tue Nov  4 21:47:57 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="013270.html">[Haiku-commits] r28505 - haiku/trunk/src/apps/soundrecorder
</A></li>
        <LI>Next message: <A HREF="013275.html">[Haiku-commits] r28506 - in haiku/trunk/src/apps: aboutsystem deskcalc deskcalc/mapm_4.9.5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13271">[ date ]</a>
              <a href="thread.html#13271">[ thread ]</a>
              <a href="subject.html#13271">[ subject ]</a>
              <a href="author.html#13271">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2008-11-04 21:47:41 +0100 (Tue, 04 Nov 2008)
New Revision: 28506
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=28506&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=28506&amp;view=rev</A>

Added:
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/README
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/m_apm.h
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/m_apm_lc.h
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm5sin.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_add.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_cpi.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_div.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_exp.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_fam.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_fft.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_flr.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_fpf.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_gcd.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_lg2.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_lg3.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_lg4.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_log.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_mul.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_pow.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_rcp.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_rnd.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_set.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapm_sin.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmasin.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmasn0.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmcbrt.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmcnst.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmfact.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmfmul.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmgues.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmhasn.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmhsin.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmipwr.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmistr.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmpwr2.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmrsin.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmsqrt.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmstck.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmutil.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmutl1.c
   haiku/trunk/src/apps/deskcalc/mapm_4.9.5/mapmutl2.c
Modified:
   haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp
   haiku/trunk/src/apps/deskcalc/CalcView.cpp
   haiku/trunk/src/apps/deskcalc/DeskCalc.cpp
   haiku/trunk/src/apps/deskcalc/ExpressionParser.cpp
   haiku/trunk/src/apps/deskcalc/ExpressionParser.h
   haiku/trunk/src/apps/deskcalc/Jamfile
Log:
Included &quot;Mike's Arbitrary Precision Math Library&quot; in DeskCalc (BSD style
license) and rebased the ExpressionParser from double on the MAPM data type.
Currently, the binary operators are not supported anymore, but the imprecise
calculations were getting on my nerves. I think a lot more neat functions
could now be supported, but I have not looked into it further. I also didn't
dare look closer at the C code of the library, but it seems to be well
tested. It's portable by all means, I guess even if the target platform has
8.3 char file names to hold the code... Luckily, the library inclused a C++
wrapper class for the data type (MAPM) which makes it fairly comfortable to
use and hides the ugly C stuff and messy memory management.

The result seems to be quite nice so far. Previously, I couldn't even calculate
my finances without eventually getting some rounding errors.


Modified: haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp
===================================================================
--- haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp	2008-11-04 20:47:41 UTC (rev 28506)
@@ -762,6 +762,12 @@
 		&quot;Copyright &quot; B_UTF8_COPYRIGHT &quot; 1996-1997 Jeff Prosise. &quot;
 		&quot;All rights reserved.&quot;);
 
+	// MAPM (Mike's Arbitrary Precision Math Library) used by DeskCalc
+	AddCopyrightEntry(&quot;MAPM&quot;,
+		&quot;Copyright &quot; B_UTF8_COPYRIGHT &quot;1999-2007 Michael C. Ring. &quot;
+		&quot;All rights reserved.&quot;,
+		&quot;<A HREF="http://tc.umn.edu/~ringx004">http://tc.umn.edu/~ringx004</A>&quot;);
+
 // OpenSound
 //	AddCopyrightEntry(&quot;OpenSound&quot;,
 //		&quot;Copyright &quot; B_UTF8_COPYRIGHT &quot; 1996-2008 4Front Technologies &quot;,

Modified: haiku/trunk/src/apps/deskcalc/CalcView.cpp
===================================================================
--- haiku/trunk/src/apps/deskcalc/CalcView.cpp	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/CalcView.cpp	2008-11-04 20:47:41 UTC (rev 28506)
@@ -774,9 +774,6 @@
 void
 CalcView::Evaluate()
 {
-	const double EXP_SWITCH_HI = 1e12; // # digits to switch from std-&gt;exp form
-	const double EXP_SWITCH_LO = 1e-12;
-
 	BString expression = fExpressionTextView-&gt;Text();
 
 	if (expression.Length() == 0) {
@@ -792,10 +789,8 @@
 		play_sound(&amp;zimp_ref, true, false, false);
 	}
 
-//printf(&quot;evaluate: %s\n&quot;, expression.String());
-
 	// evaluate expression
-	double value = 0.0;
+	BString value;
 
 	try {
 		ExpressionParser parser;
@@ -807,37 +802,8 @@
 		return;
 	}
 
-//printf(&quot;  -&gt; value: %f\n&quot;, value);
-
-	// beautify the expression
-	// TODO: see if this is necessary at all
-	char buf[64];
-	if (value == 0) {
-		strcpy(buf, &quot;0&quot;);
-	} else if (((value &lt;  EXP_SWITCH_HI) &amp;&amp; (value &gt;  EXP_SWITCH_LO)) ||
-			   ((value &gt; -EXP_SWITCH_HI) &amp;&amp; (value &lt; -EXP_SWITCH_LO))) {
-		// print in std form
-		sprintf(buf, &quot;%.13f&quot;, value);
-
-		// hack to remove surplus zeros!
-		if (strchr(buf, '.')) {
-			int32 i = strlen(buf) - 1;
-			for (; i &gt; 0; i--) {
-				if (buf[i] == '0')
-					buf[i] = '\0';
-				else
-					break;
-			}
-			if (buf[i] == '.')
-				buf[i] = '\0';
-		}
-	} else {
-		// print in exponential form
-		sprintf(buf, &quot;%e&quot;, value);
-	}
-		
 	// render new result to display
-	fExpressionTextView-&gt;SetExpression(buf);
+	fExpressionTextView-&gt;SetExpression(value.String());
 }
 
 

Modified: haiku/trunk/src/apps/deskcalc/DeskCalc.cpp
===================================================================
--- haiku/trunk/src/apps/deskcalc/DeskCalc.cpp	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/DeskCalc.cpp	2008-11-04 20:47:41 UTC (rev 28506)
@@ -33,7 +33,8 @@
 
 		try {
 			ExpressionParser parser;
-			printf(&quot;%f\n&quot;, parser.Evaluate(expression.String()));
+			BString result = parser.Evaluate(expression.String());
+			printf(&quot;%s\n&quot;, result.String());
 		} catch (ParseException e) {
 			printf(&quot;%s at %ld\n&quot;, e.message.String(), e.position + 1);
 			return 1;

Modified: haiku/trunk/src/apps/deskcalc/ExpressionParser.cpp
===================================================================
--- haiku/trunk/src/apps/deskcalc/ExpressionParser.cpp	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/ExpressionParser.cpp	2008-11-04 20:47:41 UTC (rev 28506)
@@ -12,8 +12,12 @@
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 
+#include &quot;m_apm.h&quot;
+
 #include &quot;ExpressionParser.h&quot;
 
+static const int32 kMaxDigits = 64;
+
 enum {
 	TOKEN_IDENTIFIER			= 'a',
 
@@ -44,7 +48,7 @@
 	Token()
 		: string(&quot;&quot;),
 		  type(TOKEN_NONE),
-		  value(0.0),
+		  value(0),
 		  position(0)
 	{
 	}
@@ -60,7 +64,7 @@
 	Token(const char* string, int32 length, int32 position, int32 type)
 		: string(string, length),
 		  type(type),
-		  value(0.0),
+		  value(0),
 		  position(position)
 	{
 	}
@@ -76,7 +80,7 @@
 
 	BString		string;
 	int32		type;
-	double		value;
+	MAPM		value;
 
 	int32		position;
 };
@@ -137,23 +141,30 @@
 				fCurrentChar++;
 			}
 			int32 length = fCurrentChar - begin;
-			temp &lt;&lt; &quot;&amp;_&quot;;
+			BString test = temp;
+			test &lt;&lt; &quot;&amp;_&quot;;
 			double value;
 			char t[2];
-			int32 matches = sscanf(temp.String(), &quot;%lf&amp;%s&quot;, &amp;value, t);
-			if (matches != 2)
-				throw ParseException(&quot;error in constant&quot;, _CurrentPos() - length);
+			int32 matches = sscanf(test.String(), &quot;%lf&amp;%s&quot;, &amp;value, t);
+			if (matches != 2) {
+				throw ParseException(&quot;error in constant&quot;,
+					_CurrentPos() - length);
+			}
 
-			fCurrentToken = Token(begin, length, _CurrentPos() - length, TOKEN_CONSTANT);
-			fCurrentToken.value = value;;
+			fCurrentToken = Token(begin, length, _CurrentPos() - length,
+				TOKEN_CONSTANT);
+			fCurrentToken.value = temp.String();
 
 		} else if (isalpha(*fCurrentChar)) {
 
 			const char* begin = fCurrentChar;
-			while (*fCurrentChar != 0 &amp;&amp; (isalpha(*fCurrentChar) || isdigit(*fCurrentChar)))
+			while (*fCurrentChar != 0 &amp;&amp; (isalpha(*fCurrentChar)
+				|| isdigit(*fCurrentChar))) {
 				fCurrentChar++;
+			}
 			int32 length = fCurrentChar - begin;
-			fCurrentToken = Token(begin, length, _CurrentPos() - length, TOKEN_IDENTIFIER);
+			fCurrentToken = Token(begin, length, _CurrentPos() - length,
+				TOKEN_IDENTIFIER);
 
 		} else {
 
@@ -172,7 +183,8 @@
 				case '&amp;':
 				case '|':
 				case '~':
-					fCurrentToken = Token(fCurrentChar, 1, _CurrentPos(), *fCurrentChar);
+					fCurrentToken = Token(fCurrentChar, 1, _CurrentPos(),
+						*fCurrentChar);
 					fCurrentChar++;
 					break;
 			
@@ -215,48 +227,73 @@
 }
 
 
-double
+BString
 ExpressionParser::Evaluate(const char* expressionString)
 {
 	fTokenizer-&gt;SetTo(expressionString);
 
-	double value = _ParseBinary();
+	MAPM value = _ParseBinary();
 	Token token = fTokenizer-&gt;NextToken();
 	if (token.type != TOKEN_END_OF_LINE)
 		throw ParseException(&quot;parse error&quot;, token.position);
 
-	return value;
+	if (value == 0)
+		return BString(&quot;0&quot;);
+
+	BString result;
+	char* buffer = result.LockBuffer(kMaxDigits + 1);
+		// + 1 for the decimal point
+	if (buffer == NULL)
+		throw ParseException(&quot;out of memory&quot;, 0);
+
+	value.toFixPtString(buffer, kMaxDigits);
+
+	// remove surplus zeros
+	int32 lastChar = strlen(buffer) - 1;
+	if (strchr(buffer, '.')) {
+		while (buffer[lastChar] == '0')
+			lastChar--;
+		if (buffer[lastChar] == '.')
+			lastChar--;
+	}
+	result.UnlockBuffer(lastChar + 1);
+
+	return result;
 }
 
 
-double
+MAPM
 ExpressionParser::_ParseBinary()
 {
-	double value = _ParseSum();
+	return _ParseSum();
+	// binary operation appearantly not supported by m_apm library,
+	// should not be too hard to implement though....
 
-	while (true) {
-		Token token = fTokenizer-&gt;NextToken();
-		switch (token.type) {
-			case TOKEN_AND:
-				value = (uint64)value &amp; (uint64)_ParseSum();
-				break;
-			case TOKEN_OR:
-				value = (uint64)value | (uint64)_ParseSum();
-				break;
-
-			default:
-				fTokenizer-&gt;RewindToken();
-				return value;
-		}
-	}
+//	double value = _ParseSum();
+//
+//	while (true) {
+//		Token token = fTokenizer-&gt;NextToken();
+//		switch (token.type) {
+//			case TOKEN_AND:
+//				value = (uint64)value &amp; (uint64)_ParseSum();
+//				break;
+//			case TOKEN_OR:
+//				value = (uint64)value | (uint64)_ParseSum();
+//				break;
+//
+//			default:
+//				fTokenizer-&gt;RewindToken();
+//				return value;
+//		}
+//	}
 }
 
 
-double
+MAPM
 ExpressionParser::_ParseSum()
 {
 	// TODO: check isnan()...
-	double value = _ParseProduct();
+	MAPM value = _ParseProduct();
 
 	while (true) {
 		Token token = fTokenizer-&gt;NextToken();
@@ -276,11 +313,11 @@
 }
 
 
-double
+MAPM
 ExpressionParser::_ParseProduct()
 {
 	// TODO: check isnan()...
-	double value = _ParsePower();
+	MAPM value = _ParsePower();
 
 	while (true) {
 		Token token = fTokenizer-&gt;NextToken();
@@ -289,17 +326,17 @@
 				value = value * _ParsePower();
 				break;
 			case TOKEN_SLASH: {
-				double rhs = _ParsePower();
-				if (rhs == 0.0)
+				MAPM rhs = _ParsePower();
+				if (rhs == MAPM(0))
 					throw ParseException(&quot;division by zero&quot;, token.position);
 				value = value / rhs;
 				break;
 			}
 			case TOKEN_MODULO: {
-				double rhs = _ParsePower();
-				if (rhs == 0.0)
+				MAPM rhs = _ParsePower();
+				if (rhs == MAPM(0))
 					throw ParseException(&quot;modulo by zero&quot;, token.position);
-				value = fmod(value, rhs);
+				value = value % rhs;
 				break;
 			}
 
@@ -311,10 +348,10 @@
 }
 
 
-double
+MAPM
 ExpressionParser::_ParsePower()
 {
-	double value = _ParseUnary();
+	MAPM value = _ParseUnary();
 
 	while (true) {
 		Token token = fTokenizer-&gt;NextToken();
@@ -322,12 +359,12 @@
 			fTokenizer-&gt;RewindToken();
 			return value;
 		}
-		value = pow(value, _ParseUnary());
+		value.pow(_ParseUnary());
 	}
 }
 
 
-double
+MAPM
 ExpressionParser::_ParseUnary()
 {
 	Token token = fTokenizer-&gt;NextToken();
@@ -339,8 +376,9 @@
 			return _ParseUnary();
 		case TOKEN_MINUS:
 			return -_ParseUnary();
-		case TOKEN_NOT:
-			return ~(uint64)_ParseUnary();
+// TODO: Implement !
+//		case TOKEN_NOT:
+//			return ~(uint64)_ParseUnary();
 
 		case TOKEN_IDENTIFIER:
 			return _ParseFunction(token);
@@ -350,7 +388,7 @@
 			return _ParseAtom();
 	}
 
-	return 0.0;
+	return MAPM(0);
 }
 
 
@@ -358,76 +396,96 @@
 	const char*	name;
 	int			argumentCount;
 	void*		function;
-	double		value;
+	MAPM		value;
 };
 
-static const Function kFunctions[] = {
-	{ &quot;e&quot;,		0, NULL, M_E },
-	{ &quot;pi&quot;,		0, NULL, M_PI },
 
-	{ &quot;abs&quot;,	1, (void*)&amp;fabs },
-	{ &quot;acos&quot;,	1, (void*)&amp;acos },
-	{ &quot;asin&quot;,	1, (void*)&amp;asin },
-	{ &quot;atan&quot;,	1, (void*)&amp;atan },
-	{ &quot;atan2&quot;,	2, (void*)&amp;atan2 },
-	{ &quot;ceil&quot;,	1, (void*)&amp;ceil },
-	{ &quot;cos&quot;,	1, (void*)&amp;cos },
-	{ &quot;cosh&quot;,	1, (void*)&amp;cosh },
-	{ &quot;exp&quot;,	1, (void*)&amp;exp },
-	{ &quot;fabs&quot;,	1, (void*)&amp;fabs },
-	{ &quot;floor&quot;,	1, (void*)&amp;floor },
-	{ &quot;fmod&quot;,	2, (void*)&amp;fmod },
-	{ &quot;log&quot;,	1, (void*)&amp;log },
-	{ &quot;log10&quot;,	1, (void*)&amp;log10 },
-	{ &quot;pow&quot;,	2, (void*)&amp;pow },
-	{ &quot;sin&quot;,	1, (void*)&amp;sin },
-	{ &quot;sinh&quot;,	1, (void*)&amp;sinh },
-	{ &quot;sqrt&quot;,	1, (void*)&amp;sqrt },
-	{ &quot;tan&quot;,	1, (void*)&amp;tan },
-	{ &quot;tanh&quot;,	1, (void*)&amp;tanh },
-	{ &quot;hypot&quot;,	2, (void*)&amp;hypot },
-
-	{ NULL },
-};
-
-double
-ExpressionParser::_ParseFunction(const Token&amp; token)
+void
+ExpressionParser::_InitArguments(MAPM values[], int32 argumentCount)
 {
-	const Function* function = _FindFunction(token.string.String());
-	if (!function)
-		throw ParseException(&quot;unknown identifier&quot;, token.position);
-
-	if (function-&gt;argumentCount == 0)
-		return function-&gt;value;
-
 	_EatToken(TOKEN_OPENING_BRACKET);
 
-	double values[function-&gt;argumentCount];
-	for (int32 i = 0; i &lt; function-&gt;argumentCount; i++) {
+	for (int32 i = 0; i &lt; argumentCount; i++)
 		values[i] = _ParseBinary();
-	}
 
 	_EatToken(TOKEN_CLOSING_BRACKET);
+}
 
+
+MAPM
+ExpressionParser::_ParseFunction(const Token&amp; token)
+{
+	if (strcasecmp(&quot;e&quot;, token.string.String()) == 0)
+		return MAPM(M_E);
+	else if (strcasecmp(&quot;pi&quot;, token.string.String()) == 0)
+		return MAPM(M_PI);
+
 	// hard coded cases for different count of arguments
-	switch (function-&gt;argumentCount) {
-		case 1:
-			return ((double (*)(double))function-&gt;function)(values[0]);
-		case 2:
-			return ((double (*)(double, double))function-&gt;function)(values[0],
-				values[1]);
-		case 3:
-			return ((double (*)(double, double, double))function-&gt;function)(
-				values[0], values[1], values[2]);
+	// supports functions with 3 arguments at most
 
-		default:
-			throw ParseException(&quot;unsupported function argument count&quot;,
-				token.position);
+	MAPM values[3];
+
+	if (strcasecmp(&quot;abs&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].abs();
+	} else if (strcasecmp(&quot;acos&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].acos();
+	} else if (strcasecmp(&quot;asin&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].asin();
+	} else if (strcasecmp(&quot;atan&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].atan();
+	} else if (strcasecmp(&quot;atan2&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 2);
+		return values[0].atan2(values[1]);
+	} else if (strcasecmp(&quot;ceil&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].ceil();
+	} else if (strcasecmp(&quot;cos&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].cos();
+	} else if (strcasecmp(&quot;cosh&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].cosh();
+	} else if (strcasecmp(&quot;exp&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].exp();
+	} else if (strcasecmp(&quot;floor&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].floor();
+	} else if (strcasecmp(&quot;log&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].log();
+	} else if (strcasecmp(&quot;log10&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].log10();
+	} else if (strcasecmp(&quot;pow&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 2);
+		return values[0].pow(values[1]);
+	} else if (strcasecmp(&quot;sin&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].sin();
+	} else if (strcasecmp(&quot;sinh&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].sinh();
+	} else if (strcasecmp(&quot;sqrt&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].sqrt();
+	} else if (strcasecmp(&quot;tan&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].tan();
+	} else if (strcasecmp(&quot;tanh&quot;, token.string.String()) == 0) {
+		_InitArguments(values, 1);
+		return values[0].tanh();
 	}
+
+	throw ParseException(&quot;unknown identifier&quot;, token.position);
 }
 
 
-double
+MAPM
 ExpressionParser::_ParseAtom()
 {
 	Token token = fTokenizer-&gt;NextToken();
@@ -441,7 +499,7 @@
 
 	_EatToken(TOKEN_OPENING_BRACKET);
 
-	double value = _ParseBinary();
+	MAPM value = _ParseBinary();
 
 	_EatToken(TOKEN_CLOSING_BRACKET);
 
@@ -460,15 +518,3 @@
 	}
 }
 
-
-const Function*
-ExpressionParser::_FindFunction(const char* name) const
-{
-	for (int32 i = 0; kFunctions[i].name; i++) {
-		if (strcasecmp(kFunctions[i].name, name) == 0)
-			return &amp;kFunctions[i];
-	}
-
-	return NULL;
-}
-

Modified: haiku/trunk/src/apps/deskcalc/ExpressionParser.h
===================================================================
--- haiku/trunk/src/apps/deskcalc/ExpressionParser.h	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/ExpressionParser.h	2008-11-04 20:47:41 UTC (rev 28506)
@@ -6,12 +6,13 @@
  *		Ingo Weinhold &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de</A>&gt;
  *		Stephan A&#223;mus &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">superstippi at gmx.de</A>&gt;
  */
-
 #ifndef EXPRESSION_PARSER_H
 #define EXPRESSION_PARSER_H
 
+
 #include &lt;String.h&gt;
 
+
 class Tokenizer;
 
 class ParseException {
@@ -34,26 +35,28 @@
 
 struct Function;
 struct Token;
+class MAPM;
 
 class ExpressionParser {
  public:
 								ExpressionParser();
 								~ExpressionParser();
 
-			double				Evaluate(const char* expressionString);
+			BString				Evaluate(const char* expressionString);
 
  private:
 
-			double				_ParseBinary();
-			double				_ParseSum();
-			double				_ParseProduct();
-			double				_ParsePower();
-			double				_ParseUnary();
-			double				_ParseFunction(const Token&amp; token);
-			double				_ParseAtom();
+			MAPM				_ParseBinary();
+			MAPM				_ParseSum();
+			MAPM				_ParseProduct();
+			MAPM				_ParsePower();
+			MAPM				_ParseUnary();
+			void				_InitArguments(MAPM values[],
+									int32 argumentCount);
+			MAPM				_ParseFunction(const Token&amp; token);
+			MAPM				_ParseAtom();
 
 			void				_EatToken(int32 type);
-			const Function*		_FindFunction(const char* name) const;
 
 			Tokenizer*			fTokenizer;
 };

Modified: haiku/trunk/src/apps/deskcalc/Jamfile
===================================================================
--- haiku/trunk/src/apps/deskcalc/Jamfile	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/Jamfile	2008-11-04 20:47:41 UTC (rev 28506)
@@ -2,6 +2,8 @@
 
 SetSubDirSupportedPlatformsBeOSCompatible ;
 
+SEARCH_SOURCE += [ FDirName $(HAIKU_TOP) src apps deskcalc mapm_4.9.5 ] ;
+
 Application DeskCalc :
 	CalcApplication.cpp
 	CalcOptionsWindow.cpp
@@ -11,6 +13,47 @@
 	ExpressionParser.cpp
 	ExpressionTextView.cpp
 	InputTextView.cpp
+
+	# m_apm files
+	mapmhasn.c
+	mapmhsin.c
+	mapm_pow.c
+	mapm_log.c
+	mapm_lg2.c
+	mapm_lg4.c
+	mapm_exp.c
+	mapm_lg3.c
+	mapmasin.c
+	mapmasn0.c
+	mapm_sin.c
+	mapm5sin.c
+	mapmrsin.c
+	mapm_cpi.c
+	mapmsqrt.c
+	mapmcbrt.c
+	mapmgues.c
+	mapmfact.c
+	mapm_gcd.c
+	mapmipwr.c
+	mapmpwr2.c
+	mapm_rnd.c
+	mapm_flr.c
+	mapm_fpf.c
+	mapm_rcp.c
+	mapmstck.c
+	mapm_div.c
+	mapm_mul.c
+	mapmfmul.c
+	mapm_fft.c
+	mapm_add.c
+	mapmistr.c
+	mapm_set.c
+	mapm_fam.c
+	mapmutil.c
+	mapmutl2.c
+	mapmutl1.c
+	mapmcnst.c
+
 	: be $(TARGET_LIBSTDC++) media
 	: DeskCalc.rdef
 	;

Added: haiku/trunk/src/apps/deskcalc/mapm_4.9.5/README
===================================================================
--- haiku/trunk/src/apps/deskcalc/mapm_4.9.5/README	2008-11-04 20:36:57 UTC (rev 28505)
+++ haiku/trunk/src/apps/deskcalc/mapm_4.9.5/README	2008-11-04 20:47:41 UTC (rev 28506)
@@ -0,0 +1,769 @@
+**************************************************************************
+  
+				   MAPM
+
+			       Version 4.9.5
+
+			     December 10, 2007
+
+			      Michael C. Ring
+
+			    <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ringx004 at tc.umn.edu</A>
+
+		    Latest release will be available at
+		        <A HREF="http://tc.umn.edu/~ringx004">http://tc.umn.edu/~ringx004</A>
+
+***************************************************************************
+*									  *
+*  Copyright (C) 1999 - 2007   Michael C. Ring                            *
+*									  *
+*  This software is Freeware.						  *
+*									  *
+*  Permission to use, copy, and distribute this software and its          *
+*  documentation for any purpose with or without fee is hereby granted,   *
+*  provided that the above copyright notice appear in all copies and      *
+*  that both that copyright notice and this permission notice appear      *
+*  in supporting documentation.                                           *
+*									  *
+*  Permission to modify the software is granted. Permission to distribute *
+*  the modified code is granted. Modifications are to be distributed by   *
+*  using the file 'license.txt' as a template to modify the file header.  *
+*  'license.txt' is available in the official MAPM distribution.          *
+*									  *
+*  To distribute modified source code, insert the file 'license.txt'      *
+*  at the top of all modified source code files and edit accordingly.     *
+*									  *
+*  This software is provided &quot;as is&quot; without express or implied warranty. *
+*									  *
+***************************************************************************
+
+		---------------------------------------
+		Mike's Arbitrary Precision Math Library
+		---------------------------------------
+
+Mike's Arbitrary Precision Math Library is a set of functions that
+allow the user to perform math to any level of accuracy that is
+desired. The inspiration for this library was Lloyd Zusman's similar
+APM package that was released in ~1988. I borrowed some of his ideas
+in my implementation, creating a new data type (MAPM) and how the data
+type was used by the user. However, there were a few things I wanted
+my library to do that the original library did not :
+
+1) Round a value to any desired precision. This is very handy when
+   multiplying for many iterations. Since multiplication guarantees an
+   exact result, the number of digits will grow without bound. I wanted
+   a way to trim the number of significant digits that were retained.
+
+2) A natural support for floating point values. From most of the other
+   libraries I looked at, they seem to have a preference for integer
+   only type math manipulations. (However, this library will also do
+   integer only math if you desire).
+
+   And if a library can only do integers, it can't do ...
+
+3) Trig functions and other common C math library functions. This library
+   will perform the following functions to any desired precision level :
+   SQRT, CBRT, SIN, COS, TAN, ARC-SIN, ARC-COS, ARC-TAN, ARC-TAN2, LOG,
+   LOG10, EXP, POW, SINH, COSH, TANH, ARC-SINH, ARC-COSH, ARC-TANH, and
+   also FACTORIAL.  The full 'math.h' is not duplicated, though I think
+   these are most of the important ones. My definition of what's important
+   is what I've actually used in a real application.
+
+**************************************************************************
+
+NOTE:
+
+There is a COMPILER BUG in Microsoft's Visual C++ 7.x (VS.NET 2003) which
+prevents a C++ MAPM application from compiling.
+
+This only affects C++ applications. C applications are OK.
+
+The compiler bug creates an error C2676 similar to this:
+
+&lt;path&gt;...\mapm-49\M_APM.H(###) : error C2676: binary operator '-': 'MAPM'
+doesn't define this operator or a conversion to a suitable type for the
+predefined operator.
+
+To work around this bug, go to <A HREF="http://www.microsoft.com">http://www.microsoft.com</A>
+
+In the upper right corner of web page, search for &quot;814455&quot;.
+
+The results of the search will point you to an article on how to work
+around the problem.
+
+**************************************************************************
+
+NOTE: MAPM Library History can now be found in 'history.txt'
+
+**************************************************************************
+
+ANOTHER NOTE: For the Windows/DOS distribution, the filename convention
+will always be in 8.3 format. This is because there are some users who
+still use 16 bit DOS ....
+
+(I really wasn't sure what to call this library. 'Arbitrary Precision Math'
+is a defacto standard for what this does, but that name was already taken,
+so I just put an 'M' in front of it ...)
+
+**************************************************************************
+
+MAPM LIBRARY NUMERICAL LIMITATIONS:
+
+A general floating point number is of the form:
+
+Sn.nnnnnnnnE+yyyy        ex: -4.318384739357974916E+6215
+Sn.nnnnnnnnE-yyyy        ex: +8.208237913789131096523645193E-12873
+
+'S' is the sign, + or -.
+
+In MAPM, a number (n.nnnn...) may contain up to ( INT_MAX - 1 ) digits.
+
+For example, an MAPM number with a 16 bit integer may contain 2^15 or 32,767
+digits. An MAPM number with a 32 bit integer may contain 2^31 or 2,147,483,647
+digits. All MAPM numbers are stored in RAM, there is no &quot;data on disk&quot; option.
+So to represent the maximum number of digits on a 32 bit CPU will require
+greater than 2 Gig of RAM.
+
+If you have a CPU with 64 bit ints, then the limitation is 2^63 or
+9,223,372,036,854,775,807. It should be a very long time before computers
+have this much RAM in them.
+
+For the exponent (yyyy), the limitations are also INT_MAX and INT_MIN.
+
+For a 16 bit CPU, the largest number you can represent is approx
+0.9999999....E+32767.    (H)
+
+For a 16 bit CPU, the smallest number you can represent (other than 0)
+is approx 0.1E-32767.   (L)
+
+For a 32 bit CPU, the largest number you can represent is approx
+0.9999999....E+2147483647.   (H)
+
+For a 32 bit CPU, the smallest number you can represent (other than 0)
+is approx 0.1E-2147483647.  (L)
+
+The limitations for negative numbers are the same as positive numbers.
+
+
+                            Real Number Axis
+
+     +------------------------+    ---    +--------------------------+
+     |                        |     |     |                          |
+    -H                       -L    0.0   +L                         +H
+
+
+
+MAPM can represent real numbers from -H to -L, 0.0, +L to +H.
+
+The number of significant digits is typically only limited by available RAM.
+
+In MAPM, numerical overflows and underflows are not handled very well
+(actually not at all). There really isn't a clean and portable way to
+detect integer overflow and underflow. Per K&amp;R C, the result of integer
+overflow/underflow is implementation dependent. In assembly language, when
+you add two numbers, you have access to a &quot;carry flag&quot; to see if an overflow
+occurred. C has no analogous operator to a carry flag.
+
+It is up to the user to decide if the results are valid for a given operation.
+In a 32 bit environment, the limit is so large that this is likely not an
+issue for most typical applications. However, it doesn't take much to overflow
+a 16 bit int so care should taken in a 16 bit environment.
+
+The reaction to an integer overflow/underflow is unknown at run-time:
+
+    o) adding 2 large positive numbers may silently roll over to a
+       negative number.
+    o) in some embedded applications an integer overflow/underflow triggers
+       a hardware exception.
+
+Since I don't have control over where this library could possibly run,
+I chose to ignore the problem for now. If anyone has some suggestions
+(that's portable), please let me know.
+
+**************************************************************************
+
+KNOWN BUGS : (Other than integer overflow discussed above....) None
+
+**************************************************************************
+
+IF YOU ARE IN A HURRY ...
+
+UNIX:  (assumes gcc compiler)
+
+run    make          (build library + 4 executables)
+
+run    make -f makefile.osx      (for MAC OSX)
+
+--- OR ---
+
+run:   mklib         (this will create the library, lib_mapm.a)
+
+run:   mkdemo        (this will create 4 executables, 'calc', 'validate',
+                      'primenum', and 'cpp_demo')
+
+
+DOS / Win NT/9x  (in a DOS window for NT/9x):
+
+see the file 'README.DOS' for instructions.
+
+
+**************************************************************************
+
+calc:  This is a command line version of an RPN calculator. If you are
+       familiar with RPN calculators, the use of this program will be
+       quite obvious. The default is 30 decimal places but this can be
+       changed with the '-d' command line option. This is not an
+       interactive program, it just computes an expression from the command
+       line. Run 'calc' with no arguments to get a list of the operators.
+
+       compute : (345.2 * 87.33) - (11.88 / 3.21E-2)
+
+       calc 345.2 87.33 x 11.88 3.21E-2 / -
+       result: 29776.22254205607476635514018692
+
+
+       compute PI to 70 decimal places :  (6 * arcsin(0.5))
+
+       calc -d70 6 .5 as x
+       result :
+3.1415926535897932384626433832795028841971693993751058209749445923078164
+
+       calc -d70 -1 ac             (arccos(-1) for fastest possible way)
+
+validate : This program will compare the MAPM math functions to the C
+	   standard library functions, like sqrt, sin, exp, etc.  This
+	   should give the user a good idea that the library is operating
+	   correctly. The program will also perform high precision math
+	   using known quantities like PI, log(2), etc.
+
+	   'validate' also attempts to obtain as much code coverage of the
+	   library as is practical. I used 'gcov' (available with the gcc
+	   distribution) to test the code coverage. 100% coverage is not
+	   obtained, compromises must be made in order to have the program
+	   run in a reasonable amount of time.
+
+primenum:  This program will generate the first 10 prime numbers starting
+	   with the number entered as an argument.
+
+	   Example:  primenum 1234567890 will output (actually 1 per line):
+		     this took ~3 sec on my Linux PC, a 350MHz PII.
+
+	   1234567891, 1234567907, 1234567913, 1234567927, 1234567949,
+	   1234567967, 1234567981, 1234568021, 1234568029, 1234568047
+
+
+**************************************************************************
+
+To use the library, simply include 'm_apm.h' and link your program
+with the library, libmapm.a (unix) or mapm.lib (dos).
+
+Note: If your system creates libraries with a '.a' extension, then the
+library will be named libmapm.a. (This conforms to typical unix naming
+conventions).
+
+Note: If your system creates libraries with a '.lib' extension, then the
+library will be named mapm.lib.
+
+For unix builds, you also may need to specify the math library (-lm) when
+linking. The reason is some of the MAPM functions use an iterative algorithm.
+When you use an iterative solution, you have to supply an initial guess. I
+use the standard math library to generate this initial guess. I debated
+whether this library should be stand-alone, i.e. generate it's own initial
+guesses with some algorithm. In the end, I decided using the standard math
+library would not be a big inconvienence and also it was just too tempting
+having an immediate 15 digits of precision. When you prime the iterative
+routines with 15 accurate digits, the MAPM functions converge faster.
+
+See the file 'algorithms.used' to see a description of the algorithms I
+used in the library. Some I derived on my own, others I borrowed from people
+smarter than me. Version 2 of the library supports a 'fast' multiplication
+algorithm. The algorithm used is described in the algorithms.used file. A
+considerable amount of time went into finding fast algorithms for the
+library. However, some could possibly be even better. If anyone has a
+more efficient algorithm for any of these functions, I would like to here
+from you.
+
+See the file 'function.ref' to see a description of all the functions in
+the library and the calling conventions, prototypes, etc.
+
+See the file 'struct.ref' which documents how I store the numbers internally
+in the MAPM data structure. This will not be needed for normal use, but it
+will be very useful if you need to change/add to the existing library.
+
+**************************************************************************
+
+USING MAPM IN A MULTI-THREADED APPLICATION :
+
+Note that the default MAPM library is NOT thread safe. MAPM internal data
+structures could get corrupted if multiple MAPM functions are active at the
+same time. The user should guarantee that only one thread is performing
+MAPM functions. This can usually be achieved by a call to the operating
+system to obtain a 'semaphore', 'mutex', or 'critical code section' so the
+operating system will guarantee that only one MAPM thread will be active
+at a time.
+
+The necessary function wrappers for thread safe operation can be found in
+the sub-directory 'multi_thread' (unix) or 'multithd' (Win/Dos). For now,
+only Microsoft Visual C++ 6.0 is supported.
+
+**************************************************************************
+
+QUICK TEMPLATE FOR NORMAL USE :
+
+The MAPM math is done on a new data type called &quot;M_APM&quot;.  This is
+actually a pointer to a structure, but the contents of the structure
+should never be manipulated: all operations on MAPM entities are done
+through a functional interface.
+
+The MAPM routines will automatically allocate enough space in their
+results to hold the proper number of digits.
+
+The caller must initialize all MAPM values before the routines can
+operate on them (including the values intended to contain results of
+calculations).  Once this initialization is done, the user never needs
+to worry about resizing the MAPM values, as this is handled inside the

[... truncated: 11985 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="013270.html">[Haiku-commits] r28505 - haiku/trunk/src/apps/soundrecorder
</A></li>
	<LI>Next message: <A HREF="013275.html">[Haiku-commits] r28506 - in haiku/trunk/src/apps: aboutsystem deskcalc deskcalc/mapm_4.9.5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#13271">[ date ]</a>
              <a href="thread.html#13271">[ thread ]</a>
              <a href="subject.html#13271">[ subject ]</a>
              <a href="author.html#13271">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
