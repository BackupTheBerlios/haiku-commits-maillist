<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] Haiku-commits Digest, Vol 16, Issue 93
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20Haiku-commits%20Digest%2C%20Vol%2016%2C%20Issue%2093&In-Reply-To=%3Cf019d2f30710250612j554df94ew5100fbe8dda81749%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004477.html">
   <LINK REL="Next"  HREF="004479.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] Haiku-commits Digest, Vol 16, Issue 93</H1>
    <B>Rene Gollent</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20Haiku-commits%20Digest%2C%20Vol%2016%2C%20Issue%2093&In-Reply-To=%3Cf019d2f30710250612j554df94ew5100fbe8dda81749%40mail.gmail.com%3E"
       TITLE="[Haiku-commits] Haiku-commits Digest, Vol 16, Issue 93">anevilyak at gmail.com
       </A><BR>
    <I>Thu Oct 25 15:12:04 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004477.html">[Haiku-commits] r22717 - in haiku/trunk/headers: os/arch/m68k	posix/arch/m68k
</A></li>
        <LI>Next message: <A HREF="004479.html">[Haiku-commits] Haiku-commits Digest, Vol 16, Issue 93
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4478">[ date ]</a>
              <a href="thread.html#4478">[ thread ]</a>
              <a href="subject.html#4478">[ subject ]</a>
              <a href="author.html#4478">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;<i>  Also implemented empty BStatable destructor. Needed, since it's virtual now.
</I>
I don't think you can do this without breaking FBC....R5's BStatable
had no virtual d'tor.




On 10/25/07, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits-request at lists.berlios.de</A>
&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits-request at lists.berlios.de</A>&gt; wrote:
&gt;<i> Send Haiku-commits mailing list submissions to
</I>&gt;<i> 	<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits at lists.berlios.de</A>
</I>&gt;<i>
</I>&gt;<i> To subscribe or unsubscribe via the World Wide Web, visit
</I>&gt;<i> 	<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">https://lists.berlios.de/mailman/listinfo/haiku-commits</A>
</I>&gt;<i> or, via email, send a message with subject or body 'help' to
</I>&gt;<i> 	<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits-request at lists.berlios.de</A>
</I>&gt;<i>
</I>&gt;<i> You can reach the person managing the list at
</I>&gt;<i> 	<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits-owner at lists.berlios.de</A>
</I>&gt;<i>
</I>&gt;<i> When replying, please edit your Subject line so it is more specific
</I>&gt;<i> than &quot;Re: Contents of Haiku-commits digest...&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Today's Topics:
</I>&gt;<i>
</I>&gt;<i>    1. r22710 - haiku/trunk/headers/build/os/interface
</I>&gt;<i>       (jackburton at BerliOS)
</I>&gt;<i>    2. r22711 - haiku/trunk/headers/build/os/storage
</I>&gt;<i>       (jackburton at BerliOS)
</I>&gt;<i>    3. r22712 - haiku/trunk/headers/build/os/interface
</I>&gt;<i>       (jackburton at BerliOS)
</I>&gt;<i>    4. r22713 - in haiku/trunk: headers/build/os/interface
</I>&gt;<i>       src/build/libbe/interface src/build/libbe/storage
</I>&gt;<i>       (jackburton at BerliOS)
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ----------------------------------------------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 1
</I>&gt;<i> Date: Thu, 25 Oct 2007 12:31:07 +0200
</I>&gt;<i> From: jackburton at BerliOS &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jackburton at mail.berlios.de</A>&gt;
</I>&gt;<i> Subject: [Haiku-commits] r22710 -
</I>&gt;<i> 	haiku/trunk/headers/build/os/interface
</I>&gt;<i> To: <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits at lists.berlios.de</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">200710251031.l9PAV7b7009689 at sheep.berlios.de</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i>
</I>&gt;<i> Author: jackburton
</I>&gt;<i> Date: 2007-10-25 12:31:01 +0200 (Thu, 25 Oct 2007)
</I>&gt;<i> New Revision: 22710
</I>&gt;<i> ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22710&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22710&amp;view=rev</A>
</I>&gt;<i>
</I>&gt;<i> Modified:
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Screen.h
</I>&gt;<i> Log:
</I>&gt;<i> Copied the update Screen.h to the build folder
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Modified: haiku/trunk/headers/build/os/interface/Screen.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/headers/build/os/interface/Screen.h	2007-10-25 02:24:38 UTC
</I>&gt;<i> (rev 22709)
</I>&gt;<i> +++ haiku/trunk/headers/build/os/interface/Screen.h	2007-10-25 10:31:01 UTC
</I>&gt;<i> (rev 22710)
</I>&gt;<i> @@ -1,101 +1,96 @@
</I>&gt;<i> -/*******************************************************************************
</I>&gt;<i> -/
</I>&gt;<i> -/	File:			Screen.h
</I>&gt;<i> -/
</I>&gt;<i> -/   Description:    BScreen provides information about a screen's current
</I>&gt;<i> -/                   display settings.  It also lets you set the Desktop
</I>&gt;<i> color.
</I>&gt;<i> -/
</I>&gt;<i> -/	Copyright 1993-98, Be Incorporated, All Rights Reserved
</I>&gt;<i> -/
</I>&gt;<i> -*******************************************************************************/
</I>&gt;<i> -
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright 2007, Haiku, Inc. All Rights Reserved.
</I>&gt;<i> + * Distributed under the terms of the MIT License.
</I>&gt;<i> + */
</I>&gt;<i>  #ifndef _SCREEN_H
</I>&gt;<i>  #define _SCREEN_H
</I>&gt;<i>
</I>&gt;<i> -#include &lt;BeBuild.h&gt;
</I>&gt;<i> +
</I>&gt;<i>  #include &lt;Accelerant.h&gt;
</I>&gt;<i>  #include &lt;GraphicsDefs.h&gt;
</I>&gt;<i>  #include &lt;Rect.h&gt;
</I>&gt;<i>  #include &lt;OS.h&gt;
</I>&gt;<i>
</I>&gt;<i> -/*----------------------------------------------------------------*/
</I>&gt;<i> -/*----- BScreen structures and declarations ----------------------*/
</I>&gt;<i>
</I>&gt;<i> +class BBitmap;
</I>&gt;<i>  class BWindow;
</I>&gt;<i> -class BPrivateScreen;
</I>&gt;<i>
</I>&gt;<i> -/*----------------------------------------------------------------*/
</I>&gt;<i> -/*----- BScreen class --------------------------------------------*/
</I>&gt;<i> +namespace BPrivate {
</I>&gt;<i> +	class BPrivateScreen;
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i>  class BScreen {
</I>&gt;<i> -public:
</I>&gt;<i> -        BScreen( screen_id id=B_MAIN_SCREEN_ID );
</I>&gt;<i> -        BScreen( BWindow *win );
</I>&gt;<i> -        ~BScreen();
</I>&gt;<i> +	public:
</I>&gt;<i> +		BScreen(screen_id id = B_MAIN_SCREEN_ID);
</I>&gt;<i> +		BScreen(BWindow* window);
</I>&gt;<i> +		~BScreen();
</I>&gt;<i>
</I>&gt;<i> -        bool   			IsValid();
</I>&gt;<i> -        status_t		SetToNext();
</I>&gt;<i> -
</I>&gt;<i> -        color_space		ColorSpace();
</I>&gt;<i> -        BRect			Frame();
</I>&gt;<i> -        screen_id		ID();
</I>&gt;<i> +		bool		IsValid();
</I>&gt;<i> +		status_t	SetToNext();
</I>&gt;<i>
</I>&gt;<i> -        status_t		WaitForRetrace();
</I>&gt;<i> -        status_t		WaitForRetrace(bigtime_t timeout);
</I>&gt;<i> -
</I>&gt;<i> -        uint8			IndexForColor( rgb_color rgb );
</I>&gt;<i> -        uint8			IndexForColor( uint8 r, uint8 g, uint8 b, uint8 a=255 );
</I>&gt;<i> -        rgb_color		ColorForIndex( const uint8 index );
</I>&gt;<i> -        uint8			InvertIndex( uint8 index );
</I>&gt;<i> +		color_space	ColorSpace();
</I>&gt;<i> +		BRect		Frame();
</I>&gt;<i> +		screen_id	ID();
</I>&gt;<i>
</I>&gt;<i> -const   color_map*		ColorMap();
</I>&gt;<i> +		status_t	WaitForRetrace();
</I>&gt;<i> +		status_t	WaitForRetrace(bigtime_t timeout);
</I>&gt;<i>
</I>&gt;<i> -		status_t		GetBitmap(	BBitmap		**screen_shot,
</I>&gt;<i> -									bool		draw_cursor = true,
</I>&gt;<i> -									BRect		*bound = NULL);
</I>&gt;<i> -		status_t		ReadBitmap(	BBitmap		*buffer,
</I>&gt;<i> -									bool		draw_cursor = true,
</I>&gt;<i> -									BRect		*bound = NULL);
</I>&gt;<i> -
</I>&gt;<i> -        rgb_color		DesktopColor();
</I>&gt;<i> -        rgb_color		DesktopColor(uint32 index);
</I>&gt;<i> -        void			SetDesktopColor( rgb_color rgb, bool stick=true );
</I>&gt;<i> -        void			SetDesktopColor( rgb_color rgb, uint32 index, bool
</I>&gt;<i> stick=true );
</I>&gt;<i> +		uint8		IndexForColor(rgb_color color);
</I>&gt;<i> +		uint8		IndexForColor(uint8 red, uint8 green, uint8 blue,
</I>&gt;<i> +						uint8 alpha = 255);
</I>&gt;<i> +		rgb_color	ColorForIndex(uint8 index);
</I>&gt;<i> +		uint8		InvertIndex(uint8 index);
</I>&gt;<i>
</I>&gt;<i> -		status_t		ProposeMode(display_mode *target, const display_mode *low,
</I>&gt;<i> const display_mode *high);
</I>&gt;<i> -		status_t		GetModeList(display_mode **mode_list, uint32 *count);
</I>&gt;<i> -		status_t		GetMode(display_mode *mode);
</I>&gt;<i> -		status_t		GetMode(uint32 workspace, display_mode *mode);
</I>&gt;<i> -		status_t		SetMode(display_mode *mode, bool makeDefault = false);
</I>&gt;<i> -		status_t		SetMode(uint32 workspace, display_mode *mode, bool makeDefault
</I>&gt;<i> = false);
</I>&gt;<i> -		status_t		GetDeviceInfo(accelerant_device_info *adi);
</I>&gt;<i> -		status_t		GetPixelClockLimits(display_mode *mode, uint32 *low, uint32
</I>&gt;<i> *high);
</I>&gt;<i> -		status_t		GetTimingConstraints(display_timing_constraints *dtc);
</I>&gt;<i> -		status_t		SetDPMS(uint32 dpms_state);
</I>&gt;<i> -		uint32			DPMSState(void);
</I>&gt;<i> -		uint32			DPMSCapabilites(void);
</I>&gt;<i> +		const color_map* ColorMap();
</I>&gt;<i>
</I>&gt;<i> -        BPrivateScreen*	private_screen();
</I>&gt;<i> +		status_t	GetBitmap(BBitmap** _bitmap, bool drawCursor = true,
</I>&gt;<i> +						BRect* frame = NULL);
</I>&gt;<i> +		status_t	ReadBitmap(BBitmap* bitmap, bool drawCursor = true,
</I>&gt;<i> +						BRect* frame = NULL);
</I>&gt;<i>
</I>&gt;<i> -/*----- Private or reserved -----------------------------------------*/
</I>&gt;<i> -private:
</I>&gt;<i> -		status_t		ProposeDisplayMode(display_mode *target, const display_mode
</I>&gt;<i> *low, const display_mode *high);
</I>&gt;<i> -		BScreen			&amp;operator=(const BScreen &amp;screen);
</I>&gt;<i> -						BScreen(const BScreen &amp;screen);
</I>&gt;<i> -        void*			BaseAddress();
</I>&gt;<i> -        uint32			BytesPerRow();
</I>&gt;<i> +		rgb_color	DesktopColor();
</I>&gt;<i> +		rgb_color	DesktopColor(uint32 index);
</I>&gt;<i> +		void		SetDesktopColor(rgb_color color, bool makeDefault = true);
</I>&gt;<i> +		void		SetDesktopColor(rgb_color color, uint32 index,
</I>&gt;<i> +						bool makeDefault = true);
</I>&gt;<i>
</I>&gt;<i> -        BPrivateScreen 	*screen;
</I>&gt;<i> -};
</I>&gt;<i> +		status_t	ProposeMode(display_mode* target, const display_mode* low,
</I>&gt;<i> +						const display_mode* high);
</I>&gt;<i> +		status_t	GetModeList(display_mode** _modeList, uint32* _count);
</I>&gt;<i> +		status_t	GetMode(display_mode* mode);
</I>&gt;<i> +		status_t	GetMode(uint32 workspace, display_mode* mode);
</I>&gt;<i> +		status_t	SetMode(display_mode* mode, bool makeDefault = false);
</I>&gt;<i> +		status_t	SetMode(uint32 workspace, display_mode* mode,
</I>&gt;<i> +						bool makeDefault = false);
</I>&gt;<i> +		status_t	GetDeviceInfo(accelerant_device_info* info);
</I>&gt;<i> +		status_t	GetMonitorInfo(monitor_info* info);
</I>&gt;<i> +		status_t	GetPixelClockLimits(display_mode* mode, uint32* low,
</I>&gt;<i> +						uint32* high);
</I>&gt;<i> +		status_t	GetTimingConstraints(
</I>&gt;<i> +						display_timing_constraints* timingConstraints);
</I>&gt;<i> +		status_t	SetDPMS(uint32 state);
</I>&gt;<i> +		uint32		DPMSState();
</I>&gt;<i> +		uint32		DPMSCapabilites();
</I>&gt;<i>
</I>&gt;<i> +	private:
</I>&gt;<i> +		BScreen&amp;	operator=(const BScreen&amp; other);
</I>&gt;<i> +		BScreen(const BScreen&amp; other);
</I>&gt;<i>
</I>&gt;<i> -/*----------------------------------------------------------------*/
</I>&gt;<i> -/*----- inline definitions ---------------------------------------*/
</I>&gt;<i> +		// old and deprecated methods - should be faded out
</I>&gt;<i> +		BPrivate::BPrivateScreen* private_screen();
</I>&gt;<i> +		status_t	ProposeDisplayMode(display_mode* target,
</I>&gt;<i> +						const display_mode* low, const display_mode* high);
</I>&gt;<i> +		void*		BaseAddress();
</I>&gt;<i> +		uint32		BytesPerRow();
</I>&gt;<i>
</I>&gt;<i> -inline uint8 BScreen::IndexForColor( rgb_color rgb )
</I>&gt;<i> -  { return IndexForColor(rgb.red,rgb.green,rgb.blue,rgb.alpha); }
</I>&gt;<i> +		BPrivate::BPrivateScreen* fScreen;
</I>&gt;<i> +};
</I>&gt;<i>
</I>&gt;<i> -/*-------------------------------------------------------------*/
</I>&gt;<i> -/*-------------------------------------------------------------*/
</I>&gt;<i>
</I>&gt;<i> -#endif /* _SCREEN_H */
</I>&gt;<i> +inline uint8
</I>&gt;<i> +BScreen::IndexForColor(rgb_color color)
</I>&gt;<i> +{
</I>&gt;<i> +	return IndexForColor(color.red, color.green, color.blue, color.alpha);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +#endif	// _SCREEN_H
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 2
</I>&gt;<i> Date: Thu, 25 Oct 2007 12:32:01 +0200
</I>&gt;<i> From: jackburton at BerliOS &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jackburton at mail.berlios.de</A>&gt;
</I>&gt;<i> Subject: [Haiku-commits] r22711 - haiku/trunk/headers/build/os/storage
</I>&gt;<i> To: <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits at lists.berlios.de</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">200710251032.l9PAW1Yg011761 at sheep.berlios.de</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i>
</I>&gt;<i> Author: jackburton
</I>&gt;<i> Date: 2007-10-25 12:31:57 +0200 (Thu, 25 Oct 2007)
</I>&gt;<i> New Revision: 22711
</I>&gt;<i> ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22711&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22711&amp;view=rev</A>
</I>&gt;<i>
</I>&gt;<i> Modified:
</I>&gt;<i>    haiku/trunk/headers/build/os/storage/Statable.h
</I>&gt;<i> Log:
</I>&gt;<i> Copied the updated Statable.h to the build folder, remove unneeded def
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Modified: haiku/trunk/headers/build/os/storage/Statable.h
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/headers/build/os/storage/Statable.h	2007-10-25 10:31:01 UTC
</I>&gt;<i> (rev 22710)
</I>&gt;<i> +++ haiku/trunk/headers/build/os/storage/Statable.h	2007-10-25 10:31:57 UTC
</I>&gt;<i> (rev 22711)
</I>&gt;<i> @@ -1,82 +1,64 @@
</I>&gt;<i> -//----------------------------------------------------------------------
</I>&gt;<i> -//  This software is part of the OpenBeOS distribution and is covered
</I>&gt;<i> -//  by the OpenBeOS license.
</I>&gt;<i> -//---------------------------------------------------------------------
</I>&gt;<i> -/*!
</I>&gt;<i> -	\file Statable.h
</I>&gt;<i> -	BStatable interface declaration.
</I>&gt;<i> -*/
</I>&gt;<i> -
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright 2002-2007, Haiku, Inc. All Rights Reserved.
</I>&gt;<i> + * Distributed under the terms of the MIT License.
</I>&gt;<i> + */
</I>&gt;<i>  #ifndef _STATABLE_H
</I>&gt;<i>  #define _STATABLE_H
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;SupportDefs.h&gt;
</I>&gt;<i> +
</I>&gt;<i>  #include &lt;sys/types.h&gt;
</I>&gt;<i>  #include &lt;sys/stat.h&gt;
</I>&gt;<i> -#include &lt;SupportDefs.h&gt;
</I>&gt;<i>
</I>&gt;<i> -#ifdef USE_OPENBEOS_NAMESPACE
</I>&gt;<i> -namespace OpenBeOS {
</I>&gt;<i> -#endif // USE_OPENBEOS_NAMESPACE
</I>&gt;<i> +struct node_ref;
</I>&gt;<i> +class BVolume;
</I>&gt;<i>
</I>&gt;<i> -  struct node_ref;
</I>&gt;<i> -  class BVolume;
</I>&gt;<i> -
</I>&gt;<i>
</I>&gt;<i> -	//! BStatable - A nice C++ wrapper to &lt;code&gt;stat()&lt;/code&gt;
</I>&gt;<i> -	/*! A purly abstract class which provieds an expenive, but convenet
</I>&gt;<i> -	 * C++ wrapper to the posix &lt;code&gt;\sa stat()&lt;/code&gt; command.
</I>&gt;<i> -	 *
</I>&gt;<i> -	 * @see &lt;a
</I>&gt;<i> href=&quot;<A HREF="http://www.opensource.org/licenses/mit-license.html">http://www.opensource.org/licenses/mit-license.html</A>&quot;&gt;MIT&lt;/a&gt;
</I>&gt;<i> -	 * @author &lt;a href=&quot;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">mrmlk at users.sf.net</A>&quot;&gt; Michael Lloyd Lee &lt;/a&gt;
</I>&gt;<i> -	 * @author Be Inc
</I>&gt;<i> -	 * @version 0
</I>&gt;<i> -	 */
</I>&gt;<i>  class BStatable {
</I>&gt;<i> -public:
</I>&gt;<i> -	virtual status_t GetStat(struct stat *st) const = 0;
</I>&gt;<i> +	public:
</I>&gt;<i> +		virtual ~BStatable();
</I>&gt;<i>
</I>&gt;<i> -	bool IsFile() const;
</I>&gt;<i> -	bool IsDirectory() const;
</I>&gt;<i> -	bool IsSymLink() const;
</I>&gt;<i> +		virtual status_t GetStat(struct stat *st) const = 0;
</I>&gt;<i>
</I>&gt;<i> -	status_t GetNodeRef(node_ref *ref) const;
</I>&gt;<i> +		bool IsFile() const;
</I>&gt;<i> +		bool IsDirectory() const;
</I>&gt;<i> +		bool IsSymLink() const;
</I>&gt;<i>
</I>&gt;<i> -	status_t GetOwner(uid_t *owner) const;
</I>&gt;<i> -	status_t SetOwner(uid_t owner);
</I>&gt;<i> +		status_t GetNodeRef(node_ref *ref) const;
</I>&gt;<i>
</I>&gt;<i> -	status_t GetGroup(gid_t *group) const;
</I>&gt;<i> -	status_t SetGroup(gid_t group);
</I>&gt;<i> +		status_t GetOwner(uid_t *owner) const;
</I>&gt;<i> +		status_t SetOwner(uid_t owner);
</I>&gt;<i>
</I>&gt;<i> -	status_t GetPermissions(mode_t *perms) const;
</I>&gt;<i> -	status_t SetPermissions(mode_t perms);
</I>&gt;<i> +		status_t GetGroup(gid_t *group) const;
</I>&gt;<i> +		status_t SetGroup(gid_t group);
</I>&gt;<i>
</I>&gt;<i> -	status_t GetSize(off_t *size) const;
</I>&gt;<i> +		status_t GetPermissions(mode_t *perms) const;
</I>&gt;<i> +		status_t SetPermissions(mode_t perms);
</I>&gt;<i>
</I>&gt;<i> -	status_t GetModificationTime(time_t *mtime) const;
</I>&gt;<i> -	status_t SetModificationTime(time_t mtime);
</I>&gt;<i> +		status_t GetSize(off_t *size) const;
</I>&gt;<i>
</I>&gt;<i> -	status_t GetAccessTime(time_t *atime) const;
</I>&gt;<i> -	status_t SetAccessTime(time_t atime);
</I>&gt;<i> +		status_t GetModificationTime(time_t *mtime) const;
</I>&gt;<i> +		status_t SetModificationTime(time_t mtime);
</I>&gt;<i>
</I>&gt;<i> -	status_t GetVolume(BVolume *vol) const;
</I>&gt;<i> +		status_t GetCreationTime(time_t *ctime) const;
</I>&gt;<i> +		status_t SetCreationTime(time_t ctime);
</I>&gt;<i>
</I>&gt;<i> -  private:
</I>&gt;<i> +		status_t GetAccessTime(time_t *atime) const;
</I>&gt;<i> +		status_t SetAccessTime(time_t atime);
</I>&gt;<i>
</I>&gt;<i> -	friend class BEntry;
</I>&gt;<i> -	friend class BNode;
</I>&gt;<i> +		status_t GetVolume(BVolume *vol) const;
</I>&gt;<i>
</I>&gt;<i> -	virtual	void _OhSoStatable1(); 	//&lt; FBC
</I>&gt;<i> -	virtual	void _OhSoStatable2(); 	//&lt; FBC
</I>&gt;<i> -	virtual	void _OhSoStatable3(); 	//&lt; FBC
</I>&gt;<i> -	uint32 _ohSoData[4]; 			//&lt; FBC
</I>&gt;<i> +	private:
</I>&gt;<i> +		friend class BEntry;
</I>&gt;<i> +		friend class BNode;
</I>&gt;<i>
</I>&gt;<i> -	virtual	status_t set_stat(struct stat &amp;st, uint32 what) = 0;
</I>&gt;<i> +		virtual	void _OhSoStatable1();
</I>&gt;<i> +		virtual	void _OhSoStatable2();
</I>&gt;<i> +		virtual	void _OhSoStatable3();
</I>&gt;<i> +		uint32 _reserved[4];
</I>&gt;<i> +
</I>&gt;<i> +		virtual	status_t set_stat(struct stat &amp;st, uint32 what) = 0;
</I>&gt;<i>  };
</I>&gt;<i>
</I>&gt;<i> -#ifdef USE_OPENBEOS_NAMESPACE
</I>&gt;<i> -}
</I>&gt;<i> -#endif // USE_OPENBEOS_NAMESPACE
</I>&gt;<i> -
</I>&gt;<i>  #endif // _STATABLE_H
</I>&gt;<i> -
</I>&gt;<i> -
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 3
</I>&gt;<i> Date: Thu, 25 Oct 2007 13:36:49 +0200
</I>&gt;<i> From: jackburton at BerliOS &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jackburton at mail.berlios.de</A>&gt;
</I>&gt;<i> Subject: [Haiku-commits] r22712 -
</I>&gt;<i> 	haiku/trunk/headers/build/os/interface
</I>&gt;<i> To: <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits at lists.berlios.de</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">200710251136.l9PBan1H027572 at sheep.berlios.de</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i>
</I>&gt;<i> Author: jackburton
</I>&gt;<i> Date: 2007-10-25 13:36:47 +0200 (Thu, 25 Oct 2007)
</I>&gt;<i> New Revision: 22712
</I>&gt;<i> ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22712&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22712&amp;view=rev</A>
</I>&gt;<i>
</I>&gt;<i> Removed:
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Alert.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Box.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Button.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ChannelControl.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ChannelSlider.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/CheckBox.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ColorControl.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ColorUtils.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Control.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Deskbar.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Dragger.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Font.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Input.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ListItem.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ListView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Menu.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/MenuBar.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/MenuField.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/MenuItem.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/MultiChannelControl.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/OptionControl.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/OptionPopUp.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/OutlineListView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Picture.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/PictureButton.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Polygon.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/PopUpMenu.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/PrintJob.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/RadioButton.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Region.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ScrollBar.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/ScrollView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/SeparatorItem.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Shape.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Shelf.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Slider.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/StatusBar.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/StringItem.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/StringView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/TabView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/TextControl.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/TextView.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/UnicodeBlockObjects.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/View.h
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Window.h
</I>&gt;<i> Log:
</I>&gt;<i> Removed most (unused) interface kit headers from the build folder
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Alert.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Box.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Button.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ChannelControl.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ChannelSlider.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/CheckBox.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ColorControl.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ColorUtils.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Control.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Deskbar.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Dragger.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Font.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Input.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ListItem.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ListView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Menu.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/MenuBar.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/MenuField.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/MenuItem.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/MultiChannelControl.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/OptionControl.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/OptionPopUp.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/OutlineListView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Picture.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/PictureButton.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Polygon.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/PopUpMenu.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/PrintJob.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/RadioButton.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Region.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ScrollBar.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/ScrollView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/SeparatorItem.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Shape.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Shelf.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Slider.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/StatusBar.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/StringItem.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/StringView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/TabView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/TextControl.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/TextView.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/UnicodeBlockObjects.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/View.h
</I>&gt;<i>
</I>&gt;<i> Deleted: haiku/trunk/headers/build/os/interface/Window.h
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> Message: 4
</I>&gt;<i> Date: Thu, 25 Oct 2007 13:46:09 +0200
</I>&gt;<i> From: jackburton at BerliOS &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jackburton at mail.berlios.de</A>&gt;
</I>&gt;<i> Subject: [Haiku-commits] r22713 - in haiku/trunk:
</I>&gt;<i> 	headers/build/os/interface	src/build/libbe/interface
</I>&gt;<i> 	src/build/libbe/storage
</I>&gt;<i> To: <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">haiku-commits at lists.berlios.de</A>
</I>&gt;<i> Message-ID: &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">200710251146.l9PBk9HT028264 at sheep.berlios.de</A>&gt;
</I>&gt;<i> Content-Type: text/plain; charset=UTF-8
</I>&gt;<i>
</I>&gt;<i> Author: jackburton
</I>&gt;<i> Date: 2007-10-25 13:46:06 +0200 (Thu, 25 Oct 2007)
</I>&gt;<i> New Revision: 22713
</I>&gt;<i> ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22713&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22713&amp;view=rev</A>
</I>&gt;<i>
</I>&gt;<i> Added:
</I>&gt;<i>    haiku/trunk/headers/build/os/interface/Region.h
</I>&gt;<i> Modified:
</I>&gt;<i>    haiku/trunk/src/build/libbe/interface/Region.cpp
</I>&gt;<i>    haiku/trunk/src/build/libbe/interface/RegionSupport.cpp
</I>&gt;<i>    haiku/trunk/src/build/libbe/storage/Statable.cpp
</I>&gt;<i> Log:
</I>&gt;<i> Looks like I deleted too much... copied Region.h back from the os
</I>&gt;<i> folder, updated Region.cpp and RegionSupport.cpp accordingly. Also
</I>&gt;<i> implemented empty BStatable destructor. Needed, since it's virtual now.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Copied: haiku/trunk/headers/build/os/interface/Region.h (from rev 22709,
</I>&gt;<i> haiku/trunk/headers/os/interface/Region.h)
</I>&gt;<i>
</I>&gt;<i> Modified: haiku/trunk/src/build/libbe/interface/Region.cpp
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/src/build/libbe/interface/Region.cpp	2007-10-25 11:36:47 UTC
</I>&gt;<i> (rev 22712)
</I>&gt;<i> +++ haiku/trunk/src/build/libbe/interface/Region.cpp	2007-10-25 11:46:06 UTC
</I>&gt;<i> (rev 22713)
</I>&gt;<i> @@ -1,85 +1,50 @@
</I>&gt;<i> -//------------------------------------------------------------------------------
</I>&gt;<i> -//	Copyright (c) 2003-2005, Haiku, Inc.
</I>&gt;<i> -//
</I>&gt;<i> -//	Permission is hereby granted, free of charge, to any person obtaining a
</I>&gt;<i> -//	copy of this software and associated documentation files (the
</I>&gt;<i> &quot;Software&quot;),
</I>&gt;<i> -//	to deal in the Software without restriction, including without
</I>&gt;<i> limitation
</I>&gt;<i> -//	the rights to use, copy, modify, merge, publish, distribute, sublicense,
</I>&gt;<i> -//	and/or sell copies of the Software, and to permit persons to whom the
</I>&gt;<i> -//	Software is furnished to do so, subject to the following conditions:
</I>&gt;<i> -//
</I>&gt;<i> -//	The above copyright notice and this permission notice shall be included
</I>&gt;<i> in
</I>&gt;<i> -//	all copies or substantial portions of the Software.
</I>&gt;<i> -//
</I>&gt;<i> -//	THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
</I>&gt;<i> OR
</I>&gt;<i> -//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</I>&gt;<i> -//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
</I>&gt;<i> THE
</I>&gt;<i> -//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</I>&gt;<i> -//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
</I>&gt;<i> -//	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
</I>&gt;<i> -//	DEALINGS IN THE SOFTWARE.
</I>&gt;<i> -//
</I>&gt;<i> -//	File Name:		Region.cpp
</I>&gt;<i> -//	Author:			Stefano Ceccherini (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">burton666 at libero.it</A>)
</I>&gt;<i> -//	Description:	Region class consisting of multiple rectangles
</I>&gt;<i> -//
</I>&gt;<i> -//------------------------------------------------------------------------------
</I>&gt;<i> +/*
</I>&gt;<i> + * Copyright 2003-2007, Haiku. All rights reserved.
</I>&gt;<i> + * Distributed under the terms of the MIT License.
</I>&gt;<i> + *
</I>&gt;<i> + *	Authors:
</I>&gt;<i> + *		Stefano Ceccherini (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">burton666 at libero.it</A>)
</I>&gt;<i> + *		Stephan A?mus &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">superstippi at gmx.de</A>&gt;
</I>&gt;<i> + */
</I>&gt;<i>
</I>&gt;<i> -//	Notes: As now, memory is always allocated and never freed (except on
</I>&gt;<i> destruction,
</I>&gt;<i> -//	or sometimes when a copy is made).
</I>&gt;<i> -//  This let us be a bit faster since we don't do many reallocations.
</I>&gt;<i> -//	But that means that even an empty region could &quot;waste&quot; much space, if it
</I>&gt;<i> contained
</I>&gt;<i> -//	many rects before being emptied.
</I>&gt;<i> -//	I.E: a region which contains 24 rects allocates more than 24 * 4 *
</I>&gt;<i> sizeof(int32)
</I>&gt;<i> -//  = 96 * sizeof(int32) bytes. If we call MakeEmpty(), that region will
</I>&gt;<i> contain no rects,
</I>&gt;<i> -//  but it will still keep the allocated memory.
</I>&gt;<i> -//	This shouldnt' be an issue, since usually BRegions are just used for
</I>&gt;<i> calculations,
</I>&gt;<i> -//	and don't last so long.
</I>&gt;<i> -//	Anyway, we can change that behaviour if we want, but BeOS's BRegion
</I>&gt;<i> seems to behave exactly
</I>&gt;<i> -//	like this.
</I>&gt;<i>
</I>&gt;<i> +#include &lt;Region.h&gt;
</I>&gt;<i>
</I>&gt;<i> -#include &lt;cstdlib&gt;
</I>&gt;<i> -#include &lt;cstring&gt;
</I>&gt;<i> +#include &lt;malloc.h&gt;
</I>&gt;<i> +#include &lt;string.h&gt;
</I>&gt;<i>
</I>&gt;<i>  #include &lt;Debug.h&gt;
</I>&gt;<i> -#include &lt;Region.h&gt;
</I>&gt;<i>
</I>&gt;<i> -#include &lt;clipping.h&gt;
</I>&gt;<i> -#include &lt;RegionSupport.h&gt;
</I>&gt;<i> +#include &quot;clipping.h&quot;
</I>&gt;<i> +#include &quot;RegionSupport.h&quot;
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +const static int32 kDataBlockSize = 8;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  /*! \brief Initializes a region. The region will have no rects,
</I>&gt;<i> -	and its bound will be invalid.
</I>&gt;<i> +	and its fBounds will be invalid.
</I>&gt;<i>  */
</I>&gt;<i>  BRegion::BRegion()
</I>&gt;<i> -	:
</I>&gt;<i> -	data_size(8),
</I>&gt;<i> -	data(NULL)	
</I>&gt;<i> +	: fCount(0)
</I>&gt;<i> +	, fDataSize(0)
</I>&gt;<i> +	, fBounds((clipping_rect){ 0, 0, 0, 0 })
</I>&gt;<i> +	, fData(NULL)
</I>&gt;<i>  {
</I>&gt;<i> -	data = (clipping_rect *)malloc(data_size * sizeof(clipping_rect));
</I>&gt;<i> -	
</I>&gt;<i> -	Support::ZeroRegion(*this);
</I>&gt;<i> +	_SetSize(kDataBlockSize);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>  /*! \brief Initializes a region to be a copy of another.
</I>&gt;<i>  	\param region The region to copy.
</I>&gt;<i>  */
</I>&gt;<i> -BRegion::BRegion(const BRegion &amp;region)
</I>&gt;<i> -	:
</I>&gt;<i> -	data(NULL)
</I>&gt;<i> +BRegion::BRegion(const BRegion&amp; region)
</I>&gt;<i> +	: fCount(0)
</I>&gt;<i> +	, fDataSize(0)
</I>&gt;<i> +	, fBounds((clipping_rect){ 0, 0, 0, 0 })
</I>&gt;<i> +	, fData(NULL)
</I>&gt;<i>  {
</I>&gt;<i> -	bound = region.bound;
</I>&gt;<i> -	count = region.count;
</I>&gt;<i> -	data_size = region.data_size;
</I>&gt;<i> -	
</I>&gt;<i> -	if (data_size &lt;= 0)
</I>&gt;<i> -		data_size = 1;
</I>&gt;<i> -		
</I>&gt;<i> -	data = (clipping_rect *)malloc(data_size * sizeof(clipping_rect));
</I>&gt;<i> -	
</I>&gt;<i> -	memcpy(data, region.data, count * sizeof(clipping_rect));
</I>&gt;<i> +	*this = region;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -87,31 +52,107 @@
</I>&gt;<i>  	\param rect The BRect to set the region to.
</I>&gt;<i>  */
</I>&gt;<i>  BRegion::BRegion(const BRect rect)
</I>&gt;<i> -	:
</I>&gt;<i> -	data_size(8),
</I>&gt;<i> -	data(NULL)	
</I>&gt;<i> +	: fCount(0)
</I>&gt;<i> +	, fDataSize(1)
</I>&gt;<i> +	, fBounds((clipping_rect){ 0, 0, 0, 0 })
</I>&gt;<i> +	, fData(&amp;fBounds)
</I>&gt;<i>  {
</I>&gt;<i> -	data = (clipping_rect *)malloc(data_size * sizeof(clipping_rect));
</I>&gt;<i> -		
</I>&gt;<i> -	Set(rect);	
</I>&gt;<i> +	if (!rect.IsValid())
</I>&gt;<i> +		return;
</I>&gt;<i> +
</I>&gt;<i> +	fBounds = _ConvertToInternal(rect);
</I>&gt;<i> +	fCount = 1;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> +// NOTE: private constructor
</I>&gt;<i> +/*!	\brief Initializes a region to contain a clipping_rect.
</I>&gt;<i> +	\param rect The clipping_rect to set the region to, already in
</I>&gt;<i> +	internal rect format.
</I>&gt;<i> +*/
</I>&gt;<i> +BRegion::BRegion(const clipping_rect&amp; rect)
</I>&gt;<i> +	: fCount(1)
</I>&gt;<i> +	, fDataSize(1)
</I>&gt;<i> +	, fBounds(rect)
</I>&gt;<i> +	, fData(&amp;fBounds)
</I>&gt;<i> +{
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> +
</I>&gt;<i>  /*!	\brief Frees the allocated memory.
</I>&gt;<i>  */
</I>&gt;<i>  BRegion::~BRegion()
</I>&gt;<i>  {
</I>&gt;<i> -	free(data);
</I>&gt;<i> +	if (fData != &amp;fBounds)
</I>&gt;<i> +		free(fData);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*!	\brief Modifies the region to be a copy of the given BRegion.
</I>&gt;<i> +	\param region the BRegion to copy.
</I>&gt;<i> +	\return This function always returns \c *this.
</I>&gt;<i> +*/
</I>&gt;<i> +BRegion &amp;
</I>&gt;<i> +BRegion::operator=(const BRegion &amp;region)
</I>&gt;<i> +{
</I>&gt;<i> +	if (&amp;region == this)
</I>&gt;<i> +		return *this;
</I>&gt;<i> +
</I>&gt;<i> +	// handle reallocation if we're too small to contain
</I>&gt;<i> +	// the other region
</I>&gt;<i> +	if (_SetSize(region.fDataSize)) {
</I>&gt;<i> +		memcpy(fData, region.fData, region.fCount * sizeof(clipping_rect));
</I>&gt;<i> +
</I>&gt;<i> +		fBounds = region.fBounds;
</I>&gt;<i> +		fCount = region.fCount;
</I>&gt;<i> +	}
</I>&gt;<i> +	
</I>&gt;<i> +	return *this;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*!	\brief Set the region to contain just the given BRect.
</I>&gt;<i> +	\param newBounds A BRect.
</I>&gt;<i> +*/
</I>&gt;<i> +void
</I>&gt;<i> +BRegion::Set(BRect newBounds)
</I>&gt;<i> +{
</I>&gt;<i> +	Set(_Convert(newBounds));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*!	\brief Set the region to contain just the given clipping_rect.
</I>&gt;<i> +	\param newBounds A clipping_rect.
</I>&gt;<i> +*/
</I>&gt;<i> +void
</I>&gt;<i> +BRegion::Set(clipping_rect newBounds)
</I>&gt;<i> +{
</I>&gt;<i> +	_SetSize(1);
</I>&gt;<i> +
</I>&gt;<i> +	if (valid_rect(newBounds) &amp;&amp; fData) {
</I>&gt;<i> +		fCount = 1;
</I>&gt;<i> +		// cheap convert to internal rect format
</I>&gt;<i> +		newBounds.right++;
</I>&gt;<i> +		newBounds.bottom++;
</I>&gt;<i> +		fData[0] = fBounds = newBounds;
</I>&gt;<i> +	} else
</I>&gt;<i> +		MakeEmpty();
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  /*! \brief Returns the bounds of the region.
</I>&gt;<i>  	\return A BRect which represents the bounds of the region.
</I>&gt;<i>  */
</I>&gt;<i>  BRect
</I>&gt;<i>  BRegion::Frame() const
</I>&gt;<i>  {
</I>&gt;<i> -	return to_BRect(bound);
</I>&gt;<i> +	return BRect(fBounds.left, fBounds.top,
</I>&gt;<i> +		fBounds.right - 1, fBounds.bottom - 1);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -121,7 +162,8 @@
</I>&gt;<i>  clipping_rect
</I>&gt;<i>  BRegion::FrameInt() const
</I>&gt;<i>  {
</I>&gt;<i> -	return bound;
</I>&gt;<i> +	return (clipping_rect){ fBounds.left, fBounds.top,
</I>&gt;<i> +		fBounds.right - 1, fBounds.bottom - 1 };
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -131,12 +173,15 @@
</I>&gt;<i>  		otherwise, it returns an invalid BRect.
</I>&gt;<i>  */
</I>&gt;<i>  BRect
</I>&gt;<i> -BRegion::RectAt(int32 index)
</I>&gt;<i> +BRegion::RectAt(int32 index) /*const*/
</I>&gt;<i>  {
</I>&gt;<i> -	if (index &gt;= 0 &amp;&amp; index &lt; count)
</I>&gt;<i> -		return to_BRect(data[index]);
</I>&gt;<i> +	if (index &gt;= 0 &amp;&amp; index &lt; fCount) {
</I>&gt;<i> +		const clipping_rect&amp; r = fData[index];
</I>&gt;<i> +		return BRect(r.left, r.top, r.right - 1, r.bottom - 1);
</I>&gt;<i> +	}
</I>&gt;<i>  	
</I>&gt;<i> -	return BRect(); //An invalid BRect
</I>&gt;<i> +	return BRect();
</I>&gt;<i> +		// an invalid BRect
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -146,13 +191,15 @@
</I>&gt;<i>  		otherwise, it returns an invalid clipping_rect.
</I>&gt;<i>  */
</I>&gt;<i>  clipping_rect
</I>&gt;<i> -BRegion::RectAtInt(int32 index)
</I>&gt;<i> +BRegion::RectAtInt(int32 index) /*const*/
</I>&gt;<i>  {
</I>&gt;<i> -	if (index &gt;= 0 &amp;&amp; index &lt; count)
</I>&gt;<i> -		return data[index];
</I>&gt;<i> +	if (index &gt;= 0 &amp;&amp; index &lt; fCount) {
</I>&gt;<i> +		const clipping_rect&amp; r = fData[index];
</I>&gt;<i> +		return (clipping_rect){ r.left, r.top, r.right - 1, r.bottom - 1 };
</I>&gt;<i> +	}
</I>&gt;<i>
</I>&gt;<i> -	clipping_rect rect = { 1, 1, 0, 0 };
</I>&gt;<i> -	return rect;
</I>&gt;<i> +	return (clipping_rect){ 1, 1, 0, 0 };
</I>&gt;<i> +		// an invalid clipping_rect
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -160,39 +207,15 @@
</I>&gt;<i>  	\return An int32 which is the total number of rects in the region.
</I>&gt;<i>  */
</I>&gt;<i>  int32
</I>&gt;<i> -BRegion::CountRects()
</I>&gt;<i> +BRegion::CountRects() /*const*/
</I>&gt;<i>  {
</I>&gt;<i> -	return count;
</I>&gt;<i> +	return fCount;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Set the region to contain just the given BRect.
</I>&gt;<i> -	\param newBounds A BRect.
</I>&gt;<i> -*/
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::Set(BRect newBounds)
</I>&gt;<i> -{
</I>&gt;<i> -	Set(to_clipping_rect(newBounds));
</I>&gt;<i> -}
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Set the region to contain just the given clipping_rect.
</I>&gt;<i> -	\param newBounds A clipping_rect.
</I>&gt;<i> -*/
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::Set(clipping_rect newBounds)
</I>&gt;<i> -{
</I>&gt;<i> -	ASSERT(data_size &gt; 0);
</I>&gt;<i> -
</I>&gt;<i> -	if (valid_rect(newBounds)) {
</I>&gt;<i> -		count = 1;
</I>&gt;<i> -		data[0] = newBounds;
</I>&gt;<i> -		bound = newBounds;
</I>&gt;<i> -	} else
</I>&gt;<i> -		Support::ZeroRegion(*this);	
</I>&gt;<i> -}
</I>&gt;<i> -
</I>&gt;<i> -
</I>&gt;<i>  /*!	\brief Check if the region has any area in common with the given BRect.
</I>&gt;<i>  	\param rect The BRect to check the region against to.
</I>&gt;<i>  	\return \ctrue if the region has any area in common with the BRect,
</I>&gt;<i> \cfalse if not.
</I>&gt;<i> @@ -200,7 +223,7 @@
</I>&gt;<i>  bool
</I>&gt;<i>  BRegion::Intersects(BRect rect) const
</I>&gt;<i>  {
</I>&gt;<i> -	return Intersects(to_clipping_rect(rect));
</I>&gt;<i> +	return Intersects(_Convert(rect));
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -211,15 +234,13 @@
</I>&gt;<i>  bool
</I>&gt;<i>  BRegion::Intersects(clipping_rect rect) const
</I>&gt;<i>  {
</I>&gt;<i> -	if (!rects_intersect(rect, bound))
</I>&gt;<i> -		return false;
</I>&gt;<i> +	// cheap convert to internal rect format
</I>&gt;<i> +	rect.right ++;
</I>&gt;<i> +	rect.bottom ++;
</I>&gt;<i>
</I>&gt;<i> -	for (long c = 0; c &lt; count; c++) {
</I>&gt;<i> -		if (rects_intersect(data[c], rect))
</I>&gt;<i> -			return true;
</I>&gt;<i> -	}
</I>&gt;<i> -	
</I>&gt;<i> -	return false;	
</I>&gt;<i> +	int result = Support::XRectInRegion(this, rect);
</I>&gt;<i> +
</I>&gt;<i> +	return result &gt; Support::RectangleOut;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -228,18 +249,9 @@
</I>&gt;<i>  	\return \ctrue if the region contains the BPoint, \cfalse if not.
</I>&gt;<i>  */
</I>&gt;<i>  bool
</I>&gt;<i> -BRegion::Contains(BPoint pt) const
</I>&gt;<i> +BRegion::Contains(BPoint point) const
</I>&gt;<i>  {
</I>&gt;<i> -	// If the point doesn't lie within the region's bounds,
</I>&gt;<i> -	// don't even try it against the region's rects.
</I>&gt;<i> -	if (!point_in(bound, pt))
</I>&gt;<i> -		return false;
</I>&gt;<i> -
</I>&gt;<i> -	for (long c = 0; c &lt; count; c++) {
</I>&gt;<i> -		if (point_in(data[c], pt))
</I>&gt;<i> -			return true;
</I>&gt;<i> -	}
</I>&gt;<i> -	return false;
</I>&gt;<i> +	return Support::XPointInRegion(this, (int)point.x, (int)point.y);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -249,17 +261,9 @@
</I>&gt;<i>  	\return \ctrue if the region contains the point, \cfalse if not.
</I>&gt;<i>  */
</I>&gt;<i>  bool
</I>&gt;<i> -BRegion::Contains(int32 x, int32 y)
</I>&gt;<i> +BRegion::Contains(int32 x, int32 y) /*const*/
</I>&gt;<i>  {
</I>&gt;<i> -	// see above
</I>&gt;<i> -	if (!point_in(bound, x, y))
</I>&gt;<i> -		return false;
</I>&gt;<i> -
</I>&gt;<i> -	for (long c = 0; c &lt; count; c++) {
</I>&gt;<i> -		if (point_in(data[c], x, y))
</I>&gt;<i> -			return true;
</I>&gt;<i> -	}
</I>&gt;<i> -	return false;
</I>&gt;<i> +	return Support::XPointInRegion(this, x, y);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -269,27 +273,35 @@
</I>&gt;<i>  BRegion::PrintToStream() const
</I>&gt;<i>  {
</I>&gt;<i>  	Frame().PrintToStream();
</I>&gt;<i> -	
</I>&gt;<i> -	for (long c = 0; c &lt; count; c++) {
</I>&gt;<i> -		clipping_rect *rect = &amp;data[c];
</I>&gt;<i> -		printf(&quot;data = BRect(l:%ld.0, t:%ld.0, r:%ld.0, b:%ld.0)\n&quot;,
</I>&gt;<i> -			rect-&gt;left, rect-&gt;top, rect-&gt;right, rect-&gt;bottom);
</I>&gt;<i> -	}	
</I>&gt;<i> +
</I>&gt;<i> +	for (long i = 0; i &lt; fCount; i++) {
</I>&gt;<i> +		clipping_rect *rect = &amp;fData[i];
</I>&gt;<i> +		printf(&quot;data[%ld] = BRect(l:%ld.0, t:%ld.0, r:%ld.0, b:%ld.0)\n&quot;,
</I>&gt;<i> +			i, rect-&gt;left, rect-&gt;top, rect-&gt;right - 1, rect-&gt;bottom - 1);
</I>&gt;<i> +	}
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  /*!	\brief Offsets all region's rects, and bounds by the given values.
</I>&gt;<i>  	\param dh The horizontal offset.
</I>&gt;<i>  	\param dv The vertical offset.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i> -BRegion::OffsetBy(int32 dh, int32 dv)
</I>&gt;<i> +BRegion::OffsetBy(int32 x, int32 y)
</I>&gt;<i>  {
</I>&gt;<i> -	if (count &gt; 0) {
</I>&gt;<i> -		for (long c = 0; c &lt; count; c++)
</I>&gt;<i> -			offset_rect(data[c], dh, dv);
</I>&gt;<i> +	if (x == 0 &amp;&amp; y == 0)
</I>&gt;<i> +		return;
</I>&gt;<i>
</I>&gt;<i> -		offset_rect(bound, dh, dv);	
</I>&gt;<i> +	if (fCount &gt; 0) {
</I>&gt;<i> +		if (fData != &amp;fBounds) {
</I>&gt;<i> +			for (long i = 0; i &lt; fCount; i++)
</I>&gt;<i> +				offset_rect(fData[i], x, y);
</I>&gt;<i> +		}
</I>&gt;<i> +
</I>&gt;<i> +		offset_rect(fBounds, x, y);
</I>&gt;<i>  	}
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> @@ -299,17 +311,21 @@
</I>&gt;<i>  void
</I>&gt;<i>  BRegion::MakeEmpty()
</I>&gt;<i>  {
</I>&gt;<i> -	Support::ZeroRegion(*this);
</I>&gt;<i> +	fBounds = (clipping_rect){ 0, 0, 0, 0 };
</I>&gt;<i> +	fCount = 0;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  /*!	\brief Modifies the region, so that it includes the given BRect.
</I>&gt;<i>  	\param rect The BRect to be included by the region.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i>  BRegion::Include(BRect rect)
</I>&gt;<i>  {
</I>&gt;<i> -	Include(to_clipping_rect(rect));
</I>&gt;<i> +	Include(_Convert(rect));
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -319,13 +335,17 @@
</I>&gt;<i>  void
</I>&gt;<i>  BRegion::Include(clipping_rect rect)
</I>&gt;<i>  {
</I>&gt;<i> -	BRegion region;
</I>&gt;<i> -	BRegion newRegion;	
</I>&gt;<i> +	// convert to internal rect format
</I>&gt;<i> +	rect.right ++;
</I>&gt;<i> +	rect.bottom ++;
</I>&gt;<i>
</I>&gt;<i> -	region.Set(rect);
</I>&gt;<i> -	
</I>&gt;<i> -	Support::OrRegion(*this, region, newRegion);
</I>&gt;<i> -	Support::CopyRegion(newRegion, *this);
</I>&gt;<i> +	// use private clipping_rect constructor which avoids malloc()
</I>&gt;<i> +	BRegion t(rect);
</I>&gt;<i> +
</I>&gt;<i> +	BRegion result;
</I>&gt;<i> +	Support::XUnionRegion(this, &amp;t, &amp;result);
</I>&gt;<i> +
</I>&gt;<i> +	_AdoptRegionData(result);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -333,22 +353,25 @@
</I>&gt;<i>  	\param region The region to be included.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i> -BRegion::Include(const BRegion *region)
</I>&gt;<i> +BRegion::Include(const BRegion* region)
</I>&gt;<i>  {
</I>&gt;<i> -	BRegion newRegion;
</I>&gt;<i> -	
</I>&gt;<i> -	Support::OrRegion(*this, *region, newRegion);
</I>&gt;<i> -	Support::CopyRegion(newRegion, *this);
</I>&gt;<i> +	BRegion result;
</I>&gt;<i> +	Support::XUnionRegion(this, region, &amp;result);
</I>&gt;<i> +
</I>&gt;<i> +	_AdoptRegionData(result);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i>  /*!	\brief Modifies the region, excluding the area represented by the given
</I>&gt;<i> BRect.
</I>&gt;<i>  	\param rect The BRect to be excluded.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i>  BRegion::Exclude(BRect rect)
</I>&gt;<i>  {
</I>&gt;<i> -	Exclude(to_clipping_rect(rect));
</I>&gt;<i> +	Exclude(_Convert(rect));
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> @@ -358,150 +381,146 @@
</I>&gt;<i>  void
</I>&gt;<i>  BRegion::Exclude(clipping_rect rect)
</I>&gt;<i>  {
</I>&gt;<i> -	BRegion region;
</I>&gt;<i> -	BRegion newRegion;
</I>&gt;<i> -	
</I>&gt;<i> -	region.Set(rect);
</I>&gt;<i> +	// convert to internal rect format
</I>&gt;<i> +	rect.right ++;
</I>&gt;<i> +	rect.bottom ++;
</I>&gt;<i>
</I>&gt;<i> -	Support::SubRegion(*this, region, newRegion);
</I>&gt;<i> -	Support::CopyRegion(newRegion, *this);
</I>&gt;<i> +	// use private clipping_rect constructor which avoids malloc()
</I>&gt;<i> +	BRegion t(rect);
</I>&gt;<i> +
</I>&gt;<i> +	BRegion result;
</I>&gt;<i> +	Support::XSubtractRegion(this, &amp;t, &amp;result);
</I>&gt;<i> +
</I>&gt;<i> +	_AdoptRegionData(result);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Modifies the region, excluding the area contained in the given
</I>&gt;<i> BRegion.
</I>&gt;<i> +/*!	\brief Modifies the region, excluding the area contained in the given
</I>&gt;<i> +		BRegion.
</I>&gt;<i>  	\param region The BRegion to be excluded.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i> -BRegion::Exclude(const BRegion *region)
</I>&gt;<i> +BRegion::Exclude(const BRegion* region)
</I>&gt;<i>  {
</I>&gt;<i> -	BRegion newRegion;
</I>&gt;<i> -	
</I>&gt;<i> -	Support::SubRegion(*this, *region, newRegion);
</I>&gt;<i> -	Support::CopyRegion(newRegion, *this);
</I>&gt;<i> +	BRegion result;
</I>&gt;<i> +	Support::XSubtractRegion(this, region, &amp;result);
</I>&gt;<i> +
</I>&gt;<i> +	_AdoptRegionData(result);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Modifies the region, so that it will contain just the area in
</I>&gt;<i> common with the given BRegion.
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*!	\brief Modifies the region, so that it will contain just the area
</I>&gt;<i> +		in common with the given BRegion.
</I>&gt;<i>  	\param region the BRegion to intersect to.
</I>&gt;<i>  */
</I>&gt;<i>  void
</I>&gt;<i> -BRegion::IntersectWith(const BRegion *region)
</I>&gt;<i> +BRegion::IntersectWith(const BRegion* region)
</I>&gt;<i>  {
</I>&gt;<i> -	BRegion newRegion;
</I>&gt;<i> -	
</I>&gt;<i> -	Support::AndRegion(*this, *region, newRegion);
</I>&gt;<i> -	Support::CopyRegion(newRegion, *this);
</I>&gt;<i> +	BRegion result;
</I>&gt;<i> +	Support::XIntersectRegion(this, region, &amp;result);
</I>&gt;<i> +
</I>&gt;<i> +	_AdoptRegionData(result);
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Modifies the region to be a copy of the given BRegion.
</I>&gt;<i> -	\param region the BRegion to copy.
</I>&gt;<i> -	\return This function always returns \c *this.
</I>&gt;<i> +// #pragma mark -
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*!	\brief Takes over the data of a region and marks that region empty.
</I>&gt;<i> +	\param region The region to adopt the data from.
</I>&gt;<i>  */
</I>&gt;<i> -BRegion &amp;
</I>&gt;<i> -BRegion::operator=(const BRegion &amp;region)
</I>&gt;<i> +void
</I>&gt;<i> +BRegion::_AdoptRegionData(BRegion&amp; region)
</I>&gt;<i>  {
</I>&gt;<i> -	if (&amp;region != this) {
</I>&gt;<i> -		free(data);
</I>&gt;<i> -		bound = region.bound;
</I>&gt;<i> -		count = region.count;
</I>&gt;<i> -		data_size = region.data_size;
</I>&gt;<i> -		
</I>&gt;<i> -		if (data_size &lt;= 0)
</I>&gt;<i> -			data_size = 1;
</I>&gt;<i> -			
</I>&gt;<i> -		data = (clipping_rect *)malloc(data_size * sizeof(clipping_rect));
</I>&gt;<i> -		
</I>&gt;<i> -		memcpy(data, region.data, count * sizeof(clipping_rect));
</I>&gt;<i> -	}
</I>&gt;<i> -	
</I>&gt;<i> -	return *this;
</I>&gt;<i> +	fCount = region.fCount;
</I>&gt;<i> +	fDataSize = region.fDataSize;
</I>&gt;<i> +	fBounds = region.fBounds;
</I>&gt;<i> +	if (fData != &amp;fBounds)
</I>&gt;<i> +		free(fData);
</I>&gt;<i> +	if (region.fData != &amp;region.fBounds)
</I>&gt;<i> +		fData = region.fData;
</I>&gt;<i> +	else
</I>&gt;<i> +		fData = &fBounds;
</I>&gt;<i> +
</I>&gt;<i> +	// NOTE: MakeEmpty() is not called since _AdoptRegionData is only
</I>&gt;<i> +	// called with internally allocated regions, so they don't need to
</I>&gt;<i> +	// be left in a valid state.
</I>&gt;<i> +	region.fData = NULL;
</I>&gt;<i> +//	region.MakeEmpty();
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Adds a rect to the region.
</I>&gt;<i> -	\param rect The clipping_rect to be added.
</I>&gt;<i> -	
</I>&gt;<i> -	Adds the given rect to the region, merging it with another already
</I>&gt;<i> contained in the region,
</I>&gt;<i> -	if possible. Recalculate the region's bounds if needed.
</I>&gt;<i> +/*!	\brief Reallocate the memory in the region.
</I>&gt;<i> +	\param newSize The amount of rectangles that the region should be
</I>&gt;<i> +		able to hold.
</I>&gt;<i>  */
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::_AddRect(clipping_rect rect)
</I>&gt;<i> +bool
</I>&gt;<i> +BRegion::_SetSize(long newSize)
</I>&gt;<i>  {
</I>&gt;<i> -	ASSERT(count &gt;= 0);
</I>&gt;<i> -	ASSERT(data_size &gt;= 0);
</I>&gt;<i> -	ASSERT(valid_rect(rect));
</I>&gt;<i> +	// we never shrink the size
</I>&gt;<i> +	newSize = max_c(fDataSize, newSize);
</I>&gt;<i> +	if (newSize == fDataSize)
</I>&gt;<i> +		return true;
</I>&gt;<i>
</I>&gt;<i> -	// Should we just reallocate the memory and
</I>&gt;<i> -	// copy the rect ?
</I>&gt;<i> -	bool addRect = true;
</I>&gt;<i> -		
</I>&gt;<i> -	if (count &gt; 0) {
</I>&gt;<i> -		// Wait! We could merge the rect with one of the
</I>&gt;<i> -		// existing rectangles, if it's adiacent.
</I>&gt;<i> -		// We just check it against the last rectangle, since
</I>&gt;<i> -		// we are keeping them sorted by their &quot;top&quot; coordinates.
</I>&gt;<i> -		long last = count - 1;
</I>&gt;<i> -		if (rect.left == data[last].left &amp;&amp; rect.right == data[last].right
</I>&gt;<i> -				&amp;&amp; rect.top == data[last].bottom + 1) {
</I>&gt;<i> -		
</I>&gt;<i> -			data[last].bottom = rect.bottom;
</I>&gt;<i> -			addRect = false;
</I>&gt;<i> -		
</I>&gt;<i> -		} else if (rect.top == data[last].top &amp;&amp; rect.bottom ==
</I>&gt;<i> data[last].bottom) {			
</I>&gt;<i> -			if (rect.left == data[last].right + 1) {
</I>&gt;<i> +	// align newSize to multiple of kDataBlockSize
</I>&gt;<i> +	newSize = ((newSize + kDataBlockSize - 1) / kDataBlockSize) *
</I>&gt;<i> kDataBlockSize;
</I>&gt;<i>
</I>&gt;<i> -				data[last].right = rect.right;
</I>&gt;<i> -				addRect = false;
</I>&gt;<i> -
</I>&gt;<i> -			} else if (rect.right == data[last].left - 1) {
</I>&gt;<i> -
</I>&gt;<i> -				data[last].left = rect.left;
</I>&gt;<i> -				addRect = false;
</I>&gt;<i> -			}	
</I>&gt;<i> -		}
</I>&gt;<i> -	}		
</I>&gt;<i> +	if (newSize &gt; 0) {
</I>&gt;<i> +		if (fData == &amp;fBounds) {
</I>&gt;<i> +			fData = (clipping_rect*)malloc(newSize * sizeof(clipping_rect));
</I>&gt;<i> +			fData[0] = fBounds;
</I>&gt;<i> +		} else if (fData) {
</I>&gt;<i> +			clipping_rect* resizedData = (clipping_rect*)realloc(fData,
</I>&gt;<i> +				newSize * sizeof(clipping_rect));
</I>&gt;<i> +			if (!resizedData) {
</I>&gt;<i> +				// failed to resize, but we cannot keep the
</I>&gt;<i> +				// previous state of the object
</I>&gt;<i> +				free(fData);
</I>&gt;<i> +				fData = NULL;
</I>&gt;<i> +			} else
</I>&gt;<i> +				fData = resizedData;
</I>&gt;<i> +		} else
</I>&gt;<i> +			fData = (clipping_rect*)malloc(newSize * sizeof(clipping_rect));
</I>&gt;<i> +	} else {
</I>&gt;<i> +		// just an empty region, but no error
</I>&gt;<i> +		MakeEmpty();
</I>&gt;<i> +		return true;
</I>&gt;<i> +	}
</I>&gt;<i>  	
</I>&gt;<i> -	// We weren't lucky.... just add the rect as a new one
</I>&gt;<i> -	if (addRect) {
</I>&gt;<i> -		if (data_size &lt;= count)
</I>&gt;<i> -			set_size(count + 16);
</I>&gt;<i> -			
</I>&gt;<i> -		data[count] = rect;
</I>&gt;<i> -		
</I>&gt;<i> -		count++;
</I>&gt;<i> +	if (!fData) {
</I>&gt;<i> +		// allocation actually failed
</I>&gt;<i> +		fDataSize = 0;
</I>&gt;<i> +		MakeEmpty();
</I>&gt;<i> +		return false;
</I>&gt;<i>  	}
</I>&gt;<i> -	
</I>&gt;<i> -	// Recalculate bounds
</I>&gt;<i> -	if (rect.top &lt; bound.top)
</I>&gt;<i> -		bound.top = rect.top;
</I>&gt;<i>
</I>&gt;<i> -	if (rect.left &lt; bound.left)
</I>&gt;<i> -		bound.left = rect.left;
</I>&gt;<i> -
</I>&gt;<i> -	if (rect.right &gt; bound.right)
</I>&gt;<i> -		bound.right = rect.right;
</I>&gt;<i> -
</I>&gt;<i> -	if (rect.bottom &gt; bound.bottom)
</I>&gt;<i> -		bound.bottom = rect.bottom;
</I>&gt;<i> +	fDataSize = newSize;
</I>&gt;<i> +	return true;
</I>&gt;<i>  }
</I>&gt;<i>
</I>&gt;<i> +clipping_rect
</I>&gt;<i> +BRegion::_Convert(const BRect&amp; rect) const
</I>&gt;<i> +{
</I>&gt;<i> +	return (clipping_rect){ (int)floorf(rect.left), (int)floorf(rect.top),
</I>&gt;<i> +		(int)ceilf(rect.right), (int)ceilf(rect.bottom) };
</I>&gt;<i> +}
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief Reallocate the memory in the region.
</I>&gt;<i> -	\param new_size The amount of rectangles that the region could contain.
</I>&gt;<i> -*/
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::set_size(long new_size)
</I>&gt;<i> +
</I>&gt;<i> +clipping_rect
</I>&gt;<i> +BRegion::_ConvertToInternal(const BRect&amp; rect) const
</I>&gt;<i>  {
</I>&gt;<i> -	if (new_size &lt;= 0)
</I>&gt;<i> -		new_size = data_size + 16;
</I>&gt;<i> -	
</I>&gt;<i> -	data = (clipping_rect *)realloc(data, new_size * sizeof(clipping_rect));
</I>&gt;<i> -	
</I>&gt;<i> -	if (data == NULL)
</I>&gt;<i> -		debugger(&quot;BRegion::set_size realloc error\n&quot;);
</I>&gt;<i> -	
</I>&gt;<i> -	data_size = new_size;
</I>&gt;<i> -	
</I>&gt;<i> -	ASSERT(count &lt;= data_size);		
</I>&gt;<i> +	return (clipping_rect){ (int)floorf(rect.left), (int)floorf(rect.top),
</I>&gt;<i> +		(int)ceilf(rect.right) + 1, (int)ceilf(rect.bottom) + 1 };
</I>&gt;<i>  }
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +clipping_rect
</I>&gt;<i> +BRegion::_ConvertToInternal(const clipping_rect&amp; rect) const
</I>&gt;<i> +{
</I>&gt;<i> +	return (clipping_rect){ rect.left, rect.top,
</I>&gt;<i> +		rect.right + 1, rect.bottom + 1 };
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i>
</I>&gt;<i> Modified: haiku/trunk/src/build/libbe/interface/RegionSupport.cpp
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/src/build/libbe/interface/RegionSupport.cpp	2007-10-25
</I>&gt;<i> 11:36:47 UTC (rev 22712)
</I>&gt;<i> +++ haiku/trunk/src/build/libbe/interface/RegionSupport.cpp	2007-10-25
</I>&gt;<i> 11:46:06 UTC (rev 22713)
</I>&gt;<i> @@ -1,915 +1,1637 @@
</I>&gt;<i> -//------------------------------------------------------------------------------
</I>&gt;<i> -//	Copyright (c) 2003-2005, Haiku, Inc.
</I>&gt;<i> -//
</I>&gt;<i> -//	Permission is hereby granted, free of charge, to any person obtaining a
</I>&gt;<i> -//	copy of this software and associated documentation files (the
</I>&gt;<i> &quot;Software&quot;),
</I>&gt;<i> -//	to deal in the Software without restriction, including without
</I>&gt;<i> limitation
</I>&gt;<i> -//	the rights to use, copy, modify, merge, publish, distribute, sublicense,
</I>&gt;<i> -//	and/or sell copies of the Software, and to permit persons to whom the
</I>&gt;<i> -//	Software is furnished to do so, subject to the following conditions:
</I>&gt;<i> -//
</I>&gt;<i> -//	The above copyright notice and this permission notice shall be included
</I>&gt;<i> in
</I>&gt;<i> -//	all copies or substantial portions of the Software.
</I>&gt;<i> -//
</I>&gt;<i> -//	THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
</I>&gt;<i> OR
</I>&gt;<i> -//	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</I>&gt;<i> -//	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
</I>&gt;<i> THE
</I>&gt;<i> -//	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
</I>&gt;<i> -//	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
</I>&gt;<i> -//	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
</I>&gt;<i> -//	DEALINGS IN THE SOFTWARE.
</I>&gt;<i> -//
</I>&gt;<i> -//	File Name:		RegionSupport.cpp
</I>&gt;<i> -//	Author:			Stefano Ceccherini (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">burton666 at libero.it</A>)
</I>&gt;<i> -//	Description:	Class that does the dirty work for BRegion.
</I>&gt;<i> -//
</I>&gt;<i> -//------------------------------------------------------------------------------
</I>&gt;<i> +/* $Xorg: Region.c,v 1.6 2001/02/09 02:03:35 xorgcvs Exp $ */
</I>&gt;<i> +/************************************************************************
</I>&gt;<i>
</I>&gt;<i> -// TODO: check for possible performance issue in ROr() and RSub().
</I>&gt;<i> -// Check if inlining some methods can make us be faster.
</I>&gt;<i> -
</I>&gt;<i> -// Standard Includes
</I>&gt;<i> -----------------------------------------------------------
</I>&gt;<i> -#include &lt;cstring&gt;
</I>&gt;<i> +Copyright 1987, 1988, 1998  The Open Group
</I>&gt;<i> +
</I>&gt;<i> +Permission to use, copy, modify, distribute, and sell this software and its
</I>&gt;<i> +documentation for any purpose is hereby granted without fee, provided that
</I>&gt;<i> +the above copyright notice appear in all copies and that both that
</I>&gt;<i> +copyright notice and this permission notice appear in supporting
</I>&gt;<i> +documentation.
</I>&gt;<i> +
</I>&gt;<i> +The above copyright notice and this permission notice shall be included in
</I>&gt;<i> +all copies or substantial portions of the Software.
</I>&gt;<i> +
</I>&gt;<i> +THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
</I>&gt;<i> +IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
</I>&gt;<i> +FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
</I>&gt;<i> THE
</I>&gt;<i> +OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
</I>&gt;<i> +AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
</I>&gt;<i> +CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</I>&gt;<i> +
</I>&gt;<i> +Except as contained in this notice, the name of The Open Group shall not be
</I>&gt;<i> +used in advertising or otherwise to promote the sale, use or other dealings
</I>&gt;<i> +in this Software without prior written authorization from The Open Group.
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +Copyright 1987, 1988 by Digital Equipment Corporation, Maynard,
</I>&gt;<i> Massachusetts.
</I>&gt;<i> +
</I>&gt;<i> +                        All Rights Reserved
</I>&gt;<i> +
</I>&gt;<i> +Permission to use, copy, modify, and distribute this software and its
</I>&gt;<i> +documentation for any purpose and without fee is hereby granted,
</I>&gt;<i> +provided that the above copyright notice appear in all copies and that
</I>&gt;<i> +both that copyright notice and this permission notice appear in
</I>&gt;<i> +supporting documentation, and that the name of Digital not be
</I>&gt;<i> +used in advertising or publicity pertaining to distribution of the
</I>&gt;<i> +software without specific, written prior permission.
</I>&gt;<i> +
</I>&gt;<i> +DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
</I>&gt;<i> +ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
</I>&gt;<i> +DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
</I>&gt;<i> +ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
</I>&gt;<i> +WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
</I>&gt;<i> +ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
</I>&gt;<i> +SOFTWARE.
</I>&gt;<i> +
</I>&gt;<i> +************************************************************************/
</I>&gt;<i> +/* $XFree86: xc/lib/X11/Region.c,v 1.9 2002/06/04 22:19:57 dawes Exp $ */
</I>&gt;<i> +/*
</I>&gt;<i> + * The functions in this file implement the BRegion* abstraction, similar
</I>&gt;<i> to one
</I>&gt;<i> + * used in the X11 sample server. A BRegion* is simply an area, as the name
</I>&gt;<i> + * implies, and is implemented as a &quot;y-x-banded&quot; array of rectangles. To
</I>&gt;<i> + * explain: Each BRegion* is made up of a certain number of rectangles
</I>&gt;<i> sorted
</I>&gt;<i> + * by y coordinate first, and then by x coordinate.
</I>&gt;<i> + *
</I>&gt;<i> + * Furthermore, the rectangles are banded such that every rectangle with a
</I>&gt;<i> + * given upper-left y coordinate (top) will have the same lower-right y
</I>&gt;<i> + * coordinate (bottom) and vice versa. If a rectangle has scanlines in a
</I>&gt;<i> band, it
</I>&gt;<i> + * will span the entire vertical distance of the band. This means that some
</I>&gt;<i> + * areas that could be merged into a taller rectangle will be represented
</I>&gt;<i> as
</I>&gt;<i> + * several shorter rectangles to account for shorter rectangles to its left
</I>&gt;<i> + * or right but within its &quot;vertical scope&quot;.
</I>&gt;<i> + *
</I>&gt;<i> + * An added constraint on the rectangles is that they must cover as much
</I>&gt;<i> + * horizontal area as possible. E.g. no two rectangles in a band are
</I>&gt;<i> allowed
</I>&gt;<i> + * to touch.
</I>&gt;<i> + *
</I>&gt;<i> + * Whenever possible, bands will be merged together to cover a greater
</I>&gt;<i> vertical
</I>&gt;<i> + * distance (and thus reduce the number of rectangles). Two bands can be
</I>&gt;<i> merged
</I>&gt;<i> + * only if the bottom of one touches the top of the other and they have
</I>&gt;<i> + * rectangles in the same places (of the same width, of course). This
</I>&gt;<i> maintains
</I>&gt;<i> + * the y-x-banding that's so nice to have...
</I>&gt;<i> + */
</I>&gt;<i> +
</I>&gt;<i> +#include &quot;RegionSupport.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +#include &lt;malloc.h&gt;
</I>&gt;<i>  #include &lt;new&gt;
</I>&gt;<i>
</I>&gt;<i> -// System Includes
</I>&gt;<i> -------------------------------------------------------------
</I>&gt;<i> -#include &lt;Debug.h&gt;
</I>&gt;<i> -#include &lt;Region.h&gt;
</I>&gt;<i> +using std::nothrow;
</I>&gt;<i>
</I>&gt;<i> -// Private Includes
</I>&gt;<i> -------------------------------------------------------------
</I>&gt;<i> -#include &lt;clipping.h&gt;
</I>&gt;<i> -#include &lt;RegionSupport.h&gt;
</I>&gt;<i> +#include &lt;SupportDefs.h&gt;
</I>&gt;<i>
</I>&gt;<i> -// Constants
</I>&gt;<i> --------------------------------------------------------------------
</I>&gt;<i> -static const int32 kMaxPoints = 1024;
</I>&gt;<i> -static const int32 kMaxVerticalExtent = 0x10000000;
</I>&gt;<i> -static const int32 kMaxPositive = 0x7ffffffd;
</I>&gt;<i> -static const int32 kMaxNegative = 0x80000003;
</I>&gt;<i>
</I>&gt;<i> -
</I>&gt;<i> -#define TRACE_REGION 0
</I>&gt;<i> -#define ARGS (const char *, ...)
</I>&gt;<i> -#if TRACE_REGION
</I>&gt;<i> -	#define RTRACE(ARGS) printf ARGS
</I>&gt;<i> -	#define CALLED() printf(&quot;%s\n&quot;, __PRETTY_FUNCTION__)
</I>&gt;<i> +#ifdef DEBUG
</I>&gt;<i> +#include &lt;stdio.h&gt;
</I>&gt;<i> +#define assert(expr) {if (!(expr)) fprintf(stderr,\
</I>&gt;<i> +&quot;Assertion failed file %s, line %d: &quot; #expr &quot;\n&quot;, __FILE__, __LINE__); }
</I>&gt;<i>  #else
</I>&gt;<i> -	#define RTRACE(ARGS) ;
</I>&gt;<i> - 	#define CALLED()
</I>&gt;<i> +#define assert(expr)
</I>&gt;<i>  #endif
</I>&gt;<i>
</I>&gt;<i> -using namespace std;
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief zeroes the given region, setting its rect count to 0,
</I>&gt;<i> -	and invalidating its bound rectangle.
</I>&gt;<i> -	\param region The region to be zeroed.
</I>&gt;<i> -*/
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::Support::ZeroRegion(BRegion &amp;region)
</I>&gt;<i> -{
</I>&gt;<i> -	CALLED();
</I>&gt;<i> -	
</I>&gt;<i> -	region.count = 0;
</I>&gt;<i> -	region.bound.left = kMaxPositive;
</I>&gt;<i> -	region.bound.top = kMaxPositive;
</I>&gt;<i> -	region.bound.right = kMaxNegative;
</I>&gt;<i> -	region.bound.bottom = kMaxNegative;
</I>&gt;<i> -}
</I>&gt;<i> +/*  1 if two clipping_rects overlap.
</I>&gt;<i> + *  0 if two clipping_rects do not overlap.
</I>&gt;<i> + *  Remember, right and bottom are not in the region
</I>&gt;<i> + */
</I>&gt;<i> +#define EXTENTCHECK(r1, r2) \
</I>&gt;<i> +	((r1)-&gt;right &gt; (r2)-&gt;left &amp;&amp; \
</I>&gt;<i> +	 (r1)-&gt;left &lt; (r2)-&gt;right &amp;&amp; \
</I>&gt;<i> +	 (r1)-&gt;bottom &gt; (r2)-&gt;top &amp;&amp; \
</I>&gt;<i> +	 (r1)-&gt;top &lt; (r2)-&gt;bottom)
</I>&gt;<i>
</I>&gt;<i> +/*
</I>&gt;<i> + *  update region fBounds
</I>&gt;<i> + */
</I>&gt;<i> +#define EXTENTS(r,idRect){\
</I>&gt;<i> +            if((r)-&gt;left &lt; (idRect)-&gt;fBounds.left)\
</I>&gt;<i> +              (idRect)-&gt;fBounds.left = (r)-&gt;left;\
</I>&gt;<i> +            if((r)-&gt;top &lt; (idRect)-&gt;fBounds.top)\
</I>&gt;<i> +              (idRect)-&gt;fBounds.top = (r)-&gt;top;\
</I>&gt;<i> +            if((r)-&gt;right &gt; (idRect)-&gt;fBounds.right)\
</I>&gt;<i> +              (idRect)-&gt;fBounds.right = (r)-&gt;right;\
</I>&gt;<i> +            if((r)-&gt;bottom &gt; (idRect)-&gt;fBounds.bottom)\
</I>&gt;<i> +              (idRect)-&gt;fBounds.bottom = (r)-&gt;bottom;\
</I>&gt;<i> +        }
</I>&gt;<i>
</I>&gt;<i> -/*!	\brief clear the given region, setting its rect count to 0,
</I>&gt;<i> -	and setting its bound rectangle to 0xFFFFFFF, 0xFFFFFFF, 0xF0000001,
</I>&gt;<i> 0xF0000001.
</I>&gt;<i> -	\param region The region to be cleared.
</I>&gt;<i> -*/
</I>&gt;<i> -void
</I>&gt;<i> -BRegion::Support::ClearRegion(BRegion &amp;region)
</I>&gt;<i> -{
</I>&gt;<i> -	CALLED();
</I>&gt;<i> +/*
</I>&gt;<i> + *   Check to see if there is enough memory in the present region.
</I>&gt;<i> + */
</I>&gt;<i> +#define MEMCHECK(reg, rect, firstrect){\
</I>&gt;<i> +        if ((reg)-&gt;fCount &gt;= ((reg)-&gt;fDataSize - 1)){\
</I>&gt;<i> +          (firstrect) = (clipping_rect *) realloc \
</I>&gt;<i> +          ((char *)(firstrect), (unsigned) (2 * (sizeof(clipping_rect)) *
</I>&gt;<i> ((reg)-&gt;fDataSize)));\
</I>&gt;<i> +          if ((firstrect) == 0)\
</I>&gt;<i> +            return(0);\
</I>&gt;<i> +          (reg)-&gt;fDataSize *= 2;\
</I>&gt;<i> +          (rect) = &amp;(firstrect)[(reg)-&gt;fCount];\
</I>&gt;<i> +         }\
</I>&gt;<i> +       }
</I>&gt;<i>
</I>&gt;<i> -	// TODO: What is it used for ?
</I>&gt;<i>
</I>&gt;<i> [... truncated: 2233 lines follow ...]
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> ------------------------------
</I>&gt;<i>
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Haiku-commits mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">Haiku-commits at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">https://lists.berlios.de/mailman/listinfo/haiku-commits</A>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> End of Haiku-commits Digest, Vol 16, Issue 93
</I>&gt;<i> *********************************************
</I>&gt;<i>
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004477.html">[Haiku-commits] r22717 - in haiku/trunk/headers: os/arch/m68k	posix/arch/m68k
</A></li>
	<LI>Next message: <A HREF="004479.html">[Haiku-commits] Haiku-commits Digest, Vol 16, Issue 93
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4478">[ date ]</a>
              <a href="thread.html#4478">[ thread ]</a>
              <a href="subject.html#4478">[ subject ]</a>
              <a href="author.html#4478">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
