<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22447 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel/disk_device_manager	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/partitioning_systems/intel	src/bin/makebootable/platform/bios_ia32	src/system/kernel/disk_device_manager src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22447%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel/disk_device_manager%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/partitioning_systems/intel%0A%09src/bin/makebootable/platform/bios_ia32%0A%09src/system/kernel/disk_device_manager%20src/tools/fs_shell&In-Reply-To=%3C200710042348.l94NmJ7r007351%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004143.html">
   <LINK REL="Next"  HREF="004145.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22447 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel/disk_device_manager	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/partitioning_systems/intel	src/bin/makebootable/platform/bios_ia32	src/system/kernel/disk_device_manager src/tools/fs_shell</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22447%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/private/fs_shell%20headers/private/kernel/disk_device_manager%0A%09src/add-ons/kernel/file_systems/bfs%0A%09src/add-ons/kernel/partitioning_systems/intel%0A%09src/bin/makebootable/platform/bios_ia32%0A%09src/system/kernel/disk_device_manager%20src/tools/fs_shell&In-Reply-To=%3C200710042348.l94NmJ7r007351%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22447 - in haiku/trunk: headers/os/drivers	headers/private/fs_shell headers/private/kernel/disk_device_manager	src/add-ons/kernel/file_systems/bfs	src/add-ons/kernel/partitioning_systems/intel	src/bin/makebootable/platform/bios_ia32	src/system/kernel/disk_device_manager src/tools/fs_shell">bonefish at mail.berlios.de
       </A><BR>
    <I>Fri Oct  5 01:48:19 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004143.html">[Haiku-commits] r22446 - in haiku/trunk:	headers/private/kernel/boot src/system/boot/loader	src/system/boot/loader/file_systems/amiga_ffs	src/system/boot/loader/file_systems/bfs	src/system/boot/loader/file_systems/hfs_plus	src/system/boot/loader/file_systems/tarfs
</A></li>
        <LI>Next message: <A HREF="004145.html">[Haiku-commits] r22448 -	haiku/trunk/src/system/kernel/disk_device_manager/jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4144">[ date ]</a>
              <a href="thread.html#4144">[ thread ]</a>
              <a href="subject.html#4144">[ subject ]</a>
              <a href="author.html#4144">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2007-10-05 01:48:18 +0200 (Fri, 05 Oct 2007)
New Revision: 22447
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22447&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22447&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/headers/private/kernel/disk_device_manager/ddm_modules.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.h
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.h
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.h
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.cpp
   haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.h
   haiku/trunk/src/bin/makebootable/platform/bios_ia32/makebootable.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/KFileSystem.cpp
   haiku/trunk/src/system/kernel/disk_device_manager/KPartitioningSystem.cpp
   haiku/trunk/src/tools/fs_shell/vfs.cpp
Log:
* Added the partition size as parameter to the file and partitioning
  system initialize() hooks. It's often the only info about the
  partition one needs and thus locking the partition just to get it is
  no longer necessary.
* intel partitioning system:
  - Removed passing around block sizes. We require 512 byte sectors
    anyway. In fact using the parent partition's block size was even
    wrong.
  - Simplified writing the partition map sector.
  - Simplified and corrected the partition map initialization.
  - We don't fail identifying a partition anymore, if the partition map
    contains no partitions. We would never identify a freshly
    initialized partition map before.
  - Made pm_identify() more intelligent: It determines the priority to
    return depending on whether the partition is the device itself and
    whether we have recognized child partitions.


Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -235,7 +235,7 @@
 	status_t (*set_content_parameters)(int fd, partition_id partition,
 				const char *parameters, disk_job_id job);
 	status_t (*initialize)(int fd, partition_id partition, const char *name,
-				const char *parameters, disk_job_id job);
+				const char *parameters, off_t partitionSize, disk_job_id job);
 } file_system_module_info;
 
 

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -273,7 +273,8 @@
 	fssh_status_t (*set_content_parameters)(int fd, fssh_partition_id partition,
 				const char *parameters, fssh_disk_job_id job);
 	fssh_status_t (*initialize)(int fd, fssh_partition_id partition,
-				const char *name, const char *parameters, fssh_disk_job_id job);
+				const char *name, const char *parameters,
+				fssh_off_t partitionSize, fssh_disk_job_id job);
 } fssh_file_system_module_info;
 
 

Modified: haiku/trunk/headers/private/kernel/disk_device_manager/ddm_modules.h
===================================================================
--- haiku/trunk/headers/private/kernel/disk_device_manager/ddm_modules.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/headers/private/kernel/disk_device_manager/ddm_modules.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -94,7 +94,7 @@
 	status_t (*set_content_parameters)(int fd, partition_id partition,
 				const char* parameters, disk_job_id job);
 	status_t (*initialize)(int fd, partition_id partition, const char* name,
-				const char *parameters, disk_job_id job);
+				const char *parameters, off_t partitionSize, disk_job_id job);
 	status_t (*create_child)(int fd, partition_id partition, off_t offset,
 				off_t size, const char* type, const char* parameters,
 				disk_job_id job, partition_id* childID);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -2092,7 +2092,7 @@
 
 static status_t
 bfs_initialize(int fd, partition_id partitionID, const char *name,
-	const char *parameterString, disk_job_id job)
+	const char *parameterString, off_t /*partitionSize*/, disk_job_id job)
 {
 	// parse parameters
 	initialize_parameters parameters;

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -298,25 +298,25 @@
 
 // constructor
 Partition::Partition(const partition_descriptor *descriptor,off_t ptsOffset,
-					 off_t baseOffset, int32 blockSize)
+					 off_t baseOffset)
 	: fPTSOffset(0),
 	  fOffset(0),
 	  fSize(0),
 	  fType(0),
 	  fActive(false)
 {
-	SetTo(descriptor, ptsOffset, baseOffset, blockSize);
+	SetTo(descriptor, ptsOffset, baseOffset);
 }
 
 // SetTo
 void
 Partition::SetTo(const partition_descriptor *descriptor, off_t ptsOffset,
-				 off_t baseOffset, int32 blockSize)
+				 off_t baseOffset)
 {
 TRACE((&quot;Partition::SetTo(): active: %x\n&quot;, descriptor-&gt;active));
 	fPTSOffset = ptsOffset;
-	fOffset = baseOffset + (off_t)descriptor-&gt;start * blockSize;
-	fSize = (off_t)descriptor-&gt;size * blockSize;
+	fOffset = baseOffset + (off_t)descriptor-&gt;start * SECTOR_SIZE;
+	fSize = (off_t)descriptor-&gt;size * SECTOR_SIZE;
 	fType = descriptor-&gt;type;
 	fActive = descriptor-&gt;active;
 	if (fSize == 0)
@@ -337,10 +337,10 @@
 // GetPartitionDescriptor
 void
 Partition::GetPartitionDescriptor(partition_descriptor *descriptor,
-								  off_t baseOffset, int32 blockSize) const
+								  off_t baseOffset) const
 {
-	descriptor-&gt;start = (fOffset - baseOffset) / blockSize;
-	descriptor-&gt;size = fSize / blockSize;
+	descriptor-&gt;start = (fOffset - baseOffset) / SECTOR_SIZE;
+	descriptor-&gt;size = fSize / SECTOR_SIZE;
 	descriptor-&gt;type = fType;
 	descriptor-&gt;active = fActive ? 0x80 : 0x00;
 	descriptor-&gt;begin.Unset();
@@ -362,13 +362,13 @@
 
 
 bool
-Partition::CheckLocation(off_t sessionSize, int32 blockSize) const
+Partition::CheckLocation(off_t sessionSize) const
 {
 	// offsets and size must be block aligned, PTS and partition must lie
 	// within the session
-	return fPTSOffset % blockSize == 0
-		&amp;&amp; fOffset % blockSize == 0
-		&amp;&amp; fSize % blockSize == 0
+	return fPTSOffset % SECTOR_SIZE == 0
+		&amp;&amp; fOffset % SECTOR_SIZE == 0
+		&amp;&amp; fSize % SECTOR_SIZE == 0
 		&amp;&amp; fPTSOffset &gt;= 0 &amp;&amp; fPTSOffset &lt; sessionSize
 		&amp;&amp; fOffset &gt;= 0 &amp;&amp; fOffset + fSize &lt;= sessionSize;
 }
@@ -388,22 +388,21 @@
 
 // constructor
 PrimaryPartition::PrimaryPartition(const partition_descriptor *descriptor,
-								   off_t ptsOffset, int32 blockSize)
+								   off_t ptsOffset)
 	: Partition(),
 	  fHead(NULL),
 	  fTail(NULL),
 	  fLogicalPartitionCount(0)
 {
-	SetTo(descriptor, ptsOffset, blockSize);
+	SetTo(descriptor, ptsOffset);
 }
 
 // SetTo
 void
-PrimaryPartition::SetTo(const partition_descriptor *descriptor,
-						off_t ptsOffset, int32 blockSize)
+PrimaryPartition::SetTo(const partition_descriptor *descriptor, off_t ptsOffset)
 {
 	Unset();
-	Partition::SetTo(descriptor, ptsOffset, 0, blockSize);
+	Partition::SetTo(descriptor, ptsOffset, 0);
 }
 
 // Unset
@@ -488,27 +487,25 @@
 
 // constructor
 LogicalPartition::LogicalPartition(const partition_descriptor *descriptor,
-								   off_t ptsOffset, int32 blockSize,
-								   PrimaryPartition *primary)
+		off_t ptsOffset, PrimaryPartition *primary)
 	: Partition(),
 	  fPrimary(NULL),
 	  fNext(NULL),
 	  fPrevious(NULL)
 {
-	SetTo(descriptor, ptsOffset, blockSize, primary);
+	SetTo(descriptor, ptsOffset, primary);
 }
 
 // SetTo
 void
 LogicalPartition::SetTo(const partition_descriptor *descriptor,
-						off_t ptsOffset, int32 blockSize,
-						PrimaryPartition *primary)
+	off_t ptsOffset, PrimaryPartition *primary)
 {
 	Unset();
 	if (descriptor &amp;&amp; primary) {
 		off_t baseOffset = (descriptor-&gt;is_extended() ? primary-&gt;Offset()
 													  : ptsOffset);
-		Partition::SetTo(descriptor, ptsOffset, baseOffset, blockSize);
+		Partition::SetTo(descriptor, ptsOffset, baseOffset);
 		fPrimary = primary;
 	}
 }
@@ -619,12 +616,12 @@
 
 // Check
 bool
-PartitionMap::Check(off_t sessionSize, int32 blockSize) const
+PartitionMap::Check(off_t sessionSize) const
 {
 	int32 partitionCount = CountPartitions();
 	// 1. check partition locations
 	for (int32 i = 0; i &lt; partitionCount; i++) {
-		if (!PartitionAt(i)-&gt;CheckLocation(sessionSize, blockSize))
+		if (!PartitionAt(i)-&gt;CheckLocation(sessionSize))
 			return false;
 	}
 	// 2. check overlapping of partitions and location of PTSs

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMap.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -1,9 +1,6 @@
 /*
- * Copyright 2003-2006, Haiku, Inc. All Rights Reserved.
+ * Copyright 2003-2007, Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de.</A>
  * Distributed under the terms of the MIT License.
- *
- * Authors:
- *		Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de</A>
  */
 
 /*!
@@ -29,6 +26,9 @@
 #define INTEL_EXTENDED_PARTITION_NAME &quot;Intel Extended Partition&quot;
 #define BFS_NAME &quot;BFS Filesystem&quot;
 
+enum {
+	SECTOR_SIZE = 512
+};
 
 // is_empty_type
 static inline bool
@@ -123,10 +123,10 @@
 public:
 	Partition();
 	Partition(const partition_descriptor *descriptor, off_t ptsOffset,
-		off_t baseOffset, int32 blockSize);
+		off_t baseOffset);
 
 	void SetTo(const partition_descriptor *descriptor, off_t ptsOffset,
-		off_t baseOffset, int32 blockSize);
+		off_t baseOffset);
 	void Unset();
 
 	bool IsEmpty() const	{ return is_empty_type(fType); }
@@ -140,7 +140,7 @@
 	void GetTypeString(char *buffer) const
 		{ get_partition_type_string(fType, buffer); }
 	void GetPartitionDescriptor(partition_descriptor *descriptor,
-								off_t baseOffset, int32 blockSize) const;
+								off_t baseOffset) const;
 
 	void SetPTSOffset(off_t offset)	{ fPTSOffset = offset; }
 	void SetOffset(off_t offset)	{ fOffset = offset; }
@@ -148,7 +148,7 @@
 	void SetType(uint8 type)		{ fType = type; }
 	void SetActive(bool active)		{ fActive = active; }
 
-	bool CheckLocation(off_t sessionSize, int32 blockSize) const;
+	bool CheckLocation(off_t sessionSize) const;
 #ifdef _BOOT_MODE
 	void AdjustSize(off_t sessionSize);
 #endif
@@ -165,11 +165,9 @@
 class PrimaryPartition : public Partition {
 public:
 	PrimaryPartition();
-	PrimaryPartition(const partition_descriptor *descriptor, off_t ptsOffset,
-		int32 blockSize);
+	PrimaryPartition(const partition_descriptor *descriptor, off_t ptsOffset);
 
-	void SetTo(const partition_descriptor *descriptor, off_t ptsOffset,
-		int32 blockSize);
+	void SetTo(const partition_descriptor *descriptor, off_t ptsOffset);
 	void Unset();
 
 	// only if extended
@@ -189,10 +187,10 @@
 public:
 	LogicalPartition();
 	LogicalPartition(const partition_descriptor *descriptor, off_t ptsOffset,
-		int32 blockSize, PrimaryPartition *primary);
+		PrimaryPartition *primary);
 
 	void SetTo(const partition_descriptor *descriptor, off_t ptsOffset,
-		int32 blockSize, PrimaryPartition *primary);
+		PrimaryPartition *primary);
 	void Unset();
 
 	void SetPrimaryPartition(PrimaryPartition *primary) { fPrimary = primary; }
@@ -226,7 +224,7 @@
 	Partition *PartitionAt(int32 index);
 	const Partition *PartitionAt(int32 index) const;
 
-	bool Check(off_t sessionSize, int32 blockSize) const;
+	bool Check(off_t sessionSize) const;
 
 private:
 	PrimaryPartition		fPrimaries[4];

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -38,11 +38,10 @@
 
 // constructor
 PartitionMapParser::PartitionMapParser(int deviceFD, off_t sessionOffset,
-									   off_t sessionSize, int32 blockSize)
+		off_t sessionSize)
 	: fDeviceFD(deviceFD),
 	  fSessionOffset(sessionOffset),
 	  fSessionSize(sessionSize),
-	  fBlockSize(blockSize),
 	  fPTS(NULL),
 	  fMap(NULL)
 {
@@ -72,13 +71,9 @@
 				error = _ParsePrimary(&amp;pts);
 		}
 
-		// If we don't have any partitions it might also just be an
-		// empty partition map, but we still can't do much with it
-		if (error == B_OK
-			&amp;&amp; (fMap-&gt;CountNonEmptyPartitions() == 0
-				|| !fMap-&gt;Check(fSessionSize, fBlockSize))) {
+		if (error == B_OK &amp;&amp; !fMap-&gt;Check(fSessionSize))
 			error = B_BAD_DATA;
-		}
+
 		fMap = NULL;
 	}
 	return error;
@@ -101,14 +96,14 @@
 	for (int32 i = 0; i &lt; 4; i++) {
 		const partition_descriptor *descriptor = &amp;pts-&gt;table[i];
 		PrimaryPartition *partition = fMap-&gt;PrimaryPartitionAt(i);
-		partition-&gt;SetTo(descriptor, 0, fBlockSize);
+		partition-&gt;SetTo(descriptor, 0);
 
 #ifdef _BOOT_MODE
 		// work-around potential BIOS problems
 		partition-&gt;AdjustSize(fSessionSize);
 #endif
 		// ignore, if location is bad
-		if (!partition-&gt;CheckLocation(fSessionSize, fBlockSize)) {
+		if (!partition-&gt;CheckLocation(fSessionSize)) {
 			TRACE((&quot;intel: _ParsePrimary(): partition %ld: bad location, &quot;
 				&quot;ignoring\n&quot;, i));
 			partition-&gt;Unset();
@@ -177,8 +172,7 @@
 				if (!descriptor-&gt;is_empty()) {
 					if (descriptor-&gt;is_extended()) {
 						if (extended.IsEmpty()) {
-							extended.SetTo(descriptor, offset, fBlockSize,
-										   primary);
+							extended.SetTo(descriptor, offset, primary);
 							partition = &extended;
 						} else {
 							// only one extended partition allowed
@@ -188,8 +182,7 @@
 						}
 					} else {
 						if (nonExtended.IsEmpty()) {
-							nonExtended.SetTo(descriptor, offset, fBlockSize,
-											  primary);
+							nonExtended.SetTo(descriptor, offset, primary);
 							partition = &nonExtended;
 						} else {
 							// only one non-extended partition allowed
@@ -204,8 +197,7 @@
 						partition-&gt;AdjustSize(fSessionSize);
 #endif
 					// check the partition's location
-					if (partition &amp;&amp; !partition-&gt;CheckLocation(fSessionSize,
-															   fBlockSize)) {
+					if (partition &amp;&amp; !partition-&gt;CheckLocation(fSessionSize)) {
 						error = B_BAD_DATA;
 						TRACE((&quot;intel: _ParseExtended(): Invalid partition &quot;
 							&quot;location: pts: %lld, offset: %lld, size: %lld\n&quot;,

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapParser.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -28,8 +28,8 @@
 
 class PartitionMapParser {
 	public:
-		PartitionMapParser(int deviceFD, off_t sessionOffset, off_t sessionSize,
-			int32 blockSize);
+		PartitionMapParser(int deviceFD, off_t sessionOffset,
+			off_t sessionSize);
 		~PartitionMapParser();
 
 		status_t Parse(const uint8 *block, PartitionMap *map);
@@ -46,7 +46,6 @@
 		int						fDeviceFD;
 		off_t					fSessionOffset;
 		off_t					fSessionSize;
-		int32					fBlockSize;
 		partition_table_sector	*fPTS;	// while parsing
 		PartitionMap			*fMap;
 };

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -39,14 +39,12 @@
 	\param deviceFD File descriptor.
 	\param sessionOffset Disk offset of the partition with partitioning system.
 	\param sessionSize Size of the partition with partitioning system.
-	\param blockSize Size of the sector on given disk.
 */
 PartitionMapWriter::PartitionMapWriter(int deviceFD, off_t sessionOffset,
-		off_t sessionSize, int32 blockSize)
+		off_t sessionSize)
 	: fDeviceFD(deviceFD),
 	  fSessionOffset(sessionOffset),
 	  fSessionSize(sessionSize),
-	  fBlockSize(blockSize),
 	  fPTS(NULL),
 	  fMap(NULL)
 {
@@ -64,33 +62,43 @@
 	If a \a block is not specified, the sector is firstly read from the disk
 	and after changing relevant items it is written back to the disk.
 	This allows to keep code area in MBR intact.
-	\param block Pointer to \c partition_table_sector.
+	\param pts Pointer to \c partition_table_sector.
 	\param map Pointer to the PartitionMap structure describing disk partitions.
 */
 status_t
-PartitionMapWriter::WriteMBR(uint8 *block, const PartitionMap *map)
+PartitionMapWriter::WriteMBR(const PartitionMap *map, bool clearSectors)
 {
-	status_t error = (map ? B_OK : B_BAD_VALUE);
+	if (!map)
+		return B_BAD_VALUE;
+
+	fMap = map;
+
+	uint8 sector[SECTOR_SIZE];	
+	partition_table_sector* pts = (partition_table_sector*)sector;
+
+	// If we shall not clear the first two sectors, we need to read the first
+	// sector in, first.
+	status_t error = B_OK;
+	if (clearSectors)
+		memset(sector, 0, SECTOR_SIZE);
+	else
+		error = _ReadPTS(0, pts);
+
 	if (error == B_OK) {
-		fMap = map;
-		if (block) {
-			partition_table_sector *pts
-				= (partition_table_sector*)block;
-			error = _WritePrimary(pts);
-			if (error == B_OK)
-				error = _WritePTS(0, pts);
-		} else {
-			partition_table_sector pts;
-			error = _ReadPTS(0, &amp;pts);
-			if (error == B_OK) {
-				error = _WritePrimary(&amp;pts);
-				if (error == B_OK)
-					error = _WritePTS(0, &amp;pts);
-			}
-		}
+		error = _WritePrimary(pts);
+		if (error == B_OK)
+			error = _WriteSector(0, sector);
+	}
 
-		fMap = NULL;
+	// Clear the second sector, if desired. We do that to make the partition
+	// unrecognizable by BFS.
+	if (error == B_OK &amp;&amp; clearSectors) {
+		memset(sector, 0, SECTOR_SIZE);
+		error = _WriteSector(SECTOR_SIZE, sector);
 	}
+
+	fMap = NULL;
+
 	return error;
 }
 
@@ -104,28 +112,27 @@
 	previous logical partitions (call this function on previous logical
 	partition to ensure it).
 
-	\param block Pointer to \c partition_table_sector.
+	\param pts Pointer to \c partition_table_sector.
 	\param partition Pointer to the logical partition.
 */
 status_t
-PartitionMapWriter::WriteLogical(uint8 *block,
+PartitionMapWriter::WriteLogical(partition_table_sector *pts,
 	const LogicalPartition *partition)
 {
 	status_t error = (partition ? B_OK : B_BAD_VALUE);
 	if (error == B_OK) {
-		if (block) {
-			partition_table_sector *pts
-					= (partition_table_sector*)block;
+		if (pts) {
 			error = _WriteExtended(pts, partition, partition-&gt;Next());
 			if (error == B_OK)
-				error = _WritePTS(partition-&gt;PTSOffset(), pts);
+				error = _WriteSector(partition-&gt;PTSOffset(), pts);
 		} else {
-			partition_table_sector pts;
-			error = _ReadPTS(partition-&gt;PTSOffset(), &amp;pts);
+			partition_table_sector _pts;
+			pts = &amp;_pts;
+			error = _ReadPTS(partition-&gt;PTSOffset(), pts);
 			if (error == B_OK) {
-				error = _WriteExtended(&amp;pts, partition, partition-&gt;Next());
+				error = _WriteExtended(pts, partition, partition-&gt;Next());
 				if (error == B_OK)
-					error = _WritePTS(partition-&gt;PTSOffset(), &amp;pts);
+					error = _WriteSector(partition-&gt;PTSOffset(), pts);
 			}
 		}
 	}
@@ -142,30 +149,29 @@
 	If the \a first_partition is not specified, it only initializes EBR and the
 	linked list contains no logical partitions.
 
-	\param block Pointer to \c partition_table_sector.
+	\param pts Pointer to \c partition_table_sector.
 	\param first_partition Pointer to the first logical partition.
 */
 status_t
-PartitionMapWriter::WriteExtendedHead(uint8 *block,
+PartitionMapWriter::WriteExtendedHead(partition_table_sector *pts,
 	const LogicalPartition *first_partition)
 {
 	LogicalPartition partition;
 	if (first_partition)
 		partition.SetPrimaryPartition(first_partition-&gt;GetPrimaryPartition());
 	status_t error = B_OK;
-	if (block) {
-		partition_table_sector *pts
-				= (partition_table_sector*)block;
+	if (pts) {
 		error = _WriteExtended(pts, &amp;partition, first_partition);
 		if (error == B_OK)
-			error = _WritePTS(0, pts);
+			error = _WriteSector(0, pts);
 	} else {
-		partition_table_sector pts;
-		error = _ReadPTS(0, &amp;pts);
+		partition_table_sector _pts;
+		pts = &amp;_pts;
+		error = _ReadPTS(0, pts);
 		if (error == B_OK) {
-			error = _WriteExtended(&amp;pts, &amp;partition, first_partition);
+			error = _WriteExtended(pts, &amp;partition, first_partition);
 			if (error == B_OK)
-				error = _WritePTS(0, &amp;pts);
+				error = _WriteSector(0, pts);
 		}
 	}
 	return error;
@@ -187,13 +193,13 @@
 		const PrimaryPartition *partition = fMap-&gt;PrimaryPartitionAt(i);
 
 		// ignore, if location is bad
-		if (!partition-&gt;CheckLocation(fSessionSize, fBlockSize)) {
+		if (!partition-&gt;CheckLocation(fSessionSize)) {
 			TRACE((&quot;intel: _WritePrimary(): partition %ld: bad location, &quot;
 				&quot;ignoring\n&quot;, i));
 			return B_BAD_DATA;
 		}
 
-		partition-&gt;GetPartitionDescriptor(descriptor, 0, fBlockSize);
+		partition-&gt;GetPartitionDescriptor(descriptor, 0);
 	}
 
 	return B_OK;
@@ -211,7 +217,7 @@
 	pts-&gt;signature = kPartitionTableSectorSignature;
 
 	// check the partition's location
-	if (!partition-&gt;CheckLocation(fSessionSize, fBlockSize)) {
+	if (!partition-&gt;CheckLocation(fSessionSize)) {
 		TRACE((&quot;intel: _WriteExtended(): Invalid partition &quot;
 			&quot;location: pts: %lld, offset: %lld, size: %lld, &quot;
 			&quot;fSessionSize: %lld\n&quot;,
@@ -222,8 +228,7 @@
 
 	// write the table
 	partition_descriptor *descriptor = &amp;(pts-&gt;table[0]);
-	partition-&gt;GetPartitionDescriptor(descriptor, partition-&gt;PTSOffset(),
-		fBlockSize);
+	partition-&gt;GetPartitionDescriptor(descriptor, partition-&gt;PTSOffset());
 
 	// setting offset and size of the next partition in the linked list
 	descriptor = &amp;(pts-&gt;table[1]);
@@ -233,15 +238,15 @@
 		extended.SetOffset(next-&gt;PTSOffset());
 		extended.SetSize(next-&gt;Size() + next-&gt;Offset() - next-&gt;PTSOffset());
 		extended.SetType(partition-&gt;GetPrimaryPartition()-&gt;Type());
-		extended.GetPartitionDescriptor(descriptor, 0, fBlockSize);
+		extended.GetPartitionDescriptor(descriptor, 0);
 		extended.Unset();
 	} else
-		extended.GetPartitionDescriptor(descriptor, 0, fBlockSize);
+		extended.GetPartitionDescriptor(descriptor, 0);
 
 	// last two descriptors are empty
 	for (int32 i = 2; i &lt; 4; i++) {
 		descriptor = &amp;(pts-&gt;table[i]);
-		extended.GetPartitionDescriptor(descriptor, 0, fBlockSize);
+		extended.GetPartitionDescriptor(descriptor, 0);
 	}
 
 	return B_OK;
@@ -276,31 +281,28 @@
 	return error;
 }
 
-// _WritePTS
+// _WriteSector
 /*! \brief Writes the sector to the disk.
 */
 status_t
-PartitionMapWriter::_WritePTS(off_t offset, const partition_table_sector *pts)
+PartitionMapWriter::_WriteSector(off_t offset, const void* pts)
 {
 	status_t error = B_OK;
-	if (!pts)
-		pts = fPTS;
-	int32 toWrite = sizeof(partition_table_sector);
+
+	int32 toWrite = SECTOR_SIZE;
+
 	// check the offset
 	if (offset &lt; 0 || offset + toWrite &gt; fSessionSize) {
 		error = B_BAD_VALUE;
-		TRACE((&quot;intel: _WritePTS(): bad offset: %Ld\n&quot;, offset));
+		TRACE((&quot;intel: _WriteSector(): bad offset: %Ld\n&quot;, offset));
 	// write
 	} else if (write_pos(fDeviceFD, fSessionOffset + offset, pts, toWrite)
 						!= toWrite) {
-#ifndef _BOOT_MODE
 		error = errno;
 		if (error == B_OK)
 			error = B_IO_ERROR;
-#else
-		error = B_IO_ERROR;
-#endif
-		TRACE((&quot;intel: _WritePTS(): writing the PTS failed: %lx\n&quot;, error));
+
+		TRACE((&quot;intel: _WriteSector(): writing the PTS failed: %lx\n&quot;, error));
 	}
 	return error;
 }

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.h	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/PartitionMapWriter.h	2007-10-04 23:48:18 UTC (rev 22447)
@@ -35,13 +35,13 @@
 */
 class PartitionMapWriter {
 public:
-	PartitionMapWriter(int deviceFD, off_t sessionOffset, off_t sessionSize,
-		int32 blockSize);
+	PartitionMapWriter(int deviceFD, off_t sessionOffset, off_t sessionSize);
 	~PartitionMapWriter();
 
-	status_t WriteMBR(uint8 *block, const PartitionMap *map);
-	status_t WriteLogical(uint8 *block, const LogicalPartition *partition);
-	status_t WriteExtendedHead(uint8 *block,
+	status_t WriteMBR(const PartitionMap *map, bool clearSectors);
+	status_t WriteLogical(partition_table_sector *pts,
+		const LogicalPartition *partition);
+	status_t WriteExtendedHead(partition_table_sector *pts,
 		const LogicalPartition *first_partition);
 
 private:
@@ -49,13 +49,12 @@
 	status_t _WriteExtended(partition_table_sector *pts,
 		const LogicalPartition *partition, const LogicalPartition *next);
 	status_t _ReadPTS(off_t offset, partition_table_sector *pts = NULL);
-	status_t _WritePTS(off_t offset, const partition_table_sector *pts = NULL);
+	status_t _WriteSector(off_t offset, const void* pts = NULL);
 
 private:
 	int						fDeviceFD;
 	off_t					fSessionOffset;
 	off_t					fSessionSize;
-	int32					fBlockSize;
 	partition_table_sector	*fPTS;	// while writing
 	const PartitionMap		*fMap;
 };

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/intel.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -127,14 +127,6 @@
 		return -1;
 	}
 
-	// check block size
-	uint32 blockSize = partition-&gt;block_size;
-	if (blockSize &lt; sizeof(partition_table_sector)) {
-		TRACE((&quot;intel: read_partition_map: bad block size: %ld, should be &quot;
-			&quot;&gt;= %ld\n&quot;, blockSize, sizeof(partition_table_sector)));
-		return -1;
-	}
-
 	// allocate a PartitionMap
 	PartitionMapCookie *map = new(nothrow) PartitionMapCookie;
 	if (!map)
@@ -142,16 +134,40 @@
 	map-&gt;ref_count = 1;
 
 	// read the partition structure
-	PartitionMapParser parser(fd, 0, partition-&gt;size, blockSize);
+	PartitionMapParser parser(fd, 0, partition-&gt;size);
 	status_t error = parser.Parse(NULL, map);
-	if (error == B_OK) {
-		*cookie = map;
+	if (error != B_OK) {
+		// cleanup, if not detected
+		delete map;
+		return -1;
+	}
+
+	*cookie = map;
+
+	// Depending on whether we actually have recognized child partitions and
+	// whether we are installed directly on a device (the by far most common
+	// setup), we determine the priority.
+	bool hasChildren = (map-&gt;CountNonEmptyPartitions() &gt; 0);
+	bool hasParent = (get_parent_partition(partition-&gt;id) != NULL);
+
+	if (!hasParent) {
+		if (hasChildren) {
+			// This value overrides BFS.
+			return 0.81;
+		}
+
+		// No children -- might be a freshly initialized disk. But it could
+		// also be an image file. So we give BFS a chance to override us.
 		return 0.5;
 	}
 
-	// cleanup, if not detected
-	delete map;
-	return -1;
+	// We have a parent. That's a very unlikely setup.
+	if (hasChildren)
+		return 0.4;
+
+	// No children. Extremely unlikely, that this is a desired. But if no one
+	// else claims the partition, we take it anyway.
+	return 0.1;
 }
 
 // pm_scan_partition
@@ -173,6 +189,7 @@
 	partition-&gt;content_size = partition-&gt;size;
 	// (no content_name and content_parameters)
 	// (content_type is set by the system)
+	partition-&gt;block_size = SECTOR_SIZE;
 
 	partition-&gt;content_cookie = map;
 	// children
@@ -192,7 +209,7 @@
 
 			child-&gt;offset = partition-&gt;offset + primary-&gt;Offset();
 			child-&gt;size = primary-&gt;Size();
-			child-&gt;block_size = partition-&gt;block_size;
+			child-&gt;block_size = SECTOR_SIZE;
 			// (no name)
 			char type[B_FILE_NAME_LENGTH];
 			primary-&gt;GetTypeString(type);
@@ -320,6 +337,7 @@
 	partition-&gt;content_size = partition-&gt;size;
 	// (no content_name and content_parameters)
 	// (content_type is set by the system)
+	partition-&gt;block_size = SECTOR_SIZE;
 	
 	partition-&gt;content_cookie = primary;
 	// children
@@ -339,7 +357,7 @@
 		}
 		child-&gt;offset = parent-&gt;offset + logical-&gt;Offset();
 		child-&gt;size = logical-&gt;Size();
-		child-&gt;block_size = partition-&gt;block_size;
+		child-&gt;block_size = SECTOR_SIZE;
 		// (no name)
 		char type[B_FILE_NAME_LENGTH];
 		logical-&gt;GetTypeString(type);

Modified: haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.cpp	2007-10-04 23:16:31 UTC (rev 22446)
+++ haiku/trunk/src/add-ons/kernel/partitioning_systems/intel/write_support.cpp	2007-10-04 23:48:18 UTC (rev 22447)
@@ -110,20 +110,20 @@
 // #pragma mark - Intel Partition Map - validate functions
 
 
-// block_align (auxiliary function)
+// sector_align (auxiliary function)
 static inline
 off_t
-block_align(off_t offset, uint32 block_size)
+sector_align(off_t offset)
 {
-	return offset / block_size * block_size;
+	return offset / SECTOR_SIZE * SECTOR_SIZE;
 }
 
-// block_align_up (auxiliary function)
+// sector_align_up (auxiliary function)
 static inline
 off_t
-block_align_up(off_t offset, uint32 block_size)
+sector_align_up(off_t offset)
 {
-	return (offset + block_size - 1) / block_size * block_size;
+	return (offset + SECTOR_SIZE - 1) / SECTOR_SIZE * SECTOR_SIZE;
 }
 
 // validate_resize (auxiliary function)
@@ -138,7 +138,7 @@
 	if (new_size &lt; 0)
 		new_size = 0;
 	else
-		new_size = block_align(new_size, partition-&gt;block_size);
+		new_size = sector_align(new_size);
 
 	// grow partition?
 	if (new_size &gt; partition-&gt;size) {
@@ -157,7 +157,7 @@
 	}
 	new_size = current_end - partition-&gt;offset;
 	// make the size a multiple of the block size (greater one)
-	new_size = block_align_up(new_size, partition-&gt;block_size);
+	new_size = sector_align_up(new_size);
 	*size = new_size;
 	return true;
 }
@@ -285,7 +285,7 @@
 		if (*size &lt; 0)
 			*size = 0;
 		// make the size a multiple of the block size
-		*size = block_align(*size, partition-&gt;block_size);
+		*size = sector_align(*size);
 		return true;
 	}
 	// grow partition
@@ -304,7 +304,7 @@
 
 	if (nextSibling &amp;&amp; (nextOffset &lt; childOffset + *size))
 		*size = nextOffset - childOffset;
-	*size = block_align(*size, partition-&gt;block_size);
+	*size = sector_align(*size);
 	return true;
 }
 
@@ -347,7 +347,7 @@
 	else if (start + childSize &gt; partition-&gt;size)
 		start = partition-&gt;size - childSize;
 
-	start = block_align(start, partition-&gt;block_size);
+	start = sector_align(start);
 
 	// finding out sibling partitions
 	partition_data *previousSibling = NULL;
@@ -362,13 +362,13 @@
 		// moving left
 		if (previousSibling &amp;&amp; previousOffset + previousSize &gt; start) {
 			start = previousOffset + previousSize;
-			start = block_align_up(start, partition-&gt;block_size);
+			start = sector_align_up(start);
 		}
 	} else {
 		// moving right
 		if (nextSibling &amp;&amp; nextOffset &lt; start + childSize) {
 			start = nextOffset - childSize;
-			start = block_align(start, partition-&gt;block_size);
+			start = sector_align(start);
 		}
 	}
 	*_start = start;
@@ -453,9 +453,13 @@
 			&amp; B_DISK_SYSTEM_SUPPORTS_INITIALIZING)) {
 		return false;
 	}
-	// name is ignored - we cannot set it to the intel partitioning map
-	// TODO: check parameters - don't know whether any parameters could be set
-	//		 to the intel partition map
+
+	// name is ignored
+	if (name)
+		name[0] = '\0';
+
+	// parameters are ignored, too
+
 	return true;
 }
 
@@ -465,11 +469,11 @@
 	off_t *size, fc_get_sibling_partitions getSiblingPartitions)
 {
 	// make the start and size a multiple of the block size
-	*start = block_align(*start, partition-&gt;block_size);
+	*start = sector_align(*start);
 	if (*size &lt; 0)
 		*size = 0;
 	else
-		*size = block_align(*size, partition-&gt;block_size);
+		*size = sector_align(*size);
 
 	// child must completely lie within the parent partition
 	if (*start &gt;= partition-&gt;offset + partition-&gt;size)
@@ -489,12 +493,12 @@
 	// position check of the new partition
 	if (previousSibling &amp;&amp; (previousOffset + previousSize &gt; *start)) {
 		*start = previousOffset + previousSize;
-		*start = block_align_up(*start, partition-&gt;block_size);
+		*start = sector_align_up(*start);
 	}
 	
 	if (nextSibling &amp;&amp; (nextOffset &lt; *start + *size))
 		*size = nextOffset - *start;
-	*size = block_align(*size, partition-&gt;block_size);
+	*size = sector_align(*size);
 	if (*size == 0)
 		return false;
 
@@ -540,9 +544,9 @@
 		return false;
 	*index = newIndex;
 
-	if (*start &lt; partition-&gt;offset + MBR_OFFSET * partition-&gt;block_size) {
-		*start = partition-&gt;offset + MBR_OFFSET * partition-&gt;block_size;
-		*start = block_align_up(*start, partition-&gt;block_size);
+	if (*start &lt; partition-&gt;offset + MBR_OFFSET * SECTOR_SIZE) {
+		*start = partition-&gt;offset + MBR_OFFSET * SECTOR_SIZE;
+		*start = sector_align_up(*start);
 	}
 
 	return validate_create_child_partition(partition, start, size,
@@ -626,12 +630,12 @@
 	int32 actualCount = 0;
 
 	// offset alignment (to upper bound)
-	offset = block_align_up(offset, partition-&gt;block_size);
+	offset = sector_align_up(offset);
 
 	// finding out all partitionable spaces
 	for (int32 i = 0; i &lt; partition_count; i++) {
 		size = positions[i].offset - offset;
-		size = block_align(size, partition-&gt;block_size);
+		size = sector_align(size);
 		if (size &gt; limitSize) {
 			if (actualCount &lt; count) {
 				buffer[actualCount].offset = offset;
@@ -640,11 +644,11 @@
 			actualCount++;
 		}
 		offset = positions[i].offset + positions[i].size + headerSize;
-		offset = block_align_up(offset, partition-&gt;block_size);
+		offset = sector_align_up(offset);
 	}
 	// space in the end of partition
 	size = partition-&gt;offset + partition-&gt;size - offset;
-	size = block_align(size, partition-&gt;block_size);
+	size = sector_align(size);
 	if (size &gt; 0) {
 		if (actualCount &lt; count) {
 			buffer[actualCount].offset = offset;
@@ -678,7 +682,7 @@
 		return B_BAD_VALUE;
 
 	return get_partitionable_spaces(partition, buffer, count, actualCount,
-		fill_partitionable_spaces_buffer_pm, MBR_OFFSET * partition-&gt;block_size,
+		fill_partitionable_spaces_buffer_pm, MBR_OFFSET * SECTOR_SIZE,
 		0, 0);
 }
 
@@ -809,8 +813,8 @@
 	primary-&gt;SetSize(validatedSize);
 
 // TODO: The partition is not supposed to be locked here!
-	PartitionMapWriter writer(fd, 0, partition-&gt;size, partition-&gt;block_size);
-	status_t error = writer.WriteMBR(NULL, map);
+	PartitionMapWriter writer(fd, 0, partition-&gt;size);
+	status_t error = writer.WriteMBR(map, false);
 	if (error != B_OK) {
 		// putting into previous state
 		primary-&gt;SetSize(child-&gt;size);
@@ -959,7 +963,7 @@
 
 	// buffer allocation
 	int32 allocated;
-	uint8 *buffer = allocate_buffer(partition-&gt;block_size, MAX_MOVE_BUFFER,
+	uint8 *buffer = allocate_buffer(SECTOR_SIZE, MAX_MOVE_BUFFER,

[... truncated: 387 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004143.html">[Haiku-commits] r22446 - in haiku/trunk:	headers/private/kernel/boot src/system/boot/loader	src/system/boot/loader/file_systems/amiga_ffs	src/system/boot/loader/file_systems/bfs	src/system/boot/loader/file_systems/hfs_plus	src/system/boot/loader/file_systems/tarfs
</A></li>
	<LI>Next message: <A HREF="004145.html">[Haiku-commits] r22448 -	haiku/trunk/src/system/kernel/disk_device_manager/jobs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4144">[ date ]</a>
              <a href="thread.html#4144">[ thread ]</a>
              <a href="subject.html#4144">[ subject ]</a>
              <a href="author.html#4144">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
