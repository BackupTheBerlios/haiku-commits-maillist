<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r22416 - in haiku/trunk: headers/os/drivers	headers/os/kernel headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/drivers/random src/add-ons/kernel/drivers/tty	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/network/stack src/system/kernel	src/system/kernel/fs src/system/libroot/os
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-October/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22416%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/os/kernel%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/userlandfs/private%0A%09src/add-ons/kernel/drivers/random%20src/add-ons/kernel/drivers/tty%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/add-ons/kernel/network/stack%20src/system/kernel%0A%09src/system/kernel/fs%20src/system/libroot/os&In-Reply-To=%3C200710021947.l92JlZWh016478%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="004103.html">
   <LINK REL="Next"  HREF="004124.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r22416 - in haiku/trunk: headers/os/drivers	headers/os/kernel headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/drivers/random src/add-ons/kernel/drivers/tty	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/network/stack src/system/kernel	src/system/kernel/fs src/system/libroot/os</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r22416%20-%20in%20haiku/trunk%3A%20headers/os/drivers%0A%09headers/os/kernel%20headers/private/kernel%0A%09headers/private/kernel/fs%20headers/private/userlandfs/private%0A%09src/add-ons/kernel/drivers/random%20src/add-ons/kernel/drivers/tty%0A%09src/add-ons/kernel/file_systems/userlandfs/kernel_add_on%0A%09src/add-ons/kernel/file_systems/userlandfs/server%0A%09src/add-ons/kernel/network/stack%20src/system/kernel%0A%09src/system/kernel/fs%20src/system/libroot/os&In-Reply-To=%3C200710021947.l92JlZWh016478%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r22416 - in haiku/trunk: headers/os/drivers	headers/os/kernel headers/private/kernel	headers/private/kernel/fs headers/private/userlandfs/private	src/add-ons/kernel/drivers/random src/add-ons/kernel/drivers/tty	src/add-ons/kernel/file_systems/userlandfs/kernel_add_on	src/add-ons/kernel/file_systems/userlandfs/server	src/add-ons/kernel/network/stack src/system/kernel	src/system/kernel/fs src/system/libroot/os">bonefish at mail.berlios.de
       </A><BR>
    <I>Tue Oct  2 21:47:35 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="004103.html">[Haiku-commits] r22415 -	haiku/trunk/src/add-ons/accelerants/intel_extreme
</A></li>
        <LI>Next message: <A HREF="004124.html">[Haiku-commits] r22416 - in haiku/trunk: headers/os/drivers headers/os/kernel headers/private/kernel headers/private/kernel/fs  headers/private/userlandfs/private src/add-ons/kernel/drivers/random  src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_systems/userlandfs/kernel_add_on src/add-ons/kernel/file_systems/userlandfs/server src/add-ons/kernel/network/stack src/system/kernel src/system/kernel/fs  src/system/libroot/os
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4104">[ date ]</a>
              <a href="thread.html#4104">[ thread ]</a>
              <a href="subject.html#4104">[ subject ]</a>
              <a href="author.html#4104">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2007-10-02 21:47:31 +0200 (Tue, 02 Oct 2007)
New Revision: 22416
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=22416&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=22416&amp;view=rev</A>

Added:
   haiku/trunk/headers/private/kernel/wait_for_objects.h
   haiku/trunk/src/system/kernel/wait_for_objects.cpp
   haiku/trunk/src/system/libroot/os/wait_for_objects.cpp
Removed:
   haiku/trunk/src/system/kernel/fs/vfs_select.cpp
   haiku/trunk/src/system/kernel/fs/vfs_select.h
Modified:
   haiku/trunk/headers/os/drivers/Select.h
   haiku/trunk/headers/os/kernel/OS.h
   haiku/trunk/headers/private/kernel/fs/fd.h
   haiku/trunk/headers/private/kernel/fs/select_sync_pool.h
   haiku/trunk/headers/private/kernel/port.h
   haiku/trunk/headers/private/kernel/sem.h
   haiku/trunk/headers/private/kernel/syscalls.h
   haiku/trunk/headers/private/kernel/thread.h
   haiku/trunk/headers/private/kernel/thread_types.h
   haiku/trunk/headers/private/userlandfs/private/Requests.h
   haiku/trunk/src/add-ons/kernel/drivers/random/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h
   haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp
   haiku/trunk/src/system/kernel/Jamfile
   haiku/trunk/src/system/kernel/fs/Jamfile
   haiku/trunk/src/system/kernel/fs/devfs.cpp
   haiku/trunk/src/system/kernel/fs/fd.cpp
   haiku/trunk/src/system/kernel/fs/pipefs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/port.c
   haiku/trunk/src/system/kernel/sem.c
   haiku/trunk/src/system/kernel/syscalls.c
   haiku/trunk/src/system/kernel/thread.cpp
   haiku/trunk/src/system/libroot/os/Jamfile
Log:
* Renamed fs/vfs_select.cpp to wait_for_objects.cpp and got rid of
  vfs_select.h, respectively moved most of it into the new kernel
  private header wait_for_objects.h.
* Added new experimental API functions wait_for_objects[_etc](). They
  work pretty much like poll(), but also for semaphores, ports, and
  threads.
* Removed the &quot;ref&quot; parameter from notify_select_events() and the
  select_sync_pool functions as well as from fd_ops::fd_[de]select(). It
  is no longer needed. The FS interface select() hook still has it,
  though -- the VFS will always pass 0.
* de]select_fd() take a select_info* instead of a select_sync* + ref
  pair, now. Added respective functions for semaphores, ports, and
  threads.



Modified: haiku/trunk/headers/os/drivers/Select.h
===================================================================
--- haiku/trunk/headers/os/drivers/Select.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/os/drivers/Select.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -31,11 +31,7 @@
 extern &quot;C&quot; {
 #endif
 
-#ifdef COMPILE_FOR_R5
-extern void notify_select_event(struct selectsync *sync, uint32 ref);
-#else
-extern status_t notify_select_event(struct selectsync *sync, uint32 ref, uint8 event);
-#endif
+extern status_t notify_select_event(struct selectsync *sync, uint8 event);
 
 #ifdef __cplusplus
 }

Modified: haiku/trunk/headers/os/kernel/OS.h
===================================================================
--- haiku/trunk/headers/os/kernel/OS.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/os/kernel/OS.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -658,6 +658,52 @@
 extern int32	is_computer_on(void);
 extern double	is_computer_on_fire(void);
 
+
+// WARNING: Experimental API!
+
+enum {
+	B_OBJECT_TYPE_FD		= 0,
+	B_OBJECT_TYPE_SEMAPHORE	= 1,
+	B_OBJECT_TYPE_PORT		= 2,
+	B_OBJECT_TYPE_THREAD	= 3
+};
+
+enum {
+	B_EVENT_READ				= 0x0001,	// FD/port readable
+	B_EVENT_WRITE				= 0x0002,	// FD/port writable
+	B_EVENT_ERROR				= 0x0004,	// FD error
+	B_EVENT_PRIORITY_READ		= 0x0008,	// FD priority readable
+	B_EVENT_PRIORITY_WRITE		= 0x0010,	// FD priority writable
+	B_EVENT_HIGH_PRIORITY_READ	= 0x0020,	// FD high priority readable
+	B_EVENT_HIGH_PRIORITY_WRITE	= 0x0040,	// FD high priority writable
+	B_EVENT_DISCONNECTED		= 0x0080,	// FD disconnected
+
+	B_EVENT_ACQUIRE_SEMAPHORE	= 0x0001,	// semaphore can be acquired
+
+	B_EVENT_INVALID				= 0x1000	// FD/port/sem/thread ID not or
+											// no longer valid (e.g. has been
+											// close/deleted)
+};
+
+typedef struct object_wait_info {
+	int32		object;						// ID of the object
+	uint16		type;						// type of the object
+	uint16		events;						// events mask
+} object_wait_info;
+
+// wait_for_objects[_etc]() waits until at least one of the specified events or,
+// if given, the timeout occurred. When entering the function the
+// object_wait_info::events field specifies the events for each object the
+// caller is interested in. When the function returns the fields reflect the
+// events that actually occurred. The events B_EVENT_INVALID, B_EVENT_ERROR,
+// and B_EVENT_DISCONNECTED don't need to be specified. They will always be
+// reported, when they occur.
+
+extern ssize_t 	wait_for_objects(object_wait_info* infos, int numInfos);
+extern ssize_t 	wait_for_objects_etc(object_wait_info* infos, int numInfos,
+					uint32 flags, bigtime_t timeout);
+
+
 #ifdef __cplusplus
 }
 #endif

Modified: haiku/trunk/headers/private/kernel/fs/fd.h
===================================================================
--- haiku/trunk/headers/private/kernel/fs/fd.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/fs/fd.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -17,14 +17,14 @@
 
 struct file_descriptor;
 struct selectsync;
-struct select_sync;
+struct select_info;
 
 struct fd_ops {
 	status_t	(*fd_read)(struct file_descriptor *, off_t pos, void *buffer, size_t *length);
 	status_t	(*fd_write)(struct file_descriptor *, off_t pos, const void *buffer, size_t *length);
 	off_t		(*fd_seek)(struct file_descriptor *, off_t pos, int seekType);
 	status_t	(*fd_ioctl)(struct file_descriptor *, ulong op, void *buffer, size_t length);
-	status_t	(*fd_select)(struct file_descriptor *, uint8 event, uint32 ref,
+	status_t	(*fd_select)(struct file_descriptor *, uint8 event,
 						struct selectsync *sync);
 	status_t	(*fd_deselect)(struct file_descriptor *, uint8 event,
 						struct selectsync *sync);
@@ -77,10 +77,8 @@
 extern void put_fd(struct file_descriptor *descriptor);
 extern void disconnect_fd(struct file_descriptor *descriptor);
 extern void inc_fd_ref_count(struct file_descriptor *descriptor);
-extern status_t select_fd(int fd, struct select_sync *sync, uint32 ref,
-					bool kernel);
-extern status_t deselect_fd(int fd, struct select_sync *sync, uint32 ref,
-					bool kernel);
+extern status_t select_fd(int32 fd, struct select_info *info, bool kernel);
+extern status_t deselect_fd(int32 fd, struct select_info *info, bool kernel);
 extern bool fd_is_valid(int fd, bool kernel);
 extern struct vnode *fd_vnode(struct file_descriptor *descriptor);
 

Modified: haiku/trunk/headers/private/kernel/fs/select_sync_pool.h
===================================================================
--- haiku/trunk/headers/private/kernel/fs/select_sync_pool.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/fs/select_sync_pool.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -17,7 +17,7 @@
 
 
 status_t add_select_sync_pool_entry(select_sync_pool **pool, selectsync *sync,
-			uint32 ref, uint8 event);
+			uint8 event);
 status_t remove_select_sync_pool_entry(select_sync_pool **pool,
 			selectsync *sync, uint8 event);
 void delete_select_sync_pool(select_sync_pool *pool);

Modified: haiku/trunk/headers/private/kernel/port.h
===================================================================
--- haiku/trunk/headers/private/kernel/port.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/port.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -10,6 +10,7 @@
 #include &lt;iovec.h&gt;
 
 struct kernel_args;
+struct select_info;
 
 
 #define PORT_FLAG_USE_USER_MEMCPY 0x80000000
@@ -23,6 +24,9 @@
 int32 port_max_ports(void);
 int32 port_used_ports(void);
 
+status_t select_port(int32 object, struct select_info *info, bool kernel);
+status_t deselect_port(int32 object, struct select_info *info, bool kernel);
+
 // currently private API
 status_t writev_port_etc(port_id id, int32 msgCode, const iovec *msgVecs,
 			size_t vecCount, size_t bufferSize, uint32 flags, bigtime_t timeout);

Modified: haiku/trunk/headers/private/kernel/sem.h
===================================================================
--- haiku/trunk/headers/private/kernel/sem.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/sem.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -13,6 +13,7 @@
 #include &lt;thread.h&gt;
 
 struct kernel_args;
+struct select_info;
 
 
 #ifdef __cplusplus
@@ -25,6 +26,10 @@
 extern int32 sem_used_sems(void);
 extern int32 sem_max_sems(void);
 
+extern status_t select_sem(int32 object, struct select_info *info, bool kernel);
+extern status_t deselect_sem(int32 object, struct select_info *info,
+			bool kernel);
+
 extern sem_id create_sem_etc(int32 count, const char *name, team_id owner);
 
 /* user calls */

Modified: haiku/trunk/headers/private/kernel/syscalls.h
===================================================================
--- haiku/trunk/headers/private/kernel/syscalls.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/syscalls.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -53,6 +53,10 @@
 extern status_t		_kern_shutdown(bool reboot);
 extern status_t		_kern_get_safemode_option(const char *parameter, char *buffer, size_t *_bufferSize);
 
+extern ssize_t		_kern_wait_for_objects(object_wait_info* infos, int numInfos,
+						uint32 flags, bigtime_t timeout);
+
+
 /* sem functions */
 extern sem_id		_kern_create_sem(int count, const char *name);
 extern status_t		_kern_delete_sem(sem_id id);

Modified: haiku/trunk/headers/private/kernel/thread.h
===================================================================
--- haiku/trunk/headers/private/kernel/thread.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/thread.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -14,6 +14,7 @@
 #include &lt;arch/thread.h&gt;
 
 struct kernel_args;
+struct select_info;
 
 
 #ifdef __cplusplus
@@ -65,6 +66,9 @@
 status_t wait_for_thread_etc(thread_id id, uint32 flags, bigtime_t timeout,
 	status_t *_returnCode);
 
+status_t select_thread(int32 object, struct select_info *info, bool kernel);
+status_t deselect_thread(int32 object, struct select_info *info, bool kernel);
+
 // used in syscalls.c
 status_t _user_set_thread_priority(thread_id thread, int32 newPriority);
 status_t _user_rename_thread(thread_id thread, const char *name);

Modified: haiku/trunk/headers/private/kernel/thread_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/thread_types.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/thread_types.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -54,6 +54,7 @@
 
 struct image;
 	// defined in image.c
+struct select_info;
 
 struct death_entry {
 	struct list_link	link;
@@ -234,6 +235,8 @@
 		struct list	waiters;
 	} exit;
 
+	struct select_info *select_infos;
+
 	struct thread_debug_info debug_info;
 
 	// stack

Added: haiku/trunk/headers/private/kernel/wait_for_objects.h
===================================================================
--- haiku/trunk/headers/private/kernel/wait_for_objects.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/kernel/wait_for_objects.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2007, Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">bonefish at cs.tu-berlin.de.</A> All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+#ifndef _KERNEL_WAIT_FOR_OBJECTS_H
+#define _KERNEL_WAIT_FOR_OBJECTS_H
+
+#include &lt;OS.h&gt;
+
+#include &lt;lock.h&gt;
+
+
+struct select_sync;
+
+
+typedef struct select_info {
+	struct select_info*	next;				// next in the object's list
+	struct select_sync*	sync;
+	uint16				selected_events;
+	uint16				events;
+} select_info;
+
+typedef struct select_sync {
+	vint32				ref_count;
+	benaphore			lock;
+	sem_id				sem;
+	uint32				count;
+	struct select_info*	set;
+} select_sync;
+
+#define SELECT_FLAG(type) (1L &lt;&lt; (type - 1))
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif 
+
+
+extern void		put_select_sync(select_sync* sync);
+extern status_t	notify_select_events(select_info* info, uint16 events);
+extern void		notify_select_events_list(select_info* list, uint16 events);
+
+extern ssize_t	_user_wait_for_objects(object_wait_info* userInfos,
+					int numInfos, uint32 flags, bigtime_t timeout);
+
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif	// _KERNEL_WAIT_FOR_OBJECTS_H

Modified: haiku/trunk/headers/private/userlandfs/private/Requests.h
===================================================================
--- haiku/trunk/headers/private/userlandfs/private/Requests.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/headers/private/userlandfs/private/Requests.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -547,7 +547,6 @@
 	SelectRequest() : FileRequest(SELECT_REQUEST) {}
 
 	uint8		event;
-	uint32		ref;
 	selectsync*	sync;
 };
 
@@ -1394,7 +1393,6 @@
 	NotifySelectEventRequest() : Request(NOTIFY_SELECT_EVENT_REQUEST) {}
 
 	selectsync*	sync;
-	uint32		ref;
 	uint8		event;
 	bool		unspecifiedEvent;
 };

Modified: haiku/trunk/src/add-ons/kernel/drivers/random/driver.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/random/driver.c	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/drivers/random/driver.c	2007-10-02 19:47:31 UTC (rev 22416)
@@ -466,7 +466,7 @@
 #ifdef COMPILE_FOR_R5
 		notify_select_event(sync, ref);
 #else
-		notify_select_event(sync, ref, event);
+		notify_select_event(sync, event);
 #endif
 	} else if (event == B_SELECT_WRITE) {
 		/* we're not writable */

Modified: haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/drivers/tty/tty.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -1676,7 +1676,7 @@
 	if (!ttyReference.IsLocked()) {
 		TRACE((&quot;tty_select() done: cookie %p already closed\n&quot;, cookie));
 
-		notify_select_event(sync, ref, event);
+		notify_select_event(sync, event);
 		return B_OK;
 	}
 
@@ -1690,8 +1690,7 @@
 		otherTTY = NULL;
 
 	// add the event to the TTY's pool
-	status_t error = add_select_sync_pool_entry(&amp;tty-&gt;select_pool, sync, ref,
-		event);
+	status_t error = add_select_sync_pool_entry(&amp;tty-&gt;select_pool, sync, event);
 	if (error != B_OK) {
 		TRACE((&quot;tty_select() done: add_select_sync_pool_entry() failed: %lx\n&quot;,
 			error));
@@ -1708,7 +1707,7 @@
 		case B_SELECT_READ:
 			if (tty-&gt;reader_queue.IsEmpty()
 				&amp;&amp; line_buffer_readable(tty-&gt;input_buffer) &gt; 0) {
-				notify_select_event(sync, ref, event);
+				notify_select_event(sync, event);
 			}
 			break;
 
@@ -1716,7 +1715,7 @@
 		{
 			// writes go to the other TTY
 			if (!otherTTY) {
-				notify_select_event(sync, ref, event);
+				notify_select_event(sync, event);
 				break;
 			}
 
@@ -1730,7 +1729,7 @@
 				if (!echo
 					|| (tty-&gt;writer_queue.IsEmpty()
 						&amp;&amp; line_buffer_writable(tty-&gt;input_buffer) &gt; 0)) {
-					notify_select_event(sync, ref, event);
+					notify_select_event(sync, event);
 				}
 			}
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/KernelRequestHandler.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -211,13 +211,13 @@
 		if (request-&gt;unspecifiedEvent) {
 			// old style add-ons can't provide an event argument; we shoot
 			// all events
-			notify_select_event(request-&gt;sync, request-&gt;ref, B_SELECT_READ);
-			notify_select_event(request-&gt;sync, request-&gt;ref, B_SELECT_WRITE);
-			notify_select_event(request-&gt;sync, request-&gt;ref, B_SELECT_ERROR);
+			notify_select_event(request-&gt;sync, B_SELECT_READ);
+			notify_select_event(request-&gt;sync, B_SELECT_WRITE);
+			notify_select_event(request-&gt;sync, B_SELECT_ERROR);
 		} else {
-			PRINT((&quot;notify_select_event(%p, %lu, %d)\n&quot;, request-&gt;sync,
-				request-&gt;ref, (int)request-&gt;event));
-			notify_select_event(request-&gt;sync, request-&gt;ref, request-&gt;event);
+			PRINT((&quot;notify_select_event(%p, %d)\n&quot;, request-&gt;sync,
+				(int)request-&gt;event));
+			notify_select_event(request-&gt;sync, request-&gt;event);
 		}
 	} else
 		result = B_BAD_VALUE;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/kernel_add_on/Volume.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -736,7 +736,7 @@
 {
 	// check capability
 	if (!fFileSystem-&gt;HasCapability(FS_CAPABILITY_SELECT)) {
-		notify_select_event(sync, ref, event);
+		notify_select_event(sync, event);
 		return B_OK;
 	}
 
@@ -757,7 +757,6 @@
 	request-&gt;node = node;
 	request-&gt;fileCookie = cookie;
 	request-&gt;event = event;
-	request-&gt;ref = ref;
 	request-&gt;sync = sync;
 
 	// add a selectsync entry

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/BeOSKernelVolume.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -224,7 +224,7 @@
 	uint32 ref, selectsync* sync)
 {
 	if (!fFSOps-&gt;select) {
-		UserlandFS::KernelEmu::notify_select_event(sync, ref, event, false);
+		UserlandFS::KernelEmu::notify_select_event(sync, event, false);
 		return B_OK;
 	}
 	return fFSOps-&gt;select(fVolumeCookie, node, cookie, event, ref, sync);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/HaikuKernelVolume.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -194,7 +194,7 @@
 	uint32 ref, selectsync* sync)
 {
 	if (!fFSModule-&gt;select) {
-		UserlandFS::KernelEmu::notify_select_event(sync, ref, event, false);
+		UserlandFS::KernelEmu::notify_select_event(sync, event, false);
 		return B_OK;
 	}
 	return fFSModule-&gt;select(fVolumeCookie, node, cookie, event, ref, sync);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/UserlandRequestHandler.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -627,7 +627,7 @@
 	if (result == B_OK) {
 		RequestThreadContext context(volume);
 		result = volume-&gt;Select(request-&gt;node, request-&gt;fileCookie,
-			request-&gt;event, request-&gt;ref, request-&gt;sync);
+			request-&gt;event, 0, request-&gt;sync);
 	}
 
 	// prepare the reply

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_kernel_emu.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_kernel_emu.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/beos_kernel_emu.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -82,7 +82,7 @@
 void
 notify_select_event(selectsync *sync, uint32 ref)
 {
-	UserlandFS::KernelEmu::notify_select_event(sync, ref, 0, true);
+	UserlandFS::KernelEmu::notify_select_event(sync, 0, true);
 }
 
 // send_notification

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_kernel_emu.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_kernel_emu.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/haiku_kernel_emu.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -76,9 +76,9 @@
 
 // notify_select_event
 status_t
-notify_select_event(selectsync *sync, uint32 ref, uint8 event)
+notify_select_event(selectsync *sync, uint8 event)
 {
-	return UserlandFS::KernelEmu::notify_select_event(sync, ref, event, false);
+	return UserlandFS::KernelEmu::notify_select_event(sync, event, false);
 }
 
 // notify_query_entry_created

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -170,8 +170,8 @@
 
 // notify_select_event
 status_t
-UserlandFS::KernelEmu::notify_select_event(selectsync *sync, uint32 ref,
-	uint8 event, bool unspecifiedEvent)
+UserlandFS::KernelEmu::notify_select_event(selectsync *sync, uint8 event,
+	bool unspecifiedEvent)
 {
 	// get the request port and the file system
 	RequestPort* port;
@@ -188,7 +188,6 @@
 		return error;
 
 	request-&gt;sync = sync;
-	request-&gt;ref = ref;
 	request-&gt;event = event;
 	request-&gt;unspecifiedEvent = unspecifiedEvent;
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/file_systems/userlandfs/server/kernel_emu.h	2007-10-02 19:47:31 UTC (rev 22416)
@@ -17,7 +17,7 @@
 status_t notify_listener(int32 operation, uint32 details, dev_t device,
 	ino_t oldDirectory, ino_t directory, ino_t node,
 	const char* oldName, const char* name);
-status_t notify_select_event(selectsync *sync, uint32 ref, uint8 event,
+status_t notify_select_event(selectsync *sync, uint8 event,
 	bool unspecifiedEvent);
 status_t notify_query(port_id port, int32 token, int32 operation,
 	dev_t device, ino_t directory, const char* name, ino_t node);

Modified: haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -470,7 +470,7 @@
 	benaphore_lock(&amp;socket-&gt;lock);
 
 	status_t status = add_select_sync_pool_entry(&amp;socket-&gt;select_pool, sync,
-		ref, event);
+		event);
 
 	benaphore_unlock(&amp;socket-&gt;lock);
 
@@ -486,7 +486,7 @@
 			ssize_t available = socket_read_avail(socket);
 			if ((ssize_t)socket-&gt;receive.low_water_mark &lt;= available
 				|| available &lt; B_OK)
-				notify_select_event(sync, ref, event);
+				notify_select_event(sync, event);
 			break;
 		}
 		case B_SELECT_WRITE:
@@ -494,7 +494,7 @@
 			ssize_t available = socket_send_avail(socket);
 			if ((ssize_t)socket-&gt;send.low_water_mark &lt;= available
 				|| available &lt; B_OK)
-				notify_select_event(sync, ref, event);
+				notify_select_event(sync, event);
 			break;
 		}
 		case B_SELECT_ERROR:

Modified: haiku/trunk/src/system/kernel/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/Jamfile	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/Jamfile	2007-10-02 19:47:31 UTC (rev 22416)
@@ -40,6 +40,7 @@
 	team.cpp
 	thread.cpp
 	timer.c
+	wait_for_objects.cpp
 
 	: $(TARGET_KERNEL_PIC_CCFLAGS)
 ;

Modified: haiku/trunk/src/system/kernel/fs/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/fs/Jamfile	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/fs/Jamfile	2007-10-02 19:47:31 UTC (rev 22416)
@@ -13,7 +13,6 @@
 	vfs.cpp
 	vfs_boot.cpp
 	vfs_net_boot.cpp
-	vfs_select.cpp
 	node_monitor.cpp
 	IOScheduler.cpp
 	KPath.cpp

Modified: haiku/trunk/src/system/kernel/fs/devfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/devfs.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/fs/devfs.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -1839,7 +1839,7 @@
 
 	// If the device has no select() hook, notify select() now.
 	if (!vnode-&gt;stream.u.dev.info-&gt;select)
-		return notify_select_event((selectsync*)sync, ref, event);
+		return notify_select_event((selectsync*)sync, event);
 
 	return vnode-&gt;stream.u.dev.info-&gt;select(cookie-&gt;device_cookie, event, ref,
 		(selectsync*)sync);

Modified: haiku/trunk/src/system/kernel/fs/fd.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/fd.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/fs/fd.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -4,7 +4,6 @@
  * Distributed under the terms of the MIT License.
  */
 
-
 #include &lt;fd.h&gt;
 
 #include &lt;stdlib.h&gt;
@@ -15,10 +14,9 @@
 #include &lt;syscalls.h&gt;
 #include &lt;util/AutoLock.h&gt;
 #include &lt;vfs.h&gt;
+#include &lt;wait_for_objects.h&gt;
 
-#include &quot;vfs_select.h&quot;
 
-
 //#define TRACE_FD
 #ifdef TRACE_FD
 #	define TRACE(x) dprintf x
@@ -448,6 +446,7 @@
 			}
 		}
 
+		notify_select_events(info, B_EVENT_INVALID);
 		info = info-&gt;next;
 		put_select_sync(sync);
 	}
@@ -455,9 +454,10 @@
 
 
 status_t
-select_fd(int fd, struct select_sync* sync, uint32 ref, bool kernel)
+select_fd(int32 fd, struct select_info* info, bool kernel)
 {
-	TRACE((&quot;select_fd(fd = %d, selectsync = %p, ref = %lu, 0x%x)\n&quot;, fd, sync, ref, sync-&gt;set[ref].selected_events));
+	TRACE((&quot;select_fd(fd = %d, info = %p (%p), 0x%x)\n&quot;, fd, info,
+		info-&gt;sync, info.selected_events));
 
 	FDGetter fdGetter;
 		// define before the context locker, so it will be destroyed after it
@@ -469,7 +469,6 @@
 	if (descriptor == NULL)
 		return B_FILE_ERROR;
 
-	select_info* info = &amp;sync-&gt;set[ref];
 	if (info-&gt;selected_events == 0)
 		return B_OK;
 
@@ -485,7 +484,7 @@
 
 	// as long as the info is in the list, we keep a reference to the sync
 	// object
-	atomic_add(&amp;sync-&gt;ref_count, 1);
+	atomic_add(&amp;info-&gt;sync-&gt;ref_count, 1);
 
 	locker.Unlock();
 
@@ -494,7 +493,7 @@
 
 	for (uint16 event = 1; event &lt; 16; event++) {
 		if (info-&gt;selected_events &amp; SELECT_FLAG(event)
-			&amp;&amp; descriptor-&gt;ops-&gt;fd_select(descriptor, event, ref,
+			&amp;&amp; descriptor-&gt;ops-&gt;fd_select(descriptor, event,
 				(selectsync*)info) == B_OK) {
 			selectedEvents |= SELECT_FLAG(event);
 		}
@@ -503,18 +502,18 @@
 
 	// if nothing has been selected, we deselect immediately
 	if (selectedEvents == 0)
-		deselect_fd(fd, sync, ref, kernel);
+		deselect_fd(fd, info, kernel);
 
 	return B_OK;
 }
 
 
 status_t
-deselect_fd(int fd, struct select_sync* sync, uint32 ref, bool kernel)
+deselect_fd(int32 fd, struct select_info* info, bool kernel)
 {
-	TRACE((&quot;deselect_fd(fd = %d, selectsync = %p, ref = %lu)\n&quot;, fd, sync, ref));
+	TRACE((&quot;deselect_fd(fd = %d, info = %p (%p), 0x%x)\n&quot;, fd, info,
+		info-&gt;sync, info.selected_events));
 
-	select_info* info = &amp;sync-&gt;set[ref];
 	if (info-&gt;selected_events == 0)
 		return B_OK;
 
@@ -552,7 +551,7 @@
 		}
 	}
 
-	put_select_sync(sync);
+	put_select_sync(info-&gt;sync);
 
 	return B_OK;
 }

Modified: haiku/trunk/src/system/kernel/fs/pipefs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/pipefs.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/fs/pipefs.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -12,20 +12,19 @@
 
 #include &lt;KernelExport.h&gt;
 #include &lt;NodeMonitor.h&gt;
+#include &lt;Select.h&gt;
 
 #include &lt;condition_variable.h&gt;
-#include &lt;util/kernel_cpp.h&gt;
+#include &lt;debug.h&gt;
+#include &lt;khash.h&gt;
+#include &lt;lock.h&gt;
+#include &lt;select_sync_pool.h&gt;
+#include &lt;team.h&gt;
 #include &lt;util/DoublyLinkedList.h&gt;
 #include &lt;util/AutoLock.h&gt;
 #include &lt;util/ring_buffer.h&gt;
 #include &lt;vfs.h&gt;
-#include &quot;vfs_select.h&quot;
-#include &lt;select_sync_pool.h&gt;
-#include &lt;debug.h&gt;
-#include &lt;khash.h&gt;
-#include &lt;lock.h&gt;
 #include &lt;vm.h&gt;
-#include &lt;team.h&gt;
 
 
 //#define TRACE_PIPEFS
@@ -960,7 +959,7 @@
 	} else
 		return B_NOT_ALLOWED;
 
-	if (add_select_sync_pool_entry(pool, sync, ref, event) != B_OK)
+	if (add_select_sync_pool_entry(pool, sync, event) != B_OK)
 		return B_ERROR;
 
 	// signal right away, if the condition holds already
@@ -968,12 +967,12 @@
 		if (event == B_SELECT_WRITE
 				&amp;&amp; (fBuffer.Writable() &gt; 0 || fReaderCount == 0)
 			|| event == B_SELECT_ERROR &amp;&amp; fReaderCount == 0) {
-			return notify_select_event(sync, ref, event);
+			return notify_select_event(sync, event);
 		}
 	} else {
 		if (event == B_SELECT_READ
 				&amp;&amp; (fBuffer.Readable() &gt; 0 || fWriterCount == 0)) {
-			return notify_select_event(sync, ref, event);
+			return notify_select_event(sync, event);
 		}
 	}
 

Modified: haiku/trunk/src/system/kernel/fs/vfs.cpp
===================================================================
--- haiku/trunk/src/system/kernel/fs/vfs.cpp	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/fs/vfs.cpp	2007-10-02 19:47:31 UTC (rev 22416)
@@ -201,7 +201,7 @@
 static off_t file_seek(struct file_descriptor *, off_t pos, int seek_type);
 static void file_free_fd(struct file_descriptor *);
 static status_t file_close(struct file_descriptor *);
-static status_t file_select(struct file_descriptor *, uint8 event, uint32 ref,
+static status_t file_select(struct file_descriptor *, uint8 event,
 	struct selectsync *sync);
 static status_t file_deselect(struct file_descriptor *, uint8 event,
 	struct selectsync *sync);
@@ -3894,7 +3894,7 @@
 
 
 static status_t
-file_select(struct file_descriptor *descriptor, uint8 event, uint32 ref,
+file_select(struct file_descriptor *descriptor, uint8 event,
 	struct selectsync *sync)
 {
 	FUNCTION((&quot;file_select(%p, %u, %lu, %p)\n&quot;, descriptor, event, ref, sync));
@@ -3903,10 +3903,10 @@
 
 	// If the FS has no select() hook, notify select() now.
 	if (FS_CALL(vnode, select) == NULL)
-		return notify_select_event(sync, ref, event);
+		return notify_select_event(sync, event);
 
 	return FS_CALL(vnode, select)(vnode-&gt;mount-&gt;cookie, vnode-&gt;private_node,
-		descriptor-&gt;cookie, event, ref, sync);
+		descriptor-&gt;cookie, event, 0, sync);
 }
 
 

Deleted: haiku/trunk/src/system/kernel/fs/vfs_select.cpp

Deleted: haiku/trunk/src/system/kernel/fs/vfs_select.h

Modified: haiku/trunk/src/system/kernel/port.c
===================================================================
--- haiku/trunk/src/system/kernel/port.c	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/port.c	2007-10-02 19:47:31 UTC (rev 22416)
@@ -18,6 +18,7 @@
 #include &lt;util/list.h&gt;
 #include &lt;arch/int.h&gt;
 #include &lt;cbuf.h&gt;
+#include &lt;wait_for_objects.h&gt;
 
 #include &lt;iovec.h&gt;
 #include &lt;string.h&gt;
@@ -49,6 +50,7 @@
 	sem_id		read_sem;
 	sem_id		write_sem;
 	int32		total_count;	// messages read from port since creation
+	select_info	*select_infos;
 	struct list	msg_queue;
 };
 
@@ -312,6 +314,14 @@
 }
 
 
+static void
+notify_port_select_events(int slot, uint16 events)
+{
+	if (sPorts[slot].select_infos)
+		notify_select_events_list(sPorts[slot].select_infos, events);
+}
+
+
 /** this function cycles through the ports table, deleting all
  *	the ports that are owned by the passed team_id
  */
@@ -499,6 +509,7 @@
 
 			list_init(&amp;sPorts[i].msg_queue);
 			sPorts[i].total_count = 0;
+			sPorts[i].select_infos = NULL;
 			id = sPorts[i].id;
 
 			RELEASE_PORT_LOCK(sPorts[i]);
@@ -565,6 +576,9 @@
 	readSem = sPorts[slot].read_sem;
 	writeSem = sPorts[slot].write_sem;
 
+	notify_port_select_events(slot, B_EVENT_INVALID);
+	sPorts[slot].select_infos = NULL;
+
 	RELEASE_PORT_LOCK(sPorts[slot]);
 	restore_interrupts(state);
 
@@ -611,6 +625,9 @@
 	sPorts[slot].name = NULL;
 	list_move_to_list(&amp;sPorts[slot].msg_queue, &amp;list);
 
+	notify_port_select_events(slot, B_EVENT_INVALID);
+	sPorts[slot].select_infos = NULL;
+
 	RELEASE_PORT_LOCK(sPorts[slot]);
 
 	// update the first free slot hint in the array	
@@ -639,6 +656,93 @@
 }
 
 
+status_t
+select_port(int32 id, struct select_info *info, bool kernel)
+{
+	cpu_status state;
+	int32 slot;
+	status_t error = B_OK;
+
+	if (id &lt; 0)
+		return B_BAD_PORT_ID;
+
+	slot = id % sMaxPorts;
+
+	state = disable_interrupts();
+	GRAB_PORT_LOCK(sPorts[slot]);
+
+	if (sPorts[slot].id != id || is_port_closed(slot)) {
+		// bad port ID
+		error = B_BAD_SEM_ID;
+	} else if (!kernel &amp;&amp; sPorts[slot].owner == team_get_kernel_team_id()) {
+		// kernel port, but call from userland
+		error = B_NOT_ALLOWED;
+	} else {
+		info-&gt;selected_events &amp;= B_EVENT_READ | B_EVENT_WRITE | B_EVENT_INVALID;
+
+		if (info-&gt;selected_events != 0) {
+			uint16 events = 0;
+			int32 writeCount = 0;
+
+			info-&gt;next = sPorts[slot].select_infos;
+			sPorts[slot].select_infos = info;
+
+			// check for events
+			if ((info-&gt;selected_events &amp; B_EVENT_READ) != 0
+				&amp;&amp; !list_is_empty(&amp;sPorts[slot].msg_queue)) {
+				events |= B_EVENT_READ;
+			}
+
+			if (get_sem_count(sPorts[slot].write_sem, &amp;writeCount) == B_OK
+				&amp;&amp; writeCount &gt; 0) {
+				events |= B_EVENT_WRITE;
+			}
+
+			if (events != 0)
+				notify_select_events(info, events);
+		}
+	}
+
+	RELEASE_PORT_LOCK(sPorts[slot]);
+	restore_interrupts(state);
+
+	return error;
+}
+
+
+status_t
+deselect_port(int32 id, struct select_info *info, bool kernel)
+{
+	cpu_status state;
+	int32 slot;
+
+	if (id &lt; 0)
+		return B_BAD_PORT_ID;
+
+	if (info-&gt;selected_events == 0)
+		return B_OK;
+
+	slot = id % sMaxPorts;
+
+	state = disable_interrupts();
+	GRAB_PORT_LOCK(sPorts[slot]);
+
+	if (sPorts[slot].id == id) {
+		select_info** infoLocation = &amp;sPorts[slot].select_infos;
+		while (*infoLocation != NULL &amp;&amp; *infoLocation != info)
+			infoLocation = &amp;(*infoLocation)-&gt;next;
+
+		if (*infoLocation == info)
+			*infoLocation = info-&gt;next;
+	}
+
+	RELEASE_PORT_LOCK(sPorts[slot]);
+	restore_interrupts(state);
+
+	return B_OK;
+}
+
+
 port_id
 find_port(const char *name)
 {
@@ -988,6 +1092,8 @@
 
 	sPorts[slot].total_count++;
 
+	notify_port_select_events(slot, B_EVENT_WRITE);
+
 	cachedSem = sPorts[slot].write_sem;
 
 	RELEASE_PORT_LOCK(sPorts[slot]);
@@ -1151,6 +1257,8 @@
 
 	list_add_item(&amp;sPorts[slot].msg_queue, msg);
 
+	notify_port_select_events(slot, B_EVENT_READ);
+
 	// store sem_id in local variable 
 	cachedSem = sPorts[slot].read_sem;
 

Modified: haiku/trunk/src/system/kernel/sem.c
===================================================================
--- haiku/trunk/src/system/kernel/sem.c	2007-10-02 17:40:05 UTC (rev 22415)
+++ haiku/trunk/src/system/kernel/sem.c	2007-10-02 19:47:31 UTC (rev 22416)
@@ -25,10 +25,12 @@
 #include &lt;vm_low_memory.h&gt;
 #include &lt;vm_page.h&gt;
 #include &lt;boot/kernel_args.h&gt;
+#include &lt;wait_for_objects.h&gt;
 
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 
+
 //#define TRACE_SEM
 #ifdef TRACE_SEM
 #	define TRACE(x) dprintf x

[... truncated: 1221 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="004103.html">[Haiku-commits] r22415 -	haiku/trunk/src/add-ons/accelerants/intel_extreme
</A></li>
	<LI>Next message: <A HREF="004124.html">[Haiku-commits] r22416 - in haiku/trunk: headers/os/drivers headers/os/kernel headers/private/kernel headers/private/kernel/fs  headers/private/userlandfs/private src/add-ons/kernel/drivers/random  src/add-ons/kernel/drivers/tty src/add-ons/kernel/file_systems/userlandfs/kernel_add_on src/add-ons/kernel/file_systems/userlandfs/server src/add-ons/kernel/network/stack src/system/kernel src/system/kernel/fs  src/system/libroot/os
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4104">[ date ]</a>
              <a href="thread.html#4104">[ thread ]</a>
              <a href="subject.html#4104">[ subject ]</a>
              <a href="author.html#4104">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
