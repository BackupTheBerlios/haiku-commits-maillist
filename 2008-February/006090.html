<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23965 - in haiku/trunk/src:	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	libs/compat/freebsd_network/compat/sys
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23965%20-%20in%20haiku/trunk/src%3A%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/msk%0A%09libs/compat/freebsd_network/compat/sys&In-Reply-To=%3C200802161846.m1GIkfmU018584%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="006089.html">
   <LINK REL="Next"  HREF="006091.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23965 - in haiku/trunk/src:	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	libs/compat/freebsd_network/compat/sys</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23965%20-%20in%20haiku/trunk/src%3A%0A%09add-ons/kernel/drivers/network/marvell_yukon/dev/msk%0A%09libs/compat/freebsd_network/compat/sys&In-Reply-To=%3C200802161846.m1GIkfmU018584%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23965 - in haiku/trunk/src:	add-ons/kernel/drivers/network/marvell_yukon/dev/msk	libs/compat/freebsd_network/compat/sys">korli at mail.berlios.de
       </A><BR>
    <I>Sat Feb 16 19:46:41 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="006089.html">[Haiku-commits] r23964 -	haiku/trunk/src/add-ons/kernel/drivers/input/usb_hid
</A></li>
        <LI>Next message: <A HREF="006091.html">[Haiku-commits] r23966 - haiku/trunk/src/apps/aboutsystem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6090">[ date ]</a>
              <a href="thread.html#6090">[ thread ]</a>
              <a href="subject.html#6090">[ subject ]</a>
              <a href="author.html#6090">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2008-02-16 19:46:40 +0100 (Sat, 16 Feb 2008)
New Revision: 23965
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23965&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23965&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_msk.c
   haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_mskreg.h
   haiku/trunk/src/libs/compat/freebsd_network/compat/sys/param.h
Log:
updated marvell_yukon to 1.26 for the source file and 1.11 for the header
should help with bug #1787


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_msk.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_msk.c	2008-02-16 15:54:51 UTC (rev 23964)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_msk.c	2008-02-16 18:46:40 UTC (rev 23965)
@@ -99,7 +99,7 @@
  */
 
 #include &lt;sys/cdefs.h&gt;
-__FBSDID(&quot;$FreeBSD: src/sys/dev/msk/if_msk.c,v 1.18 2007/07/20 00:25:20 yongari Exp $&quot;);
+__FBSDID(&quot;$FreeBSD: src/sys/dev/msk/if_msk.c,v 1.26 2007/12/05 09:41:58 remko Exp $&quot;);
 
 #include &lt;sys/param.h&gt;
 #include &lt;sys/systm.h&gt;
@@ -193,6 +193,8 @@
 	    &quot;Marvell Yukon 88E8036 Gigabit Ethernet&quot; },
 	{ VENDORID_MARVELL, DEVICEID_MRVL_8038,
 	    &quot;Marvell Yukon 88E8038 Gigabit Ethernet&quot; },
+	{ VENDORID_MARVELL, DEVICEID_MRVL_8039,
+	    &quot;Marvell Yukon 88E8039 Gigabit Ethernet&quot; },
 	{ VENDORID_MARVELL, DEVICEID_MRVL_4361,
 	    &quot;Marvell Yukon 88E8050 Gigabit Ethernet&quot; },
 	{ VENDORID_MARVELL, DEVICEID_MRVL_4360,
@@ -203,6 +205,8 @@
 	    &quot;Marvell Yukon 88E8055 Gigabit Ethernet&quot; },
 	{ VENDORID_MARVELL, DEVICEID_MRVL_4364,
 	    &quot;Marvell Yukon 88E8056 Gigabit Ethernet&quot; },
+	{ VENDORID_MARVELL, DEVICEID_MRVL_436A,
+	    &quot;Marvell Yukon 88E8058 Gigabit Ethernet&quot; },
 	{ VENDORID_DLINK, DEVICEID_DLINK_DGE550SX,
 	    &quot;D-Link 550SX Gigabit Ethernet&quot; },
 	{ VENDORID_DLINK, DEVICEID_DLINK_DGE560T,
@@ -220,7 +224,7 @@
 static int mskc_probe(device_t);
 static int mskc_attach(device_t);
 static int mskc_detach(device_t);
-static void mskc_shutdown(device_t);
+static int mskc_shutdown(device_t);
 static int mskc_setup_rambuffer(struct msk_softc *);
 static int mskc_suspend(device_t);
 static int mskc_resume(device_t);
@@ -358,6 +362,11 @@
 
 static struct resource_spec msk_irq_spec_msi[] = {
 	{ SYS_RES_IRQ,		1,		RF_ACTIVE },
+	{ -1,			0,		0 }
+};
+
+static struct resource_spec msk_irq_spec_msi2[] = {
+	{ SYS_RES_IRQ,		1,		RF_ACTIVE },
 	{ SYS_RES_IRQ,		2,		RF_ACTIVE },
 	{ -1,			0,		0 }
 };
@@ -367,6 +376,9 @@
 {
 	struct msk_if_softc *sc_if;
 
+	if (phy != PHY_ADDR_MARV)
+		return (0);
+
 	sc_if = device_get_softc(dev);
 
 	return (msk_phy_readreg(sc_if, phy, reg));
@@ -405,6 +417,9 @@
 {
 	struct msk_if_softc *sc_if;
 
+	if (phy != PHY_ADDR_MARV)
+		return (0);
+
 	sc_if = device_get_softc(dev);
 
 	return (msk_phy_writereg(sc_if, phy, reg, val));
@@ -516,17 +531,14 @@
 		CSR_WRITE_4(sc, MR_ADDR(sc_if-&gt;msk_port, GMAC_CTRL), gmac);
 
 		/* Enable PHY interrupt for FIFO underrun/overflow. */
-		if (sc-&gt;msk_marvell_phy)
-			msk_phy_writereg(sc_if, PHY_ADDR_MARV,
-			    PHY_MARV_INT_MASK, PHY_M_IS_FIFO_ERROR);
+		msk_phy_writereg(sc_if, PHY_ADDR_MARV,
+		    PHY_MARV_INT_MASK, PHY_M_IS_FIFO_ERROR);
 	} else {
 		/*
 		 * Link state changed to down.
 		 * Disable PHY interrupts.
 		 */
-		if (sc-&gt;msk_marvell_phy)
-			msk_phy_writereg(sc_if, PHY_ADDR_MARV,
-			    PHY_MARV_INT_MASK, 0);
+		msk_phy_writereg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_MASK, 0);
 		/* Disable Rx/Tx MAC. */
 		gmac = GMAC_READ_2(sc, sc_if-&gt;msk_port, GM_GP_CTRL);
 		gmac &amp;= ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
@@ -916,7 +928,7 @@
 			error = EINVAL;
 			break;
 		}
-		if (sc_if-&gt;msk_softc-&gt;msk_hw_id == CHIP_ID_YUKON_EC_U &amp;&amp;
+		if (sc_if-&gt;msk_softc-&gt;msk_hw_id == CHIP_ID_YUKON_FE &amp;&amp;
 		    ifr-&gt;ifr_mtu &gt; MSK_MAX_FRAMELEN) {
 			error = EINVAL;
 			break;
@@ -983,6 +995,16 @@
 			else
 				ifp-&gt;if_hwassist &amp;= ~CSUM_TSO;
 		}
+		if (sc_if-&gt;msk_framesize &gt; MSK_MAX_FRAMELEN &amp;&amp;
+		    sc_if-&gt;msk_softc-&gt;msk_hw_id == CHIP_ID_YUKON_EC_U) {
+			/*
+			 * In Yukon EC Ultra, TSO &amp; checksum offload is not
+			 * supported for jumbo frame.
+			 */
+			ifp-&gt;if_hwassist &amp;= ~(MSK_CSUM_FEATURES | CSUM_TSO);
+			ifp-&gt;if_capenable &amp;= ~(IFCAP_TSO4 | IFCAP_TXCSUM);
+		}
+
 		VLAN_CAPABILITIES(ifp);
 		MSK_IF_UNLOCK(sc_if);
 		break;
@@ -1018,64 +1040,38 @@
 static int
 mskc_setup_rambuffer(struct msk_softc *sc)
 {
-	int totqsize, minqsize;
-	int avail, next;
+	int next;
 	int i;
 	uint8_t val;
 
 	/* Get adapter SRAM size. */
 	val = CSR_READ_1(sc, B2_E_0);
 	sc-&gt;msk_ramsize = (val == 0) ? 128 : val * 4;
-	if (sc-&gt;msk_hw_id == CHIP_ID_YUKON_FE)
-		sc-&gt;msk_ramsize = 4 * 4;
 	if (bootverbose)
 		device_printf(sc-&gt;msk_dev,
 		    &quot;RAM buffer size : %dKB\n&quot;, sc-&gt;msk_ramsize);
-
-	totqsize = sc-&gt;msk_ramsize * sc-&gt;msk_num_port;
-	minqsize = MSK_MIN_RXQ_SIZE + MSK_MIN_TXQ_SIZE;
-	if (minqsize &gt; sc-&gt;msk_ramsize)
-		minqsize = sc-&gt;msk_ramsize;
-
-	if (minqsize * sc-&gt;msk_num_port &gt; totqsize) {
-		device_printf(sc-&gt;msk_dev,
-		    &quot;not enough RAM buffer memory : %d/%dKB\n&quot;,
-		    minqsize * sc-&gt;msk_num_port, totqsize);
-		return (ENOSPC);
-	}
-
-	avail = totqsize;
-	if (sc-&gt;msk_num_port &gt; 1) {
-		/*
-		 * Divide up the memory evenly so that everyone gets a
-		 * fair share for dual port adapters.
-		 */
-		avail = sc-&gt;msk_ramsize;
-	}
-
-	/* Take away the minimum memory for active queues. */
-	avail -= minqsize;
-	/* Rx queue gets the minimum + 80% of the rest. */
-	sc-&gt;msk_rxqsize =
-	    (avail * MSK_RAM_QUOTA_RX) / 100 + MSK_MIN_RXQ_SIZE;
-	avail -= (sc-&gt;msk_rxqsize - MSK_MIN_RXQ_SIZE);
-	sc-&gt;msk_txqsize = avail + MSK_MIN_TXQ_SIZE;
-
+	/*
+	 * Give receiver 2/3 of memory and round down to the multiple
+	 * of 1024. Tx/Rx RAM buffer size of Yukon II shoud be multiple
+	 * of 1024.
+	 */
+	sc-&gt;msk_rxqsize = rounddown((sc-&gt;msk_ramsize * 1024 * 2) / 3, 1024);
+	sc-&gt;msk_txqsize = (sc-&gt;msk_ramsize * 1024) - sc-&gt;msk_rxqsize;
 	for (i = 0, next = 0; i &lt; sc-&gt;msk_num_port; i++) {
 		sc-&gt;msk_rxqstart[i] = next;
-		sc-&gt;msk_rxqend[i] = next + (sc-&gt;msk_rxqsize * 1024) - 1;
+		sc-&gt;msk_rxqend[i] = next + sc-&gt;msk_rxqsize - 1;
 		next = sc-&gt;msk_rxqend[i] + 1;
 		sc-&gt;msk_txqstart[i] = next;
-		sc-&gt;msk_txqend[i] = next + (sc-&gt;msk_txqsize * 1024) - 1;
+		sc-&gt;msk_txqend[i] = next + sc-&gt;msk_txqsize - 1;
 		next = sc-&gt;msk_txqend[i] + 1;
 		if (bootverbose) {
 			device_printf(sc-&gt;msk_dev,
 			    &quot;Port %d : Rx Queue %dKB(0x%08x:0x%08x)\n&quot;, i,
-			    sc-&gt;msk_rxqsize, sc-&gt;msk_rxqstart[i],
+			    sc-&gt;msk_rxqsize / 1024, sc-&gt;msk_rxqstart[i],
 			    sc-&gt;msk_rxqend[i]);
 			device_printf(sc-&gt;msk_dev,
 			    &quot;Port %d : Tx Queue %dKB(0x%08x:0x%08x)\n&quot;, i,
-			    sc-&gt;msk_txqsize, sc-&gt;msk_txqstart[i],
+			    sc-&gt;msk_txqsize / 1024, sc-&gt;msk_txqstart[i],
 			    sc-&gt;msk_txqend[i]);
 		}
 	}
@@ -1345,7 +1341,8 @@
 	CSR_WRITE_4(sc, STAT_LIST_ADDR_HI, MSK_ADDR_HI(addr));
 	/* Set the status list last index. */
 	CSR_WRITE_2(sc, STAT_LAST_IDX, MSK_STAT_RING_CNT - 1);
-	if (HW_FEATURE(sc, HWF_WA_DEV_43_418)) {
+	if (sc-&gt;msk_hw_id == CHIP_ID_YUKON_EC &amp;&amp;
+	    sc-&gt;msk_hw_rev == CHIP_REV_YU_EC_A1) {
 		/* WA for dev. #4.3 */
 		CSR_WRITE_2(sc, STAT_TX_IDX_TH, ST_TXTH_IDX_MASK);
 		/* WA for dev. #4.18 */
@@ -1354,8 +1351,11 @@
 	} else {
 		CSR_WRITE_2(sc, STAT_TX_IDX_TH, 0x0a);
 		CSR_WRITE_1(sc, STAT_FIFO_WM, 0x10);
-		CSR_WRITE_1(sc, STAT_FIFO_ISR_WM,
-		    HW_FEATURE(sc, HWF_WA_DEV_4109) ? 0x10 : 0x04);
+		if (sc-&gt;msk_hw_id == CHIP_ID_YUKON_XL &amp;&amp;
+		    sc-&gt;msk_hw_rev == CHIP_REV_YU_XL_A0)
+			CSR_WRITE_1(sc, STAT_FIFO_ISR_WM, 0x04);
+		else
+			CSR_WRITE_1(sc, STAT_FIFO_ISR_WM, 0x10);
 		CSR_WRITE_4(sc, STAT_ISR_TIMER_INI, 0x0190);
 	}
 	/*
@@ -1453,13 +1453,8 @@
 	 * compute the checksum? I think there is no reason to spend time to
 	 * make Rx checksum offload work on Yukon II hardware.
 	 */
-	ifp-&gt;if_capabilities = IFCAP_TXCSUM;
-	ifp-&gt;if_hwassist = MSK_CSUM_FEATURES;
-	if (sc-&gt;msk_hw_id != CHIP_ID_YUKON_EC_U) {
-		/* It seems Yukon EC Ultra doesn't support TSO. */
-		ifp-&gt;if_capabilities |= IFCAP_TSO4;
-		ifp-&gt;if_hwassist |= CSUM_TSO;
-	}
+	ifp-&gt;if_capabilities = IFCAP_TXCSUM | IFCAP_TSO4;
+	ifp-&gt;if_hwassist = MSK_CSUM_FEATURES | CSUM_TSO;
 	ifp-&gt;if_capenable = ifp-&gt;if_capabilities;
 	ifp-&gt;if_ioctl = msk_ioctl;
 	ifp-&gt;if_start = msk_start;
@@ -1505,6 +1500,9 @@
 	 */
         ifp-&gt;if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
 
+	sc_if-&gt;msk_framesize = ifp-&gt;if_mtu + ETHER_HDR_LEN +
+	    ETHER_VLAN_ENCAP_LEN;
+
 	/*
 	 * Do miibus setup.
 	 */
@@ -1517,10 +1515,6 @@
 		error = ENXIO;
 		goto fail;
 	}
-	/* Check whether PHY Id is MARVELL. */
-	if (msk_phy_readreg(sc_if, PHY_ADDR_MARV, PHY_MARV_ID0)
-	    == PHY_MARV_ID0_VAL)
-		sc-&gt;msk_marvell_phy = 1;
 
 fail:
 	if (error != 0) {
@@ -1540,7 +1534,7 @@
 mskc_attach(device_t dev)
 {
 	struct msk_softc *sc;
-	int error, msic, *port, reg;
+	int error, msic, msir, *port, reg;
 
 	sc = device_get_softc(dev);
 	sc-&gt;msk_dev = dev;
@@ -1629,74 +1623,20 @@
 	else
 		sc-&gt;msk_bustype = MSK_PCI_BUS;
 
-	/* Get H/W features(bugs). */
 	switch (sc-&gt;msk_hw_id) {
 	case CHIP_ID_YUKON_EC:
-		sc-&gt;msk_clock = 125;	/* 125 Mhz */
-		if (sc-&gt;msk_hw_rev == CHIP_REV_YU_EC_A1) {
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_42  | HWF_WA_DEV_46 | HWF_WA_DEV_43_418 |
-			    HWF_WA_DEV_420 | HWF_WA_DEV_423 |
-			    HWF_WA_DEV_424 | HWF_WA_DEV_425 | HWF_WA_DEV_427 |
-			    HWF_WA_DEV_428 | HWF_WA_DEV_483 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4152 | HWF_WA_DEV_4167;
-		} else {
-			/* A2/A3 */
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_424 | HWF_WA_DEV_425 | HWF_WA_DEV_427 |
-			    HWF_WA_DEV_428 | HWF_WA_DEV_483 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4152 | HWF_WA_DEV_4167;
-		}
-		break;
 	case CHIP_ID_YUKON_EC_U:
 		sc-&gt;msk_clock = 125;	/* 125 Mhz */
-		if (sc-&gt;msk_hw_rev == CHIP_REV_YU_EC_U_A0) {
-			sc-&gt;msk_hw_feature = HWF_WA_DEV_427 | HWF_WA_DEV_483 |
-			    HWF_WA_DEV_4109;
-		} else if (sc-&gt;msk_hw_rev == CHIP_REV_YU_EC_A1) {
-			uint16_t v;
-
-			sc-&gt;msk_hw_feature = HWF_WA_DEV_427 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4185;
-			v = CSR_READ_2(sc, Q_ADDR(Q_XA1, Q_WM));
-			if (v == 0)
-				sc-&gt;msk_hw_feature |= HWF_WA_DEV_4185CS |
-				    HWF_WA_DEV_4200;
-		}
 		break;
 	case CHIP_ID_YUKON_FE:
 		sc-&gt;msk_clock = 100;	/* 100 Mhz */
-		sc-&gt;msk_hw_feature = HWF_WA_DEV_427 | HWF_WA_DEV_4109 |
-		    HWF_WA_DEV_4152 | HWF_WA_DEV_4167;
 		break;
 	case CHIP_ID_YUKON_XL:
 		sc-&gt;msk_clock = 156;	/* 156 Mhz */
-		switch (sc-&gt;msk_hw_rev) {
-		case CHIP_REV_YU_XL_A0:
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_427 | HWF_WA_DEV_463 | HWF_WA_DEV_472 |
-			    HWF_WA_DEV_479 | HWF_WA_DEV_483 | HWF_WA_DEV_4115 |
-			    HWF_WA_DEV_4152 | HWF_WA_DEV_4167;
-			break;
-		case CHIP_REV_YU_XL_A1:
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_427 | HWF_WA_DEV_483 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4115 | HWF_WA_DEV_4152 | HWF_WA_DEV_4167;
-			break;
-		case CHIP_REV_YU_XL_A2:
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_427 | HWF_WA_DEV_483 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4115 | HWF_WA_DEV_4167;
-			break;
-		case CHIP_REV_YU_XL_A3:
-			sc-&gt;msk_hw_feature =
-			    HWF_WA_DEV_427 | HWF_WA_DEV_483 | HWF_WA_DEV_4109 |
-			    HWF_WA_DEV_4115;
-		}
 		break;
 	default:
 		sc-&gt;msk_clock = 156;	/* 156 Mhz */
-		sc-&gt;msk_hw_feature = 0;
+		break;
 	}
 
 	/* Allocate IRQ resources. */
@@ -1714,13 +1654,27 @@
 	 */
 	if (legacy_intr != 0)
 		msi_disable = 1;
-	if (msic == 2 &amp;&amp; msi_disable == 0 &amp;&amp; sc-&gt;msk_num_port == 1 &amp;&amp;
-	    pci_alloc_msi(dev, &amp;msic) == 0) {
-		if (msic == 2) {
-			sc-&gt;msk_msi = 1;
-			sc-&gt;msk_irq_spec = msk_irq_spec_msi;
-		} else
-			pci_release_msi(dev);
+	if (msi_disable == 0) {
+		switch (msic) {
+		case 2:
+		case 1: /* 88E8058 reports 1 MSI message */
+			msir = msic;
+			if (sc-&gt;msk_num_port == 1 &amp;&amp;
+			    pci_alloc_msi(dev, &amp;msir) == 0) {
+				if (msic == msir) {
+					sc-&gt;msk_msi = 1;
+					sc-&gt;msk_irq_spec = msic == 2 ?
+					    msk_irq_spec_msi2 :
+					    msk_irq_spec_msi;
+				} else
+					pci_release_msi(dev);
+			}
+			break;
+		default:
+			device_printf(dev,
+			    &quot;Unexpected number of MSI messages : %d\n&quot;, msic);
+			break;
+		}
 	}
 
 	error = bus_alloc_resources(dev, sc-&gt;msk_irq_spec, sc-&gt;msk_irq);
@@ -2964,7 +2918,7 @@
 		taskqueue_enqueue(taskqueue_fast, &amp;sc_if-&gt;msk_tx_task);
 }
 
-static void
+static int
 mskc_shutdown(device_t dev)
 {
 	struct msk_softc *sc;
@@ -2987,6 +2941,7 @@
 	CSR_WRITE_2(sc, B0_CTST, CS_RST_SET);
 
 	MSK_UNLOCK(sc);
+	return (0);
 }
 
 static int
@@ -3226,15 +3181,12 @@
 {
 	uint16_t status;
 
-	if (sc_if-&gt;msk_softc-&gt;msk_marvell_phy) {
-		msk_phy_readreg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_STAT);
-		status = msk_phy_readreg(sc_if, PHY_ADDR_MARV,
-		    PHY_MARV_INT_STAT);
-		/* Handle FIFO Underrun/Overflow? */
-		if ((status &amp; PHY_M_IS_FIFO_ERROR))
-			device_printf(sc_if-&gt;msk_if_dev,
-			    &quot;PHY FIFO underrun/overflow.\n&quot;);
-	}
+	msk_phy_readreg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_STAT);
+	status = msk_phy_readreg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_STAT);
+	/* Handle FIFO Underrun/Overflow? */
+	if ((status &amp; PHY_M_IS_FIFO_ERROR))
+		device_printf(sc_if-&gt;msk_if_dev,
+		    &quot;PHY FIFO underrun/overflow.\n&quot;);
 }
 
 static void
@@ -3706,6 +3658,15 @@
 
 	sc_if-&gt;msk_framesize = ifp-&gt;if_mtu + ETHER_HDR_LEN +
 	    ETHER_VLAN_ENCAP_LEN;
+	if (sc_if-&gt;msk_framesize &gt; MSK_MAX_FRAMELEN &amp;&amp;
+	    sc_if-&gt;msk_softc-&gt;msk_hw_id == CHIP_ID_YUKON_EC_U) {
+		/*
+		 * In Yukon EC Ultra, TSO &amp; checksum offload is not
+		 * supported for jumbo frame.
+		 */
+		ifp-&gt;if_hwassist &amp;= ~(MSK_CSUM_FEATURES | CSUM_TSO);
+		ifp-&gt;if_capenable &amp;= ~(IFCAP_TSO4 | IFCAP_TXCSUM);
+	}
 
 	/*
 	 * Initialize GMAC first.
@@ -3796,9 +3757,6 @@
 	/* Configure hardware VLAN tag insertion/stripping. */
 	msk_setvlan(sc_if, ifp);
 
-	/* XXX It seems STFW is requried for all cases. */
-	CSR_WRITE_4(sc, MR_ADDR(sc_if-&gt;msk_port, TX_GMF_CTRL_T), TX_STFW_ENA);
-
 	if (sc-&gt;msk_hw_id == CHIP_ID_YUKON_EC_U) {
 		/* Set Rx Pause threshould. */
 		CSR_WRITE_1(sc, MR_ADDR(sc_if-&gt;msk_port, RX_GMF_LP_THR),
@@ -3807,16 +3765,17 @@
 		    MSK_ECU_ULPP);
 		if (sc_if-&gt;msk_framesize &gt; MSK_MAX_FRAMELEN) {
 			/*
-			 * Can't sure the following code is needed as Yukon
-			 * Yukon EC Ultra may not support jumbo frames.
-			 *
 			 * Set Tx GMAC FIFO Almost Empty Threshold.
 			 */
 			CSR_WRITE_4(sc, MR_ADDR(sc_if-&gt;msk_port, TX_GMF_AE_THR),
-			    MSK_ECU_AE_THR);
+			    MSK_ECU_JUMBO_WM &lt;&lt; 16 | MSK_ECU_AE_THR);
 			/* Disable Store &amp; Forward mode for Tx. */
 			CSR_WRITE_4(sc, MR_ADDR(sc_if-&gt;msk_port, TX_GMF_CTRL_T),
-			    TX_STFW_DIS);
+			    TX_JUMBO_ENA | TX_STFW_DIS);
+		} else {
+			/* Enable Store &amp; Forward mode for Tx. */
+			CSR_WRITE_4(sc, MR_ADDR(sc_if-&gt;msk_port, TX_GMF_CTRL_T),
+			    TX_JUMBO_DIS | TX_STFW_ENA);
 		}
 	}
 
@@ -4035,8 +3994,7 @@
 	/* Disable all GMAC interrupt. */
 	CSR_WRITE_1(sc, MR_ADDR(sc_if-&gt;msk_port, GMAC_IRQ_MSK), 0);
 	/* Disable PHY interrupt. */
-	if (sc-&gt;msk_marvell_phy)
-		msk_phy_writereg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_MASK, 0);
+	msk_phy_writereg(sc_if, PHY_ADDR_MARV, PHY_MARV_INT_MASK, 0);
 
 	/* Disable the RAM Interface Arbiter. */
 	CSR_WRITE_1(sc, MR_ADDR(sc_if-&gt;msk_port, TXA_CTRL), TXA_DIS_ARB);

Modified: haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_mskreg.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_mskreg.h	2008-02-16 15:54:51 UTC (rev 23964)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/marvell_yukon/dev/msk/if_mskreg.h	2008-02-16 18:46:40 UTC (rev 23965)
@@ -93,7 +93,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-/*$FreeBSD: src/sys/dev/msk/if_mskreg.h,v 1.6 2007/06/12 10:50:32 yongari Exp $*/
+/*$FreeBSD: src/sys/dev/msk/if_mskreg.h,v 1.11 2007/12/05 09:41:58 remko Exp $*/
 
 /*
  * SysKonnect PCI vendor ID
@@ -130,11 +130,13 @@
 #define DEVICEID_MRVL_8035	0x4350
 #define DEVICEID_MRVL_8036	0x4351
 #define DEVICEID_MRVL_8038	0x4352
+#define DEVICEID_MRVL_8039	0X4353
 #define DEVICEID_MRVL_4360	0x4360
 #define DEVICEID_MRVL_4361	0x4361
 #define DEVICEID_MRVL_4362	0x4362
 #define DEVICEID_MRVL_4363	0x4363
 #define DEVICEID_MRVL_4364	0x4364
+#define DEVICEID_MRVL_436A	0x436A
 
 /*
  * D-Link gigabit ethernet device ID
@@ -836,8 +838,8 @@
 #define CHIP_REV_YU_EC_A2	1 /* Chip Rev. for Yukon-EC A2 */
 #define CHIP_REV_YU_EC_A3	2 /* Chip Rev. for Yukon-EC A3 */
 
-#define	CHIP_REV_YU_EC_U_A0	0
-#define	CHIP_REV_YU_EC_U_A1	1
+#define	CHIP_REV_YU_EC_U_A0	1
+#define	CHIP_REV_YU_EC_U_A1	2
 
 /*	B2_Y2_CLK_GATE	 8 bit	Clock Gating (Yukon-2 only) */
 #define Y2_STATUS_LNK2_INAC	BIT_7	/* Status Link 2 inactiv (0 = activ) */
@@ -1082,8 +1084,9 @@
 /* Threshold values for Yukon-EC Ultra */
 #define	MSK_ECU_ULPP	0x0080	/* Upper Pause Threshold (multiples of 8) */
 #define	MSK_ECU_LLPP	0x0060	/* Lower Pause Threshold (multiples of 8) */
-#define	MSK_ECU_AE_THR	0x0180  /* Almost Empty Threshold */
+#define	MSK_ECU_AE_THR	0x0070  /* Almost Empty Threshold */
 #define	MSK_ECU_TXFF_LEV	0x01a0	/* Tx BMU FIFO Level */
+#define	MSK_ECU_JUMBO_WM	0x01
 
 #define MSK_BMU_RX_WM		0x600	/* BMU Rx Watermark */
 #define MSK_BMU_TX_WM		0x600	/* BMU Tx Watermark */
@@ -1863,6 +1866,8 @@
 #define	TX_STFW_ENA	BIT_30	/* Enable Store &amp; Forward (Yukon-EC Ultra) */
 #define TX_VLAN_TAG_ON	BIT_25	/* enable  VLAN tagging */
 #define TX_VLAN_TAG_OFF	BIT_24	/* disable VLAN tagging */
+#define	TX_JUMBO_ENA	BIT_23	/* Enable Jumbo Mode (Yukon-EC Ultra) */
+#define	TX_JUMBO_DIS	BIT_22	/* Disable Jumbo Mode (Yukon-EC Ultra) */
 #define GMF_WSP_TST_ON	BIT_18	/* Write Shadow Pointer Test On */
 #define GMF_WSP_TST_OFF	BIT_17	/* Write Shadow Pointer Test Off */
 #define GMF_WSP_STEP	BIT_16	/* Write Shadow Pointer Step/Increment */
@@ -2020,35 +2025,6 @@
 /* GPHY address (bits 15..11 of SMI control reg) */
 #define PHY_ADDR_MARV	0
 
-/*-RMV- DWORD 1: Deviations */
-#define HWF_WA_DEV_4200		0x10200000UL	/*-RMV- 4.200 (D3 Blue Screen)*/
-#define HWF_WA_DEV_4185CS	0x10100000UL	/*-RMV- 4.185 (ECU 100 CS cal)*/
-#define HWF_WA_DEV_4185		0x10080000UL	/*-RMV- 4.185 (ECU Tx h check)*/
-#define HWF_WA_DEV_4167		0x10040000UL	/*-RMV- 4.167 (Rx OvSize Hang)*/
-#define HWF_WA_DEV_4152		0x10020000UL	/*-RMV- 4.152 (RSS issue) */
-#define HWF_WA_DEV_4115		0x10010000UL	/*-RMV- 4.115 (Rx MAC FIFO) */
-#define HWF_WA_DEV_4109		0x10008000UL	/*-RMV- 4.109 (BIU hang) */
-#define HWF_WA_DEV_483		0x10004000UL	/*-RMV- 4.83 (Rx TCP wrong) */
-#define HWF_WA_DEV_479		0x10002000UL	/*-RMV- 4.79 (Rx BMU hang II) */
-#define HWF_WA_DEV_472		0x10001000UL	/*-RMV- 4.72 (GPHY2 MDC clk) */
-#define HWF_WA_DEV_463		0x10000800UL	/*-RMV- 4.63 (Rx BMU hang I) */
-#define HWF_WA_DEV_427		0x10000400UL	/*-RMV- 4.27 (Tx Done Rep) */
-#define HWF_WA_DEV_42		0x10000200UL	/*-RMV- 4.2 (pref unit burst) */
-#define HWF_WA_DEV_46		0x10000100UL	/*-RMV- 4.6 (CPU crash II) */
-#define HWF_WA_DEV_43_418	0x10000080UL	/*-RMV- 4.3 &amp; 4.18 (PCI unexp */
-/*-RMV- compl&amp;Stat BMU deadl) */
-#define HWF_WA_DEV_420		0x10000040UL	/*-RMV- 4.20 (Status BMU ov) */
-#define HWF_WA_DEV_423		0x10000020UL	/*-RMV- 4.23 (TCP Segm Hang) */
-#define HWF_WA_DEV_424		0x10000010UL	/*-RMV- 4.24 (MAC reg overwr) */
-#define HWF_WA_DEV_425		0x10000008UL	/*-RMV- 4.25 (Magic packet */
-/*-RMV- with odd offset) */
-#define HWF_WA_DEV_428		0x10000004UL	/*-RMV- 4.28 (Poll-U &amp;BigEndi)*/
-#define HWF_WA_FIFO_FLUSH_YLA0	0x10000002UL	/*-RMV- dis Rx GMAC FIFO Flush*/
-
-#define HW_FEATURE(sc, f)	\
-	(((((sc)-&gt;msk_hw_feature &amp; 0x30000000) &gt;&gt; 28) &amp; ((f) &amp; 0x0fffffff)) != 0)
-
-
 #define MSK_ADDR_LO(x)	((uint64_t) (x) &amp; 0xffffffffUL)
 #define MSK_ADDR_HI(x)	((uint64_t) (x) &gt;&gt; 32)
 
@@ -2331,9 +2307,7 @@
 	uint32_t		msk_intrmask;
 	uint32_t		msk_intrhwemask;
 	int			msk_suspended;
-	int			msk_hw_feature;
 	int			msk_clock;
-	int			msk_marvell_phy;
 	int			msk_msi;
 	struct msk_if_softc	*msk_if[2];
 	device_t		msk_devs[2];

Modified: haiku/trunk/src/libs/compat/freebsd_network/compat/sys/param.h
===================================================================
--- haiku/trunk/src/libs/compat/freebsd_network/compat/sys/param.h	2008-02-16 15:54:51 UTC (rev 23964)
+++ haiku/trunk/src/libs/compat/freebsd_network/compat/sys/param.h	2008-02-16 18:46:40 UTC (rev 23965)
@@ -48,5 +48,6 @@
 #define ALIGN(x)		((((unsigned)x) + ALIGN_BYTES) &amp; ~ALIGN_BYTES)
 
 #define roundup2(x, y)	(((x) + ((y) - 1)) &amp; (~((y) - 1)))
+#define rounddown(x, y)  (((x) / (y)) * (y))
 
 #endif	/* _FBSD_COMPAT_SYS_PARAM_H_ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="006089.html">[Haiku-commits] r23964 -	haiku/trunk/src/add-ons/kernel/drivers/input/usb_hid
</A></li>
	<LI>Next message: <A HREF="006091.html">[Haiku-commits] r23966 - haiku/trunk/src/apps/aboutsystem
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#6090">[ date ]</a>
              <a href="thread.html#6090">[ thread ]</a>
              <a href="subject.html#6090">[ subject ]</a>
              <a href="author.html#6090">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
