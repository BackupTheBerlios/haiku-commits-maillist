<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23878 - haiku/trunk/src/build/libroot
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23878%20-%20haiku/trunk/src/build/libroot&In-Reply-To=%3C200802051940.m15JeRtB029594%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005953.html">
   <LINK REL="Next"  HREF="005955.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23878 - haiku/trunk/src/build/libroot</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23878%20-%20haiku/trunk/src/build/libroot&In-Reply-To=%3C200802051940.m15JeRtB029594%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23878 - haiku/trunk/src/build/libroot">bonefish at mail.berlios.de
       </A><BR>
    <I>Tue Feb  5 20:40:27 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="005953.html">[Haiku-commits] r23877 - haiku/trunk/src/add-ons/disk_systems/intel
</A></li>
        <LI>Next message: <A HREF="005955.html">[Haiku-commits] r23879 - haiku/trunk/src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5954">[ date ]</a>
              <a href="thread.html#5954">[ thread ]</a>
              <a href="subject.html#5954">[ subject ]</a>
              <a href="author.html#5954">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-02-05 20:40:26 +0100 (Tue, 05 Feb 2008)
New Revision: 23878
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23878&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23878&amp;view=rev</A>

Modified:
   haiku/trunk/src/build/libroot/fs.cpp
Log:
Converted to UNIX line breaks.


Modified: haiku/trunk/src/build/libroot/fs.cpp
===================================================================
--- haiku/trunk/src/build/libroot/fs.cpp	2008-02-05 17:57:40 UTC (rev 23877)
+++ haiku/trunk/src/build/libroot/fs.cpp	2008-02-05 19:40:26 UTC (rev 23878)
@@ -1,999 +1,999 @@
-
-#include &lt;BeOSBuildCompatibility.h&gt;
-
-#include &quot;fs_impl.h&quot;
-
-#include &lt;dirent.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;utime.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-
-#include &lt;fs_attr.h&gt;
-#include &lt;NodeMonitor.h&gt;	// for B_STAT_* flags
-#include &lt;syscalls.h&gt;
-
-#include &quot;fs_descriptors.h&quot;
-#include &quot;NodeRef.h&quot;
-
-using namespace std;
-using namespace BPrivate;
-
-
-static status_t get_path(dev_t device, ino_t node, const char *name,
-	string &amp;path);
-
-
-// find_dir_entry
-static status_t
-find_dir_entry(DIR *dir, const char *path, NodeRef ref, string &amp;name,
-	bool skipDot)
-{
-	// find the entry
-	bool found = false;
-	while (dirent *entry = readdir(dir)) {
-		if ((!skipDot &amp;&amp; strcmp(entry-&gt;d_name, &quot;.&quot;) == 0)
-			|| strcmp(entry-&gt;d_name, &quot;..&quot;) == 0) {
-			// skip &quot;.&quot; and &quot;..&quot;
-		} else /*if (entry-&gt;d_ino == ref.node)*/ {
-				// Note: Linux doesn't seem to translate dirent::d_ino of
-				// mount points. Thus we always have to lstat().
-			// We also need to compare the device, which is generally not
-			// included in the dirent structure. Hence we lstat().
-			string entryPath(path);
-			entryPath += '/';
-			entryPath += entry-&gt;d_name;
-			struct stat st;
-			if (lstat(entryPath.c_str(), &amp;st) == 0) {
-				if (NodeRef(st) == ref) {
-					name = entry-&gt;d_name;
-					found = true;
-					break;
-				}
-			}
-		}
-	}
-
-	if (!found)
-		return B_ENTRY_NOT_FOUND;
-
-	return B_OK;
-}
-
-// find_dir_entry
-static status_t
-find_dir_entry(const char *path, NodeRef ref, string &amp;name, bool skipDot)
-{
-	// open dir
-	DIR *dir = opendir(path);
-	if (!dir)
-		return errno;
-
-	status_t error = find_dir_entry(dir, path, ref, name, skipDot);
-
-	// close dir
-	closedir(dir);
-
-	return error;
-}
-
-// normalize_dir_path
-static status_t
-normalize_dir_path(string path, NodeRef ref, string &amp;normalizedPath)
-{
-	// get parent path
-	path += &quot;/..&quot;;
-
-	// stat the parent dir
-	struct stat st;
-	if (lstat(path.c_str(), &amp;st) &lt; 0)
-		return errno;
-
-	// root dir?
-	NodeRef parentRef(st);
-	if (parentRef == ref) {
-		normalizedPath = &quot;/&quot;;
-		return 0;
-	}
-
-	// find the entry
-	string name;
-	status_t error = find_dir_entry(path.c_str(), ref, name, true)				;
-	if (error != B_OK)
-		return error;
-		
-	// recurse to get the parent dir path, if found
-	error = normalize_dir_path(path, parentRef, normalizedPath);
-	if (error != 0)
-		return error;
-
-	// construct the normalizedPath		
-	if (normalizedPath.length() &gt; 1) // don't append &quot;/&quot;, if parent is root
-		normalizedPath += '/';
-	normalizedPath += name;
-	
-	return 0;
-}
-
-// normalize_dir_path
-static status_t
-normalize_dir_path(const char *path, string &amp;normalizedPath)
-{
-	// stat() the dir
-	struct stat st;
-	if (stat(path, &amp;st) &lt; 0)
-		return errno;
-		
-	return normalize_dir_path(path, NodeRef(st), normalizedPath);
-}
-
-// normalize_entry_path
-static status_t
-normalize_entry_path(const char *path, string &amp;normalizedPath)
-{
-	const char *dirPath = NULL;
-	const char *leafName = NULL;
-	
-	string dirPathString;
-	if (char *lastSlash = strrchr(path, '/')) {
-		// found a slash: decompose into dir path and leaf name
-		leafName = lastSlash + 1;
-		if (leafName[0] == '\0') {
-			// slash is at the end: the whole path is a dir name
-			leafName = NULL;
-		} else {
-			dirPathString = string(path, leafName - path);
-			dirPath = dirPathString.c_str();
-		}
-
-	} else {
-		// path contains no slash, so it is a path relative to the current dir
-		dirPath = &quot;.&quot;;
-		leafName = path;
-	}
-
-	// catch special case: no leaf, or leaf is a directory
-	if (!leafName || strcmp(leafName, &quot;.&quot;) == 0 || strcmp(leafName, &quot;..&quot;) == 0)
-		return normalize_dir_path(path, normalizedPath);
-	
-	// normalize the dir path
-	status_t error = normalize_dir_path(dirPath, normalizedPath);
-	if (error != B_OK)
-		return error;
-
-	// append the leaf name
-	if (normalizedPath.length() &gt; 1) // don't append &quot;/&quot;, if parent is root
-		normalizedPath += '/';
-	normalizedPath += leafName;
-
-	return B_OK;
-}
-
-
-// #pragma mark -
-
-typedef map&lt;NodeRef, string&gt; DirPathMap;
-static DirPathMap sDirPathMap;
-
-// get_path
-static status_t
-get_path(const NodeRef *ref, const char *name, string &amp;path)
-{
-	if (!ref &amp;&amp; !name)
-		return B_BAD_VALUE;
-
-	// no ref or absolute path
-	if (!ref || (name &amp;&amp; name[0] == '/')) {
-		path = name;
-		return B_OK;
-	}
-
-	// get the dir path
-	if (ref) {
-		DirPathMap::iterator it = sDirPathMap.find(*ref);
-		if (it == sDirPathMap.end())
-			return B_ENTRY_NOT_FOUND;
-	
-		path = it-&gt;second;
-
-		// stat the path to check, if it is still valid
-		struct stat st;
-		if (lstat(path.c_str(), &amp;st) &lt; 0) {
-			sDirPathMap.erase(it);
-			return errno;
-		}
-
-		// compare the NodeRef
-		if (NodeRef(st) != *ref) {
-			sDirPathMap.erase(it);
-			return B_ENTRY_NOT_FOUND;
-		}
-
-		// still a directory?
-		if (!S_ISDIR(st.st_mode)) {
-			sDirPathMap.erase(it);
-			return B_NOT_A_DIRECTORY;
-		}
-	}
-
-	// if there's a name, append it
-	if (name) {
-		path += '/';
-		path += name;
-	}
-	
-	return B_OK;
-}
-
-// get_path
-status_t
-BPrivate::get_path(int fd, const char *name, string &amp;path)
-{
-	// get the node ref for the fd, if any, and the path part is not absolute
-	if (fd &gt;= 0 &amp;&amp; !(name &amp;&amp; name[0] == '/')) {
-		// get descriptor
-		Descriptor *descriptor = get_descriptor(fd);
-		if (!descriptor)
-			return B_FILE_ERROR;
-
-		// get node ref for the descriptor
-		NodeRef ref;
-		status_t error = descriptor-&gt;GetNodeRef(ref);
-		if (error != B_OK)
-			return error;
-
-		return ::get_path(&amp;ref, name, path);
-	
-	} else	// no descriptor or absolute path
-		return ::get_path((NodeRef*)NULL, name, path);
-}
-
-// get_path
-static status_t
-get_path(dev_t device, ino_t directory, const char *name, string &amp;path)
-{
-	NodeRef ref;
-	ref.device = device;
-	ref.node = directory;
-	
-	return get_path(&amp;ref, name, path);
-}
-
-// add_dir_path
-static void
-add_dir_path(const char *path, const NodeRef &amp;ref)
-{
-	// add the normalized path
-	string normalizedPath;
-	if (normalize_dir_path(path, normalizedPath) == B_OK)
-		sDirPathMap[ref] = normalizedPath;
-}
-
-
-// #pragma mark -
-
-// _kern_entry_ref_to_path
-status_t
-_kern_entry_ref_to_path(dev_t device, ino_t node, const char *leaf,
-	char *userPath, size_t pathLength)
-{
-	// get the path
-	string path;
-	status_t error = get_path(device, node, leaf, path);
-	if (error != B_OK)
-		return error;
-
-	// copy it back to the user buffer
-	if (strlcpy(userPath, path.c_str(), pathLength) &gt;= pathLength)
-		return B_BUFFER_OVERFLOW;
-	
-	return B_OK;
-}
-
-
-// #pragma mark -
-
-// _kern_create_dir
-status_t
-_kern_create_dir(int fd, const char *path, int perms)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, path, realPath);
-	if (error != B_OK)
-		return error;
-
-	// mkdir
-	if (mkdir(realPath.c_str(), perms) &lt; 0)
-		return errno;	
-	
-	return B_OK;
-}
-
-// _kern_create_dir_entry_ref
-status_t
-_kern_create_dir_entry_ref(dev_t device, ino_t node, const char *name,
-	int perms)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(device, node, name, realPath);
-	if (error != B_OK)
-		return error;
-
-	// mkdir
-	if (mkdir(realPath.c_str(), perms) &lt; 0)
-		return errno;	
-	
-	return B_OK;
-}
-
-// open_dir
-static int
-open_dir(const char *path)
-{
-	// open the dir
-	DIR *dir = opendir(path);
-	if (!dir)
-		return errno;
-
-	// stat the entry
-	struct stat st;
-	if (stat(path, &amp;st) &lt; 0) {
-		closedir(dir);
-		return errno;
-	}
-
-	if (!S_ISDIR(st.st_mode)) {
-		closedir(dir);
-		return B_NOT_A_DIRECTORY;
-	}
-
-	// cache dir path
-	NodeRef ref(st);
-	add_dir_path(path, ref);
-
-	// create descriptor	
-	DirectoryDescriptor *descriptor = new DirectoryDescriptor(dir, ref);
-	return add_descriptor(descriptor);
-}
-
-// _kern_open_dir
-int
-_kern_open_dir(int fd, const char *path)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, path, realPath);
-	if (error != B_OK)
-		return error;
-
-	return open_dir(realPath.c_str());
-}
-
-// _kern_open_dir_entry_ref
-int
-_kern_open_dir_entry_ref(dev_t device, ino_t node, const char *name)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(device, node, name, realPath);
-	if (error != B_OK)
-		return error;
-
-	return open_dir(realPath.c_str());
-}
-
-// _kern_open_parent_dir
-int
-_kern_open_parent_dir(int fd, char *name, size_t nameLength)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, name, realPath);
-	if (error != B_OK)
-		return error;
-
-	// stat the entry
-	struct stat st;
-	if (stat(realPath.c_str(), &amp;st) &lt; 0)
-		return errno;
-
-	if (!S_ISDIR(st.st_mode))
-		return B_NOT_A_DIRECTORY;
-
-	// get the entry name
-	realPath += &quot;/..&quot;;
-	string entryName;
-	error = find_dir_entry(realPath.c_str(), NodeRef(st),
-		entryName, false);
-	if (error != B_OK)
-		return error;
-
-	if (strlcpy(name, entryName.c_str(), nameLength) &gt;= nameLength)
-		return B_BUFFER_OVERFLOW;
-
-	// open the parent directory
-				
-	return open_dir(realPath.c_str());
-}
-
-// _kern_read_dir
-ssize_t
-_kern_read_dir(int fd, struct dirent *buffer, size_t bufferSize,
-	uint32 maxCount)
-{
-	if (maxCount &lt;= 0)
-		return B_BAD_VALUE;
-
-	// get the descriptor	
-	DirectoryDescriptor *descriptor
-		= dynamic_cast&lt;DirectoryDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// get the next entry
-	dirent *entry;
-	if (dynamic_cast&lt;AttrDirDescriptor*&gt;(descriptor))
-		entry = fs_read_attr_dir(descriptor-&gt;dir);
-	else
-		entry = readdir(descriptor-&gt;dir);
-	if (!entry)
-		return errno;
-
-	// copy the entry
-	int entryLen = &amp;entry-&gt;d_name[strlen(entry-&gt;d_name) + 1] - (char*)entry;
-	if (entryLen &gt; (int)bufferSize)
-		return B_BUFFER_OVERFLOW;
-
-	memcpy(buffer, entry, entryLen);
-
-	return 1;
-}
-
-// _kern_rewind_dir
-status_t
-_kern_rewind_dir(int fd)
-{
-	// get the descriptor	
-	DirectoryDescriptor *descriptor
-		= dynamic_cast&lt;DirectoryDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// rewind
-	if (dynamic_cast&lt;AttrDirDescriptor*&gt;(descriptor))
-		fs_rewind_attr_dir(descriptor-&gt;dir);
-	else
-		rewinddir(descriptor-&gt;dir);
-
-	return B_OK;
-}
-
-
-// #pragma mark -
-
-// open_file
-static int
-open_file(const char *path, int openMode, int perms)
-{
-	// stat the node
-	bool exists = true;
-	struct stat st;
-	if (lstat(path, &amp;st) &lt; 0) {
-		exists = false;
-		if (!(openMode &amp; O_CREAT))
-			return errno;
-	}
-
-	Descriptor *descriptor;
-	if (exists &amp;&amp; S_ISLNK(st.st_mode) &amp;&amp; (openMode &amp; O_NOTRAVERSE)) {
-		// a symlink not to be followed: create a special descriptor
-		// normalize path first
-		string normalizedPath;
-		status_t error = normalize_entry_path(path, normalizedPath);
-		if (error != B_OK)
-			return error;
-		
-		descriptor = new SymlinkDescriptor(normalizedPath.c_str());
-	
-	} else {
-		// open the file
-		openMode &amp;= ~O_NOTRAVERSE;
-		int newFD = open(path, openMode, perms);
-		if (newFD &lt; 0)
-			return errno;
-
-		descriptor = new FileDescriptor(newFD);
-	}
-	
-	// cache path, if this is a directory
-	if (exists &amp;&amp; S_ISDIR(st.st_mode))
-		add_dir_path(path, NodeRef(st));
-	
-	return add_descriptor(descriptor);
-}
-
-// _kern_open
-int
-_kern_open(int fd, const char *path, int openMode, int perms)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, path, realPath);
-	if (error != B_OK)
-		return error;
-
-	return open_file(realPath.c_str(), openMode, perms);
-}
-
-// _kern_open_entry_ref
-int
-_kern_open_entry_ref(dev_t device, ino_t node, const char *name,
-	int openMode, int perms)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(device, node, name, realPath);
-	if (error != B_OK)
-		return error;
-
-	return open_file(realPath.c_str(), openMode, perms);
-}
-
-// _kern_seek
-off_t
-_kern_seek(int fd, off_t pos, int seekType)
-{
-	// get the descriptor
-	FileDescriptor *descriptor
-		= dynamic_cast&lt;FileDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// seek
-	off_t result = lseek(descriptor-&gt;fd, pos, seekType);
-	if (result &lt; 0)
-		return errno;
-
-	return result;
-}
-
-// _kern_read
-ssize_t
-_kern_read(int fd, off_t pos, void *buffer, size_t bufferSize)
-{
-	// get the descriptor
-	FileDescriptor *descriptor
-		= dynamic_cast&lt;FileDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// seek
-	if (pos != -1) {
-		off_t result = lseek(descriptor-&gt;fd, pos, SEEK_SET);
-		if (result &lt; 0)
-			return errno;
-	}
-	
-	// read
-	ssize_t bytesRead = read(descriptor-&gt;fd, buffer, bufferSize);
-	if (bytesRead &lt; 0)
-		return errno;
-
-	return bytesRead;
-}
-
-// _kern_write
-ssize_t
-_kern_write(int fd, off_t pos, const void *buffer, size_t bufferSize)
-{
-	// get the descriptor
-	FileDescriptor *descriptor
-		= dynamic_cast&lt;FileDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// seek
-	if (pos != -1) {
-		off_t result = lseek(descriptor-&gt;fd, pos, SEEK_SET);
-		if (result &lt; 0)
-			return errno;
-	}
-	
-	// read
-	ssize_t bytesWritten = write(descriptor-&gt;fd, buffer, bufferSize);
-	if (bytesWritten &lt; 0)
-		return errno;
-
-	return bytesWritten;
-}
-
-// _kern_close
-status_t
-_kern_close(int fd)
-{
-	return delete_descriptor(fd);
-}
-
-// _kern_dup
-int
-_kern_dup(int fd)
-{
-	// get the descriptor
-	Descriptor *descriptor = get_descriptor(fd);
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// clone it
-	Descriptor *clone;
-	status_t error = descriptor-&gt;Dup(clone);
-	if (error != B_OK)
-		return error;
-
-	return add_descriptor(clone);
-}
-
-// _kern_fsync
-status_t
-_kern_fsync(int fd)
-{
-	// get the descriptor
-	FileDescriptor *descriptor
-		= dynamic_cast&lt;FileDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// sync
-	if (fsync(descriptor-&gt;fd) &lt; 0)
-		return errno;
-
-	return B_OK;
-}
-
-// _kern_read_stat
-status_t
-_kern_read_stat(int fd, const char *path, bool traverseLink,
-	struct stat *st, size_t statSize)
-{
-	if (path) {
-		// get a usable path
-		string realPath;
-		status_t error = get_path(fd, path, realPath);
-		if (error != B_OK)
-			return error;
-
-		// stat
-		int result;
-		if (traverseLink)
-			result = stat(realPath.c_str(), st);
-		else
-			result = lstat(realPath.c_str(), st);
-
-		if (result &lt; 0)
-			return errno;
-	} else {
-		Descriptor *descriptor = get_descriptor(fd);
-		if (!descriptor)
-			return B_FILE_ERROR;
-	
-		return descriptor-&gt;GetStat(traverseLink, st);
-	}
-			
-	return B_OK;
-}
-
-// _kern_write_stat
-status_t
-_kern_write_stat(int fd, const char *path, bool traverseLink,
-	const struct stat *st, size_t statSize, int statMask)
-{
-	// get a usable path
-	int realFD = -1;
-	string realPath;
-	status_t error;
-	bool isSymlink = false;
-	if (path) {
-		error = get_path(fd, path, realPath);
-		if (error != B_OK)
-			return error;
-
-		// stat it to see, if it is a symlink
-		struct stat tmpStat;
-		if (lstat(realPath.c_str(), &amp;tmpStat) &lt; 0)
-			return errno;
-
-		isSymlink = S_ISLNK(tmpStat.st_mode);
-			
-	} else {
-		Descriptor *descriptor = get_descriptor(fd);
-		if (!descriptor)
-			return B_FILE_ERROR;
-
-		if (FileDescriptor *fileFD
-				= dynamic_cast&lt;FileDescriptor*&gt;(descriptor)) {
-			realFD = fileFD-&gt;fd;
-		
-		} else if (dynamic_cast&lt;DirectoryDescriptor*&gt;(descriptor)) {
-			error = get_path(fd, NULL, realPath);
-			if (error != B_OK)
-				return error;
-		
-		} else if (SymlinkDescriptor *linkFD
-				= dynamic_cast&lt;SymlinkDescriptor*&gt;(descriptor)) {
-			realPath = linkFD-&gt;path;
-			isSymlink = true;
-		
-		} else
-			return B_FILE_ERROR;
-	}
-
-	// We're screwed, if the node to manipulate is a symlink. All the
-	// available functions traverse symlinks.
-	if (isSymlink &amp;&amp; !traverseLink)
-		return B_ERROR;
-	
-	if (realFD &gt;= 0) {
-		if (statMask &amp; B_STAT_MODE) {
-			if (fchmod(realFD, st-&gt;st_mode) &lt; 0)
-				return errno;
-		}
-			
-		if (statMask &amp; B_STAT_UID) {
-			if (fchown(realFD, st-&gt;st_uid, (gid_t)-1) &lt; 0)
-				return errno;
-		}
-			
-		if (statMask &amp; B_STAT_GID) {
-			if (fchown(realFD, (uid_t)-1, st-&gt;st_gid) &lt; 0)
-				return errno;
-		}
-		
-		if (statMask &amp; B_STAT_SIZE) {
-			if (ftruncate(realFD, st-&gt;st_size) &lt; 0)
-				return errno;
-		}
-
-		// The timestamps can only be set via utime(), but that requires a
-		// path we don't have.
-		if (statMask &amp; (B_STAT_ACCESS_TIME | B_STAT_MODIFICATION_TIME
-				| B_STAT_CREATION_TIME | B_STAT_CHANGE_TIME)) {
-			return B_ERROR;
-		}
-		
-		return 0;
-	
-	} else {
-		if (statMask &amp; B_STAT_MODE) {
-			if (chmod(realPath.c_str(), st-&gt;st_mode) &lt; 0)
-				return errno;
-		}
-			
-		if (statMask &amp; B_STAT_UID) {
-			if (chown(realPath.c_str(), st-&gt;st_uid, (gid_t)-1) &lt; 0)
-				return errno;
-		}
-			
-		if (statMask &amp; B_STAT_GID) {
-			if (chown(realPath.c_str(), (uid_t)-1, st-&gt;st_gid) &lt; 0)
-				return errno;
-		}
-		
-		if (statMask &amp; B_STAT_SIZE) {
-			if (truncate(realPath.c_str(), st-&gt;st_size) &lt; 0)
-				return errno;
-		}
-
-		if (statMask &amp; (B_STAT_ACCESS_TIME | B_STAT_MODIFICATION_TIME)) {
-			// Grab the previous mod and access times so we only overwrite
-			// the specified time and not both
-			struct stat oldStat;
-			if (~statMask &amp; (B_STAT_ACCESS_TIME | B_STAT_MODIFICATION_TIME)) {
-				if (stat(realPath.c_str(), &amp;oldStat) &lt; 0)
-					return errno;
-			}
-				
-			utimbuf buffer;
-			buffer.actime = (statMask &amp; B_STAT_ACCESS_TIME) ? st-&gt;st_atime : oldStat.st_atime;
-			buffer.modtime = (statMask &amp; B_STAT_MODIFICATION_TIME) ? st-&gt;st_mtime : oldStat.st_mtime;
-			if (utime(realPath.c_str(), &amp;buffer) &lt; 0)
-				return errno;
-		}
-				
-		// not supported	
-		if (statMask &amp; (B_STAT_CREATION_TIME | B_STAT_CHANGE_TIME))
-			return B_ERROR;
-	}	
-
-	return B_OK;
-}
-
-
-// #pragma mark -
-
-// _kern_create_symlink
-status_t
-_kern_create_symlink(int fd, const char *path, const char *toPath, int mode)
-{
-	// Note: path must not be NULL, so this will always work.
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, path, realPath);
-	if (error != B_OK)
-		return error;
-
-	// symlink
-	if (symlink(toPath, realPath.c_str()) &lt; 0)
-		return errno;
-
-	return B_OK;
-}
-
-// _kern_read_link
-status_t
-_kern_read_link(int fd, const char *path, char *buffer, size_t *_bufferSize)
-{
-	// get the descriptor
-	SymlinkDescriptor *descriptor
-		= dynamic_cast&lt;SymlinkDescriptor*&gt;(get_descriptor(fd));
-	if (!descriptor)
-		return B_FILE_ERROR;
-
-	// readlink
-	ssize_t bytesRead = readlink(descriptor-&gt;path.c_str(), buffer,
-		*_bufferSize);
-	if (bytesRead &lt; 0)
-		return errno;
-
-	if (*_bufferSize &gt; 0) {
-		if ((size_t)bytesRead == *_bufferSize)
-			bytesRead--;
-	
-		buffer[bytesRead] = '\0';
-	}
-
-	*_bufferSize = bytesRead;
-
-	return B_OK;
-}
-
-// _kern_unlink
-status_t
-_kern_unlink(int fd, const char *path)
-{
-	// get a usable path
-	string realPath;
-	status_t error = get_path(fd, path, realPath);
-	if (error != B_OK)
-		return error;
-
-	// unlink
-	if (unlink(realPath.c_str()) &lt; 0)
-		return errno;
-
-	return B_OK;
-}
-
-// _kern_rename
-status_t
-_kern_rename(int oldDir, const char *oldPath, int newDir, const char *newPath)
-{
-	// get usable paths
-	string realOldPath;
-	status_t error = get_path(oldDir, oldPath, realOldPath);
-	if (error != B_OK)
-		return error;
-
-	string realNewPath;
-	error = get_path(newDir, newPath, realNewPath);
-	if (error != B_OK)
-		return error;
-		
-	// rename
-	if (rename(realOldPath.c_str(), realNewPath.c_str()) &lt; 0)
-		return errno;
-
-	return B_OK;
-}
-
-
-// #pragma mark -
-
-// _kern_lock_node
-status_t
-_kern_lock_node(int fd)
-{
-	return B_ERROR;
-}
-
-// _kern_unlock_node
-status_t
-_kern_unlock_node(int fd)
-{
-	return B_ERROR;
-}
-
-
-// #pragma mark -
-
-// read_pos
-ssize_t
-read_pos(int fd, off_t pos, void *buffer, size_t bufferSize)
-{
-	// seek
-	off_t result = lseek(fd, pos, SEEK_SET);
-	if (result &lt; 0)
-		return errno;
-	
-	// read
-	ssize_t bytesRead = read(fd, buffer, bufferSize);
-	if (bytesRead &lt; 0) {
-		errno = bytesRead;
-		return -1;
-	}
-
-	return bytesRead;
-}
-
-// write_pos
-ssize_t
-write_pos(int fd, off_t pos, const void *buffer, size_t bufferSize)
-{
-	// seek
-	off_t result = lseek(fd, pos, SEEK_SET);
-	if (result &lt; 0)
-		return errno;
-	
-	// read
-	ssize_t bytesWritten = write(fd, buffer, bufferSize);
-	if (bytesWritten &lt; 0) {
-		errno = bytesWritten;
-		return -1;
-	}
-
-	return bytesWritten;
-}
-
-// readv_pos
-ssize_t
-readv_pos(int fd, off_t pos, const struct iovec *vec, size_t count)
-{
-	// seek
-	off_t result = lseek(fd, pos, SEEK_SET);
-	if (result &lt; 0)
-		return errno;
-	
-	// read
-	ssize_t bytesRead = readv(fd, vec, count);
-	if (bytesRead &lt; 0) {
-		errno = bytesRead;
-		return -1;
-	}
-
-	return bytesRead;
-}
-
-// writev_pos
-ssize_t
-writev_pos(int fd, off_t pos, const struct iovec *vec, size_t count)
-{
-	// seek
-	off_t result = lseek(fd, pos, SEEK_SET);
-	if (result &lt; 0)
-		return errno;
-	
-	// read
-	ssize_t bytesWritten = writev(fd, vec, count);
-	if (bytesWritten &lt; 0) {
-		errno = bytesWritten;
-		return -1;

[... truncated: 1004 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005953.html">[Haiku-commits] r23877 - haiku/trunk/src/add-ons/disk_systems/intel
</A></li>
	<LI>Next message: <A HREF="005955.html">[Haiku-commits] r23879 - haiku/trunk/src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5954">[ date ]</a>
              <a href="thread.html#5954">[ thread ]</a>
              <a href="subject.html#5954">[ subject ]</a>
              <a href="author.html#5954">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
