<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33217 - in haiku/trunk: build/config_headers	src/apps/debugger src/apps/debugger/arch/x86	src/apps/debugger/debug_info src/apps/debugger/dwarf	src/apps/debugger/elf src/apps/debugger/gui/team_window	src/apps/debugger/model src/apps/debugger/types
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33217%20-%20in%20haiku/trunk%3A%20build/config_headers%0A%09src/apps/debugger%20src/apps/debugger/arch/x86%0A%09src/apps/debugger/debug_info%20src/apps/debugger/dwarf%0A%09src/apps/debugger/elf%20src/apps/debugger/gui/team_window%0A%09src/apps/debugger/model%20src/apps/debugger/types&In-Reply-To=%3C200909210440.n8L4e1Ha024037%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020741.html">
   <LINK REL="Next"  HREF="020745.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33217 - in haiku/trunk: build/config_headers	src/apps/debugger src/apps/debugger/arch/x86	src/apps/debugger/debug_info src/apps/debugger/dwarf	src/apps/debugger/elf src/apps/debugger/gui/team_window	src/apps/debugger/model src/apps/debugger/types</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33217%20-%20in%20haiku/trunk%3A%20build/config_headers%0A%09src/apps/debugger%20src/apps/debugger/arch/x86%0A%09src/apps/debugger/debug_info%20src/apps/debugger/dwarf%0A%09src/apps/debugger/elf%20src/apps/debugger/gui/team_window%0A%09src/apps/debugger/model%20src/apps/debugger/types&In-Reply-To=%3C200909210440.n8L4e1Ha024037%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33217 - in haiku/trunk: build/config_headers	src/apps/debugger src/apps/debugger/arch/x86	src/apps/debugger/debug_info src/apps/debugger/dwarf	src/apps/debugger/elf src/apps/debugger/gui/team_window	src/apps/debugger/model src/apps/debugger/types">bonefish at mail.berlios.de
       </A><BR>
    <I>Mon Sep 21 06:40:01 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020741.html">[Haiku-commits] r33216 - haiku/trunk/src/apps/debugger
</A></li>
        <LI>Next message: <A HREF="020745.html">[Haiku-commits] r33218 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20742">[ date ]</a>
              <a href="thread.html#20742">[ thread ]</a>
              <a href="subject.html#20742">[ subject ]</a>
              <a href="author.html#20742">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-09-21 06:39:40 +0200 (Mon, 21 Sep 2009)
New Revision: 33217
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33217&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33217&amp;view=rev</A>

Added:
   haiku/trunk/build/config_headers/apps_debugger_config.h
   haiku/trunk/src/apps/debugger/Tracing.h
   haiku/trunk/src/apps/debugger/debug_info/DwarfStackFrameDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfStackFrameDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/NoOpStackFrameDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/NoOpStackFrameDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/StackFrameDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/StackFrameDebugInfo.h
   haiku/trunk/src/apps/debugger/model/StackFrameValueInfos.cpp
   haiku/trunk/src/apps/debugger/model/StackFrameValueInfos.h
Removed:
   haiku/trunk/src/apps/debugger/debug_info/DwarfInterfaceFactory.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfInterfaceFactory.h
Modified:
   haiku/trunk/src/apps/debugger/BreakpointManager.cpp
   haiku/trunk/src/apps/debugger/Jamfile
   haiku/trunk/src/apps/debugger/Jobs.cpp
   haiku/trunk/src/apps/debugger/Jobs.h
   haiku/trunk/src/apps/debugger/TeamDebugger.cpp
   haiku/trunk/src/apps/debugger/ThreadHandler.cpp
   haiku/trunk/src/apps/debugger/arch/x86/ArchitectureX86.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.cpp
   haiku/trunk/src/apps/debugger/debug_info/DwarfImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/SpecificImageDebugInfo.h
   haiku/trunk/src/apps/debugger/debug_info/TeamDebugInfo.cpp
   haiku/trunk/src/apps/debugger/dwarf/AttributeValue.h
   haiku/trunk/src/apps/debugger/dwarf/DebugInfoEntries.cpp
   haiku/trunk/src/apps/debugger/dwarf/DebugInfoEntries.h
   haiku/trunk/src/apps/debugger/dwarf/DebugInfoEntry.cpp
   haiku/trunk/src/apps/debugger/dwarf/DebugInfoEntry.h
   haiku/trunk/src/apps/debugger/dwarf/DwarfExpressionEvaluator.cpp
   haiku/trunk/src/apps/debugger/dwarf/DwarfFile.cpp
   haiku/trunk/src/apps/debugger/dwarf/DwarfFile.h
   haiku/trunk/src/apps/debugger/dwarf/DwarfTargetInterface.h
   haiku/trunk/src/apps/debugger/dwarf/LineNumberProgram.cpp
   haiku/trunk/src/apps/debugger/elf/ElfFile.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/ImageFunctionsView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/ImageListView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/SourceView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/TeamWindow.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/VariablesView.cpp
   haiku/trunk/src/apps/debugger/gui/team_window/VariablesView.h
   haiku/trunk/src/apps/debugger/model/StackFrame.cpp
   haiku/trunk/src/apps/debugger/model/StackFrame.h
   haiku/trunk/src/apps/debugger/model/Team.cpp
   haiku/trunk/src/apps/debugger/model/Type.cpp
   haiku/trunk/src/apps/debugger/model/Type.h
   haiku/trunk/src/apps/debugger/model/TypeComponentPath.cpp
   haiku/trunk/src/apps/debugger/model/TypeComponentPath.h
   haiku/trunk/src/apps/debugger/types/ValueLocation.cpp
   haiku/trunk/src/apps/debugger/types/ValueLocation.h
Log:
* More work on retrieving local variable values. Address and compound types can
  now be inspected. Still work in progress -- bit fields and arrays don't work
  correctly yet nor does type lookup beyond the current compilation unit.
* Made most of the debugger output configurable via a config header. By default
  it's much less noisy now.


Added: haiku/trunk/build/config_headers/apps_debugger_config.h
===================================================================
--- haiku/trunk/build/config_headers/apps_debugger_config.h	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/build/config_headers/apps_debugger_config.h	2009-09-21 04:39:40 UTC (rev 33217)
@@ -0,0 +1,44 @@
+#ifndef APPS_DEBUGGER_CONFIG_H
+#define APPS_DEBUGGER_CONFIG_H
+
+
+// trace DWARF debug info entry parsing
+#define	APPS_DEBUGGER_TRACE_DWARF_DIE			0
+
+// trace DWARF line info:
+// 1: general info only
+// 2: line number program execution
+#define	APPS_DEBUGGER_TRACE_DWARF_LINE_INFO		0
+
+// trace DWARF expression evaluation
+#define	APPS_DEBUGGER_TRACE_DWARF_EXPRESSIONS	0
+
+// dump DWARF public types section
+#define	APPS_DEBUGGER_TRACE_DWARF_PUBLIC_TYPES	0
+
+// trace (DWARF) canonical frame info parsing/evaluation
+#define	APPS_DEBUGGER_TRACE_CFI					0
+
+// trace retrieving of stack frame local variable types and values
+#define	APPS_DEBUGGER_TRACE_STACK_FRAME_LOCALS	0
+
+// trace image loading and changes
+#define	APPS_DEBUGGER_TRACE_IMAGES				0
+
+// trace program code reading/analyzing
+#define	APPS_DEBUGGER_TRACE_CODE				0
+
+// trace general job handling
+#define	APPS_DEBUGGER_TRACE_JOBS				0
+
+// trace debug events
+#define	APPS_DEBUGGER_TRACE_DEBUG_EVENTS		0
+
+// trace controlling the debugged team (stepping, breakpoints,...)
+#define	APPS_DEBUGGER_TRACE_TEAM_CONTROL		0
+
+// trace GUI operations
+#define	APPS_DEBUGGER_TRACE_GUI					0
+
+
+#endif	// APPS_DEBUGGER_CONFIG_H

Modified: haiku/trunk/src/apps/debugger/BreakpointManager.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/BreakpointManager.cpp	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/src/apps/debugger/BreakpointManager.cpp	2009-09-21 04:39:40 UTC (rev 33217)
@@ -16,6 +16,7 @@
 #include &quot;SpecificImageDebugInfo.h&quot;
 #include &quot;Statement.h&quot;
 #include &quot;Team.h&quot;
+#include &quot;Tracing.h&quot;
 
 
 BreakpointManager::BreakpointManager(Team* team,
@@ -44,36 +45,41 @@
 BreakpointManager::InstallUserBreakpoint(UserBreakpoint* userBreakpoint,
 	bool enabled)
 {
-printf(&quot;BreakpointManager::InstallUserBreakpoint(%p, %d)\n&quot;, userBreakpoint, enabled);
+	TRACE_CONTROL(&quot;BreakpointManager::InstallUserBreakpoint(%p, %d)\n&quot;,
+		userBreakpoint, enabled);
+
 	AutoLocker&lt;BLocker&gt; installLocker(fLock);
 	AutoLocker&lt;Team&gt; teamLocker(fTeam);
 
 	bool oldEnabled = userBreakpoint-&gt;IsEnabled();
-	if (userBreakpoint-&gt;IsValid() &amp;&amp; enabled == oldEnabled)
-{
-printf(&quot;  user breakpoint already valid and with same enabled state\n&quot;);
+	if (userBreakpoint-&gt;IsValid() &amp;&amp; enabled == oldEnabled) {
+		TRACE_CONTROL(&quot;  user breakpoint already valid and with same enabled &quot;
+			&quot;state\n&quot;);
 		return B_OK;
-}
+	}
 
 	// get/create the breakpoints for all instances
-printf(&quot;  creating breakpoints for breakpoint instances\n&quot;);
+	TRACE_CONTROL(&quot;  creating breakpoints for breakpoint instances\n&quot;);
+
 	status_t error = B_OK;
 	for (int32 i = 0;
 		UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i); i++) {
-printf(&quot;    breakpoint instance %p\n&quot;, instance);
-		if (instance-&gt;GetBreakpoint() != NULL)
-{
-printf(&quot;    -&gt; already has breakpoint\n&quot;);
+
+		TRACE_CONTROL(&quot;    breakpoint instance %p\n&quot;, instance);
+
+		if (instance-&gt;GetBreakpoint() != NULL) {
+			TRACE_CONTROL(&quot;    -&gt; already has breakpoint\n&quot;);
 			continue;
-}
+		}
 
 		target_addr_t address = instance-&gt;Address();
 		Breakpoint* breakpoint = fTeam-&gt;BreakpointAtAddress(address);
 		if (breakpoint == NULL) {
-printf(&quot;    -&gt; no breakpoint at that address yet\n&quot;);
+			TRACE_CONTROL(&quot;    -&gt; no breakpoint at that address yet\n&quot;);
+
 			Image* image = fTeam-&gt;ImageByAddress(address);
 			if (image == NULL) {
-printf(&quot;    -&gt; no image at that address\n&quot;);
+				TRACE_CONTROL(&quot;    -&gt; no image at that address\n&quot;);
 				error = B_BAD_ADDRESS;
 				break;
 			}
@@ -86,7 +92,8 @@
 			}
 		}
 
-printf(&quot;    -&gt; adding instance to breakpoint %p\n&quot;, breakpoint);
+		TRACE_CONTROL(&quot;    -&gt; adding instance to breakpoint %p\n&quot;, breakpoint);
+
 		breakpoint-&gt;AddUserBreakpoint(instance);
 		instance-&gt;SetBreakpoint(breakpoint);
 	}
@@ -108,12 +115,14 @@
 	teamLocker.Unlock();
 
 	// install/uninstall the breakpoints as needed
-printf(&quot;  updating breakpoints\n&quot;);
+	TRACE_CONTROL(&quot;  updating breakpoints\n&quot;);
+
 	if (error == B_OK) {
 		for (int32 i = 0;
 			UserBreakpointInstance* instance = userBreakpoint-&gt;InstanceAt(i);
 			i++) {
-printf(&quot;    breakpoint instance %p\n&quot;, instance);
+			TRACE_CONTROL(&quot;    breakpoint instance %p\n&quot;, instance);
+
 			error = _UpdateBreakpointInstallation(instance-&gt;GetBreakpoint());
 			if (error != B_OK)
 				break;
@@ -121,7 +130,8 @@
 	}
 
 	if (error == B_OK) {
-printf(&quot;  success, marking user breakpoint valid\n&quot;);
+		TRACE_CONTROL(&quot;  success, marking user breakpoint valid\n&quot;);
+
 		// everything went fine -- mark the user breakpoint valid
 		if (!userBreakpoint-&gt;IsValid()) {
 			teamLocker.Lock();
@@ -132,7 +142,8 @@
 		}
 	} else {
 		// something went wrong -- revert the situation
-printf(&quot;  error, reverting\n&quot;);
+		TRACE_CONTROL(&quot;  error, reverting\n&quot;);
+
 		teamLocker.Lock();
 		userBreakpoint-&gt;SetEnabled(oldEnabled);
 		teamLocker.Unlock();
@@ -471,7 +482,11 @@
 BreakpointManager::_UpdateBreakpointInstallation(Breakpoint* breakpoint)
 {
 	bool shouldBeInstalled = breakpoint-&gt;ShouldBeInstalled();
-printf(&quot;BreakpointManager::_UpdateBreakpointInstallation(%p): should be installed: %d, is installed: %d\n&quot;, breakpoint, shouldBeInstalled, breakpoint-&gt;IsInstalled());
+
+	TRACE_CONTROL(&quot;BreakpointManager::_UpdateBreakpointInstallation(%p): &quot;
+		&quot;should be installed: %d, is installed: %d\n&quot;, breakpoint,
+		shouldBeInstalled, breakpoint-&gt;IsInstalled());
+
 	if (shouldBeInstalled == breakpoint-&gt;IsInstalled())
 		return B_OK;
 
@@ -481,12 +496,18 @@
 			breakpoint-&gt;Address());
 		if (error != B_OK)
 			return error;
-printf(&quot;BREAKPOINT at %#llx installed: %s\n&quot;, breakpoint-&gt;Address(), strerror(error));
+
+		TRACE_CONTROL(&quot;BREAKPOINT at %#llx installed: %s\n&quot;,
+			breakpoint-&gt;Address(), strerror(error));
+
 		breakpoint-&gt;SetInstalled(true);
 	} else {
 		// uninstall
 		fDebuggerInterface-&gt;UninstallBreakpoint(breakpoint-&gt;Address());
-printf(&quot;BREAKPOINT at %#llx uninstalled\n&quot;, breakpoint-&gt;Address());
+
+		TRACE_CONTROL(&quot;BREAKPOINT at %#llx uninstalled\n&quot;,
+			breakpoint-&gt;Address());
+
 		breakpoint-&gt;SetInstalled(false);
 	}
 

Modified: haiku/trunk/src/apps/debugger/Jamfile
===================================================================
--- haiku/trunk/src/apps/debugger/Jamfile	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/src/apps/debugger/Jamfile	2009-09-21 04:39:40 UTC (rev 33217)
@@ -30,8 +30,8 @@
 SourceHdrs
 	DwarfFunctionDebugInfo.cpp
 	DwarfImageDebugInfo.cpp
+	DwarfStackFrameDebugInfo.cpp
 	DwarfTeamDebugInfo.cpp
-	DwarfInterfaceFactory.cpp
 	: [ FDirName $(SUBDIR) dwarf ]
 ;
 
@@ -60,15 +60,17 @@
 	DebuggerTeamDebugInfo.cpp
 	DwarfFunctionDebugInfo.cpp
 	DwarfImageDebugInfo.cpp
+	DwarfStackFrameDebugInfo.cpp
 	DwarfTeamDebugInfo.cpp
-	DwarfInterfaceFactory.cpp
 	Function.cpp
 	FunctionDebugInfo.cpp
 	FunctionInstance.cpp
 	ImageDebugInfo.cpp
 	ImageDebugInfoProvider.cpp
+	NoOpStackFrameDebugInfo.cpp
 	SpecificImageDebugInfo.cpp
 	SpecificTeamDebugInfo.cpp
+	StackFrameDebugInfo.cpp
 	TeamDebugInfo.cpp
 
 	# debugger_interface
@@ -110,6 +112,7 @@
 	SourceCode.cpp
 	StackFrame.cpp
 	StackFrameValues.cpp
+	StackFrameValueInfos.cpp
 	StackTrace.cpp
 	Statement.cpp
 	SymbolInfo.cpp

Modified: haiku/trunk/src/apps/debugger/Jobs.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/Jobs.cpp	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/src/apps/debugger/Jobs.cpp	2009-09-21 04:39:40 UTC (rev 33217)
@@ -5,8 +5,6 @@
 
 #include &quot;Jobs.h&quot;
 
-#include &lt;new&gt;
-
 #include &lt;AutoLocker.h&gt;
 
 #include &quot;Architecture.h&quot;
@@ -21,11 +19,14 @@
 #include &quot;Register.h&quot;
 #include &quot;SourceCode.h&quot;
 #include &quot;SpecificImageDebugInfo.h&quot;
+#include &quot;StackFrameDebugInfo.h&quot;
+#include &quot;StackFrameValueInfos.h&quot;
 #include &quot;StackFrameValues.h&quot;
 #include &quot;StackTrace.h&quot;
 #include &quot;Team.h&quot;
 #include &quot;TeamDebugInfo.h&quot;
 #include &quot;Thread.h&quot;
+#include &quot;Tracing.h&quot;
 #include &quot;Type.h&quot;
 #include &quot;TypeComponentPath.h&quot;
 #include &quot;ValueLocation.h&quot;
@@ -495,78 +496,111 @@
 status_t
 GetStackFrameValueJob::_GetValue()
 {
-printf(&quot;GetStackFrameValueJob::_GetValue()\n&quot;);
-	if (fPath-&gt;CountComponents() &gt; 0)
-{
-printf(&quot;  -&gt; non-empty path\n&quot;);
-		return B_UNSUPPORTED;
-		// TODO: Implement!
-}
+	TRACE_LOCALS_ONLY(
+		TRACE_LOCALS(&quot;GetStackFrameValueJob::_GetValue(): %s &quot;,
+			fVariable-&gt;Name().String());
+		fPath-&gt;Dump();
+		TRACE_LOCALS(&quot;\n&quot;);
+	)
 
+	Type* type;
+	ValueLocation* location;
+	bool valueResolved;
+	status_t error = _ResolveTypeAndLocation(type, location, valueResolved);
+	if (error != B_OK || valueResolved) {
+		TRACE_LOCALS(&quot;  -&gt; error: %#lx, valueResolved: %d\n&quot;, error,
+			valueResolved);
+		return error;
+	}
+	Type* actualType = type;
+	Reference&lt;Type&gt; typeReference(type);
+	Reference&lt;Type&gt; actualTypeReference(actualType);
+	Reference&lt;ValueLocation&gt; locationReference(location);
+
 	// find out the type of the data we want to read
-	Type* type = fVariable-&gt;GetType();
 	type_code valueType = 0;
 	while (valueType == 0) {
 		switch (type-&gt;Kind()) {
 			case TYPE_PRIMITIVE:
 				valueType = dynamic_cast&lt;PrimitiveType*&gt;(type)-&gt;TypeConstant();
-printf(&quot;  TYPE_PRIMITIVE: '%c%c%c%c'\n&quot;, int(valueType &gt;&gt; 24),
-int(valueType &gt;&gt; 16), int(valueType &gt;&gt; 8), int(valueType));
-				if (valueType == 0)
-{
-printf(&quot;  -&gt; unknown type constant\n&quot;);
+
+				TRACE_LOCALS(&quot;  TYPE_PRIMITIVE: '%c%c%c%c'\n&quot;,
+					int(valueType &gt;&gt; 24), int(valueType &gt;&gt; 16),
+					int(valueType &gt;&gt; 8), int(valueType));
+
+				if (valueType == 0) {
+					TRACE_LOCALS(&quot;  -&gt; unknown type constant\n&quot;);
 					return B_BAD_VALUE;
-}
+				}
 				break;
 			case TYPE_MODIFIED:
-printf(&quot;  TYPE_MODIFIED\n&quot;);
+				TRACE_LOCALS(&quot;  TYPE_MODIFIED\n&quot;);
 				// ignore modifiers
 				type = dynamic_cast&lt;ModifiedType*&gt;(type)-&gt;BaseType();
 				break;
 			case TYPE_TYPEDEF:
-printf(&quot;  TYPE_TYPEDEF\n&quot;);
+				TRACE_LOCALS(&quot;  TYPE_TYPEDEF\n&quot;);
 				type = dynamic_cast&lt;TypedefType*&gt;(type)-&gt;BaseType();
 				break;
 			case TYPE_ADDRESS:
-printf(&quot;  TYPE_ADDRESS\n&quot;);
-				if (fArchitecture-&gt;AddressSize() == 4)
-{
+				TRACE_LOCALS(&quot;  TYPE_ADDRESS\n&quot;);
+				if (fArchitecture-&gt;AddressSize() == 4) {
 					valueType = B_UINT32_TYPE;
-printf(&quot;    -&gt; 32 bit\n&quot;);
-}
-				else
-{
+					TRACE_LOCALS(&quot;    -&gt; 32 bit\n&quot;);
+				} else {
 					valueType = B_UINT64_TYPE;
-printf(&quot;    -&gt; 64 bit\n&quot;);
-}
+					TRACE_LOCALS(&quot;    -&gt; 64 bit\n&quot;);
+				}
 				break;
 			case TYPE_COMPOUND:
 			case TYPE_ARRAY:
+				TRACE_LOCALS(&quot;  TYPE_COMPOUND/TYPE_ARRAY\n&quot;);
+				// We can't retrieve the actual value of the compound object/
+				// array (just of its components/elements), but to make the
+				// recursion work smoothly, we have to set the type and
+				// location at least.
+				return _SetValue(BVariant(), actualType, location);
 			default:
-printf(&quot;  TYPE_COMPOUND/TYPE_ARRAY/default\n&quot;);
-				// TODO:...
-printf(&quot;  -&gt; unsupported\n&quot;);
+				TRACE_LOCALS(&quot;  default -&gt; unsupported\n&quot;);
 				return B_UNSUPPORTED;
 		}
 	}
 
-	if (valueType == B_STRING_TYPE)
-{
-printf(&quot;  -&gt; B_STRING_TYPE: unsupported\n&quot;);
+	// update the reference in case the type has changed
+	typeReference.SetTo(type);
+
+	if (valueType == B_STRING_TYPE) {
+		TRACE_LOCALS(&quot;  -&gt; B_STRING_TYPE: unsupported\n&quot;);
 		return B_UNSUPPORTED;
 			// TODO:...
-}
+	}
 
 	// check whether we know the complete location
-	ValueLocation* location = fVariable-&gt;Location();
 	int32 count = location-&gt;CountPieces();
-printf(&quot;  location: %p, %ld pieces\n&quot;, location, count);
-	if (count == 0)
-{
-printf(&quot;  -&gt; no location\n&quot;);
+
+	TRACE_LOCALS(&quot;  location: %p, %ld pieces\n&quot;, location, count);
+
+	if (count == 0) {
+		TRACE_LOCALS(&quot;  -&gt; no location\n&quot;);
 		return B_ENTRY_NOT_FOUND;
-}
+	}
 
+	// If the source language implementation uses descriptors to point to
+	// objects, we need to resolve the object address to the data address.
+	if (count == 1) {
+		ValuePieceLocation piece = location-&gt;PieceAt(0);
+		if (piece.type == VALUE_PIECE_LOCATION_MEMORY) {
+			ValueLocation* dataLocation;
+			error = fStackFrame-&gt;DebugInfo()-&gt;ResolveObjectDataLocation(
+				fStackFrame, type, piece.address, dataLocation);
+			if (error != B_OK)
+				return error;
+
+			location = dataLocation;
+			locationReference.SetTo(location, true);
+		}
+	}
+
 	target_size_t totalSize = 0;
 	uint64 totalBitSize = 0;
 	for (int32 i = 0; i &lt; count; i++) {
@@ -583,26 +617,26 @@
 		totalSize += piece.size;
 		totalBitSize += piece.bitSize;
 	}
-printf(&quot;  -&gt; totalSize: %llu, totalBitSize: %llu\n&quot;, totalSize, totalBitSize);
 
-	if (totalSize == 0 &amp;&amp; totalBitSize == 0)
-{
-printf(&quot;  -&gt; no size\n&quot;);
+	TRACE_LOCALS(&quot;  -&gt; totalSize: %llu, totalBitSize: %llu\n&quot;, totalSize,
+		totalBitSize);
+
+	if (totalSize == 0 &amp;&amp; totalBitSize == 0) {
+		TRACE_LOCALS(&quot;  -&gt; no size\n&quot;);
 		return B_ENTRY_NOT_FOUND;
-}
+	}
 
-	if (totalSize &gt; 8 || totalSize + (totalBitSize + 7) / 8 &gt; 8)
-{
-printf(&quot;  -&gt; longer than 8 bytes: unsupported\n&quot;);
+	if (totalSize &gt; 8 || totalSize + (totalBitSize + 7) / 8 &gt; 8) {
+		TRACE_LOCALS(&quot;  -&gt; longer than 8 bytes: unsupported\n&quot;);
 		return B_UNSUPPORTED;
-}
+	}
 
-	if (totalSize + (totalBitSize + 7) / 8 &lt; BVariant::SizeOfType(valueType))
-{
-printf(&quot;  -&gt; too short for value type (%llu vs. %lu)\n&quot;,
-totalSize + (totalBitSize + 7) / 8, BVariant::SizeOfType(valueType));
+	if (totalSize + (totalBitSize + 7) / 8 &lt; BVariant::SizeOfType(valueType)) {
+		TRACE_LOCALS(&quot;  -&gt; too short for value type (%llu vs. %lu)\n&quot;,
+			totalSize + (totalBitSize + 7) / 8,
+			BVariant::SizeOfType(valueType));
 		return B_BAD_VALUE;
-}
+	}
 
 	// load the data
 	BitBuffer valueBuffer;
@@ -630,7 +664,10 @@
 			case VALUE_PIECE_LOCATION_MEMORY:
 			{
 				target_addr_t address = piece.address + bitOffset / 8;
-printf(&quot;  piece %ld: memory address: %#llx, bits: %lu\n&quot;, i, address, bitSize);
+
+				TRACE_LOCALS(&quot;  piece %ld: memory address: %#llx, bits: %lu\n&quot;,
+					i, address, bitSize);
+
 				bitOffset %= 8;
 				uint8 pieceBuffer[8];
 				ssize_t bytesRead = fDebuggerInterface-&gt;ReadMemory(address,
@@ -639,17 +676,22 @@
 					return bytesRead;
 				if ((uint32)bytesRead != bytesToRead)
 					return B_BAD_ADDRESS;
-printf(&quot;  -&gt; read: &quot;);
-for (ssize_t k = 0; k &lt; bytesRead; k++)
-printf(&quot;%02x&quot;, pieceBuffer[k]);
-printf(&quot;\n&quot;);
 
+				TRACE_LOCALS_ONLY(
+					TRACE_LOCALS(&quot;  -&gt; read: &quot;);
+					for (ssize_t k = 0; k &lt; bytesRead; k++)
+						TRACE_LOCALS(&quot;%02x&quot;, pieceBuffer[k]);
+					TRACE_LOCALS(&quot;\n&quot;);
+				)
+
 				valueBuffer.AddBits(pieceBuffer, bitSize, bitOffset);
 				break;
 			}
 			case VALUE_PIECE_LOCATION_REGISTER:
 			{
-printf(&quot;  piece %ld: register: %lu, bits: %lu\n&quot;, i, piece.reg, bitSize);
+				TRACE_LOCALS(&quot;  piece %ld: register: %lu, bits: %lu\n&quot;, i,
+					piece.reg, bitSize);
+
 				BVariant registerValue;
 				if (!fStackFrame-&gt;GetCpuState()-&gt;GetRegisterValue(
 						registers + piece.reg, registerValue)) {
@@ -675,28 +717,246 @@
 
 	// convert the bits into something we can work with
 	BVariant value;
-	status_t error = value.SetToTypedData(valueBuffer.Bytes(), valueType);
-	if (error != B_OK)
-{
-printf(&quot;  -&gt; failed to set typed data: %s\n&quot;, strerror(error));
+	error = value.SetToTypedData(valueBuffer.Bytes(), valueType);
+	if (error != B_OK) {
+		TRACE_LOCALS(&quot;  -&gt; failed to set typed data: %s\n&quot;, strerror(error));
 		return error;
-}
+	}
 
 	if (!fArchitecture-&gt;IsHostEndian())
 		value.SwapEndianess();
 
+	return _SetValue(value, actualType, location);
+}
+
+
+status_t
+GetStackFrameValueJob::_SetValue(const BVariant&amp; value, Type* type,
+	ValueLocation* location)
+{
 	// set the value
 	AutoLocker&lt;Team&gt; locker(fThread-&gt;GetTeam());
 
-	StackFrameValues* values = fStackFrame-&gt;Values();
+	status_t error = fStackFrame-&gt;Values()-&gt;SetValue(fVariable-&gt;ID(), fPath,
+		value);
+	if (error != B_OK) {
+		TRACE_LOCALS(&quot;  -&gt; failed to set value: %s\n&quot;, strerror(error));
+		return error;
+	}
 
-	error = values-&gt;SetValue(fVariable-&gt;ID(), fPath, value);
-	if (error != B_OK)
+	fStackFrame-&gt;ValueInfos()-&gt;SetInfo(fVariable-&gt;ID(), fPath, type, location);
+
+	fStackFrame-&gt;NotifyValueRetrieved(fVariable, fPath);
+	return B_OK;
+}
+
+
+status_t
+GetStackFrameValueJob::_ResolveTypeAndLocation(Type*&amp; _type,
+	ValueLocation*&amp; _location, bool&amp; _valueResolved)
 {
-printf(&quot;  -&gt; failed to set value: %s\n&quot;, strerror(error));
+	if (fPath-&gt;CountComponents() == 0) {
+		fVariable-&gt;GetType()-&gt;AcquireReference();
+		fVariable-&gt;Location()-&gt;AcquireReference();
+		_type = fVariable-&gt;GetType();
+		_location = fVariable-&gt;Location();
+		_valueResolved = false;
+		return B_OK;
+	}
+
+	// get the parent value
+	int32 componentCount = fPath-&gt;CountComponents();
+	TypeComponentPath* parentPath = fPath-&gt;CreateSubPath(componentCount - 1);
+	if (parentPath == NULL)
+		return B_NO_MEMORY;
+	Reference&lt;TypeComponentPath&gt; parentPathReference(parentPath, true);
+
+	Type* parentType;
+	ValueLocation* parentLocation;
+	BVariant parentValue;
+	status_t error = _GetTypeLocationAndValue(parentPath, parentType,
+		parentLocation, parentValue);
+	if (error != B_OK) {
+		TRACE_LOCALS(&quot;GetStackFrameValueJob::_ResolveTypeAndLocation(): &quot;
+			&quot;_GetTypeLocationAndValue() failed: %s\n&quot;, strerror(error));
 		return error;
+	}
+	Reference&lt;Type&gt; parentTypeReference(parentType, true);
+	Reference&lt;ValueLocation&gt; parentLocationReference(parentLocation, true);
+
+	// resolve the last component
+	TypeComponent component = fPath-&gt;ComponentAt(componentCount - 1);
+	switch (component.typeKind) {
+		case TYPE_PRIMITIVE:
+			// cannot happen
+			TRACE_LOCALS(&quot;GetStackFrameValueJob::_ResolveTypeAndLocation(): &quot;
+				&quot;TYPE_PRIMITIVE subcomponent!\n&quot;);
+			return B_BAD_VALUE;
+		case TYPE_COMPOUND:
+		{
+			CompoundType* compoundType
+				= dynamic_cast&lt;CompoundType*&gt;(parentType);
+
+			// base type
+			if (component.componentKind == TYPE_COMPONENT_BASE_TYPE) {
+				BaseType* baseType = compoundType-&gt;BaseTypeAt(
+					component.index);
+				if (baseType == NULL)
+					return B_BAD_VALUE;
+
+				// The parent's location refers to the location of the complete
+				// object. We want to extract the location of a member.
+				ValueLocation* location;
+				error = fStackFrame-&gt;DebugInfo()-&gt;ResolveBaseTypeLocation(
+					fStackFrame, parentType, baseType, *parentLocation,
+					location);
+				if (error != B_OK) {
+					TRACE_LOCALS(&quot;GetStackFrameValueJob::&quot;
+						&quot;_ResolveTypeAndLocation(): TYPE_COMPOUND: &quot;
+						&quot;ResolveBaseTypeLocation() failed: %s\n&quot;,
+						strerror(error));
+					return error;
+				}
+
+				baseType-&gt;GetType()-&gt;AcquireReference();
+				_type = baseType-&gt;GetType();
+				_location = location;
+				_valueResolved = false;
+
+				return B_OK;
+			}
+
+			// data member
+			if (component.componentKind == TYPE_COMPONENT_DATA_MEMBER) {
+				DataMember* dataMember = compoundType-&gt;DataMemberAt(
+					component.index);
+				if (dataMember == NULL)
+					return B_BAD_VALUE;
+
+				// The parent's location refers to the location of the complete
+				// object. We want to extract the location of a member.
+				ValueLocation* location;
+				error = fStackFrame-&gt;DebugInfo()-&gt;ResolveDataMemberLocation(
+					fStackFrame, parentType, dataMember, *parentLocation,
+					location);
+				if (error != B_OK) {
+					TRACE_LOCALS(&quot;GetStackFrameValueJob::&quot;
+						&quot;_ResolveTypeAndLocation(): TYPE_COMPOUND: &quot;
+						&quot;ResolveDataMemberLocation() failed: %s\n&quot;,
+						strerror(error));
+					return error;
+				}
+
+				dataMember-&gt;GetType()-&gt;AcquireReference();
+				_type = dataMember-&gt;GetType();
+				_location = location;
+				_valueResolved = false;
+
+				return B_OK;
+			}
+
+			return B_UNSUPPORTED;
+		}
+		case TYPE_MODIFIED:
+		case TYPE_TYPEDEF:
+		{
+			Type* type = component.typeKind == TYPE_MODIFIED
+				? dynamic_cast&lt;ModifiedType*&gt;(parentType)-&gt;BaseType()
+				: dynamic_cast&lt;TypedefType*&gt;(parentType)-&gt;BaseType();
+			_valueResolved = true;
+			return _SetValue(parentValue, type, parentLocation);
+		}
+		case TYPE_ADDRESS:
+		{
+			// The parent's value is an address pointing to this component.
+			// resolve the location
+			Type* type = dynamic_cast&lt;AddressType*&gt;(parentType)-&gt;BaseType();
+			ValueLocation* location;
+			error = fStackFrame-&gt;DebugInfo()-&gt;ResolveObjectDataLocation(
+				fStackFrame, type, parentValue.ToUInt64(), location);
+			if (error != B_OK) {
+				TRACE_LOCALS(&quot;GetStackFrameValueJob::&quot;
+					&quot;_ResolveTypeAndLocation(): TYPE_ADDRESS: &quot;
+					&quot;ResolveObjectDataLocation() failed: %s\n&quot;,
+					strerror(error));
+				return error;
+			}
+
+			type-&gt;AcquireReference();
+			_type = type;
+			_location = location;
+			_valueResolved = false;
+
+			return B_OK;
+		}
+		case TYPE_ARRAY:
+			// TODO:...
+		default:
+			return B_UNSUPPORTED;
+	}
 }
 
-	fStackFrame-&gt;NotifyValueRetrieved(fVariable, fPath);
+
+status_t
+GetStackFrameValueJob::_GetTypeLocationAndValue(TypeComponentPath* parentPath,
+	Type*&amp; _parentType, ValueLocation*&amp; _parentLocation, BVariant&amp; _parentValue)
+{
+	AutoLocker&lt;Team&gt; teamLocker(fThread-&gt;GetTeam());
+
+	// If there's already a value for the parent path, we're done.
+	StackFrameValues* values = fStackFrame-&gt;Values();
+	StackFrameValueInfos* valueInfos = fStackFrame-&gt;ValueInfos();
+	if (values-&gt;HasValue(fVariable-&gt;ID(), parentPath)) {
+		if (!values-&gt;GetValue(fVariable-&gt;ID(), parentPath, _parentValue)
+			|| !valueInfos-&gt;GetInfo(fVariable-&gt;ID(), parentPath, &amp;_parentType,
+					&amp;_parentLocation)) {
+			return B_ERROR;
+		}
+
+		return B_OK;
+	}
+
+	// check whether a job is already in progress
+	AutoLocker&lt;Worker&gt; workerLocker(GetWorker());
+	GetStackFrameValueJobKey jobKey(fStackFrame, fVariable, parentPath);
+	if (GetWorker()-&gt;GetJob(jobKey) == NULL) {
+		workerLocker.Unlock();
+
+		// schedule the job
+		status_t error = GetWorker()-&gt;ScheduleJob(
+			new(std::nothrow) GetStackFrameValueJob(fDebuggerInterface,
+				fArchitecture, fThread, fStackFrame, fVariable, parentPath));
+		if (error != B_OK) {
+			// scheduling failed -- set the value to invalid
+			values-&gt;SetValue(fVariable-&gt;ID(), parentPath, BVariant());
+			return error;
+		}
+	}
+
+	// wait for the job to finish
+	workerLocker.Unlock();
+	teamLocker.Unlock();
+
+	switch (WaitFor(jobKey)) {
+		case JOB_DEPENDENCY_SUCCEEDED:
+		case JOB_DEPENDENCY_NOT_FOUND:
+			// &quot;Not found&quot; can happen due to a race condition between
+			// unlocking the worker and starting to wait.
+			break;
+		case JOB_DEPENDENCY_FAILED:
+		case JOB_DEPENDENCY_ABORTED:
+		default:
+			return B_ERROR;
+	}
+
+	teamLocker.Lock();
+
+	// now there should be a value for the path
+	if (!values-&gt;GetValue(fVariable-&gt;ID(), parentPath, _parentValue)
+		|| !valueInfos-&gt;GetInfo(fVariable-&gt;ID(), parentPath, &amp;_parentType,
+				&amp;_parentLocation)) {
+		return B_ERROR;
+	}
+
 	return B_OK;
 }

Modified: haiku/trunk/src/apps/debugger/Jobs.h
===================================================================
--- haiku/trunk/src/apps/debugger/Jobs.h	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/src/apps/debugger/Jobs.h	2009-09-21 04:39:40 UTC (rev 33217)
@@ -11,6 +11,7 @@
 
 
 class Architecture;
+class BVariant;
 class CpuState;
 class DebuggerInterface;
 class Function;
@@ -20,7 +21,9 @@
 class StackFrameValues;
 class Team;
 class Thread;
+class Type;
 class TypeComponentPath;
+class ValueLocation;
 class Variable;
 
 
@@ -176,6 +179,18 @@
 
 private:
 			status_t			_GetValue();
+			status_t			_SetValue(const BVariant&amp; value, Type* type,
+									ValueLocation* location);
+			status_t			_ResolveTypeAndLocation(Type*&amp; _type,
+									ValueLocation*&amp; _location,
+									bool&amp; _valueResolved);
+									// returns references
+			status_t			_GetTypeLocationAndValue(
+									TypeComponentPath* parentPath,
+									Type*&amp; _parentType,
+									ValueLocation*&amp; _parentLocation,
+									BVariant&amp; _parentValue);
+									// returns references
 
 private:
 			GetStackFrameValueJobKey fKey;

Modified: haiku/trunk/src/apps/debugger/TeamDebugger.cpp
===================================================================
--- haiku/trunk/src/apps/debugger/TeamDebugger.cpp	2009-09-21 04:34:55 UTC (rev 33216)
+++ haiku/trunk/src/apps/debugger/TeamDebugger.cpp	2009-09-21 04:39:40 UTC (rev 33217)
@@ -38,6 +38,7 @@
 #include &quot;SymbolInfo.h&quot;
 #include &quot;TeamDebugInfo.h&quot;
 #include &quot;TeamSettings.h&quot;
+#include &quot;Tracing.h&quot;
 #include &quot;Variable.h&quot;
 
 // #pragma mark - ImageHandler
@@ -360,7 +361,7 @@
 		fTeamWindow = TeamWindow::Create(fTeam, this);
 	} catch (...) {
 		// TODO: Notify the user!
-		fprintf(stderr, &quot;Error: Failed to create team window!\n&quot;);
+		ERROR(&quot;Error: Failed to create team window!\n&quot;);
 		return B_NO_MEMORY;
 	}
 
@@ -645,21 +646,21 @@
 void
 TeamDebugger::JobDone(Job* job)
 {
-printf(&quot;TeamDebugger::JobDone(%p)\n&quot;, job);
+	TRACE_JOBS(&quot;TeamDebugger::JobDone(%p)\n&quot;, job);
 }
 
 
 void
 TeamDebugger::JobFailed(Job* job)
 {
-printf(&quot;TeamDebugger::JobFailed(%p)\n&quot;, job);
+	TRACE_JOBS(&quot;TeamDebugger::JobFailed(%p)\n&quot;, job);
 }
 
 
 void
 TeamDebugger::JobAborted(Job* job)
 {
-printf(&quot;TeamDebugger::JobAborted(%p)\n&quot;, job);
+	TRACE_JOBS(&quot;TeamDebugger::JobAborted(%p)\n&quot;, job);
 	// TODO: For a stack frame source loader thread we should reset the
 	// loading state! Asynchronously due to locking order.
 }
@@ -721,8 +722,8 @@
 
 
 		if (event-&gt;Team() != fTeamID) {
-printf(&quot;TeamDebugger for team %ld: received event from team %ld!\n&quot;, fTeamID,
-event-&gt;Team());
+			TRACE_EVENTS(&quot;TeamDebugger for team %ld: received event from team &quot;
+				&quot;%ld!\n&quot;, fTeamID, event-&gt;Team());
 			continue;
 		}
 
@@ -741,7 +742,9 @@
 void
 TeamDebugger::_HandleDebuggerMessage(DebugEvent* event)
 {
-printf(&quot;TeamDebugger::_HandleDebuggerMessage(): %d\n&quot;, event-&gt;EventType());
+	TRACE_EVENTS(&quot;TeamDebugger::_HandleDebuggerMessage(): %d\n&quot;,
+		event-&gt;EventType());
+
 	bool handled = false;
 
 	ThreadHandler* handler = _GetThreadHandler(event-&gt;Thread());
@@ -749,42 +752,54 @@
 
 	switch (event-&gt;EventType()) {
 		case B_DEBUGGER_MESSAGE_THREAD_DEBUGGED:
-printf(&quot;B_DEBUGGER_MESSAGE_THREAD_DEBUGGED: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_THREAD_DEBUGGED: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleThreadDebugged(
 					dynamic_cast&lt;ThreadDebuggedEvent*&gt;(event));
 			}
 			break;
 		case B_DEBUGGER_MESSAGE_DEBUGGER_CALL:
-printf(&quot;B_DEBUGGER_MESSAGE_DEBUGGER_CALL: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_DEBUGGER_CALL: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleDebuggerCall(
 					dynamic_cast&lt;DebuggerCallEvent*&gt;(event));
 			}
 			break;
 		case B_DEBUGGER_MESSAGE_BREAKPOINT_HIT:
-printf(&quot;B_DEBUGGER_MESSAGE_BREAKPOINT_HIT: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_BREAKPOINT_HIT: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleBreakpointHit(
 					dynamic_cast&lt;BreakpointHitEvent*&gt;(event));
 			}
 			break;
 		case B_DEBUGGER_MESSAGE_WATCHPOINT_HIT:
-printf(&quot;B_DEBUGGER_MESSAGE_WATCHPOINT_HIT: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_WATCHPOINT_HIT: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleWatchpointHit(
 					dynamic_cast&lt;WatchpointHitEvent*&gt;(event));
 			}
 			break;
 		case B_DEBUGGER_MESSAGE_SINGLE_STEP:
-printf(&quot;B_DEBUGGER_MESSAGE_SINGLE_STEP: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_SINGLE_STEP: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleSingleStep(
 					dynamic_cast&lt;SingleStepEvent*&gt;(event));
 			}
 			break;
 		case B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED:
-printf(&quot;B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED: thread: %ld\n&quot;, event-&gt;Thread());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_EXCEPTION_OCCURRED: thread: %ld\n&quot;,
+				event-&gt;Thread());
+
 			if (handler != NULL) {
 				handled = handler-&gt;HandleExceptionOccurred(
 					dynamic_cast&lt;ExceptionOccurredEvent*&gt;(event));
@@ -795,10 +810,12 @@
 //			break;
 		case B_DEBUGGER_MESSAGE_TEAM_DELETED:
 			// TODO: Handle!
-printf(&quot;B_DEBUGGER_MESSAGE_TEAM_DELETED: team: %ld\n&quot;, event-&gt;Team());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_TEAM_DELETED: team: %ld\n&quot;,
+				event-&gt;Team());
 			break;
 		case B_DEBUGGER_MESSAGE_TEAM_EXEC:
-printf(&quot;B_DEBUGGER_MESSAGE_TEAM_EXEC: team: %ld\n&quot;, event-&gt;Team());
+			TRACE_EVENTS(&quot;B_DEBUGGER_MESSAGE_TEAM_EXEC: team: %ld\n&quot;,
+				event-&gt;Team());
 			// TODO: Handle!
 			break;
 		case B_DEBUGGER_MESSAGE_THREAD_CREATED:
@@ -825,7 +842,7 @@
 			// not interested
 			break;
 		default:
-			printf(&quot;TeamDebugger for team %ld: unknown event type: &quot;
+			WARNING(&quot;TeamDebugger for team %ld: unknown event type: &quot;
 				&quot;%d\n&quot;, fTeamID, event-&gt;EventType());
 			break;
 	}
@@ -926,7 +943,7 @@
 void
 TeamDebugger::_HandleImageFileChanged(image_id imageID)
 {
-printf(&quot;TeamDebugger::_HandleImageFileChanged(%ld)\n&quot;, imageID);
+	TRACE_IMAGES(&quot;TeamDebugger::_HandleImageFileChanged(%ld)\n&quot;, imageID);
 // TODO: Reload the debug info!
 }
 
@@ -934,7 +951,9 @@
 void
 TeamDebugger::_HandleSetUserBreakpoint(target_addr_t address, bool enabled)
 {
-printf(&quot;TeamDebugger::_HandleSetUserBreakpoint(%#llx, %d)\n&quot;, address, enabled);
+	TRACE_CONTROL(&quot;TeamDebugger::_HandleSetUserBreakpoint(%#llx, %d)\n&quot;,
+		address, enabled);
+
 	// check whether there already is a breakpoint
 	AutoLocker&lt; ::Team&gt; locker(fTeam);
 
@@ -945,25 +964,33 @@
 	Reference&lt;UserBreakpoint&gt; userBreakpointReference(userBreakpoint);
 
 	if (userBreakpoint == NULL) {
-printf(&quot;  no breakpoint yet\n&quot;);
+		TRACE_CONTROL(&quot;  no breakpoint yet\n&quot;);
+
 		// get the function at the address
 		Image* image = fTeam-&gt;ImageByAddress(address);
-printf(&quot;  image: %p\n&quot;, image);
+
+		TRACE_CONTROL(&quot;  image: %p\n&quot;, image);
+
 		if (image == NULL)
 			return;
 		ImageDebugInfo* imageDebugInfo = image-&gt;GetImageDebugInfo();
-printf(&quot;  image debug info: %p\n&quot;, imageDebugInfo);
+
+		TRACE_CONTROL(&quot;  image debug info: %p\n&quot;, imageDebugInfo);
+
 		if (imageDebugInfo == NULL)
 			return;
 			// TODO: Handle this case by loading the debug info, if possible!
 		FunctionInstance* functionInstance
 			= imageDebugInfo-&gt;FunctionAtAddress(address);
-printf(&quot;  function instance: %p\n&quot;, functionInstance);
+

[... truncated: 6075 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020741.html">[Haiku-commits] r33216 - haiku/trunk/src/apps/debugger
</A></li>
	<LI>Next message: <A HREF="020745.html">[Haiku-commits] r33218 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20742">[ date ]</a>
              <a href="thread.html#20742">[ thread ]</a>
              <a href="subject.html#20742">[ subject ]</a>
              <a href="author.html#20742">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
