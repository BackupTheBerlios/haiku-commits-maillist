<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33343%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/theora%3A%20.%20libtheora%0A%09libtheora/theora%20libtheora/x86&In-Reply-To=%3C200909290038.n8T0ctRN016372%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020977.html">
   <LINK REL="Next"  HREF="020979.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86</H1>
    <B>phoudoin at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33343%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/theora%3A%20.%20libtheora%0A%09libtheora/theora%20libtheora/x86&In-Reply-To=%3C200909290038.n8T0ctRN016372%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86">phoudoin at mail.berlios.de
       </A><BR>
    <I>Tue Sep 29 02:38:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020977.html">[Haiku-commits] r33342 -	haiku/trunk/src/add-ons/kernel/drivers/network/usb_asix
</A></li>
        <LI>Next message: <A HREF="020979.html">[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20978">[ date ]</a>
              <a href="thread.html#20978">[ thread ]</a>
              <a href="subject.html#20978">[ subject ]</a>
              <a href="author.html#20978">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: phoudoin
Date: 2009-09-29 02:37:35 +0200 (Tue, 29 Sep 2009)
New Revision: 33343
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33343&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33343&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/theora/Jamfile
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/apiwrapper.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/apiwrapper.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/bitpack.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/bitpack.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/cpu.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/cpu.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decapiwrapper.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decinfo.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decint.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dequant.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dequant.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encapiwrapper.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encfrag.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encinfo.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encint.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/enquant.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/enquant.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/fdct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/fragment.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffdec.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffdec.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffenc.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffenc.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/info.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/internal.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/internal.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mathops.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mathops.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mcenc.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/modedec.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/ocintrin.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/rate.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/state.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/codec.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theoradec.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theoraenc.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/tokenize.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxencfrag.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfdct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfrag.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfrag.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxidct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxloop.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxstate.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/sse2fdct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86enc.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86enc.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86int.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86state.c
Removed:
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/block_inline.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/blockmap.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/comment.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct_decode.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct_encode.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encoder_internal.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encoder_lookup.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/frarray.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/frinit.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffman.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/hufftables.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mcomp.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/misc_common.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pb.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pp.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pp.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant_lookup.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/reconstruct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/scan.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/toplevel.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/toplevel_lookup.h
Modified:
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decode.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encode.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffman.h
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/idct.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant.c
   haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theora.h
   haiku/trunk/src/add-ons/media/plugins/theora/theoraCodecPlugin.cpp
   haiku/trunk/src/add-ons/media/plugins/theora/theoraCodecPlugin.h
Log:
Update theora to latest v1.1, which improve performance and quality.
Untested yet...


Added: haiku/trunk/src/add-ons/media/plugins/theora/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/theora/Jamfile	2009-09-28 23:02:30 UTC (rev 33342)
+++ haiku/trunk/src/add-ons/media/plugins/theora/Jamfile	2009-09-29 00:37:35 UTC (rev 33343)
@@ -0,0 +1,16 @@
+SubDir HAIKU_TOP src add-ons media plugins theora ;
+
+SetSubDirSupportedPlatformsBeOSCompatible ;
+
+UsePrivateHeaders media shared ;
+
+SubDirSysHdrs $(SUBDIR) libtheora ;
+SubDirHdrs $(SUBDIR) .. ogg ;
+SubDirSysHdrs $(SUBDIR) .. ogg libogg ;
+
+Addon theora :
+ 	theoraCodecPlugin.cpp
+	: libtheora.a libogg.a be libmedia.so $(TARGET_LIBSUPC++)
+;
+
+SubInclude HAIKU_TOP src add-ons media plugins theora libtheora ;

Modified: haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile	2009-09-28 23:02:30 UTC (rev 33342)
+++ haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile	2009-09-29 00:37:35 UTC (rev 33343)
@@ -1,28 +1,38 @@
 SubDir HAIKU_TOP src add-ons media plugins theora libtheora ;
 
-SubDirHdrs [ FDirName $(SUBDIR) .. .. ogg libogg ] ;
+SubDirSysHdrs $(SUBDIR) ;
+SubDirHdrs $(SUBDIR) .. .. ogg ;
+SubDirSysHdrs $(SUBDIR) .. .. ogg libogg ;
 
-SubDirCcFlags -DPACKAGE=\\\&quot;libtheora\\\&quot; -DVERSION=\\\&quot;0.0\\\&quot; ;
+SubDirCcFlags -DPACKAGE=\\\&quot;libtheora\\\&quot; -DVERSION=\\\&quot;1.1.0\\\&quot; ;
 SubDirCcFlags -D_REENTRANT -DPIC -DTRUE=true ;
 
+local arch_sources ;
+if $(TARGET_ARCH) = x86 {
+	arch_sources = 
+		mmxidct.c
+		mmxfrag.c
+		mmxstate.c
+		x86state.c
+		;
+
+	SEARCH_SOURCE += [ FDirName $(SUBDIR) x86 ] ;
+}
+
 StaticLibrary libtheora.a :
-	blockmap.c
-	comment.c
-	dct.c
-	dct_decode.c
-	dct_encode.c
+	apiwrapper.c
+	bitpack.c
+	decapiwrapper.c
+	decinfo.c
 	decode.c
-	encode.c
-	frarray.c
-	frinit.c
-	huffman.c
+	dequant.c
+	fragment.c
+	huffdec.c
 	idct.c
-	mcomp.c
-	misc_common.c
-	pb.c
-	pp.c
+	info.c
+	internal.c
 	quant.c
-	reconstruct.c
-	scan.c
-	toplevel.c
+	state.c
+	
+	$(arch_sources)	
 ;

Added: haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c	2009-09-28 23:02:30 UTC (rev 33342)
+++ haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c	2009-09-29 00:37:35 UTC (rev 33343)
@@ -0,0 +1,2709 @@
+/********************************************************************
+ *                                                                  *
+ * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE.   *
+ * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
+ * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
+ * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
+ *                                                                  *
+ * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2009                *
+ * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A>                  *
+ *                                                                  *
+ ********************************************************************
+
+  function: mode selection code
+  last mod: $Id$
+
+ ********************************************************************/
+#include &lt;limits.h&gt;
+#include &lt;string.h&gt;
+#include &quot;encint.h&quot;
+#include &quot;modedec.h&quot;
+
+
+
+typedef struct oc_fr_state           oc_fr_state;
+typedef struct oc_qii_state          oc_qii_state;
+typedef struct oc_enc_pipeline_state oc_enc_pipeline_state;
+typedef struct oc_rd_metric          oc_rd_metric;
+typedef struct oc_mode_choice        oc_mode_choice;
+
+
+
+/*There are 8 possible schemes used to encode macro block modes.
+  Schemes 0-6 use a maximally-skewed Huffman code to code each of the modes.
+  The same set of Huffman codes is used for each of these 7 schemes, but the
+   mode assigned to each codeword varies.
+  Scheme 0 writes a custom mapping from codeword to MB mode to the bitstream,
+   while schemes 1-6 have a fixed mapping.
+  Scheme 7 just encodes each mode directly in 3 bits.*/
+
+/*The mode orderings for the various mode coding schemes.
+  Scheme 0 uses a custom alphabet, which is not stored in this table.
+  This is the inverse of the equivalent table OC_MODE_ALPHABETS in the
+   decoder.*/
+static const unsigned char OC_MODE_RANKS[7][OC_NMODES]={
+  /*Last MV dominates.*/ 
+  /*L P M N I G GM 4*/
+  {3,4,2,0,1,5,6,7},
+  /*L P N M I G GM 4*/
+  {2,4,3,0,1,5,6,7},
+  /*L M P N I G GM 4*/
+  {3,4,1,0,2,5,6,7},
+  /*L M N P I G GM 4*/
+  {2,4,1,0,3,5,6,7},
+  /*No MV dominates.*/
+  /*N L P M I G GM 4*/
+  {0,4,3,1,2,5,6,7},
+  /*N G L P M I GM 4*/
+  {0,5,4,2,3,1,6,7},
+  /*Default ordering.*/
+  /*N I M L P G GM 4*/
+  {0,1,2,3,4,5,6,7}
+};
+
+
+
+/*Initialize the mode scheme chooser.
+  This need only be called once per encoder.*/
+void oc_mode_scheme_chooser_init(oc_mode_scheme_chooser *_chooser){
+  int si;
+  _chooser-&gt;mode_ranks[0]=_chooser-&gt;scheme0_ranks;
+  for(si=1;si&lt;8;si++)_chooser-&gt;mode_ranks[si]=OC_MODE_RANKS[si-1];
+}
+
+/*Reset the mode scheme chooser.
+  This needs to be called once for each frame, including the first.*/
+static void oc_mode_scheme_chooser_reset(oc_mode_scheme_chooser *_chooser){
+  int si;
+  memset(_chooser-&gt;mode_counts,0,OC_NMODES*sizeof(*_chooser-&gt;mode_counts));
+  /*Scheme 0 starts with 24 bits to store the mode list in.*/
+  _chooser-&gt;scheme_bits[0]=24;
+  memset(_chooser-&gt;scheme_bits+1,0,7*sizeof(*_chooser-&gt;scheme_bits));
+  for(si=0;si&lt;8;si++){
+    /*Scheme 7 should always start first, and scheme 0 should always start
+       last.*/
+    _chooser-&gt;scheme_list[si]=7-si;
+    _chooser-&gt;scheme0_list[si]=_chooser-&gt;scheme0_ranks[si]=si;
+  }
+}
+
+
+/*This is the real purpose of this data structure: not actually selecting a
+   mode scheme, but estimating the cost of coding a given mode given all the
+   modes selected so far.
+  This is done via opportunity cost: the cost is defined as the number of bits
+   required to encode all the modes selected so far including the current one
+   using the best possible scheme, minus the number of bits required to encode
+   all the modes selected so far not including the current one using the best
+   possible scheme.
+  The computational expense of doing this probably makes it overkill.
+  Just be happy we take a greedy approach instead of trying to solve the
+   global mode-selection problem (which is NP-hard).
+  _mb_mode: The mode to determine the cost of.
+  Return: The number of bits required to code this mode.*/
+static int oc_mode_scheme_chooser_cost(oc_mode_scheme_chooser *_chooser,
+ int _mb_mode){
+  int scheme0;
+  int scheme1;
+  int best_bits;
+  int mode_bits;
+  int si;
+  int scheme_bits;
+  scheme0=_chooser-&gt;scheme_list[0];
+  scheme1=_chooser-&gt;scheme_list[1];
+  best_bits=_chooser-&gt;scheme_bits[scheme0];
+  mode_bits=OC_MODE_BITS[scheme0+1&gt;&gt;3][_chooser-&gt;mode_ranks[scheme0][_mb_mode]];
+  /*Typical case: If the difference between the best scheme and the next best
+     is greater than 6 bits, then adding just one mode cannot change which
+     scheme we use.*/
+  if(_chooser-&gt;scheme_bits[scheme1]-best_bits&gt;6)return mode_bits;
+  /*Otherwise, check to see if adding this mode selects a different scheme as
+     the best.*/
+  si=1;
+  best_bits+=mode_bits;
+  do{
+    /*For any scheme except 0, we can just use the bit cost of the mode's rank
+       in that scheme.*/
+    if(scheme1!=0){
+      scheme_bits=_chooser-&gt;scheme_bits[scheme1]+
+       OC_MODE_BITS[scheme1+1&gt;&gt;3][_chooser-&gt;mode_ranks[scheme1][_mb_mode]];
+    }
+    else{
+      int ri;
+      /*For scheme 0, incrementing the mode count could potentially change the
+         mode's rank.
+        Find the index where the mode would be moved to in the optimal list,
+         and use its bit cost instead of the one for the mode's current
+         position in the list.*/
+      /*We don't recompute scheme bits; this is computing opportunity cost, not
+         an update.*/
+      for(ri=_chooser-&gt;scheme0_ranks[_mb_mode];ri&gt;0&amp;&amp;
+       _chooser-&gt;mode_counts[_mb_mode]&gt;=
+       _chooser-&gt;mode_counts[_chooser-&gt;scheme0_list[ri-1]];ri--);
+      scheme_bits=_chooser-&gt;scheme_bits[0]+OC_MODE_BITS[0][ri];
+    }
+    if(scheme_bits&lt;best_bits)best_bits=scheme_bits;
+    if(++si&gt;=8)break;
+    scheme1=_chooser-&gt;scheme_list[si];
+  }
+  while(_chooser-&gt;scheme_bits[scheme1]-_chooser-&gt;scheme_bits[scheme0]&lt;=6);
+  return best_bits-_chooser-&gt;scheme_bits[scheme0];
+}
+
+/*Incrementally update the mode counts and per-scheme bit counts and re-order
+   the scheme lists once a mode has been selected.
+  _mb_mode: The mode that was chosen.*/
+static void oc_mode_scheme_chooser_update(oc_mode_scheme_chooser *_chooser,
+ int _mb_mode){
+  int ri;
+  int si;
+  _chooser-&gt;mode_counts[_mb_mode]++;
+  /*Re-order the scheme0 mode list if necessary.*/
+  for(ri=_chooser-&gt;scheme0_ranks[_mb_mode];ri&gt;0;ri--){
+    int pmode;
+    pmode=_chooser-&gt;scheme0_list[ri-1];
+    if(_chooser-&gt;mode_counts[pmode]&gt;=_chooser-&gt;mode_counts[_mb_mode])break;
+    /*Reorder the mode ranking.*/
+    _chooser-&gt;scheme0_ranks[pmode]++;
+    _chooser-&gt;scheme0_list[ri]=pmode;
+  }
+  _chooser-&gt;scheme0_ranks[_mb_mode]=ri;
+  _chooser-&gt;scheme0_list[ri]=_mb_mode;
+  /*Now add the bit cost for the mode to each scheme.*/
+  for(si=0;si&lt;8;si++){
+    _chooser-&gt;scheme_bits[si]+=
+     OC_MODE_BITS[si+1&gt;&gt;3][_chooser-&gt;mode_ranks[si][_mb_mode]];
+  }
+  /*Finally, re-order the list of schemes.*/
+  for(si=1;si&lt;8;si++){
+    int sj;
+    int scheme0;
+    int bits0;
+    sj=si;
+    scheme0=_chooser-&gt;scheme_list[si];
+    bits0=_chooser-&gt;scheme_bits[scheme0];
+    do{
+      int scheme1;
+      scheme1=_chooser-&gt;scheme_list[sj-1];
+      if(bits0&gt;=_chooser-&gt;scheme_bits[scheme1])break;
+      _chooser-&gt;scheme_list[sj]=scheme1;
+    }
+    while(--sj&gt;0);
+    _chooser-&gt;scheme_list[sj]=scheme0;
+  }
+}
+
+
+
+/*The number of bits required to encode a super block run.
+  _run_count: The desired run count; must be positive and less than 4130.*/
+static int oc_sb_run_bits(int _run_count){
+  int i;
+  for(i=0;_run_count&gt;=OC_SB_RUN_VAL_MIN[i+1];i++);
+  return OC_SB_RUN_CODE_NBITS[i];
+}
+
+/*The number of bits required to encode a block run.
+  _run_count: The desired run count; must be positive and less than 30.*/
+static int oc_block_run_bits(int _run_count){
+  return OC_BLOCK_RUN_CODE_NBITS[_run_count-1];
+}
+
+
+
+/*State to track coded block flags and their bit cost.*/
+struct oc_fr_state{
+  ptrdiff_t  bits;
+  unsigned   sb_partial_count:16;
+  unsigned   sb_full_count:16;
+  unsigned   b_coded_count_prev:8;
+  unsigned   b_coded_count:8;
+  unsigned   b_count:8;
+  signed int sb_partial:2;
+  signed int sb_full:2;
+  signed int b_coded_prev:2;
+  signed int b_coded:2;
+};
+
+
+
+static void oc_fr_state_init(oc_fr_state *_fr){
+  _fr-&gt;bits=0;
+  _fr-&gt;sb_partial_count=0;
+  _fr-&gt;sb_full_count=0;
+  _fr-&gt;b_coded_count_prev=0;
+  _fr-&gt;b_coded_count=0;
+  _fr-&gt;b_count=0;
+  _fr-&gt;sb_partial=-1;
+  _fr-&gt;sb_full=-1;
+  _fr-&gt;b_coded_prev=-1;
+  _fr-&gt;b_coded=-1;
+}
+
+
+static void oc_fr_state_advance_sb(oc_fr_state *_fr,
+ int _sb_partial,int _sb_full){
+  ptrdiff_t bits;
+  int       sb_partial_count;
+  int       sb_full_count;
+  bits=_fr-&gt;bits;
+  /*Extend the sb_partial run, or start a new one.*/
+  sb_partial_count=_fr-&gt;sb_partial;
+  if(_fr-&gt;sb_partial==_sb_partial){
+    if(sb_partial_count&gt;=4129){
+      bits++;
+      sb_partial_count=0;
+    }
+    else bits-=oc_sb_run_bits(sb_partial_count);
+  }
+  else sb_partial_count=0;
+  sb_partial_count++;
+  bits+=oc_sb_run_bits(sb_partial_count);
+  if(!_sb_partial){
+    /*Extend the sb_full run, or start a new one.*/
+    sb_full_count=_fr-&gt;sb_full_count;
+    if(_fr-&gt;sb_full==_sb_full){
+      if(sb_full_count&gt;=4129){
+        bits++;
+        sb_full_count=0;
+      }
+      else bits-=oc_sb_run_bits(sb_full_count);
+    }
+    else sb_full_count=0;
+    sb_full_count++;
+    bits+=oc_sb_run_bits(sb_full_count);
+    _fr-&gt;sb_full=_sb_full;
+    _fr-&gt;sb_full_count=sb_full_count;
+  }
+  _fr-&gt;bits=bits;
+  _fr-&gt;sb_partial=_sb_partial;
+  _fr-&gt;sb_partial_count=sb_partial_count;
+}
+
+/*Flush any outstanding block flags for a SB (e.g., one with fewer than 16
+   blocks).*/
+static void oc_fr_state_flush_sb(oc_fr_state *_fr){
+  ptrdiff_t bits;
+  int       sb_partial;
+  int       sb_full=sb_full;
+  int       b_coded_count;
+  int       b_coded;
+  int       b_count;
+  b_count=_fr-&gt;b_count;
+  if(b_count&gt;0){
+    bits=_fr-&gt;bits;
+    b_coded=_fr-&gt;b_coded;
+    b_coded_count=_fr-&gt;b_coded_count;
+    if(b_coded_count&gt;=b_count){
+      /*This SB was fully coded/uncoded; roll back the partial block flags.*/
+      bits-=oc_block_run_bits(b_coded_count);
+      if(b_coded_count&gt;b_count)bits+=oc_block_run_bits(b_coded_count-b_count);
+      sb_partial=0;
+      sb_full=b_coded;
+      b_coded=_fr-&gt;b_coded_prev;
+      b_coded_count=_fr-&gt;b_coded_count_prev;
+    }
+    else{
+      /*It was partially coded.*/
+      sb_partial=1;
+      /*sb_full is unused.*/
+    }
+    _fr-&gt;bits=bits;
+    _fr-&gt;b_coded_count=b_coded_count;
+    _fr-&gt;b_coded_count_prev=b_coded_count;
+    _fr-&gt;b_count=0;
+    _fr-&gt;b_coded=b_coded;
+    _fr-&gt;b_coded_prev=b_coded;
+    oc_fr_state_advance_sb(_fr,sb_partial,sb_full);
+  }
+}
+
+static void oc_fr_state_advance_block(oc_fr_state *_fr,int _b_coded){
+  ptrdiff_t bits;
+  int       b_coded_count;
+  int       b_count;
+  int       sb_partial;
+  int       sb_full=sb_full;
+  bits=_fr-&gt;bits;
+  /*Extend the b_coded run, or start a new one.*/
+  b_coded_count=_fr-&gt;b_coded_count;
+  if(_fr-&gt;b_coded==_b_coded)bits-=oc_block_run_bits(b_coded_count);
+  else b_coded_count=0;
+  b_coded_count++;
+  b_count=_fr-&gt;b_count+1;
+  if(b_count&gt;=16){
+    /*We finished a superblock.*/
+    if(b_coded_count&gt;=16){
+      /*It was fully coded/uncoded; roll back the partial block flags.*/
+      if(b_coded_count&gt;16)bits+=oc_block_run_bits(b_coded_count-16);
+      sb_partial=0;
+      sb_full=_b_coded;
+      _b_coded=_fr-&gt;b_coded_prev;
+      b_coded_count=_fr-&gt;b_coded_count_prev;
+    }
+    else{
+      bits+=oc_block_run_bits(b_coded_count);
+      /*It was partially coded.*/
+      sb_partial=1;
+      /*sb_full is unused.*/
+    }
+    _fr-&gt;bits=bits;
+    _fr-&gt;b_coded_count=b_coded_count;
+    _fr-&gt;b_coded_count_prev=b_coded_count;
+    _fr-&gt;b_count=0;
+    _fr-&gt;b_coded=_b_coded;
+    _fr-&gt;b_coded_prev=_b_coded;
+    oc_fr_state_advance_sb(_fr,sb_partial,sb_full);
+  }
+  else{
+    bits+=oc_block_run_bits(b_coded_count);
+    _fr-&gt;bits=bits;
+    _fr-&gt;b_coded_count=b_coded_count;
+    _fr-&gt;b_count=b_count;
+    _fr-&gt;b_coded=_b_coded;
+  }
+}
+
+static void oc_fr_skip_block(oc_fr_state *_fr){
+  oc_fr_state_advance_block(_fr,0);
+}
+
+static void oc_fr_code_block(oc_fr_state *_fr){
+  oc_fr_state_advance_block(_fr,1);
+}
+
+static int oc_fr_cost1(const oc_fr_state *_fr){
+  oc_fr_state tmp;
+  ptrdiff_t   bits;
+  *&amp;tmp=*_fr;
+  oc_fr_skip_block(&amp;tmp);
+  bits=tmp.bits;
+  *&amp;tmp=*_fr;
+  oc_fr_code_block(&amp;tmp);
+  return (int)(tmp.bits-bits);
+}
+
+static int oc_fr_cost4(const oc_fr_state *_pre,const oc_fr_state *_post){
+  oc_fr_state tmp;
+  *&amp;tmp=*_pre;
+  oc_fr_skip_block(&amp;tmp);
+  oc_fr_skip_block(&amp;tmp);
+  oc_fr_skip_block(&amp;tmp);
+  oc_fr_skip_block(&amp;tmp);
+  return (int)(_post-&gt;bits-tmp.bits);
+}
+
+
+
+struct oc_qii_state{
+  ptrdiff_t  bits;
+  unsigned   qi01_count:14;
+  signed int qi01:2;
+  unsigned   qi12_count:14;
+  signed int qi12:2;
+};
+
+
+
+static void oc_qii_state_init(oc_qii_state *_qs){
+  _qs-&gt;bits=0;
+  _qs-&gt;qi01_count=0;
+  _qs-&gt;qi01=-1;
+  _qs-&gt;qi12_count=0;
+  _qs-&gt;qi12=-1;
+}
+
+
+static void oc_qii_state_advance(oc_qii_state *_qd,
+ const oc_qii_state *_qs,int _qii){
+  ptrdiff_t bits;
+  int       qi01;
+  int       qi01_count;
+  int       qi12;
+  int       qi12_count;
+  bits=_qs-&gt;bits;
+  qi01=_qii+1&gt;&gt;1;
+  qi01_count=_qs-&gt;qi01_count;
+  if(qi01==_qs-&gt;qi01){
+    if(qi01_count&gt;=4129){
+      bits++;
+      qi01_count=0;
+    }
+    else bits-=oc_sb_run_bits(qi01_count);
+  }
+  else qi01_count=0;
+  qi01_count++;
+  bits+=oc_sb_run_bits(qi01_count);
+  qi12_count=_qs-&gt;qi12_count;
+  if(_qii){
+    qi12=_qii&gt;&gt;1;
+    if(qi12==_qs-&gt;qi12){
+      if(qi12_count&gt;=4129){
+        bits++;
+        qi12_count=0;
+      }
+      else bits-=oc_sb_run_bits(qi12_count);
+    }
+    else qi12_count=0;
+    qi12_count++;
+    bits+=oc_sb_run_bits(qi12_count);
+  }
+  else qi12=_qs-&gt;qi12;
+  _qd-&gt;bits=bits;
+  _qd-&gt;qi01=qi01;
+  _qd-&gt;qi01_count=qi01_count;
+  _qd-&gt;qi12=qi12;
+  _qd-&gt;qi12_count=qi12_count;
+}
+
+
+
+/*Temporary encoder state for the analysis pipeline.*/
+struct oc_enc_pipeline_state{
+  int                 bounding_values[256];
+  oc_fr_state         fr[3];
+  oc_qii_state        qs[3];
+  /*Condensed dequantization tables.*/
+  const ogg_uint16_t *dequant[3][3][2];
+  /*Condensed quantization tables.*/
+  const oc_iquant    *enquant[3][3][2];
+  /*Skip SSD storage for the current MCU in each plane.*/
+  unsigned           *skip_ssd[3];
+  /*Coded/uncoded fragment lists for each plane for the current MCU.*/
+  ptrdiff_t          *coded_fragis[3];
+  ptrdiff_t          *uncoded_fragis[3];
+  ptrdiff_t           ncoded_fragis[3];
+  ptrdiff_t           nuncoded_fragis[3];
+  /*The starting fragment for the current MCU in each plane.*/
+  ptrdiff_t           froffset[3];
+  /*The starting row for the current MCU in each plane.*/
+  int                 fragy0[3];
+  /*The ending row for the current MCU in each plane.*/
+  int                 fragy_end[3];
+  /*The starting superblock for the current MCU in each plane.*/
+  unsigned            sbi0[3];
+  /*The ending superblock for the current MCU in each plane.*/
+  unsigned            sbi_end[3];
+  /*The number of tokens for zzi=1 for each color plane.*/
+  int                 ndct_tokens1[3];
+  /*The outstanding eob_run count for zzi=1 for each color plane.*/
+  int                 eob_run1[3];
+  /*Whether or not the loop filter is enabled.*/
+  int                 loop_filter;
+};
+
+
+static void oc_enc_pipeline_init(oc_enc_ctx *_enc,oc_enc_pipeline_state *_pipe){
+  ptrdiff_t *coded_fragis;
+  unsigned   mcu_nvsbs;
+  ptrdiff_t  mcu_nfrags;
+  int        hdec;
+  int        vdec;
+  int        pli;
+  int        qii;
+  int        qti;
+  /*Initialize the per-plane coded block flag trackers.
+    These are used for bit-estimation purposes only; the real flag bits span
+     all three planes, so we can't compute them in parallel.*/
+  for(pli=0;pli&lt;3;pli++)oc_fr_state_init(_pipe-&gt;fr+pli);
+  for(pli=0;pli&lt;3;pli++)oc_qii_state_init(_pipe-&gt;qs+pli);
+  /*Set up the per-plane skip SSD storage pointers.*/
+  mcu_nvsbs=_enc-&gt;mcu_nvsbs;
+  mcu_nfrags=mcu_nvsbs*_enc-&gt;state.fplanes[0].nhsbs*16;
+  hdec=!(_enc-&gt;state.info.pixel_fmt&amp;1);
+  vdec=!(_enc-&gt;state.info.pixel_fmt&amp;2);
+  _pipe-&gt;skip_ssd[0]=_enc-&gt;mcu_skip_ssd;
+  _pipe-&gt;skip_ssd[1]=_pipe-&gt;skip_ssd[0]+mcu_nfrags;
+  _pipe-&gt;skip_ssd[2]=_pipe-&gt;skip_ssd[1]+(mcu_nfrags&gt;&gt;hdec+vdec);
+  /*Set up per-plane pointers to the coded and uncoded fragments lists.
+    Unlike the decoder, each planes' coded and uncoded fragment list is kept
+     separate during the analysis stage; we only make the coded list for all
+     three planes contiguous right before the final packet is output
+     (destroying the uncoded lists, which are no longer needed).*/
+  coded_fragis=_enc-&gt;state.coded_fragis;
+  for(pli=0;pli&lt;3;pli++){
+    _pipe-&gt;coded_fragis[pli]=coded_fragis;
+    coded_fragis+=_enc-&gt;state.fplanes[pli].nfrags;
+    _pipe-&gt;uncoded_fragis[pli]=coded_fragis;
+  }
+  memset(_pipe-&gt;ncoded_fragis,0,sizeof(_pipe-&gt;ncoded_fragis));
+  memset(_pipe-&gt;nuncoded_fragis,0,sizeof(_pipe-&gt;nuncoded_fragis));
+  /*Set up condensed quantizer tables.*/
+  for(pli=0;pli&lt;3;pli++){
+    for(qii=0;qii&lt;_enc-&gt;state.nqis;qii++){
+      int qi;
+      qi=_enc-&gt;state.qis[qii];
+      for(qti=0;qti&lt;2;qti++){
+        _pipe-&gt;dequant[pli][qii][qti]=_enc-&gt;state.dequant_tables[qi][pli][qti];
+        _pipe-&gt;enquant[pli][qii][qti]=_enc-&gt;enquant_tables[qi][pli][qti];
+      }
+    }
+  }
+  /*Initialize the tokenization state.*/
+  for(pli=0;pli&lt;3;pli++){
+    _pipe-&gt;ndct_tokens1[pli]=0;
+    _pipe-&gt;eob_run1[pli]=0;
+  }
+  /*Initialize the bounding value array for the loop filter.*/
+  _pipe-&gt;loop_filter=!oc_state_loop_filter_init(&amp;_enc-&gt;state,
+   _pipe-&gt;bounding_values);
+}
+
+/*Sets the current MCU stripe to super block row _sby.
+  Return: A non-zero value if this was the last MCU.*/
+static int oc_enc_pipeline_set_stripe(oc_enc_ctx *_enc,
+ oc_enc_pipeline_state *_pipe,int _sby){
+  const oc_fragment_plane *fplane;
+  unsigned                 mcu_nvsbs;
+  int                      sby_end;
+  int                      notdone;
+  int                      vdec;
+  int                      pli;
+  mcu_nvsbs=_enc-&gt;mcu_nvsbs;
+  sby_end=_enc-&gt;state.fplanes[0].nvsbs;
+  notdone=_sby+mcu_nvsbs&lt;sby_end;
+  if(notdone)sby_end=_sby+mcu_nvsbs;
+  vdec=0;
+  for(pli=0;pli&lt;3;pli++){
+    fplane=_enc-&gt;state.fplanes+pli;
+    _pipe-&gt;sbi0[pli]=fplane-&gt;sboffset+(_sby&gt;&gt;vdec)*fplane-&gt;nhsbs;
+    _pipe-&gt;fragy0[pli]=_sby&lt;&lt;2-vdec;
+    _pipe-&gt;froffset[pli]=fplane-&gt;froffset
+     +_pipe-&gt;fragy0[pli]*(ptrdiff_t)fplane-&gt;nhfrags;
+    if(notdone){
+      _pipe-&gt;sbi_end[pli]=fplane-&gt;sboffset+(sby_end&gt;&gt;vdec)*fplane-&gt;nhsbs;
+      _pipe-&gt;fragy_end[pli]=sby_end&lt;&lt;2-vdec;
+    }
+    else{
+      _pipe-&gt;sbi_end[pli]=fplane-&gt;sboffset+fplane-&gt;nsbs;
+      _pipe-&gt;fragy_end[pli]=fplane-&gt;nvfrags;
+    }
+    vdec=!(_enc-&gt;state.info.pixel_fmt&amp;2);
+  }
+  return notdone;
+}
+
+static void oc_enc_pipeline_finish_mcu_plane(oc_enc_ctx *_enc,
+ oc_enc_pipeline_state *_pipe,int _pli,int _sdelay,int _edelay){
+  int refi;
+  /*Copy over all the uncoded fragments from this plane and advance the uncoded
+     fragment list.*/
+  _pipe-&gt;uncoded_fragis[_pli]-=_pipe-&gt;nuncoded_fragis[_pli];
+  oc_state_frag_copy_list(&amp;_enc-&gt;state,_pipe-&gt;uncoded_fragis[_pli],
+   _pipe-&gt;nuncoded_fragis[_pli],OC_FRAME_SELF,OC_FRAME_PREV,_pli);
+  _pipe-&gt;nuncoded_fragis[_pli]=0;
+  /*Perform DC prediction.*/
+  oc_enc_pred_dc_frag_rows(_enc,_pli,
+   _pipe-&gt;fragy0[_pli],_pipe-&gt;fragy_end[_pli]);
+  /*Finish DC tokenization.*/
+  oc_enc_tokenize_dc_frag_list(_enc,_pli,
+   _pipe-&gt;coded_fragis[_pli],_pipe-&gt;ncoded_fragis[_pli],
+   _pipe-&gt;ndct_tokens1[_pli],_pipe-&gt;eob_run1[_pli]);
+  _pipe-&gt;ndct_tokens1[_pli]=_enc-&gt;ndct_tokens[_pli][1];
+  _pipe-&gt;eob_run1[_pli]=_enc-&gt;eob_run[_pli][1];
+  /*And advance the coded fragment list.*/
+  _enc-&gt;state.ncoded_fragis[_pli]+=_pipe-&gt;ncoded_fragis[_pli];
+  _pipe-&gt;coded_fragis[_pli]+=_pipe-&gt;ncoded_fragis[_pli];
+  _pipe-&gt;ncoded_fragis[_pli]=0;
+  /*Apply the loop filter if necessary.*/
+  refi=_enc-&gt;state.ref_frame_idx[OC_FRAME_SELF];
+  if(_pipe-&gt;loop_filter){
+    oc_state_loop_filter_frag_rows(&amp;_enc-&gt;state,_pipe-&gt;bounding_values,
+     refi,_pli,_pipe-&gt;fragy0[_pli]-_sdelay,_pipe-&gt;fragy_end[_pli]-_edelay);
+  }
+  else _sdelay=_edelay=0;
+  /*To fill borders, we have an additional two pixel delay, since a fragment
+     in the next row could filter its top edge, using two pixels from a
+     fragment in this row.
+    But there's no reason to delay a full fragment between the two.*/
+  oc_state_borders_fill_rows(&amp;_enc-&gt;state,refi,_pli,
+   (_pipe-&gt;fragy0[_pli]-_sdelay&lt;&lt;3)-(_sdelay&lt;&lt;1),
+   (_pipe-&gt;fragy_end[_pli]-_edelay&lt;&lt;3)-(_edelay&lt;&lt;1));
+}
+
+
+
+/*Cost information about the coded blocks in a MB.*/
+struct oc_rd_metric{
+  int uncoded_ac_ssd;
+  int coded_ac_ssd;
+  int ac_bits;
+  int dc_flag;
+};
+
+
+
+static int oc_enc_block_transform_quantize(oc_enc_ctx *_enc,
+ oc_enc_pipeline_state *_pipe,int _pli,ptrdiff_t _fragi,int _overhead_bits,
+ oc_rd_metric *_mo,oc_token_checkpoint **_stack){
+  OC_ALIGN16(ogg_int16_t  dct[64]);
+  OC_ALIGN16(ogg_int16_t  data[64]);
+  ogg_uint16_t            dc_dequant;
+  const ogg_uint16_t     *dequant;
+  const oc_iquant        *enquant;
+  ptrdiff_t               frag_offs;
+  int                     ystride;
+  const unsigned char    *src;
+  const unsigned char    *ref;
+  unsigned char          *dst;
+  int                     frame_type;
+  int                     nonzero;
+  unsigned                uncoded_ssd;
+  unsigned                coded_ssd;
+  int                     coded_dc;
+  oc_token_checkpoint    *checkpoint;
+  oc_fragment            *frags;
+  int                     mb_mode;
+  int                     mv_offs[2];
+  int                     nmv_offs;
+  int                     ac_bits;
+  int                     borderi;
+  int                     qti;
+  int                     qii;
+  int                     pi;
+  int                     zzi;
+  int                     v;
+  int                     val;
+  int                     d;
+  int                     s;
+  int                     dc;
+  frags=_enc-&gt;state.frags;
+  frag_offs=_enc-&gt;state.frag_buf_offs[_fragi];
+  ystride=_enc-&gt;state.ref_ystride[_pli];
+  src=_enc-&gt;state.ref_frame_data[OC_FRAME_IO]+frag_offs;
+  borderi=frags[_fragi].borderi;
+  qii=frags[_fragi].qii;
+  if(qii&amp;~3){
+#if !defined(OC_COLLECT_METRICS)
+    if(_enc-&gt;sp_level&gt;=OC_SP_LEVEL_EARLY_SKIP){
+      /*Enable early skip detection.*/
+      frags[_fragi].coded=0;
+      return 0;
+    }
+#endif
+    /*Try and code this block anyway.*/
+    qii&amp;=3;
+    frags[_fragi].qii=qii;
+  }
+  mb_mode=frags[_fragi].mb_mode;
+  ref=_enc-&gt;state.ref_frame_data[
+   _enc-&gt;state.ref_frame_idx[OC_FRAME_FOR_MODE(mb_mode)]]+frag_offs;
+  dst=_enc-&gt;state.ref_frame_data[_enc-&gt;state.ref_frame_idx[OC_FRAME_SELF]]
+   +frag_offs;
+  /*Motion compensation:*/
+  switch(mb_mode){
+    case OC_MODE_INTRA:{
+      nmv_offs=0;
+      oc_enc_frag_sub_128(_enc,data,src,ystride);
+    }break;
+    case OC_MODE_GOLDEN_NOMV:
+    case OC_MODE_INTER_NOMV:{
+      nmv_offs=1;
+      mv_offs[0]=0;
+      oc_enc_frag_sub(_enc,data,src,ref,ystride);
+    }break;
+    default:{
+      const oc_mv *frag_mvs;
+      frag_mvs=(const oc_mv *)_enc-&gt;state.frag_mvs;
+      nmv_offs=oc_state_get_mv_offsets(&amp;_enc-&gt;state,mv_offs,_pli,
+       frag_mvs[_fragi][0],frag_mvs[_fragi][1]);
+      if(nmv_offs&gt;1){
+        oc_enc_frag_copy2(_enc,dst,
+         ref+mv_offs[0],ref+mv_offs[1],ystride);
+        oc_enc_frag_sub(_enc,data,src,dst,ystride);
+      }
+      else oc_enc_frag_sub(_enc,data,src,ref+mv_offs[0],ystride);
+    }break;
+  }
+#if defined(OC_COLLECT_METRICS)
+  {
+    unsigned satd;
+    switch(nmv_offs){
+      case 0:satd=oc_enc_frag_intra_satd(_enc,src,ystride);break;
+      case 1:{
+        satd=oc_enc_frag_satd_thresh(_enc,src,ref+mv_offs[0],ystride,UINT_MAX);
+      }break;
+      default:{
+        satd=oc_enc_frag_satd_thresh(_enc,src,dst,ystride,UINT_MAX);
+      }
+    }
+    _enc-&gt;frag_satd[_fragi]=satd;
+  }
+#endif
+  /*Transform:*/
+  oc_enc_fdct8x8(_enc,dct,data);
+  /*Quantize the DC coefficient:*/
+  qti=mb_mode!=OC_MODE_INTRA;
+  enquant=_pipe-&gt;enquant[_pli][0][qti];
+  dc_dequant=_pipe-&gt;dequant[_pli][0][qti][0];
+  v=dct[0];
+  val=v&lt;&lt;1;
+  s=OC_SIGNMASK(val);
+  val+=dc_dequant+s^s;
+  val=((enquant[0].m*(ogg_int32_t)val&gt;&gt;16)+val&gt;&gt;enquant[0].l)-s;
+  dc=OC_CLAMPI(-580,val,580);
+  nonzero=0;
+  /*Quantize the AC coefficients:*/
+  dequant=_pipe-&gt;dequant[_pli][qii][qti];
+  enquant=_pipe-&gt;enquant[_pli][qii][qti];
+  for(zzi=1;zzi&lt;64;zzi++){
+    v=dct[OC_FZIG_ZAG[zzi]];
+    d=dequant[zzi];
+    val=v&lt;&lt;1;
+    v=abs(val);
+    if(v&gt;=d){
+      s=OC_SIGNMASK(val);
+      /*The bias added here rounds ties away from zero, since token
+         optimization can only decrease the magnitude of the quantized
+         value.*/
+      val+=d+s^s;
+      /*Note the arithmetic right shift is not guaranteed by ANSI C.
+        Hopefully no one still uses ones-complement architectures.*/
+      val=((enquant[zzi].m*(ogg_int32_t)val&gt;&gt;16)+val&gt;&gt;enquant[zzi].l)-s;
+      data[zzi]=OC_CLAMPI(-580,val,580);
+      nonzero=zzi;
+    }
+    else data[zzi]=0;
+  }
+  /*Tokenize.*/
+  checkpoint=*_stack;
+  ac_bits=oc_enc_tokenize_ac(_enc,_pli,_fragi,data,dequant,dct,nonzero+1,
+   _stack,qti?0:3);
+  /*Reconstruct.
+    TODO: nonzero may need to be adjusted after tokenization.*/
+  if(nonzero==0){
+    ogg_int16_t p;
+    int         ci;
+    /*We round this dequant product (and not any of the others) because there's
+       no iDCT rounding.*/
+    p=(ogg_int16_t)(dc*(ogg_int32_t)dc_dequant+15&gt;&gt;5);
+    /*LOOP VECTORIZES.*/
+    for(ci=0;ci&lt;64;ci++)data[ci]=p;
+  }
+  else{
+    data[0]=dc*dc_dequant;
+    oc_idct8x8(&amp;_enc-&gt;state,data,nonzero+1);
+  }
+  if(!qti)oc_enc_frag_recon_intra(_enc,dst,ystride,data);
+  else{
+    oc_enc_frag_recon_inter(_enc,dst,
+     nmv_offs==1?ref+mv_offs[0]:dst,ystride,data);
+  }
+  frame_type=_enc-&gt;state.frame_type;
+#if !defined(OC_COLLECT_METRICS)
+  if(frame_type!=OC_INTRA_FRAME)
+#endif
+  {
+    /*In retrospect, should we have skipped this block?*/
+    oc_enc_frag_sub(_enc,data,src,dst,ystride);
+    coded_ssd=coded_dc=0;
+    if(borderi&lt;0){
+      for(pi=0;pi&lt;64;pi++){
+        coded_ssd+=data[pi]*data[pi];
+        coded_dc+=data[pi];
+      }
+    }
+    else{
+      ogg_int64_t mask;
+      mask=_enc-&gt;state.borders[borderi].mask;
+      for(pi=0;pi&lt;64;pi++,mask&gt;&gt;=1)if(mask&amp;1){
+        coded_ssd+=data[pi]*data[pi];
+        coded_dc+=data[pi];
+      }
+    }
+    /*Scale to match DCT domain.*/
+    coded_ssd&lt;&lt;=4;
+    /*We actually only want the AC contribution to the SSD.*/
+    coded_ssd-=coded_dc*coded_dc&gt;&gt;2;
+#if defined(OC_COLLECT_METRICS)
+    _enc-&gt;frag_ssd[_fragi]=coded_ssd;
+  }
+  if(frame_type!=OC_INTRA_FRAME){
+#endif
+    uncoded_ssd=_pipe-&gt;skip_ssd[_pli][_fragi-_pipe-&gt;froffset[_pli]];
+    if(uncoded_ssd&lt;UINT_MAX){
+      /*Although the fragment coding overhead determination is accurate, it is
+         greedy, using very coarse-grained local information.
+        Allowing it to mildly discourage coding turns out to be beneficial, but
+         it's not clear that allowing it to encourage coding through negative
+         coding overhead deltas is useful.
+        For that reason, we disallow negative coding_overheads.*/
+      if(_overhead_bits&lt;0)_overhead_bits=0;
+      if(uncoded_ssd&lt;=coded_ssd+(_overhead_bits+ac_bits)*_enc-&gt;lambda&amp;&amp;
+       /*Don't allow luma blocks to be skipped in 4MV mode when VP3
+          compatibility is enabled.*/
+       (!_enc-&gt;vp3_compatible||mb_mode!=OC_MODE_INTER_MV_FOUR||_pli)){
+        /*Hm, not worth it; roll back.*/
+        oc_enc_tokenlog_rollback(_enc,checkpoint,(*_stack)-checkpoint);
+        *_stack=checkpoint;
+        frags[_fragi].coded=0;
+        return 0;
+      }
+    }
+    else _mo-&gt;dc_flag=1;
+    _mo-&gt;uncoded_ac_ssd+=uncoded_ssd;
+    _mo-&gt;coded_ac_ssd+=coded_ssd;
+    _mo-&gt;ac_bits+=ac_bits;
+  }
+  oc_qii_state_advance(_pipe-&gt;qs+_pli,_pipe-&gt;qs+_pli,qii);
+  frags[_fragi].dc=dc;
+  frags[_fragi].coded=1;
+  return 1;
+}
+
+static int oc_enc_mb_transform_quantize_luma(oc_enc_ctx *_enc,
+ oc_enc_pipeline_state *_pipe,unsigned _mbi,int _mode_overhead){
+  /*Worst case token stack usage for 4 fragments.*/
+  oc_token_checkpoint  stack[64*4];
+  oc_token_checkpoint *stackptr;
+  const oc_sb_map     *sb_maps;
+  signed char         *mb_modes;
+  oc_fragment         *frags;
+  ptrdiff_t           *coded_fragis;
+  ptrdiff_t            ncoded_fragis;
+  ptrdiff_t           *uncoded_fragis;
+  ptrdiff_t            nuncoded_fragis;
+  oc_rd_metric         mo;
+  oc_fr_state          fr_checkpoint;
+  oc_qii_state         qs_checkpoint;
+  int                  mb_mode;
+  int                  ncoded;
+  ptrdiff_t            fragi;
+  int                  bi;
+  *&amp;fr_checkpoint=*(_pipe-&gt;fr+0);
+  *&amp;qs_checkpoint=*(_pipe-&gt;qs+0);
+  sb_maps=(const oc_sb_map *)_enc-&gt;state.sb_maps;
+  mb_modes=_enc-&gt;state.mb_modes;
+  frags=_enc-&gt;state.frags;
+  coded_fragis=_pipe-&gt;coded_fragis[0];
+  ncoded_fragis=_pipe-&gt;ncoded_fragis[0];
+  uncoded_fragis=_pipe-&gt;uncoded_fragis[0];
+  nuncoded_fragis=_pipe-&gt;nuncoded_fragis[0];
+  mb_mode=mb_modes[_mbi];
+  ncoded=0;
+  stackptr=stack;
+  memset(&amp;mo,0,sizeof(mo));
+  for(bi=0;bi&lt;4;bi++){
+    fragi=sb_maps[_mbi&gt;&gt;2][_mbi&amp;3][bi];
+    frags[fragi].mb_mode=mb_mode;
+    if(oc_enc_block_transform_quantize(_enc,
+     _pipe,0,fragi,oc_fr_cost1(_pipe-&gt;fr+0),&amp;mo,&amp;stackptr)){
+      oc_fr_code_block(_pipe-&gt;fr+0);
+      coded_fragis[ncoded_fragis++]=fragi;
+      ncoded++;
+    }
+    else{
+      *(uncoded_fragis-++nuncoded_fragis)=fragi;
+      oc_fr_skip_block(_pipe-&gt;fr+0);
+    }
+  }
+  if(_enc-&gt;state.frame_type!=OC_INTRA_FRAME){
+    if(ncoded&gt;0&amp;&amp;!mo.dc_flag){
+      int cost;
+      /*Some individual blocks were worth coding.
+        See if that's still true when accounting for mode and MV overhead.*/
+      cost=mo.coded_ac_ssd+_enc-&gt;lambda*(mo.ac_bits
+       +oc_fr_cost4(&amp;fr_checkpoint,_pipe-&gt;fr+0)+_mode_overhead);
+      if(mo.uncoded_ac_ssd&lt;=cost){
+        /*Taking macroblock overhead into account, it is not worth coding this
+           MB.*/
+        oc_enc_tokenlog_rollback(_enc,stack,stackptr-stack);
+        *(_pipe-&gt;fr+0)=*&amp;fr_checkpoint;

[... truncated: 31019 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020977.html">[Haiku-commits] r33342 -	haiku/trunk/src/add-ons/kernel/drivers/network/usb_asix
</A></li>
	<LI>Next message: <A HREF="020979.html">[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20978">[ date ]</a>
              <a href="thread.html#20978">[ thread ]</a>
              <a href="subject.html#20978">[ subject ]</a>
              <a href="author.html#20978">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
