<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33343%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/theora%3A%20.%20libtheora%0A%09libtheora/theora%20libtheora/x86&In-Reply-To=%3Cda2be3d70909281743x1ee3a420h53dd499fd03eb3d5%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020978.html">
   <LINK REL="Next"  HREF="020983.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86</H1>
    <B>David McPaul</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33343%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/theora%3A%20.%20libtheora%0A%09libtheora/theora%20libtheora/x86&In-Reply-To=%3Cda2be3d70909281743x1ee3a420h53dd499fd03eb3d5%40mail.gmail.com%3E"
       TITLE="[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86">dlmcpaul at gmail.com
       </A><BR>
    <I>Tue Sep 29 02:43:15 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020978.html">[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
</A></li>
        <LI>Next message: <A HREF="020983.html">[Haiku-commits] r33343 - in haiku/trunk/src/add-ons/media/plugins/theora: . libtheora libtheora/theora libtheora/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20979">[ date ]</a>
              <a href="thread.html#20979">[ thread ]</a>
              <a href="subject.html#20979">[ subject ]</a>
              <a href="author.html#20979">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>How familiar are you with the OGG reader plugin source?

I started looking at Ticket 4653.  From my initial analysis it needs a
TheoraSeek class written although it has a TheoraStream class it does
not handle video from what I can see.

2009/9/29  &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">phoudoin at mail.berlios.de</A>&gt;:
&gt;<i> Author: phoudoin
</I>&gt;<i> Date: 2009-09-29 02:37:35 +0200 (Tue, 29 Sep 2009)
</I>&gt;<i> New Revision: 33343
</I>&gt;<i> ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33343&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33343&amp;view=rev</A>
</I>&gt;<i>
</I>&gt;<i> Added:
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/Jamfile
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/apiwrapper.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/apiwrapper.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/bitpack.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/bitpack.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/cpu.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/cpu.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decapiwrapper.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decinfo.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decint.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dequant.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dequant.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encapiwrapper.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encfrag.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encinfo.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encint.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/enquant.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/enquant.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/fdct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/fragment.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffdec.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffdec.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffenc.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffenc.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/info.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/internal.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/internal.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mathops.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mathops.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mcenc.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/modedec.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/ocintrin.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/rate.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/state.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/codec.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theoradec.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theoraenc.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/tokenize.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxencfrag.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfdct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfrag.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxfrag.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxidct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxloop.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/mmxstate.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/sse2fdct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86enc.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86enc.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86int.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/x86/x86state.c
</I>&gt;<i> Removed:
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/block_inline.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/blockmap.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/comment.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct_decode.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/dct_encode.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encoder_internal.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encoder_lookup.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/frarray.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/frinit.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffman.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/hufftables.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/mcomp.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/misc_common.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pb.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pp.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/pp.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant_lookup.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/reconstruct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/scan.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/toplevel.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/toplevel_lookup.h
</I>&gt;<i> Modified:
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/decode.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/encode.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/huffman.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/idct.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/quant.c
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/libtheora/theora/theora.h
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/theoraCodecPlugin.cpp
</I>&gt;<i> &#160; haiku/trunk/src/add-ons/media/plugins/theora/theoraCodecPlugin.h
</I>&gt;<i> Log:
</I>&gt;<i> Update theora to latest v1.1, which improve performance and quality.
</I>&gt;<i> Untested yet...
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Added: haiku/trunk/src/add-ons/media/plugins/theora/Jamfile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/src/add-ons/media/plugins/theora/Jamfile &#160; &#160; &#160; &#160;2009-09-28 23:02:30 UTC (rev 33342)
</I>&gt;<i> +++ haiku/trunk/src/add-ons/media/plugins/theora/Jamfile &#160; &#160; &#160; &#160;2009-09-29 00:37:35 UTC (rev 33343)
</I>&gt;<i> @@ -0,0 +1,16 @@
</I>&gt;<i> +SubDir HAIKU_TOP src add-ons media plugins theora ;
</I>&gt;<i> +
</I>&gt;<i> +SetSubDirSupportedPlatformsBeOSCompatible ;
</I>&gt;<i> +
</I>&gt;<i> +UsePrivateHeaders media shared ;
</I>&gt;<i> +
</I>&gt;<i> +SubDirSysHdrs $(SUBDIR) libtheora ;
</I>&gt;<i> +SubDirHdrs $(SUBDIR) .. ogg ;
</I>&gt;<i> +SubDirSysHdrs $(SUBDIR) .. ogg libogg ;
</I>&gt;<i> +
</I>&gt;<i> +Addon theora :
</I>&gt;<i> + &#160; &#160; &#160; theoraCodecPlugin.cpp
</I>&gt;<i> + &#160; &#160; &#160; : libtheora.a libogg.a be libmedia.so $(TARGET_LIBSUPC++)
</I>&gt;<i> +;
</I>&gt;<i> +
</I>&gt;<i> +SubInclude HAIKU_TOP src add-ons media plugins theora libtheora ;
</I>&gt;<i>
</I>&gt;<i> Modified: haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile &#160; &#160; &#160;2009-09-28 23:02:30 UTC (rev 33342)
</I>&gt;<i> +++ haiku/trunk/src/add-ons/media/plugins/theora/libtheora/Jamfile &#160; &#160; &#160;2009-09-29 00:37:35 UTC (rev 33343)
</I>&gt;<i> @@ -1,28 +1,38 @@
</I>&gt;<i> &#160;SubDir HAIKU_TOP src add-ons media plugins theora libtheora ;
</I>&gt;<i>
</I>&gt;<i> -SubDirHdrs [ FDirName $(SUBDIR) .. .. ogg libogg ] ;
</I>&gt;<i> +SubDirSysHdrs $(SUBDIR) ;
</I>&gt;<i> +SubDirHdrs $(SUBDIR) .. .. ogg ;
</I>&gt;<i> +SubDirSysHdrs $(SUBDIR) .. .. ogg libogg ;
</I>&gt;<i>
</I>&gt;<i> -SubDirCcFlags -DPACKAGE=\\\&quot;libtheora\\\&quot; -DVERSION=\\\&quot;0.0\\\&quot; ;
</I>&gt;<i> +SubDirCcFlags -DPACKAGE=\\\&quot;libtheora\\\&quot; -DVERSION=\\\&quot;1.1.0\\\&quot; ;
</I>&gt;<i> &#160;SubDirCcFlags -D_REENTRANT -DPIC -DTRUE=true ;
</I>&gt;<i>
</I>&gt;<i> +local arch_sources ;
</I>&gt;<i> +if $(TARGET_ARCH) = x86 {
</I>&gt;<i> + &#160; &#160; &#160; arch_sources =
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mmxidct.c
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mmxfrag.c
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; mmxstate.c
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; x86state.c
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; &#160; &#160; ;
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; SEARCH_SOURCE += [ FDirName $(SUBDIR) x86 ] ;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> &#160;StaticLibrary libtheora.a :
</I>&gt;<i> - &#160; &#160; &#160; blockmap.c
</I>&gt;<i> - &#160; &#160; &#160; comment.c
</I>&gt;<i> - &#160; &#160; &#160; dct.c
</I>&gt;<i> - &#160; &#160; &#160; dct_decode.c
</I>&gt;<i> - &#160; &#160; &#160; dct_encode.c
</I>&gt;<i> + &#160; &#160; &#160; apiwrapper.c
</I>&gt;<i> + &#160; &#160; &#160; bitpack.c
</I>&gt;<i> + &#160; &#160; &#160; decapiwrapper.c
</I>&gt;<i> + &#160; &#160; &#160; decinfo.c
</I>&gt;<i> &#160; &#160; &#160; &#160;decode.c
</I>&gt;<i> - &#160; &#160; &#160; encode.c
</I>&gt;<i> - &#160; &#160; &#160; frarray.c
</I>&gt;<i> - &#160; &#160; &#160; frinit.c
</I>&gt;<i> - &#160; &#160; &#160; huffman.c
</I>&gt;<i> + &#160; &#160; &#160; dequant.c
</I>&gt;<i> + &#160; &#160; &#160; fragment.c
</I>&gt;<i> + &#160; &#160; &#160; huffdec.c
</I>&gt;<i> &#160; &#160; &#160; &#160;idct.c
</I>&gt;<i> - &#160; &#160; &#160; mcomp.c
</I>&gt;<i> - &#160; &#160; &#160; misc_common.c
</I>&gt;<i> - &#160; &#160; &#160; pb.c
</I>&gt;<i> - &#160; &#160; &#160; pp.c
</I>&gt;<i> + &#160; &#160; &#160; info.c
</I>&gt;<i> + &#160; &#160; &#160; internal.c
</I>&gt;<i> &#160; &#160; &#160; &#160;quant.c
</I>&gt;<i> - &#160; &#160; &#160; reconstruct.c
</I>&gt;<i> - &#160; &#160; &#160; scan.c
</I>&gt;<i> - &#160; &#160; &#160; toplevel.c
</I>&gt;<i> + &#160; &#160; &#160; state.c
</I>&gt;<i> +
</I>&gt;<i> + &#160; &#160; &#160; $(arch_sources)
</I>&gt;<i> &#160;;
</I>&gt;<i>
</I>&gt;<i> Added: haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c
</I>&gt;<i> ===================================================================
</I>&gt;<i> --- haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c &#160; &#160;2009-09-28 23:02:30 UTC (rev 33342)
</I>&gt;<i> +++ haiku/trunk/src/add-ons/media/plugins/theora/libtheora/analyze.c &#160; &#160;2009-09-29 00:37:35 UTC (rev 33343)
</I>&gt;<i> @@ -0,0 +1,2709 @@
</I>&gt;<i> +/********************************************************************
</I>&gt;<i> + * &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*
</I>&gt;<i> + * THIS FILE IS PART OF THE OggTheora SOFTWARE CODEC SOURCE CODE. &#160; *
</I>&gt;<i> + * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS &#160; &#160; *
</I>&gt;<i> + * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
</I>&gt;<i> + * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING. &#160; &#160; &#160; *
</I>&gt;<i> + * &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*
</I>&gt;<i> + * THE Theora SOURCE CODE IS COPYRIGHT (C) 2002-2009 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*
</I>&gt;<i> + * by the Xiph.Org Foundation <A HREF="http://www.xiph.org/">http://www.xiph.org/</A> &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*
</I>&gt;<i> + * &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;*
</I>&gt;<i> + ********************************************************************
</I>&gt;<i> +
</I>&gt;<i> + &#160;function: mode selection code
</I>&gt;<i> + &#160;last mod: $Id$
</I>&gt;<i> +
</I>&gt;<i> + ********************************************************************/
</I>&gt;<i> +#include &lt;limits.h&gt;
</I>&gt;<i> +#include &lt;string.h&gt;
</I>&gt;<i> +#include &quot;encint.h&quot;
</I>&gt;<i> +#include &quot;modedec.h&quot;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +typedef struct oc_fr_state &#160; &#160; &#160; &#160; &#160; oc_fr_state;
</I>&gt;<i> +typedef struct oc_qii_state &#160; &#160; &#160; &#160; &#160;oc_qii_state;
</I>&gt;<i> +typedef struct oc_enc_pipeline_state oc_enc_pipeline_state;
</I>&gt;<i> +typedef struct oc_rd_metric &#160; &#160; &#160; &#160; &#160;oc_rd_metric;
</I>&gt;<i> +typedef struct oc_mode_choice &#160; &#160; &#160; &#160;oc_mode_choice;
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*There are 8 possible schemes used to encode macro block modes.
</I>&gt;<i> + &#160;Schemes 0-6 use a maximally-skewed Huffman code to code each of the modes.
</I>&gt;<i> + &#160;The same set of Huffman codes is used for each of these 7 schemes, but the
</I>&gt;<i> + &#160; mode assigned to each codeword varies.
</I>&gt;<i> + &#160;Scheme 0 writes a custom mapping from codeword to MB mode to the bitstream,
</I>&gt;<i> + &#160; while schemes 1-6 have a fixed mapping.
</I>&gt;<i> + &#160;Scheme 7 just encodes each mode directly in 3 bits.*/
</I>&gt;<i> +
</I>&gt;<i> +/*The mode orderings for the various mode coding schemes.
</I>&gt;<i> + &#160;Scheme 0 uses a custom alphabet, which is not stored in this table.
</I>&gt;<i> + &#160;This is the inverse of the equivalent table OC_MODE_ALPHABETS in the
</I>&gt;<i> + &#160; decoder.*/
</I>&gt;<i> +static const unsigned char OC_MODE_RANKS[7][OC_NMODES]={
</I>&gt;<i> + &#160;/*Last MV dominates.*/
</I>&gt;<i> + &#160;/*L P M N I G GM 4*/
</I>&gt;<i> + &#160;{3,4,2,0,1,5,6,7},
</I>&gt;<i> + &#160;/*L P N M I G GM 4*/
</I>&gt;<i> + &#160;{2,4,3,0,1,5,6,7},
</I>&gt;<i> + &#160;/*L M P N I G GM 4*/
</I>&gt;<i> + &#160;{3,4,1,0,2,5,6,7},
</I>&gt;<i> + &#160;/*L M N P I G GM 4*/
</I>&gt;<i> + &#160;{2,4,1,0,3,5,6,7},
</I>&gt;<i> + &#160;/*No MV dominates.*/
</I>&gt;<i> + &#160;/*N L P M I G GM 4*/
</I>&gt;<i> + &#160;{0,4,3,1,2,5,6,7},
</I>&gt;<i> + &#160;/*N G L P M I GM 4*/
</I>&gt;<i> + &#160;{0,5,4,2,3,1,6,7},
</I>&gt;<i> + &#160;/*Default ordering.*/
</I>&gt;<i> + &#160;/*N I M L P G GM 4*/
</I>&gt;<i> + &#160;{0,1,2,3,4,5,6,7}
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*Initialize the mode scheme chooser.
</I>&gt;<i> + &#160;This need only be called once per encoder.*/
</I>&gt;<i> +void oc_mode_scheme_chooser_init(oc_mode_scheme_chooser *_chooser){
</I>&gt;<i> + &#160;int si;
</I>&gt;<i> + &#160;_chooser-&gt;mode_ranks[0]=_chooser-&gt;scheme0_ranks;
</I>&gt;<i> + &#160;for(si=1;si&lt;8;si++)_chooser-&gt;mode_ranks[si]=OC_MODE_RANKS[si-1];
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*Reset the mode scheme chooser.
</I>&gt;<i> + &#160;This needs to be called once for each frame, including the first.*/
</I>&gt;<i> +static void oc_mode_scheme_chooser_reset(oc_mode_scheme_chooser *_chooser){
</I>&gt;<i> + &#160;int si;
</I>&gt;<i> + &#160;memset(_chooser-&gt;mode_counts,0,OC_NMODES*sizeof(*_chooser-&gt;mode_counts));
</I>&gt;<i> + &#160;/*Scheme 0 starts with 24 bits to store the mode list in.*/
</I>&gt;<i> + &#160;_chooser-&gt;scheme_bits[0]=24;
</I>&gt;<i> + &#160;memset(_chooser-&gt;scheme_bits+1,0,7*sizeof(*_chooser-&gt;scheme_bits));
</I>&gt;<i> + &#160;for(si=0;si&lt;8;si++){
</I>&gt;<i> + &#160; &#160;/*Scheme 7 should always start first, and scheme 0 should always start
</I>&gt;<i> + &#160; &#160; &#160; last.*/
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme_list[si]=7-si;
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme0_list[si]=_chooser-&gt;scheme0_ranks[si]=si;
</I>&gt;<i> + &#160;}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*This is the real purpose of this data structure: not actually selecting a
</I>&gt;<i> + &#160; mode scheme, but estimating the cost of coding a given mode given all the
</I>&gt;<i> + &#160; modes selected so far.
</I>&gt;<i> + &#160;This is done via opportunity cost: the cost is defined as the number of bits
</I>&gt;<i> + &#160; required to encode all the modes selected so far including the current one
</I>&gt;<i> + &#160; using the best possible scheme, minus the number of bits required to encode
</I>&gt;<i> + &#160; all the modes selected so far not including the current one using the best
</I>&gt;<i> + &#160; possible scheme.
</I>&gt;<i> + &#160;The computational expense of doing this probably makes it overkill.
</I>&gt;<i> + &#160;Just be happy we take a greedy approach instead of trying to solve the
</I>&gt;<i> + &#160; global mode-selection problem (which is NP-hard).
</I>&gt;<i> + &#160;_mb_mode: The mode to determine the cost of.
</I>&gt;<i> + &#160;Return: The number of bits required to code this mode.*/
</I>&gt;<i> +static int oc_mode_scheme_chooser_cost(oc_mode_scheme_chooser *_chooser,
</I>&gt;<i> + int _mb_mode){
</I>&gt;<i> + &#160;int scheme0;
</I>&gt;<i> + &#160;int scheme1;
</I>&gt;<i> + &#160;int best_bits;
</I>&gt;<i> + &#160;int mode_bits;
</I>&gt;<i> + &#160;int si;
</I>&gt;<i> + &#160;int scheme_bits;
</I>&gt;<i> + &#160;scheme0=_chooser-&gt;scheme_list[0];
</I>&gt;<i> + &#160;scheme1=_chooser-&gt;scheme_list[1];
</I>&gt;<i> + &#160;best_bits=_chooser-&gt;scheme_bits[scheme0];
</I>&gt;<i> + &#160;mode_bits=OC_MODE_BITS[scheme0+1&gt;&gt;3][_chooser-&gt;mode_ranks[scheme0][_mb_mode]];
</I>&gt;<i> + &#160;/*Typical case: If the difference between the best scheme and the next best
</I>&gt;<i> + &#160; &#160; is greater than 6 bits, then adding just one mode cannot change which
</I>&gt;<i> + &#160; &#160; scheme we use.*/
</I>&gt;<i> + &#160;if(_chooser-&gt;scheme_bits[scheme1]-best_bits&gt;6)return mode_bits;
</I>&gt;<i> + &#160;/*Otherwise, check to see if adding this mode selects a different scheme as
</I>&gt;<i> + &#160; &#160; the best.*/
</I>&gt;<i> + &#160;si=1;
</I>&gt;<i> + &#160;best_bits+=mode_bits;
</I>&gt;<i> + &#160;do{
</I>&gt;<i> + &#160; &#160;/*For any scheme except 0, we can just use the bit cost of the mode's rank
</I>&gt;<i> + &#160; &#160; &#160; in that scheme.*/
</I>&gt;<i> + &#160; &#160;if(scheme1!=0){
</I>&gt;<i> + &#160; &#160; &#160;scheme_bits=_chooser-&gt;scheme_bits[scheme1]+
</I>&gt;<i> + &#160; &#160; &#160; OC_MODE_BITS[scheme1+1&gt;&gt;3][_chooser-&gt;mode_ranks[scheme1][_mb_mode]];
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;int ri;
</I>&gt;<i> + &#160; &#160; &#160;/*For scheme 0, incrementing the mode count could potentially change the
</I>&gt;<i> + &#160; &#160; &#160; &#160; mode's rank.
</I>&gt;<i> + &#160; &#160; &#160; &#160;Find the index where the mode would be moved to in the optimal list,
</I>&gt;<i> + &#160; &#160; &#160; &#160; and use its bit cost instead of the one for the mode's current
</I>&gt;<i> + &#160; &#160; &#160; &#160; position in the list.*/
</I>&gt;<i> + &#160; &#160; &#160;/*We don't recompute scheme bits; this is computing opportunity cost, not
</I>&gt;<i> + &#160; &#160; &#160; &#160; an update.*/
</I>&gt;<i> + &#160; &#160; &#160;for(ri=_chooser-&gt;scheme0_ranks[_mb_mode];ri&gt;0&amp;&amp;
</I>&gt;<i> + &#160; &#160; &#160; _chooser-&gt;mode_counts[_mb_mode]&gt;=
</I>&gt;<i> + &#160; &#160; &#160; _chooser-&gt;mode_counts[_chooser-&gt;scheme0_list[ri-1]];ri--);
</I>&gt;<i> + &#160; &#160; &#160;scheme_bits=_chooser-&gt;scheme_bits[0]+OC_MODE_BITS[0][ri];
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;if(scheme_bits&lt;best_bits)best_bits=scheme_bits;
</I>&gt;<i> + &#160; &#160;if(++si&gt;=8)break;
</I>&gt;<i> + &#160; &#160;scheme1=_chooser-&gt;scheme_list[si];
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;while(_chooser-&gt;scheme_bits[scheme1]-_chooser-&gt;scheme_bits[scheme0]&lt;=6);
</I>&gt;<i> + &#160;return best_bits-_chooser-&gt;scheme_bits[scheme0];
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*Incrementally update the mode counts and per-scheme bit counts and re-order
</I>&gt;<i> + &#160; the scheme lists once a mode has been selected.
</I>&gt;<i> + &#160;_mb_mode: The mode that was chosen.*/
</I>&gt;<i> +static void oc_mode_scheme_chooser_update(oc_mode_scheme_chooser *_chooser,
</I>&gt;<i> + int _mb_mode){
</I>&gt;<i> + &#160;int ri;
</I>&gt;<i> + &#160;int si;
</I>&gt;<i> + &#160;_chooser-&gt;mode_counts[_mb_mode]++;
</I>&gt;<i> + &#160;/*Re-order the scheme0 mode list if necessary.*/
</I>&gt;<i> + &#160;for(ri=_chooser-&gt;scheme0_ranks[_mb_mode];ri&gt;0;ri--){
</I>&gt;<i> + &#160; &#160;int pmode;
</I>&gt;<i> + &#160; &#160;pmode=_chooser-&gt;scheme0_list[ri-1];
</I>&gt;<i> + &#160; &#160;if(_chooser-&gt;mode_counts[pmode]&gt;=_chooser-&gt;mode_counts[_mb_mode])break;
</I>&gt;<i> + &#160; &#160;/*Reorder the mode ranking.*/
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme0_ranks[pmode]++;
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme0_list[ri]=pmode;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;_chooser-&gt;scheme0_ranks[_mb_mode]=ri;
</I>&gt;<i> + &#160;_chooser-&gt;scheme0_list[ri]=_mb_mode;
</I>&gt;<i> + &#160;/*Now add the bit cost for the mode to each scheme.*/
</I>&gt;<i> + &#160;for(si=0;si&lt;8;si++){
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme_bits[si]+=
</I>&gt;<i> + &#160; &#160; OC_MODE_BITS[si+1&gt;&gt;3][_chooser-&gt;mode_ranks[si][_mb_mode]];
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;/*Finally, re-order the list of schemes.*/
</I>&gt;<i> + &#160;for(si=1;si&lt;8;si++){
</I>&gt;<i> + &#160; &#160;int sj;
</I>&gt;<i> + &#160; &#160;int scheme0;
</I>&gt;<i> + &#160; &#160;int bits0;
</I>&gt;<i> + &#160; &#160;sj=si;
</I>&gt;<i> + &#160; &#160;scheme0=_chooser-&gt;scheme_list[si];
</I>&gt;<i> + &#160; &#160;bits0=_chooser-&gt;scheme_bits[scheme0];
</I>&gt;<i> + &#160; &#160;do{
</I>&gt;<i> + &#160; &#160; &#160;int scheme1;
</I>&gt;<i> + &#160; &#160; &#160;scheme1=_chooser-&gt;scheme_list[sj-1];
</I>&gt;<i> + &#160; &#160; &#160;if(bits0&gt;=_chooser-&gt;scheme_bits[scheme1])break;
</I>&gt;<i> + &#160; &#160; &#160;_chooser-&gt;scheme_list[sj]=scheme1;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;while(--sj&gt;0);
</I>&gt;<i> + &#160; &#160;_chooser-&gt;scheme_list[sj]=scheme0;
</I>&gt;<i> + &#160;}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*The number of bits required to encode a super block run.
</I>&gt;<i> + &#160;_run_count: The desired run count; must be positive and less than 4130.*/
</I>&gt;<i> +static int oc_sb_run_bits(int _run_count){
</I>&gt;<i> + &#160;int i;
</I>&gt;<i> + &#160;for(i=0;_run_count&gt;=OC_SB_RUN_VAL_MIN[i+1];i++);
</I>&gt;<i> + &#160;return OC_SB_RUN_CODE_NBITS[i];
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*The number of bits required to encode a block run.
</I>&gt;<i> + &#160;_run_count: The desired run count; must be positive and less than 30.*/
</I>&gt;<i> +static int oc_block_run_bits(int _run_count){
</I>&gt;<i> + &#160;return OC_BLOCK_RUN_CODE_NBITS[_run_count-1];
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*State to track coded block flags and their bit cost.*/
</I>&gt;<i> +struct oc_fr_state{
</I>&gt;<i> + &#160;ptrdiff_t &#160;bits;
</I>&gt;<i> + &#160;unsigned &#160; sb_partial_count:16;
</I>&gt;<i> + &#160;unsigned &#160; sb_full_count:16;
</I>&gt;<i> + &#160;unsigned &#160; b_coded_count_prev:8;
</I>&gt;<i> + &#160;unsigned &#160; b_coded_count:8;
</I>&gt;<i> + &#160;unsigned &#160; b_count:8;
</I>&gt;<i> + &#160;signed int sb_partial:2;
</I>&gt;<i> + &#160;signed int sb_full:2;
</I>&gt;<i> + &#160;signed int b_coded_prev:2;
</I>&gt;<i> + &#160;signed int b_coded:2;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void oc_fr_state_init(oc_fr_state *_fr){
</I>&gt;<i> + &#160;_fr-&gt;bits=0;
</I>&gt;<i> + &#160;_fr-&gt;sb_partial_count=0;
</I>&gt;<i> + &#160;_fr-&gt;sb_full_count=0;
</I>&gt;<i> + &#160;_fr-&gt;b_coded_count_prev=0;
</I>&gt;<i> + &#160;_fr-&gt;b_coded_count=0;
</I>&gt;<i> + &#160;_fr-&gt;b_count=0;
</I>&gt;<i> + &#160;_fr-&gt;sb_partial=-1;
</I>&gt;<i> + &#160;_fr-&gt;sb_full=-1;
</I>&gt;<i> + &#160;_fr-&gt;b_coded_prev=-1;
</I>&gt;<i> + &#160;_fr-&gt;b_coded=-1;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void oc_fr_state_advance_sb(oc_fr_state *_fr,
</I>&gt;<i> + int _sb_partial,int _sb_full){
</I>&gt;<i> + &#160;ptrdiff_t bits;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_partial_count;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_full_count;
</I>&gt;<i> + &#160;bits=_fr-&gt;bits;
</I>&gt;<i> + &#160;/*Extend the sb_partial run, or start a new one.*/
</I>&gt;<i> + &#160;sb_partial_count=_fr-&gt;sb_partial;
</I>&gt;<i> + &#160;if(_fr-&gt;sb_partial==_sb_partial){
</I>&gt;<i> + &#160; &#160;if(sb_partial_count&gt;=4129){
</I>&gt;<i> + &#160; &#160; &#160;bits++;
</I>&gt;<i> + &#160; &#160; &#160;sb_partial_count=0;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else bits-=oc_sb_run_bits(sb_partial_count);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else sb_partial_count=0;
</I>&gt;<i> + &#160;sb_partial_count++;
</I>&gt;<i> + &#160;bits+=oc_sb_run_bits(sb_partial_count);
</I>&gt;<i> + &#160;if(!_sb_partial){
</I>&gt;<i> + &#160; &#160;/*Extend the sb_full run, or start a new one.*/
</I>&gt;<i> + &#160; &#160;sb_full_count=_fr-&gt;sb_full_count;
</I>&gt;<i> + &#160; &#160;if(_fr-&gt;sb_full==_sb_full){
</I>&gt;<i> + &#160; &#160; &#160;if(sb_full_count&gt;=4129){
</I>&gt;<i> + &#160; &#160; &#160; &#160;bits++;
</I>&gt;<i> + &#160; &#160; &#160; &#160;sb_full_count=0;
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160;else bits-=oc_sb_run_bits(sb_full_count);
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else sb_full_count=0;
</I>&gt;<i> + &#160; &#160;sb_full_count++;
</I>&gt;<i> + &#160; &#160;bits+=oc_sb_run_bits(sb_full_count);
</I>&gt;<i> + &#160; &#160;_fr-&gt;sb_full=_sb_full;
</I>&gt;<i> + &#160; &#160;_fr-&gt;sb_full_count=sb_full_count;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;_fr-&gt;bits=bits;
</I>&gt;<i> + &#160;_fr-&gt;sb_partial=_sb_partial;
</I>&gt;<i> + &#160;_fr-&gt;sb_partial_count=sb_partial_count;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*Flush any outstanding block flags for a SB (e.g., one with fewer than 16
</I>&gt;<i> + &#160; blocks).*/
</I>&gt;<i> +static void oc_fr_state_flush_sb(oc_fr_state *_fr){
</I>&gt;<i> + &#160;ptrdiff_t bits;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_partial;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_full=sb_full;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; b_coded_count;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; b_coded;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; b_count;
</I>&gt;<i> + &#160;b_count=_fr-&gt;b_count;
</I>&gt;<i> + &#160;if(b_count&gt;0){
</I>&gt;<i> + &#160; &#160;bits=_fr-&gt;bits;
</I>&gt;<i> + &#160; &#160;b_coded=_fr-&gt;b_coded;
</I>&gt;<i> + &#160; &#160;b_coded_count=_fr-&gt;b_coded_count;
</I>&gt;<i> + &#160; &#160;if(b_coded_count&gt;=b_count){
</I>&gt;<i> + &#160; &#160; &#160;/*This SB was fully coded/uncoded; roll back the partial block flags.*/
</I>&gt;<i> + &#160; &#160; &#160;bits-=oc_block_run_bits(b_coded_count);
</I>&gt;<i> + &#160; &#160; &#160;if(b_coded_count&gt;b_count)bits+=oc_block_run_bits(b_coded_count-b_count);
</I>&gt;<i> + &#160; &#160; &#160;sb_partial=0;
</I>&gt;<i> + &#160; &#160; &#160;sb_full=b_coded;
</I>&gt;<i> + &#160; &#160; &#160;b_coded=_fr-&gt;b_coded_prev;
</I>&gt;<i> + &#160; &#160; &#160;b_coded_count=_fr-&gt;b_coded_count_prev;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;/*It was partially coded.*/
</I>&gt;<i> + &#160; &#160; &#160;sb_partial=1;
</I>&gt;<i> + &#160; &#160; &#160;/*sb_full is unused.*/
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;_fr-&gt;bits=bits;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_count=b_coded_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_count_prev=b_coded_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_count=0;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded=b_coded;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_prev=b_coded;
</I>&gt;<i> + &#160; &#160;oc_fr_state_advance_sb(_fr,sb_partial,sb_full);
</I>&gt;<i> + &#160;}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void oc_fr_state_advance_block(oc_fr_state *_fr,int _b_coded){
</I>&gt;<i> + &#160;ptrdiff_t bits;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; b_coded_count;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; b_count;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_partial;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; sb_full=sb_full;
</I>&gt;<i> + &#160;bits=_fr-&gt;bits;
</I>&gt;<i> + &#160;/*Extend the b_coded run, or start a new one.*/
</I>&gt;<i> + &#160;b_coded_count=_fr-&gt;b_coded_count;
</I>&gt;<i> + &#160;if(_fr-&gt;b_coded==_b_coded)bits-=oc_block_run_bits(b_coded_count);
</I>&gt;<i> + &#160;else b_coded_count=0;
</I>&gt;<i> + &#160;b_coded_count++;
</I>&gt;<i> + &#160;b_count=_fr-&gt;b_count+1;
</I>&gt;<i> + &#160;if(b_count&gt;=16){
</I>&gt;<i> + &#160; &#160;/*We finished a superblock.*/
</I>&gt;<i> + &#160; &#160;if(b_coded_count&gt;=16){
</I>&gt;<i> + &#160; &#160; &#160;/*It was fully coded/uncoded; roll back the partial block flags.*/
</I>&gt;<i> + &#160; &#160; &#160;if(b_coded_count&gt;16)bits+=oc_block_run_bits(b_coded_count-16);
</I>&gt;<i> + &#160; &#160; &#160;sb_partial=0;
</I>&gt;<i> + &#160; &#160; &#160;sb_full=_b_coded;
</I>&gt;<i> + &#160; &#160; &#160;_b_coded=_fr-&gt;b_coded_prev;
</I>&gt;<i> + &#160; &#160; &#160;b_coded_count=_fr-&gt;b_coded_count_prev;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;bits+=oc_block_run_bits(b_coded_count);
</I>&gt;<i> + &#160; &#160; &#160;/*It was partially coded.*/
</I>&gt;<i> + &#160; &#160; &#160;sb_partial=1;
</I>&gt;<i> + &#160; &#160; &#160;/*sb_full is unused.*/
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;_fr-&gt;bits=bits;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_count=b_coded_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_count_prev=b_coded_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_count=0;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded=_b_coded;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_prev=_b_coded;
</I>&gt;<i> + &#160; &#160;oc_fr_state_advance_sb(_fr,sb_partial,sb_full);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else{
</I>&gt;<i> + &#160; &#160;bits+=oc_block_run_bits(b_coded_count);
</I>&gt;<i> + &#160; &#160;_fr-&gt;bits=bits;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded_count=b_coded_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_count=b_count;
</I>&gt;<i> + &#160; &#160;_fr-&gt;b_coded=_b_coded;
</I>&gt;<i> + &#160;}
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void oc_fr_skip_block(oc_fr_state *_fr){
</I>&gt;<i> + &#160;oc_fr_state_advance_block(_fr,0);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void oc_fr_code_block(oc_fr_state *_fr){
</I>&gt;<i> + &#160;oc_fr_state_advance_block(_fr,1);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int oc_fr_cost1(const oc_fr_state *_fr){
</I>&gt;<i> + &#160;oc_fr_state tmp;
</I>&gt;<i> + &#160;ptrdiff_t &#160; bits;
</I>&gt;<i> + &#160;*&amp;tmp=*_fr;
</I>&gt;<i> + &#160;oc_fr_skip_block(&amp;tmp);
</I>&gt;<i> + &#160;bits=tmp.bits;
</I>&gt;<i> + &#160;*&amp;tmp=*_fr;
</I>&gt;<i> + &#160;oc_fr_code_block(&amp;tmp);
</I>&gt;<i> + &#160;return (int)(tmp.bits-bits);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int oc_fr_cost4(const oc_fr_state *_pre,const oc_fr_state *_post){
</I>&gt;<i> + &#160;oc_fr_state tmp;
</I>&gt;<i> + &#160;*&amp;tmp=*_pre;
</I>&gt;<i> + &#160;oc_fr_skip_block(&amp;tmp);
</I>&gt;<i> + &#160;oc_fr_skip_block(&amp;tmp);
</I>&gt;<i> + &#160;oc_fr_skip_block(&amp;tmp);
</I>&gt;<i> + &#160;oc_fr_skip_block(&amp;tmp);
</I>&gt;<i> + &#160;return (int)(_post-&gt;bits-tmp.bits);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +struct oc_qii_state{
</I>&gt;<i> + &#160;ptrdiff_t &#160;bits;
</I>&gt;<i> + &#160;unsigned &#160; qi01_count:14;
</I>&gt;<i> + &#160;signed int qi01:2;
</I>&gt;<i> + &#160;unsigned &#160; qi12_count:14;
</I>&gt;<i> + &#160;signed int qi12:2;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void oc_qii_state_init(oc_qii_state *_qs){
</I>&gt;<i> + &#160;_qs-&gt;bits=0;
</I>&gt;<i> + &#160;_qs-&gt;qi01_count=0;
</I>&gt;<i> + &#160;_qs-&gt;qi01=-1;
</I>&gt;<i> + &#160;_qs-&gt;qi12_count=0;
</I>&gt;<i> + &#160;_qs-&gt;qi12=-1;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void oc_qii_state_advance(oc_qii_state *_qd,
</I>&gt;<i> + const oc_qii_state *_qs,int _qii){
</I>&gt;<i> + &#160;ptrdiff_t bits;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; qi01;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; qi01_count;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; qi12;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; qi12_count;
</I>&gt;<i> + &#160;bits=_qs-&gt;bits;
</I>&gt;<i> + &#160;qi01=_qii+1&gt;&gt;1;
</I>&gt;<i> + &#160;qi01_count=_qs-&gt;qi01_count;
</I>&gt;<i> + &#160;if(qi01==_qs-&gt;qi01){
</I>&gt;<i> + &#160; &#160;if(qi01_count&gt;=4129){
</I>&gt;<i> + &#160; &#160; &#160;bits++;
</I>&gt;<i> + &#160; &#160; &#160;qi01_count=0;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else bits-=oc_sb_run_bits(qi01_count);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else qi01_count=0;
</I>&gt;<i> + &#160;qi01_count++;
</I>&gt;<i> + &#160;bits+=oc_sb_run_bits(qi01_count);
</I>&gt;<i> + &#160;qi12_count=_qs-&gt;qi12_count;
</I>&gt;<i> + &#160;if(_qii){
</I>&gt;<i> + &#160; &#160;qi12=_qii&gt;&gt;1;
</I>&gt;<i> + &#160; &#160;if(qi12==_qs-&gt;qi12){
</I>&gt;<i> + &#160; &#160; &#160;if(qi12_count&gt;=4129){
</I>&gt;<i> + &#160; &#160; &#160; &#160;bits++;
</I>&gt;<i> + &#160; &#160; &#160; &#160;qi12_count=0;
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160;else bits-=oc_sb_run_bits(qi12_count);
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else qi12_count=0;
</I>&gt;<i> + &#160; &#160;qi12_count++;
</I>&gt;<i> + &#160; &#160;bits+=oc_sb_run_bits(qi12_count);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else qi12=_qs-&gt;qi12;
</I>&gt;<i> + &#160;_qd-&gt;bits=bits;
</I>&gt;<i> + &#160;_qd-&gt;qi01=qi01;
</I>&gt;<i> + &#160;_qd-&gt;qi01_count=qi01_count;
</I>&gt;<i> + &#160;_qd-&gt;qi12=qi12;
</I>&gt;<i> + &#160;_qd-&gt;qi12_count=qi12_count;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*Temporary encoder state for the analysis pipeline.*/
</I>&gt;<i> +struct oc_enc_pipeline_state{
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; bounding_values[256];
</I>&gt;<i> + &#160;oc_fr_state &#160; &#160; &#160; &#160; fr[3];
</I>&gt;<i> + &#160;oc_qii_state &#160; &#160; &#160; &#160;qs[3];
</I>&gt;<i> + &#160;/*Condensed dequantization tables.*/
</I>&gt;<i> + &#160;const ogg_uint16_t *dequant[3][3][2];
</I>&gt;<i> + &#160;/*Condensed quantization tables.*/
</I>&gt;<i> + &#160;const oc_iquant &#160; &#160;*enquant[3][3][2];
</I>&gt;<i> + &#160;/*Skip SSD storage for the current MCU in each plane.*/
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; *skip_ssd[3];
</I>&gt;<i> + &#160;/*Coded/uncoded fragment lists for each plane for the current MCU.*/
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160;*coded_fragis[3];
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160;*uncoded_fragis[3];
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; ncoded_fragis[3];
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; nuncoded_fragis[3];
</I>&gt;<i> + &#160;/*The starting fragment for the current MCU in each plane.*/
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; froffset[3];
</I>&gt;<i> + &#160;/*The starting row for the current MCU in each plane.*/
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; fragy0[3];
</I>&gt;<i> + &#160;/*The ending row for the current MCU in each plane.*/
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; fragy_end[3];
</I>&gt;<i> + &#160;/*The starting superblock for the current MCU in each plane.*/
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; &#160;sbi0[3];
</I>&gt;<i> + &#160;/*The ending superblock for the current MCU in each plane.*/
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; &#160;sbi_end[3];
</I>&gt;<i> + &#160;/*The number of tokens for zzi=1 for each color plane.*/
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ndct_tokens1[3];
</I>&gt;<i> + &#160;/*The outstanding eob_run count for zzi=1 for each color plane.*/
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; eob_run1[3];
</I>&gt;<i> + &#160;/*Whether or not the loop filter is enabled.*/
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; loop_filter;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static void oc_enc_pipeline_init(oc_enc_ctx *_enc,oc_enc_pipeline_state *_pipe){
</I>&gt;<i> + &#160;ptrdiff_t *coded_fragis;
</I>&gt;<i> + &#160;unsigned &#160; mcu_nvsbs;
</I>&gt;<i> + &#160;ptrdiff_t &#160;mcu_nfrags;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160;hdec;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160;vdec;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160;pli;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160;qii;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160;qti;
</I>&gt;<i> + &#160;/*Initialize the per-plane coded block flag trackers.
</I>&gt;<i> + &#160; &#160;These are used for bit-estimation purposes only; the real flag bits span
</I>&gt;<i> + &#160; &#160; all three planes, so we can't compute them in parallel.*/
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++)oc_fr_state_init(_pipe-&gt;fr+pli);
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++)oc_qii_state_init(_pipe-&gt;qs+pli);
</I>&gt;<i> + &#160;/*Set up the per-plane skip SSD storage pointers.*/
</I>&gt;<i> + &#160;mcu_nvsbs=_enc-&gt;mcu_nvsbs;
</I>&gt;<i> + &#160;mcu_nfrags=mcu_nvsbs*_enc-&gt;state.fplanes[0].nhsbs*16;
</I>&gt;<i> + &#160;hdec=!(_enc-&gt;state.info.pixel_fmt&amp;1);
</I>&gt;<i> + &#160;vdec=!(_enc-&gt;state.info.pixel_fmt&amp;2);
</I>&gt;<i> + &#160;_pipe-&gt;skip_ssd[0]=_enc-&gt;mcu_skip_ssd;
</I>&gt;<i> + &#160;_pipe-&gt;skip_ssd[1]=_pipe-&gt;skip_ssd[0]+mcu_nfrags;
</I>&gt;<i> + &#160;_pipe-&gt;skip_ssd[2]=_pipe-&gt;skip_ssd[1]+(mcu_nfrags&gt;&gt;hdec+vdec);
</I>&gt;<i> + &#160;/*Set up per-plane pointers to the coded and uncoded fragments lists.
</I>&gt;<i> + &#160; &#160;Unlike the decoder, each planes' coded and uncoded fragment list is kept
</I>&gt;<i> + &#160; &#160; separate during the analysis stage; we only make the coded list for all
</I>&gt;<i> + &#160; &#160; three planes contiguous right before the final packet is output
</I>&gt;<i> + &#160; &#160; (destroying the uncoded lists, which are no longer needed).*/
</I>&gt;<i> + &#160;coded_fragis=_enc-&gt;state.coded_fragis;
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++){
</I>&gt;<i> + &#160; &#160;_pipe-&gt;coded_fragis[pli]=coded_fragis;
</I>&gt;<i> + &#160; &#160;coded_fragis+=_enc-&gt;state.fplanes[pli].nfrags;
</I>&gt;<i> + &#160; &#160;_pipe-&gt;uncoded_fragis[pli]=coded_fragis;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;memset(_pipe-&gt;ncoded_fragis,0,sizeof(_pipe-&gt;ncoded_fragis));
</I>&gt;<i> + &#160;memset(_pipe-&gt;nuncoded_fragis,0,sizeof(_pipe-&gt;nuncoded_fragis));
</I>&gt;<i> + &#160;/*Set up condensed quantizer tables.*/
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++){
</I>&gt;<i> + &#160; &#160;for(qii=0;qii&lt;_enc-&gt;state.nqis;qii++){
</I>&gt;<i> + &#160; &#160; &#160;int qi;
</I>&gt;<i> + &#160; &#160; &#160;qi=_enc-&gt;state.qis[qii];
</I>&gt;<i> + &#160; &#160; &#160;for(qti=0;qti&lt;2;qti++){
</I>&gt;<i> + &#160; &#160; &#160; &#160;_pipe-&gt;dequant[pli][qii][qti]=_enc-&gt;state.dequant_tables[qi][pli][qti];
</I>&gt;<i> + &#160; &#160; &#160; &#160;_pipe-&gt;enquant[pli][qii][qti]=_enc-&gt;enquant_tables[qi][pli][qti];
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;/*Initialize the tokenization state.*/
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++){
</I>&gt;<i> + &#160; &#160;_pipe-&gt;ndct_tokens1[pli]=0;
</I>&gt;<i> + &#160; &#160;_pipe-&gt;eob_run1[pli]=0;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;/*Initialize the bounding value array for the loop filter.*/
</I>&gt;<i> + &#160;_pipe-&gt;loop_filter=!oc_state_loop_filter_init(&amp;_enc-&gt;state,
</I>&gt;<i> + &#160; _pipe-&gt;bounding_values);
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +/*Sets the current MCU stripe to super block row _sby.
</I>&gt;<i> + &#160;Return: A non-zero value if this was the last MCU.*/
</I>&gt;<i> +static int oc_enc_pipeline_set_stripe(oc_enc_ctx *_enc,
</I>&gt;<i> + oc_enc_pipeline_state *_pipe,int _sby){
</I>&gt;<i> + &#160;const oc_fragment_plane *fplane;
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mcu_nvsbs;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;sby_end;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;notdone;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;vdec;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;pli;
</I>&gt;<i> + &#160;mcu_nvsbs=_enc-&gt;mcu_nvsbs;
</I>&gt;<i> + &#160;sby_end=_enc-&gt;state.fplanes[0].nvsbs;
</I>&gt;<i> + &#160;notdone=_sby+mcu_nvsbs&lt;sby_end;
</I>&gt;<i> + &#160;if(notdone)sby_end=_sby+mcu_nvsbs;
</I>&gt;<i> + &#160;vdec=0;
</I>&gt;<i> + &#160;for(pli=0;pli&lt;3;pli++){
</I>&gt;<i> + &#160; &#160;fplane=_enc-&gt;state.fplanes+pli;
</I>&gt;<i> + &#160; &#160;_pipe-&gt;sbi0[pli]=fplane-&gt;sboffset+(_sby&gt;&gt;vdec)*fplane-&gt;nhsbs;
</I>&gt;<i> + &#160; &#160;_pipe-&gt;fragy0[pli]=_sby&lt;&lt;2-vdec;
</I>&gt;<i> + &#160; &#160;_pipe-&gt;froffset[pli]=fplane-&gt;froffset
</I>&gt;<i> + &#160; &#160; +_pipe-&gt;fragy0[pli]*(ptrdiff_t)fplane-&gt;nhfrags;
</I>&gt;<i> + &#160; &#160;if(notdone){
</I>&gt;<i> + &#160; &#160; &#160;_pipe-&gt;sbi_end[pli]=fplane-&gt;sboffset+(sby_end&gt;&gt;vdec)*fplane-&gt;nhsbs;
</I>&gt;<i> + &#160; &#160; &#160;_pipe-&gt;fragy_end[pli]=sby_end&lt;&lt;2-vdec;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;_pipe-&gt;sbi_end[pli]=fplane-&gt;sboffset+fplane-&gt;nsbs;
</I>&gt;<i> + &#160; &#160; &#160;_pipe-&gt;fragy_end[pli]=fplane-&gt;nvfrags;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;vdec=!(_enc-&gt;state.info.pixel_fmt&amp;2);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;return notdone;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static void oc_enc_pipeline_finish_mcu_plane(oc_enc_ctx *_enc,
</I>&gt;<i> + oc_enc_pipeline_state *_pipe,int _pli,int _sdelay,int _edelay){
</I>&gt;<i> + &#160;int refi;
</I>&gt;<i> + &#160;/*Copy over all the uncoded fragments from this plane and advance the uncoded
</I>&gt;<i> + &#160; &#160; fragment list.*/
</I>&gt;<i> + &#160;_pipe-&gt;uncoded_fragis[_pli]-=_pipe-&gt;nuncoded_fragis[_pli];
</I>&gt;<i> + &#160;oc_state_frag_copy_list(&amp;_enc-&gt;state,_pipe-&gt;uncoded_fragis[_pli],
</I>&gt;<i> + &#160; _pipe-&gt;nuncoded_fragis[_pli],OC_FRAME_SELF,OC_FRAME_PREV,_pli);
</I>&gt;<i> + &#160;_pipe-&gt;nuncoded_fragis[_pli]=0;
</I>&gt;<i> + &#160;/*Perform DC prediction.*/
</I>&gt;<i> + &#160;oc_enc_pred_dc_frag_rows(_enc,_pli,
</I>&gt;<i> + &#160; _pipe-&gt;fragy0[_pli],_pipe-&gt;fragy_end[_pli]);
</I>&gt;<i> + &#160;/*Finish DC tokenization.*/
</I>&gt;<i> + &#160;oc_enc_tokenize_dc_frag_list(_enc,_pli,
</I>&gt;<i> + &#160; _pipe-&gt;coded_fragis[_pli],_pipe-&gt;ncoded_fragis[_pli],
</I>&gt;<i> + &#160; _pipe-&gt;ndct_tokens1[_pli],_pipe-&gt;eob_run1[_pli]);
</I>&gt;<i> + &#160;_pipe-&gt;ndct_tokens1[_pli]=_enc-&gt;ndct_tokens[_pli][1];
</I>&gt;<i> + &#160;_pipe-&gt;eob_run1[_pli]=_enc-&gt;eob_run[_pli][1];
</I>&gt;<i> + &#160;/*And advance the coded fragment list.*/
</I>&gt;<i> + &#160;_enc-&gt;state.ncoded_fragis[_pli]+=_pipe-&gt;ncoded_fragis[_pli];
</I>&gt;<i> + &#160;_pipe-&gt;coded_fragis[_pli]+=_pipe-&gt;ncoded_fragis[_pli];
</I>&gt;<i> + &#160;_pipe-&gt;ncoded_fragis[_pli]=0;
</I>&gt;<i> + &#160;/*Apply the loop filter if necessary.*/
</I>&gt;<i> + &#160;refi=_enc-&gt;state.ref_frame_idx[OC_FRAME_SELF];
</I>&gt;<i> + &#160;if(_pipe-&gt;loop_filter){
</I>&gt;<i> + &#160; &#160;oc_state_loop_filter_frag_rows(&amp;_enc-&gt;state,_pipe-&gt;bounding_values,
</I>&gt;<i> + &#160; &#160; refi,_pli,_pipe-&gt;fragy0[_pli]-_sdelay,_pipe-&gt;fragy_end[_pli]-_edelay);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else _sdelay=_edelay=0;
</I>&gt;<i> + &#160;/*To fill borders, we have an additional two pixel delay, since a fragment
</I>&gt;<i> + &#160; &#160; in the next row could filter its top edge, using two pixels from a
</I>&gt;<i> + &#160; &#160; fragment in this row.
</I>&gt;<i> + &#160; &#160;But there's no reason to delay a full fragment between the two.*/
</I>&gt;<i> + &#160;oc_state_borders_fill_rows(&amp;_enc-&gt;state,refi,_pli,
</I>&gt;<i> + &#160; (_pipe-&gt;fragy0[_pli]-_sdelay&lt;&lt;3)-(_sdelay&lt;&lt;1),
</I>&gt;<i> + &#160; (_pipe-&gt;fragy_end[_pli]-_edelay&lt;&lt;3)-(_edelay&lt;&lt;1));
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +/*Cost information about the coded blocks in a MB.*/
</I>&gt;<i> +struct oc_rd_metric{
</I>&gt;<i> + &#160;int uncoded_ac_ssd;
</I>&gt;<i> + &#160;int coded_ac_ssd;
</I>&gt;<i> + &#160;int ac_bits;
</I>&gt;<i> + &#160;int dc_flag;
</I>&gt;<i> +};
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +
</I>&gt;<i> +static int oc_enc_block_transform_quantize(oc_enc_ctx *_enc,
</I>&gt;<i> + oc_enc_pipeline_state *_pipe,int _pli,ptrdiff_t _fragi,int _overhead_bits,
</I>&gt;<i> + oc_rd_metric *_mo,oc_token_checkpoint **_stack){
</I>&gt;<i> + &#160;OC_ALIGN16(ogg_int16_t &#160;dct[64]);
</I>&gt;<i> + &#160;OC_ALIGN16(ogg_int16_t &#160;data[64]);
</I>&gt;<i> + &#160;ogg_uint16_t &#160; &#160; &#160; &#160; &#160; &#160;dc_dequant;
</I>&gt;<i> + &#160;const ogg_uint16_t &#160; &#160; *dequant;
</I>&gt;<i> + &#160;const oc_iquant &#160; &#160; &#160; &#160;*enquant;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; &#160; &#160; frag_offs;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ystride;
</I>&gt;<i> + &#160;const unsigned char &#160; &#160;*src;
</I>&gt;<i> + &#160;const unsigned char &#160; &#160;*ref;
</I>&gt;<i> + &#160;unsigned char &#160; &#160; &#160; &#160; &#160;*dst;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; frame_type;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nonzero;
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;uncoded_ssd;
</I>&gt;<i> + &#160;unsigned &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;coded_ssd;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; coded_dc;
</I>&gt;<i> + &#160;oc_token_checkpoint &#160; &#160;*checkpoint;
</I>&gt;<i> + &#160;oc_fragment &#160; &#160; &#160; &#160; &#160; &#160;*frags;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mb_mode;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; mv_offs[2];
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; nmv_offs;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; ac_bits;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; borderi;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; qti;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; qii;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; pi;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; zzi;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; v;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; val;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; d;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; s;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; dc;
</I>&gt;<i> + &#160;frags=_enc-&gt;state.frags;
</I>&gt;<i> + &#160;frag_offs=_enc-&gt;state.frag_buf_offs[_fragi];
</I>&gt;<i> + &#160;ystride=_enc-&gt;state.ref_ystride[_pli];
</I>&gt;<i> + &#160;src=_enc-&gt;state.ref_frame_data[OC_FRAME_IO]+frag_offs;
</I>&gt;<i> + &#160;borderi=frags[_fragi].borderi;
</I>&gt;<i> + &#160;qii=frags[_fragi].qii;
</I>&gt;<i> + &#160;if(qii&amp;~3){
</I>&gt;<i> +#if !defined(OC_COLLECT_METRICS)
</I>&gt;<i> + &#160; &#160;if(_enc-&gt;sp_level&gt;=OC_SP_LEVEL_EARLY_SKIP){
</I>&gt;<i> + &#160; &#160; &#160;/*Enable early skip detection.*/
</I>&gt;<i> + &#160; &#160; &#160;frags[_fragi].coded=0;
</I>&gt;<i> + &#160; &#160; &#160;return 0;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> +#endif
</I>&gt;<i> + &#160; &#160;/*Try and code this block anyway.*/
</I>&gt;<i> + &#160; &#160;qii&amp;=3;
</I>&gt;<i> + &#160; &#160;frags[_fragi].qii=qii;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;mb_mode=frags[_fragi].mb_mode;
</I>&gt;<i> + &#160;ref=_enc-&gt;state.ref_frame_data[
</I>&gt;<i> + &#160; _enc-&gt;state.ref_frame_idx[OC_FRAME_FOR_MODE(mb_mode)]]+frag_offs;
</I>&gt;<i> + &#160;dst=_enc-&gt;state.ref_frame_data[_enc-&gt;state.ref_frame_idx[OC_FRAME_SELF]]
</I>&gt;<i> + &#160; +frag_offs;
</I>&gt;<i> + &#160;/*Motion compensation:*/
</I>&gt;<i> + &#160;switch(mb_mode){
</I>&gt;<i> + &#160; &#160;case OC_MODE_INTRA:{
</I>&gt;<i> + &#160; &#160; &#160;nmv_offs=0;
</I>&gt;<i> + &#160; &#160; &#160;oc_enc_frag_sub_128(_enc,data,src,ystride);
</I>&gt;<i> + &#160; &#160;}break;
</I>&gt;<i> + &#160; &#160;case OC_MODE_GOLDEN_NOMV:
</I>&gt;<i> + &#160; &#160;case OC_MODE_INTER_NOMV:{
</I>&gt;<i> + &#160; &#160; &#160;nmv_offs=1;
</I>&gt;<i> + &#160; &#160; &#160;mv_offs[0]=0;
</I>&gt;<i> + &#160; &#160; &#160;oc_enc_frag_sub(_enc,data,src,ref,ystride);
</I>&gt;<i> + &#160; &#160;}break;
</I>&gt;<i> + &#160; &#160;default:{
</I>&gt;<i> + &#160; &#160; &#160;const oc_mv *frag_mvs;
</I>&gt;<i> + &#160; &#160; &#160;frag_mvs=(const oc_mv *)_enc-&gt;state.frag_mvs;
</I>&gt;<i> + &#160; &#160; &#160;nmv_offs=oc_state_get_mv_offsets(&amp;_enc-&gt;state,mv_offs,_pli,
</I>&gt;<i> + &#160; &#160; &#160; frag_mvs[_fragi][0],frag_mvs[_fragi][1]);
</I>&gt;<i> + &#160; &#160; &#160;if(nmv_offs&gt;1){
</I>&gt;<i> + &#160; &#160; &#160; &#160;oc_enc_frag_copy2(_enc,dst,
</I>&gt;<i> + &#160; &#160; &#160; &#160; ref+mv_offs[0],ref+mv_offs[1],ystride);
</I>&gt;<i> + &#160; &#160; &#160; &#160;oc_enc_frag_sub(_enc,data,src,dst,ystride);
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160; &#160;else oc_enc_frag_sub(_enc,data,src,ref+mv_offs[0],ystride);
</I>&gt;<i> + &#160; &#160;}break;
</I>&gt;<i> + &#160;}
</I>&gt;<i> +#if defined(OC_COLLECT_METRICS)
</I>&gt;<i> + &#160;{
</I>&gt;<i> + &#160; &#160;unsigned satd;
</I>&gt;<i> + &#160; &#160;switch(nmv_offs){
</I>&gt;<i> + &#160; &#160; &#160;case 0:satd=oc_enc_frag_intra_satd(_enc,src,ystride);break;
</I>&gt;<i> + &#160; &#160; &#160;case 1:{
</I>&gt;<i> + &#160; &#160; &#160; &#160;satd=oc_enc_frag_satd_thresh(_enc,src,ref+mv_offs[0],ystride,UINT_MAX);
</I>&gt;<i> + &#160; &#160; &#160;}break;
</I>&gt;<i> + &#160; &#160; &#160;default:{
</I>&gt;<i> + &#160; &#160; &#160; &#160;satd=oc_enc_frag_satd_thresh(_enc,src,dst,ystride,UINT_MAX);
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;_enc-&gt;frag_satd[_fragi]=satd;
</I>&gt;<i> + &#160;}
</I>&gt;<i> +#endif
</I>&gt;<i> + &#160;/*Transform:*/
</I>&gt;<i> + &#160;oc_enc_fdct8x8(_enc,dct,data);
</I>&gt;<i> + &#160;/*Quantize the DC coefficient:*/
</I>&gt;<i> + &#160;qti=mb_mode!=OC_MODE_INTRA;
</I>&gt;<i> + &#160;enquant=_pipe-&gt;enquant[_pli][0][qti];
</I>&gt;<i> + &#160;dc_dequant=_pipe-&gt;dequant[_pli][0][qti][0];
</I>&gt;<i> + &#160;v=dct[0];
</I>&gt;<i> + &#160;val=v&lt;&lt;1;
</I>&gt;<i> + &#160;s=OC_SIGNMASK(val);
</I>&gt;<i> + &#160;val+=dc_dequant+s^s;
</I>&gt;<i> + &#160;val=((enquant[0].m*(ogg_int32_t)val&gt;&gt;16)+val&gt;&gt;enquant[0].l)-s;
</I>&gt;<i> + &#160;dc=OC_CLAMPI(-580,val,580);
</I>&gt;<i> + &#160;nonzero=0;
</I>&gt;<i> + &#160;/*Quantize the AC coefficients:*/
</I>&gt;<i> + &#160;dequant=_pipe-&gt;dequant[_pli][qii][qti];
</I>&gt;<i> + &#160;enquant=_pipe-&gt;enquant[_pli][qii][qti];
</I>&gt;<i> + &#160;for(zzi=1;zzi&lt;64;zzi++){
</I>&gt;<i> + &#160; &#160;v=dct[OC_FZIG_ZAG[zzi]];
</I>&gt;<i> + &#160; &#160;d=dequant[zzi];
</I>&gt;<i> + &#160; &#160;val=v&lt;&lt;1;
</I>&gt;<i> + &#160; &#160;v=abs(val);
</I>&gt;<i> + &#160; &#160;if(v&gt;=d){
</I>&gt;<i> + &#160; &#160; &#160;s=OC_SIGNMASK(val);
</I>&gt;<i> + &#160; &#160; &#160;/*The bias added here rounds ties away from zero, since token
</I>&gt;<i> + &#160; &#160; &#160; &#160; optimization can only decrease the magnitude of the quantized
</I>&gt;<i> + &#160; &#160; &#160; &#160; value.*/
</I>&gt;<i> + &#160; &#160; &#160;val+=d+s^s;
</I>&gt;<i> + &#160; &#160; &#160;/*Note the arithmetic right shift is not guaranteed by ANSI C.
</I>&gt;<i> + &#160; &#160; &#160; &#160;Hopefully no one still uses ones-complement architectures.*/
</I>&gt;<i> + &#160; &#160; &#160;val=((enquant[zzi].m*(ogg_int32_t)val&gt;&gt;16)+val&gt;&gt;enquant[zzi].l)-s;
</I>&gt;<i> + &#160; &#160; &#160;data[zzi]=OC_CLAMPI(-580,val,580);
</I>&gt;<i> + &#160; &#160; &#160;nonzero=zzi;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else data[zzi]=0;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;/*Tokenize.*/
</I>&gt;<i> + &#160;checkpoint=*_stack;
</I>&gt;<i> + &#160;ac_bits=oc_enc_tokenize_ac(_enc,_pli,_fragi,data,dequant,dct,nonzero+1,
</I>&gt;<i> + &#160; _stack,qti?0:3);
</I>&gt;<i> + &#160;/*Reconstruct.
</I>&gt;<i> + &#160; &#160;TODO: nonzero may need to be adjusted after tokenization.*/
</I>&gt;<i> + &#160;if(nonzero==0){
</I>&gt;<i> + &#160; &#160;ogg_int16_t p;
</I>&gt;<i> + &#160; &#160;int &#160; &#160; &#160; &#160; ci;
</I>&gt;<i> + &#160; &#160;/*We round this dequant product (and not any of the others) because there's
</I>&gt;<i> + &#160; &#160; &#160; no iDCT rounding.*/
</I>&gt;<i> + &#160; &#160;p=(ogg_int16_t)(dc*(ogg_int32_t)dc_dequant+15&gt;&gt;5);
</I>&gt;<i> + &#160; &#160;/*LOOP VECTORIZES.*/
</I>&gt;<i> + &#160; &#160;for(ci=0;ci&lt;64;ci++)data[ci]=p;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;else{
</I>&gt;<i> + &#160; &#160;data[0]=dc*dc_dequant;
</I>&gt;<i> + &#160; &#160;oc_idct8x8(&amp;_enc-&gt;state,data,nonzero+1);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;if(!qti)oc_enc_frag_recon_intra(_enc,dst,ystride,data);
</I>&gt;<i> + &#160;else{
</I>&gt;<i> + &#160; &#160;oc_enc_frag_recon_inter(_enc,dst,
</I>&gt;<i> + &#160; &#160; nmv_offs==1?ref+mv_offs[0]:dst,ystride,data);
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;frame_type=_enc-&gt;state.frame_type;
</I>&gt;<i> +#if !defined(OC_COLLECT_METRICS)
</I>&gt;<i> + &#160;if(frame_type!=OC_INTRA_FRAME)
</I>&gt;<i> +#endif
</I>&gt;<i> + &#160;{
</I>&gt;<i> + &#160; &#160;/*In retrospect, should we have skipped this block?*/
</I>&gt;<i> + &#160; &#160;oc_enc_frag_sub(_enc,data,src,dst,ystride);
</I>&gt;<i> + &#160; &#160;coded_ssd=coded_dc=0;
</I>&gt;<i> + &#160; &#160;if(borderi&lt;0){
</I>&gt;<i> + &#160; &#160; &#160;for(pi=0;pi&lt;64;pi++){
</I>&gt;<i> + &#160; &#160; &#160; &#160;coded_ssd+=data[pi]*data[pi];
</I>&gt;<i> + &#160; &#160; &#160; &#160;coded_dc+=data[pi];
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;ogg_int64_t mask;
</I>&gt;<i> + &#160; &#160; &#160;mask=_enc-&gt;state.borders[borderi].mask;
</I>&gt;<i> + &#160; &#160; &#160;for(pi=0;pi&lt;64;pi++,mask&gt;&gt;=1)if(mask&amp;1){
</I>&gt;<i> + &#160; &#160; &#160; &#160;coded_ssd+=data[pi]*data[pi];
</I>&gt;<i> + &#160; &#160; &#160; &#160;coded_dc+=data[pi];
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;/*Scale to match DCT domain.*/
</I>&gt;<i> + &#160; &#160;coded_ssd&lt;&lt;=4;
</I>&gt;<i> + &#160; &#160;/*We actually only want the AC contribution to the SSD.*/
</I>&gt;<i> + &#160; &#160;coded_ssd-=coded_dc*coded_dc&gt;&gt;2;
</I>&gt;<i> +#if defined(OC_COLLECT_METRICS)
</I>&gt;<i> + &#160; &#160;_enc-&gt;frag_ssd[_fragi]=coded_ssd;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;if(frame_type!=OC_INTRA_FRAME){
</I>&gt;<i> +#endif
</I>&gt;<i> + &#160; &#160;uncoded_ssd=_pipe-&gt;skip_ssd[_pli][_fragi-_pipe-&gt;froffset[_pli]];
</I>&gt;<i> + &#160; &#160;if(uncoded_ssd&lt;UINT_MAX){
</I>&gt;<i> + &#160; &#160; &#160;/*Although the fragment coding overhead determination is accurate, it is
</I>&gt;<i> + &#160; &#160; &#160; &#160; greedy, using very coarse-grained local information.
</I>&gt;<i> + &#160; &#160; &#160; &#160;Allowing it to mildly discourage coding turns out to be beneficial, but
</I>&gt;<i> + &#160; &#160; &#160; &#160; it's not clear that allowing it to encourage coding through negative
</I>&gt;<i> + &#160; &#160; &#160; &#160; coding overhead deltas is useful.
</I>&gt;<i> + &#160; &#160; &#160; &#160;For that reason, we disallow negative coding_overheads.*/
</I>&gt;<i> + &#160; &#160; &#160;if(_overhead_bits&lt;0)_overhead_bits=0;
</I>&gt;<i> + &#160; &#160; &#160;if(uncoded_ssd&lt;=coded_ssd+(_overhead_bits+ac_bits)*_enc-&gt;lambda&amp;&amp;
</I>&gt;<i> + &#160; &#160; &#160; /*Don't allow luma blocks to be skipped in 4MV mode when VP3
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160;compatibility is enabled.*/
</I>&gt;<i> + &#160; &#160; &#160; (!_enc-&gt;vp3_compatible||mb_mode!=OC_MODE_INTER_MV_FOUR||_pli)){
</I>&gt;<i> + &#160; &#160; &#160; &#160;/*Hm, not worth it; roll back.*/
</I>&gt;<i> + &#160; &#160; &#160; &#160;oc_enc_tokenlog_rollback(_enc,checkpoint,(*_stack)-checkpoint);
</I>&gt;<i> + &#160; &#160; &#160; &#160;*_stack=checkpoint;
</I>&gt;<i> + &#160; &#160; &#160; &#160;frags[_fragi].coded=0;
</I>&gt;<i> + &#160; &#160; &#160; &#160;return 0;
</I>&gt;<i> + &#160; &#160; &#160;}
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else _mo-&gt;dc_flag=1;
</I>&gt;<i> + &#160; &#160;_mo-&gt;uncoded_ac_ssd+=uncoded_ssd;
</I>&gt;<i> + &#160; &#160;_mo-&gt;coded_ac_ssd+=coded_ssd;
</I>&gt;<i> + &#160; &#160;_mo-&gt;ac_bits+=ac_bits;
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;oc_qii_state_advance(_pipe-&gt;qs+_pli,_pipe-&gt;qs+_pli,qii);
</I>&gt;<i> + &#160;frags[_fragi].dc=dc;
</I>&gt;<i> + &#160;frags[_fragi].coded=1;
</I>&gt;<i> + &#160;return 1;
</I>&gt;<i> +}
</I>&gt;<i> +
</I>&gt;<i> +static int oc_enc_mb_transform_quantize_luma(oc_enc_ctx *_enc,
</I>&gt;<i> + oc_enc_pipeline_state *_pipe,unsigned _mbi,int _mode_overhead){
</I>&gt;<i> + &#160;/*Worst case token stack usage for 4 fragments.*/
</I>&gt;<i> + &#160;oc_token_checkpoint &#160;stack[64*4];
</I>&gt;<i> + &#160;oc_token_checkpoint *stackptr;
</I>&gt;<i> + &#160;const oc_sb_map &#160; &#160; *sb_maps;
</I>&gt;<i> + &#160;signed char &#160; &#160; &#160; &#160; *mb_modes;
</I>&gt;<i> + &#160;oc_fragment &#160; &#160; &#160; &#160; *frags;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; *coded_fragis;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; &#160;ncoded_fragis;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; *uncoded_fragis;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; &#160;nuncoded_fragis;
</I>&gt;<i> + &#160;oc_rd_metric &#160; &#160; &#160; &#160; mo;
</I>&gt;<i> + &#160;oc_fr_state &#160; &#160; &#160; &#160; &#160;fr_checkpoint;
</I>&gt;<i> + &#160;oc_qii_state &#160; &#160; &#160; &#160; qs_checkpoint;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;mb_mode;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;ncoded;
</I>&gt;<i> + &#160;ptrdiff_t &#160; &#160; &#160; &#160; &#160; &#160;fragi;
</I>&gt;<i> + &#160;int &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;bi;
</I>&gt;<i> + &#160;*&amp;fr_checkpoint=*(_pipe-&gt;fr+0);
</I>&gt;<i> + &#160;*&amp;qs_checkpoint=*(_pipe-&gt;qs+0);
</I>&gt;<i> + &#160;sb_maps=(const oc_sb_map *)_enc-&gt;state.sb_maps;
</I>&gt;<i> + &#160;mb_modes=_enc-&gt;state.mb_modes;
</I>&gt;<i> + &#160;frags=_enc-&gt;state.frags;
</I>&gt;<i> + &#160;coded_fragis=_pipe-&gt;coded_fragis[0];
</I>&gt;<i> + &#160;ncoded_fragis=_pipe-&gt;ncoded_fragis[0];
</I>&gt;<i> + &#160;uncoded_fragis=_pipe-&gt;uncoded_fragis[0];
</I>&gt;<i> + &#160;nuncoded_fragis=_pipe-&gt;nuncoded_fragis[0];
</I>&gt;<i> + &#160;mb_mode=mb_modes[_mbi];
</I>&gt;<i> + &#160;ncoded=0;
</I>&gt;<i> + &#160;stackptr=stack;
</I>&gt;<i> + &#160;memset(&amp;mo,0,sizeof(mo));
</I>&gt;<i> + &#160;for(bi=0;bi&lt;4;bi++){
</I>&gt;<i> + &#160; &#160;fragi=sb_maps[_mbi&gt;&gt;2][_mbi&amp;3][bi];
</I>&gt;<i> + &#160; &#160;frags[fragi].mb_mode=mb_mode;
</I>&gt;<i> + &#160; &#160;if(oc_enc_block_transform_quantize(_enc,
</I>&gt;<i> + &#160; &#160; _pipe,0,fragi,oc_fr_cost1(_pipe-&gt;fr+0),&amp;mo,&amp;stackptr)){
</I>&gt;<i> + &#160; &#160; &#160;oc_fr_code_block(_pipe-&gt;fr+0);
</I>&gt;<i> + &#160; &#160; &#160;coded_fragis[ncoded_fragis++]=fragi;
</I>&gt;<i> + &#160; &#160; &#160;ncoded++;
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160; &#160;else{
</I>&gt;<i> + &#160; &#160; &#160;*(uncoded_fragis-++nuncoded_fragis)=fragi;
</I>&gt;<i> + &#160; &#160; &#160;oc_fr_skip_block(_pipe-&gt;fr+0);
</I>&gt;<i> + &#160; &#160;}
</I>&gt;<i> + &#160;}
</I>&gt;<i> + &#160;if(_enc-&gt;state.frame_type!=OC_INTRA_FRAME){
</I>&gt;<i> + &#160; &#160;if(ncoded&gt;0&amp;&amp;!mo.dc_flag){
</I>&gt;<i> + &#160; &#160; &#160;int cost;
</I>&gt;<i> + &#160; &#160; &#160;/*Some individual blocks were worth coding.
</I>&gt;<i> + &#160; &#160; &#160; &#160;See if that's still true when accounting for mode and MV overhead.*/
</I>&gt;<i> + &#160; &#160; &#160;cost=mo.coded_ac_ssd+_enc-&gt;lambda*(mo.ac_bits
</I>&gt;<i> + &#160; &#160; &#160; +oc_fr_cost4(&amp;fr_checkpoint,_pipe-&gt;fr+0)+_mode_overhead);
</I>&gt;<i> + &#160; &#160; &#160;if(mo.uncoded_ac_ssd&lt;=cost){
</I>&gt;<i> + &#160; &#160; &#160; &#160;/*Taking macroblock overhead into account, it is not worth coding this
</I>&gt;<i> + &#160; &#160; &#160; &#160; &#160; MB.*/
</I>&gt;<i> + &#160; &#160; &#160; &#160;oc_enc_tokenlog_rollback(_enc,stack,stackptr-stack);
</I>&gt;<i> + &#160; &#160; &#160; &#160;*(_pipe-&gt;fr+0)=*&amp;fr_checkpoint;
</I>&gt;<i>
</I>&gt;<i> [... truncated: 31019 lines follow ...]
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Haiku-commits mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">Haiku-commits at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">https://lists.berlios.de/mailman/listinfo/haiku-commits</A>
</I>&gt;<i>
</I>


-- 
Cheers
David

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020978.html">[Haiku-commits] r33343 - in	haiku/trunk/src/add-ons/media/plugins/theora: . libtheora	libtheora/theora libtheora/x86
</A></li>
	<LI>Next message: <A HREF="020983.html">[Haiku-commits] r33343 - in haiku/trunk/src/add-ons/media/plugins/theora: . libtheora libtheora/theora libtheora/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20979">[ date ]</a>
              <a href="thread.html#20979">[ thread ]</a>
              <a href="subject.html#20979">[ subject ]</a>
              <a href="author.html#20979">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
