<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33351 - haiku/trunk/src/kits/network/libnetapi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33351%20-%20haiku/trunk/src/kits/network/libnetapi&In-Reply-To=%3C200909291408.n8TE8edW025521%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="021000.html">
   <LINK REL="Next"  HREF="021001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33351 - haiku/trunk/src/kits/network/libnetapi</H1>
    <B>mmlr at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33351%20-%20haiku/trunk/src/kits/network/libnetapi&In-Reply-To=%3C200909291408.n8TE8edW025521%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33351 - haiku/trunk/src/kits/network/libnetapi">mmlr at mail.berlios.de
       </A><BR>
    <I>Tue Sep 29 16:08:40 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="021000.html">[Haiku-commits] r33350 - haiku/trunk/src/preferences/locale
</A></li>
        <LI>Next message: <A HREF="021001.html">[Haiku-commits] r33352 - haiku/trunk/src/kits/network/libnetapi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20999">[ date ]</a>
              <a href="thread.html#20999">[ thread ]</a>
              <a href="subject.html#20999">[ subject ]</a>
              <a href="author.html#20999">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmlr
Date: 2009-09-29 16:08:39 +0200 (Tue, 29 Sep 2009)
New Revision: 33351
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33351&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33351&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/network/libnetapi/NetAddress.cpp
Log:
Space indent -&gt; tab indent.


Modified: haiku/trunk/src/kits/network/libnetapi/NetAddress.cpp
===================================================================
--- haiku/trunk/src/kits/network/libnetapi/NetAddress.cpp	2009-09-29 13:45:06 UTC (rev 33350)
+++ haiku/trunk/src/kits/network/libnetapi/NetAddress.cpp	2009-09-29 14:08:39 UTC (rev 33351)
@@ -34,7 +34,7 @@
 	:
 	fInit(B_NO_INIT)
 {
-    SetTo(hostname, port);
+	SetTo(hostname, port);
 }
 
 
@@ -58,7 +58,7 @@
 	:
 	fInit(B_NO_INIT)
 {
-    SetTo(addr, port);
+	SetTo(addr, port);
 }
 
 
@@ -79,21 +79,21 @@
 
 BNetAddress::BNetAddress(BMessage* archive)
 {
-    int16 int16value;
-    if (archive-&gt;FindInt16(&quot;bnaddr_family&quot;, &amp;int16value) != B_OK)
-        return;
+	int16 int16value;
+	if (archive-&gt;FindInt16(&quot;bnaddr_family&quot;, &amp;int16value) != B_OK)
+		return;
 
-    fFamily = int16value;
+	fFamily = int16value;
 
-    if (archive-&gt;FindInt16(&quot;bnaddr_port&quot;, &amp;int16value) != B_OK)
-        return;
+	if (archive-&gt;FindInt16(&quot;bnaddr_port&quot;, &amp;int16value) != B_OK)
+		return;
 
-    fPort = int16value;
+	fPort = int16value;
 
-    if (archive-&gt;FindInt32(&quot;bnaddr_addr&quot;, &amp;fAddress) != B_OK)
-        return;
+	if (archive-&gt;FindInt32(&quot;bnaddr_addr&quot;, &amp;fAddress) != B_OK)
+		return;
 
-    fInit = B_OK;
+	fInit = B_OK;
 }
 
 
@@ -105,145 +105,146 @@
 BNetAddress&amp;
 BNetAddress::operator=( const BNetAddress&amp; other)
 {
-    fInit = other.fInit;
-    fFamily = other.fFamily;
-    fPort = other.fPort;
-    fAddress = other.fAddress;
+	fInit = other.fInit;
+	fFamily = other.fFamily;
+	fPort = other.fPort;
+	fAddress = other.fAddress;
 
-    return *this;
+	return *this;
 }
 
 
 /* GetAddr
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Class accessor.
+ *		Class accessor.
  *
  * Output parameters:
- *     hostname     : Host name associated with this instance (default: NULL).
- *                    In this particular implementation, hostname will be an
- *                    ASCII-fied representation of an IP address.
- *     port         : Port number associated with this instance
- *                    (default: NULL).  Will be converted to host byte order
- *                    here, so it is not necessary to call ntohs() after
- *                    calling this method.
+ *		hostname:		Host name associated with this instance (default: NULL).
+ *						In this particular implementation, hostname will be an
+ *						ASCII-fied representation of an IP address.
  *
+ *		port:			Port number associated with this instance
+ *						(default: NULL).  Will be converted to host byte order
+ *						here, so it is not necessary to call ntohs() after
+ *						calling this method.
+ *
  * Returns:
- *     B_OK for success, B_NO_INIT if instance was not properly constructed.
+ *	B_OK for success, B_NO_INIT if instance was not properly constructed.
  *
  * Remarks:
- *     Hostname and/or port can be NULL; although having them both NULL would
- *     be a pointless waste of CPU cycles.  ;-)
+ *		Hostname and/or port can be NULL; although having them both NULL would
+ *		be a pointless waste of CPU cycles.  ;-)
  *
- *     The hostname output parameter can be a variety of things, but in this
- *     method we convert the IP address to a string.  See the relevant
- *     documentation about inet_ntoa() for details.
+ *		The hostname output parameter can be a variety of things, but in this
+ *		method we convert the IP address to a string.  See the relevant
+ *		documentation about inet_ntoa() for details.
  *
- *     Make sure hostname is large enough or you will step on someone
- *     else's toes.  (Can you say &quot;buffer overflow exploit&quot; boys and girls?)
- *     You can generally be safe using the MAXHOSTNAMELEN define, which
- *     defaults to 64 bytes--don't forget to leave room for the NULL!
+ *		Make sure hostname is large enough or you will step on someone
+ *		else's toes.  (Can you say &quot;buffer overflow exploit&quot; boys and girls?)
+ *		You can generally be safe using the MAXHOSTNAMELEN define, which
+ *		defaults to 64 bytes--don't forget to leave room for the NULL!
  */
 status_t
 BNetAddress::GetAddr(char* hostname, unsigned short* port) const
 {
-    if (fInit != B_OK)
-        return B_NO_INIT;
+	if (fInit != B_OK)
+		return B_NO_INIT;
 
-    if (port != NULL)
-        *port = ntohs(fPort);
+	if (port != NULL)
+		*port = ntohs(fPort);
 
-    if (hostname != NULL) {
-	    struct in_addr addr;
-    	addr.s_addr = fAddress;
+	if (hostname != NULL) {
+		struct in_addr addr;
+		addr.s_addr = fAddress;
 
-	    char* text = inet_ntoa(addr);
-        if (text != NULL)
-            strcpy(hostname, text);
-    }
+		char* text = inet_ntoa(addr);
+		if (text != NULL)
+			strcpy(hostname, text);
+	}
 
-    return B_OK;
+	return B_OK;
 }
 
 
 /* GetAddr
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Class accessor.
+ *		Class accessor.
  *
  * Output parameter:
- *     sa           : sockaddr_in struct to be filled.
+ *		sa:					sockaddr_in struct to be filled.
  *
  * Returns:
- *     B_OK for success, B_NO_INIT if instance was not properly constructed.
+ *		B_OK for success, B_NO_INIT if instance was not properly constructed.
  *
  * Remarks:
- *     This method fills in the sin_addr, sin_family, and sin_port fields of
- *     the output parameter, all other fields are untouched so we can work
- *     with both POSIX and non-POSIX versions of said struct.  The port and
- *     address values added to the output parameter are in network byte order.
+ *		This method fills in the sin_addr, sin_family, and sin_port fields of
+ *		the output parameter, all other fields are untouched so we can work
+ *		with both POSIX and non-POSIX versions of said struct.  The port and
+ *		address values added to the output parameter are in network byte order.
  */
 status_t BNetAddress::GetAddr( struct sockaddr_in&amp; sa ) const
 {
-    if ( fInit != B_OK )
-        return B_NO_INIT;
+	if ( fInit != B_OK )
+		return B_NO_INIT;
 
-    sa.sin_port = fPort;
-    sa.sin_addr.s_addr = fAddress;
+	sa.sin_port = fPort;
+	sa.sin_addr.s_addr = fAddress;
 	if (check_r5_compatibility()) {
-	    r5_sockaddr_in* r5Addr = (r5_sockaddr_in *)&sa;
-    	if (fFamily == AF_INET)
-    		r5Addr-&gt;sin_family = R5_AF_INET;
-    	else
-    		r5Addr-&gt;sin_family = fFamily;
-    } else
-        sa.sin_family = fFamily;
+		r5_sockaddr_in* r5Addr = (r5_sockaddr_in *)&sa;
+		if (fFamily == AF_INET)
+			r5Addr-&gt;sin_family = R5_AF_INET;
+		else
+			r5Addr-&gt;sin_family = fFamily;
+	} else
+		sa.sin_family = fFamily;
 
-    return B_OK;
+	return B_OK;
 }
 
 
 /* GetAddr
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Class accessor.
+ *		Class accessor.
  *
  * Output parameters:
- *     addr         : in_addr struct to fill.
- *     port         : optional port number to fill.
+ *		addr:			in_addr struct to fill.
+ *		port:			optional port number to fill.
  *
  * Returns:
- *     B_OK for success, B_NO_INIT if instance was not properly constructed.
+ *		B_OK for success, B_NO_INIT if instance was not properly constructed.
  *
  * Remarks:
- *     Output port will be in host byte order, but addr will be in the usual
- *     network byte order (ready to be used by other network functions).
+ *		Output port will be in host byte order, but addr will be in the usual
+ *		network byte order (ready to be used by other network functions).
  */
 status_t BNetAddress::GetAddr( in_addr&amp; addr, unsigned short* port ) const
 {
-    if ( fInit != B_OK )
-        return B_NO_INIT;
+	if ( fInit != B_OK )
+		return B_NO_INIT;
 
-    addr.s_addr = fAddress;
+	addr.s_addr = fAddress;
 
-    if ( port != NULL )
-        *port = ntohs(fPort);
+	if ( port != NULL )
+		*port = ntohs(fPort);
 
-    return B_OK;
+	return B_OK;
 }
 
 
 /* InitCheck
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Determine whether or not this instance is properly initialized.
+ *		Determine whether or not this instance is properly initialized.
  *
  * Returns:
- *     B_OK if this instance is initialized, B_ERROR if not.
+ *		B_OK if this instance is initialized, B_ERROR if not.
  */
 status_t BNetAddress::InitCheck( void ) const
 {
-    return ( fInit == B_OK ) ? B_OK : B_ERROR;
+	return ( fInit == B_OK ) ? B_OK : B_ERROR;
 }
 
 
@@ -256,82 +257,82 @@
 /* Archive
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Serialize this instance into the passed BMessage parameter.
+ *		Serialize this instance into the passed BMessage parameter.
  *
  * Input parameter:
- *     deep         : [ignored] default==true.
+ *		deep:			[ignored] default==true.
  *
  * Output parameter:
- *     into         : BMessage object to serialize into.
+ *		into:			BMessage object to serialize into.
  *
  * Returns:
- *     B_OK/BERROR on success/failure.  Returns B_NO_INIT if instance not
- *     properly initialized.
+ *		B_OK/BERROR on success/failure.  Returns B_NO_INIT if instance not
+ *		properly initialized.
  */
 status_t BNetAddress::Archive( BMessage* into, bool deep ) const
 {
-    if ( fInit != B_OK )
-        return B_NO_INIT;
+	if ( fInit != B_OK )
+		return B_NO_INIT;
 
-    if ( into-&gt;AddInt16( &quot;bnaddr_family&quot;, fFamily ) != B_OK )
-        return B_ERROR;
+	if ( into-&gt;AddInt16( &quot;bnaddr_family&quot;, fFamily ) != B_OK )
+		return B_ERROR;
 
-    if ( into-&gt;AddInt16( &quot;bnaddr_port&quot;, fPort ) != B_OK )
-        return B_ERROR;
+	if ( into-&gt;AddInt16( &quot;bnaddr_port&quot;, fPort ) != B_OK )
+		return B_ERROR;
 
-    if ( into-&gt;AddInt32( &quot;bnaddr_addr&quot;, fAddress ) != B_OK )
-        return B_ERROR;
+	if ( into-&gt;AddInt32( &quot;bnaddr_addr&quot;, fAddress ) != B_OK )
+		return B_ERROR;
 
-    return B_OK;
+	return B_OK;
 }
 
 
 /* Instantiate
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Un-serialize and instantiate from the passed BMessage parameter.
+ *		Un-serialize and instantiate from the passed BMessage parameter.
  *
  * Input parameter:
- *     archive      : Archived BMessage object for (de)serialization.
+ *		archive:		Archived BMessage object for (de)serialization.
  *
  * Returns:
- *     NULL if a BNetAddress instance can not be initialized, otherwise
- *     a new BNetAddress object instantiated from the BMessage parameter.
+ *		NULL if a BNetAddress instance can not be initialized, otherwise
+ *		a new BNetAddress object instantiated from the BMessage parameter.
  */
 BArchivable*
 BNetAddress::Instantiate(BMessage* archive)
 {
-    if (!validate_instantiation(archive, &quot;BNetAddress&quot;))
-        return NULL;
+	if (!validate_instantiation(archive, &quot;BNetAddress&quot;))
+		return NULL;
 
-    BNetAddress* address = new (std::nothrow) BNetAddress(archive);
-    if (address == NULL)
-        return NULL;
+	BNetAddress* address = new (std::nothrow) BNetAddress(archive);
+	if (address == NULL)
+		return NULL;
 
-    if (address-&gt;InitCheck() != B_OK) {
-        delete address;
-        return NULL;
-    }
+	if (address-&gt;InitCheck() != B_OK) {
+		delete address;
+		return NULL;
+	}
 
-    return address;
+	return address;
 }
 
 
 /* SetTo
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Set hostname and port network address data.
+ *	 Set hostname and port network address data.
  *
  * Input parameters:
- *     hostname     : Can be one of three things:
- *                    1. An ASCII-string representation of an IP address.
- *                    2. A canonical hostname.
- *                    3. NULL.  If NULL, then by default the address will be
- *                       set to INADDR_ANY (0.0.0.0).
- *     port         : Duh.
+ *		hostname:		Can be one of three things:
+ *						1. An ASCII-string representation of an IP address.
+ *						2. A canonical hostname.
+ *						3. NULL.  If NULL, then by default the address will be
+ *							set to INADDR_ANY (0.0.0.0).
+ *		port:			Duh.
  *
  * Returns:
- *     B_OK/B_ERROR for success/failure.
+ *		B_OK/B_ERROR for success/failure.
  */
 status_t
 BNetAddress::SetTo(const char* hostname, unsigned short port)
@@ -375,13 +376,13 @@
 	fAddress = addr.sin_addr.s_addr;
 
 	if (check_r5_compatibility()) {
-	    const r5_sockaddr_in* r5Addr = (const r5_sockaddr_in *)&addr;
-    	if (r5Addr-&gt;sin_family == R5_AF_INET)
-    		fFamily = AF_INET;
-    	else
-    		fFamily = r5Addr-&gt;sin_family;
-    } else
-    	fFamily = addr.sin_family;
+		const r5_sockaddr_in* r5Addr = (const r5_sockaddr_in *)&addr;
+		if (r5Addr-&gt;sin_family == R5_AF_INET)
+			fFamily = AF_INET;
+		else
+			fFamily = r5Addr-&gt;sin_family;
+	} else
+		fFamily = addr.sin_family;
 
 	return fInit = B_OK;
 }
@@ -428,38 +429,38 @@
 /* SetTo
  *=--------------------------------------------------------------------------=*
  * Purpose:
- *     Set from passed in hostname and protocol/service information.
+ *		Set from passed in hostname and protocol/service information.
  *
  * Input parameters:
- *     hostname     : Can be one of three things:
- *                    1. An ASCII-string representation of an IP address.
- *                    2. A canonical hostname.
- *                    3. NULL.  If NULL, then by default the address will be
- *                       set to INADDR_ANY (0.0.0.0).
- *     protocol     : Datagram type, typically &quot;TCP&quot; or &quot;UDP&quot;
- *     service      : The name of the service, such as http, ftp, et al.  This
- *                    must be one of the official service names listed in
- *                    /etc/services -- but you already knew that because
- *                    you're doing network/sockets programming, RIIIGHT???.
+ *		hostname:		Can be one of three things:
+ *						1. An ASCII-string representation of an IP address.
+ *						2. A canonical hostname.
+ *						3. NULL.  If NULL, then by default the address will be
+ *							set to INADDR_ANY (0.0.0.0).
+ *		protocol:		Datagram type, typically &quot;TCP&quot; or &quot;UDP&quot;
+ *		service:		The name of the service, such as http, ftp, et al. This
+ *						must be one of the official service names listed in
+ *						/etc/services -- but you already knew that because
+ *						you're doing network/sockets programming, RIIIGHT???.
  *
  * Returns:
- *     B_OK/B_ERROR on success/failure.
+ *		B_OK/B_ERROR on success/failure.
  *
  * Remarks:
- *     The protocol and service input parameters must be one of the official
- *     types listed in /etc/services.  We use these two parameters to
- *     determine the port number (see getservbyname(3)).  This method will
- *     fail if the aforementioned precondition is not met.
+ *		The protocol and service input parameters must be one of the official
+ *		types listed in /etc/services.  We use these two parameters to
+ *		determine the port number (see getservbyname(3)).  This method will
+ *		fail if the aforementioned precondition is not met.
  */
 status_t
 BNetAddress::SetTo(const char* hostname, const char* protocol,
 	const char* service)
 {
 	struct servent* serviceEntry = getservbyname(service, protocol);
-    if (serviceEntry == NULL)
-        return B_ERROR;
+	if (serviceEntry == NULL)
+		return B_ERROR;
 
-    return SetTo(hostname, serviceEntry-&gt;s_port);
+	return SetTo(hostname, serviceEntry-&gt;s_port);
 }
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="021000.html">[Haiku-commits] r33350 - haiku/trunk/src/preferences/locale
</A></li>
	<LI>Next message: <A HREF="021001.html">[Haiku-commits] r33352 - haiku/trunk/src/kits/network/libnetapi
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20999">[ date ]</a>
              <a href="thread.html#20999">[ thread ]</a>
              <a href="subject.html#20999">[ subject ]</a>
              <a href="author.html#20999">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
