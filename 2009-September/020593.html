<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33100 - in	haiku/branches/components/gallium3d/src/kits/opengl/gallium:	. auxiliary auxiliary/rbug drivers drivers/failover	drivers/i915simple drivers/softpipe drivers/trace
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33100%20-%20in%0A%09haiku/branches/components/gallium3d/src/kits/opengl/gallium%3A%0A%09.%20auxiliary%20auxiliary/rbug%20drivers%20drivers/failover%0A%09drivers/i915simple%20drivers/softpipe%20drivers/trace&In-Reply-To=%3C200909121647.n8CGld8p031326%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020592.html">
   <LINK REL="Next"  HREF="020594.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33100 - in	haiku/branches/components/gallium3d/src/kits/opengl/gallium:	. auxiliary auxiliary/rbug drivers drivers/failover	drivers/i915simple drivers/softpipe drivers/trace</H1>
    <B>aljen at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33100%20-%20in%0A%09haiku/branches/components/gallium3d/src/kits/opengl/gallium%3A%0A%09.%20auxiliary%20auxiliary/rbug%20drivers%20drivers/failover%0A%09drivers/i915simple%20drivers/softpipe%20drivers/trace&In-Reply-To=%3C200909121647.n8CGld8p031326%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33100 - in	haiku/branches/components/gallium3d/src/kits/opengl/gallium:	. auxiliary auxiliary/rbug drivers drivers/failover	drivers/i915simple drivers/softpipe drivers/trace">aljen at mail.berlios.de
       </A><BR>
    <I>Sat Sep 12 18:47:39 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020592.html">[Haiku-commits] r33099 - in haiku/branches/components/gallium3d:	headers/private headers/private/drm src/add-ons/kernel	src/add-ons/kernel/drivers src/add-ons/kernel/drivers/drm	src/add-ons/kernel/drivers/drm/test src/add-ons/kernel/drm
</A></li>
        <LI>Next message: <A HREF="020594.html">[Haiku-commits] r33101 - haiku/trunk/headers/os/device
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20593">[ date ]</a>
              <a href="thread.html#20593">[ thread ]</a>
              <a href="subject.html#20593">[ subject ]</a>
              <a href="author.html#20593">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: aljen
Date: 2009-09-12 18:47:18 +0200 (Sat, 12 Sep 2009)
New Revision: 33100
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33100&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33100&amp;view=rev</A>

Added:
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/README
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_context.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_context.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_core.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_core.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_demarshal.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_internal.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_proto.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_shader.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_shader.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_texture.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_texture.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/Jamfile
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/Jamfile
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/fo_context.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/fo_context.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/fo_state.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/fo_state_emit.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/failover/fo_winsys.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/Jamfile
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/README
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_buffer.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_buffer.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_context.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_context.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_drm.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_drm.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_dump.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_dump.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_dump_state.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_dump_state.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_rbug.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_screen.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_screen.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_state.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_state.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_texture.c
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/tr_texture.h
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/trace/trace.xsl
Modified:
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/Jamfile
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/i915simple/Jamfile
   haiku/branches/components/gallium3d/src/kits/opengl/gallium/drivers/softpipe/Jamfile
Log:
added failover, trace drivers and rbug from gallium

Modified: haiku/branches/components/gallium3d/src/kits/opengl/gallium/Jamfile
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/Jamfile	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/Jamfile	2009-09-12 16:47:18 UTC (rev 33100)
@@ -13,6 +13,7 @@
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary gallivm ] ;
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary indices ] ;
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary pipebuffer ] ;
+SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary rbug ] ;
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary rtasm ] ;
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary sct ] ;
 SEARCH_SOURCE += [ FDirName $(SUBDIR) auxiliary tgsi ] ;
@@ -115,6 +116,14 @@
 	pb_bufmgr_slab.c
 	pb_validate.c
 
+    # auxiliary/rbug
+    rbug_connection.c
+    rbug_context.c
+    rbug_core.c
+    rbug_demarshal.c
+    rbug_shader.c
+    rbug_texture.c
+
 	# auxiliary/rtasm
 	rtasm_cpu.c
 	rtasm_execmem.c
@@ -184,6 +193,5 @@
 	u_upload_mgr.c
 ;
 
-SubInclude HAIKU_TOP src kits opengl gallium drivers i915simple ;
-SubInclude HAIKU_TOP src kits opengl gallium drivers softpipe ;
+SubInclude HAIKU_TOP src kits opengl gallium drivers ;
 SubInclude HAIKU_TOP src kits opengl gallium state_trackers dri ;

Added: haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/README
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/README	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/README	2009-09-12 16:47:18 UTC (rev 33100)
@@ -0,0 +1,21 @@
+                 GALLIUM REMOTE DEBUGGING COMMON CODE
+
+= About =
+
+This directory contains the common code for the Gallium 3D remote debugging
+driver and clients. The code is two parts the connection managment code and
+the (de)marsheller.
+
+The code currently uses tcp and ip4v for connections.
+
+Information about driver integration can be found in:
+
+src/gallium/drivers/trace/README
+
+for information about applications look in:
+
+progs/rbug/README
+
+
+--
+Jakob Bornecrantz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jakob at vmware.com</A>&gt;

Added: haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug.h
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug.h	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug.h	2009-09-12 16:47:18 UTC (rev 33100)
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * Include all for users the remote debugger protocol code.
+ */
+
+#include &quot;rbug/rbug_core.h&quot;
+#include &quot;rbug/rbug_shader.h&quot;
+#include &quot;rbug/rbug_context.h&quot;
+#include &quot;rbug/rbug_texture.h&quot;
+#include &quot;rbug/rbug_connection.h&quot;

Added: haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.c	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.c	2009-09-12 16:47:18 UTC (rev 33100)
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include &quot;rbug/rbug.h&quot;
+#include &quot;rbug/rbug_internal.h&quot;
+
+#include &quot;util/u_network.h&quot;
+
+struct rbug_connection
+{
+   int socket;
+   uint32_t send_serial;
+   uint32_t recv_serial;
+   enum rbug_opcode opcode;
+};
+
+/**
+ * Create a rbug connection from a socket created with u_socket.
+ *
+ * Result:
+ *    A new allocated connection using socket as communication path
+ */
+struct rbug_connection *
+rbug_from_socket(int socket)
+{
+   struct rbug_connection *c = CALLOC_STRUCT(rbug_connection);
+   c-&gt;socket = socket;
+   return c;
+}
+
+/**
+ * Free a connection, also closes socket.
+ */
+void
+rbug_disconnect(struct rbug_connection *c)
+{
+   u_socket_close(c-&gt;socket);
+   FREE(c);
+}
+
+/**
+ * Waits for a message to be fully received.
+ * Also returns the serial for the message, serial is not touched for replys.
+ *
+ * Result:
+ *    demarshaled message on success, NULL on connection error
+ */
+struct rbug_header *
+rbug_get_message(struct rbug_connection *c, uint32_t *serial)
+{
+   struct rbug_proto_header header;
+   struct rbug_header *out;
+   struct rbug_proto_header *data;
+   size_t length = 0;
+   size_t read = 0;
+   int ret;
+
+
+   ret = u_socket_peek(c-&gt;socket, &amp;header, sizeof(header));
+   if (ret &lt;= 0) {
+      return NULL;
+   }
+
+   length = (size_t)header.length * 4;
+   data = MALLOC(length);
+   if (!data) {
+      return NULL;
+   }
+
+   do {
+      uint8_t *ptr = ((uint8_t*)data) + read;
+      ret = u_socket_recv(c-&gt;socket, ptr, length - read);
+
+      if (ret &lt;= 0) {
+         FREE(data);
+         return NULL;
+      }
+
+      read += ret;
+   } while(read &lt; length);
+
+   out = rbug_demarshal(data);
+   if (!out)
+      FREE(data);
+   else if (serial)
+      *serial = c-&gt;recv_serial++;
+   else
+      c-&gt;recv_serial++;
+
+   return out;
+}
+
+/**
+ * Frees a message and associated data.
+ */
+void
+rbug_free_header(struct rbug_header *header)
+{
+   if (!header)
+      return;
+
+   FREE(header-&gt;__message);
+   FREE(header);
+}
+
+/**
+ * Internal function used by rbug_send_* functions.
+ *
+ * Start sending a message.
+ */
+int
+rbug_connection_send_start(struct rbug_connection *c, enum rbug_opcode opcode, uint32_t length)
+{
+   c-&gt;opcode = opcode;
+   return 0;
+}
+
+/**
+ * Internal function used by rbug_send_* functions.
+ *
+ * Write data to the socket.
+ */
+int
+rbug_connection_write(struct rbug_connection *c, void *to, uint32_t size)
+{
+   int ret = u_socket_send(c-&gt;socket, to, size);
+   return ret;
+}
+
+/**
+ * Internal function used by rbug_send_* functions.
+ *
+ * Finish writeing data to the socket.
+ * Ups the send_serial and sets the serial argument if supplied.
+ */
+int rbug_connection_send_finish(struct rbug_connection *c, uint32_t *serial)
+{
+   if (c-&gt;opcode &lt; 0)
+      return 0;
+   else if (serial)
+      *serial = c-&gt;send_serial++;
+   else
+      c-&gt;send_serial++;
+
+   return 0;
+}

Added: haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.h
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.h	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_connection.h	2009-09-12 16:47:18 UTC (rev 33100)
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This file contains the function defentions for connection see c file for
+ * more comments covering function use.
+ */
+
+#ifndef _RBUG_CONNECTION_H_
+#define _RBUG_CONNECTION_H_
+
+#include &quot;rbug/rbug_proto.h&quot;
+
+struct rbug_connection * rbug_from_socket(int socket);
+
+void rbug_disconnect(struct rbug_connection *c);
+
+struct rbug_header * rbug_get_message(struct rbug_connection *c, uint32_t *serial);
+
+void rbug_free_header(struct rbug_header *header);
+
+struct rbug_header * rbug_demarshal(struct rbug_proto_header *header);
+
+#endif

Added: haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_context.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_context.c	2009-09-12 15:46:37 UTC (rev 33099)
+++ haiku/branches/components/gallium3d/src/kits/opengl/gallium/auxiliary/rbug/rbug_context.c	2009-09-12 16:47:18 UTC (rev 33100)
@@ -0,0 +1,759 @@
+/*
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * VMWARE AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * This file holds the function implementation for one of the rbug extensions.
+ * Prototypes and declerations of functions and structs is in the same folder
+ * in the header file matching this file's name.
+ *
+ * The functions starting rbug_send_* encodes a call to the write format and
+ * sends that to the supplied connection, while functions starting with
+ * rbug_demarshal_* demarshal data in the wire protocol.
+ *
+ * Functions ending with _reply are replies to requests.
+ */
+
+#include &quot;rbug_internal.h&quot;
+#include &quot;rbug/rbug_context.h&quot;
+
+int rbug_send_context_list(struct rbug_connection *__con,
+                           uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_LIST));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_LIST, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_info(struct rbug_connection *__con,
+                           rbug_context_t context,
+                           uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_INFO));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_INFO, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_draw_block(struct rbug_connection *__con,
+                                 rbug_context_t context,
+                                 rbug_block_t block,
+                                 uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(4); /* block */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_DRAW_BLOCK));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(4, rbug_block_t, block); /* block */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_DRAW_BLOCK, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_draw_step(struct rbug_connection *__con,
+                                rbug_context_t context,
+                                rbug_block_t step,
+                                uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(4); /* step */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_DRAW_STEP));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(4, rbug_block_t, step); /* step */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_DRAW_STEP, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_draw_unblock(struct rbug_connection *__con,
+                                   rbug_context_t context,
+                                   rbug_block_t unblock,
+                                   uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(4); /* unblock */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_DRAW_UNBLOCK));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(4, rbug_block_t, unblock); /* unblock */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_DRAW_UNBLOCK, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_draw_rule(struct rbug_connection *__con,
+                                rbug_context_t context,
+                                rbug_shader_t vertex,
+                                rbug_shader_t fragment,
+                                rbug_texture_t texture,
+                                rbug_texture_t surface,
+                                rbug_block_t block,
+                                uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(8); /* vertex */
+	LEN(8); /* fragment */
+	LEN(8); /* texture */
+	LEN(8); /* surface */
+	LEN(4); /* block */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_DRAW_RULE));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(8, rbug_shader_t, vertex); /* vertex */
+	WRITE(8, rbug_shader_t, fragment); /* fragment */
+	WRITE(8, rbug_texture_t, texture); /* texture */
+	WRITE(8, rbug_texture_t, surface); /* surface */
+	WRITE(4, rbug_block_t, block); /* block */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_DRAW_RULE, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_flush(struct rbug_connection *__con,
+                            rbug_context_t context,
+                            int32_t flags,
+                            uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(4); /* flags */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_FLUSH));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(4, int32_t, flags); /* flags */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_FLUSH, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_list_reply(struct rbug_connection *__con,
+                                 uint32_t serial,
+                                 rbug_context_t *contexts,
+                                 uint32_t contexts_len,
+                                 uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(4); /* serial */
+	LEN_ARRAY(8, contexts); /* contexts */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_LIST_REPLY));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(4, uint32_t, serial); /* serial */
+	WRITE_ARRAY(8, rbug_context_t, contexts); /* contexts */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_LIST_REPLY, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_info_reply(struct rbug_connection *__con,
+                                 uint32_t serial,
+                                 rbug_shader_t vertex,
+                                 rbug_shader_t fragment,
+                                 rbug_texture_t *texs,
+                                 uint32_t texs_len,
+                                 rbug_texture_t *cbufs,
+                                 uint32_t cbufs_len,
+                                 rbug_texture_t zsbuf,
+                                 rbug_block_t blocker,
+                                 rbug_block_t blocked,
+                                 uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(4); /* serial */
+	LEN(8); /* vertex */
+	LEN(8); /* fragment */
+	LEN_ARRAY(8, texs); /* texs */
+	LEN_ARRAY(8, cbufs); /* cbufs */
+	LEN(8); /* zsbuf */
+	LEN(4); /* blocker */
+	LEN(4); /* blocked */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_INFO_REPLY));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(4, uint32_t, serial); /* serial */
+	WRITE(8, rbug_shader_t, vertex); /* vertex */
+	WRITE(8, rbug_shader_t, fragment); /* fragment */
+	WRITE_ARRAY(8, rbug_texture_t, texs); /* texs */
+	WRITE_ARRAY(8, rbug_texture_t, cbufs); /* cbufs */
+	WRITE(8, rbug_texture_t, zsbuf); /* zsbuf */
+	WRITE(4, rbug_block_t, blocker); /* blocker */
+	WRITE(4, rbug_block_t, blocked); /* blocked */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_INFO_REPLY, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+int rbug_send_context_draw_blocked(struct rbug_connection *__con,
+                                   rbug_context_t context,
+                                   rbug_block_t block,
+                                   uint32_t *__serial)
+{
+	uint32_t __len = 0;
+	uint32_t __pos = 0;
+	uint8_t *__data = NULL;
+	int __ret = 0;
+
+	LEN(8); /* header */
+	LEN(8); /* context */
+	LEN(4); /* block */
+
+	/* align */
+	PAD(__len, 8);
+
+	__data = (uint8_t*)MALLOC(__len);
+	if (!__data)
+		return -ENOMEM;
+
+	WRITE(4, int32_t, ((int32_t)RBUG_OP_CONTEXT_DRAW_BLOCKED));
+	WRITE(4, uint32_t, ((uint32_t)(__len / 4)));
+	WRITE(8, rbug_context_t, context); /* context */
+	WRITE(4, rbug_block_t, block); /* block */
+
+	/* final pad */
+	PAD(__pos, 8);
+
+	if (__pos != __len) {
+		__ret = -EINVAL;
+	} else {
+		rbug_connection_send_start(__con, RBUG_OP_CONTEXT_DRAW_BLOCKED, __len);
+		rbug_connection_write(__con, __data, __len);
+		__ret = rbug_connection_send_finish(__con, __serial);
+	}
+
+	FREE(__data);
+	return __ret;
+}
+
+struct rbug_proto_context_list * rbug_demarshal_context_list(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_list *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_LIST)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+
+	return ret;
+}
+
+struct rbug_proto_context_info * rbug_demarshal_context_info(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_info *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_INFO)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+
+	return ret;
+}
+
+struct rbug_proto_context_draw_block * rbug_demarshal_context_draw_block(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_draw_block *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_DRAW_BLOCK)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+	READ(4, rbug_block_t, block); /* block */
+
+	return ret;
+}
+
+struct rbug_proto_context_draw_step * rbug_demarshal_context_draw_step(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_draw_step *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_DRAW_STEP)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+	READ(4, rbug_block_t, step); /* step */
+
+	return ret;
+}
+
+struct rbug_proto_context_draw_unblock * rbug_demarshal_context_draw_unblock(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_draw_unblock *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_DRAW_UNBLOCK)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+	READ(4, rbug_block_t, unblock); /* unblock */
+
+	return ret;
+}
+
+struct rbug_proto_context_draw_rule * rbug_demarshal_context_draw_rule(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_draw_rule *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_DRAW_RULE)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+	READ(8, rbug_shader_t, vertex); /* vertex */
+	READ(8, rbug_shader_t, fragment); /* fragment */
+	READ(8, rbug_texture_t, texture); /* texture */
+	READ(8, rbug_texture_t, surface); /* surface */
+	READ(4, rbug_block_t, block); /* block */
+
+	return ret;
+}
+
+struct rbug_proto_context_flush * rbug_demarshal_context_flush(struct rbug_proto_header *header)
+{
+	uint32_t len = 0;
+	uint32_t pos = 0;
+	uint8_t *data =  NULL;
+	struct rbug_proto_context_flush *ret;
+
+	if (!header)
+		return NULL;
+	if (header-&gt;opcode != (int16_t)RBUG_OP_CONTEXT_FLUSH)
+		return NULL;
+
+	pos = 0;
+	len = header-&gt;length * 4;
+	data = (uint8_t*)&amp;header[1];
+	ret = MALLOC(sizeof(*ret));
+	if (!ret)
+		return NULL;
+
+	ret-&gt;header.__message = header;
+	ret-&gt;header.opcode = header-&gt;opcode;
+
+	READ(8, rbug_context_t, context); /* context */
+	READ(4, int32_t, flags); /* flags */
+
+	return ret;
+}

[... truncated: 9590 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020592.html">[Haiku-commits] r33099 - in haiku/branches/components/gallium3d:	headers/private headers/private/drm src/add-ons/kernel	src/add-ons/kernel/drivers src/add-ons/kernel/drivers/drm	src/add-ons/kernel/drivers/drm/test src/add-ons/kernel/drm
</A></li>
	<LI>Next message: <A HREF="020594.html">[Haiku-commits] r33101 - haiku/trunk/headers/os/device
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20593">[ date ]</a>
              <a href="thread.html#20593">[ thread ]</a>
              <a href="subject.html#20593">[ subject ]</a>
              <a href="author.html#20593">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
