<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33057 - in haiku/branches/components/gallium3d/src:	add-ons/opengl/softpipe	kits/opengl/mesa/gallium/auxiliary/pipebuffer	kits/opengl/mesa/gallium/auxiliary/rtasm	kits/opengl/mesa/gallium/auxiliary/tgsi	kits/opengl/mesa/gallium/auxiliary/util kits/opengl/mesa/main	kits/opengl/mesa/state_tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33057%20-%20in%20haiku/branches/components/gallium3d/src%3A%0A%09add-ons/opengl/softpipe%0A%09kits/opengl/mesa/gallium/auxiliary/pipebuffer%0A%09kits/opengl/mesa/gallium/auxiliary/rtasm%0A%09kits/opengl/mesa/gallium/auxiliary/tgsi%0A%09kits/opengl/mesa/gallium/auxiliary/util%20kits/opengl/mesa/main%0A%09kits/opengl/mesa/state_tracker&In-Reply-To=%3C200909110317.n8B3H5Qh007137%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020543.html">
   <LINK REL="Next"  HREF="020545.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33057 - in haiku/branches/components/gallium3d/src:	add-ons/opengl/softpipe	kits/opengl/mesa/gallium/auxiliary/pipebuffer	kits/opengl/mesa/gallium/auxiliary/rtasm	kits/opengl/mesa/gallium/auxiliary/tgsi	kits/opengl/mesa/gallium/auxiliary/util kits/opengl/mesa/main	kits/opengl/mesa/state_tracker</H1>
    <B>aljen at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33057%20-%20in%20haiku/branches/components/gallium3d/src%3A%0A%09add-ons/opengl/softpipe%0A%09kits/opengl/mesa/gallium/auxiliary/pipebuffer%0A%09kits/opengl/mesa/gallium/auxiliary/rtasm%0A%09kits/opengl/mesa/gallium/auxiliary/tgsi%0A%09kits/opengl/mesa/gallium/auxiliary/util%20kits/opengl/mesa/main%0A%09kits/opengl/mesa/state_tracker&In-Reply-To=%3C200909110317.n8B3H5Qh007137%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33057 - in haiku/branches/components/gallium3d/src:	add-ons/opengl/softpipe	kits/opengl/mesa/gallium/auxiliary/pipebuffer	kits/opengl/mesa/gallium/auxiliary/rtasm	kits/opengl/mesa/gallium/auxiliary/tgsi	kits/opengl/mesa/gallium/auxiliary/util kits/opengl/mesa/main	kits/opengl/mesa/state_tracker">aljen at mail.berlios.de
       </A><BR>
    <I>Fri Sep 11 05:17:05 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020543.html">[Haiku-commits] r33056 -	haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe
</A></li>
        <LI>Next message: <A HREF="020545.html">[Haiku-commits] r33058 - haiku/trunk/src/bin/rc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20544">[ date ]</a>
              <a href="thread.html#20544">[ thread ]</a>
              <a href="subject.html#20544">[ subject ]</a>
              <a href="author.html#20544">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: aljen
Date: 2009-09-11 05:16:57 +0200 (Fri, 11 Sep 2009)
New Revision: 33057
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33057&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33057&amp;view=rev</A>

Modified:
   haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.c
   haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.h
   haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_context.c
   haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.c
   haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.h
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/rtasm/rtasm_execmem.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.h
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_screen.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_shaders.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_time.h
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/execmem.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/texenvprogram.c
   haiku/branches/components/gallium3d/src/kits/opengl/mesa/state_tracker/st_cb_drawpixels.c
Log:
updated to mesa master

Modified: haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.c
===================================================================
--- haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -36,8 +36,6 @@
 #include &quot;util/u_pack_color.h&quot;
 #include &quot;sp_clear.h&quot;
 #include &quot;sp_context.h&quot;
-#include &quot;sp_surface.h&quot;
-#include &quot;sp_state.h&quot;
 #include &quot;sp_tile_cache.h&quot;
 
 
@@ -85,5 +83,7 @@
       /* non-cached surface */
       pipe-&gt;surface_fill(pipe, ps, 0, 0, ps-&gt;width, ps-&gt;height, cv);
 #endif
-      }
+   }
+
+   softpipe-&gt;dirty_render_cache = TRUE;
 }

Modified: haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.h
===================================================================
--- haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.h	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_clear.h	2009-09-11 03:16:57 UTC (rev 33057)
@@ -32,7 +32,6 @@
 #ifndef SP_CLEAR_H
 #define SP_CLEAR_H
 
-#include &quot;pipe/p_state.h&quot;
 struct pipe_context;
 
 extern void

Modified: haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_context.c
===================================================================
--- haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_context.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_context.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -83,7 +83,8 @@
 }
 
 
-static void softpipe_destroy( struct pipe_context *pipe )
+static void
+softpipe_destroy( struct pipe_context *pipe )
 {
    struct softpipe_context *softpipe = softpipe_context( pipe );
    uint i;
@@ -121,6 +122,15 @@
    FREE( softpipe );
 }
 
+
+/**
+ * if (the texture is being used as a framebuffer surface)
+ *    return PIPE_REFERENCED_FOR_WRITE
+ * else if (the texture is a bound texture source)
+ *    return PIPE_REFERENCED_FOR_READ  XXX not done yet
+ * else
+ *    return PIPE_UNREFERENCED
+ */
 static unsigned int
 softpipe_is_texture_referenced( struct pipe_context *pipe,
 				struct pipe_texture *texture,
@@ -129,15 +139,17 @@
    struct softpipe_context *softpipe = softpipe_context( pipe );
    unsigned i;
 
-   if(softpipe-&gt;dirty_render_cache) {
+   if (softpipe-&gt;dirty_render_cache) {
       for (i = 0; i &lt; softpipe-&gt;framebuffer.nr_cbufs; i++) {
-         if(softpipe-&gt;framebuffer.cbufs[i] &amp;&amp; 
-            softpipe-&gt;framebuffer.cbufs[i]-&gt;texture == texture)
+         if (softpipe-&gt;framebuffer.cbufs[i] &amp;&amp; 
+             softpipe-&gt;framebuffer.cbufs[i]-&gt;texture == texture) {
             return PIPE_REFERENCED_FOR_WRITE;
+         }
       }
-      if(softpipe-&gt;framebuffer.zsbuf &amp;&amp; 
-         softpipe-&gt;framebuffer.zsbuf-&gt;texture == texture)
+      if (softpipe-&gt;framebuffer.zsbuf &amp;&amp; 
+          softpipe-&gt;framebuffer.zsbuf-&gt;texture == texture) {
          return PIPE_REFERENCED_FOR_WRITE;
+      }
    }
    
    /* FIXME: we also need to do the same for the texture cache */
@@ -145,6 +157,7 @@
    return PIPE_UNREFERENCED;
 }
 
+
 static unsigned int
 softpipe_is_buffer_referenced( struct pipe_context *pipe,
 			       struct pipe_buffer *buf)
@@ -152,6 +165,7 @@
    return PIPE_UNREFERENCED;
 }
 
+
 struct pipe_context *
 softpipe_create( struct pipe_screen *screen )
 {
@@ -222,7 +236,6 @@
    softpipe-&gt;pipe.is_buffer_referenced = softpipe_is_buffer_referenced;
 
    softpipe_init_query_funcs( softpipe );
-   softpipe_init_texture_funcs( softpipe );
 
    /*
     * Alloc caches for accessing drawing surfaces and textures.

Modified: haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.c
===================================================================
--- haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -30,27 +30,22 @@
   *   Michel D&#228;nzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">michel at tungstengraphics.com</A>&gt;
   */
 
-#include &quot;pipe/p_context.h&quot;
 #include &quot;pipe/p_defines.h&quot;
 #include &quot;pipe/p_inlines.h&quot;
-#include &quot;pipe/internal/p_winsys_screen.h&quot;
 #include &quot;util/u_math.h&quot;
 #include &quot;util/u_memory.h&quot;
 
 #include &quot;sp_context.h&quot;
 #include &quot;sp_state.h&quot;
 #include &quot;sp_texture.h&quot;
-#include &quot;sp_tile_cache.h&quot;
 #include &quot;sp_screen.h&quot;
 #include &quot;sp_winsys.h&quot;
 
 
-/* Simple, maximally packed layout.
+/**
+ * Conventional allocation path for non-display textures:
+ * Use a simple, maximally packed layout.
  */
-
-
-/* Conventional allocation path for non-display textures:
- */
 static boolean
 softpipe_texture_layout(struct pipe_screen *screen,
                         struct softpipe_texture * spt)
@@ -89,6 +84,10 @@
    return spt-&gt;buffer != NULL;
 }
 
+
+/**
+ * Texture layout for simple color buffers.
+ */
 static boolean
 softpipe_displaytarget_layout(struct pipe_screen *screen,
                               struct softpipe_texture * spt)
@@ -112,9 +111,6 @@
 }
 
 
-
-
-
 static struct pipe_texture *
 softpipe_texture_create(struct pipe_screen *screen,
                         const struct pipe_texture *templat)
@@ -342,14 +338,13 @@
    /* May want to different things here depending on read/write nature
     * of the map:
     */
-   if (transfer-&gt;texture &amp;&amp; transfer-&gt;usage != PIPE_TRANSFER_READ) 
-   {
+   if (transfer-&gt;texture &amp;&amp; transfer-&gt;usage != PIPE_TRANSFER_READ) {
       /* Do something to notify sharing contexts of a texture change.
        * In softpipe, that would mean flushing the texture cache.
        */
       softpipe_screen(screen)-&gt;timestamp++;
    }
-   
+
    xfer_map = map + softpipe_transfer(transfer)-&gt;offset +
       transfer-&gt;y / transfer-&gt;block.height * transfer-&gt;stride +
       transfer-&gt;x / transfer-&gt;block.width * transfer-&gt;block.size;
@@ -360,7 +355,7 @@
 
 static void
 softpipe_transfer_unmap(struct pipe_screen *screen,
-                       struct pipe_transfer *transfer)
+                        struct pipe_transfer *transfer)
 {
    struct softpipe_texture *spt;
 
@@ -377,12 +372,6 @@
 
 
 void
-softpipe_init_texture_funcs(struct softpipe_context *sp)
-{
-}
-
-
-void
 softpipe_init_screen_texture_funcs(struct pipe_screen *screen)
 {
    screen-&gt;texture_create = softpipe_texture_create;
@@ -404,7 +393,7 @@
                              struct pipe_buffer **buf,
                              unsigned *stride )
 {
-   struct softpipe_texture *tex = (struct softpipe_texture *)texture;
+   struct softpipe_texture *tex = (struct softpipe_texture *) texture;
 
    if (!tex)
       return FALSE;

Modified: haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.h
===================================================================
--- haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.h	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe/sp_texture.h	2009-09-11 03:16:57 UTC (rev 33057)
@@ -74,9 +74,6 @@
 
 
 extern void
-softpipe_init_texture_funcs( struct softpipe_context *softpipe );
-
-extern void
 softpipe_init_screen_texture_funcs(struct pipe_screen *screen);
 
 

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/pipebuffer/pb_buffer_fenced.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -36,7 +36,7 @@
 
 #include &quot;pipe/p_config.h&quot;
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
 #include &lt;unistd.h&gt;
 #include &lt;sched.h&gt;
 #endif
@@ -576,7 +576,7 @@
    /* Wait on outstanding fences */
    while (fenced_list-&gt;numDelayed) {
       pipe_mutex_unlock(fenced_list-&gt;mutex);
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
       sched_yield();
 #endif
       _fenced_buffer_list_check_free(fenced_list, 1);

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/rtasm/rtasm_execmem.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/rtasm/rtasm_execmem.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/rtasm/rtasm_execmem.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -42,7 +42,7 @@
 #endif
 
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
 
 
 /*
@@ -118,7 +118,7 @@
 }
 
 
-#else /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#else /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS || PIPE_OS_HAIKU */
 
 /*
  * Just use regular memory.
@@ -138,4 +138,4 @@
 }
 
 
-#endif /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS */
+#endif /* PIPE_OS_LINUX || PIPE_OS_BSD || PIPE_OS_SOLARIS || PIPE_OS_HAIKU */

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -2756,19 +2756,32 @@
       if (mach-&gt;ExecMask) {
          /* do the call */
 
-         /* push the Cond, Loop, Cont stacks */
+         /* First, record the depths of the execution stacks.
+          * This is important for deeply nested/looped return statements.
+          * We have to unwind the stacks by the correct amount.  For a
+          * real code generator, we could determine the number of entries
+          * to pop off each stack with simple static analysis and avoid
+          * implementing this data structure at run time.
+          */
+         mach-&gt;CallStack[mach-&gt;CallStackTop].CondStackTop = mach-&gt;CondStackTop;
+         mach-&gt;CallStack[mach-&gt;CallStackTop].LoopStackTop = mach-&gt;LoopStackTop;
+         mach-&gt;CallStack[mach-&gt;CallStackTop].ContStackTop = mach-&gt;ContStackTop;
+         /* note that PC was already incremented above */
+         mach-&gt;CallStack[mach-&gt;CallStackTop].ReturnAddr = *pc;
+
+         mach-&gt;CallStackTop++;
+
+         /* Second, push the Cond, Loop, Cont, Func stacks */
          assert(mach-&gt;CondStackTop &lt; TGSI_EXEC_MAX_COND_NESTING);
          mach-&gt;CondStack[mach-&gt;CondStackTop++] = mach-&gt;CondMask;
          assert(mach-&gt;LoopStackTop &lt; TGSI_EXEC_MAX_LOOP_NESTING);
          mach-&gt;LoopStack[mach-&gt;LoopStackTop++] = mach-&gt;LoopMask;
          assert(mach-&gt;ContStackTop &lt; TGSI_EXEC_MAX_LOOP_NESTING);
          mach-&gt;ContStack[mach-&gt;ContStackTop++] = mach-&gt;ContMask;
-
          assert(mach-&gt;FuncStackTop &lt; TGSI_EXEC_MAX_CALL_NESTING);
          mach-&gt;FuncStack[mach-&gt;FuncStackTop++] = mach-&gt;FuncMask;
 
-         /* note that PC was already incremented above */
-         mach-&gt;CallStack[mach-&gt;CallStackTop++] = *pc;
+         /* Finally, jump to the subroutine */
          *pc = inst-&gt;InstructionExtLabel.Label;
       }
       break;
@@ -2785,18 +2798,24 @@
             *pc = -1;
             return;
          }
-         *pc = mach-&gt;CallStack[--mach-&gt;CallStackTop];
 
-         /* pop the Cond, Loop, Cont stacks */
-         assert(mach-&gt;CondStackTop &gt; 0);
-         mach-&gt;CondMask = mach-&gt;CondStack[--mach-&gt;CondStackTop];
-         assert(mach-&gt;LoopStackTop &gt; 0);
-         mach-&gt;LoopMask = mach-&gt;LoopStack[--mach-&gt;LoopStackTop];
-         assert(mach-&gt;ContStackTop &gt; 0);
-         mach-&gt;ContMask = mach-&gt;ContStack[--mach-&gt;ContStackTop];
+         assert(mach-&gt;CallStackTop &gt; 0);
+         mach-&gt;CallStackTop--;
+
+         mach-&gt;CondStackTop = mach-&gt;CallStack[mach-&gt;CallStackTop].CondStackTop;
+         mach-&gt;CondMask = mach-&gt;CondStack[mach-&gt;CondStackTop];
+
+         mach-&gt;LoopStackTop = mach-&gt;CallStack[mach-&gt;CallStackTop].LoopStackTop;
+         mach-&gt;LoopMask = mach-&gt;LoopStack[mach-&gt;LoopStackTop];
+
+         mach-&gt;ContStackTop = mach-&gt;CallStack[mach-&gt;CallStackTop].ContStackTop;
+         mach-&gt;ContMask = mach-&gt;ContStack[mach-&gt;ContStackTop];
+
          assert(mach-&gt;FuncStackTop &gt; 0);
          mach-&gt;FuncMask = mach-&gt;FuncStack[--mach-&gt;FuncStackTop];
 
+         *pc = mach-&gt;CallStack[mach-&gt;CallStackTop].ReturnAddr;
+
          UPDATE_EXEC_MASK(mach);
       }
       break;
@@ -3245,7 +3264,6 @@
    mach-&gt;FuncMask = 0xf;
    mach-&gt;ExecMask = 0xf;
 
-   mach-&gt;CondStackTop = 0; /* temporarily subvert this assertion */
    assert(mach-&gt;CondStackTop == 0);
    assert(mach-&gt;LoopStackTop == 0);
    assert(mach-&gt;ContStackTop == 0);

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.h
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.h	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/tgsi/tgsi_exec.h	2009-09-11 03:16:57 UTC (rev 33057)
@@ -186,6 +186,17 @@
  */
 #define TGSI_EXEC_MAX_CONST_BUFFER  4096
 
+
+/** function call/activation record */
+struct tgsi_call_record
+{
+   uint CondStackTop;
+   uint LoopStackTop;
+   uint ContStackTop;
+   uint ReturnAddr;
+};
+
+
 /**
  * Run-time virtual machine state for executing TGSI shader.
  */
@@ -249,7 +260,7 @@
    int FuncStackTop;
 
    /** Function call stack for saving/restoring the program counter */
-   uint CallStack[TGSI_EXEC_MAX_CALL_NESTING];
+   struct tgsi_call_record CallStack[TGSI_EXEC_MAX_CALL_NESTING];
    int CallStackTop;
 
    struct tgsi_full_instruction *Instructions;

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_screen.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_screen.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_screen.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -52,8 +52,7 @@
                         unsigned bytes)
 {
    struct pipe_buffer *buffer =
-      screen-&gt;winsys-&gt;user_buffer_create(screen-&gt;winsys,
-                                             ptr, bytes);
+      screen-&gt;winsys-&gt;user_buffer_create(screen-&gt;winsys, ptr, bytes);
 
    buffer-&gt;screen = screen;
 
@@ -69,9 +68,8 @@
                            unsigned *stride)
 {
    struct pipe_buffer *buffer =
-      screen-&gt;winsys-&gt;surface_buffer_create(screen-&gt;winsys,
-                                                width, height,
-                                                format, usage, tex_usage, stride);
+      screen-&gt;winsys-&gt;surface_buffer_create(screen-&gt;winsys, width, height,
+                                            format, usage, tex_usage, stride);
 
    buffer-&gt;screen = screen;
 
@@ -83,8 +81,7 @@
                 struct pipe_buffer *buf,
                 unsigned usage)
 {
-   return screen-&gt;winsys-&gt;buffer_map(screen-&gt;winsys,
-                                     buf, usage);
+   return screen-&gt;winsys-&gt;buffer_map(screen-&gt;winsys, buf, usage);
 }
 
 static void
@@ -106,8 +103,7 @@
                        struct pipe_surface *surf,
                        void *context_private)
 {
-   screen-&gt;winsys-&gt;flush_frontbuffer(screen-&gt;winsys,
-                                     surf, context_private);
+   screen-&gt;winsys-&gt;flush_frontbuffer(screen-&gt;winsys, surf, context_private);
 }
 
 static void
@@ -115,8 +111,7 @@
                      struct pipe_fence_handle **ptr,
                      struct pipe_fence_handle *fence)
 {
-   screen-&gt;winsys-&gt;fence_reference(screen-&gt;winsys,
-                                   ptr, fence);
+   screen-&gt;winsys-&gt;fence_reference(screen-&gt;winsys, ptr, fence);
 }
 
 static int
@@ -124,8 +119,7 @@
                      struct pipe_fence_handle *fence,
                      unsigned flag)
 {
-   return screen-&gt;winsys-&gt;fence_signalled(screen-&gt;winsys,
-                                          fence, flag);
+   return screen-&gt;winsys-&gt;fence_signalled(screen-&gt;winsys, fence, flag);
 }
 
 static int
@@ -133,11 +127,11 @@
                   struct pipe_fence_handle *fence,
                   unsigned flag)
 {
-   return screen-&gt;winsys-&gt;fence_finish(screen-&gt;winsys,
-                                       fence, flag);
+   return screen-&gt;winsys-&gt;fence_finish(screen-&gt;winsys, fence, flag);
 }
 
-void u_simple_screen_init(struct pipe_screen *screen)
+void
+u_simple_screen_init(struct pipe_screen *screen)
 {
    screen-&gt;buffer_create = pass_buffer_create;
    screen-&gt;user_buffer_create = pass_user_buffer_create;
@@ -152,7 +146,8 @@
    screen-&gt;fence_finish = pass_fence_finish;
 }
 
-const char* u_simple_screen_winsys_name(struct pipe_screen *screen)
+const char *
+u_simple_screen_winsys_name(struct pipe_screen *screen)
 {
    return screen-&gt;winsys-&gt;get_name(screen-&gt;winsys);
 }

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_shaders.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_shaders.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_simple_shaders.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -34,14 +34,8 @@
 
 
 #include &quot;pipe/p_context.h&quot;
-#include &quot;util/u_debug.h&quot;
-#include &quot;pipe/p_defines.h&quot;
-#include &quot;pipe/p_screen.h&quot;
 #include &quot;pipe/p_shader_tokens.h&quot;
-
-#include &quot;util/u_memory.h&quot;
 #include &quot;util/u_simple_shaders.h&quot;
-
 #include &quot;tgsi/tgsi_ureg.h&quot;
 
 

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_time.h
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_time.h	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/gallium/auxiliary/util/u_time.h	2009-09-11 03:16:57 UTC (rev 33057)
@@ -94,7 +94,7 @@
                   const struct util_time *end,
                   const struct util_time *curr);
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU)
 #define util_time_sleep usleep
 #else
 void

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/execmem.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/execmem.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/execmem.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -36,7 +36,7 @@
 
 
 
-#if defined(__linux__) || defined(__OpenBSD__) || defined(_NetBSD__) || defined(__sun)
+#if defined(__linux__) || defined(__OpenBSD__) || defined(_NetBSD__) || defined(__sun) || defined(__HAIKU__)
 
 /*
  * Allocate a large block of memory which can hold code then dole it out

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/texenvprogram.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/texenvprogram.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/main/texenvprogram.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -248,6 +248,40 @@
 
 
 /**
+ * Do we need to clamp the results of the given texture env/combine mode?
+ * If the inputs to the mode are in [0,1] we don't always have to clamp
+ * the results.
+ */
+static GLboolean
+need_saturate( GLuint mode )
+{
+   switch (mode) {
+   case MODE_REPLACE:
+   case MODE_MODULATE:
+   case MODE_INTERPOLATE:
+      return GL_FALSE;
+   case MODE_ADD:
+   case MODE_ADD_SIGNED:
+   case MODE_SUBTRACT:
+   case MODE_DOT3_RGB:
+   case MODE_DOT3_RGB_EXT:
+   case MODE_DOT3_RGBA:
+   case MODE_DOT3_RGBA_EXT:
+   case MODE_MODULATE_ADD_ATI:
+   case MODE_MODULATE_SIGNED_ADD_ATI:
+   case MODE_MODULATE_SUBTRACT_ATI:
+   case MODE_ADD_PRODUCTS:
+   case MODE_ADD_PRODUCTS_SIGNED:
+   case MODE_BUMP_ENVMAP_ATI:
+      return GL_TRUE;
+   default:
+      assert(0);
+   }
+}
+
+
+
+/**
  * Translate TEXTURE_x_BIT to TEXTURE_x_INDEX.
  */
 static GLuint translate_tex_src_bit( GLbitfield bit )
@@ -1116,7 +1150,7 @@
 emit_texenv(struct texenv_fragment_program *p, GLuint unit)
 {
    const struct state_key *key = p-&gt;state;
-   GLboolean saturate;
+   GLboolean rgb_saturate, alpha_saturate;
    GLuint rgb_shift, alpha_shift;
    struct ureg out, dest;
 
@@ -1146,8 +1180,20 @@
    /* If we'll do rgb/alpha shifting don't saturate in emit_combine().
     * We don't want to clamp twice.
     */
-   saturate = !(rgb_shift || alpha_shift);
+   if (rgb_shift)
+      rgb_saturate = GL_FALSE;  /* saturate after rgb shift */
+   else if (need_saturate(key-&gt;unit[unit].ModeRGB))
+      rgb_saturate = GL_TRUE;
+   else
+      rgb_saturate = GL_FALSE;
 
+   if (alpha_shift)
+      alpha_saturate = GL_FALSE;  /* saturate after alpha shift */
+   else if (need_saturate(key-&gt;unit[unit].ModeA))
+      alpha_saturate = GL_TRUE;
+   else
+      alpha_saturate = GL_FALSE;
+
    /* If this is the very last calculation, emit direct to output reg:
     */
    if (key-&gt;separate_specular ||
@@ -1162,7 +1208,7 @@
     */
    if (key-&gt;unit[unit].ModeRGB == key-&gt;unit[unit].ModeA &amp;&amp;
        args_match(key, unit)) {
-      out = emit_combine( p, dest, WRITEMASK_XYZW, saturate,
+      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
 			  unit,
 			  key-&gt;unit[unit].NumArgsRGB,
 			  key-&gt;unit[unit].ModeRGB,
@@ -1170,7 +1216,7 @@
    }
    else if (key-&gt;unit[unit].ModeRGB == MODE_DOT3_RGBA_EXT ||
 	    key-&gt;unit[unit].ModeRGB == MODE_DOT3_RGBA) {
-      out = emit_combine( p, dest, WRITEMASK_XYZW, saturate,
+      out = emit_combine( p, dest, WRITEMASK_XYZW, rgb_saturate,
 			  unit,
 			  key-&gt;unit[unit].NumArgsRGB,
 			  key-&gt;unit[unit].ModeRGB,
@@ -1180,12 +1226,12 @@
       /* Need to do something to stop from re-emitting identical
        * argument calculations here:
        */
-      out = emit_combine( p, dest, WRITEMASK_XYZ, saturate,
+      out = emit_combine( p, dest, WRITEMASK_XYZ, rgb_saturate,
 			  unit,
 			  key-&gt;unit[unit].NumArgsRGB,
 			  key-&gt;unit[unit].ModeRGB,
 			  key-&gt;unit[unit].OptRGB);
-      out = emit_combine( p, dest, WRITEMASK_W, saturate,
+      out = emit_combine( p, dest, WRITEMASK_W, alpha_saturate,
 			  unit,
 			  key-&gt;unit[unit].NumArgsA,
 			  key-&gt;unit[unit].ModeA,
@@ -1196,9 +1242,8 @@
     */
    if (alpha_shift || rgb_shift) {
       struct ureg shift;
+      GLboolean saturate = GL_TRUE;  /* always saturate at this point */
 
-      saturate = GL_TRUE;  /* always saturate at this point */
-
       if (rgb_shift == alpha_shift) {
 	 shift = register_scalar_const(p, (GLfloat)(1&lt;&lt;rgb_shift));
       }

Modified: haiku/branches/components/gallium3d/src/kits/opengl/mesa/state_tracker/st_cb_drawpixels.c
===================================================================
--- haiku/branches/components/gallium3d/src/kits/opengl/mesa/state_tracker/st_cb_drawpixels.c	2009-09-11 03:15:47 UTC (rev 33056)
+++ haiku/branches/components/gallium3d/src/kits/opengl/mesa/state_tracker/st_cb_drawpixels.c	2009-09-11 03:16:57 UTC (rev 33057)
@@ -98,7 +98,7 @@
 static struct st_fragment_program *
 combined_drawpix_fragment_program(GLcontext *ctx)
 {
-   struct st_context *st = ctx-&gt;st;
+   struct st_context *st = st_context(ctx);
    struct st_fragment_program *stfp;
 
    if (st-&gt;pixel_xfer.program-&gt;serialNo == st-&gt;pixel_xfer.xfer_prog_sn
@@ -445,8 +445,8 @@
           GLfloat x1, GLfloat y1, const GLfloat *color,
           GLboolean invertTex, GLfloat maxXcoord, GLfloat maxYcoord)
 {
-   struct st_context *st = ctx-&gt;st;
-   struct pipe_context *pipe = ctx-&gt;st-&gt;pipe;
+   struct st_context *st = st_context(ctx);
+   struct pipe_context *pipe = st-&gt;pipe;
    GLfloat verts[4][3][4]; /* four verts, three attribs, XYZW */
 
    /* setup vertex data */
@@ -540,9 +540,9 @@
                    const GLfloat *color,
                    GLboolean invertTex)
 {
-   struct st_context *st = ctx-&gt;st;
-   struct pipe_context *pipe = ctx-&gt;st-&gt;pipe;
-   struct cso_context *cso = ctx-&gt;st-&gt;cso_context;
+   struct st_context *st = st_context(ctx);
+   struct pipe_context *pipe = st-&gt;pipe;
+   struct cso_context *cso = st-&gt;cso_context;
    GLfloat x0, y0, x1, y1;
    GLsizei maxSize;
 
@@ -652,7 +652,7 @@
                     const struct gl_pixelstore_attrib *unpack,
                     const GLvoid *pixels)
 {
-   struct st_context *st = ctx-&gt;st;
+   struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st-&gt;pipe;
    struct pipe_screen *screen = pipe-&gt;screen;
    struct st_renderbuffer *strb;
@@ -793,7 +793,7 @@
 {
    struct st_fragment_program *stfp;
    struct st_vertex_program *stvp;
-   struct st_context *st = ctx-&gt;st;
+   struct st_context *st = st_context(ctx);
    struct pipe_surface *ps;
    const GLfloat *color;
 
@@ -811,21 +811,21 @@
 
    if (format == GL_DEPTH_COMPONENT) {
       ps = st-&gt;state.framebuffer.zsbuf;
-      stfp = make_fragment_shader_z(ctx-&gt;st);
-      stvp = st_make_passthrough_vertex_shader(ctx-&gt;st, GL_TRUE);
+      stfp = make_fragment_shader_z(st);
+      stvp = st_make_passthrough_vertex_shader(st, GL_TRUE);
       color = ctx-&gt;Current.RasterColor;
    }
    else {
       ps = st-&gt;state.framebuffer.cbufs[0];
       stfp = combined_drawpix_fragment_program(ctx);
-      stvp = st_make_passthrough_vertex_shader(ctx-&gt;st, GL_FALSE);
+      stvp = st_make_passthrough_vertex_shader(st, GL_FALSE);
       color = NULL;
    }
 
    /* draw with textured quad */
    {
       struct pipe_texture *pt
-         = make_texture(ctx-&gt;st, width, height, format, type, unpack, pixels);
+         = make_texture(st, width, height, format, type, unpack, pixels);
       if (pt) {
          draw_textured_quad(ctx, x, y, ctx-&gt;Current.RasterPos[2],
                             width, height, ctx-&gt;Pixel.ZoomX, ctx-&gt;Pixel.ZoomY,
@@ -942,7 +942,7 @@
               GLsizei width, GLsizei height,
               GLint dstx, GLint dsty, GLenum type)
 {
-   struct st_context *st = ctx-&gt;st;
+   struct st_context *st = st_context(ctx);
    struct pipe_context *pipe = st-&gt;pipe;
    struct pipe_screen *screen = pipe-&gt;screen;
    struct st_renderbuffer *rbRead;
@@ -995,14 +995,14 @@
       rbRead = st_get_color_read_renderbuffer(ctx);
       color = NULL;
       stfp = combined_drawpix_fragment_program(ctx);
-      stvp = st_make_passthrough_vertex_shader(ctx-&gt;st, GL_FALSE);
+      stvp = st_make_passthrough_vertex_shader(st, GL_FALSE);
    }
    else {
       assert(type == GL_DEPTH);
       rbRead = st_renderbuffer(ctx-&gt;ReadBuffer-&gt;_DepthBuffer);
       color = ctx-&gt;Current.Attrib[VERT_ATTRIB_COLOR0];
-      stfp = make_fragment_shader_z(ctx-&gt;st);
-      stvp = st_make_passthrough_vertex_shader(ctx-&gt;st, GL_TRUE);
+      stfp = make_fragment_shader_z(st);
+      stvp = st_make_passthrough_vertex_shader(st, GL_TRUE);
    }
 
    srcFormat = rbRead-&gt;texture-&gt;format;
@@ -1059,7 +1059,7 @@
       assert(pth &lt;= maxSize);
    }
 
-   pt = st_texture_create(ctx-&gt;st, PIPE_TEXTURE_2D, texFormat, 0,
+   pt = st_texture_create(st, PIPE_TEXTURE_2D, texFormat, 0,
                           ptw, pth, 1,
                           PIPE_TEXTURE_USAGE_SAMPLER);
    if (!pt)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020543.html">[Haiku-commits] r33056 -	haiku/branches/components/gallium3d/src/add-ons/opengl/softpipe
</A></li>
	<LI>Next message: <A HREF="020545.html">[Haiku-commits] r33058 - haiku/trunk/src/bin/rc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20544">[ date ]</a>
              <a href="thread.html#20544">[ thread ]</a>
              <a href="subject.html#20544">[ subject ]</a>
              <a href="author.html#20544">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
