<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33086 - in haiku/branches/components/gallium3d:	headers/libs headers/libs/drm src/libs src/libs/drm	src/libs/drm/intel src/libs/drm/nouveau src/libs/drm/radeon
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33086%20-%20in%20haiku/branches/components/gallium3d%3A%0A%09headers/libs%20headers/libs/drm%20src/libs%20src/libs/drm%0A%09src/libs/drm/intel%20src/libs/drm/nouveau%20src/libs/drm/radeon&In-Reply-To=%3C200909121003.n8CA3g7f018728%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020576.html">
   <LINK REL="Next"  HREF="020578.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33086 - in haiku/branches/components/gallium3d:	headers/libs headers/libs/drm src/libs src/libs/drm	src/libs/drm/intel src/libs/drm/nouveau src/libs/drm/radeon</H1>
    <B>aljen at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33086%20-%20in%20haiku/branches/components/gallium3d%3A%0A%09headers/libs%20headers/libs/drm%20src/libs%20src/libs/drm%0A%09src/libs/drm/intel%20src/libs/drm/nouveau%20src/libs/drm/radeon&In-Reply-To=%3C200909121003.n8CA3g7f018728%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33086 - in haiku/branches/components/gallium3d:	headers/libs headers/libs/drm src/libs src/libs/drm	src/libs/drm/intel src/libs/drm/nouveau src/libs/drm/radeon">aljen at mail.berlios.de
       </A><BR>
    <I>Sat Sep 12 12:03:42 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020576.html">[Haiku-commits] r33085 - haiku/trunk/src/apps/bootman
</A></li>
        <LI>Next message: <A HREF="020578.html">[Haiku-commits] r33087 - in	haiku/branches/components/gallium3d/src/libs/drm: . intel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20577">[ date ]</a>
              <a href="thread.html#20577">[ thread ]</a>
              <a href="subject.html#20577">[ subject ]</a>
              <a href="author.html#20577">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: aljen
Date: 2009-09-12 12:03:07 +0200 (Sat, 12 Sep 2009)
New Revision: 33086
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33086&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33086&amp;view=rev</A>

Added:
   haiku/branches/components/gallium3d/headers/libs/drm/
   haiku/branches/components/gallium3d/headers/libs/drm/drm.h
   haiku/branches/components/gallium3d/headers/libs/drm/drm_mode.h
   haiku/branches/components/gallium3d/headers/libs/drm/i915_drm.h
   haiku/branches/components/gallium3d/headers/libs/drm/nouveau_drm.h
   haiku/branches/components/gallium3d/headers/libs/drm/radeon_drm.h
   haiku/branches/components/gallium3d/src/libs/drm/
   haiku/branches/components/gallium3d/src/libs/drm/Jamfile
   haiku/branches/components/gallium3d/src/libs/drm/intel/
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_bufmgr.c
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_bufmgr.h
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_bufmgr_fake.c
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_bufmgr_gem.c
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_bufmgr_priv.h
   haiku/branches/components/gallium3d/src/libs/drm/intel/intel_chipset.h
   haiku/branches/components/gallium3d/src/libs/drm/intel/mm.c
   haiku/branches/components/gallium3d/src/libs/drm/intel/mm.h
   haiku/branches/components/gallium3d/src/libs/drm/libdrm_lists.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_bo.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_bo.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_channel.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_channel.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_class.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_device.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_device.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_drmif.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_grobj.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_grobj.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_notifier.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_notifier.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_private.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_pushbuf.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_pushbuf.h
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_resource.c
   haiku/branches/components/gallium3d/src/libs/drm/nouveau/nouveau_resource.h
   haiku/branches/components/gallium3d/src/libs/drm/radeon/
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_bo.h
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_bo_gem.c
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_bo_gem.h
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_cs.h
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_cs_gem.c
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_cs_gem.h
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_cs_space.c
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_track.c
   haiku/branches/components/gallium3d/src/libs/drm/radeon/radeon_track.h
   haiku/branches/components/gallium3d/src/libs/drm/xf86drm.c
   haiku/branches/components/gallium3d/src/libs/drm/xf86drm.h
   haiku/branches/components/gallium3d/src/libs/drm/xf86drmHash.c
   haiku/branches/components/gallium3d/src/libs/drm/xf86drmMode.c
   haiku/branches/components/gallium3d/src/libs/drm/xf86drmMode.h
   haiku/branches/components/gallium3d/src/libs/drm/xf86drmRandom.c
   haiku/branches/components/gallium3d/src/libs/drm/xf86drmSL.c
   haiku/branches/components/gallium3d/src/libs/drm/xf86mm.h
Modified:
   haiku/branches/components/gallium3d/src/libs/Jamfile
Log:
Added libdrm:
* libdrm.so
* libdrm_intel.so
* libdrm_radeon.so
* libdrm_nouveau.so



Added: haiku/branches/components/gallium3d/headers/libs/drm/drm.h
===================================================================
--- haiku/branches/components/gallium3d/headers/libs/drm/drm.h	2009-09-12 07:15:29 UTC (rev 33085)
+++ haiku/branches/components/gallium3d/headers/libs/drm/drm.h	2009-09-12 10:03:07 UTC (rev 33086)
@@ -0,0 +1,859 @@
+/**
+ * \file drm.h
+ * Header for the Direct Rendering Manager
+ *
+ * \author Rickard E. (Rik) Faith &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">faith at valinux.com</A>&gt;
+ *
+ * \par Acknowledgments:
+ * Dec 1999, Richard Henderson &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">rth at twiddle.net</A>&gt;, move to generic \c cmpxchg.
+ */
+
+/*
+ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \mainpage
+ *
+ * The Direct Rendering Manager (DRM) is a device-independent kernel-level
+ * device driver that provides support for the XFree86 Direct Rendering
+ * Infrastructure (DRI).
+ *
+ * The DRM supports the Direct Rendering Infrastructure (DRI) in four major
+ * ways:
+ *     -# The DRM provides synchronized access to the graphics hardware via
+ *        the use of an optimized two-tiered lock.
+ *     -# The DRM enforces the DRI security policy for access to the graphics
+ *        hardware by only allowing authenticated X11 clients access to
+ *        restricted regions of memory.
+ *     -# The DRM provides a generic DMA engine, complete with multiple
+ *        queues and the ability to detect the need for an OpenGL context
+ *        switch.
+ *     -# The DRM is extensible via the use of small device-specific modules
+ *        that rely extensively on the API exported by the DRM module.
+ *
+ */
+
+#ifndef _DRM_H_
+#define _DRM_H_
+
+#ifndef __user
+#define __user
+#endif
+#ifndef __iomem
+#define __iomem
+#endif
+
+#ifdef __GNUC__
+# define DEPRECATED  __attribute__ ((deprecated))
+#else
+# define DEPRECATED
+# ifndef __FUNCTION__
+#  define __FUNCTION__ __func__ /* C99 */
+# endif
+# ifndef __volatile__
+#  define __volatile__ volatile
+# endif
+#endif
+
+#if defined(__linux__)
+#include &lt;asm/ioctl.h&gt;		/* For _IO* macros */
+#define DRM_IOCTL_NR(n)		_IOC_NR(n)
+#define DRM_IOC_VOID		_IOC_NONE
+#define DRM_IOC_READ		_IOC_READ
+#define DRM_IOC_WRITE		_IOC_WRITE
+#define DRM_IOC_READWRITE	_IOC_READ|_IOC_WRITE
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__HAIKU__)
+#include &lt;sys/ioccom.h&gt;
+#define DRM_IOCTL_NR(n)		((n) &amp; 0xff)
+#define DRM_IOC_VOID		IOC_VOID
+#define DRM_IOC_READ		IOC_OUT
+#define DRM_IOC_WRITE		IOC_IN
+#define DRM_IOC_READWRITE	IOC_INOUT
+#define DRM_IOC(dir, group, nr, size) _IOC(dir, group, nr, size)
+#endif
+
+#ifdef __OpenBSD__
+#define DRM_MAJOR       81
+#endif
+#if defined(__linux__) || defined(__NetBSD__)
+#define DRM_MAJOR       226
+#endif
+#define DRM_MAX_MINOR   15
+
+#define DRM_NAME	&quot;drm&quot;	  /**&lt; Name in kernel, /dev, and /proc */
+#define DRM_MIN_ORDER	5	  /**&lt; At least 2^5 bytes = 32 bytes */
+#define DRM_MAX_ORDER	22	  /**&lt; Up to 2^22 bytes = 4MB */
+#define DRM_RAM_PERCENT 10	  /**&lt; How much system ram can we lock? */
+
+#define _DRM_LOCK_HELD	0x80000000U /**&lt; Hardware lock is held */
+#define _DRM_LOCK_CONT	0x40000000U /**&lt; Hardware lock is contended */
+#define _DRM_LOCK_IS_HELD(lock)	   ((lock) &amp; _DRM_LOCK_HELD)
+#define _DRM_LOCK_IS_CONT(lock)	   ((lock) &amp; _DRM_LOCK_CONT)
+#define _DRM_LOCKING_CONTEXT(lock) ((lock) &amp; ~(_DRM_LOCK_HELD|_DRM_LOCK_CONT))
+
+#if defined(__linux__)
+typedef unsigned int drm_handle_t;
+#else
+#include &lt;sys/types.h&gt;
+typedef unsigned long drm_handle_t;	/**&lt; To mapped regions */
+#endif
+typedef unsigned int drm_context_t;	/**&lt; GLXContext handle */
+typedef unsigned int drm_drawable_t;
+typedef unsigned int drm_magic_t;	/**&lt; Magic for authentication */
+
+/**
+ * Cliprect.
+ *
+ * \warning If you change this structure, make sure you change
+ * XF86DRIClipRectRec in the server as well
+ *
+ * \note KW: Actually it's illegal to change either for
+ * backwards-compatibility reasons.
+ */
+struct drm_clip_rect {
+	unsigned short x1;
+	unsigned short y1;
+	unsigned short x2;
+	unsigned short y2;
+};
+
+/**
+ * Texture region,
+ */
+struct drm_tex_region {
+	unsigned char next;
+	unsigned char prev;
+	unsigned char in_use;
+	unsigned char padding;
+	unsigned int age;
+};
+
+/**
+ * Hardware lock.
+ *
+ * The lock structure is a simple cache-line aligned integer.  To avoid
+ * processor bus contention on a multiprocessor system, there should not be any
+ * other data stored in the same cache line.
+ */
+struct drm_hw_lock {
+	__volatile__ unsigned int lock;		/**&lt; lock variable */
+	char padding[60];			/**&lt; Pad to cache line */
+};
+
+/* This is beyond ugly, and only works on GCC.  However, it allows me to use
+ * drm.h in places (i.e., in the X-server) where I can't use size_t.  The real
+ * fix is to use uint32_t instead of size_t, but that fix will break existing
+ * LP64 (i.e., PowerPC64, SPARC64, IA-64, Alpha, etc.) systems.  That *will*
+ * eventually happen, though.  I chose 'unsigned long' to be the fallback type
+ * because that works on all the platforms I know about.  Hopefully, the
+ * real fix will happen before that bites us.
+ */
+
+#ifdef __SIZE_TYPE__
+# define DRM_SIZE_T __SIZE_TYPE__
+#else
+# warning &quot;__SIZE_TYPE__ not defined.  Assuming sizeof(size_t) == sizeof(unsigned long)!&quot;
+# define DRM_SIZE_T unsigned long
+#endif
+
+/**
+ * DRM_IOCTL_VERSION ioctl argument type.
+ *
+ * \sa drmGetVersion().
+ */
+struct drm_version {
+	int version_major;	  /**&lt; Major version */
+	int version_minor;	  /**&lt; Minor version */
+	int version_patchlevel;	  /**&lt; Patch level */
+	DRM_SIZE_T name_len;	  /**&lt; Length of name buffer */
+	char __user *name;		  /**&lt; Name of driver */
+	DRM_SIZE_T date_len;	  /**&lt; Length of date buffer */
+	char __user *date;		  /**&lt; User-space buffer to hold date */
+	DRM_SIZE_T desc_len;	  /**&lt; Length of desc buffer */
+	char __user *desc;		  /**&lt; User-space buffer to hold desc */
+};
+
+/**
+ * DRM_IOCTL_GET_UNIQUE ioctl argument type.
+ *
+ * \sa drmGetBusid() and drmSetBusId().
+ */
+struct drm_unique {
+	DRM_SIZE_T unique_len;	  /**&lt; Length of unique */
+	char __user *unique;		  /**&lt; Unique name for driver instantiation */
+};
+
+#undef DRM_SIZE_T
+
+struct drm_list {
+	int count;		  /**&lt; Length of user-space structures */
+	struct drm_version __user *version;
+};
+
+struct drm_block {
+	int unused;
+};
+
+/**
+ * DRM_IOCTL_CONTROL ioctl argument type.
+ *
+ * \sa drmCtlInstHandler() and drmCtlUninstHandler().
+ */
+struct drm_control {
+	enum {
+		DRM_ADD_COMMAND,
+		DRM_RM_COMMAND,
+		DRM_INST_HANDLER,
+		DRM_UNINST_HANDLER
+	} func;
+	int irq;
+};
+
+/**
+ * Type of memory to map.
+ */
+enum drm_map_type {
+	_DRM_FRAME_BUFFER = 0,	  /**&lt; WC (no caching), no core dump */
+	_DRM_REGISTERS = 1,	  /**&lt; no caching, no core dump */
+	_DRM_SHM = 2,		  /**&lt; shared, cached */
+	_DRM_AGP = 3,		  /**&lt; AGP/GART */
+	_DRM_SCATTER_GATHER = 4,  /**&lt; Scatter/gather memory for PCI DMA */
+	_DRM_CONSISTENT = 5,	  /**&lt; Consistent memory for PCI DMA */
+	_DRM_GEM = 6,
+	_DRM_TTM = 7,
+};
+
+/**
+ * Memory mapping flags.
+ */
+enum drm_map_flags {
+	_DRM_RESTRICTED = 0x01,	     /**&lt; Cannot be mapped to user-virtual */
+	_DRM_READ_ONLY = 0x02,
+	_DRM_LOCKED = 0x04,	     /**&lt; shared, cached, locked */
+	_DRM_KERNEL = 0x08,	     /**&lt; kernel requires access */
+	_DRM_WRITE_COMBINING = 0x10, /**&lt; use write-combining if available */
+	_DRM_CONTAINS_LOCK = 0x20,   /**&lt; SHM page that contains lock */
+	_DRM_REMOVABLE = 0x40,	     /**&lt; Removable mapping */
+	_DRM_DRIVER = 0x80	     /**&lt; Managed by driver */
+};
+
+struct drm_ctx_priv_map {
+	unsigned int ctx_id;	 /**&lt; Context requesting private mapping */
+	void *handle;		 /**&lt; Handle of map */
+};
+
+/**
+ * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls
+ * argument type.
+ *
+ * \sa drmAddMap().
+ */
+struct drm_map {
+	unsigned long offset;	 /**&lt; Requested physical address (0 for SAREA)*/
+	unsigned long size;	 /**&lt; Requested physical size (bytes) */
+	enum drm_map_type type;	 /**&lt; Type of memory to map */
+	enum drm_map_flags flags;	 /**&lt; Flags */
+	void *handle;		 /**&lt; User-space: &quot;Handle&quot; to pass to mmap() */
+				 /**&lt; Kernel-space: kernel-virtual address */
+	int mtrr;		 /**&lt; MTRR slot used */
+	/*   Private data */
+};
+
+/**
+ * DRM_IOCTL_GET_CLIENT ioctl argument type.
+ */
+struct drm_client {
+	int idx;		/**&lt; Which client desired? */
+	int auth;		/**&lt; Is client authenticated? */
+	unsigned long pid;	/**&lt; Process ID */
+	unsigned long uid;	/**&lt; User ID */
+	unsigned long magic;	/**&lt; Magic */
+	unsigned long iocs;	/**&lt; Ioctl count */
+};
+
+enum drm_stat_type {
+	_DRM_STAT_LOCK,
+	_DRM_STAT_OPENS,
+	_DRM_STAT_CLOSES,
+	_DRM_STAT_IOCTLS,
+	_DRM_STAT_LOCKS,
+	_DRM_STAT_UNLOCKS,
+	_DRM_STAT_VALUE,	/**&lt; Generic value */
+	_DRM_STAT_BYTE,		/**&lt; Generic byte counter (1024bytes/K) */
+	_DRM_STAT_COUNT,	/**&lt; Generic non-byte counter (1000/k) */
+
+	_DRM_STAT_IRQ,		/**&lt; IRQ */
+	_DRM_STAT_PRIMARY,	/**&lt; Primary DMA bytes */
+	_DRM_STAT_SECONDARY,	/**&lt; Secondary DMA bytes */
+	_DRM_STAT_DMA,		/**&lt; DMA */
+	_DRM_STAT_SPECIAL,	/**&lt; Special DMA (e.g., priority or polled) */
+	_DRM_STAT_MISSED	/**&lt; Missed DMA opportunity */
+	    /* Add to the *END* of the list */
+};
+
+/**
+ * DRM_IOCTL_GET_STATS ioctl argument type.
+ */
+struct drm_stats {
+	unsigned long count;
+	struct {
+		unsigned long value;
+		enum drm_stat_type type;
+	} data[15];
+};
+
+/**
+ * Hardware locking flags.
+ */
+enum drm_lock_flags {
+	_DRM_LOCK_READY = 0x01,	     /**&lt; Wait until hardware is ready for DMA */
+	_DRM_LOCK_QUIESCENT = 0x02,  /**&lt; Wait until hardware quiescent */
+	_DRM_LOCK_FLUSH = 0x04,	     /**&lt; Flush this context's DMA queue first */
+	_DRM_LOCK_FLUSH_ALL = 0x08,  /**&lt; Flush all DMA queues first */
+	/* These *HALT* flags aren't supported yet
+	   -- they will be used to support the
+	   full-screen DGA-like mode. */
+	_DRM_HALT_ALL_QUEUES = 0x10, /**&lt; Halt all current and future queues */
+	_DRM_HALT_CUR_QUEUES = 0x20  /**&lt; Halt all current queues */
+};
+
+/**
+ * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.
+ *
+ * \sa drmGetLock() and drmUnlock().
+ */
+struct drm_lock {
+	int context;
+	enum drm_lock_flags flags;
+};
+
+/**
+ * DMA flags
+ *
+ * \warning
+ * These values \e must match xf86drm.h.
+ *
+ * \sa drm_dma.
+ */
+enum drm_dma_flags {
+	/* Flags for DMA buffer dispatch */
+	_DRM_DMA_BLOCK = 0x01,	      /**&lt;
+				       * Block until buffer dispatched.
+				       *
+				       * \note The buffer may not yet have
+				       * been processed by the hardware --
+				       * getting a hardware lock with the
+				       * hardware quiescent will ensure
+				       * that the buffer has been
+				       * processed.
+				       */
+	_DRM_DMA_WHILE_LOCKED = 0x02, /**&lt; Dispatch while lock held */
+	_DRM_DMA_PRIORITY = 0x04,     /**&lt; High priority dispatch */
+
+	/* Flags for DMA buffer request */
+	_DRM_DMA_WAIT = 0x10,	      /**&lt; Wait for free buffers */
+	_DRM_DMA_SMALLER_OK = 0x20,   /**&lt; Smaller-than-requested buffers OK */
+	_DRM_DMA_LARGER_OK = 0x40     /**&lt; Larger-than-requested buffers OK */
+};
+
+/**
+ * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.
+ *
+ * \sa drmAddBufs().
+ */
+struct drm_buf_desc {
+	int count;		 /**&lt; Number of buffers of this size */
+	int size;		 /**&lt; Size in bytes */
+	int low_mark;		 /**&lt; Low water mark */
+	int high_mark;		 /**&lt; High water mark */
+	enum {
+		_DRM_PAGE_ALIGN = 0x01,	/**&lt; Align on page boundaries for DMA */
+		_DRM_AGP_BUFFER = 0x02,	/**&lt; Buffer is in AGP space */
+		_DRM_SG_BUFFER  = 0x04,	/**&lt; Scatter/gather memory buffer */
+		_DRM_FB_BUFFER  = 0x08, /**&lt; Buffer is in frame buffer */
+		_DRM_PCI_BUFFER_RO = 0x10 /**&lt; Map PCI DMA buffer read-only */
+	} flags;
+	unsigned long agp_start; /**&lt;
+				  * Start address of where the AGP buffers are
+				  * in the AGP aperture
+				  */
+};
+
+/**
+ * DRM_IOCTL_INFO_BUFS ioctl argument type.
+ */
+struct drm_buf_info {
+	int count;		  /**&lt; Number of buffers described in list */
+	struct drm_buf_desc __user *list; /**&lt; List of buffer descriptions */
+};
+
+/**
+ * DRM_IOCTL_FREE_BUFS ioctl argument type.
+ */
+struct drm_buf_free {
+	int count;
+	int __user *list;
+};
+
+/**
+ * Buffer information
+ *
+ * \sa drm_buf_map.
+ */
+struct drm_buf_pub {
+	int idx;		       /**&lt; Index into the master buffer list */
+	int total;		       /**&lt; Buffer size */
+	int used;		       /**&lt; Amount of buffer in use (for DMA) */
+	void __user *address;	       /**&lt; Address of buffer */
+};
+
+/**
+ * DRM_IOCTL_MAP_BUFS ioctl argument type.
+ */
+struct drm_buf_map {
+	int count;		/**&lt; Length of the buffer list */
+#if defined(__cplusplus)
+	void __user *c_virtual;
+#else
+	void __user *virtual;		/**&lt; Mmap'd area in user-virtual */
+#endif
+	struct drm_buf_pub __user *list;	/**&lt; Buffer information */
+};
+
+/**
+ * DRM_IOCTL_DMA ioctl argument type.
+ *
+ * Indices here refer to the offset into the buffer list in drm_buf_get.
+ *
+ * \sa drmDMA().
+ */
+struct drm_dma {
+	int context;			  /**&lt; Context handle */
+	int send_count;			  /**&lt; Number of buffers to send */
+	int __user *send_indices;	  /**&lt; List of handles to buffers */
+	int __user *send_sizes;		  /**&lt; Lengths of data to send */
+	enum drm_dma_flags flags;	  /**&lt; Flags */
+	int request_count;		  /**&lt; Number of buffers requested */
+	int request_size;		  /**&lt; Desired size for buffers */
+	int __user *request_indices;	 /**&lt; Buffer information */
+	int __user *request_sizes;
+	int granted_count;		  /**&lt; Number of buffers granted */
+};
+
+enum drm_ctx_flags {
+	_DRM_CONTEXT_PRESERVED = 0x01,
+	_DRM_CONTEXT_2DONLY = 0x02
+};
+
+/**
+ * DRM_IOCTL_ADD_CTX ioctl argument type.
+ *
+ * \sa drmCreateContext() and drmDestroyContext().
+ */
+struct drm_ctx {
+	drm_context_t handle;
+	enum drm_ctx_flags flags;
+};
+
+/**
+ * DRM_IOCTL_RES_CTX ioctl argument type.
+ */
+struct drm_ctx_res {
+	int count;
+	struct drm_ctx __user *contexts;
+};
+
+/**
+ * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.
+ */
+struct drm_draw {
+	drm_drawable_t handle;
+};
+
+/**
+ * DRM_IOCTL_UPDATE_DRAW ioctl argument type.
+ */
+typedef enum {
+	DRM_DRAWABLE_CLIPRECTS,
+} drm_drawable_info_type_t;
+
+struct drm_update_draw {
+	drm_drawable_t handle;
+	unsigned int type;
+	unsigned int num;
+	unsigned long long data;
+};
+
+/**
+ * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.
+ */
+struct drm_auth {
+	drm_magic_t magic;
+};
+
+/**
+ * DRM_IOCTL_IRQ_BUSID ioctl argument type.
+ *
+ * \sa drmGetInterruptFromBusID().
+ */
+struct drm_irq_busid {
+	int irq;	/**&lt; IRQ number */
+	int busnum;	/**&lt; bus number */
+	int devnum;	/**&lt; device number */
+	int funcnum;	/**&lt; function number */
+};
+
+enum drm_vblank_seq_type {
+	_DRM_VBLANK_ABSOLUTE = 0x0,	/**&lt; Wait for specific vblank sequence number */
+	_DRM_VBLANK_RELATIVE = 0x1,	/**&lt; Wait for given number of vblanks */
+	_DRM_VBLANK_FLIP = 0x8000000,	/**&lt; Scheduled buffer swap should flip */
+	_DRM_VBLANK_NEXTONMISS = 0x10000000,	/**&lt; If missed, wait for next vblank */
+	_DRM_VBLANK_SECONDARY = 0x20000000,	/**&lt; Secondary display controller */
+	_DRM_VBLANK_SIGNAL = 0x40000000	/**&lt; Send signal instead of blocking */
+};
+
+#define _DRM_VBLANK_TYPES_MASK (_DRM_VBLANK_ABSOLUTE | _DRM_VBLANK_RELATIVE)
+#define _DRM_VBLANK_FLAGS_MASK (_DRM_VBLANK_SIGNAL | _DRM_VBLANK_SECONDARY | \
+				_DRM_VBLANK_NEXTONMISS)
+
+struct drm_wait_vblank_request {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	unsigned long signal;
+};
+
+struct drm_wait_vblank_reply {
+	enum drm_vblank_seq_type type;
+	unsigned int sequence;
+	long tval_sec;
+	long tval_usec;
+};
+
+/**
+ * DRM_IOCTL_WAIT_VBLANK ioctl argument type.
+ *
+ * \sa drmWaitVBlank().
+ */
+union drm_wait_vblank {
+	struct drm_wait_vblank_request request;
+	struct drm_wait_vblank_reply reply;
+};
+
+
+#define _DRM_PRE_MODESET 1
+#define _DRM_POST_MODESET 2
+
+/**
+ * DRM_IOCTL_MODESET_CTL ioctl argument type
+ *
+ * \sa drmModesetCtl().
+ */
+struct drm_modeset_ctl {
+	uint32_t crtc;
+	uint32_t cmd;
+};
+
+/**
+ * DRM_IOCTL_AGP_ENABLE ioctl argument type.
+ *
+ * \sa drmAgpEnable().
+ */
+struct drm_agp_mode {
+	unsigned long mode;	/**&lt; AGP mode */
+};
+
+/**
+ * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.
+ *
+ * \sa drmAgpAlloc() and drmAgpFree().
+ */
+struct drm_agp_buffer {
+	unsigned long size;	/**&lt; In bytes -- will round to page boundary */
+	unsigned long handle;	/**&lt; Used for binding / unbinding */
+	unsigned long type;	/**&lt; Type of memory to allocate */
+	unsigned long physical;	/**&lt; Physical used by i810 */
+};
+
+/**
+ * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.
+ *
+ * \sa drmAgpBind() and drmAgpUnbind().
+ */
+struct drm_agp_binding {
+	unsigned long handle;	/**&lt; From drm_agp_buffer */
+	unsigned long offset;	/**&lt; In bytes -- will round to page boundary */
+};
+
+/**
+ * DRM_IOCTL_AGP_INFO ioctl argument type.
+ *
+ * \sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),
+ * drmAgpBase(), drmAgpSize(), drmAgpMemoryUsed(), drmAgpMemoryAvail(),
+ * drmAgpVendorId() and drmAgpDeviceId().
+ */
+struct drm_agp_info {
+	int agp_version_major;
+	int agp_version_minor;
+	unsigned long mode;
+	unsigned long aperture_base;   /**&lt; physical address */
+	unsigned long aperture_size;   /**&lt; bytes */
+	unsigned long memory_allowed;  /**&lt; bytes */
+	unsigned long memory_used;
+
+	/** \name PCI information */
+	/*@{ */
+	unsigned short id_vendor;
+	unsigned short id_device;
+	/*@} */
+};
+
+/**
+ * DRM_IOCTL_SG_ALLOC ioctl argument type.
+ */
+struct drm_scatter_gather {
+	unsigned long size;	/**&lt; In bytes -- will round to page boundary */
+	unsigned long handle;	/**&lt; Used for mapping / unmapping */
+};
+
+/**
+ * DRM_IOCTL_SET_VERSION ioctl argument type.
+ */
+struct drm_set_version {
+	int drm_di_major;
+	int drm_di_minor;
+	int drm_dd_major;
+	int drm_dd_minor;
+};
+
+struct drm_gem_close {
+	/** Handle of the object to be closed. */
+	uint32_t handle;
+	uint32_t pad;
+};
+
+struct drm_gem_flink {
+	/** Handle for the object being named */
+	uint32_t handle;
+
+	/** Returned global name */
+	uint32_t name;
+};
+
+struct drm_gem_open {
+	/** Name of object being opened */
+	uint32_t name;
+
+	/** Returned handle for the object */
+	uint32_t handle;
+	
+	/** Returned size of the object */
+	uint64_t size;
+};
+
+#include &quot;drm_mode.h&quot;
+
+/**
+ * \name Ioctls Definitions
+ */
+/*@{*/
+
+#define DRM_IOCTL_BASE			'd'
+#define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)
+#define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)
+#define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)
+
+#define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)
+#define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)
+#define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)
+#define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)
+#define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)
+#define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)
+#define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)
+#define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)
+#define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08,  struct drm_modeset_ctl)
+
+#define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)
+#define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)
+#define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)
+
+#define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)
+#define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)
+#define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)
+#define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)
+#define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)
+#define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)
+#define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)
+#define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)
+#define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)
+#define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)
+#define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)
+
+#define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)
+
+#define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)
+#define DRM_IOCTL_GET_SAREA_CTX		DRM_IOWR(0x1d, struct drm_ctx_priv_map)
+
+#define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)
+#define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)
+
+#define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)
+#define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)
+#define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)
+#define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)
+#define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)
+#define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)
+#define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)
+#define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)
+#define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)
+#define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)
+#define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)
+#define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)
+#define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)
+
+#define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)
+#define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)
+#define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)
+#define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)
+#define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)
+#define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)
+#define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)
+
+#define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)
+#define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)
+
+#define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)
+
+#define DRM_IOCTL_UPDATE_DRAW           DRM_IOW(0x3f, struct drm_update_draw)
+
+#define DRM_IOCTL_MM_INIT               DRM_IOWR(0xc0, struct drm_mm_init_arg)
+#define DRM_IOCTL_MM_TAKEDOWN           DRM_IOWR(0xc1, struct drm_mm_type_arg)
+#define DRM_IOCTL_MM_LOCK               DRM_IOWR(0xc2, struct drm_mm_type_arg)
+#define DRM_IOCTL_MM_UNLOCK             DRM_IOWR(0xc3, struct drm_mm_type_arg)
+
+#define DRM_IOCTL_FENCE_CREATE          DRM_IOWR(0xc4, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_REFERENCE       DRM_IOWR(0xc6, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_UNREFERENCE     DRM_IOWR(0xc7, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_SIGNALED        DRM_IOWR(0xc8, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_FLUSH           DRM_IOWR(0xc9, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_WAIT            DRM_IOWR(0xca, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_EMIT            DRM_IOWR(0xcb, struct drm_fence_arg)
+#define DRM_IOCTL_FENCE_BUFFERS         DRM_IOWR(0xcc, struct drm_fence_arg)
+
+#define DRM_IOCTL_BO_CREATE             DRM_IOWR(0xcd, struct drm_bo_create_arg)
+#define DRM_IOCTL_BO_MAP                DRM_IOWR(0xcf, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_UNMAP              DRM_IOWR(0xd0, struct drm_bo_handle_arg)
+#define DRM_IOCTL_BO_REFERENCE          DRM_IOWR(0xd1, struct drm_bo_reference_info_arg)
+#define DRM_IOCTL_BO_UNREFERENCE        DRM_IOWR(0xd2, struct drm_bo_handle_arg)
+#define DRM_IOCTL_BO_SETSTATUS          DRM_IOWR(0xd3, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_INFO               DRM_IOWR(0xd4, struct drm_bo_reference_info_arg)
+#define DRM_IOCTL_BO_WAIT_IDLE          DRM_IOWR(0xd5, struct drm_bo_map_wait_idle_arg)
+#define DRM_IOCTL_BO_VERSION          DRM_IOR(0xd6, struct drm_bo_version_arg)
+#define DRM_IOCTL_MM_INFO               DRM_IOWR(0xd7, struct drm_mm_info_arg)
+
+#define DRM_IOCTL_MODE_GETRESOURCES     DRM_IOWR(0xA0, struct drm_mode_card_res)
+
+#define DRM_IOCTL_MODE_GETCRTC          DRM_IOWR(0xA1, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)
+#define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)
+#define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)
+#define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)
+
+#define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)
+
+#define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)
+#define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)
+#define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)
+#define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)
+#define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)
+
+#define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)
+#define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, uint32_t)
+
+/*@}*/
+
+/**
+ * Device specific ioctls should only be in their respective headers
+ * The device specific ioctl range is from 0x40 to 0x99.
+ * Generic IOCTLS restart at 0xA0.
+ *
+ * \sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and
+ * drmCommandReadWrite().
+ */
+#define DRM_COMMAND_BASE                0x40
+#define DRM_COMMAND_END                 0xA0
+
+/* typedef area */
+#ifndef __KERNEL__
+typedef struct drm_clip_rect drm_clip_rect_t;
+typedef struct drm_tex_region drm_tex_region_t;
+typedef struct drm_hw_lock drm_hw_lock_t;
+typedef struct drm_version drm_version_t;
+typedef struct drm_unique drm_unique_t;
+typedef struct drm_list drm_list_t;
+typedef struct drm_block drm_block_t;
+typedef struct drm_control drm_control_t;
+typedef enum drm_map_type drm_map_type_t;
+typedef enum drm_map_flags drm_map_flags_t;
+typedef struct drm_ctx_priv_map drm_ctx_priv_map_t;
+typedef struct drm_map drm_map_t;
+typedef struct drm_client drm_client_t;
+typedef enum drm_stat_type drm_stat_type_t;
+typedef struct drm_stats drm_stats_t;
+typedef enum drm_lock_flags drm_lock_flags_t;
+typedef struct drm_lock drm_lock_t;
+typedef enum drm_dma_flags drm_dma_flags_t;
+typedef struct drm_buf_desc drm_buf_desc_t;
+typedef struct drm_buf_info drm_buf_info_t;
+typedef struct drm_buf_free drm_buf_free_t;
+typedef struct drm_buf_pub drm_buf_pub_t;
+typedef struct drm_buf_map drm_buf_map_t;
+typedef struct drm_dma drm_dma_t;
+typedef union drm_wait_vblank drm_wait_vblank_t;
+typedef struct drm_agp_mode drm_agp_mode_t;
+typedef enum drm_ctx_flags drm_ctx_flags_t;
+typedef struct drm_ctx drm_ctx_t;
+typedef struct drm_ctx_res drm_ctx_res_t;
+typedef struct drm_draw drm_draw_t;
+typedef struct drm_update_draw drm_update_draw_t;
+typedef struct drm_auth drm_auth_t;
+typedef struct drm_irq_busid drm_irq_busid_t;
+typedef enum drm_vblank_seq_type drm_vblank_seq_type_t;
+typedef struct drm_agp_buffer drm_agp_buffer_t;
+typedef struct drm_agp_binding drm_agp_binding_t;
+typedef struct drm_agp_info drm_agp_info_t;
+typedef struct drm_scatter_gather drm_scatter_gather_t;
+typedef struct drm_set_version drm_set_version_t;
+
+typedef struct drm_fence_arg drm_fence_arg_t;
+typedef struct drm_mm_type_arg drm_mm_type_arg_t;
+typedef struct drm_mm_init_arg drm_mm_init_arg_t;
+#endif
+
+#endif

Added: haiku/branches/components/gallium3d/headers/libs/drm/drm_mode.h
===================================================================
--- haiku/branches/components/gallium3d/headers/libs/drm/drm_mode.h	2009-09-12 07:15:29 UTC (rev 33085)
+++ haiku/branches/components/gallium3d/headers/libs/drm/drm_mode.h	2009-09-12 10:03:07 UTC (rev 33086)
@@ -0,0 +1,273 @@
+/*
+ * Copyright (c) 2007 Dave Airlie &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">airlied at linux.ie</A>&gt;
+ * Copyright (c) 2007 Jakob Bornecrantz &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wallbraker at gmail.com</A>&gt;
+ * Copyright (c) 2008 Red Hat Inc.
+ * Copyright (c) 2007-2008 Tungsten Graphics, Inc., Cedar Park, TX., USA
+ * Copyright (c) 2007-2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef _DRM_MODE_H
+#define _DRM_MODE_H
+
+#ifdef __linux__
+#if !defined(__KERNEL__) &amp;&amp; !defined(_KERNEL)
+#include &lt;stdint.h&gt;
+#else
+#include &lt;linux/kernel.h&gt;
+#endif
+#endif
+
+#define DRM_DISPLAY_INFO_LEN	32
+#define DRM_CONNECTOR_NAME_LEN	32
+#define DRM_DISPLAY_MODE_LEN	32
+#define DRM_PROP_NAME_LEN	32
+
+#define DRM_MODE_TYPE_BUILTIN	(1&lt;&lt;0)
+#define DRM_MODE_TYPE_CLOCK_C	((1&lt;&lt;1) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_CRTC_C	((1&lt;&lt;2) | DRM_MODE_TYPE_BUILTIN)
+#define DRM_MODE_TYPE_PREFERRED	(1&lt;&lt;3)
+#define DRM_MODE_TYPE_DEFAULT	(1&lt;&lt;4)
+#define DRM_MODE_TYPE_USERDEF	(1&lt;&lt;5)
+#define DRM_MODE_TYPE_DRIVER	(1&lt;&lt;6)
+
+/* Video mode flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_FLAG_PHSYNC	(1&lt;&lt;0)
+#define DRM_MODE_FLAG_NHSYNC	(1&lt;&lt;1)
+#define DRM_MODE_FLAG_PVSYNC	(1&lt;&lt;2)
+#define DRM_MODE_FLAG_NVSYNC	(1&lt;&lt;3)
+#define DRM_MODE_FLAG_INTERLACE	(1&lt;&lt;4)
+#define DRM_MODE_FLAG_DBLSCAN	(1&lt;&lt;5)
+#define DRM_MODE_FLAG_CSYNC	(1&lt;&lt;6)
+#define DRM_MODE_FLAG_PCSYNC	(1&lt;&lt;7)
+#define DRM_MODE_FLAG_NCSYNC	(1&lt;&lt;8)
+#define DRM_MODE_FLAG_HSKEW	(1&lt;&lt;9) /* hskew provided */
+#define DRM_MODE_FLAG_BCAST	(1&lt;&lt;10)
+#define DRM_MODE_FLAG_PIXMUX	(1&lt;&lt;11)
+#define DRM_MODE_FLAG_DBLCLK	(1&lt;&lt;12)
+#define DRM_MODE_FLAG_CLKDIV2	(1&lt;&lt;13)
+
+/* DPMS flags */
+/* bit compatible with the xorg definitions. */
+#define DRM_MODE_DPMS_ON	0
+#define DRM_MODE_DPMS_STANDBY	1
+#define DRM_MODE_DPMS_SUSPEND	2
+#define DRM_MODE_DPMS_OFF	3
+
+/* Scaling mode options */
+#define DRM_MODE_SCALE_NON_GPU		0
+#define DRM_MODE_SCALE_FULLSCREEN	1
+#define DRM_MODE_SCALE_NO_SCALE		2
+#define DRM_MODE_SCALE_ASPECT		3
+
+/* Dithering mode options */
+#define DRM_MODE_DITHERING_OFF	0
+#define DRM_MODE_DITHERING_ON	1
+
+struct drm_mode_modeinfo {
+	uint32_t clock;
+	uint16_t hdisplay, hsync_start, hsync_end, htotal, hskew;
+	uint16_t vdisplay, vsync_start, vsync_end, vtotal, vscan;
+
+	uint32_t vrefresh; /* vertical refresh * 1000 */
+
+	uint32_t flags;
+	uint32_t type;
+	char name[DRM_DISPLAY_MODE_LEN];
+};
+
+struct drm_mode_card_res {
+	uint64_t fb_id_ptr;
+	uint64_t crtc_id_ptr;
+	uint64_t connector_id_ptr;
+	uint64_t encoder_id_ptr;
+	uint32_t count_fbs;
+	uint32_t count_crtcs;
+	uint32_t count_connectors;
+	uint32_t count_encoders;
+	uint32_t min_width, max_width;
+	uint32_t min_height, max_height;
+};
+
+struct drm_mode_crtc {
+	uint64_t set_connectors_ptr;
+	uint32_t count_connectors;
+
+	uint32_t crtc_id; /**&lt; Id */
+	uint32_t fb_id; /**&lt; Id of framebuffer */
+
+	uint32_t x, y; /**&lt; Position on the frameuffer */
+
+	uint32_t gamma_size;
+	uint32_t mode_valid;
+	struct drm_mode_modeinfo mode;
+};
+
+#define DRM_MODE_ENCODER_NONE	0
+#define DRM_MODE_ENCODER_DAC	1
+#define DRM_MODE_ENCODER_TMDS	2
+#define DRM_MODE_ENCODER_LVDS	3
+#define DRM_MODE_ENCODER_TVDAC	4
+
+struct drm_mode_get_encoder {

[... truncated: 24668 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020576.html">[Haiku-commits] r33085 - haiku/trunk/src/apps/bootman
</A></li>
	<LI>Next message: <A HREF="020578.html">[Haiku-commits] r33087 - in	haiku/branches/components/gallium3d/src/libs/drm: . intel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20577">[ date ]</a>
              <a href="thread.html#20577">[ thread ]</a>
              <a href="subject.html#20577">[ subject ]</a>
              <a href="author.html#20577">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
