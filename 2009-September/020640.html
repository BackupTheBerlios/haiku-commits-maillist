<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r33145 - in	haiku/branches/components/gallium3d/src/libs: .	mesa/gallium/auxiliary/tgsi mesa/gallium/auxiliary/util	mesa/gallium/include/pipe mesa/mesa/shader mesa/mesa/state_tracker
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33145%20-%20in%0A%09haiku/branches/components/gallium3d/src/libs%3A%20.%0A%09mesa/gallium/auxiliary/tgsi%20mesa/gallium/auxiliary/util%0A%09mesa/gallium/include/pipe%20mesa/mesa/shader%20mesa/mesa/state_tracker&In-Reply-To=%3C200909150921.n8F9LYDn008278%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020639.html">
   <LINK REL="Next"  HREF="020641.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r33145 - in	haiku/branches/components/gallium3d/src/libs: .	mesa/gallium/auxiliary/tgsi mesa/gallium/auxiliary/util	mesa/gallium/include/pipe mesa/mesa/shader mesa/mesa/state_tracker</H1>
    <B>aljen at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r33145%20-%20in%0A%09haiku/branches/components/gallium3d/src/libs%3A%20.%0A%09mesa/gallium/auxiliary/tgsi%20mesa/gallium/auxiliary/util%0A%09mesa/gallium/include/pipe%20mesa/mesa/shader%20mesa/mesa/state_tracker&In-Reply-To=%3C200909150921.n8F9LYDn008278%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r33145 - in	haiku/branches/components/gallium3d/src/libs: .	mesa/gallium/auxiliary/tgsi mesa/gallium/auxiliary/util	mesa/gallium/include/pipe mesa/mesa/shader mesa/mesa/state_tracker">aljen at mail.berlios.de
       </A><BR>
    <I>Tue Sep 15 11:21:34 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020639.html">[Haiku-commits] r33144 - in	haiku/branches/components/gallium3d/src: add-ons/opengl/i915	add-ons/opengl/softpipe kits/opengl libs/mesa	libs/mesa/gallium libs/mesa/gallium/auxiliary	libs/mesa/gallium/auxiliary/cso_cache	libs/mesa/gallium/auxiliary/draw libs/mesa/gallium/auxiliary/gallivm	libs/mesa/gallium/auxiliary/indices	libs/mesa/gallium/auxiliary/pipebuffer	libs/mesa/gallium/auxiliary/rbug libs/mesa/gallium/auxiliary/rtasm	libs/mesa/gallium/auxiliary/sct libs/mesa/gallium/auxiliary/tgsi	libs/mesa/gallium/auxiliary/translate	libs/mesa/gallium/auxiliary/util libs/mesa/gallium/drivers	libs/mesa/gallium/drivers/failover	libs/mesa/gallium/drivers/i915simple	libs/mesa/gallium/drivers/softpipe libs/mesa/gallium/drivers/trace	libs/mesa/gallium/state_trackers	libs/mesa/gallium/state_trackers/dri libs/mesa/glu	libs/mesa/glut libs/mesa/mesa libs/mesa/mesa/drivers/dri/common
</A></li>
        <LI>Next message: <A HREF="020641.html">[Haiku-commits] r33146 -	haiku/trunk/src/add-ons/kernel/partitioning_systems/intel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20640">[ date ]</a>
              <a href="thread.html#20640">[ thread ]</a>
              <a href="subject.html#20640">[ subject ]</a>
              <a href="author.html#20640">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: aljen
Date: 2009-09-15 11:21:08 +0200 (Tue, 15 Sep 2009)
New Revision: 33145
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=33145&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=33145&amp;view=rev</A>

Modified:
   haiku/branches/components/gallium3d/src/libs/Jamfile
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.c
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.h
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sse2.c
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.c
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.h
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_format.csv
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_math.h
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_simple_shaders.c
   haiku/branches/components/gallium3d/src/libs/mesa/gallium/include/pipe/p_inlines.h
   haiku/branches/components/gallium3d/src/libs/mesa/mesa/shader/prog_instruction.h
   haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_mesa_to_tgsi.c
   haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_mesa_to_tgsi.h
   haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_program.c
Log:
* Updated mesa to latest version from git
* Added src/libs/mesa to src/libs/Jamfile



Modified: haiku/branches/components/gallium3d/src/libs/Jamfile
===================================================================
--- haiku/branches/components/gallium3d/src/libs/Jamfile	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/Jamfile	2009-09-15 09:21:08 UTC (rev 33145)
@@ -18,6 +18,7 @@
 SubInclude HAIKU_TOP src libs linprog ;
 SubInclude HAIKU_TOP src libs lp_solve ;
 SubInclude HAIKU_TOP src libs mapm ;
+SubInclude HAIKU_TOP src libs mesa ;
 SubInclude HAIKU_TOP src libs ncurses ;
 SubInclude HAIKU_TOP src libs pdflib ;
 SubInclude HAIKU_TOP src libs png ;

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.c
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.c	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.c	2009-09-15 09:21:08 UTC (rev 33145)
@@ -358,7 +358,7 @@
 
 boolean
 tgsi_sanity_check(
-   struct tgsi_token *tokens )
+   const struct tgsi_token *tokens )
 {
    struct sanity_check_ctx ctx;
 

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.h
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.h	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sanity.h	2009-09-15 09:21:08 UTC (rev 33145)
@@ -40,7 +40,7 @@
  */
 boolean
 tgsi_sanity_check(
-   struct tgsi_token *tokens );
+   const struct tgsi_token *tokens );
 
 #if defined __cplusplus
 }

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sse2.c
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sse2.c	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_sse2.c	2009-09-15 09:21:08 UTC (rev 33145)
@@ -39,8 +39,9 @@
 #include &quot;tgsi/tgsi_info.h&quot;
 #include &quot;tgsi/tgsi_parse.h&quot;
 #include &quot;tgsi/tgsi_util.h&quot;
-#include &quot;tgsi_exec.h&quot;
-#include &quot;tgsi_sse2.h&quot;
+#include &quot;tgsi/tgsi_dump.h&quot;
+#include &quot;tgsi/tgsi_exec.h&quot;
+#include &quot;tgsi/tgsi_sse2.h&quot;
 
 #include &quot;rtasm/rtasm_x86sse.h&quot;
 
@@ -1360,6 +1361,32 @@
    const struct tgsi_full_instruction *inst,
    unsigned chan_index )
 {
+   switch( inst-&gt;Instruction.Saturate ) {
+   case TGSI_SAT_NONE:
+      break;
+
+   case TGSI_SAT_ZERO_ONE:
+      sse_maxps(
+         func,
+         make_xmm( xmm ),
+         get_temp(
+            TGSI_EXEC_TEMP_00000000_I,
+            TGSI_EXEC_TEMP_00000000_C ) );
+
+      sse_minps(
+         func,
+         make_xmm( xmm ),
+         get_temp(
+            TGSI_EXEC_TEMP_ONE_I,
+            TGSI_EXEC_TEMP_ONE_C ) );
+      break;
+
+   case TGSI_SAT_MINUS_PLUS_ONE:
+      assert( 0 );
+      break;
+   }
+
+
    switch( reg-&gt;DstRegister.File ) {
    case TGSI_FILE_OUTPUT:
       emit_output(
@@ -1388,19 +1415,6 @@
    default:
       assert( 0 );
    }
-
-   switch( inst-&gt;Instruction.Saturate ) {
-   case TGSI_SAT_NONE:
-      break;
-
-   case TGSI_SAT_ZERO_ONE:
-      /* assert( 0 ); */
-      break;
-
-   case TGSI_SAT_MINUS_PLUS_ONE:
-      assert( 0 );
-      break;
-   }
 }
 
 #define STORE( FUNC, INST, XMM, INDEX, CHAN )\
@@ -1747,14 +1761,6 @@
    if (indirect_temp_reference(inst))
       return FALSE;
 
-   /* we don't handle saturation/clamping yet */
-   if (inst-&gt;Instruction.Saturate != TGSI_SAT_NONE)
-      return FALSE;
-
-   /* need to use extra temps to fix SOA dependencies : */
-   if (tgsi_check_soa_dependencies(inst))
-      return FALSE;
-
    switch (inst-&gt;Instruction.Opcode) {
    case TGSI_OPCODE_ARL:
       FOR_EACH_DST0_ENABLED_CHANNEL( *inst, chan_index ) {
@@ -1768,9 +1774,11 @@
    case TGSI_OPCODE_MOV:
    case TGSI_OPCODE_SWZ:
       FOR_EACH_DST0_ENABLED_CHANNEL( *inst, chan_index ) {
-         FETCH( func, *inst, 0, 0, chan_index );
-         STORE( func, *inst, 0, 0, chan_index );
+         FETCH( func, *inst, 4 + chan_index, 0, chan_index );
       }
+      FOR_EACH_DST0_ENABLED_CHANNEL( *inst, chan_index ) {
+         STORE( func, *inst, 4 + chan_index, 0, chan_index );
+      }
       break;
 
    case TGSI_OPCODE_LIT:
@@ -2929,6 +2937,22 @@
                          parse.FullHeader.Processor.Processor == TGSI_PROCESSOR_VERTEX ?
                          &quot;vertex shader&quot; : &quot;fragment shader&quot;);
 	 }
+
+         if (tgsi_check_soa_dependencies(&amp;parse.FullToken.FullInstruction)) {
+            uint opcode = parse.FullToken.FullInstruction.Instruction.Opcode;
+
+            /* XXX: we only handle src/dst aliasing in a few opcodes
+             * currently.  Need to use an additional temporay to hold
+             * the result in the cases where the code is too opaque to
+             * fix.
+             */
+            if (opcode != TGSI_OPCODE_MOV &amp;&amp;
+                opcode != TGSI_OPCODE_SWZ) {
+               debug_printf(&quot;Warning: src/dst aliasing in instruction&quot;
+                            &quot; is not handled:\n&quot;);
+               tgsi_dump_instruction(&amp;parse.FullToken.FullInstruction, 1);
+            }
+         }
          break;
 
       case TGSI_TOKEN_TYPE_IMMEDIATE:

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.c
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.c	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.c	2009-09-15 09:21:08 UTC (rev 33145)
@@ -31,6 +31,7 @@
 #include &quot;tgsi/tgsi_ureg.h&quot;
 #include &quot;tgsi/tgsi_info.h&quot;
 #include &quot;tgsi/tgsi_dump.h&quot;
+#include &quot;tgsi/tgsi_sanity.h&quot;
 #include &quot;util/u_memory.h&quot;
 #include &quot;util/u_math.h&quot;
 
@@ -70,6 +71,7 @@
 
 #define UREG_MAX_INPUT PIPE_MAX_ATTRIBS
 #define UREG_MAX_OUTPUT PIPE_MAX_ATTRIBS
+#define UREG_MAX_CONSTANT_RANGE 32
 #define UREG_MAX_IMMEDIATE 32
 #define UREG_MAX_TEMP 256
 #define UREG_MAX_ADDR 2
@@ -86,9 +88,11 @@
       unsigned semantic_name;
       unsigned semantic_index;
       unsigned interp;
-   } input[UREG_MAX_INPUT];
-   unsigned nr_inputs;
+   } fs_input[UREG_MAX_INPUT];
+   unsigned nr_fs_inputs;
 
+   unsigned vs_inputs[UREG_MAX_INPUT/32];
+
    struct {
       unsigned semantic_name;
       unsigned semantic_index;
@@ -107,9 +111,13 @@
    unsigned temps_active[UREG_MAX_TEMP / 32];
    unsigned nr_temps;
 
+   struct {
+      unsigned first;
+      unsigned last;
+   } constant_range[UREG_MAX_CONSTANT_RANGE];
+   unsigned nr_constant_ranges;
+
    unsigned nr_addrs;
-
-   unsigned nr_constants;
    unsigned nr_instructions;
 
    struct ureg_tokens domain[2];
@@ -119,6 +127,9 @@
 
 static void tokens_error( struct ureg_tokens *tokens )
 {
+   if (tokens-&gt;tokens &amp;&amp; tokens-&gt;tokens != error_tokens)
+      FREE(tokens-&gt;tokens);
+
    tokens-&gt;tokens = error_tokens;
    tokens-&gt;size = Elements(error_tokens);
    tokens-&gt;count = 0;
@@ -228,25 +239,25 @@
 
 
 
-static struct ureg_src 
-ureg_DECL_input( struct ureg_program *ureg,
-                 unsigned name,
-                 unsigned index,
-                 unsigned interp_mode )
+struct ureg_src 
+ureg_DECL_fs_input( struct ureg_program *ureg,
+                    unsigned name,
+                    unsigned index,
+                    unsigned interp_mode )
 {
    unsigned i;
 
-   for (i = 0; i &lt; ureg-&gt;nr_inputs; i++) {
-      if (ureg-&gt;input[i].semantic_name == name &amp;&amp;
-          ureg-&gt;input[i].semantic_index == index) 
+   for (i = 0; i &lt; ureg-&gt;nr_fs_inputs; i++) {
+      if (ureg-&gt;fs_input[i].semantic_name == name &amp;&amp;
+          ureg-&gt;fs_input[i].semantic_index == index) 
          goto out;
    }
 
-   if (ureg-&gt;nr_inputs &lt; UREG_MAX_INPUT) {
-      ureg-&gt;input[i].semantic_name = name;
-      ureg-&gt;input[i].semantic_index = index;
-      ureg-&gt;input[i].interp = interp_mode;
-      ureg-&gt;nr_inputs++;
+   if (ureg-&gt;nr_fs_inputs &lt; UREG_MAX_INPUT) {
+      ureg-&gt;fs_input[i].semantic_name = name;
+      ureg-&gt;fs_input[i].semantic_index = index;
+      ureg-&gt;fs_input[i].interp = interp_mode;
+      ureg-&gt;nr_fs_inputs++;
    }
    else {
       set_bad( ureg );
@@ -257,25 +268,14 @@
 }
 
 
-
 struct ureg_src 
-ureg_DECL_fs_input( struct ureg_program *ureg,
-                    unsigned name,
-                    unsigned index,
-                    unsigned interp )
-{
-   assert(ureg-&gt;processor == TGSI_PROCESSOR_FRAGMENT);
-   return ureg_DECL_input( ureg, name, index, interp );
-}
-
-
-struct ureg_src 
 ureg_DECL_vs_input( struct ureg_program *ureg,
-                    unsigned name,
                     unsigned index )
 {
    assert(ureg-&gt;processor == TGSI_PROCESSOR_VERTEX);
-   return ureg_DECL_input( ureg, name, index, TGSI_INTERPOLATE_CONSTANT );
+   
+   ureg-&gt;vs_inputs[index/32] |= 1 &lt;&lt; (index % 32);
+   return ureg_src_register( TGSI_FILE_INPUT, index );
 }
 
 
@@ -313,9 +313,57 @@
  * value or manage any constant_buffer contents -- that's the
  * resposibility of the calling code.
  */
-struct ureg_src ureg_DECL_constant(struct ureg_program *ureg )
+struct ureg_src ureg_DECL_constant(struct ureg_program *ureg, 
+                                   unsigned index )
 {
-   return ureg_src_register( TGSI_FILE_CONSTANT, ureg-&gt;nr_constants++ );
+   unsigned minconst = index, maxconst = index;
+   unsigned i;
+
+   /* Inside existing range?
+    */
+   for (i = 0; i &lt; ureg-&gt;nr_constant_ranges; i++) {
+      if (ureg-&gt;constant_range[i].first &lt;= index &amp;&amp;
+          ureg-&gt;constant_range[i].last &gt;= index)
+         goto out;
+   }
+
+   /* Extend existing range?
+    */
+   for (i = 0; i &lt; ureg-&gt;nr_constant_ranges; i++) {
+      if (ureg-&gt;constant_range[i].last == index - 1) {
+         ureg-&gt;constant_range[i].last = index;
+         goto out;
+      }
+
+      if (ureg-&gt;constant_range[i].first == index + 1) {
+         ureg-&gt;constant_range[i].first = index;
+         goto out;
+      }
+
+      minconst = MIN2(minconst, ureg-&gt;constant_range[i].first);
+      maxconst = MAX2(maxconst, ureg-&gt;constant_range[i].last);
+   }
+
+   /* Create new range?
+    */
+   if (ureg-&gt;nr_constant_ranges &lt; UREG_MAX_CONSTANT_RANGE) {
+      i = ureg-&gt;nr_constant_ranges++;
+      ureg-&gt;constant_range[i].first = index;
+      ureg-&gt;constant_range[i].last = index;
+   }
+
+   /* Collapse all ranges down to one:
+    */
+   i = 0;
+   ureg-&gt;constant_range[0].first = minconst;
+   ureg-&gt;constant_range[0].last = maxconst;
+   ureg-&gt;nr_constant_ranges = 1;
+
+out:
+   assert(i &lt; ureg-&gt;nr_constant_ranges);
+   assert(ureg-&gt;constant_range[i].first &lt;= index);
+   assert(ureg-&gt;constant_range[i].last &gt;= index);
+   return ureg_src_register( TGSI_FILE_CONSTANT, index );
 }
 
 
@@ -566,6 +614,19 @@
 }
 
 
+static void validate( unsigned opcode,
+                      unsigned nr_dst,
+                      unsigned nr_src )
+{
+#ifdef DEBUG
+   const struct tgsi_opcode_info *info = tgsi_get_opcode_info( opcode );
+   assert(info);
+   if(info) {
+      assert(nr_dst == info-&gt;num_dst);
+      assert(nr_src == info-&gt;num_src);
+   }
+#endif
+}
 
 unsigned
 ureg_emit_insn(struct ureg_program *ureg,
@@ -576,6 +637,8 @@
 {
    union tgsi_any_token *out;
 
+   validate( opcode, num_dst, num_src );
+   
    out = get_tokens( ureg, DOMAIN_INSN, 1 );
    out[0].value = 0;
    out[0].insn.Type = TGSI_TOKEN_TYPE_INSTRUCTION;
@@ -678,17 +741,6 @@
    unsigned insn, i;
    boolean saturate;
 
-#ifdef DEBUG
-   {
-      const struct tgsi_opcode_info *info = tgsi_get_opcode_info( opcode );
-      assert(info);
-      if(info) {
-         assert(nr_dst == info-&gt;num_dst);
-         assert(nr_src == info-&gt;num_src);
-      }
-   }
-#endif
-   
    saturate = nr_dst ? dst[0].Saturate : FALSE;
 
    insn = ureg_emit_insn( ureg, opcode, saturate, nr_dst, nr_src );
@@ -702,8 +754,55 @@
    ureg_fixup_insn_size( ureg, insn );
 }
 
+void
+ureg_tex_insn(struct ureg_program *ureg,
+              unsigned opcode,
+              const struct ureg_dst *dst,
+              unsigned nr_dst,
+              unsigned target,
+              const struct ureg_src *src,
+              unsigned nr_src )
+{
+   unsigned insn, i;
+   boolean saturate;
 
+   saturate = nr_dst ? dst[0].Saturate : FALSE;
 
+   insn = ureg_emit_insn( ureg, opcode, saturate, nr_dst, nr_src );
+
+   ureg_emit_texture( ureg, insn, target );                             \
+
+   for (i = 0; i &lt; nr_dst; i++)
+      ureg_emit_dst( ureg, dst[i] );
+
+   for (i = 0; i &lt; nr_src; i++)
+      ureg_emit_src( ureg, src[i] );
+
+   ureg_fixup_insn_size( ureg, insn );
+}
+
+
+void
+ureg_label_insn(struct ureg_program *ureg,
+                unsigned opcode,
+                const struct ureg_src *src,
+                unsigned nr_src,
+                unsigned *label_token )
+{
+   unsigned insn, i;
+
+   insn = ureg_emit_insn( ureg, opcode, FALSE, 0, nr_src );
+
+   ureg_emit_label( ureg, insn, label_token );                  \
+
+   for (i = 0; i &lt; nr_src; i++)
+      ureg_emit_src( ureg, src[i] );
+
+   ureg_fixup_insn_size( ureg, insn );
+}
+
+
+
 static void emit_decl( struct ureg_program *ureg,
                        unsigned file,
                        unsigned index,
@@ -777,14 +876,23 @@
 {
    unsigned i;
 
-   for (i = 0; i &lt; ureg-&gt;nr_inputs; i++) {
-      emit_decl( ureg, 
-                 TGSI_FILE_INPUT, 
-                 i,
-                 ureg-&gt;input[i].semantic_name,
-                 ureg-&gt;input[i].semantic_index,
-                 ureg-&gt;input[i].interp );
+   if (ureg-&gt;processor == TGSI_PROCESSOR_VERTEX) {
+      for (i = 0; i &lt; UREG_MAX_INPUT; i++) {
+         if (ureg-&gt;vs_inputs[i/32] &amp; (1 &lt;&lt; (i%32))) {
+            emit_decl_range( ureg, TGSI_FILE_INPUT, i, 1 );
+         }
+      }
    }
+   else {
+      for (i = 0; i &lt; ureg-&gt;nr_fs_inputs; i++) {
+         emit_decl( ureg, 
+                    TGSI_FILE_INPUT, 
+                    i,
+                    ureg-&gt;fs_input[i].semantic_name,
+                    ureg-&gt;fs_input[i].semantic_index,
+                    ureg-&gt;fs_input[i].interp );
+      }
+   }
 
    for (i = 0; i &lt; ureg-&gt;nr_outputs; i++) {
       emit_decl( ureg, 
@@ -801,10 +909,13 @@
                        ureg-&gt;sampler[i].Index, 1 );
    }
 
-   if (ureg-&gt;nr_constants) {
-      emit_decl_range( ureg,
-                       TGSI_FILE_CONSTANT,
-                       0, ureg-&gt;nr_constants );
+   if (ureg-&gt;nr_constant_ranges) {
+      for (i = 0; i &lt; ureg-&gt;nr_constant_ranges; i++)
+         emit_decl_range( ureg,
+                          TGSI_FILE_CONSTANT,
+                          ureg-&gt;constant_range[i].first, 
+                          (ureg-&gt;constant_range[i].last + 1 -
+                           ureg-&gt;constant_range[i].first) );
    }
 
    if (ureg-&gt;nr_temps) {
@@ -890,6 +1001,15 @@
                    ureg-&gt;domain[DOMAIN_DECL].count);
       tgsi_dump( tokens, 0 );
    }
+
+#if DEBUG
+   if (tokens &amp;&amp; !tgsi_sanity_check(tokens)) {
+      debug_printf(&quot;tgsi_ureg.c, sanity check failed on generated tokens:\n&quot;);
+      tgsi_dump(tokens, 0);
+      assert(0);
+   }
+#endif
+
    
    return tokens;
 }
@@ -911,8 +1031,27 @@
 }
 
 
+const struct tgsi_token *ureg_get_tokens( struct ureg_program *ureg,
+                                          unsigned *nr_tokens )
+{
+   const struct tgsi_token *tokens;
 
+   ureg_finalize(ureg);
 
+   tokens = &amp;ureg-&gt;domain[DOMAIN_DECL].tokens[0].token;
+
+   if (nr_tokens) 
+      *nr_tokens = ureg-&gt;domain[DOMAIN_DECL].size;
+
+   ureg-&gt;domain[DOMAIN_DECL].tokens = 0;
+   ureg-&gt;domain[DOMAIN_DECL].size = 0;
+   ureg-&gt;domain[DOMAIN_DECL].order = 0;
+   ureg-&gt;domain[DOMAIN_DECL].count = 0;
+
+   return tokens;
+}
+
+
 struct ureg_program *ureg_create( unsigned processor )
 {
    struct ureg_program *ureg = CALLOC_STRUCT( ureg_program );

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.h
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.h	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/tgsi/tgsi_ureg.h	2009-09-15 09:21:08 UTC (rev 33145)
@@ -82,10 +82,21 @@
 const struct tgsi_token *
 ureg_finalize( struct ureg_program * );
 
+/* Create and return a shader:
+ */
 void *
 ureg_create_shader( struct ureg_program *,
                     struct pipe_context *pipe );
 
+
+/* Alternately, return the built token stream and hand ownership of
+ * that memory to the caller:
+ */
+const struct tgsi_token *
+ureg_get_tokens( struct ureg_program *ureg,
+                 unsigned *nr_tokens );
+
+
 void 
 ureg_destroy( struct ureg_program * );
 
@@ -116,8 +127,7 @@
 
 struct ureg_src
 ureg_DECL_vs_input( struct ureg_program *,
-                    unsigned semantic_name,
-                    unsigned semantic_index );
+                    unsigned index );
 
 struct ureg_dst
 ureg_DECL_output( struct ureg_program *,
@@ -130,7 +140,8 @@
                      unsigned nr );
 
 struct ureg_src
-ureg_DECL_constant( struct ureg_program * );
+ureg_DECL_constant( struct ureg_program *,
+                    unsigned index );
 
 struct ureg_dst
 ureg_DECL_temporary( struct ureg_program * );
@@ -233,6 +244,24 @@
           unsigned nr_src );
 
 
+void
+ureg_tex_insn(struct ureg_program *ureg,
+              unsigned opcode,
+              const struct ureg_dst *dst,
+              unsigned nr_dst,
+              unsigned target,
+              const struct ureg_src *src,
+              unsigned nr_src );
+
+
+void
+ureg_label_insn(struct ureg_program *ureg,
+                unsigned opcode,
+                const struct ureg_src *src,
+                unsigned nr_src,
+                unsigned *label);
+
+
 /***********************************************************************
  * Internal instruction helpers, don't call these directly:
  */

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_format.csv
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_format.csv	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_format.csv	2009-09-15 09:21:08 UTC (rev 33145)
@@ -2,7 +2,7 @@
 PIPE_FORMAT_X8R8G8B8_UNORM        , arith , 1, 1, un8 , un8 , un8 , un8 , zyx1, rgb
 PIPE_FORMAT_B8G8R8A8_UNORM        , arith , 1, 1, un8 , un8 , un8 , un8 , yzwx, rgb
 PIPE_FORMAT_B8G8R8X8_UNORM        , arith , 1, 1, un8 , un8 , un8 , un8 , yzw1, rgb
-PIPE_FORMAT_A1R5G5B5_UNORM        , arith , 1, 1, un1 , un5 , un5 , un5 , zyxw, rgb
+PIPE_FORMAT_A1R5G5B5_UNORM        , arith , 1, 1, un5 , un5 , un5 , un1 , zyxw, rgb
 PIPE_FORMAT_A4R4G4B4_UNORM        , arith , 1, 1, un4 , un4 , un4 , un4 , zyxw, rgb
 PIPE_FORMAT_R5G6B5_UNORM          , arith , 1, 1, un5 , un6 , un5 ,     , zyx1, rgb
 PIPE_FORMAT_A2B10G10R10_UNORM     , arith , 1, 1, un10, un10, un10, un2 , xyzw, rgb

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_math.h
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_math.h	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_math.h	2009-09-15 09:21:08 UTC (rev 33145)
@@ -354,7 +354,9 @@
  * Find first bit set in word.  Least significant bit is 1.
  * Return 0 if no bits set.
  */
-#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1300
+#if defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1300 &amp;&amp; (_M_IX86 || _M_AMD64 || _M_IA64)
+unsigned char _BitScanForward(unsigned long* Index, unsigned long Mask);
+#pragma intrinsic(_BitScanForward)
 static INLINE
 unsigned long ffs( unsigned long u )
 {

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_simple_shaders.c
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_simple_shaders.c	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/auxiliary/util/u_simple_shaders.c	2009-09-15 09:21:08 UTC (rev 33145)
@@ -61,9 +61,7 @@
       struct ureg_src src;
       struct ureg_dst dst;
 
-      src = ureg_DECL_vs_input( ureg,
-                                semantic_names[i],
-                                semantic_indexes[i]);
+      src = ureg_DECL_vs_input( ureg, i );
       
       dst = ureg_DECL_output( ureg,
                               semantic_names[i],

Modified: haiku/branches/components/gallium3d/src/libs/mesa/gallium/include/pipe/p_inlines.h
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/gallium/include/pipe/p_inlines.h	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/gallium/include/pipe/p_inlines.h	2009-09-15 09:21:08 UTC (rev 33145)
@@ -155,7 +155,20 @@
    }
 }
 
+static INLINE void *
+pipe_transfer_map( struct pipe_transfer *transf )
+{
+   struct pipe_screen *screen = transf-&gt;texture-&gt;screen;
+   return screen-&gt;transfer_map(screen, transf);
+}
 
+static INLINE void
+pipe_transfer_unmap( struct pipe_transfer *transf )
+{
+   struct pipe_screen *screen = transf-&gt;texture-&gt;screen;
+   screen-&gt;transfer_unmap(screen, transf);
+}
+
 #ifdef __cplusplus
 }
 #endif

Modified: haiku/branches/components/gallium3d/src/libs/mesa/mesa/shader/prog_instruction.h
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/mesa/shader/prog_instruction.h	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/mesa/shader/prog_instruction.h	2009-09-15 09:21:08 UTC (rev 33145)
@@ -121,7 +121,6 @@
 /*@{*/
 #define SATURATE_OFF            0
 #define SATURATE_ZERO_ONE       1
-#define SATURATE_PLUS_MINUS_ONE 2
 /*@}*/
 
 

Modified: haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_mesa_to_tgsi.c
===================================================================
--- haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_mesa_to_tgsi.c	2009-09-15 08:50:18 UTC (rev 33144)
+++ haiku/branches/components/gallium3d/src/libs/mesa/mesa/state_tracker/st_mesa_to_tgsi.c	2009-09-15 09:21:08 UTC (rev 33145)
@@ -27,857 +27,668 @@
 
 /*
  * \author
- * Michal Krol
+ * Michal Krol,
+ * Keith Whitwell
  */
 
 #include &quot;pipe/p_compiler.h&quot;
 #include &quot;pipe/p_shader_tokens.h&quot;
-#include &quot;tgsi/tgsi_parse.h&quot;
-#include &quot;tgsi/tgsi_build.h&quot;
-#include &quot;tgsi/tgsi_util.h&quot;
-#include &quot;tgsi/tgsi_dump.h&quot;
-#include &quot;tgsi/tgsi_sanity.h&quot;
+#include &quot;pipe/p_state.h&quot;
+#include &quot;tgsi/tgsi_ureg.h&quot;
 #include &quot;st_mesa_to_tgsi.h&quot;
 #include &quot;shader/prog_instruction.h&quot;
 #include &quot;shader/prog_parameter.h&quot;
 #include &quot;shader/prog_print.h&quot;
 #include &quot;util/u_debug.h&quot;
+#include &quot;util/u_math.h&quot;
+#include &quot;util/u_memory.h&quot;
 
+struct label {
+   unsigned branch_target;
+   unsigned token;
+};
+
+struct st_translate {
+   struct ureg_program *ureg;
+
+   struct ureg_dst temps[MAX_PROGRAM_TEMPS];
+   struct ureg_src *constants;
+   struct ureg_dst outputs[PIPE_MAX_SHADER_OUTPUTS];
+   struct ureg_src inputs[PIPE_MAX_SHADER_INPUTS];
+   struct ureg_dst address[1];
+   struct ureg_src samplers[PIPE_MAX_SAMPLERS];
+
+   const GLuint *inputMapping;
+   const GLuint *outputMapping;
+
+   /* For every instruction that contains a label (eg CALL), keep
+    * details so that we can go back afterwards and emit the correct
+    * tgsi instruction number for each label.
+    */
+   struct label *labels;
+   unsigned labels_size;
+   unsigned labels_count;
+
+   /* Keep a record of the tgsi instruction number that each mesa
+    * instruction starts at, will be used to fix up labels after
+    * translation.
+    */
+   unsigned *insn;
+   unsigned insn_size;
+   unsigned insn_count;
+
+   unsigned procType;  /**&lt; TGSI_PROCESSOR_VERTEX/FRAGMENT */
+
+   boolean error;
+};
+
+
+static unsigned *get_label( struct st_translate *t,
+                            unsigned branch_target )
+{
+   unsigned i;
+
+   if (t-&gt;labels_count + 1 &gt;= t-&gt;labels_size) {
+      unsigned old_size = t-&gt;labels_size;
+      t-&gt;labels_size = 1 &lt;&lt; (util_logbase2(t-&gt;labels_size) + 1);
+      t-&gt;labels = REALLOC( t-&gt;labels, 
+                           old_size * sizeof t-&gt;labels[0], 
+                           t-&gt;labels_size * sizeof t-&gt;labels[0] );
+      if (t-&gt;labels == NULL) {
+         static unsigned dummy;
+         t-&gt;error = TRUE;
+         return &dummy;
+      }
+   }
+
+   i = t-&gt;labels_count++;
+   t-&gt;labels[i].branch_target = branch_target;
+   return &amp;t-&gt;labels[i].token;
+}
+
+
+static void set_insn_start( struct st_translate *t,
+                            unsigned start )
+{
+   if (t-&gt;insn_count + 1 &gt;= t-&gt;insn_size) {
+      unsigned old_size = t-&gt;insn_size;
+      t-&gt;insn_size = 1 &lt;&lt; (util_logbase2(t-&gt;insn_size) + 1);
+      t-&gt;insn = REALLOC( t-&gt;insn, 
+                         old_size * sizeof t-&gt;insn[0], 
+                         t-&gt;insn_size * sizeof t-&gt;insn[0] );
+      if (t-&gt;insn == NULL) {
+         t-&gt;error = TRUE;
+         return;
+      }
+   }
+
+   t-&gt;insn[t-&gt;insn_count++] = start;
+}
+
+
 /*
  * Map mesa register file to TGSI register file.
  */
-static GLuint
-map_register_file(
-   gl_register_file file,
-   GLuint index,
-   const GLuint immediateMapping[],
-   GLboolean indirectAccess )
+static struct ureg_dst
+dst_register( struct st_translate *t,
+              gl_register_file file,
+              GLuint index )
 {
    switch( file ) {
    case PROGRAM_UNDEFINED:
-      return TGSI_FILE_NULL;
+      return ureg_dst_undef();
+
    case PROGRAM_TEMPORARY:
-      return TGSI_FILE_TEMPORARY;
-   /*case PROGRAM_LOCAL_PARAM:*/
-   /*case PROGRAM_ENV_PARAM:*/
+      if (ureg_dst_is_undef(t-&gt;temps[index]))
+         t-&gt;temps[index] = ureg_DECL_temporary( t-&gt;ureg );
 
-      /* Because of the longstanding problem with mesa arb shaders
-       * where constants, immediates and state variables are all
-       * bundled together as PROGRAM_STATE_VAR, we can't tell from the
-       * mesa register file whether this is a CONSTANT or an
-       * IMMEDIATE, hence we need all the other information.
-       */
-   case PROGRAM_STATE_VAR:
-   case PROGRAM_NAMED_PARAM:
-   case PROGRAM_UNIFORM:
-      if (!indirectAccess &amp;&amp; immediateMapping &amp;&amp; immediateMapping[index] != ~0)
-         return TGSI_FILE_IMMEDIATE;
-      else
-	 return TGSI_FILE_CONSTANT;
-   case PROGRAM_CONSTANT:
-      if (indirectAccess)
-         return TGSI_FILE_CONSTANT;
-      assert(immediateMapping[index] != ~0);
-      return TGSI_FILE_IMMEDIATE;
-   case PROGRAM_INPUT:
-      return TGSI_FILE_INPUT;
+      return t-&gt;temps[index];
+
    case PROGRAM_OUTPUT:
-      return TGSI_FILE_OUTPUT;
+      return t-&gt;outputs[t-&gt;outputMapping[index]];
+
    case PROGRAM_ADDRESS:
-      return TGSI_FILE_ADDRESS;
+      return t-&gt;address[index];
+
    default:
       assert( 0 );
-      return TGSI_FILE_NULL;
+      return ureg_dst_undef();
    }
 }
 
-/**
- * Map mesa register file index to TGSI index.
- * Take special care when processing input and output indices.
- * \param file  one of TGSI_FILE_x
- * \param index  the mesa register file index
- * \param inputMapping  maps Mesa input indexes to TGSI input indexes
- * \param outputMapping  maps Mesa output indexes to TGSI output indexes
- */
-static GLuint
-map_register_file_index(
-   GLuint procType,
-   GLuint file,
-   GLuint index,
-   GLuint *swizzle,
-   const GLuint inputMapping[],
-   const GLuint outputMapping[],
-   const GLuint immediateMapping[],
-   GLboolean indirectAccess )
+
+static struct ureg_src
+src_register( struct st_translate *t,
+              gl_register_file file,
+              GLuint index )
 {
    switch( file ) {
-   case TGSI_FILE_INPUT:
-      /* inputs are mapped according to the user-defined map */
-      return inputMapping[index];
+   case PROGRAM_UNDEFINED:
+      return ureg_src_undef();
 
-   case TGSI_FILE_OUTPUT:
-      return outputMapping[index];
+   case PROGRAM_TEMPORARY:
+      if (ureg_dst_is_undef(t-&gt;temps[index]))
+         t-&gt;temps[index] = ureg_DECL_temporary( t-&gt;ureg );
+      return ureg_src(t-&gt;temps[index]);
 
-   case TGSI_FILE_IMMEDIATE:
-      if (indirectAccess)
-         return index;
-      assert(immediateMapping[index] != ~0);
-      return immediateMapping[index];
+   case PROGRAM_STATE_VAR:
+   case PROGRAM_NAMED_PARAM:
+   case PROGRAM_UNIFORM:
+   case PROGRAM_CONSTANT:
+      return t-&gt;constants[index];
 
+   case PROGRAM_INPUT:
+      return t-&gt;inputs[t-&gt;inputMapping[index]];
+
+   case PROGRAM_OUTPUT:
+      return ureg_src(t-&gt;outputs[t-&gt;outputMapping[index]]); /* not needed? */
+
+   case PROGRAM_ADDRESS:
+      return ureg_src(t-&gt;address[index]);
+
    default:
-      return index;
+      assert( 0 );
+      return ureg_src_undef();
    }
 }
 
-/*
+
+/**
  * Map mesa texture target to TGSI texture target.
  */
-static GLuint
-map_texture_target(
-    GLuint textarget,
-    GLboolean shadow )
+static unsigned
+translate_texture_target( GLuint textarget,
+                          GLboolean shadow )
 {
-   switch( textarget ) {
-   case TEXTURE_1D_INDEX:
-      if (shadow)
-         return TGSI_TEXTURE_SHADOW1D;
-      else
-         return TGSI_TEXTURE_1D;
-   case TEXTURE_2D_INDEX:
-      if (shadow)
-         return TGSI_TEXTURE_SHADOW2D;
-      else
-         return TGSI_TEXTURE_2D;
-   case TEXTURE_3D_INDEX:
-      return TGSI_TEXTURE_3D;
-   case TEXTURE_CUBE_INDEX:
-      return TGSI_TEXTURE_CUBE;
-   case TEXTURE_RECT_INDEX:
-      if (shadow)
-         return TGSI_TEXTURE_SHADOWRECT;
-      else
-         return TGSI_TEXTURE_RECT;
-   default:
-      assert( 0 );
+   if (shadow) {
+      switch( textarget ) {
+      case TEXTURE_1D_INDEX:   return TGSI_TEXTURE_SHADOW1D;
+      case TEXTURE_2D_INDEX:   return TGSI_TEXTURE_SHADOW2D;
+      case TEXTURE_RECT_INDEX: return TGSI_TEXTURE_SHADOWRECT;
+      default: break;
+      }
    }
 
-   return TGSI_TEXTURE_1D;
-}
-
-static GLuint
-convert_sat(
-   GLuint sat )
-{
-   switch( sat ) {
-   case SATURATE_OFF:
-      return TGSI_SAT_NONE;

[... truncated: 1683 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020639.html">[Haiku-commits] r33144 - in	haiku/branches/components/gallium3d/src: add-ons/opengl/i915	add-ons/opengl/softpipe kits/opengl libs/mesa	libs/mesa/gallium libs/mesa/gallium/auxiliary	libs/mesa/gallium/auxiliary/cso_cache	libs/mesa/gallium/auxiliary/draw libs/mesa/gallium/auxiliary/gallivm	libs/mesa/gallium/auxiliary/indices	libs/mesa/gallium/auxiliary/pipebuffer	libs/mesa/gallium/auxiliary/rbug libs/mesa/gallium/auxiliary/rtasm	libs/mesa/gallium/auxiliary/sct libs/mesa/gallium/auxiliary/tgsi	libs/mesa/gallium/auxiliary/translate	libs/mesa/gallium/auxiliary/util libs/mesa/gallium/drivers	libs/mesa/gallium/drivers/failover	libs/mesa/gallium/drivers/i915simple	libs/mesa/gallium/drivers/softpipe libs/mesa/gallium/drivers/trace	libs/mesa/gallium/state_trackers	libs/mesa/gallium/state_trackers/dri libs/mesa/glu	libs/mesa/glut libs/mesa/mesa libs/mesa/mesa/drivers/dri/common
</A></li>
	<LI>Next message: <A HREF="020641.html">[Haiku-commits] r33146 -	haiku/trunk/src/add-ons/kernel/partitioning_systems/intel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20640">[ date ]</a>
              <a href="thread.html#20640">[ thread ]</a>
              <a href="subject.html#20640">[ subject ]</a>
              <a href="author.html#20640">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
