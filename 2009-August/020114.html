<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r32779 - in haiku/trunk/headers/os: media support
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32779%20-%20in%20haiku/trunk/headers/os%3A%20media%20support&In-Reply-To=%3C200908281242.n7SCgdXi007494%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020113.html">
   <LINK REL="Next"  HREF="020115.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r32779 - in haiku/trunk/headers/os: media support</H1>
    <B>stippi at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32779%20-%20in%20haiku/trunk/headers/os%3A%20media%20support&In-Reply-To=%3C200908281242.n7SCgdXi007494%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r32779 - in haiku/trunk/headers/os: media support">stippi at mail.berlios.de
       </A><BR>
    <I>Fri Aug 28 14:42:39 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020113.html">[Haiku-commits] r32778 - haiku/trunk/headers/os/support
</A></li>
        <LI>Next message: <A HREF="020115.html">[Haiku-commits] r32780 - haiku/trunk/headers/os/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20114">[ date ]</a>
              <a href="thread.html#20114">[ thread ]</a>
              <a href="subject.html#20114">[ subject ]</a>
              <a href="author.html#20114">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2009-08-28 14:42:36 +0200 (Fri, 28 Aug 2009)
New Revision: 32779
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=32779&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=32779&amp;view=rev</A>

Modified:
   haiku/trunk/headers/os/media/MediaDefs.h
   haiku/trunk/headers/os/media/MediaEncoder.h
   haiku/trunk/headers/os/support/Errors.h
Log:
* Rewrote MediaDefs.h and MediaEncoder.h
* Moved MediaKit errors into Errors.h


Modified: haiku/trunk/headers/os/media/MediaDefs.h
===================================================================
--- haiku/trunk/headers/os/media/MediaDefs.h	2009-08-28 12:30:04 UTC (rev 32778)
+++ haiku/trunk/headers/os/media/MediaDefs.h	2009-08-28 12:42:36 UTC (rev 32779)
@@ -1,90 +1,62 @@
-/*******************************************************************************
-/
-/	File:			MediaDefs.h
-/
-/   Description:   Basic data types and defines for the Media Kit.
-/
-/	Copyright 1997-1999, Be Incorporated, All Rights Reserved
-/
-*******************************************************************************/
-
-#if !defined(_MEDIA_DEFS_H)
+/*
+ * Copyright 2009, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _MEDIA_DEFS_H
 #define _MEDIA_DEFS_H
 
-#include &lt;BeBuild.h&gt;
-#include &lt;SupportDefs.h&gt;
+
+/*! Basic data types and defines for the Media Kit. */
+
+
 #include &lt;OS.h&gt;
 #include &lt;ByteOrder.h&gt;
 
 #if defined(__cplusplus)
-#include &lt;GraphicsDefs.h&gt;
-#include &lt;Looper.h&gt;
+#	include &lt;GraphicsDefs.h&gt;
+#	include &lt;Looper.h&gt;
 #endif
 
+
 struct media_node;
 
 #define B_MEDIA_NAME_LENGTH 64
 
 
-enum {	/* maybe migrate these into Errors.h */
-	B_MEDIA_SYSTEM_FAILURE = (int)B_MEDIA_ERROR_BASE+0x100,	/* 80004100 */
-	B_MEDIA_BAD_NODE,
-	B_MEDIA_NODE_BUSY,
-	B_MEDIA_BAD_FORMAT,
-	B_MEDIA_BAD_BUFFER,
-	B_MEDIA_TOO_MANY_NODES,
-	B_MEDIA_TOO_MANY_BUFFERS,
-	B_MEDIA_NODE_ALREADY_EXISTS,
-	B_MEDIA_BUFFER_ALREADY_EXISTS,
-	B_MEDIA_CANNOT_SEEK,
-	B_MEDIA_CANNOT_CHANGE_RUN_MODE,
-	B_MEDIA_APP_ALREADY_REGISTERED,
-	B_MEDIA_APP_NOT_REGISTERED,
-	B_MEDIA_CANNOT_RECLAIM_BUFFERS,
-	B_MEDIA_BUFFERS_NOT_RECLAIMED,
-	B_MEDIA_TIME_SOURCE_STOPPED,
-	B_MEDIA_TIME_SOURCE_BUSY,					/* 80004110 */
-	B_MEDIA_BAD_SOURCE,
-	B_MEDIA_BAD_DESTINATION,
-	B_MEDIA_ALREADY_CONNECTED,
-	B_MEDIA_NOT_CONNECTED,
-	B_MEDIA_BAD_CLIP_FORMAT,
-	B_MEDIA_ADDON_FAILED,
-	B_MEDIA_ADDON_DISABLED,
-	B_MEDIA_CHANGE_IN_PROGRESS,
-	B_MEDIA_STALE_CHANGE_COUNT,
-	B_MEDIA_ADDON_RESTRICTED,
-	B_MEDIA_NO_HANDLER, 
-	B_MEDIA_DUPLICATE_FORMAT,
-	B_MEDIA_REALTIME_DISABLED,
-	B_MEDIA_REALTIME_UNAVAILABLE
-};
-
-/* Notification message 'what's */
+/* Notification messages 'what' fields */
 enum {
-	// Note that BMediaNode::node_error also belongs in here! */
-	B_MEDIA_WILDCARD = 'TRWC',		/* used to match any notification in Start/StopWatching */
-	B_MEDIA_NODE_CREATED = 'TRIA',	/* &quot;media_node_id&quot; (multiple items) */
+	/* Note that BMediaNode::node_error also belongs in here! */
+	B_MEDIA_WILDCARD		= 'TRWC',
+									/* Used to match any notification in */
+									/* Start/StopWatching */
+	B_MEDIA_NODE_CREATED	= 'TRIA',
+									/* &quot;media_node_id&quot; (multiple items) */
 	B_MEDIA_NODE_DELETED,			/* &quot;media_node_id&quot; (multiple items) */
 	B_MEDIA_CONNECTION_MADE,		/* &quot;output&quot;, &quot;input&quot;, &quot;format&quot; */
 	B_MEDIA_CONNECTION_BROKEN,		/* &quot;source&quot;, &quot;destination&quot; */
-	B_MEDIA_BUFFER_CREATED,			/* &quot;clone_info&quot; -- handled by BMediaRoster */
-	B_MEDIA_BUFFER_DELETED,			/* &quot;media_buffer_id&quot; -- handled by BMediaRoster */
+	B_MEDIA_BUFFER_CREATED,			/* &quot;clone_info&quot; -- handled by */
+									/* BMediaRoster */
+	B_MEDIA_BUFFER_DELETED,			/* &quot;media_buffer_id&quot; -- handled by */
+									/* BMediaRoster */
 	B_MEDIA_TRANSPORT_STATE,		/* &quot;state&quot;, &quot;location&quot;, &quot;realtime&quot; */
 	B_MEDIA_PARAMETER_CHANGED,		/* N &quot;node&quot;, &quot;parameter&quot; */
 	B_MEDIA_FORMAT_CHANGED,			/* N &quot;source&quot;, &quot;destination&quot;, &quot;format&quot; */
 	B_MEDIA_WEB_CHANGED,			/* N &quot;node&quot; */
-	B_MEDIA_DEFAULT_CHANGED,		/* &quot;default&quot;, &quot;node&quot; -- handled by BMediaRoster */
-	B_MEDIA_NEW_PARAMETER_VALUE,	/* N &quot;node&quot;, &quot;parameter&quot;, &quot;when&quot;, &quot;value&quot; */
+	B_MEDIA_DEFAULT_CHANGED,		/* &quot;default&quot;, &quot;node&quot; -- handled by */
+									/* BMediaRoster */
+	B_MEDIA_NEW_PARAMETER_VALUE,	/* N &quot;node&quot;, &quot;parameter&quot;, &quot;when&quot;, */
+									/* &quot;value&quot; */
 	B_MEDIA_NODE_STOPPED,			/* N &quot;node&quot;, &quot;when&quot; */
-	B_MEDIA_FLAVORS_CHANGED			/* &quot;be:addon_id&quot;, &quot;be:new_count&quot;, &quot;be:gone_count&quot; */
+	B_MEDIA_FLAVORS_CHANGED			/* &quot;be:addon_id&quot;, &quot;be:new_count&quot;, */
+									/* &quot;be:gone_count&quot; */
 };
 
+
 enum media_type {
-	B_MEDIA_NO_TYPE = -1,
-	B_MEDIA_UNKNOWN_TYPE = 0,
-	B_MEDIA_RAW_AUDIO = 1,			/* uncompressed raw_audio -- linear relationship bytes &lt;-&gt; samples */
-	B_MEDIA_RAW_VIDEO,				/* uncompressed raw_video -- linear relationship bytes &lt;-&gt; pixels */
+	B_MEDIA_NO_TYPE			= -1,
+	B_MEDIA_UNKNOWN_TYPE	= 0,
+	B_MEDIA_RAW_AUDIO		= 1,	/* uncompressed raw_audio */
+	B_MEDIA_RAW_VIDEO,				/* uncompressed raw_video */
 	B_MEDIA_VBL,					/* raw data from VBL area, 1600/line */
 	B_MEDIA_TIMECODE,				/* data format TBD */
 	B_MEDIA_MIDI,
@@ -92,89 +64,104 @@
 	B_MEDIA_HTML,
 	B_MEDIA_MULTISTREAM,			/* AVI, etc */
 	B_MEDIA_PARAMETERS,				/* BControllable change data */
-	B_MEDIA_ENCODED_AUDIO,			/* dts, AC3, ... */
-	B_MEDIA_ENCODED_VIDEO,			/* Indeo, MPEG, ... */
-	B_MEDIA_PRIVATE = 90000,		/* Don't touch! */
-	B_MEDIA_FIRST_USER_TYPE = 100000	/* Use something bigger than this for */
-										/* experimentation with your own media forms */
+	B_MEDIA_ENCODED_AUDIO,			/* MP3, AC-3, ... */
+	B_MEDIA_ENCODED_VIDEO,			/* H.264, Theora, ... */
+	B_MEDIA_PRIVATE			= 90000,
+									/* This are reserved. */
+	B_MEDIA_FIRST_USER_TYPE	= 100000
+									/* Use something bigger than this for */
+									/* experimentation with your own media */
+									/* formats. */
 };
 
+
 enum node_kind {
-	B_BUFFER_PRODUCER = 0x1,
-	B_BUFFER_CONSUMER = 0x2,
-	B_TIME_SOURCE = 0x4,
-	B_CONTROLLABLE = 0x8,
-	B_FILE_INTERFACE = 0x10,
-	B_ENTITY_INTERFACE = 0x20,
-	/* Set these flags for nodes that are suitable as default entities */
-	B_PHYSICAL_INPUT = 0x10000,
-	B_PHYSICAL_OUTPUT = 0x20000,
-	B_SYSTEM_MIXER = 0x40000
+	B_BUFFER_PRODUCER		= 0x1,
+	B_BUFFER_CONSUMER		= 0x2,
+	B_TIME_SOURCE			= 0x4,
+	B_CONTROLLABLE			= 0x8,
+	B_FILE_INTERFACE		= 0x10,
+	B_ENTITY_INTERFACE		= 0x20,
+
+	/* Set these flags for nodes that are suitable as default system nodes. */
+	B_PHYSICAL_INPUT		= 0x10000,
+	B_PHYSICAL_OUTPUT		= 0x20000,
+	B_SYSTEM_MIXER			= 0x40000
 };
 
-enum video_orientation {	/* for orientation, which pixel is first and how do we scan each &quot;line&quot;? */
-	B_VIDEO_TOP_LEFT_RIGHT = 1,		/* This is the typical progressive scan format */
+
+enum video_orientation {
+	/* Which pixel is first and how do we scan each &quot;line&quot;? */
+	B_VIDEO_TOP_LEFT_RIGHT	= 1,	/* This is the typical progressive scan */
+									/* format */
 	B_VIDEO_BOTTOM_LEFT_RIGHT		/* This is how BMP and TGA might scan */
 };
 
 
-enum media_flags			/* data */
+/* data */
+enum media_flags
 {
-	B_MEDIA_FLAGS_VERSION = 1,			/* uint32, bigger for newer */
-	B_MEDIA_FLAGS_PRIVATE = 0x40000000	/* private to Be */
+	B_MEDIA_FLAGS_VERSION			= 1,
+									/* uint32, greater for newer versions */
+	B_MEDIA_FLAGS_PRIVATE			= 0x40000000
+									/* private to Haiku */
 };
 
 
-enum media_producer_status {	/* for producer status */
-	B_DATA_NOT_AVAILABLE = 1,
-	B_DATA_AVAILABLE = 2,
-	B_PRODUCER_STOPPED = 3
+/* for producer status */
+enum media_producer_status {
+	B_DATA_NOT_AVAILABLE			= 1,
+	B_DATA_AVAILABLE				= 2,
+	B_PRODUCER_STOPPED				= 3
 };
 
-//	realtime flags
+
+/* realtime flags */
 enum media_realtime_flags {
-	B_MEDIA_REALTIME_ALLOCATOR = 0x1,
-	B_MEDIA_REALTIME_AUDIO = 0x2,
-	B_MEDIA_REALTIME_VIDEO = 0x4,
-	B_MEDIA_REALTIME_ANYKIND = 0xffff
+	B_MEDIA_REALTIME_ALLOCATOR		= 0x1,
+	B_MEDIA_REALTIME_AUDIO			= 0x2,
+	B_MEDIA_REALTIME_VIDEO			= 0x4,
+	B_MEDIA_REALTIME_ANYKIND		= 0xffff
 };
 
 enum media_frame_flags {
-	B_MEDIA_KEY_FRAME = 0x1
+	B_MEDIA_KEY_FRAME				= 0x1
 };
 
-#define B_MEDIA_ANY_QUALITY 0.0f
-#define B_MEDIA_LOW_QUALITY 0.1f
-#define B_MEDIA_MEDIUM_QUALITY 0.5f
-#define B_MEDIA_HIGH_QUALITY 1.0f
+#define B_MEDIA_ANY_QUALITY			0.0f
+#define B_MEDIA_LOW_QUALITY			0.1f
+#define B_MEDIA_MEDIUM_QUALITY		0.5f
+#define B_MEDIA_HIGH_QUALITY		1.0f
 
 
-#if !defined(_MULTI_AUDIO_H)	/* #define in protocol header */
+#ifndef _MULTI_AUDIO_H	/* #define in protocol header */
 enum media_multi_channels {
-	B_CHANNEL_LEFT = 0x1,
-	B_CHANNEL_RIGHT = 0x2,
-	B_CHANNEL_CENTER = 0x4,				/* 5.1+ or fake surround */
-	B_CHANNEL_SUB = 0x8,				/* 5.1+ */
-	B_CHANNEL_REARLEFT = 0x10,			/* quad surround or 5.1+ */
-	B_CHANNEL_REARRIGHT = 0x20,			/* quad surround or 5.1+ */
-	B_CHANNEL_FRONT_LEFT_CENTER = 0x40,
-	B_CHANNEL_FRONT_RIGHT_CENTER = 0x80,
-	B_CHANNEL_BACK_CENTER = 0x100,		/* 6.1 or fake surround */
-	B_CHANNEL_SIDE_LEFT = 0x200,
-	B_CHANNEL_SIDE_RIGHT = 0x400,
-	B_CHANNEL_TOP_CENTER = 0x800,
-	B_CHANNEL_TOP_FRONT_LEFT = 0x1000,
-	B_CHANNEL_TOP_FRONT_CENTER = 0x2000,
-	B_CHANNEL_TOP_FRONT_RIGHT = 0x4000,
-	B_CHANNEL_TOP_BACK_LEFT = 0x8000,
-	B_CHANNEL_TOP_BACK_CENTER = 0x10000,
-	B_CHANNEL_TOP_BACK_RIGHT = 0x20000
+	B_CHANNEL_LEFT					= 0x00001,
+	B_CHANNEL_RIGHT					= 0x00002,
+	B_CHANNEL_CENTER				= 0x00004,	/* 5.1+ or fake surround */
+	B_CHANNEL_SUB					= 0x00008,	/* 5.1+ */
+	B_CHANNEL_REARLEFT				= 0x00010,	/* quad surround or 5.1+ */
+	B_CHANNEL_REARRIGHT				= 0x00020,	/* quad surround or 5.1+ */
+	B_CHANNEL_FRONT_LEFT_CENTER		= 0x00040,
+	B_CHANNEL_FRONT_RIGHT_CENTER	= 0x00080,
+	B_CHANNEL_BACK_CENTER			= 0x00100,	/* 6.1 or fake surround */
+	B_CHANNEL_SIDE_LEFT				= 0x00200,
+	B_CHANNEL_SIDE_RIGHT			= 0x00400,
+	B_CHANNEL_TOP_CENTER			= 0x00800,
+	B_CHANNEL_TOP_FRONT_LEFT		= 0x01000,
+	B_CHANNEL_TOP_FRONT_CENTER		= 0x02000,
+	B_CHANNEL_TOP_FRONT_RIGHT		= 0x04000,
+	B_CHANNEL_TOP_BACK_LEFT			= 0x08000,
+	B_CHANNEL_TOP_BACK_CENTER		= 0x10000,
+	B_CHANNEL_TOP_BACK_RIGHT		= 0x20000
 };
+
+
 enum media_multi_matrix {
-	B_MATRIX_PROLOGIC_LR = 0x1,
-	B_MATRIX_AMBISONIC_WXYZ = 0x4
+	B_MATRIX_PROLOGIC_LR			= 0x1,
+	B_MATRIX_AMBISONIC_WXYZ			= 0x4
 };
-#endif
+#endif // !_MULTI_AUDIO_H
 
 
 typedef int32 media_node_id;
@@ -184,43 +171,53 @@
 
 #if defined(__cplusplus)
 struct media_destination {
-	media_destination(port_id, int32);
-	media_destination(const media_destination &amp; clone);
-	media_destination &amp; operator=(const media_destination &amp; clone);
-	media_destination();
-	~media_destination();
-	port_id port;	/* can be different from media_node.port */
-	int32 id;
-static media_destination null;
+								media_destination();
+								media_destination(port_id, int32);
+								media_destination(
+									const media_destination&amp; other);
+								~media_destination();
+
+			media_destination&amp;	operator=(const media_destination&amp; other);
+
+			port_id				port;	/* can be different from */
+										/* media_node.port */
+			int32				id;
+	static	media_destination	null;
+
 private:
-	uint32 _reserved_media_destination_[2];
+			uint32				_reserved_media_destination_[2];
 };
 
+
 struct media_source {
-	media_source(port_id, int32);
-	media_source(const media_source &amp; clone);
-	media_source &amp; operator=(const media_source &amp; clone);
-	media_source();
-	~media_source();
-	port_id port;	/* must be the same as media_node.port	for owner */
-	int32 id;
-static media_source null;
+								media_source();
+								media_source(port_id, int32);
+								media_source(const media_source&amp; other);
+								~media_source();
+
+			media_source&amp;		operator=(const media_source&amp; other);
+			port_id				port;	/* must be the same as */
+										/* media_node.port for owner */
+			int32				id;
+	static	media_source		null;
+
 private:
-	uint32 _reserved_media_source_[2];
+			uint32				_reserved_media_source_[2];
 };
 
-bool operator==(const media_destination &amp; a, const media_destination &amp; b);
-bool operator!=(const media_destination &amp; a, const media_destination &amp; b);
-bool operator&lt;(const media_destination &amp; a, const media_destination &amp; b);
-bool operator==(const media_source &amp; a, const media_source &amp; b);
-bool operator!=(const media_source &amp; a, const media_source &amp; b);
-bool operator&lt;(const media_source &amp; a, const media_source &amp; b);
-bool operator==(const media_node &amp; a, const media_node &amp; b);
-bool operator!=(const media_node &amp; a, const media_node &amp; b);
-bool operator&lt;(const media_node &amp; a, const media_node &amp; b);
 
+bool operator==(const media_destination&amp; a, const media_destination&amp; b);
+bool operator!=(const media_destination&amp; a, const media_destination&amp; b);
+bool operator&lt;(const media_destination&amp; a, const media_destination&amp; b);
+bool operator==(const media_source&amp; a, const media_source&amp; b);
+bool operator!=(const media_source&amp; a, const media_source&amp; b);
+bool operator&lt;(const media_source&amp; a, const media_source&amp; b);
+bool operator==(const media_node&amp; a, const media_node&amp; b);
+bool operator!=(const media_node&amp; a, const media_node&amp; b);
+bool operator&lt;(const media_node&amp; a, const media_node&amp; b);
 
 
+
 /* Buffers are low-level constructs identified by an ID. */
 /* Buffers consist of the actual data area, plus a 64-byte */
 /* header area that is different for each type. */
@@ -228,261 +225,338 @@
 /* buffer header; it's negotiated out-of-bounds by nodes. */
 
 enum {
-	B_MEDIA_BIG_ENDIAN = 1,
-	B_MEDIA_LITTLE_ENDIAN = 2,
+	B_MEDIA_BIG_ENDIAN			= 1,
+	B_MEDIA_LITTLE_ENDIAN		= 2,
 #if B_HOST_IS_BENDIAN
-	B_MEDIA_HOST_ENDIAN = B_MEDIA_BIG_ENDIAN
+	B_MEDIA_HOST_ENDIAN			= B_MEDIA_BIG_ENDIAN
 #else
-	B_MEDIA_HOST_ENDIAN = B_MEDIA_LITTLE_ENDIAN
+	B_MEDIA_HOST_ENDIAN			= B_MEDIA_LITTLE_ENDIAN
 #endif
 };
 
+
 struct media_multi_audio_format;
 
+
 struct media_raw_audio_format {
-	enum {						// for &quot;format&quot;
-		B_AUDIO_FLOAT = 0x24,	// 0 == mid, -1.0 == bottom, 1.0 == top (the preferred format for non-game audio)
-		B_AUDIO_DOUBLE = 0x28,	// 0 == mid, -1.0 == bottom, 1.0 == top (only useful for pro audio)
-		B_AUDIO_INT = 0x4,		// 0 == mid, 0x80000001 == bottom, 0x7fffffff == top (all &gt;16-bit formats, left-adjusted)
-		B_AUDIO_SHORT = 0x2,	// 0 == mid, -32767 == bottom, +32767 == top
-		B_AUDIO_UCHAR = 0x11,	// 128 == mid, 1 == bottom, 255 == top (discouraged but supported format)
-		B_AUDIO_CHAR = 0x1,		// 0 == mid, -127 == bottom, +127 == top (not officially supported format)
-		B_AUDIO_SIZE_MASK = 0xf
-	};							// we guarantee that (format&amp;0xf) == sizeof(sample) for raw formats
+	// possible values for &quot;format&quot;
+	enum {
+		B_AUDIO_FLOAT		= 0x24,
+			// 0 == mid, -1.0 == bottom, 1.0 == top
+			// (the preferred format for non-game audio)
 
+		B_AUDIO_DOUBLE		= 0x28,
+			// 0 == mid, -1.0 == bottom, 1.0 == top
+			// (only useful for pro audio)
+
+		B_AUDIO_INT			= 0x4,
+			// 0 == mid, 0x80000001 == bottom, 0x7fffffff == top
+			// (all &gt;16-bit formats, left-adjusted)
+
+		B_AUDIO_SHORT		= 0x2,
+			// 0 == mid, -32767 == bottom, +32767 == top
+
+		B_AUDIO_UCHAR		= 0x11,
+			// 128 == mid, 1 == bottom, 255 == top
+			// (discouraged but supported format)
+
+		B_AUDIO_CHAR		= 0x1,
+			// 0 == mid, -127 == bottom, +127 == top
+			// (not officially supported format)
+
+		B_AUDIO_SIZE_MASK	= 0xf
+			// This mask can be used to obtain the sample size
+			// for raw formats: (format &amp; 0xf) == sizeof(sample)
+	};
+
 	float		frame_rate;
-	uint32		channel_count;		// 1 or 2, mostly
-	uint32		format;				// for compressed formats, go to media_encoded_audio_format
-	uint32		byte_order;			// 2 for little endian (B_MEDIA_LITTLE_ENDIAN), 1 for big endian (B_MEDIA_BIG_ENDIAN)
-	size_t		buffer_size;		// size of each buffer
+	uint32		channel_count;
+	uint32		format;			// see possible values above
+	uint32		byte_order;		// B_MEDIA_LITTLE_ENDIAN or B_MEDIA_BIG_ENDIAN
+	size_t		buffer_size;	// size of each buffer
 
-static media_multi_audio_format wildcard;
+	static media_multi_audio_format wildcard;
 };
 
+
 struct media_audio_header {
-	// please put actual data at the end
-	int32		_reserved_[16];		// gotta have something
+	// TODO: Define this structure, put actual data at the end
+	int32		_reserved_[16];
 };
 
+
 struct media_multi_audio_info {
-	uint32		channel_mask;		//	bitmask
-	int16		valid_bits;			//	if &lt; 32, for B_AUDIO_INT
-	uint16		matrix_mask;		//	each of these bits may mean more than one channel
+	uint32		channel_mask;	// bitmask
+	int16		valid_bits;		// if &lt; 32, for B_AUDIO_INT
+	uint16		matrix_mask;	// each of these bits may mean more than one
+								// channel
 
 	uint32		_reserved_b[3];
 };
 
-#if defined(__cplusplus)
-struct media_multi_audio_format : public media_raw_audio_format, public media_multi_audio_info {
-static media_multi_audio_format wildcard;
+
+struct media_multi_audio_format : public media_raw_audio_format,
+	public media_multi_audio_info {
+
+	static media_multi_audio_format wildcard;
 };
-#else
-struct media_multi_audio_format {
-	media_raw_audio_format	raw;
-	media_multi_audio_info	multi;
-};
-#endif
 
 
 struct media_encoded_audio_format {
 	enum audio_encoding {
 		B_ANY
 	};
+
 	media_raw_audio_format	output;
 	audio_encoding			encoding;
 
-	float					bit_rate;		// BIT rate, not byte rate
+	float					bit_rate;
 	size_t					frame_size;
 
 	media_multi_audio_info	multi_info;
 
 	uint32					_reserved_[3];
 
-static media_encoded_audio_format wildcard;
+	static media_encoded_audio_format wildcard;
 };
 
+
 struct media_encoded_audio_header {
-	// please put actual data at the end 
-	int32		_reserved_0[14];	// gotta have something
-	uint32		buffer_flags;		// B_MEDIA_KEY_FRAME for key buffers (ADPCM etc)
-	uchar		unused_mask;		// mask of unused bits for the last byte of data
+	// NOTE: More data fields need to go to the end
+	int32		_reserved_0[14];
+
+	uint32		buffer_flags;
+		// B_MEDIA_KEY_FRAME for key frame chunks
+	uchar		unused_mask;
+		// mask of unused bits for the last byte of data
 	uchar		_reserved_2[3];
 
 };
 
 enum media_display_flags {
-	B_F1_DOMINANT = 0x1,		// The first buffer sent (temporally) will be an F1 field
-	B_F2_DOMINANT = 0x2,		// The first buffer sent (temporally) will be an F2 field
-	B_TOP_SCANLINE_F1 = 0x4,	// The topmost scanline of the output buffer belongs to F1
-	B_TOP_SCANLINE_F2 = 0x8		// The topmost scanline of the output buffer belongs to F2
+	B_F1_DOMINANT		= 0x1,	// The first buffer sent (temporally) will
+								// be an F1 field.
+	B_F2_DOMINANT		= 0x2,	// The first buffer sent (temporally) will
+								// be an F2 field.
+	B_TOP_SCANLINE_F1	= 0x4,	// The topmost scanline of the output buffer
+								// belongs to F1.
+	B_TOP_SCANLINE_F2	= 0x8	// The topmost scanline of the output buffer
+								// belongs to F2.
 };
+
+
 struct media_video_display_info {
 	color_space	format;
 	uint32		line_width;
-	uint32		line_count;		// total of all interlace fields 
-	uint32		bytes_per_row;	// bytes_per_row is in format, not header, because it's part of SetBuffers
-	uint32		pixel_offset;	// (in pixels) ... These are offsets from the start of the buffer ... 
-	uint32		line_offset;	// (in lines) ... to the start of the field. Think &quot;buffer == framebuffer&quot; ... 
-								// ... when the window displaying the active field moves on screen. 
+	uint32		line_count;		// sum of all interlace fields lines
+	uint32		bytes_per_row;	// bytes_per_row is in format, not header,
+								// because it's part of SetBuffers
+	uint32		pixel_offset;	// (in pixels) Offset from the start of the
+								// buffer (see below).
+	uint32		line_offset;	// (in lines) Offset to the start of the field.
+								// Think &quot;buffer == framebuffer&quot; when the
+								// window displaying the active field moves
+								// on screen.
 	uint32		flags;
 	uint32		_reserved_[3];
-static media_video_display_info wildcard;
+
+	static media_video_display_info wildcard;
 };
 
+
 struct media_raw_video_format {
 	float		field_rate;
-	uint32		interlace;		// how many fields per frame -- 1 means progressive (non-interlaced)
-	uint32		first_active;	// 0, typically (wildcard, or &quot;don't care&quot;)
-	uint32		last_active;	// line_count-1, if first_active is 0.
-	uint32		orientation;	// B_VIDEO_TOP_LEFT_RIGHT is preferred
-	// PIXEL aspect ratio; not active area aspect ratio...
+	uint32		interlace;		// Number of fields per frame: 1 means
+								// progressive (non-interlaced) frames.
+	uint32		first_active;	// Index of first active line. 0, typically
+								// (wildcard, or &quot;don't care&quot;)
+	uint32		last_active;	// Index of last active line (typically
+								// line_count - 1, if first_active is 0.
+	uint32		orientation;	// B_VIDEO_TOP_LEFT_RIGHT is preferred.
+
+	// This is the display aspect ratio (DAR). Usually, you would reduce the
+	// width and height of the intended output frame size as far as possible
+	// without changing their ratio. Note that you should not put 1 in both
+	// fields to mean &quot;undistorted pixels&quot;, unless you really intend square
+	// video output!
 	uint16		pixel_width_aspect;		// 1:1 has 1 here, 4:3 has 4 here
+										// 16:9 has 16 here!
 	uint16		pixel_height_aspect;	// 1:1 has 1 here, 4:3 has 3 here
+										// 16:9 has 9 here!
 
 	media_video_display_info	display;
 
-static media_raw_video_format wildcard;
+	static media_raw_video_format wildcard;
 };
 
+
 struct media_video_header {
-	uint32		_reserved_[12];		// at the top to push used data to the end
+	uint32		_reserved_[12];		// NOTE: Keep reserved data at the top!
+
 	float		field_gamma;
-	uint32		field_sequence;		// sequence since start of capture -- may roll over if machine is on for a LONG time
-	uint16		field_number;		// 0 .. {interlace-1}; F1 == 0 (&quot;odd&quot;), F2 == 1 (&quot;even&quot;)
+	uint32		field_sequence;		// Sequence number since start of capture
+									// May roll over if machine is on for a
+									// LONG time.
+	uint16		field_number;		// 0 .. {interlace-1}; F1 == 0 (&quot;odd&quot;),
+									// F2 == 1 (&quot;even&quot;)
 	uint16		pulldown_number;	// 0..2 for pulldown duplicated sequence
-	uint16		first_active_line;	// the NTSC/PAL line number (1-based) of the first line in this field
-	uint16		line_count;			// number of active lines in buffer
+	uint16		first_active_line;	// The NTSC/PAL line number (1-based) of
+									// the first line in this field
+	uint16		line_count;			// The number of active lines in buffer.
 };
 
+
 struct media_encoded_video_format {
 	enum video_encoding {
 		B_ANY
 	};
+
 	media_raw_video_format	output;				// set unknowns to wildcard
+
 	float					avg_bit_rate;
 	float					max_bit_rate;
+
 	video_encoding			encoding;
 	size_t					frame_size;
-	int16					forward_history;	//	maximum forward memory required by algorithm
-	int16					backward_history;	//	maximum backward memory required by algorithm
 
-	uint32					_reserved_[3];		//	can't grow more than this
+	int16					forward_history;	// maximum forward memory
+												// required by codec
 
-static media_encoded_video_format wildcard;
+	int16					backward_history;	// maximum backward memory
+												// required by codec
+
+	uint32					_reserved_[3];		// This structure cannot grow
+												// more than this (embedded)
+												// in media_format union
+
+	static media_encoded_video_format wildcard;
 };
 
+
 struct media_encoded_video_header {
-	/* please put actual data at the end */
-	int32		_reserved_1[9];		// gotta have something... 
+	// NOTE: More data fields need to go at the end of this structure.
+	int32		_reserved_1[9];
 
 	uint32		field_flags;		//	B_MEDIA_KEY_FRAME
 
-	int16		forward_history;	// forward memory required by this buffer (0 for key frames)
-	int16		backward_history;	// backward memory required by this buffer (0 for key frames)
-	uchar		unused_mask;		// mask of unused bits for the last byte of data
+	int16		forward_history;	// forward memory required by this buffer
+									// (0 for key frames)
+
+	int16		backward_history;	// backward memory required by this buffer
+									// (0 for key frames)
+
+	uchar		unused_mask;		// mask of unused bits for the last byte
+									// of data
 	uchar		_reserved_2[3];
 	float		field_gamma;
 	uint32		field_sequence;		// sequence since start of capture
 	uint16		field_number;		// 0 .. {interlace-1};  F1 == 0, F2 == 1
 	uint16		pulldown_number;	// 0..2 for pulldown duplicated sequence
-	uint16		first_active_line;	// 0 or 1, typically, but could be 10 or 11 for full-NTSC formats
+	uint16		first_active_line;	// 0 or 1, typically, but could be 10 or
+									// 11 for full-NTSC formats
 	uint16		line_count;			// number of actual lines in buffer
 };
 
 struct media_multistream_format {
 	enum {
-		B_ANY = 0,
-		B_VID = 1,					// raw raw_video/raw_audio buffers
+		B_ANY					= 0,
+		B_VID					= 1,	// raw raw_video/raw_audio buffers
 		B_AVI,
 		B_MPEG1,
 		B_MPEG2,
 		B_QUICKTIME,
-		B_PRIVATE = 90000,
-		B_FIRST_USER_TYPE = 100000	// user formats &gt;= 100000
+		B_PRIVATE				= 90000,
+		B_FIRST_USER_TYPE		= 100000
 	};
-	float		avg_bit_rate;		// 8 * byte rate, on average
-	float		max_bit_rate;		// 8 * byte rate, tops
-	uint32		avg_chunk_size;		// == max_chunk_size for fixed-size chunks
-	uint32		max_chunk_size;		// max buffer size
+	float		avg_bit_rate;			// 8 * byte rate, on average
+	float		max_bit_rate;			// 8 * byte rate, tops
+	uint32		avg_chunk_size;			// == max_chunk_size for fixed-size
+										// chunks
+	uint32		max_chunk_size;			// max buffer size
 	enum {
-		B_HEADER_HAS_FLAGS = 0x1,	// are flags important?
-		B_CLEAN_BUFFERS = 0x2,		// each buffer represents an integral number of &quot;frames&quot;
-		B_HOMOGENOUS_BUFFERS = 0x4	// a buffer has only one format in it
+		B_HEADER_HAS_FLAGS		= 0x1,	// are flags important?
+		B_CLEAN_BUFFERS			= 0x2,	// each buffer represents an integral
+										// number of &quot;frames&quot;
+		B_HOMOGENOUS_BUFFERS	= 0x4	// a buffer has only one format in it
 	};
 	uint32		flags;
 	int32		format;
 	uint32		_reserved_[2];
 
 	struct vid_info {
-		float frame_rate;
-		uint16 width;
-		uint16 height;
-		color_space space;
+		float		frame_rate;
+		uint16		width;
+		uint16		height;
+		color_space	space;
 
-		float sampling_rate;
-		uint32 sample_format;
-		uint16 byte_order;
-		uint16 channel_count;
+		float		sampling_rate;
+		uint32		sample_format;
+		uint16		byte_order;
+		uint16		channel_count;
 	};
 	struct avi_info {
-		uint32 us_per_frame;
-		uint16 width;
-		uint16 height;
-		uint16 _reserved_;
-		uint16 type_count;
-		media_type types[5];
+		uint32		us_per_frame;
+		uint16		width;
+		uint16		height;
+		uint16		_reserved_;
+		uint16		type_count;
+		media_type	types[5];
 	};
 
 	union {
 		vid_info	vid;
 		avi_info	avi;
-	}			u;
+	} 			u;
 
-static media_multistream_format wildcard;
+	static media_multistream_format wildcard;
 };
 
+
 struct media_multistream_header {
-	uint32 _reserved_[14];
-	uchar	unused_mask;			// mask of unused bits for the last byte of data
+	uint32	_reserved_[14];
+	uchar	unused_mask;			// mask of unused bits for the last byte
+									// of data
 	uchar	_reserved_2[3];
 	enum {
-		B_MASTER_HEADER = 0x1,		// for master stream header data in buffer
-		B_SUBSTREAM_HEADER = 0x2,	// for sub-stream header data in buffer
-		B_COMPLETE_BUFFER = 0x4		// data is an integral number of &quot;frames&quot;
+		B_MASTER_HEADER		= 0x1,	// for master stream header data in buffer
+		B_SUBSTREAM_HEADER	= 0x2,	// for sub-stream header data in buffer
+		B_COMPLETE_BUFFER	= 0x4	// data is an integral number of &quot;frames&quot;
 	};
 	uint32 	flags;
 };
 
+
 extern const type_code B_CODEC_TYPE_INFO;
 
+
 enum media_format_flags {
-	B_MEDIA_RETAINED_DATA = 0x1, 
-	B_MEDIA_MULTIPLE_BUFFERS = 0x2,
-	B_MEDIA_CONTIGUOUS_BUFFER = 0x4,
-	B_MEDIA_LINEAR_UPDATES = 0x8,
-	B_MEDIA_MAUI_UNDEFINED_FLAGS = ~0xf /* always deny these */
+	B_MEDIA_RETAINED_DATA			= 0x1,
+	B_MEDIA_MULTIPLE_BUFFERS		= 0x2,
+	B_MEDIA_CONTIGUOUS_BUFFER		= 0x4,
+	B_MEDIA_LINEAR_UPDATES			= 0x8,
+	B_MEDIA_MAUI_UNDEFINED_FLAGS	= ~0xf	// NOTE: Always deny these flags
+											// in new code.
 };
 
-/* typically, a field of 0 means &quot;anything&quot; or &quot;wildcard&quot; */
-struct media_format {	/* no more than 192 bytes */
+// NOTE: A field of 0 typically means &quot;anything&quot; or &quot;wildcard&quot;.
+// NOTE: This structure should not be bigger than 192 bytes!
+struct media_format {
 	media_type						type;
 	type_code						user_data_type;
 	uchar							user_data[48];
 	uint32							_reserved_[3];
-	uint16							require_flags;			//	media_format_flags
-	uint16							deny_flags;				//	media_format_flags
+	uint16							require_flags;	//	media_format_flags
+	uint16							deny_flags;		//	media_format_flags
 
-	private:
-
-	void *							meta_data;
+private:
+	void*							meta_data;
 	int32							meta_data_size;
 	area_id							meta_data_area;
 	area_id							__unused_was_use_area;
 	team_id							__unused_was_team;
-	void *							__unused_was_thisPtr;
+	void*							__unused_was_thisPtr;
 
-	public:
-
+public:
 	union {
 		media_multi_audio_format	raw_audio;
 		media_raw_video_format		raw_video;
@@ -491,55 +565,84 @@
 		media_encoded_video_format	encoded_video;
 		char						_reserved_[96];	 // pad to 96 bytes
 	} u;
-	
-	bool 			IsVideo() const		{ return (type==B_MEDIA_ENCODED_VIDEO)||(type==B_MEDIA_RAW_VIDEO); };
-	uint32  		Width() const		{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.line_width:u.raw_video.display.line_width; };
-	uint32 			Height() const		{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.line_count:u.raw_video.display.line_count; };
-	color_space  	ColorSpace() const	{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.format:u.raw_video.display.format; };
-	uint32 &amp; 		Width()				{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.line_width:u.raw_video.display.line_width; };
-	uint32 &amp; 		Height()			{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.line_count:u.raw_video.display.line_count; };
-	color_space &amp; 	ColorSpace()		{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.output.display.format:u.raw_video.display.format; };
 
-	bool 			IsAudio() const		{ return (type==B_MEDIA_ENCODED_AUDIO)||(type==B_MEDIA_RAW_AUDIO); };
-	uint32 			AudioFormat() const	{ return (type==B_MEDIA_ENCODED_AUDIO)?u.encoded_audio.output.format:u.raw_audio.format; };
-	uint32 &amp; 		AudioFormat()		{ return (type==B_MEDIA_ENCODED_AUDIO)?u.encoded_audio.output.format:u.raw_audio.format; };
-	uint32 			AudioFrameSize() const	{ return (type==B_MEDIA_ENCODED_AUDIO)?(u.encoded_audio.output.format &amp; 0xf)*u.encoded_audio.output.channel_count:(u.raw_audio.format &amp; 0xf)*u.raw_audio.channel_count; };
+	bool 			IsVideo() const;
 
-	uint32			Encoding() const	{ return (type==B_MEDIA_ENCODED_VIDEO)?u.encoded_video.encoding:(type==B_MEDIA_ENCODED_AUDIO)?u.encoded_audio.encoding:(type==B_MEDIA_MULTISTREAM)?u.multistream.format:0UL; }
+	uint32  		Width() const;
+	uint32 			Height() const;
+	color_space  	ColorSpace() const;
 
-	bool			Matches(const media_format *otherFormat) const;
-	void			SpecializeTo(const media_format *otherFormat);
+	uint32&amp; 		Width();
+	uint32&amp; 		Height();
+	color_space&amp; 	ColorSpace();
 
-	status_t		SetMetaData(const void *data, size_t size);
-	const void *	MetaData() const;
+	bool 			IsAudio() const;
+	uint32 			AudioFormat() const;
+	uint32&amp; 		AudioFormat();
+	uint32 			AudioFrameSize() const;
+
+	uint32			Encoding() const;
+
+	bool			Matches(const media_format* other) const;
+	void			SpecializeTo(const media_format* other);
+
+	status_t		SetMetaData(const void* data, size_t size);
+	const void*		MetaData() const;
 	int32			MetaDataSize() const;
 
 					media_format();
-					media_format(const media_format &amp;other);
+					media_format(const media_format&amp; other);
 					~media_format();
-	media_format &amp;	operator=(const media_format &amp; clone);
+
+	media_format&amp;	operator=(const media_format&amp; other);
 };
 
-bool operator==(const media_raw_audio_format &amp; a, const media_raw_audio_format &amp; b);
-bool operator==(const media_multi_audio_info &amp; a, const media_multi_audio_info &amp; b);
-bool operator==(const media_multi_audio_format &amp; a, const media_multi_audio_format &amp; b);
-bool operator==(const media_encoded_audio_format &amp; a, const media_encoded_audio_format &amp; b);
-bool operator==(const media_video_display_info &amp; a, const media_video_display_info &amp; b);
-bool operator==(const media_raw_video_format &amp; a, const media_raw_video_format &amp; b);
-bool operator==(const media_encoded_video_format &amp; a, const media_encoded_video_format &amp; b);
-bool operator==(const media_multistream_format::vid_info &amp; a, const media_multistream_format::vid_info &amp; b);
-bool operator==(const media_multistream_format::avi_info &amp; a, const media_multistream_format::avi_info &amp; b);
-bool operator==(const media_multistream_format &amp; a, const media_multistream_format &amp; b);
-bool operator==(const media_format &amp; a, const media_format &amp; b);
 
-/* return true if a and b are compatible (accounting for wildcards) */
-bool format_is_compatible(const media_format &amp; a, const media_format &amp; b);	/* a is the format you want to feed to something accepting b */
+bool operator==(const media_raw_audio_format&amp; a,
+	const media_raw_audio_format&amp; b);
+
+bool operator==(const media_multi_audio_info&amp; a,
+	const media_multi_audio_info&amp; b);
+
+bool operator==(const media_multi_audio_format&amp; a,
+	const media_multi_audio_format&amp; b);
+
+bool operator==(const media_encoded_audio_format&amp; a,
+	const media_encoded_audio_format&amp; b);
+
+bool operator==(const media_video_display_info&amp; a,
+	const media_video_display_info&amp; b);
+
+bool operator==(const media_raw_video_format&amp; a,
+	const media_raw_video_format&amp; b);
+
+bool operator==(const media_encoded_video_format&amp; a,
+	const media_encoded_video_format&amp; b);
+
+bool operator==(const media_multistream_format::vid_info&amp; a,
+	const media_multistream_format::vid_info&amp; b);
+
+bool operator==(const media_multistream_format::avi_info&amp; a,
+	const media_multistream_format::avi_info &amp; b);
+
+bool operator==(const media_multistream_format&amp; a,
+	const media_multistream_format&amp; b);
+
+bool operator==(const media_format&amp; a, const media_format&amp; b);
+
+
+bool format_is_compatible(const media_format &amp; a, const media_format &amp; b);
+	// Returns true if a and b are compatible (accounting for wildcards)
+	// (a is the format you want to feed to something accepting b
+
 bool string_for_format(const media_format &amp; f, char * buf, size_t size);
 
+
 struct media_seek_tag {
-	char data[16];
+	char	data[16];
 };
 
+
 struct media_header_time_code {
 	int8	type;		//	See TimeCode.h; don't use the &quot;DEFAULT&quot; value
 	int8	_reserved;
@@ -547,12 +650,14 @@
 	int8	minutes;
 	int8	seconds;
 	int8	frames;
-	int16	subframes;	//	-1 if not available
+	int16	subframes;	//	Set to -1 if not available
 };
 
-struct media_header {		// Broadcast() fills in fields marked with &quot;//+&quot;
+
+// Broadcast() fills in fields marked with &quot;//+&quot;
+struct media_header {
 	media_type		type;			// what kind of data (for union)
-	media_buffer_id buffer;			//+ what buffer does this header go with? 
+	media_buffer_id buffer;			//+ what buffer does this header go with?
 	int32			destination;	//+ what 'socket' is this intended for?
 	media_node_id	time_source;	// node that encoded start_time
 	uint32			_deprecated_;	// used to be change_tag
@@ -560,9 +665,9 @@
 	bigtime_t		start_time;		// performance time
 	area_id			owner;			//+ buffer owner info area
 	enum {
-		B_SEEK_TAG = 'TRST',			// user data type of the codec seek
+		B_SEEK_TAG	= 'TRST',		// user data type of the codec seek
 									// protocol. size of seek tag is 16 bytes
-		B_TIME_CODE = 'TRTC'			//	user data is media_header_time_code
+		B_TIME_CODE	= 'TRTC'		// user data is media_header_time_code
 	};
 	type_code		user_data_type;
 	uchar			user_data[64];	// user_data_type indicates what this is
@@ -579,8 +684,8 @@
 		media_multistream_header	multistream;
 		media_encoded_audio_header	encoded_audio;
 		media_encoded_video_header	encoded_video;
-		char						_reserved_[64];		// pad to 64 bytes
-	} u;
+		char						_reserved_[64];	// pad to 64 bytes
+	}				u;
 };
 
 
@@ -589,66 +694,74 @@
 	dev_t	device;
 	uint32	internal_id;
 };
-bool operator==(const media_file_format_id &amp; a, const media_file_format_id &amp; b);
-bool operator&lt;(const media_file_format_id &amp; a, const media_file_format_id &amp; b);
 
+
+bool operator==(const media_file_format_id&amp; a, const media_file_format_id&amp; b);
+bool operator&lt;(const media_file_format_id&amp; a, const media_file_format_id&amp; b);
+
+
 typedef enum {
-	B_ANY_FORMAT_FAMILY = 0,
-	B_BEOS_FORMAT_FAMILY = 1,

[... truncated: 612 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020113.html">[Haiku-commits] r32778 - haiku/trunk/headers/os/support
</A></li>
	<LI>Next message: <A HREF="020115.html">[Haiku-commits] r32780 - haiku/trunk/headers/os/media
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20114">[ date ]</a>
              <a href="thread.html#20114">[ thread ]</a>
              <a href="subject.html#20114">[ subject ]</a>
              <a href="author.html#20114">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
