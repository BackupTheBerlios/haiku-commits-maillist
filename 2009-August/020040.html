<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r32739 - haiku/trunk/src/tests/kits/game/chart
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32739%20-%20haiku/trunk/src/tests/kits/game/chart&In-Reply-To=%3C200908270834.n7R8YrgZ002356%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="020069.html">
   <LINK REL="Next"  HREF="020041.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r32739 - haiku/trunk/src/tests/kits/game/chart</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32739%20-%20haiku/trunk/src/tests/kits/game/chart&In-Reply-To=%3C200908270834.n7R8YrgZ002356%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r32739 - haiku/trunk/src/tests/kits/game/chart">axeld at mail.berlios.de
       </A><BR>
    <I>Thu Aug 27 10:34:53 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="020069.html">[Haiku-commits] r32738 - haiku/trunk/headers/build/os
</A></li>
        <LI>Next message: <A HREF="020041.html">[Haiku-commits] r32740 - haiku/trunk/src/kits/game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20040">[ date ]</a>
              <a href="thread.html#20040">[ thread ]</a>
              <a href="subject.html#20040">[ subject ]</a>
              <a href="author.html#20040">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2009-08-27 10:34:45 +0200 (Thu, 27 Aug 2009)
New Revision: 32739
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=32739&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=32739&amp;view=rev</A>

Modified:
   haiku/trunk/src/tests/kits/game/chart/ChartRender.cpp
   haiku/trunk/src/tests/kits/game/chart/ChartWindow.cpp
Log:
* Automatic whitespace cleanup.


Modified: haiku/trunk/src/tests/kits/game/chart/ChartRender.cpp
===================================================================
--- haiku/trunk/src/tests/kits/game/chart/ChartRender.cpp	2009-08-27 08:20:46 UTC (rev 32738)
+++ haiku/trunk/src/tests/kits/game/chart/ChartRender.cpp	2009-08-27 08:34:45 UTC (rev 32739)
@@ -1,11 +1,11 @@
 /*
-	
+
 	ChartRender.c
-	
+
 	by Pierre Raynaud-Richard.
-	
+
 	Copyright 1998 Be Incorporated, All Rights Reserved.
-	
+
 */
 
 /* This file has been designed to be easy to compile as a stand-alone
@@ -17,14 +17,14 @@
 
 /* This table provide the horizontal and vertical offset of the matrix
    of pixel used for drawing stars. This matrix is designed as follow:
-   
+
     --  [00] [01] [02] [03]  --
    [04] [05] [06] [07] [08] [09]
    [10] [11] [12] [13] [14] [15]
    [16] [17] [18] [19] [20] [21]
    [22] [23] [24] [25] [26] [27]
     --  [28] [29] [30] [31]  --
-    
+
    The reference pixel is [12]. */
 int8	pattern_dh[32] = {
 		-1, 0, 1, 2,
@@ -68,7 +68,7 @@
 	0x8c30c308,
 	0x08208200
 };
-			
+
 static uint32	visible_mask_right[6] = {
 	0xffffffff,
 	0xf7df7dff,
@@ -77,7 +77,7 @@
 	0x10c30c31,
 	0x00410410,
 };
-			
+
 static uint32	visible_mask_top[6] = {
 	0xffffffff,
 	0xfffffff0,
@@ -86,7 +86,7 @@
 	0xffc00000,
 	0xf0000000
 };
-			
+
 static uint32	visible_mask_bottom[6] = {
 	0xffffffff,
 	0x0fffffff,
@@ -95,7 +95,7 @@
 	0x000003ff,
 	0x0000000f
 };
-			
+
 /* Private functions used only internally. */
 bool		ProjectStar(star *s, geometry *geo);
 bool		CheckClipping(star *s, buffer *buf, bool reset_clipping);
@@ -108,33 +108,33 @@
    x : -0.25, y : -0.25
    x : +0.25, y : -0.25
    x : -0.25, y : +0.25
-   x : +0.25, y : +0.25 */		
+   x : +0.25, y : +0.25 */
 void InitPatterns()
 {
 	int32		i, j, k, count;
 	float		radius, x0, y0, x, y, dist, delta;
 	uint8		color;
 	uint8		*list, *color_offset;
-	
+
 	/* do the 4 half-pixel alignement */
 	for (j=0; j&lt;4; j++) {
 		if (j&amp;1) x0 = 1.25;
-		else	 x0 = 0.75; 
+		else	 x0 = 0.75;
 		if (j&amp;2) y0 = 1.25;
-		else	 y0 = 0.75; 
-		
+		else	 y0 = 0.75;
+
 		/* do the 32 sizes */
 		for (i=0; i&lt;LEVEL_COUNT; i++) {
 			radius = (float)(i+1) * (2.8/(float)LEVEL_COUNT);
 			count = 0;
 			list = pattern_list[j*LEVEL_COUNT + i];
 			color_offset = pattern_color_offset[j*LEVEL_COUNT + i];
-			
+
 			/* scan the 32 pixels of the matrix */
 			for (k=0; k&lt;32; k++) {
 				x = ((float)pattern_dh[k] + ROUNDING) - x0;
 				y = ((float)pattern_dv[k] + ROUNDING) - y0;
-				
+
 				dist = sqrt(x*x + y*y);
 				/* process non source pixel */
 				if (dist &gt; 0.5) {
@@ -194,7 +194,7 @@
 	/* Calculate the coordinate of the star after doing the cycling operation
 	   that convert the cube of the starfield in a torus. This ensure that
 	   get the copy of the star that is the only one likely to be visible from
-	   the camera. */	
+	   the camera. */
 	x0 = s-&gt;x;
 	if (x0 &lt; geo-&gt;cutx)
 		x0 += 1.0;
@@ -208,7 +208,7 @@
 	x0 -= geo-&gt;x;
 	y0 -= geo-&gt;y;
 	z0 -= geo-&gt;z;
-	
+
 	/* Calculate the z coordinate (depth) of the star in the camera referential. */
 	z = geo-&gt;m[0][2]*x0 + geo-&gt;m[1][2]*y0 + geo-&gt;m[2][2]*z0;
 
@@ -218,27 +218,27 @@
 
 	/* Calculate the x coordinate (horizontal) of the star in the camera referential. */
 	x = geo-&gt;m[0][0]*x0 + geo-&gt;m[1][0]*y0 + geo-&gt;m[2][0]*z0;
-	
+
 	/* Do the left and right clipping based on the pyramid of vision. */
 	if ((x &lt; geo-&gt;xz_min*z-BORDER_CLIPPING) || (x &gt; geo-&gt;xz_max*z+BORDER_CLIPPING))
 		return false;
-	
+
 	/* Calculate the y coordinate (vertical) of the star in the camera referential. */
 	y = geo-&gt;m[0][1]*x0 + geo-&gt;m[1][1]*y0 + geo-&gt;m[2][1]*z0;
-	
+
 	/* Do the top and bottom clipping based on the pyramid of vision. */
 	if ((y &lt; geo-&gt;yz_min*z-BORDER_CLIPPING) || (y &gt; geo-&gt;yz_max*z+BORDER_CLIPPING))
 		return false;
-	
+
 	/* Calculate the invert of z, used to project both H and V coordinate. Apply
 	   the zoom-factor at the same time. The zoom-factor was overscale by a factor
 	   of two in advance, for the half-pixel precision processing */
-	inv_z = geo-&gt;zoom_factor/z;	
+	inv_z = geo-&gt;zoom_factor/z;
 
 	/* Calculate the double pixel coordinate in the buffer (in half-pixel). */
 	h_double = (int32)(x * inv_z + geo-&gt;offset_h);
 	v_double = (int32)(y * inv_z + geo-&gt;offset_v);
-	
+
 	/* Calculate the light level of the star. We use that little weird function
 	   to a get faster gradient to black near the rear plan. */
 	level = (int32)(s-&gt;size * (inv_z * geo-&gt;z_max_square - z * geo-&gt;zoom_factor)) &gt;&gt; 8;
@@ -262,8 +262,8 @@
    which pixel of the star matrix are visible (if any). This depend of the
    clipping of the specific buffer you're using. This function will do that
    for the star (s), in the buffer (buf). It will return false if the star
-   is fully invisible, true if not. The falg reset_clipping is used to
-   reprocess the clipping from scratsh, or to just cumulate the new clipping
+   is fully invisible, true if not. The flag reset_clipping is used to
+   reprocess the clipping from scratch, or to just cumulate the new clipping
    to the last drawing clipping (this is needed when updating the clipping
    of every stars after changing the clipping region of the buffer). */
 bool CheckClipping(star *s, buffer *buf, bool reset_clipping)
@@ -295,7 +295,7 @@
 				(s-&gt;v &gt;= r-&gt;top) &amp;&amp;
 				(s-&gt;v &lt;= r-&gt;bottom))
 				goto visible;
-		/* The pixel is not visible. The star is marked as not drawn. */ 
+		/* The pixel is not visible. The star is marked as not drawn. */
 	invisible:
 		s-&gt;last_draw_offset = INVALID;
 		return false;
@@ -315,7 +315,7 @@
 		box.bottom = s-&gt;v + 3;
 
 		/* Check if the box is fully outside of the bounding box of the clipping
-		   region. That woudl guarantee that the star is invisible. */ 
+		   region. That woudl guarantee that the star is invisible. */
 		if ((box.right &lt; buf-&gt;clip_bounds.left) ||
 			(box.left &gt; buf-&gt;clip_bounds.right) ||
 			(box.bottom &lt; buf-&gt;clip_bounds.top) ||
@@ -336,35 +336,35 @@
 				tmp_visible = 0xffffffff;
 			else
 				tmp_visible = s-&gt;last_draw_pattern;
-			
+
 			/* Calculate the clipping on the left side of the rectangle. */
 			delta = r-&gt;left-box.left;
 			if (delta &gt; 5)
 				continue;
 			if (delta &gt; 0)
 				tmp_visible &amp;= visible_mask_left[delta];
-			
+
 			/* Calculate the clipping on the right side of the rectangle. */
 			delta = box.right-r-&gt;right;
 			if (delta &gt; 5)
 				continue;
 			if (delta &gt; 0)
 				tmp_visible &amp;= visible_mask_right[delta];
-			
+
 			/* Calculate the clipping on the top side of the rectangle. */
 			delta = r-&gt;top-box.top;
 			if (delta &gt; 5)
 				continue;
 			if (delta &gt; 0)
 				tmp_visible &amp;= visible_mask_top[delta];
-			
+
 			/* Calculate the clipping on the bottom side of the rectangle. */
 			delta = box.bottom-r-&gt;bottom;
 			if (delta &gt; 5)
 				continue;
 			if (delta &gt; 0)
 				tmp_visible &amp;= visible_mask_bottom[delta];
-			
+
 			/* Pixel of the matrix not clipped out at that point are visible
 			   inside this rectangle of the clipping region. We need to add
 			   them to the mask of currently known visible pixel. */
@@ -377,8 +377,8 @@
 		/* If no pixel are visible, then we know... */
 		if (total_visible != 0)
 			goto visible_pat;
-			
-		/* The star is not visible. It's marked as not drawn. */ 
+
+		/* The star is not visible. It's marked as not drawn. */
 	invisible_pat:
 		s-&gt;last_draw_offset = INVALID;
 		return false;
@@ -436,7 +436,7 @@
 		colors = buf-&gt;colors[s-&gt;color_type];
 		pat_list = pattern_list[s-&gt;pattern_level];
 		pat_color_offset = pattern_color_offset[s-&gt;pattern_level];
-		
+
 		/* Plot all pixel used to represent the star one after one... */
 		for (i=0; i&lt;count; i++) {
 			/* This is the index of the pixel in the matrix */
@@ -480,7 +480,7 @@
 
 	/* Color pattern we use to erase the buffer. */
 	back_color = buf-&gt;back_color;
-	
+
 	/* Simple case : the star is represented by only one pixel. */
 	count = pattern_list_count[s-&gt;pattern_level];
 	if (count == 1) {
@@ -507,7 +507,7 @@
 	/* Complex case : the star is represented by a multiple pixels. */
 	else {
 		pat_list = pattern_list[s-&gt;pattern_level];
-		
+
 		/* Erase all pixel used to represent the star one after one... */
 		for (i=0; i&lt;count; i++) {
 			index = pat_list[i];
@@ -542,21 +542,21 @@
 {
 	int32			i, min_count;
 	star			*s;
-	
+
 	// TODO: For some reason, when selecting the &quot;2 threads&quot; option under vmware,
 	// some weird timing calculations finish with setting the star packet count to
 	// a negative number. This screws all the next calculations, and the animation
 	// then comes to a stop.
-	sp-&gt;count = max_c(sp-&gt;count, 0);	
+	sp-&gt;count = max_c(sp-&gt;count, 0);
 
 	/* Calculate the number of stars that were process during the
 	   previous frame and still need to be process for that frame. */
 	min_count = sp-&gt;erase_count;
 	if (sp-&gt;count &lt; min_count)
 		min_count = sp-&gt;count;
-	
+
 	s = sp-&gt;list;
-	
+
 	/* For all those star... */
 	for (i=0; i&lt;min_count; s++, i++) {
 		/* ... erase them if necessary, ... */
@@ -575,13 +575,14 @@
 		else
 			s-&gt;last_draw_offset = INVALID;
 	}
-	
+
 	/* For star that were process at the previous frame but that we don't
 	   want to process anymore, we just need to erase them. */
-	for (; i&lt;sp-&gt;erase_count; s++, i++)
+	for (; i&lt;sp-&gt;erase_count; s++, i++) {
 		if (s-&gt;last_draw_offset != INVALID)
 			EraseStar(s, buf);
-	
+	}
+
 	/* For star that were not process before, but are now, we just need to
 	   go through the projection, clipping and drawing steps. */
 	for (; i&lt;sp-&gt;count; s++, i++) {
@@ -602,9 +603,10 @@
 	int32		i;
 
 	s = sp-&gt;list;
-	for (i=0; i&lt;sp-&gt;erase_count; s++, i++)
+	for (i=0; i&lt;sp-&gt;erase_count; s++, i++) {
 		if (s-&gt;last_draw_offset != INVALID)
 			CheckClipping(s, buf, false);
+	}
 }
 
 

Modified: haiku/trunk/src/tests/kits/game/chart/ChartWindow.cpp
===================================================================
--- haiku/trunk/src/tests/kits/game/chart/ChartWindow.cpp	2009-08-27 08:20:46 UTC (rev 32738)
+++ haiku/trunk/src/tests/kits/game/chart/ChartWindow.cpp	2009-08-27 08:34:45 UTC (rev 32739)
@@ -1,11 +1,11 @@
 /*
-	
+
 	ChartWindow.cpp
-	
+
 	by Pierre Raynaud-Richard.
-	
+
 	Copyright 1998 Be Incorporated, All Rights Reserved.
-	
+
 */
 
 #include &quot;ChartWindow.h&quot;
@@ -116,7 +116,7 @@
 	WINDOW_V_STD		= 600,
 	WINDOW_H_MAX		= 1920,
 	WINDOW_V_MAX		= 1440,
-	
+
 /* increment step used to dynamically resize the offscreen buffer */
 	WINDOW_H_STEP		= 224,
 	WINDOW_V_STEP		= 168
@@ -301,14 +301,14 @@
 void
 LaunchSound()
 {
-/*	
+/*
 	BEntry			soundFile;
 	app_info 		info;
 	status_t		err;
 	entry_ref		snd_ref;
 	BDirectory		appFolder;
-	sound_handle	sndhandle;	
-	
+	sound_handle	sndhandle;
+
 	err = be_app-&gt;GetAppInfo(&amp;info);
 	BEntry appEntry(&amp;info.ref);
 	if (err != B_NO_ERROR)
@@ -374,7 +374,7 @@
 	BFont boldFont(be_bold_font);
 	if (boldFont.Size() &gt; MAX_FONT_SIZE)
 		boldFont.SetSize(MAX_FONT_SIZE);
-	
+
 	/* offset the content area frame in window relative coordinate */
 	frame.OffsetTo(0.0, 0.0);
 
@@ -406,7 +406,7 @@
 	fCurrentSettings.back_color.alpha = 255;
 	fCurrentSettings.star_density = STAR_DENSITY_DEFAULT;
 	fCurrentSettings.refresh_rate = REFRESH_RATE_DEFAULT;
-	BScreen	screen(this);		
+	BScreen	screen(this);
 	fCurrentSettings.depth	= screen.ColorSpace();
 	fCurrentSettings.width = (int32)frame.right+1-LEFT_WIDTH;
 	fCurrentSettings.height = (int32)frame.bottom+1-TOP_LEFT_LIMIT;
@@ -448,7 +448,7 @@
 	fSpeed = 0.0115;
 	fTargetSpeed = fSpeed;
 
-	/* initialise the view coordinate system */	
+	/* initialise the view coordinate system */
 	InitGeometry();
 	SetGeometry(fCurrentSettings.width, fCurrentSettings.height);
 	SetCubeOffset();
@@ -470,7 +470,7 @@
 	/* build the UI content of the window */
 
 	/* top line background */
-	r.Set(0.0, 0.0, frame.right, TOP_LEFT_LIMIT - 1);  
+	r.Set(0.0, 0.0, frame.right, TOP_LEFT_LIMIT - 1);
 	fTopView = new BView(r, &quot;top view&quot;, B_FOLLOW_LEFT_RIGHT, B_WILL_DRAW);
 	fTopView-&gt;SetViewColor(background_color);
 	AddChild(fTopView);
@@ -478,7 +478,7 @@
 	h = 2;
 	v = V_BORDER;
 
-		/* instant load vue-meter */	
+		/* instant load vue-meter */
 		r.Set(h, v, h+INSTANT_LOAD-1, v + (TOP_LEFT_LIMIT - 1 - 2*V_BORDER));
 		fInstantLoad = new InstantView(r);
 		fTopView-&gt;AddChild(fInstantLoad);
@@ -564,7 +564,7 @@
 
 	h += BUTTON_WIDTH+2*H_BORDER;
 
-		/* background color button */									  
+		/* background color button */
 		r.Set(h, v, h+BUTTON_WIDTH-1, v + (TOP_LEFT_LIMIT - 1 - 2*V_BORDER));
 		fColorButton = new BPictureButton(r, &quot;&quot;,
 										  ButtonPicture(false, COLOR_BUTTON_PICT),
@@ -576,7 +576,7 @@
 
 	h += BUTTON_WIDTH+2*H_BORDER;
 
-		/* star density button */											  
+		/* star density button */
 		r.Set(h, v, h+BUTTON_WIDTH-1, v + (TOP_LEFT_LIMIT - 1 - 2*V_BORDER));
 		fDensityButton = new BPictureButton(r, &quot;&quot;,
 											ButtonPicture(false, DENSITY_BUTTON_PICT),
@@ -588,7 +588,7 @@
 
 	h += BUTTON_WIDTH+H_BORDER;
 
-		/* starfield type popup */ 
+		/* starfield type popup */
 		menu = new BPopUpMenu(&quot;Chaos&quot;);
 		item = new BMenuItem(&quot;Chaos&quot;, new BMessage(SPACE_CHAOS_MSG));
 		item-&gt;SetTarget(this);
@@ -599,7 +599,7 @@
 		item = new BMenuItem(&quot;Spiral&quot;, new BMessage(SPACE_SPIRAL_MSG));
 		item-&gt;SetTarget(this);
 		menu-&gt;AddItem(item);
-	
+
 		r.Set(h, v, h+SPACE_LABEL+SPACE_POPUP-1, v + (TOP_LEFT_LIMIT - 1 - 2*V_BORDER));
 		popup = new BMenuField(r, &quot;&quot;, &quot;Space:&quot;, menu);
 		popup-&gt;SetFont(&amp;font);
@@ -608,11 +608,11 @@
 		popup-&gt;ResizeToPreferred();
 		popup-&gt;SetDivider(popup-&gt;StringWidth(popup-&gt;Label()) + 4.0f);
 		fTopView-&gt;AddChild(popup);
-	
+
 	h += SPACE_LABEL+SPACE_POPUP+2*H_BORDER;
-	
+
 	/* left column gray background */
-	r.Set(0.0, TOP_LEFT_LIMIT, LEFT_WIDTH - 1, frame.bottom);  
+	r.Set(0.0, TOP_LEFT_LIMIT, LEFT_WIDTH - 1, frame.bottom);
 	fLeftView = new BView(r, &quot;top view&quot;, B_FOLLOW_LEFT | B_FOLLOW_TOP_BOTTOM, B_WILL_DRAW);
 	fLeftView-&gt;SetViewColor(background_color);
 	AddChild(fLeftView);
@@ -621,8 +621,8 @@
 	v2 = LEFT_OFFSET;
 	h = h2;
 	v = v2;
-		
-		/* status box */	
+
+		/* status box */
 		r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2, v+STATUS_BOX-1);
 		fStatusBox = new BBox(r);
 		fStatusBox-&gt;SetFont(&amp;boldFont);
@@ -631,8 +631,8 @@
 		float boxWidth, boxHeight;
 		fStatusBox-&gt;GetPreferredSize(&amp;boxWidth, &amp;boxHeight);
 		boxWidth += r.left;
-		
-		h = BOX_H_OFFSET;	
+
+		h = BOX_H_OFFSET;
 		v = BOX_V_OFFSET;
 
 			/* frames per second title string */
@@ -676,7 +676,7 @@
 	v2 += STATUS_BOX+LEFT_OFFSET*2;
 	h = h2;
 	v = v2;
-	
+
 		/* Fullscreen mode check box */
 		r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-1, v+FULL_SCREEN-1);
 		full_screen = new BCheckBox(r, &quot;&quot;, &quot;Full Screen&quot;, new BMessage(FULL_SCREEN_MSG));
@@ -688,11 +688,11 @@
 		full_screen-&gt;GetPreferredSize(&amp;width, &amp;height);
 		boxWidth = max_c(width + r.left, boxWidth);
 		fLeftView-&gt;AddChild(full_screen);
-		
+
 	v2 += FULL_SCREEN+LEFT_OFFSET*2;
 	h = h2;
 	v = v2;
-		
+
 		/* Automatic demonstration activation button */
 		r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-1, v+AUTO_DEMO-1);
 		button = new BButton(r, &quot;&quot;, &quot;Auto demo&quot;, new BMessage(AUTO_DEMO_MSG));
@@ -701,10 +701,10 @@
 		button-&gt;GetPreferredSize(&amp;width, &amp;height);
 		boxWidth = max_c(width + r.left, boxWidth);
 		fLeftView-&gt;AddChild(button);
-		
+
 	v2 += AUTO_DEMO+LEFT_OFFSET*2;
 	h = h2;
-	v = v2;		
+	v = v2;
 
 		/* Enabling second thread check box */
 		r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-1, v+SECOND_THREAD-1);
@@ -713,7 +713,7 @@
 		check_box-&gt;SetFont(&amp;font);
 		check_box-&gt;ResizeToPreferred();
 		fLeftView-&gt;AddChild(check_box);
-		
+
 	v2 += SECOND_THREAD+LEFT_OFFSET*2 + 2;
 	h = h2;
 	v = v2;
@@ -725,67 +725,67 @@
 		fColorsBox-&gt;SetFont(&amp;boldFont);
 		fLeftView-&gt;AddChild(fColorsBox);
 
-		h = BOX_H_OFFSET;	
+		h = BOX_H_OFFSET;
 		v = BOX_V_OFFSET;
 
-			/* star color red check box */	
+			/* star color red check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Red&quot;, new BMessage(COLORS_RED_MSG));
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color green check box */	
+
+			/* star color green check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Green&quot;, new BMessage(COLORS_GREEN_MSG));
 			check_box-&gt;SetValue(1);
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color blue check box */	
+
+			/* star color blue check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Blue&quot;, new BMessage(COLORS_BLUE_MSG));
 			check_box-&gt;SetValue(1);
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color yellow check box */	
+
+			/* star color yellow check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Yellow&quot;, new BMessage(COLORS_YELLOW_MSG));
 			check_box-&gt;SetValue(1);
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color orange check box */	
+
+			/* star color orange check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Orange&quot;, new BMessage(COLORS_ORANGE_MSG));
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color pink check box */	
+
+			/* star color pink check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;Pink&quot;, new BMessage(COLORS_PINK_MSG));
 			check_box-&gt;SetFont(&amp;font);
 			check_box-&gt;ResizeToPreferred();
 			fColorsBox-&gt;AddChild(check_box);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* star color white check box */	
+
+			/* star color white check box */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			check_box = new BCheckBox(r, &quot;&quot;, &quot;White&quot;, new BMessage(COLORS_WHITE_MSG));
 			check_box-&gt;SetFont(&amp;font);
@@ -803,38 +803,38 @@
 		fSpecialBox-&gt;SetLabel(&quot;Special&quot;);
 		fLeftView-&gt;AddChild(fSpecialBox);
 
-		h = BOX_H_OFFSET;	
+		h = BOX_H_OFFSET;
 		v = BOX_V_OFFSET;
 
-			/* no special radio button */	
+			/* no special radio button */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			radio = new BRadioButton(r, &quot;&quot;, &quot;None&quot;, new BMessage(SPECIAL_NONE_MSG));
 			radio-&gt;SetValue(1);
 			radio-&gt;SetFont(&amp;font);
 			radio-&gt;ResizeToPreferred();
 			fSpecialBox-&gt;AddChild(radio);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* comet special animation radio button */	
+
+			/* comet special animation radio button */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			radio = new BRadioButton(r, &quot;&quot;, &quot;Comet&quot;, new BMessage(SPECIAL_COMET_MSG));
 			radio-&gt;SetFont(&amp;font);
 			radio-&gt;ResizeToPreferred();
 			fSpecialBox-&gt;AddChild(radio);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* novas special animation radio button */	
+
+			/* novas special animation radio button */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			radio = new BRadioButton(r, &quot;&quot;, &quot;Novas&quot;, new BMessage(SPECIAL_NOVAS_MSG));
 			radio-&gt;SetFont(&amp;font);
 			radio-&gt;ResizeToPreferred();
 			fSpecialBox-&gt;AddChild(radio);
-	
+
 		v += COLORS_LABEL+COLORS_OFFSET;
-	
-			/* space batle special animation radio button (not implemented) */	
+
+			/* space batle special animation radio button (not implemented) */
 			r.Set(h, v, h+LEFT_WIDTH-2*LEFT_OFFSET-2*BOX_H_OFFSET-1, v+COLORS_LABEL-1);
 			radio = new BRadioButton(r, &quot;&quot;, &quot;Battle&quot;, new BMessage(SPECIAL_BATTLE_MSG));
 			radio-&gt;SetEnabled(false);
@@ -850,7 +850,7 @@
 	fChartView = new ChartView(r);
 	fChartView-&gt;SetViewColor(0, 0, 0);
 	AddChild(fChartView);
-	
+
 	/* allocate the semaphores */
 	fDrawingLock = create_sem(1, &quot;chart locker&quot;);
 	fSecondThreadLock = create_sem(0, &quot;chart second locker&quot;);
@@ -861,7 +861,7 @@
 	fAnimationThread = spawn_thread(ChartWindow::Animation, &quot;chart animation&quot;,
 								B_NORMAL_PRIORITY,
 								(void*)this);
-	
+
 	fSecondAnimationThread = spawn_thread(ChartWindow::Animation2, &quot;chart animation2&quot;,
 								B_NORMAL_PRIORITY,
 								(void*)this);
@@ -876,19 +876,19 @@
 
 	/* setting this flag force both animation threads to quit */
 	fKillThread = true;
-	
+
 	/* wait for the two animation threads to quit */
-	wait_for_thread(fAnimationThread, &amp;result);	
-	wait_for_thread(fSecondAnimationThread, &amp;result);	
+	wait_for_thread(fAnimationThread, &amp;result);
+	wait_for_thread(fSecondAnimationThread, &amp;result);
 
 	/* free the offscreen bitmap if any */
 	delete fOffscreen;
-		
+
 	/* release the semaphores used for synchronisation */
 	delete_sem(fDrawingLock);
 	delete_sem(fSecondThreadLock);
 	delete_sem(fSecondThreadRelease);
-	
+
 	/* free the buffers used to store the starlists */
 	free(fStars.list);
 	free(fSpecials.list);
@@ -896,7 +896,7 @@
 }
 
 
-//	#pragma mark Standard window members			
+//	#pragma mark Standard window members
 
 
 bool
@@ -914,7 +914,7 @@
 	BHandler		*handler;
 	BCheckBox		*check_box;
 	BSlider			*slider;
-	
+
 	message-&gt;FindPointer(&quot;source&quot;, (void**)&amp;handler);
 	switch(message-&gt;what) {
 		/* This is a key part of the architecture. MessageReceived is
@@ -1021,7 +1021,7 @@
 		/* open the three floating window used to do live setting of
 		   some advanced parameters. Those windows will return live
 		   feedback that will be executed by some of the previous
-		   messages. */	
+		   messages. */
 		case OPEN_COLOR_MSG :
 			OpenColorPalette(BPoint(200.0, 200.0));
 			break;
@@ -1045,7 +1045,7 @@
 	/* this is the same principle than the one described for
 	   MessageReceived, to inform the engine that the depth of
 	   the screen changed (needed only for offscreen bitmap.
-	   In DirectWindow, you get a direct notification). */	
+	   In DirectWindow, you get a direct notification). */
 	fNextSettings.depth = BScreen(this).ColorSpace();
 }
 
@@ -1056,9 +1056,9 @@
 	/* this is the same principle than the one described for
 	   MessageReceived, to inform the engine that the window
 	   size changed (needed only for offscreen bitmap. In
-	   DirectWindow, you get a direct notification). */	
+	   DirectWindow, you get a direct notification). */
 	fNextSettings.width = (int32)Frame().Width()+1-LEFT_WIDTH;
-	fNextSettings.height = (int32)Frame().Height()+1-TOP_LEFT_LIMIT;		
+	fNextSettings.height = (int32)Frame().Height()+1-TOP_LEFT_LIMIT;
 }
 
 
@@ -1072,7 +1072,7 @@
 {
 	int32		index;
 	BWindow		*window;
-	
+
 	for (index = 0;; index++) {
 		window = be_app-&gt;WindowAt(index);
 		if (window == NULL)
@@ -1085,7 +1085,7 @@
 			window-&gt;Unlock();
 		}
 	}
-	return window; 
+	return window;
 }
 
 /* this function return a picture (in active or inactive state) of
@@ -1101,7 +1101,7 @@
 	BPicture	*pict;
 
 
-	/* create and open the picture */	
+	/* create and open the picture */
 	pict = new BPicture();
 	r = fOffwindowButton-&gt;Bounds();
 	fOffwindowButton-&gt;SetValue(active);
@@ -1121,7 +1121,7 @@
 	else if (button_type == DENSITY_BUTTON_PICT) {
 		/* this button just contains a big string (using a bigger font size
 		   than what a standard BButton would allow) with the current value
-		   of the star density pourcentage. */ 
+		   of the star density pourcentage. */
 		value = (fCurrentSettings.star_density*100 + STAR_DENSITY_MAX/2) / STAR_DENSITY_MAX;
 		sprintf(word, &quot;%3ld&quot;, value);
 	draw_string:
@@ -1129,12 +1129,12 @@
 		fOffwindowButton-&gt;SetFontSize(14.0);
 		delta.x = BUTTON_WIDTH/2-(fOffwindowButton-&gt;StringWidth(word) * 0.5);
 		delta.y = (TOP_LEFT_LIMIT-2*V_BORDER)/2 + 6.0;
-		fOffwindowButton-&gt;DrawString(word, delta); 
+		fOffwindowButton-&gt;DrawString(word, delta);
 	}
 	else {
 		/* this button just contains a big string (using a bigger font size
 		   than what a standard BButton would allow) with the current value
-		   of the target refresh rate in frames per second. */ 
+		   of the target refresh rate in frames per second. */
 		sprintf(word, &quot;%3.1f&quot;, fCurrentSettings.refresh_rate + 0.05);
 		goto draw_string;
 	}
@@ -1219,7 +1219,7 @@
 		BSlider *slider = new BSlider(frame, &quot;&quot;, NULL, new BMessage(REFRESH_RATE_MSG), 0, 1000);
 		slider-&gt;SetViewColor(background_color);
 		slider-&gt;SetTarget(NULL, this);
-		slider-&gt;SetValue((int32)(1000 * log(fCurrentSettings.refresh_rate / REFRESH_RATE_MIN) / 
+		slider-&gt;SetValue((int32)(1000 * log(fCurrentSettings.refresh_rate / REFRESH_RATE_MIN) /
 						log(REFRESH_RATE_MAX/REFRESH_RATE_MIN)));
 		slider-&gt;SetModificationMessage(new BMessage(REFRESH_RATE_MSG));
 		slider-&gt;SetLimitLabels(&quot; 0.6 f/s  (logarythmic scale)&quot;, &quot;600.0 f/s&quot;);
@@ -1237,15 +1237,15 @@
 {
 	int32 i;
 	bigtime_t	timeout;
-	
+
 	int32 level = (int32)((frame_per_second + 6.0) * (1.0/12.0));
 	if (level &gt; 50)
 		level = 50;
 
-	/* if the load level is inchanged, nothing more to do... */	
+	/* if the load level is inchanged, nothing more to do... */
 	if (level == fInstantLoadLevel)
 		return;
-	
+
 	/* We need to lock the window to be able to draw that. But as some
 	   BControl are still synchronous, if the user is still tracking them,
 	   the window can stay block for a long time. It's not such a big deal
@@ -1259,9 +1259,9 @@
 		timeout = 0;
 	if (LockWithTimeout(timeout) != B_OK)
 		return;
-		
+
 	/* the new level is higher than the previous. We need to draw more
-	   colored bars. */	
+	   colored bars. */
 	if (level &gt; fInstantLoadLevel) {
 		for (i = fInstantLoadLevel; i &lt; level; i++) {
 			if (i &lt; fInstantLoad-&gt;step)
@@ -1281,7 +1281,7 @@
 	}
 	/* we want that drawing to be completed as soon as possible */
 	Flush();
-	
+
 	fInstantLoadLevel = level;
 	Unlock();
 }
@@ -1297,7 +1297,7 @@
 
 	/* rules use to determine the stat numbers : if the target framerate
 	   is greater than the simulate one, then we consider that 100.0 cpu
-	   was used, and we only got the simulate framerate. */ 
+	   was used, and we only got the simulate framerate. */
 	if (fps &lt;= fCurrentSettings.refresh_rate) {
 		load = 100.0;
 		frame_rate = fps + 0.05;
@@ -1310,7 +1310,7 @@
 		load = (100.0*fCurrentSettings.refresh_rate)/fps + 0.05;
 		frame_rate = fCurrentSettings.refresh_rate + 0.05;
 	}
-	
+
 	/* convert numbers in strings */
 	sprintf(text_cpu_load, &quot;%3.1f&quot;, load);
 	sprintf(text_frames, &quot;%3.1f&quot;, frame_rate);
@@ -1321,7 +1321,7 @@
 		timeout = 100000;
 	else
 		timeout = 0;
-		
+
 	if (LockWithTimeout(timeout) == B_OK) {
 		fFramesView-&gt;SetText(text_frames);
 		fCpuLoadView-&gt;SetText(text_cpu_load);
@@ -1336,19 +1336,19 @@
 void
 ChartWindow::InitGeometry()
 {
-	/* calculate some parameters required for the 3d processing */ 
+	/* calculate some parameters required for the 3d processing */
 	float dz = sqrt(1.0 - (DH_REF*DH_REF + DV_REF*DV_REF) * (0.5 + 0.5/Z_CUT_RATIO) * (0.5 + 0.5/Z_CUT_RATIO));
 	fDepthRef = dz / (1.0 - 1.0/Z_CUT_RATIO);
-	
+
 	/* set the position of the pyramid of vision, so that it was always
 	   possible to include it into a 1x1x1 cube parallel to the 3 main
 	   axis. */
 	fGeometry.z_max = fDepthRef;
 	fGeometry.z_min = fDepthRef/Z_CUT_RATIO;
-	
+
 	/* used for lighting processing */
 	fGeometry.z_max_square = fGeometry.z_max * fGeometry.z_max;
-	
+
 	/* preprocess that for the fast clipping based on the pyramid of vision */
 	fGeometry.xz_max = (0.5*DH_REF)/fGeometry.z_max;
 	fGeometry.xz_min = -fGeometry.xz_max;
@@ -1400,7 +1400,7 @@
 			break;
 		}
 	}
-	
+
 	/* check for change in the target refresh rate */
 	if (fCurrentSettings.refresh_rate != new_set.refresh_rate) {
 		fCurrentSettings.refresh_rate = new_set.refresh_rate;
@@ -1419,7 +1419,7 @@
 		if (fCurrentSettings.animation != ANIMATION_OFF)
 			fFrameDelay = (bigtime_t)(1000000.0/new_set.refresh_rate);
 	}
-	
+
 	/* check for change in the star colors list */
 	for (i=0; i&lt;7; i++)
 		if (fCurrentSettings.colors[i] != new_set.colors[i]) {
@@ -1435,7 +1435,7 @@
 			SetStarColors(color_index, color_count);
 			break;
 		}
-	
+
 	/* check for change of the special effect setting */
 	if (new_set.special != fCurrentSettings.special)
 		InitSpecials(new_set.special);
@@ -1446,7 +1446,7 @@
 			/* check the settings of the offscreen bitmap */
 			CheckBitmap(new_set.depth, new_set.width, new_set.height);
 			/* synchronise the camera geometry and the offscreen buffer geometry */
-			SetGeometry(fBitmapBuffer.buffer_width, fBitmapBuffer.buffer_height);	
+			SetGeometry(fBitmapBuffer.buffer_width, fBitmapBuffer.buffer_height);
 			/* reset the offscreen background and cancel the erasing */
 			SetBitmapBackGround();
 			fStars.erase_count = 0;
@@ -1464,7 +1464,7 @@
 			release_sem(fDrawingLock);
 		}
 	}
-	
+
 	/* check for change of the animation mode. */
 	if (new_set.animation != fCurrentSettings.animation) {
 		/* when there is no camera animation, we loop only
@@ -1483,21 +1483,21 @@
 			fCountPhi = 0;
 		}
 	}
-	
+
 	/* check for change of starfield model */
 	if (new_set.space_model != fCurrentSettings.space_model) {
 		/* Generate a new starfield. Also reset the special animation */
 		InitStars(new_set.space_model);
 		InitSpecials(new_set.special);
 	}
-	
+
 	/* check for change of the background color */
 	if ((new_set.back_color.red != fCurrentSettings.back_color.red) ||
 		(new_set.back_color.green != fCurrentSettings.back_color.green) ||
 		(new_set.back_color.blue != fCurrentSettings.back_color.blue)) {
 		if (LockWithTimeout(200000) == B_OK) {
-			BScreen		screen(this);		
-			/* set the background color and it's 8 bits index equivalent */	
+			BScreen		screen(this);
+			/* set the background color and it's 8 bits index equivalent */
 			fCurrentSettings.back_color = new_set.back_color;
 			fBackColorIndex = screen.IndexForColor(new_set.back_color);
 			/* set the nackground color of the view (directwindow mode) */
@@ -1515,7 +1515,7 @@
 			release_sem(fDrawingLock);
 			/* in offscreen mode, erase the background and cancel star erasing */
 			if (new_set.display == DISPLAY_BITMAP) {
-				SetBitmapBackGround();					
+				SetBitmapBackGround();
 				fStars.erase_count = 0;
 				fSpecials.erase_count = 0;

[... truncated: 836 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="020069.html">[Haiku-commits] r32738 - haiku/trunk/headers/build/os
</A></li>
	<LI>Next message: <A HREF="020041.html">[Haiku-commits] r32740 - haiku/trunk/src/kits/game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#20040">[ date ]</a>
              <a href="thread.html#20040">[ thread ]</a>
              <a href="subject.html#20040">[ subject ]</a>
              <a href="author.html#20040">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
