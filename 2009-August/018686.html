<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r32073 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch headers/private/kernel/arch/x86	src/system/boot/loader src/system/boot/platform/bios_ia32	src/system/boot/platform/openfirmware/arch/ppc	src/system/boot/platform/u-boot src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/slab src/system/kernel/vm
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-August/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32073%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/arch%20headers/private/kernel/arch/x86%0A%09src/system/boot/loader%20src/system/boot/platform/bios_ia32%0A%09src/system/boot/platform/openfirmware/arch/ppc%0A%09src/system/boot/platform/u-boot%20src/system/kernel%0A%09src/system/kernel/arch/m68k%20src/system/kernel/arch/ppc%0A%09src/system/kernel/arch/x86%20src/system/kernel/debug%0A%09src/system/kernel/slab%20src/system/kernel/vm&In-Reply-To=%3C200908031240.n73CeTJL007743%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="018685.html">
   <LINK REL="Next"  HREF="018689.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r32073 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch headers/private/kernel/arch/x86	src/system/boot/loader src/system/boot/platform/bios_ia32	src/system/boot/platform/openfirmware/arch/ppc	src/system/boot/platform/u-boot src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/slab src/system/kernel/vm</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r32073%20-%20in%20haiku/trunk%3A%20headers/private/kernel%0A%09headers/private/kernel/arch%20headers/private/kernel/arch/x86%0A%09src/system/boot/loader%20src/system/boot/platform/bios_ia32%0A%09src/system/boot/platform/openfirmware/arch/ppc%0A%09src/system/boot/platform/u-boot%20src/system/kernel%0A%09src/system/kernel/arch/m68k%20src/system/kernel/arch/ppc%0A%09src/system/kernel/arch/x86%20src/system/kernel/debug%0A%09src/system/kernel/slab%20src/system/kernel/vm&In-Reply-To=%3C200908031240.n73CeTJL007743%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r32073 - in haiku/trunk: headers/private/kernel	headers/private/kernel/arch headers/private/kernel/arch/x86	src/system/boot/loader src/system/boot/platform/bios_ia32	src/system/boot/platform/openfirmware/arch/ppc	src/system/boot/platform/u-boot src/system/kernel	src/system/kernel/arch/m68k src/system/kernel/arch/ppc	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/slab src/system/kernel/vm">bonefish at mail.berlios.de
       </A><BR>
    <I>Mon Aug  3 14:40:29 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="018685.html">[Haiku-commits] r32072 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
        <LI>Next message: <A HREF="018689.html">[Haiku-commits] r32074 - in haiku/trunk: headers/private/kernel	src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18686">[ date ]</a>
              <a href="thread.html#18686">[ thread ]</a>
              <a href="subject.html#18686">[ subject ]</a>
              <a href="author.html#18686">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-08-03 14:39:56 +0200 (Mon, 03 Aug 2009)
New Revision: 32073
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=32073&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=32073&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/kernel/arch/debug.h
   haiku/trunk/headers/private/kernel/arch/vm_translation_map.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h
   haiku/trunk/headers/private/kernel/cpu.h
   haiku/trunk/headers/private/kernel/debug.h
   haiku/trunk/headers/private/kernel/kernel.h
   haiku/trunk/src/system/boot/loader/elf.cpp
   haiku/trunk/src/system/boot/loader/kernel_args.cpp
   haiku/trunk/src/system/boot/platform/bios_ia32/mmu.cpp
   haiku/trunk/src/system/boot/platform/openfirmware/arch/ppc/mmu.cpp
   haiku/trunk/src/system/boot/platform/u-boot/mmu.cpp
   haiku/trunk/src/system/kernel/arch/m68k/arch_cpu.cpp
   haiku/trunk/src/system/kernel/arch/m68k/arch_debug.cpp
   haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
   haiku/trunk/src/system/kernel/arch/ppc/arch_cpu.cpp
   haiku/trunk/src/system/kernel/arch/ppc/arch_debug.cpp
   haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_int.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_interrupts.S
   haiku/trunk/src/system/kernel/arch/x86/arch_vm_translation_map.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_x86.S
   haiku/trunk/src/system/kernel/arch/x86/asm_offsets.cpp
   haiku/trunk/src/system/kernel/arch/x86/interrupts.h
   haiku/trunk/src/system/kernel/arch/x86/x86_physical_page_mapper.h
   haiku/trunk/src/system/kernel/arch/x86/x86_physical_page_mapper_large_memory.cpp
   haiku/trunk/src/system/kernel/debug/debug.cpp
   haiku/trunk/src/system/kernel/debug/debug_commands.cpp
   haiku/trunk/src/system/kernel/debug/debug_parser.cpp
   haiku/trunk/src/system/kernel/debug/gdb.cpp
   haiku/trunk/src/system/kernel/elf.cpp
   haiku/trunk/src/system/kernel/slab/Slab.cpp
   haiku/trunk/src/system/kernel/vm/vm.cpp
Log:
* Renamed the ROUNDOWN macro to ROUNDDOWN. Also changed the implementation of
  ROUNDUP to use '*' and '/' -- the compiler will optimize that for powers of
  two anyway and this implementation works for other numbers as well.
* The thread::fault_handler use in C[++] code was broken with gcc 4. At least
  when other functions were invoked. Trying to trick the compiler wasn't a
  particularly good idea anyway, since the next compiler version could break
  the trick again. So the general policy is to use the fault handlers only in
  assembly code where we have full control. Changed that for x86 (save for the
  vm86 mode, which has a similar mechanism), but not for the other
  architectures.
* Introduced fault_handler, fault_handler_stack_pointer, and fault_jump_buffer
  fields in the cpu_ent structure, which must be used instead of
  thread::fault_handler in the kernel debugger. Consequently user_memcpy() must
  not be used in the kernel debugger either. Introduced a debug_memcpy()
  instead.
* Introduced debug_call_with_fault_handler() function which calls a function
  in a setjmp() and fault handler context. The architecture specific backend
  arch_debug_call_with_fault_handler() has only been implemented for x86 yet.
* Introduced debug_is_kernel_memory_accessible() for use in the kernel
  debugger. It determines whether a range of memory can be accessed in the
  way specified. The architecture specific back end
  arch_vm_translation_map_is_kernel_page_accessible() has only been implemented
  for x86 yet.
* Added arch_debug_unset_current_thread() (only implemented for x86) to unset
  the current thread pointer in the kernel debugger. When entering the kernel
  debugger we do some basic sanity checks of the currently set thread structure
  and unset it, if they fail. This allows certain commands (most importantly
  the stack trace command) to avoid accessing the thread structure.
* x86: When handling a double fault, we do now install a special handler for
  page faults. This allows us to gracefully catch faulting commands, even if
  e.g. the thread structure is toast.

We are now in much better shape to deal with double faults. Hopefully avoiding
the triple faults that some people have been experiencing on their hardware
and ideally even allowing to use the kernel debugger normally.


Modified: haiku/trunk/headers/private/kernel/arch/debug.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/debug.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/arch/debug.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -11,6 +11,9 @@
 
 #include &lt;SupportDefs.h&gt;
 
+#include &lt;cpu.h&gt;
+
+
 struct kernel_args;
 struct thread;
 
@@ -27,6 +30,9 @@
 bool arch_debug_contains_call(struct thread *thread, const char *symbol,
 		addr_t start, addr_t end);
 void arch_debug_save_registers(int *);
+void arch_debug_unset_current_thread(void);
+void arch_debug_call_with_fault_handler(cpu_ent* cpu, jmp_buf jumpBuffer,
+		void (*function)(void*), void* parameter);
 
 bool arch_is_debug_variable_defined(const char* variableName);
 status_t arch_set_debug_variable(const char* variableName, uint64 value);

Modified: haiku/trunk/headers/private/kernel/arch/vm_translation_map.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/vm_translation_map.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/arch/vm_translation_map.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -23,11 +23,14 @@
 status_t arch_vm_translation_map_init_post_area(struct kernel_args *args);
 status_t arch_vm_translation_map_init_post_sem(struct kernel_args *args);
 
-// quick function to map a page in regardless of map context. Used in VM initialization,
-// before most vm data structures exist
+// Quick function to map a page in regardless of map context. Used in VM
+// initialization before most vm data structures exist.
 status_t arch_vm_translation_map_early_map(struct kernel_args *args, addr_t va, addr_t pa,
 	uint8 attributes, addr_t (*get_free_page)(struct kernel_args *));
 
+bool arch_vm_translation_map_is_kernel_page_accessible(addr_t virtualAddress,
+		uint32 protection);
+
 #ifdef __cplusplus
 }
 #endif

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -284,6 +284,7 @@
 void* x86_get_double_fault_stack(int32 cpu, size_t* _size);
 int32 x86_double_fault_get_cpu(void);
 void x86_double_fault_exception(struct iframe* frame);
+void x86_page_fault_exception_double_fault(struct iframe* frame);
 
 
 #define read_cr3(value) \

Modified: haiku/trunk/headers/private/kernel/cpu.h
===================================================================
--- haiku/trunk/headers/private/kernel/cpu.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/cpu.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -9,6 +9,8 @@
 #define _KERNEL_CPU_H
 
 
+#include &lt;setjmp.h&gt;
+
 #include &lt;smp.h&gt;
 #include &lt;timer.h&gt;
 #include &lt;boot/kernel_args.h&gt;
@@ -24,20 +26,25 @@
 /* CPU local data structure */
 
 typedef struct cpu_ent {
-	int cpu_num;
+	int			cpu_num;
 
 	// thread.c: used to force a reschedule at quantum expiration time
-	int preempted;
-	timer quantum_timer;
+	int			preempted;
+	timer		quantum_timer;
 
 	// keeping track of CPU activity
-	bigtime_t active_time;
-	bigtime_t last_kernel_time;
-	bigtime_t last_user_time;
+	bigtime_t	active_time;
+	bigtime_t	last_kernel_time;
+	bigtime_t	last_user_time;
 
-	bool invoke_scheduler;
-	bool disabled;
+	// used in the kernel debugger
+	addr_t		fault_handler;
+	addr_t		fault_handler_stack_pointer;
+	jmp_buf		fault_jump_buffer;
 
+	bool		invoke_scheduler;
+	bool		disabled;
+
 	// arch-specific stuff
 	arch_cpu_info arch;
 } cpu_ent __attribute__((aligned(64)));

Modified: haiku/trunk/headers/private/kernel/debug.h
===================================================================
--- haiku/trunk/headers/private/kernel/debug.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/debug.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -8,12 +8,15 @@
 #ifndef _KERNEL_DEBUG_H
 #define _KERNEL_DEBUG_H
 
-#include &quot;kernel_debug_config.h&quot;
 
+#include &lt;setjmp.h&gt;
+
 #include &lt;KernelExport.h&gt;
 #include &lt;module.h&gt;
 
+#include &quot;kernel_debug_config.h&quot;
 
+
 /*	KDEBUG
 	The kernel debug level.
 	Level 1 is usual asserts, &gt; 1 should be used for very expensive runtime
@@ -123,6 +126,11 @@
 extern void		debug_trap_cpu_in_kdl(int32 cpu, bool returnIfHandedOver);
 extern void		debug_double_fault(int32 cpu);
 extern bool		debug_emergency_key_pressed(char key);
+extern bool		debug_is_kernel_memory_accessible(addr_t address, size_t size,
+					uint32 protection);
+extern int		debug_call_with_fault_handler(jmp_buf jumpBuffer,
+					void (*function)(void*), void* parameter);
+extern status_t	debug_memcpy(void* to, const void* from, size_t size);
 
 extern char		kgetc(void);
 extern void		kputs(const char *string);

Modified: haiku/trunk/headers/private/kernel/kernel.h
===================================================================
--- haiku/trunk/headers/private/kernel/kernel.h	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/headers/private/kernel/kernel.h	2009-08-03 12:39:56 UTC (rev 32073)
@@ -39,8 +39,8 @@
 #define ENV_SIZE	(B_PAGE_SIZE * 8)
 
 
-#define ROUNDUP(a, b) (((a) + ((b)-1)) &amp; ~((b)-1))
-#define ROUNDOWN(a, b) (((a) / (b)) * (b))
+#define ROUNDDOWN(a, b)	(((a) / (b)) * (b))
+#define ROUNDUP(a, b)	ROUNDDOWN((a) + (b) - 1, b)
 
 
 #define CHECK_BIT(a, b) ((a) &amp; (1 &lt;&lt; (b)))

Modified: haiku/trunk/src/system/boot/loader/elf.cpp
===================================================================
--- haiku/trunk/src/system/boot/loader/elf.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/boot/loader/elf.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -126,9 +126,9 @@
 		status = B_ERROR;
 		goto error1;
 	}
-	
+
 	// find symbol table in section headers
-	
+
 	for (int32 i = 0; i &lt; elfHeader.e_shnum; i++) {
 		if (sectionHeaders[i].sh_type == SHT_SYMTAB) {
 			stringHeader = &amp;sectionHeaders[sectionHeaders[i].sh_link];
@@ -275,7 +275,7 @@
 		} else
 			continue;
 
-		region-&gt;start = ROUNDOWN(header.p_vaddr, B_PAGE_SIZE);
+		region-&gt;start = ROUNDDOWN(header.p_vaddr, B_PAGE_SIZE);
 		region-&gt;size = ROUNDUP(header.p_memsz + (header.p_vaddr % B_PAGE_SIZE),
 			B_PAGE_SIZE);
 		region-&gt;delta = -region-&gt;start;

Modified: haiku/trunk/src/system/boot/loader/kernel_args.cpp
===================================================================
--- haiku/trunk/src/system/boot/loader/kernel_args.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/boot/loader/kernel_args.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -62,7 +62,7 @@
 {
 	uint32 numRanges = *_numRanges;
 
-	start = ROUNDOWN(start, B_PAGE_SIZE);
+	start = ROUNDDOWN(start, B_PAGE_SIZE);
 	size = ROUNDUP(size, B_PAGE_SIZE);
 	addr_t end = start + size;
 
@@ -141,7 +141,7 @@
 	uint32 numRanges = *_numRanges;
 
 	addr_t end = ROUNDUP(start + size, B_PAGE_SIZE);
-	start = ROUNDOWN(start, B_PAGE_SIZE);
+	start = ROUNDDOWN(start, B_PAGE_SIZE);
 
 	for (uint32 i = 0; i &lt; numRanges; i++) {
 		addr_t rangeStart = ranges[i].start;

Modified: haiku/trunk/src/system/boot/platform/bios_ia32/mmu.cpp
===================================================================
--- haiku/trunk/src/system/boot/platform/bios_ia32/mmu.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/boot/platform/bios_ia32/mmu.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -632,7 +632,7 @@
 				extMemoryBlock[i].base_addr
 					= ROUNDUP(extMemoryBlock[i].base_addr, B_PAGE_SIZE);
 				extMemoryBlock[i].length
-					= ROUNDOWN(extMemoryBlock[i].length, B_PAGE_SIZE);
+					= ROUNDDOWN(extMemoryBlock[i].length, B_PAGE_SIZE);
 
 				// we ignore all memory beyond 4 GB
 				if (extMemoryBlock[i].base_addr &gt; 0xffffffffULL)

Modified: haiku/trunk/src/system/boot/platform/openfirmware/arch/ppc/mmu.cpp
===================================================================
--- haiku/trunk/src/system/boot/platform/openfirmware/arch/ppc/mmu.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/boot/platform/openfirmware/arch/ppc/mmu.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -57,7 +57,7 @@
 insert_memory_range(addr_range *ranges, uint32 &amp;numRanges, uint32 maxRanges,
 	const void *_start, uint32 _size)
 {
-	addr_t start = ROUNDOWN(addr_t(_start), B_PAGE_SIZE);
+	addr_t start = ROUNDDOWN(addr_t(_start), B_PAGE_SIZE);
 	addr_t end = ROUNDUP(addr_t(_start) + _size, B_PAGE_SIZE);
 	addr_t size = end - start;
 	if (size == 0)
@@ -133,7 +133,7 @@
 remove_memory_range(addr_range *ranges, uint32 &amp;numRanges, uint32 maxRanges,
 	const void *_start, uint32 _size)
 {
-	addr_t start = ROUNDOWN(addr_t(_start), B_PAGE_SIZE);
+	addr_t start = ROUNDDOWN(addr_t(_start), B_PAGE_SIZE);
 	addr_t end = ROUNDUP(addr_t(_start) + _size, B_PAGE_SIZE);
 
 	for (uint32 i = 0; i &lt; numRanges; i++) {

Modified: haiku/trunk/src/system/boot/platform/u-boot/mmu.cpp
===================================================================
--- haiku/trunk/src/system/boot/platform/u-boot/mmu.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/boot/platform/u-boot/mmu.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -618,7 +618,7 @@
 				extMemoryBlock[i].base_addr
 					= ROUNDUP(extMemoryBlock[i].base_addr, B_PAGE_SIZE);
 				extMemoryBlock[i].length
-					= ROUNDOWN(extMemoryBlock[i].length, B_PAGE_SIZE);
+					= ROUNDDOWN(extMemoryBlock[i].length, B_PAGE_SIZE);
 
 				// we ignore all memory beyond 4 GB
 				if (extMemoryBlock[i].base_addr &gt; 0xffffffffULL)

Modified: haiku/trunk/src/system/kernel/arch/m68k/arch_cpu.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/arch_cpu.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/m68k/arch_cpu.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -30,7 +30,7 @@
 int arch_mmu_type;
 int arch_platform;
 
-status_t 
+status_t
 arch_cpu_preboot_init_percpu(kernel_args *args, int curr_cpu)
 {
 	// enable FPU
@@ -44,7 +44,7 @@
 }
 
 
-status_t 
+status_t
 arch_cpu_init_percpu(kernel_args *args, int curr_cpu)
 {
 	//detect_cpu(curr_cpu);
@@ -102,7 +102,7 @@
 }
 
 
-void 
+void
 arch_cpu_sync_icache(void *address, size_t len)
 {
 	cpu_ops.flush_icache((addr_t)address, len);
@@ -125,7 +125,7 @@
 }
 
 
-void 
+void
 arch_cpu_invalidate_TLB_range(addr_t start, addr_t end)
 {
 	int32 num_pages = end / B_PAGE_SIZE - start / B_PAGE_SIZE;
@@ -139,11 +139,11 @@
 }
 
 
-void 
+void
 arch_cpu_invalidate_TLB_list(addr_t pages[], int num_pages)
 {
 	int i;
-	
+
 	cpu_ops.flush_insn_pipeline();
 	for (i = 0; i &lt; num_pages; i++) {
 		cpu_ops.flush_atc_addr(pages[i]);
@@ -153,7 +153,7 @@
 }
 
 
-void 
+void
 arch_cpu_global_TLB_invalidate(void)
 {
 	cpu_ops.flush_insn_pipeline();
@@ -162,7 +162,7 @@
 }
 
 
-void 
+void
 arch_cpu_user_TLB_invalidate(void)
 {
 	cpu_ops.flush_insn_pipeline();
@@ -179,6 +179,7 @@
 	char *s = (char *)from;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (m68k_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
@@ -200,7 +201,7 @@
  *	\param to Pointer to the destination C-string.
  *	\param from Pointer to the source C-string.
  *	\param size Size in bytes of the string buffer pointed to by \a to.
- *	
+ *
  *	\return strlen(\a from).
  */
 
@@ -210,12 +211,13 @@
 	int from_length = 0;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (m68k_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
 	if (size &gt; 0) {
 		to[--size] = '\0';
-		// copy 
+		// copy
 		for ( ; size; size--, from_length++, to++, from++) {
 			if ((*to = *from) == '\0')
 				break;
@@ -240,6 +242,7 @@
 	char *xs = (char *)s;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (m68k_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
@@ -289,6 +292,7 @@
 bool
 m68k_set_fault_handler(addr_t *handlerLocation, addr_t handler)
 {
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	*handlerLocation = handler;
 	return false;
 }

Modified: haiku/trunk/src/system/kernel/arch/m68k/arch_debug.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/arch_debug.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/m68k/arch_debug.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -65,25 +65,14 @@
 static status_t
 get_next_frame(addr_t framePointer, addr_t *next, addr_t *ip)
 {
-	struct thread *thread = thread_get_current_thread();
-	addr_t oldFaultHandler = thread-&gt;fault_handler;
+	stack_frame frame;
+	if (debug_memcpy(&amp;frame, (void*)framePointer, sizeof(frame)) != B_OK)
+		return B_BAD_ADDRESS;
 
-	// set fault handler, so that we can safely access user stacks
-	if (thread) {
-		if (m68k_set_fault_handler(&amp;thread-&gt;fault_handler, (addr_t)&amp;&amp;error))
-			goto error;
-	}
+	*ip = frame.return_address;
+	*next = (addr_t)frame.previous;
 
-	*ip = ((struct stack_frame *)framePointer)-&gt;return_address;
-	*next = (addr_t)((struct stack_frame *)framePointer)-&gt;previous;
-
-	if (thread)
-		thread-&gt;fault_handler = oldFaultHandler;
 	return B_OK;
-
-error:
-	thread-&gt;fault_handler = oldFaultHandler;
-	return B_BAD_ADDRESS;
 }
 
 
@@ -367,6 +356,22 @@
 }
 
 
+void
+arch_debug_unset_current_thread(void)
+{
+	// TODO: Implement!
+}
+
+
+void
+arch_debug_call_with_fault_handler(cpu_ent* cpu, jmp_buf jumpBuffer,
+	void (*function)(void*), void* parameter)
+{
+	// TODO: Implement! Most likely in assembly.
+	longjmp(jumpBuffer, 1);
+}
+
+
 bool
 arch_is_debug_variable_defined(const char* variableName)
 {

Modified: haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/m68k/arch_vm_translation_map_impl.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -651,7 +651,7 @@
 	status_t status;
 	int index;
 
-	start = ROUNDOWN(start, B_PAGE_SIZE);
+	start = ROUNDDOWN(start, B_PAGE_SIZE);
 	end = ROUNDUP(end, B_PAGE_SIZE);
 
 	TRACE((&quot;unmap_tmap: asked to free pages 0x%lx to 0x%lx\n&quot;, start, end));
@@ -873,7 +873,7 @@
 	status_t status;
 	int index;
 
-	start = ROUNDOWN(start, B_PAGE_SIZE);
+	start = ROUNDDOWN(start, B_PAGE_SIZE);
 	end = ROUNDUP(end, B_PAGE_SIZE);
 
 	TRACE((&quot;protect_tmap: pages 0x%lx to 0x%lx, attributes %lx\n&quot;, start, end, attributes));
@@ -1511,3 +1511,11 @@
 	return B_OK;
 }
 
+
+bool
+arch_vm_translation_map_is_kernel_page_accessible(addr_t virtualAddress,
+	uint32 protection)
+{
+	// TODO: Implement!
+	return false;
+}

Modified: haiku/trunk/src/system/kernel/arch/ppc/arch_cpu.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/ppc/arch_cpu.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/ppc/arch_cpu.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -16,7 +16,7 @@
 
 static bool sHasTlbia;
 
-status_t 
+status_t
 arch_cpu_preboot_init_percpu(kernel_args *args, int curr_cpu)
 {
 	// enable FPU
@@ -65,7 +65,7 @@
 
 #define CACHELINE 32
 
-void 
+void
 arch_cpu_sync_icache(void *address, size_t len)
 {
 	int l, off;
@@ -109,7 +109,7 @@
 }
 
 
-void 
+void
 arch_cpu_invalidate_TLB_range(addr_t start, addr_t end)
 {
 	asm volatile(&quot;sync&quot;);
@@ -124,7 +124,7 @@
 }
 
 
-void 
+void
 arch_cpu_invalidate_TLB_list(addr_t pages[], int num_pages)
 {
 	int i;
@@ -140,7 +140,7 @@
 }
 
 
-void 
+void
 arch_cpu_global_TLB_invalidate(void)
 {
 	if (sHasTlbia) {
@@ -156,7 +156,7 @@
 			tlbie(address);
 			eieio();
 			ppc_sync();
-	
+
 			address += B_PAGE_SIZE;
 		}
 		tlbsync();
@@ -165,7 +165,7 @@
 }
 
 
-void 
+void
 arch_cpu_user_TLB_invalidate(void)
 {
 	arch_cpu_global_TLB_invalidate();
@@ -180,6 +180,7 @@
 	char *s = (char *)from;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (ppc_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
@@ -201,7 +202,7 @@
  *	\param to Pointer to the destination C-string.
  *	\param from Pointer to the source C-string.
  *	\param size Size in bytes of the string buffer pointed to by \a to.
- *	
+ *
  *	\return strlen(\a from).
  */
 
@@ -211,12 +212,13 @@
 	int from_length = 0;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (ppc_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
 	if (size &gt; 0) {
 		to[--size] = '\0';
-		// copy 
+		// copy
 		for ( ; size; size--, from_length++, to++, from++) {
 			if ((*to = *from) == '\0')
 				break;
@@ -241,6 +243,7 @@
 	char *xs = (char *)s;
 	addr_t oldFaultHandler = *faultHandler;
 
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	if (ppc_set_fault_handler(faultHandler, (addr_t)&amp;&amp;error))
 		goto error;
 
@@ -286,6 +289,7 @@
 bool
 ppc_set_fault_handler(addr_t *handlerLocation, addr_t handler)
 {
+// TODO: This doesn't work correctly with gcc 4 anymore!
 	*handlerLocation = handler;
 	return false;
 }

Modified: haiku/trunk/src/system/kernel/arch/ppc/arch_debug.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/ppc/arch_debug.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/ppc/arch_debug.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -64,25 +64,14 @@
 static status_t
 get_next_frame(addr_t framePointer, addr_t *next, addr_t *ip)
 {
-	struct thread *thread = thread_get_current_thread();
-	addr_t oldFaultHandler = thread-&gt;fault_handler;
+	stack_frame frame;
+	if (debug_memcpy(&amp;frame, (void*)framePointer, sizeof(frame)) != B_OK)
+		return B_BAD_ADDRESS;
 
-	// set fault handler, so that we can safely access user stacks
-	if (thread) {
-		if (ppc_set_fault_handler(&amp;thread-&gt;fault_handler, (addr_t)&amp;&amp;error))
-			goto error;
-	}
+	*ip = frame.return_address;
+	*next = (addr_t)frame.previous;
 
-	*ip = ((struct stack_frame *)framePointer)-&gt;return_address;
-	*next = (addr_t)((struct stack_frame *)framePointer)-&gt;previous;
-
-	if (thread)
-		thread-&gt;fault_handler = oldFaultHandler;
 	return B_OK;
-
-error:
-	thread-&gt;fault_handler = oldFaultHandler;
-	return B_BAD_ADDRESS;
 }
 
 
@@ -303,6 +292,22 @@
 }
 
 
+void
+arch_debug_unset_current_thread(void)
+{
+	// TODO: Implement!
+}
+
+
+void
+arch_debug_call_with_fault_handler(cpu_ent* cpu, jmp_buf jumpBuffer,
+	void (*function)(void*), void* parameter)
+{
+	// TODO: Implement! Most likely in assembly.
+	longjmp(jumpBuffer, 1);
+}
+
+
 bool
 arch_is_debug_variable_defined(const char* variableName)
 {

Modified: haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/ppc/arch_vm_translation_map.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -330,7 +330,7 @@
 {
 	page_table_entry *entry;
 
-	start = ROUNDOWN(start, B_PAGE_SIZE);
+	start = ROUNDDOWN(start, B_PAGE_SIZE);
 	end = ROUNDUP(end, B_PAGE_SIZE);
 
 //	dprintf(&quot;vm_translation_map.unmap_tmap: start 0x%lx, end 0x%lx\n&quot;, start, end);
@@ -678,8 +678,8 @@
 	size_t size)
 {
 	addr_t virtualEnd = ROUNDUP(virtualAddress + size, B_PAGE_SIZE);
-	virtualAddress = ROUNDOWN(virtualAddress, B_PAGE_SIZE);
-	physicalAddress = ROUNDOWN(physicalAddress, B_PAGE_SIZE);
+	virtualAddress = ROUNDDOWN(virtualAddress, B_PAGE_SIZE);
+	physicalAddress = ROUNDDOWN(physicalAddress, B_PAGE_SIZE);
 
 	vm_address_space *addressSpace = vm_kernel_address_space();
 
@@ -701,7 +701,7 @@
 ppc_unmap_address_range(addr_t virtualAddress, size_t size)
 {
 	addr_t virtualEnd = ROUNDUP(virtualAddress + size, B_PAGE_SIZE);
-	virtualAddress = ROUNDOWN(virtualAddress, B_PAGE_SIZE);
+	virtualAddress = ROUNDDOWN(virtualAddress, B_PAGE_SIZE);
 
 	vm_address_space *addressSpace = vm_kernel_address_space();
 
@@ -713,7 +713,7 @@
 status_t
 ppc_remap_address_range(addr_t *_virtualAddress, size_t size, bool unmap)
 {
-	addr_t virtualAddress = ROUNDOWN(*_virtualAddress, B_PAGE_SIZE);
+	addr_t virtualAddress = ROUNDDOWN(*_virtualAddress, B_PAGE_SIZE);
 	size = ROUNDUP(*_virtualAddress + size - virtualAddress, B_PAGE_SIZE);
 
 	vm_address_space *addressSpace = vm_kernel_address_space();
@@ -746,3 +746,11 @@
 	return B_OK;
 }
 
+
+bool
+arch_vm_translation_map_is_kernel_page_accessible(addr_t virtualAddress,
+	uint32 protection)
+{
+	// TODO: Implement!
+	return false;
+}

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -56,26 +56,36 @@
 }
 
 
+/*!	Safe to be called only from outside the debugger.
+*/
 static status_t
-get_next_frame(addr_t ebp, addr_t *_next, addr_t *_eip)
+get_next_frame_no_debugger(addr_t ebp, addr_t *_next, addr_t *_eip)
 {
-	// set fault handler, so that we can safely access user stacks
-	addr_t oldFaultHandler = thread_get_current_thread()-&gt;fault_handler;
-	thread_get_current_thread()-&gt;fault_handler = (addr_t)&amp;&error;
-	// Fake goto to trick the compiler not to optimize the code at the label
-	// away.
-	if (ebp == 0)
-		goto error;
+	// TODO: Do this more efficiently in assembly.
+	stack_frame frame;
+	if (user_memcpy(&amp;frame, (void*)ebp, sizeof(frame)) != B_OK)
+		return B_BAD_ADDRESS;
 
-	*_eip = ((struct stack_frame *)ebp)-&gt;return_address;
-	*_next = (addr_t)((struct stack_frame *)ebp)-&gt;previous;
+	*_eip = frame.return_address;
+	*_next = (addr_t)frame.previous;
 
-	thread_get_current_thread()-&gt;fault_handler = oldFaultHandler;
 	return B_OK;
+}
 
-error:
-	thread_get_current_thread()-&gt;fault_handler = oldFaultHandler;
-	return B_BAD_ADDRESS;
+
+/*!	Safe to be called only from inside the debugger.
+*/
+static status_t
+get_next_frame_debugger(addr_t ebp, addr_t *_next, addr_t *_eip)
+{
+	stack_frame frame;
+	if (debug_memcpy(&amp;frame, (void*)ebp, sizeof(frame)) != B_OK)
+		return B_BAD_ADDRESS;
+
+	*_eip = frame.return_address;
+	*_next = (addr_t)frame.previous;
+
+	return B_OK;
 }
 
 
@@ -285,8 +295,10 @@
 		kprintf(&quot; + 0x%04lx\n&quot;, eip - baseAddress);
 	} else {
 		vm_area *area = NULL;
-		if (thread-&gt;team-&gt;address_space != NULL)
+		if (thread != NULL &amp;&amp; thread-&gt;team != NULL
+			&amp;&amp; thread-&gt;team-&gt;address_space != NULL) {
 			area = vm_area_lookup(thread-&gt;team-&gt;address_space, eip);
+		}
 		if (area != NULL) {
 			kprintf(&quot;%ld:%s@%p + %#lx\n&quot;, area-&gt;id, area-&gt;name,
 				(void*)area-&gt;base, eip - area-&gt;base);
@@ -358,6 +370,7 @@
 	*_thread = thread;
 }
 
+
 static bool
 is_double_fault_stack_address(int32 cpu, addr_t address)
 {
@@ -564,7 +577,7 @@
 		} else {
 			addr_t eip, nextEbp;
 
-			if (get_next_frame(ebp, &amp;nextEbp, &amp;eip) != B_OK) {
+			if (get_next_frame_debugger(ebp, &amp;nextEbp, &amp;eip) != B_OK) {
 				kprintf(&quot;%08lx -- read fault\n&quot;, ebp);
 				break;
 			}
@@ -723,7 +736,7 @@
 		} else {
 			addr_t eip, nextEbp;
 
-			if (get_next_frame(ebp, &amp;nextEbp, &amp;eip) != B_OK) {
+			if (get_next_frame_debugger(ebp, &amp;nextEbp, &amp;eip) != B_OK) {
 				kprintf(&quot;%08lx -- read fault\n&quot;, ebp);
 				break;
 			}
@@ -894,7 +907,7 @@
 		} else {
 			addr_t eip, nextEbp;
 
-			if (get_next_frame(ebp, &amp;nextEbp, &amp;eip) != B_OK
+			if (get_next_frame_no_debugger(ebp, &amp;nextEbp, &amp;eip) != B_OK
 				|| eip == 0 || ebp == 0)
 				break;
 
@@ -964,7 +977,7 @@
 					skipFrames = 0;
 			}
 		} else {
-			if (get_next_frame(ebp, &amp;nextEbp, &amp;eip) != B_OK)
+			if (get_next_frame_no_debugger(ebp, &amp;nextEbp, &amp;eip) != B_OK)
 				break;
 		}
 
@@ -1000,6 +1013,16 @@
 }
 
 
+/*!	Sets the current thread to \c NULL.
+	Invoked in the kernel debugger only.
+*/
+void
+arch_debug_unset_current_thread(void)
+{
+	write_dr3(NULL);
+}
+
+
 bool
 arch_is_debug_variable_defined(const char* variableName)
 {

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_int.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_int.cpp	2009-08-03 11:54:25 UTC (rev 32072)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_int.cpp	2009-08-03 12:39:56 UTC (rev 32073)
@@ -204,22 +204,27 @@
 
 
 /*!	Initializes the descriptor for interrupt vector \a n in the IDT of the
-	boot CPU to an interrupt-gate descriptor with the given procedure address.
+	specified CPU to an interrupt-gate descriptor with the given procedure
+	address.
+	For CPUs other than the boot CPU it must not be called before
+	arch_int_init_post_vm().
 */
 static void
-set_interrupt_gate(int n, void (*addr)())
+set_interrupt_gate(int32 cpu, int n, void (*addr)())
 {
-	set_gate(&amp;sIDTs[0][n], (addr_t)addr, 14, DPL_KERNEL);
+	set_gate(&amp;sIDTs[cpu][n], (addr_t)addr, 14, DPL_KERNEL);
 }
 
 
 /*!	Initializes the descriptor for interrupt vector \a n in the IDT of the
-	boot CPU to an trap-gate descriptor with the given procedure address.
+	specified CPU to an trap-gate descriptor with the given procedure address.
+	For CPUs other than the boot CPU it must not be called before
+	arch_int_init_post_vm().
 */
 static void
-set_trap_gate(int n, void (*addr)())
+set_trap_gate(int32 cpu, int n, void (*addr)())
 {
-	set_gate(&amp;sIDTs[0][n], (unsigned int)addr, 15, DPL_USER);
+	set_gate(&amp;sIDTs[cpu][n], (unsigned int)addr, 15, DPL_USER);
 }
 
 
@@ -851,27 +856,74 @@
 	frame-&gt;edi = tss-&gt;edi;
 	frame-&gt;flags = tss-&gt;eflags;
 
+	// Use a special handler for page faults which avoids the triple fault
+	// pitfalls.
+	set_interrupt_gate(cpu, 14, &amp;trap14_double_fault);
+
 	debug_double_fault(cpu);
 }
 
 
+void
+x86_page_fault_exception_double_fault(struct iframe* frame)
+{
+	uint32 cr2;
+	asm(&quot;movl %%cr2, %0&quot; : &quot;=r&quot; (cr2));
+
+	// Only if this CPU has a fault handler, we're allowed to be here.
+	cpu_ent&amp; cpu = gCPU[x86_double_fault_get_cpu()];
+	addr_t faultHandler = cpu.fault_handler;
+	if (faultHandler != 0) {
+		debug_set_page_fault_info(cr2, frame-&gt;eip,
+			(frame-&gt;error_code &amp; 0x2) != 0 ? DEBUG_PAGE_FAULT_WRITE : 0);
+		frame-&gt;eip = faultHandler;
+		frame-&gt;ebp = cpu.fault_handler_stack_pointer;
+		return;
+	}
+
+	// No fault handler. This is bad. Since we originally came from a double
+	// fault, we don't try to reenter the kernel debugger. Instead we just
+	// print the info we've got and enter an infinite loop.
+	kprintf(&quot;Page fault in double fault debugger without fault handler! &quot;
+		&quot;Touching address %p from eip %p. Entering infinite loop...\n&quot;,
+		(void*)cr2, (void*)frame-&gt;eip);
+
+	while (true);
+}
+
+
 static void
 page_fault_exception(struct iframe* frame)
 {
 	struct thread *thread = thread_get_current_thread();
-	bool kernelDebugger = debug_debugger_running();
-	unsigned int cr2;
+	uint32 cr2;
 	addr_t newip;
 
 	asm(&quot;movl %%cr2, %0&quot; : &quot;=r&quot; (cr2));
 
-	if (kernelDebugger) {
-		// if this thread has a fault handler, we're allowed to be here
-		if (thread &amp;&amp; thread-&gt;fault_handler != 0) {
-			debug_set_page_fault_info(cr2, frame-&gt;eip,
-				(frame-&gt;error_code &amp; 0x2) != 0 ? DEBUG_PAGE_FAULT_WRITE : 0);
-			frame-&gt;eip = thread-&gt;fault_handler;
-			return;
+	if (debug_debugger_running()) {
+		// If this CPU or this thread has a fault handler, we're allowed to be
+		// here.
+		if (thread != NULL) {
+			cpu_ent* cpu = &amp;gCPU[smp_get_current_cpu()];
+			if (cpu-&gt;fault_handler != 0) {
+				debug_set_page_fault_info(cr2, frame-&gt;eip,
+					(frame-&gt;error_code &amp; 0x2) != 0
+						? DEBUG_PAGE_FAULT_WRITE : 0);
+				frame-&gt;eip = cpu-&gt;fault_handler;
+				frame-&gt;ebp = cpu-&gt;fault_handler_stack_pointer;
+				return;
+			}
+
+			if (thread-&gt;fault_handler != 0) {
+				kprintf(&quot;ERROR: thread::fault_handler used in kernel &quot;
+					&quot;debugger!\n&quot;);
+				debug_set_page_fault_info(cr2, frame-&gt;eip,
+					(frame-&gt;error_code &amp; 0x2) != 0
+						? DEBUG_PAGE_FAULT_WRITE : 0);
+				frame-&gt;eip = thread-&gt;fault_handler;
+				return;
+			}
 		}
 
 		// otherwise, not really
@@ -886,8 +938,16 @@
 		// disabled, which in most cases is a bug. We should add some thread
 		// flag allowing to explicitly indicate that this handling is desired.
 		if (thread &amp;&amp; thread-&gt;fault_handler != 0) {
-			frame-&gt;eip = thread-&gt;fault_handler;
-			return;
+			if (frame-&gt;eip != thread-&gt;fault_handler) {
+				frame-&gt;eip = thread-&gt;fault_handler;
+				return;
+			}
+
+			// The fault happened at the fault handler address. This is a
+			// certain infinite loop.
+			panic(&quot;page fault, interrupts disabled, fault handler loop. &quot;
+				&quot;Touching address %p from eip %p\n&quot;, (void*)cr2,
+				(void*)frame-&gt;eip);
 		}
 
 		// If we are not running the kernel startup the page fault was not
@@ -971,60 +1031,60 @@
 	// setup the standard programmable interrupt controller
 	pic_init();
 
-	set_interrupt_gate(0,  &amp;trap0);
-	set_interrupt_gate(1,  &amp;trap1);
-	set_interrupt_gate(2,  &amp;trap2);
-	set_trap_gate(3,  &amp;trap3);
-	set_interrupt_gate(4,  &amp;trap4);
-	set_interrupt_gate(5,  &amp;trap5);
-	set_interrupt_gate(6,  &amp;trap6);
-	set_interrupt_gate(7,  &amp;trap7);
+	set_interrupt_gate(0, 0,  &amp;trap0);
+	set_interrupt_gate(0, 1,  &amp;trap1);
+	set_interrupt_gate(0, 2,  &amp;trap2);
+	set_trap_gate(0, 3,  &amp;trap3);
+	set_interrupt_gate(0, 4,  &amp;trap4);
+	set_interrupt_gate(0, 5,  &amp;trap5);
+	set_interrupt_gate(0, 6,  &amp;trap6);
+	set_interrupt_gate(0, 7,  &amp;trap7);
 	// trap8 (double fault) is set in arch_cpu.c
-	set_interrupt_gate(9,  &amp;trap9);
-	set_interrupt_gate(10,  &amp;trap10);
-	set_interrupt_gate(11,  &amp;trap11);
-	set_interrupt_gate(12,  &amp;trap12);
-	set_interrupt_gate(13,  &amp;trap13);
-	set_interrupt_gate(14,  &amp;trap14);

[... truncated: 895 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="018685.html">[Haiku-commits] r32072 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
	<LI>Next message: <A HREF="018689.html">[Haiku-commits] r32074 - in haiku/trunk: headers/private/kernel	src/system/kernel
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#18686">[ date ]</a>
              <a href="thread.html#18686">[ thread ]</a>
              <a href="subject.html#18686">[ subject ]</a>
              <a href="author.html#18686">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
