<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21137 - in haiku/trunk/src/apps/cortex: .	DiagramView MediaRoutingView RouteApp ValControl
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21137%20-%20in%20haiku/trunk/src/apps/cortex%3A%20.%0A%09DiagramView%20MediaRoutingView%20RouteApp%20ValControl&In-Reply-To=%3C200705141415.l4EEFaQf002373%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002295.html">
   <LINK REL="Next"  HREF="002294.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21137 - in haiku/trunk/src/apps/cortex: .	DiagramView MediaRoutingView RouteApp ValControl</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21137%20-%20in%20haiku/trunk/src/apps/cortex%3A%20.%0A%09DiagramView%20MediaRoutingView%20RouteApp%20ValControl&In-Reply-To=%3C200705141415.l4EEFaQf002373%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21137 - in haiku/trunk/src/apps/cortex: .	DiagramView MediaRoutingView RouteApp ValControl">axeld at mail.berlios.de
       </A><BR>
    <I>Mon May 14 16:15:36 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002295.html">[Haiku-commits] r21130 - in haiku/trunk/src/preferences: keyboard keymap mouse virtualmemory
</A></li>
        <LI>Next message: <A HREF="002294.html">[Haiku-commits] r21138 - in haiku/trunk/src: apps/powerstatus	preferences/joysticks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2292">[ date ]</a>
              <a href="thread.html#2292">[ thread ]</a>
              <a href="subject.html#2292">[ subject ]</a>
              <a href="author.html#2292">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-05-14 16:15:34 +0200 (Mon, 14 May 2007)
New Revision: 21137
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21137&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21137&amp;view=rev</A>

Modified:
   haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.cpp
   haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.h
   haiku/trunk/src/apps/cortex/DiagramView/DiagramItemGroup.cpp
   haiku/trunk/src/apps/cortex/DiagramView/DiagramItemGroup.h
   haiku/trunk/src/apps/cortex/DiagramView/DiagramView.cpp
   haiku/trunk/src/apps/cortex/DiagramView/DiagramView.h
   haiku/trunk/src/apps/cortex/DiagramView/DiagramWire.cpp
   haiku/trunk/src/apps/cortex/MediaRoutingView/MediaNodePanel.cpp
   haiku/trunk/src/apps/cortex/MediaRoutingView/MediaRoutingView.cpp
   haiku/trunk/src/apps/cortex/RouteApp/RouteApp.cpp
   haiku/trunk/src/apps/cortex/ValControl/NumericValControl.cpp
   haiku/trunk/src/apps/cortex/ValControl/ValControl.cpp
   haiku/trunk/src/apps/cortex/ValControl/ValControl.h
   haiku/trunk/src/apps/cortex/ValControl/ValControlSegment.cpp
   haiku/trunk/src/apps/cortex/ValControl/ValControlSegment.h
   haiku/trunk/src/apps/cortex/cortex_defs.h
Log:
Next row of Cortex style updates, courtesy of Vasilis Kaoutsis - thanks!


Modified: haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.cpp
===================================================================
--- haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.cpp	2007-05-14 02:37:14 UTC (rev 21136)
+++ haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.cpp	2007-05-14 14:15:34 UTC (rev 21137)
@@ -39,11 +39,11 @@
 
 // derived from DiagramItemGroup (public)
 bool
-DiagramBox::addItem(DiagramItem *item)
+DiagramBox::AddItem(DiagramItem *item)
 {
-	D_METHOD((&quot;DiagramBox::addItem()\n&quot;));
+	D_METHOD((&quot;DiagramBox::AddItem()\n&quot;));
 	if (item) {
-		if (DiagramItemGroup::addItem(item)) {
+		if (DiagramItemGroup::AddItem(item)) {
 			if (m_view) {
 				item-&gt;_setOwner(m_view);
 				item-&gt;attachedToDiagram();
@@ -56,12 +56,12 @@
 
 
 bool
-DiagramBox::removeItem(DiagramItem *item)
+DiagramBox::RemoveItem(DiagramItem *item)
 {
-	D_METHOD((&quot;DiagramBox::removeItem()\n&quot;));
+	D_METHOD((&quot;DiagramBox::RemoveItem()\n&quot;));
 	if (item) {
 		item-&gt;detachedFromDiagram();
-		if (DiagramItemGroup::removeItem(item)) {
+		if (DiagramItemGroup::RemoveItem(item)) {
 			item-&gt;_setOwner(0);
 			return true;
 		}
@@ -81,22 +81,22 @@
 			if (m_flags &amp; M_DRAW_UNDER_ENDPOINTS) {
 				BRegion region, clipping;
 				region.Include(frame());
-				if (group()-&gt;getClippingAbove(this, &amp;clipping))
+				if (group()-&gt;GetClippingAbove(this, &amp;clipping))
 					region.Exclude(&amp;clipping);
 				view()-&gt;ConstrainClippingRegion(&amp;region);
 				drawBox();
-				for (uint32 i = 0; i &lt; countItems(); i++) {
-					DiagramItem *item = itemAt(i);
+				for (uint32 i = 0; i &lt; CountItems(); i++) {
+					DiagramItem *item = ItemAt(i);
 					if (region.Intersects(item-&gt;frame()))
 						item-&gt;draw(item-&gt;frame());
 				}
 			} else {
 				BRegion region, clipping;
 				region.Include(frame());
-				if (view()-&gt;getClippingAbove(this, &amp;clipping))
+				if (view()-&gt;GetClippingAbove(this, &amp;clipping))
 					region.Exclude(&amp;clipping);
-				for (uint32 i = 0; i &lt; countItems(); i++) {
-					DiagramItem *item = itemAt(i);
+				for (uint32 i = 0; i &lt; CountItems(); i++) {
+					DiagramItem *item = ItemAt(i);
 					BRect r;
 					if (region.Intersects(r = item-&gt;frame())) {
 						item-&gt;draw(r);
@@ -116,7 +116,7 @@
 DiagramBox::mouseDown(BPoint point, uint32 buttons, uint32 clicks)
 {
 	D_MOUSE((&quot;DiagramBox::mouseDown()\n&quot;));
-	DiagramItem *item = itemUnder(point);
+	DiagramItem *item = ItemUnder(point);
 	if (item)
 		item-&gt;mouseDown(point, buttons, clicks);
 	else if (clicks == 1) {
@@ -144,12 +144,12 @@
 DiagramBox::mouseOver(BPoint point, uint32 transit)
 {
 	D_MOUSE((&quot;DiagramBox::mouseOver()\n&quot;));
-	DiagramItem *last = lastItemUnder();
+	DiagramItem *last = _LastItemUnder();
 	if (last &amp;&amp; (transit == B_EXITED_VIEW)) {
 		last-&gt;mouseOver(point, B_EXITED_VIEW);
-		resetItemUnder();
+		_ResetItemUnder();
 	} else {
-		DiagramItem *item = itemUnder(point);
+		DiagramItem *item = ItemUnder(point);
 		if (item) {
 			if (item != last) {
 				if (last)
@@ -168,12 +168,12 @@
 DiagramBox::messageDragged(BPoint point, uint32 transit, const BMessage *message)
 {
 	D_MOUSE((&quot;DiagramBox::messageDragged()\n&quot;));
-	DiagramItem *last = lastItemUnder();
+	DiagramItem *last = _LastItemUnder();
 	if (last &amp;&amp; (transit == B_EXITED_VIEW)) {
 		last-&gt;messageDragged(point, B_EXITED_VIEW, message);
-		resetItemUnder();
+		_ResetItemUnder();
 	} else {
-		DiagramItem *item = itemUnder(point);
+		DiagramItem *item = ItemUnder(point);
 		if (item) {
 			if (item != last) {
 				if (last)
@@ -194,7 +194,7 @@
 DiagramBox::messageDropped(BPoint point, BMessage *message)
 {
 	D_METHOD((&quot;DiagramBox::messageDropped()\n&quot;));
-	DiagramItem *item = itemUnder(point);
+	DiagramItem *item = ItemUnder(point);
 	if (item) {
 		item-&gt;messageDropped(point, message);
 		return;
@@ -210,8 +210,8 @@
 	if (view()) {
 		view()-&gt;PushState();
 		{
-			for (uint32 i = 0; i &lt; countItems(); i++) {
-				DiagramEndPoint *endPoint = dynamic_cast&lt;DiagramEndPoint *&gt;(itemAt(i));
+			for (uint32 i = 0; i &lt; CountItems(); i++) {
+				DiagramEndPoint *endPoint = dynamic_cast&lt;DiagramEndPoint *&gt;(ItemAt(i));
 				if (endPoint)
 					endPoint-&gt;moveBy(x, y, wireRegion);
 			}
@@ -243,8 +243,8 @@
 {
 	D_METHOD((&quot;DiagramBox::_setOwner()\n&quot;));
 	m_view = owner;
-	for (uint32 i = 0; i &lt; countItems(DiagramItem::M_ENDPOINT); i++) {
-		DiagramItem *item = itemAt(i);
+	for (uint32 i = 0; i &lt; CountItems(DiagramItem::M_ENDPOINT); i++) {
+		DiagramItem *item = ItemAt(i);
 		item-&gt;_setOwner(m_view);
 		if (m_view)
 			item-&gt;attachedToDiagram();

Modified: haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.h
===================================================================
--- haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.h	2007-05-14 02:37:14 UTC (rev 21136)
+++ haiku/trunk/src/apps/cortex/DiagramView/DiagramBox.h	2007-05-14 14:15:34 UTC (rev 21137)
@@ -42,11 +42,11 @@
 		// extends the DiagramItemGroup implementation by setting
 		// the items owner and calling the attachedToDiagram() hook
 		// on it
-		virtual bool addItem(DiagramItem *item);
+		virtual bool AddItem(DiagramItem *item);
 
 		// extends the DiagramItemGroup implementation by calling 
 		// the detachedToDiagram() hook on the item
-		virtual bool removeItem(DiagramItem *item);
+		virtual bool RemoveItem(DiagramItem *item);
 
 	public:	// derived from DiagramItem
 

Modified: haiku/trunk/src/apps/cortex/DiagramView/DiagramItemGroup.cpp
===================================================================
--- haiku/trunk/src/apps/cortex/DiagramView/DiagramItemGroup.cpp	2007-05-14 02:37:14 UTC (rev 21136)
+++ haiku/trunk/src/apps/cortex/DiagramView/DiagramItemGroup.cpp	2007-05-14 14:15:34 UTC (rev 21137)
@@ -1,5 +1,13 @@
 // DiagramItemGroup.cpp
 
+/*! \class DiagramItemGroup.
+	\brief Basic class for managing and accessing DiagramItem objects.
+
+	Objects of this class can manage one or more of the DiagramItem
+	type M_BOX, M_WIRE and M_ENDPOINT. Many methods let you specify
+	which type of item you want to deal with.	
+*/
+
 #include &quot;DiagramItemGroup.h&quot;
 #include &quot;DiagramItem.h&quot;
 
@@ -10,397 +18,341 @@
 #include &lt;Debug.h&gt;
 #define D_METHOD(x) //PRINT (x)
 
-// -------------------------------------------------------- //
-// *** ctor/dtor
-// -------------------------------------------------------- //
 
-DiagramItemGroup::DiagramItemGroup(
-	uint32 acceptedTypes,
-	bool multiSelection)
-	: m_boxes(0),
-	  m_wires(0),
-	  m_endPoints(0),
-	  m_selection(0),
-	  m_types(acceptedTypes),
-	  m_itemAlignment(1.0, 1.0),
-	  m_multiSelection(multiSelection),
-	  m_lastItemUnder(0)
+DiagramItemGroup::DiagramItemGroup(uint32 acceptedTypes, bool multiSelection)
+	: fBoxes(0),
+	fWires(0),
+	fEndPoints(0),
+	fSelection(0),
+	fTypes(acceptedTypes),
+	fItemAlignment(1.0, 1.0),
+	fMultiSelection(multiSelection),
+	fLastItemUnder(0)
 {
 	D_METHOD((&quot;DiagramItemGroup::DiagramItemGroup()\n&quot;));
-	m_selection = new BList(1);
+	fSelection = new BList(1);
 }
 
+
 DiagramItemGroup::~DiagramItemGroup()
 {
 	D_METHOD((&quot;DiagramItemGroup::~DiagramItemGroup()\n&quot;));
-	if (m_selection)
-	{
-		m_selection-&gt;MakeEmpty();
-		delete m_selection;
+	if (fSelection) {
+		fSelection-&gt;MakeEmpty();
+		delete fSelection;
 	}
-	if (m_boxes &amp;&amp; (m_types &amp; DiagramItem::M_BOX))
-	{
-		while (countItems(DiagramItem::M_BOX) &gt; 0)
-		{
-			DiagramItem *item = itemAt(0, DiagramItem::M_BOX);
-			if (removeItem(item))
+
+	if (fBoxes &amp;&amp; (fTypes &amp; DiagramItem::M_BOX)) {
+		while (CountItems(DiagramItem::M_BOX) &gt; 0) {
+			DiagramItem *item = ItemAt(0, DiagramItem::M_BOX);
+			if (RemoveItem(item))
 				delete item;
 		}
-		delete m_boxes;
+		delete fBoxes;
 	}
-	if (m_wires &amp;&amp; (m_types &amp; DiagramItem::M_WIRE))
-	{
-		while (countItems(DiagramItem::M_WIRE) &gt; 0)
-		{
-			DiagramItem *item = itemAt(0, DiagramItem::M_WIRE);
-			if (removeItem(item))
+
+	if (fWires &amp;&amp; (fTypes &amp; DiagramItem::M_WIRE)) {
+		while (CountItems(DiagramItem::M_WIRE) &gt; 0) {
+			DiagramItem *item = ItemAt(0, DiagramItem::M_WIRE);
+			if (RemoveItem(item))
 				delete item;
 		}
-		delete m_wires;
+		delete fWires;
 	}
-	if (m_endPoints &amp;&amp; (m_types &amp; DiagramItem::M_ENDPOINT))
-	{
-		while (countItems(DiagramItem::M_ENDPOINT) &gt; 0)
-		{
-			DiagramItem *item = itemAt(0, DiagramItem::M_ENDPOINT);
-			if (removeItem(item))
+
+	if (fEndPoints &amp;&amp; (fTypes &amp; DiagramItem::M_ENDPOINT)) {
+		while (CountItems(DiagramItem::M_ENDPOINT) &gt; 0) {
+			DiagramItem *item = ItemAt(0, DiagramItem::M_ENDPOINT);
+			if (RemoveItem(item))
 				delete item;
 		}
-		delete m_endPoints;
+		delete fEndPoints;
 	}
 }
 
-// -------------------------------------------------------- //
-// *** item accessors
-// -------------------------------------------------------- //
 
-uint32 DiagramItemGroup::countItems(
-	uint32 whichType) const
+//	#pragma mark - item accessors
+
+
+//! Returns the number of items in the group (optionally only those
+//	of the given type \param whichType)
+uint32
+DiagramItemGroup::CountItems(uint32 whichType) const
 {
-	D_METHOD((&quot;DiagramItemGroup::countItems()\n&quot;));
+	D_METHOD((&quot;DiagramItemGroup::CountItems()\n&quot;));
 	uint32 count = 0;
-	if (whichType &amp; m_types)
-	{
-		if (whichType &amp; DiagramItem::M_BOX)
-		{
-			if (m_boxes)
-			{
-				count += m_boxes-&gt;CountItems();
-			}
+	if (whichType &amp; fTypes) {
+		if (whichType &amp; DiagramItem::M_BOX) {
+			if (fBoxes)
+				count += fBoxes-&gt;CountItems();
+
 		}
-		if (whichType &amp; DiagramItem::M_WIRE)
-		{
-			if (m_wires)
-			{
-				count += m_wires-&gt;CountItems();
-			}
+
+		if (whichType &amp; DiagramItem::M_WIRE) {
+			if (fWires)
+				count += fWires-&gt;CountItems();
 		}
-		if (whichType &amp; DiagramItem::M_ENDPOINT)
-		{
-			if (m_endPoints)
-			{
-				count += m_endPoints-&gt;CountItems();
-			}
+
+		if (whichType &amp; DiagramItem::M_ENDPOINT) {
+			if (fEndPoints)
+				count += fEndPoints-&gt;CountItems();
 		}
 	}
+
 	return count;
 }
 
-DiagramItem *DiagramItemGroup::itemAt(
-	uint32 index,
-	uint32 whichType) const
+
+/*! Returns a pointer to the item in the lists which is
+	at the given index; if none is found, this function
+	returns 0
+*/
+DiagramItem*
+DiagramItemGroup::ItemAt(uint32 index, uint32 whichType) const
 {
-	D_METHOD((&quot;DiagramItemGroup::itemAt()\n&quot;));
-	if (m_types &amp; whichType)
-	{
-		if (whichType &amp; DiagramItem::M_BOX)
-		{
-			if (m_boxes &amp;&amp; (index &lt; countItems(DiagramItem::M_BOX)))
-			{
-				return static_cast&lt;DiagramItem *&gt;(m_boxes-&gt;ItemAt(index));
-			}
+	D_METHOD((&quot;DiagramItemGroup::ItemAt()\n&quot;));
+	if (fTypes &amp; whichType) {
+		if (whichType &amp; DiagramItem::M_BOX) {
+			if (fBoxes &amp;&amp; (index &lt; CountItems(DiagramItem::M_BOX)))
+				return static_cast&lt;DiagramItem *&gt;(fBoxes-&gt;ItemAt(index));
 			else
-			{
-				index -= countItems(DiagramItem::M_BOX);
-			}
+				index -= CountItems(DiagramItem::M_BOX);
 		}
-		if (whichType &amp; DiagramItem::M_WIRE)
-		{
-			if (m_wires &amp;&amp; (index &lt; countItems(DiagramItem::M_WIRE)))
-			{
-				return static_cast&lt;DiagramItem *&gt;(m_wires-&gt;ItemAt(index));
-			}
+
+		if (whichType &amp; DiagramItem::M_WIRE) {
+			if (fWires &amp;&amp; (index &lt; CountItems(DiagramItem::M_WIRE)))
+				return static_cast&lt;DiagramItem *&gt;(fWires-&gt;ItemAt(index));
 			else
-			{
-				index -= countItems(DiagramItem::M_WIRE);
-			}
+				index -= CountItems(DiagramItem::M_WIRE);
 		}
-		if (whichType &amp; DiagramItem::M_ENDPOINT)
-		{
-			if (m_endPoints &amp;&amp; (index &lt; countItems(DiagramItem::M_ENDPOINT)))
-			{
-				return static_cast&lt;DiagramItem *&gt;(m_endPoints-&gt;ItemAt(index));
-			}
+
+		if (whichType &amp; DiagramItem::M_ENDPOINT) {
+			if (fEndPoints &amp;&amp; (index &lt; CountItems(DiagramItem::M_ENDPOINT)))
+				return static_cast&lt;DiagramItem *&gt;(fEndPoints-&gt;ItemAt(index));
 		}
 	}
+
 	return 0;
 }
 
-// This function returns the first box or endpoint found that
-// contains the given point. For connections it looks at all
-// wires that 'might' contain the point and calls their method
-// howCloseTo() to find the one closest to the point.
-// The lists should be sorted by selection time for proper results!
-DiagramItem *DiagramItemGroup::itemUnder(
-	BPoint point)
+
+/*! This function returns the first box or endpoint found that
+	contains the given \param point. For connections it looks at all
+	wires that 'might' contain the point and calls their method
+	howCloseTo() to find the one closest to the point.
+	The lists should be sorted by selection time for proper results!
+*/
+DiagramItem*
+DiagramItemGroup::ItemUnder(BPoint point)
 {
-	D_METHOD((&quot;DiagramItemGroup::itemUnder()\n&quot;));
-	if (m_types &amp; DiagramItem::M_BOX)
-	{
-		for (uint32 i = 0; i &lt; countItems(DiagramItem::M_BOX); i++)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_BOX);
-			if (item-&gt;frame().Contains(point) &amp;&amp; (item-&gt;howCloseTo(point) == 1.0))
-			{
-//				DiagramItemGroup *group = dynamic_cast&lt;DiagramItemGroup *&gt;(item);
-				return (m_lastItemUnder = item);
+	D_METHOD((&quot;DiagramItemGroup::ItemUnder()\n&quot;));
+	if (fTypes &amp; DiagramItem::M_BOX) {
+		for (uint32 i = 0; i &lt; CountItems(DiagramItem::M_BOX); i++) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_BOX);
+			if (item-&gt;frame().Contains(point) &amp;&amp; (item-&gt;howCloseTo(point) == 1.0)) {
+				// DiagramItemGroup *group = dynamic_cast&lt;DiagramItemGroup *&gt;(item);
+				return (fLastItemUnder = item);
 			}
 		}
 	}
-	if (m_types &amp; DiagramItem::M_WIRE)
-	{
+
+	if (fTypes &amp; DiagramItem::M_WIRE) {
 		float closest = 0.0;
 		DiagramItem *closestItem = 0;
-		for (uint32 i = 0; i &lt; countItems(DiagramItem::M_WIRE); i++)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_WIRE);
-			if (item-&gt;frame().Contains(point))
-			{
+		for (uint32 i = 0; i &lt; CountItems(DiagramItem::M_WIRE); i++) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_WIRE);
+			if (item-&gt;frame().Contains(point)) {
 				float howClose = item-&gt;howCloseTo(point);
-				if (howClose &gt; closest)
-				{
+				if (howClose &gt; closest) {
 					closestItem = item;
 					if (howClose == 1.0)
-						return (m_lastItemUnder = item);
+						return (fLastItemUnder = item);
 					closest = howClose;
 				}
 			}
 		}
+
 		if (closest &gt; 0.5)
-		{
-			return (m_lastItemUnder = closestItem);
-		}
+			return (fLastItemUnder = closestItem);
 	}
-	if (m_types &amp; DiagramItem::M_ENDPOINT)
-	{
-		for (uint32 i = 0; i &lt; countItems(DiagramItem::M_ENDPOINT); i++)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_ENDPOINT);
+
+	if (fTypes &amp; DiagramItem::M_ENDPOINT) {
+		for (uint32 i = 0; i &lt; CountItems(DiagramItem::M_ENDPOINT); i++) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_ENDPOINT);
 			if (item-&gt;frame().Contains(point) &amp;&amp; (item-&gt;howCloseTo(point) == 1.0))
-			{
-				return (m_lastItemUnder = item);
-			}
+				return (fLastItemUnder = item);
 		}
 	}
-	return (m_lastItemUnder = 0); // no item was found!
+
+	return (fLastItemUnder = 0); // no item was found!
 }
 
-// -------------------------------------------------------- //
-// *** item operations
-// -------------------------------------------------------- //
 
-bool DiagramItemGroup::addItem(
-	DiagramItem *item)
+//	#pragma mark - item operations
+
+
+//! Adds an \param item to the group; returns true on success.
+bool
+DiagramItemGroup::AddItem(DiagramItem *item)
 {
-	D_METHOD((&quot;DiagramItemGroup::addItem()\n&quot;));
-	if (item &amp;&amp; (m_types &amp; item-&gt;type()))
-	{
-		switch (item-&gt;type())
-		{
+	D_METHOD((&quot;DiagramItemGroup::AddItem()\n&quot;));
+	if (item &amp;&amp; (fTypes &amp; item-&gt;type())) {
+		switch (item-&gt;type()) {
 			case DiagramItem::M_BOX:
-			{
-				if (!m_boxes)
-				{
-					m_boxes = new BList();
-				}
+				if (!fBoxes)
+					fBoxes = new BList();
 				item-&gt;m_group = this;
-				return m_boxes-&gt;AddItem(static_cast&lt;void *&gt;(item));
-			}
+				return fBoxes-&gt;AddItem(static_cast&lt;void *&gt;(item));
+
 			case DiagramItem::M_WIRE:
-			{
-				if (!m_wires)
-				{
-					m_wires = new BList();
-				}
+				if (!fWires)
+					fWires = new BList();
 				item-&gt;m_group = this;
-				return m_wires-&gt;AddItem(static_cast&lt;void *&gt;(item));
-			}
+				return fWires-&gt;AddItem(static_cast&lt;void *&gt;(item));
+
 			case DiagramItem::M_ENDPOINT:
-			{
-				if (!m_endPoints)
-				{
-					m_endPoints = new BList();
-				}
+				if (!fEndPoints)
+					fEndPoints = new BList();
 				item-&gt;m_group = this;
-				return m_endPoints-&gt;AddItem(static_cast&lt;void *&gt;(item));
-			}
+				return fEndPoints-&gt;AddItem(static_cast&lt;void *&gt;(item));
 		}
 	}
+
 	return false;
 }
 
-bool DiagramItemGroup::removeItem(
-	DiagramItem *item)
+
+//! Removes an \param item from the group; returns true on success.
+bool
+DiagramItemGroup::RemoveItem(DiagramItem* item)
 {
-	D_METHOD((&quot;DiagramItemGroup::removeItem()\n&quot;));
-	if (item &amp;&amp; (m_types &amp; item-&gt;type()))
-	{
+	D_METHOD((&quot;DiagramItemGroup::RemoveItem()\n&quot;));
+	if (item &amp;&amp; (fTypes &amp; item-&gt;type())) {
 		// reset the lastItemUnder-pointer if it pointed to this item
-		if (m_lastItemUnder == item)
-		{
-			m_lastItemUnder = 0;
-		}
+		if (fLastItemUnder == item)
+			fLastItemUnder = 0;
+
 		// remove it from the selection list if it was selected
 		if (item-&gt;isSelected())
-		{
-			m_selection-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
-		}
+			fSelection-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
+
 		// try to remove the item from its list
-		switch (item-&gt;type())
-		{
+		switch (item-&gt;type()) {
 			case DiagramItem::M_BOX:
-			{
-				if (m_boxes)
-				{
+				if (fBoxes) {
 					item-&gt;m_group = 0;
-					return m_boxes-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
+					return fBoxes-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
 				}
-			}
+				break;
+
 			case DiagramItem::M_WIRE:
-			{
-				if (m_wires)
-				{
+				if (fWires) {
 					item-&gt;m_group = 0;
-					return m_wires-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
+					return fWires-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
 				}
-			}
+				break;
+
 			case DiagramItem::M_ENDPOINT:
-			{
-				if (m_endPoints)
-				{
+				if (fEndPoints) {
 					item-&gt;m_group = 0;
-					return m_endPoints-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
+					return fEndPoints-&gt;RemoveItem(static_cast&lt;void *&gt;(item));
 				}
-			}
 		}
 	}
+
 	return false;
 }
 
-void DiagramItemGroup::sortItems(
-	uint32 whichType,
+
+/*! Performs a quicksort on a list of items with the provided
+	compare function (one is already defined in the DiagramItem
+	implementation); can't handle more than one item type at a
+	time!
+*/
+void
+DiagramItemGroup::SortItems(uint32 whichType,
 	int (*compareFunc)(const void *, const void *))
 {
-	D_METHOD((&quot;DiagramItemGroup::sortItems()\n&quot;));
-	if ((whichType != DiagramItem::M_ANY) &amp;&amp; (m_types &amp; whichType))
-	{
-		switch (whichType)
-		{
+	D_METHOD((&quot;DiagramItemGroup::SortItems()\n&quot;));
+	if ((whichType != DiagramItem::M_ANY) &amp;&amp; (fTypes &amp; whichType)) {
+		switch (whichType) {
 			case DiagramItem::M_BOX:
-			{
-				if (m_boxes)
-				{
-					m_boxes-&gt;SortItems(compareFunc);
-				}
+				if (fBoxes)
+					fBoxes-&gt;SortItems(compareFunc);
 				break;
-			}
+
 			case DiagramItem::M_WIRE:
-			{
-				if (m_wires)
-				{
-					m_wires-&gt;SortItems(compareFunc);
-				}
+				if (fWires)
+					fWires-&gt;SortItems(compareFunc);
 				break;
-			}
+
 			case DiagramItem::M_ENDPOINT:
-			{
-				if (m_endPoints)
-				{
-					m_endPoints-&gt;SortItems(compareFunc);
-				}
+				if (fEndPoints)
+					fEndPoints-&gt;SortItems(compareFunc);
 				break;
-			}
 		}
 	}
 }
 
-// items are drawn in reverse order; they should be sorted by
-// selection time before this function gets called, so that
-// the more recently selected item are drawn above others
-void DiagramItemGroup::drawItems(
-	BRect updateRect,
-	uint32 whichType,
-	BRegion *updateRegion)
+
+/*! Fires a draw() command at all items of a specific type that
+	intersect with the \param updateRect;
+	items are drawn in reverse order; they should be sorted by
+	selection time before this function gets called, so that
+	the more recently selected item are drawn above others.
+*/
+void
+DiagramItemGroup::DrawItems(BRect updateRect, uint32 whichType, BRegion* updateRegion)
 {
-	D_METHOD((&quot;DiagramItemGroup::drawItems()\n&quot;));
-	if (whichType &amp; DiagramItem::M_WIRE)
-	{
-		for (int32 i = countItems(DiagramItem::M_WIRE) - 1; i &gt;= 0; i--)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_WIRE);
+	D_METHOD((&quot;DiagramItemGroup::DrawItems()\n&quot;));
+	if (whichType &amp; DiagramItem::M_WIRE) {
+		for (int32 i = CountItems(DiagramItem::M_WIRE) - 1; i &gt;= 0; i--) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_WIRE);
 			if (item-&gt;frame().Intersects(updateRect))
-			{	
 				item-&gt;draw(updateRect);
-			}
 		}
 	}
-	if (whichType &amp; DiagramItem::M_BOX)
-	{
-		for (int32 i = countItems(DiagramItem::M_BOX) - 1; i &gt;= 0; i--)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_BOX);
-			if (item &amp;&amp; item-&gt;frame().Intersects(updateRect))
-			{	
+
+	if (whichType &amp; DiagramItem::M_BOX) {
+		for (int32 i = CountItems(DiagramItem::M_BOX) - 1; i &gt;= 0; i--) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_BOX);
+			if (item &amp;&amp; item-&gt;frame().Intersects(updateRect)) {	
 				item-&gt;draw(updateRect);
 				if (updateRegion)
 					updateRegion-&gt;Exclude(item-&gt;frame());
 			}
 		}
 	}
-	if (whichType &amp; DiagramItem::M_ENDPOINT)
-	{
-		for (int32 i = countItems(DiagramItem::M_ENDPOINT) - 1; i &gt;= 0; i--)
-		{
-			DiagramItem *item = itemAt(i, DiagramItem::M_ENDPOINT);
+
+	if (whichType &amp; DiagramItem::M_ENDPOINT) {
+		for (int32 i = CountItems(DiagramItem::M_ENDPOINT) - 1; i &gt;= 0; i--) {
+			DiagramItem *item = ItemAt(i, DiagramItem::M_ENDPOINT);
 			if (item &amp;&amp; item-&gt;frame().Intersects(updateRect))
-			{	
 				item-&gt;draw(updateRect);
-			}
 		}
 	}
 }
 
-bool DiagramItemGroup::getClippingAbove(
-	DiagramItem *which,
-	BRegion *region)
+
+/*!	Returns in outRegion the \param region of items that lay &quot;over&quot; the given
+	DiagramItem in \param which; returns false if no items are above or the item
+	doesn't exist.
+*/
+bool
+DiagramItemGroup::GetClippingAbove(DiagramItem *which, BRegion *region)
 {
-	D_METHOD((&quot;DiagramItemGroup::getClippingAbove()\n&quot;));
+	D_METHOD((&quot;DiagramItemGroup::GetClippingAbove()\n&quot;));
 	bool found = false;
-	if (which &amp;&amp; region)
-	{
-		switch (which-&gt;type())
-		{
+	if (which &amp;&amp; region) {
+		switch (which-&gt;type()) {
 			case DiagramItem::M_BOX:
 			{
-				int32 index = m_boxes-&gt;IndexOf(which);
-				if (index &gt;= 0) // the item was found
-				{
+				int32 index = fBoxes-&gt;IndexOf(which);
+				if (index &gt;= 0) { // the item was found
 					BRect r = which-&gt;frame();
-					for (int32 i = 0; i &lt; index; i++)
-					{
-						DiagramItem *item = itemAt(i, DiagramItem::M_BOX);
-						if (item &amp;&amp; item-&gt;frame().Intersects(r))
-						{
+					for (int32 i = 0; i &lt; index; i++) {
+						DiagramItem *item = ItemAt(i, DiagramItem::M_BOX);
+						if (item &amp;&amp; item-&gt;frame().Intersects(r)) {
 							region-&gt;Include(item-&gt;frame() &amp; r);
 							found = true;
 						}
@@ -408,14 +360,13 @@
 				}
 				break;
 			}
+
 			case DiagramItem::M_WIRE:
 			{
 				BRect r = which-&gt;frame();
-				for (uint32 i = 0; i &lt; countItems(DiagramItem::M_BOX); i++)
-				{
-					DiagramItem *item = itemAt(i, DiagramItem::M_BOX);
-					if (item &amp;&amp; item-&gt;frame().Intersects(r))
-					{
+				for (uint32 i = 0; i &lt; CountItems(DiagramItem::M_BOX); i++) {
+					DiagramItem *item = ItemAt(i, DiagramItem::M_BOX);
+					if (item &amp;&amp; item-&gt;frame().Intersects(r)) {
 						region-&gt;Include(item-&gt;frame() &amp; r);
 						found = true;
 					}
@@ -424,219 +375,227 @@
 			}
 		}
 	}
+
 	return found;
 }
 
-// -------------------------------------------------------- //
-// *** selection accessors
-// -------------------------------------------------------- //
 
-uint32 DiagramItemGroup::selectedType() const
+//	#pragma mark - selection accessors
+
+
+/*!	Returns the type of DiagramItems in the current selection
+	(currently only one type at a time is supported!)
+*/
+uint32
+DiagramItemGroup::SelectedType() const
 {
-	D_METHOD((&quot;DiagramItemGroup::selectedType()\n&quot;));
-	if (countSelectedItems() &gt; 0)
-	{
-		return selectedItemAt(0)-&gt;type();
-	}
+	D_METHOD((&quot;DiagramItemGroup::SelectedType()\n&quot;));
+	if (CountSelectedItems() &gt; 0)
+		return SelectedItemAt(0)-&gt;type();
+
 	return 0;
 }
 
-uint32 DiagramItemGroup::countSelectedItems() const
+
+//!	Returns the number of items in the current selection
+uint32
+DiagramItemGroup::CountSelectedItems() const
 {
-	D_METHOD((&quot;DiagramItemGroup::countSelectedItems()\n&quot;));
-	if (m_selection)
-	{
-		return m_selection-&gt;CountItems();
-	}
+	D_METHOD((&quot;DiagramItemGroup::CountSelectedItems()\n&quot;));
+	if (fSelection)
+		return fSelection-&gt;CountItems();
+
 	return 0;
 }
 
-DiagramItem *DiagramItemGroup::selectedItemAt(
-	uint32 index) const
+
+/*!	Returns a pointer to the item in the list which is
+	at the given \param index; if none is found, this function
+	returns 0
+*/
+DiagramItem*
+DiagramItemGroup::SelectedItemAt(uint32 index) const
 {
-	D_METHOD((&quot;DiagramItemGroup::selectedItemAt()\n&quot;));
-	if (m_selection)
-	{
-		return static_cast&lt;DiagramItem *&gt;(m_selection-&gt;ItemAt(index));
-	}
+	D_METHOD((&quot;DiagramItemGroup::SelectedItemAt()\n&quot;));
+	if (fSelection)
+		return static_cast&lt;DiagramItem *&gt;(fSelection-&gt;ItemAt(index));
+
 	return 0;
 }
 
-// -------------------------------------------------------- //
-// *** selection related operations
-// -------------------------------------------------------- //
 
-// selects an item, optionally replacing the complete former
-// selection. If the type of the item to be selected differs
-// from the type of items currently selected, this methods
-// automatically replaces the former selection
-bool DiagramItemGroup::selectItem(
-	DiagramItem *which,
-	bool deselectOthers)
+//	#pragma mark - selection related operations
+
+
+/*!	Selects an item, optionally replacing the complete former
+	selection. If the type of the item to be selected differs
+	from the type of items currently selected, this methods
+	automatically replaces the former selection
+*/
+bool
+DiagramItemGroup::SelectItem(DiagramItem* which, bool deselectOthers)
 {
-	D_METHOD((&quot;DiagramItemGroup::selectItem()\n&quot;));
+	D_METHOD((&quot;DiagramItemGroup::SelectItem()\n&quot;));
 	bool selectionChanged = false;
-	if (which &amp;&amp; !which-&gt;isSelected() &amp;&amp; which-&gt;isSelectable())
-	{
+	if (which &amp;&amp; !which-&gt;isSelected() &amp;&amp; which-&gt;isSelectable()) {
 		// check if the item's type is the same as of the other
 		// selected items
-		if (m_multiSelection)
-		{
-			if (which-&gt;type() != selectedType())
-			{
+		if (fMultiSelection) {
+			if (which-&gt;type() != SelectedType())
 				deselectOthers = true;
-			}
 		}
 
 		// check if the former selection has to be deselected
-		if (deselectOthers || !m_multiSelection)
-		{
-			while (countSelectedItems() &gt; 0)
-			{
-				deselectItem(selectedItemAt(0));
-			}
+		if (deselectOthers || !fMultiSelection) {
+			while (CountSelectedItems() &gt; 0)
+				DeselectItem(SelectedItemAt(0));
 		}
 
 		// select the item
-		if (deselectOthers || countSelectedItems() == 0)
-		{
+		if (deselectOthers || CountSelectedItems() == 0)
 			which-&gt;select();
-		}
 		else
-		{
 			which-&gt;selectAdding();
-		}
-		m_selection-&gt;AddItem(which);
+
+		fSelection-&gt;AddItem(which);
 		selectionChanged = true;
 	}
 
 	// resort the lists if necessary
-	if (selectionChanged)
-	{
-		sortItems(which-&gt;type(), compareSelectionTime);
-		sortSelectedItems(compareSelectionTime);
+	if (selectionChanged) {
+		SortItems(which-&gt;type(), compareSelectionTime);
+		SortSelectedItems(compareSelectionTime);
 		return true;
 	}
+
 	return false;
 }
 
-bool DiagramItemGroup::deselectItem(
-	DiagramItem *which)
+
+//!	Simply deselects one item
+bool
+DiagramItemGroup::DeselectItem(DiagramItem* which)
 {
-	D_METHOD((&quot;DiagramItemGroup::deselectItem()\n&quot;));
-	if (which &amp;&amp; which-&gt;isSelected())
-	{
-		m_selection-&gt;RemoveItem(which);
+	D_METHOD((&quot;DiagramItemGroup::DeselectItem()\n&quot;));
+	if (which &amp;&amp; which-&gt;isSelected()) {
+		fSelection-&gt;RemoveItem(which);
 		which-&gt;deselect();
-		sortItems(which-&gt;type(), compareSelectionTime);
-		sortSelectedItems(compareSelectionTime);
+		SortItems(which-&gt;type(), compareSelectionTime);
+		SortSelectedItems(compareSelectionTime);
 		return true;
 	}
+
 	return false;
 }
 
-bool DiagramItemGroup::selectAll(
-	uint32 itemType)
+
+//! Selects all items of the given \param itemType
+bool
+DiagramItemGroup::SelectAll(uint32 itemType)
 {
-	D_METHOD((&quot;DiagramItemGroup::selectAll()\n&quot;));
+	D_METHOD((&quot;DiagramItemGroup::SelectAll()\n&quot;));
 	bool selectionChanged = false;
-	if (m_types &amp; itemType)
-	{
-		for (int32 i = 0; i &lt; countItems(itemType); i++)
-		{
-			if (selectItem(itemAt(i, itemType), false))
+	if (fTypes &amp; itemType) {
+		for (uint32 i = 0; i &lt; CountItems(itemType); i++) {
+			if (SelectItem(ItemAt(i, itemType), false))
 				selectionChanged = true;

[... truncated: 3663 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002295.html">[Haiku-commits] r21130 - in haiku/trunk/src/preferences: keyboard keymap mouse virtualmemory
</A></li>
	<LI>Next message: <A HREF="002294.html">[Haiku-commits] r21138 - in haiku/trunk/src: apps/powerstatus	preferences/joysticks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2292">[ date ]</a>
              <a href="thread.html#2292">[ thread ]</a>
              <a href="subject.html#2292">[ subject ]</a>
              <a href="author.html#2292">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
