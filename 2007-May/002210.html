<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21087 - in	haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000: .	dev dev/em
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21087%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000%3A%20.%0A%09dev%20dev/em&In-Reply-To=%3C200705091320.l49DKfZC022103%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002209.html">
   <LINK REL="Next"  HREF="002212.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21087 - in	haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000: .	dev dev/em</H1>
    <B>hugosantos at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21087%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000%3A%20.%0A%09dev%20dev/em&In-Reply-To=%3C200705091320.l49DKfZC022103%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21087 - in	haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000: .	dev dev/em">hugosantos at mail.berlios.de
       </A><BR>
    <I>Wed May  9 15:20:41 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002209.html">[Haiku-commits] r21086 - haiku/trunk/src/documentation
</A></li>
        <LI>Next message: <A HREF="002212.html">[Haiku-commits] r21087 - in	haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000: .	dev dev/em
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2210">[ date ]</a>
              <a href="thread.html#2210">[ thread ]</a>
              <a href="subject.html#2210">[ subject ]</a>
              <a href="author.html#2210">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hugosantos
Date: 2007-05-09 15:20:14 +0200 (Wed, 09 May 2007)
New Revision: 21087
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21087&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21087&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/LICENSE
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/README
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em.h
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em_hw.c
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em_hw.h
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em_osdep.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/Jamfile
Log:
added FreeBSD 6.2's Intel Pro 1000 driver to the tree (original source, unchanged).


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/Jamfile	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/Jamfile	2007-05-09 13:20:14 UTC (rev 21087)
@@ -1,5 +1,7 @@
 SubDir HAIKU_TOP src add-ons kernel drivers network ipro1000 ;
 
+SubInclude HAIKU_TOP src add-ons kernel drivers network ipro1000 dev ;
+
 SetSubDirSupportedPlatformsBeOSCompatible ;
 
 # set some additional flags

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/Jamfile	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/Jamfile	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network ipro1000 dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network ipro1000 dev em ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/Jamfile	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/Jamfile	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,18 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network ipro1000 dev em ;
+
+SubDirCcFlags -Wall ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 EM_FAST_INTR=1 DBG=1 ] ;
+
+KernelAddon e1000 :
+	if_em.c
+	if_em_hw.c
+	glue.c
+	: libfreebsd_network.a
+	;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/LICENSE
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/LICENSE	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/LICENSE	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,31 @@
+$FreeBSD: src/sys/dev/em/LICENSE,v 1.3.2.1 2006/08/08 09:20:26 glebius Exp $
+/*-
+Copyright (c) 2001-2005, Intel Corporation 
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without 
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice, 
+    this list of conditions and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright 
+    notice, this list of conditions and the following disclaimer in the 
+    documentation and/or other materials provided with the distribution.
+
+ 3. Neither the name of the Intel Corporation nor the names of its 
+    contributors may be used to endorse or promote products derived from 
+    this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+*/

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/README
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/README	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/README	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,373 @@
+$FreeBSD: src/sys/dev/em/README,v 1.10.2.1 2006/08/08 09:20:26 glebius Exp $
+FreeBSD* Driver for the Intel(R) PRO/1000 Family of Adapters
+============================================================
+
+May 2, 2006
+
+
+Contents
+========
+
+- Overview
+- Identifying Your Adapter
+- Building and Installation
+- Speed and Duplex Configuration
+- Additional Configurations
+- Known Limitations
+- Support
+- License
+
+
+Overview
+========
+
+This file describes the FreeBSD* driver for the Intel(R) PRO/1000 Family of
+Adapters. This driver has been developed for use with FreeBSD, Release 6.x.
+
+For questions related to hardware requirements, refer to the documentation
+supplied with your Intel PRO/1000 adapter. All hardware requirements listed
+apply to use with FreeBSD.
+
+
+Identifying Your Adapter
+========================
+
+For information on how to identify your adapter, go to the Adapter &amp;
+Driver ID Guide at:
+
+<A HREF="http://support.intel.com/support/network/sb/cs-012904.htm">http://support.intel.com/support/network/sb/cs-012904.htm</A>
+
+
+For the latest Intel network drivers for FreeBSD, see:
+
+<A HREF="http://downloadfinder.intel.com/scripts-df-external/support_intel.aspx">http://downloadfinder.intel.com/scripts-df-external/support_intel.aspx</A>
+
+
+NOTE: Mobile adapters are not fully supported.
+NOTE: The Intel(R) 82562v 10/100 Network Connection only provides 10/100
+support.
+
+Building and Installation
+=========================
+
+NOTE: The driver can be installed as a dynamic loadable kernel module or
+      compiled into the kernel. You must have kernel sources installed in
+      order to compile the driver module.
+
+In the instructions below, x.x.x is the driver version as indicated in the
+name of the driver tar file.
+
+1. Move the base driver tar file to the directory of your choice. For
+   example, use /home/username/em or /usr/local/src/em.
+
+2. Untar/unzip the archive:
+
+        tar xvfz em-x.x.x.tar.gz
+
+   This will create an em-x.x.x directory.
+
+3. To create a loadable module, perform the following steps.
+   NOTE: To compile the driver into the kernel, go directly to step 4.
+
+        a. To compile the module
+
+                  cd em-x.x.x
+                  make
+
+        b. To install the compiled module in system directory:
+
+                  make install
+
+        c. If you want the driver to load automatically when the system is booted:
+
+              1. Edit /boot/loader.conf, and add the following line:
+
+                  if_em_load=&quot;YES&quot;
+
+4. To compile the driver into the kernel:
+
+        cd em-x.x.x/src
+
+        cp if_em* /usr/src/sys/dev/em
+
+        cp Makefile.kernel /usr/src/sys/modules/em/Makefile
+
+   Edit the /usr/src/sys/conf/files file, and add the following lines only if
+   they don't already exist:
+
+        dev/em/if_em.c optional em
+
+        dev/em/if_em_hw.c optional em
+
+   Remove the following lines from the /usr/src/sys/conf/files file,
+   if they exist:
+
+        dev/em/if_em_fxhw.c optional em
+        dev/em/if_em_phy.c optional em
+
+   Edit the kernel configuration file (i.e., GENERIC or MYKERNEL) in
+   /usr/src/sys/i386/conf, and ensure the following line is present:
+
+        device em
+
+   Compile and install the kernel. The system must be rebooted for the kernel
+   updates to take effect. For additional information on compiling the
+   kernel, consult the FreeBSD operating system documentation.
+
+5. To assign an IP address to the interface, enter the following:
+
+        ifconfig em&lt;interface_num&gt; &lt;IP_address&gt;
+
+6. Verify that the interface works. Enter the following, where &lt;IP_address&gt;
+   is the IP address for another machine on the same subnet as the interface
+   that is being tested:
+
+        ping &lt;IP_address&gt;
+
+7. To configure the IP address to remain after reboot, edit /etc/rc.conf,
+   and create the appropriate ifconfig_em&lt;interface_num&gt;entry:
+
+        ifconfig_em&lt;interface_num&gt;=&quot;&lt;ifconfig_settings&gt;&quot;
+
+   Example usage:
+
+        ifconfig_em0=&quot;inet 192.168.10.1 netmask 255.255.255.0&quot;
+
+   NOTE: For assistance, see the ifconfig man page.
+
+
+Speed and Duplex Configuration
+==============================
+
+By default, the adapter auto-negotiates the speed and duplex of the
+connection. If there is a specific need, the ifconfig utility can be used to
+configure the speed and duplex settings on the adapter. Example usage:
+
+        ifconfig em&lt;interface_num&gt; &lt;IP_address&gt; media 100baseTX mediaopt
+            full-duplex
+
+   NOTE: Only use mediaopt to set the driver to full-duplex. If mediaopt is
+         not specified and you are not running at gigabit speed, the driver
+         defaults to half-duplex.
+
+
+This driver supports the following media type options:
+
+   autoselect      -  Enables auto-negotiation for speed and duplex.
+
+   10baseT/UTP     -  Sets speed to 10 Mbps. Use the ifconfig mediaopt
+                      option to select full-duplex mode.
+
+   100baseTX       -  Sets speed to 100 Mbps. Use the ifconfig mediaopt
+                      option to select full-duplex mode.
+
+   1000baseTX      -  Sets speed to 1000 Mbps. In this case, the driver
+                      supports only full-duplex mode.
+
+   1000baseSX      -  Sets speed to 1000 Mbps. In this case, the driver
+                      supports only full-duplex mode.
+
+For more information on the ifconfig utility, see the ifconfig man page.
+
+
+Additional Configurations
+=========================
+
+The driver supports Transmit/Receive Checksum Offload and Jumbo Frames on
+all but the 82542-based adapters.  For specific adapters, refer to the
+Identifying Your Adapter section.
+
+  Jumbo Frames
+  ------------
+  To enable Jumbo Frames, use the ifconfig utility to set the Maximum
+  Transport Unit (MTU) frame size above its default of 1500 bytes.
+
+  The Jumbo Frames MTU range for Intel Adapters is 1500 to 16110. To modify
+  the setting, enter the following:
+
+        ifconfig em&lt;interface_num&gt; &lt;hostname or IP address&gt; mtu 9000
+
+  To confirm the MTU used between two specific devices, use:
+
+        route get &lt;destination_IP_address&gt;
+
+  Notes:
+
+  - Only enable Jumbo Frames if your network infrastructure supports them.
+
+  - To enable Jumbo Frames, increase the MTU size on the interface beyond
+    1500.
+
+  - The Jumbo Frames setting on the switch must be set to at least 22 bytes
+    larger than that of the MTU.
+
+  - The maximum MTU setting for Jumbo Frames is 16110.  This value coincides
+    with the maximum Jumbo Frames size of 16128.
+
+  - Some Intel gigabit adapters that support Jumbo Frames have a frame size
+    limit of 9238 bytes, with a corresponding MTU size limit of 9216 bytes.
+    The adapters with this limitation are based on the Intel(R) 82571EB,
+    82572EI, 82573L and 80003ES2LAN controller.  These correspond to the
+    following product names:
+     Intel(R) PRO/1000 PT Server Adapter
+     Intel(R) PRO/1000 PT Desktop Adapter
+     Intel(R) PRO/1000 PT Network Connection
+     Intel(R) PRO/1000 PT Dual Port Server Adapter
+     Intel(R) PRO/1000 PT Dual Port Network Connection
+     Intel(R) PRO/1000 PF Server Adapter
+     Intel(R) PRO/1000 PF Network Connection
+     Intel(R) PRO/1000 PF Dual Port Server Adapter
+     Intel(R) PRO/1000 PB Server Connection
+     Intel(R) PRO/1000 PL Network Connection
+     Intel(R) PRO/1000 EB Network Connection with I/O Acceleration
+     Intel(R) PRO/1000 EB Backplane Connection with I/O Acceleration
+
+  - Adapters based on the Intel(R) 82542 and 82573V/E controller do not
+    support Jumbo Frames. These correspond to the following product names:
+     Intel(R) PRO/1000 Gigabit Server Adapter
+     Intel(R) PRO/1000 PM Network Connection
+
+  - Using Jumbo Frames at 10 or 100 Mbps may result in poor performance or
+    loss of link.
+
+  - The following adapters do not support Jumbo Frames:
+    Intel(R) 82562V 10/100 Network Connection
+    Intel(R) 82566DM Gigabit Network Connection
+    Intel(R) 82566DC Gigabit Network Connection
+    Intel(R) 82566MM Gigabit Network Connection
+    Intel(R) 82566MC Gigabit Network Connection
+
+
+  VLANs
+  -----
+  To create a new VLAN interface:
+
+        ifconfig &lt;vlan_name&gt; create
+
+  To associate the VLAN interface with a physical interface and
+  assign a VLAN ID, IP address, and netmask:
+
+        ifconfig &lt;vlan_name&gt; &lt;ip_address&gt; netmask &lt;subnet_mask&gt; vlan
+           &lt;vlan_id&gt; vlandev &lt;physical_interface&gt;
+
+  Example:
+
+        ifconfig vlan10 10.0.0.1 netmask 255.255.255.0 vlan10 vlandev em0
+
+  In this example, all packets will be marked on egress with  802.1Q VLAN
+  tags, specifying a VLAN ID of 10.
+
+  To remove a VLAN interface:
+
+        ifconfig &lt;vlan_name&gt; destroy
+
+
+  Polling
+  -------
+  To enable polling in the driver, add the following options to the kernel
+  configuration, and then recompile the kernel:
+
+        options DEVICE_POLLING
+        options HZ=1000
+
+  At runtime use:
+        ifconfig em0 polling to turn polling on
+  Use:
+        ifconfig em0 -polling to turn polling off
+
+
+  Checksum Offload
+  ----------------
+  Checksum offloading is not supported on 82542 Gigabit adapters.
+
+  Checksum offloading supports both TCP and UDP packets and is
+  supported for both transmit and receive.
+
+  Checksum offloading can be enabled or disabled using ifconfig.
+  Both transmit and receive offloading will be either enabled or
+  disabled together. You cannot enable/disable one without the other.
+
+  To enable checksum offloading:
+
+         ifconfig &lt;interface_num&gt; rxcsum
+
+  To disable checksum offloading:
+
+         ifconfig &lt;interface_num&gt; -rxcsum
+
+  To confirm the current setting:
+
+         ifconfig &lt;interface_num&gt;
+
+  Look for the presence or absence of the following line:
+
+         options=3 &lt;RXCSUM,TXCSUM&gt;
+
+  See the ifconfig man page for further information.
+
+
+Known Limitations
+=================
+
+  In FreeBSD version 4.x with Symmetric MultiProcessing (SMP), there is a known
+  issue on some newer hardware.  The problem is generic kernel and only in SMP
+  mode.  The workaround is to either use FreeBSD version 4.x in single processor
+  mode, or use FreeBSD 5.4 or later.
+
+  There are known performance issues with this driver when running UDP traffic
+  with Jumbo Frames.
+
+  There is a known compatibility issue where time to link is slow or link is not
+  established between 82541/82547 controllers and some switches.  Known switches
+  include:
+        Planex FXG-08TE
+        I-O Data ETG-SH8
+
+  The driver can be compiled with the following changes:
+
+  Edit ./em.x.x.x/src/if_em.h to uncomment the #define EM_MASTER_SLAVE
+  from within the comments.  For example, change from:
+
+      /* #define EM_MASTER_SLAVE  2 */
+  to:
+      #define EM_MASTER_SLAVE  2
+
+  Use one of the following options:
+      1 = Master mode
+      2 = Slave mode
+      3 = Auto master/slave
+  Setting 2 is recommended.
+
+  Recompile the module:
+          a. To compile the module
+                cd em-x.x.x
+                make clean
+                make
+
+   b. To install the compiled module in system directory:
+                make install
+
+
+Support
+=======
+
+For general information and support, go to the Intel support website at:
+
+        <A HREF="http://support.intel.com">http://support.intel.com</A>
+
+If an issue is identified, support is through email only at:
<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">+freebsdnic at mailbox.intel.com</A>
+
+
+License
+=======
+
+This software program is released under the terms of a license agreement
+between you ('Licensee') and Intel. Do not use or load this software or any
+associated materials (collectively, the 'Software') until you have carefully
+read the full terms and conditions of the LICENSE located in this software
+package. By loading or using the Software, you agree to the terms of this
+Agreement. If you do not agree with the terms of this Agreement, do not
+install or use the Software.
+
+* Other names and brands may be claimed as the property of others.

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/glue.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/glue.c	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/glue.c	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,11 @@
+#include &lt;sys/bus.h&gt;
+
+HAIKU_FBSD_DRIVER_GLUE(e1000, em, pci)
+
+NO_HAIKU_CHECK_DISABLE_INTERRUPTS()
+
+#ifdef EM_FAST_INTR
+	HAIKU_DRIVER_REQUIREMENTS(FBSD_TASKQUEUES | FBSD_FAST_TASKQUEUE);
+#else
+	HAIKU_DRIVER_REQUIREMENTS(0);
+#endif

Added: haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em.c	2007-05-09 13:17:19 UTC (rev 21086)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000/dev/em/if_em.c	2007-05-09 13:20:14 UTC (rev 21087)
@@ -0,0 +1,4167 @@
+/**************************************************************************
+
+Copyright (c) 2001-2006, Intel Corporation
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+ 1. Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+ 3. Neither the name of the Intel Corporation nor the names of its
+    contributors may be used to endorse or promote products derived from
+    this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+/*$FreeBSD: src/sys/dev/em/if_em.c,v 1.65.2.21 2006/11/10 09:30:27 jfv Exp $*/
+
+#ifdef HAVE_KERNEL_OPTION_HEADERS
+#include &quot;opt_device_polling.h&quot;
+#endif
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/bus.h&gt;
+#include &lt;sys/endian.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/kthread.h&gt;
+#include &lt;sys/malloc.h&gt;
+#include &lt;sys/mbuf.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/rman.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/sockio.h&gt;
+#include &lt;sys/sysctl.h&gt;
+#include &lt;sys/taskqueue.h&gt;
+
+#include &lt;machine/bus.h&gt;
+#include &lt;machine/resource.h&gt;
+
+#include &lt;net/bpf.h&gt;
+#include &lt;net/ethernet.h&gt;
+#include &lt;net/if.h&gt;
+#include &lt;net/if_arp.h&gt;
+#include &lt;net/if_dl.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;net/if_types.h&gt;
+#include &lt;net/if_vlan_var.h&gt;
+
+#include &lt;netinet/in_systm.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;netinet/if_ether.h&gt;
+#include &lt;netinet/ip.h&gt;
+#include &lt;netinet/tcp.h&gt;
+#include &lt;netinet/udp.h&gt;
+
+#include &lt;machine/in_cksum.h&gt;
+
+#include &lt;dev/pci/pcivar.h&gt;
+#include &lt;dev/pci/pcireg.h&gt;
+#include &lt;dev/em/if_em_hw.h&gt;
+#include &lt;dev/em/if_em.h&gt;
+
+/*********************************************************************
+ *  Set this to one to display debug statistics
+ *********************************************************************/
+int	em_display_debug_stats = 0;
+
+/*********************************************************************
+ *  Driver version
+ *********************************************************************/
+char em_driver_version[] = &quot;Version - 6.2.9&quot;;
+
+
+/*********************************************************************
+ *  PCI Device ID Table
+ *
+ *  Used by probe to select devices to load on
+ *  Last field stores an index into em_strings
+ *  Last entry must be all 0s
+ *
+ *  { Vendor ID, Device ID, SubVendor ID, SubDevice ID, String Index }
+ *********************************************************************/
+
+static em_vendor_info_t em_vendor_info_array[] =
+{
+	/* Intel(R) PRO/1000 Network Connection */
+	{ 0x8086, E1000_DEV_ID_82540EM,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82540EM_LOM,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82540EP,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82540EP_LOM,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82540EP_LP,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82541EI,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541ER,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541ER_LOM,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541EI_MOBILE,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541GI,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541GI_LF,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82541GI_MOBILE,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82542,		PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82543GC_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82543GC_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82544EI_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82544EI_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82544GC_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82544GC_LOM,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82545EM_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82545EM_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82545GM_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82545GM_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82545GM_SERDES,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82546EB_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546EB_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546EB_QUAD_COPPER, PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_SERDES,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_PCIE,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_QUAD_COPPER, PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82547EI,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82547EI_MOBILE,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82547GI,		PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82571EB_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82571EB_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82571EB_SERDES,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82571EB_QUAD_COPPER,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82571EB_QUAD_COPPER_LOWPROFILE,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82572EI_COPPER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82572EI_FIBER,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82572EI_SERDES,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82572EI,		PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	{ 0x8086, E1000_DEV_ID_82573E,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82573E_IAMT,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_82573L,		PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_80003ES2LAN_COPPER_SPT,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_80003ES2LAN_SERDES_SPT,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_80003ES2LAN_COPPER_DPT,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_80003ES2LAN_SERDES_DPT,
+						PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IGP_M_AMT,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IGP_AMT,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IGP_C,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IFE,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IFE_GT,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IFE_G,	PCI_ANY_ID, PCI_ANY_ID, 0},
+	{ 0x8086, E1000_DEV_ID_ICH8_IGP_M,	PCI_ANY_ID, PCI_ANY_ID, 0},
+
+	/* required last entry */
+	{ 0, 0, 0, 0, 0}
+};
+
+/*********************************************************************
+ *  Table of branding strings for all supported NICs.
+ *********************************************************************/
+
+static char *em_strings[] = {
+	&quot;Intel(R) PRO/1000 Network Connection&quot;
+};
+
+/*********************************************************************
+ *  Function prototypes
+ *********************************************************************/
+static int	em_probe(device_t);
+static int	em_attach(device_t);
+static int	em_detach(device_t);
+static int	em_shutdown(device_t);
+static int	em_suspend(device_t);
+static int	em_resume(device_t);
+static void	em_start(struct ifnet *);
+static void	em_start_locked(struct ifnet *ifp);
+static int	em_ioctl(struct ifnet *, u_long, caddr_t);
+static void	em_watchdog(struct adapter *);
+static void	em_init(void *);
+static void	em_init_locked(struct adapter *);
+static void	em_stop(void *);
+static void	em_media_status(struct ifnet *, struct ifmediareq *);
+static int	em_media_change(struct ifnet *);
+static void	em_identify_hardware(struct adapter *);
+static int	em_allocate_pci_resources(struct adapter *);
+static int	em_allocate_intr(struct adapter *);
+static void	em_free_intr(struct adapter *);
+static void	em_free_pci_resources(struct adapter *);
+static void	em_local_timer(void *);
+static int	em_hardware_init(struct adapter *);
+static void	em_setup_interface(device_t, struct adapter *);
+static void	em_setup_transmit_structures(struct adapter *);
+static void	em_initialize_transmit_unit(struct adapter *);
+static int	em_setup_receive_structures(struct adapter *);
+static void	em_initialize_receive_unit(struct adapter *);
+static void	em_enable_intr(struct adapter *);
+static void	em_disable_intr(struct adapter *);
+static void	em_free_transmit_structures(struct adapter *);
+static void	em_free_receive_structures(struct adapter *);
+static void	em_update_stats_counters(struct adapter *);
+static void	em_txeof(struct adapter *);
+static int	em_allocate_receive_structures(struct adapter *);
+static int	em_allocate_transmit_structures(struct adapter *);
+static int	em_rxeof(struct adapter *, int);
+#ifndef __NO_STRICT_ALIGNMENT
+static int	em_fixup_rx(struct adapter *);
+#endif
+static void	em_receive_checksum(struct adapter *, struct em_rx_desc *,
+		    struct mbuf *);
+static void	em_transmit_checksum_setup(struct adapter *, struct mbuf *,
+		    uint32_t *, uint32_t *);
+#ifdef EM_TSO
+static boolean_t em_tso_setup(struct adapter *, struct mbuf *, u_int32_t *,
+		    uint32_t *);
+#endif
+static void	em_set_promisc(struct adapter *);
+static void	em_disable_promisc(struct adapter *);
+static void	em_set_multi(struct adapter *);
+static void	em_print_hw_stats(struct adapter *);
+static void	em_update_link_status(struct adapter *);
+static int	em_get_buf(int i, struct adapter *, struct mbuf *);
+static void	em_enable_vlans(struct adapter *);
+static void	em_disable_vlans(struct adapter *);
+static int	em_encap(struct adapter *, struct mbuf **);
+static void	em_smartspeed(struct adapter *);
+static int	em_82547_fifo_workaround(struct adapter *, int);
+static void	em_82547_update_fifo_head(struct adapter *, int);
+static int	em_82547_tx_fifo_reset(struct adapter *);
+static void	em_82547_move_tail(void *);
+static int	em_dma_malloc(struct adapter *, bus_size_t,
+		struct em_dma_alloc *, int);
+static void	em_dma_free(struct adapter *, struct em_dma_alloc *);
+static void	em_print_debug_info(struct adapter *);
+static int 	em_is_valid_ether_addr(uint8_t *);
+static int	em_sysctl_stats(SYSCTL_HANDLER_ARGS);
+static int	em_sysctl_debug_info(SYSCTL_HANDLER_ARGS);
+static uint32_t	em_fill_descriptors (bus_addr_t address, uint32_t length,
+		    PDESC_ARRAY desc_array);
+static int	em_sysctl_int_delay(SYSCTL_HANDLER_ARGS);
+static void	em_add_int_delay_sysctl(struct adapter *, const char *,
+		const char *, struct em_int_delay_info *, int, int);
+static void	em_add_rx_process_limit(struct adapter *, const char *,
+		const char *, int *, int);
+#ifdef EM_FAST_INTR
+static void	em_intr_fast(void *);
+static void	em_handle_rxtx(void *context, int pending);
+static void	em_handle_link(void *context, int pending);
+#else /* Legacy Interrupt Handling */
+static void	em_intr(void *);
+#ifdef DEVICE_POLLING
+static poll_handler_t em_poll;
+#endif /* DEVICE_POLLING */
+#endif /* EM_FAST_INTR */
+
+/*********************************************************************
+ *  FreeBSD Device Interface Entry Points
+ *********************************************************************/
+
+static device_method_t em_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe, em_probe),
+	DEVMETHOD(device_attach, em_attach),
+	DEVMETHOD(device_detach, em_detach),
+	DEVMETHOD(device_shutdown, em_shutdown),
+	DEVMETHOD(device_suspend, em_suspend),
+	DEVMETHOD(device_resume, em_resume),
+	{0, 0}
+};
+
+static driver_t em_driver = {
+	&quot;em&quot;, em_methods, sizeof(struct adapter),
+};
+
+static devclass_t em_devclass;
+DRIVER_MODULE(em, pci, em_driver, em_devclass, 0, 0);
+MODULE_DEPEND(em, pci, 1, 1, 1);
+MODULE_DEPEND(em, ether, 1, 1, 1);
+
+/*********************************************************************
+ *  Tunable default values.
+ *********************************************************************/
+
+#define E1000_TICKS_TO_USECS(ticks)	((1024 * (ticks) + 500) / 1000)
+#define E1000_USECS_TO_TICKS(usecs)	((1000 * (usecs) + 512) / 1024)
+#define M_TSO_LEN		66  /* mbuf with just hdr and TSO pkthdr */
+
+static int em_tx_int_delay_dflt = E1000_TICKS_TO_USECS(EM_TIDV);
+static int em_rx_int_delay_dflt = E1000_TICKS_TO_USECS(EM_RDTR);
+static int em_tx_abs_int_delay_dflt = E1000_TICKS_TO_USECS(EM_TADV);
+static int em_rx_abs_int_delay_dflt = E1000_TICKS_TO_USECS(EM_RADV);
+static int em_rxd = EM_DEFAULT_RXD;
+static int em_txd = EM_DEFAULT_TXD;
+static int em_smart_pwr_down = FALSE;
+
+TUNABLE_INT(&quot;hw.em.tx_int_delay&quot;, &amp;em_tx_int_delay_dflt);
+TUNABLE_INT(&quot;hw.em.rx_int_delay&quot;, &amp;em_rx_int_delay_dflt);
+TUNABLE_INT(&quot;hw.em.tx_abs_int_delay&quot;, &amp;em_tx_abs_int_delay_dflt);
+TUNABLE_INT(&quot;hw.em.rx_abs_int_delay&quot;, &amp;em_rx_abs_int_delay_dflt);
+TUNABLE_INT(&quot;hw.em.rxd&quot;, &amp;em_rxd);
+TUNABLE_INT(&quot;hw.em.txd&quot;, &amp;em_txd);
+TUNABLE_INT(&quot;hw.em.smart_pwr_down&quot;, &amp;em_smart_pwr_down);
+
+/* How many packets rxeof tries to clean at a time */
+static int em_rx_process_limit = 100;
+TUNABLE_INT(&quot;hw.em.rx_process_limit&quot;, &amp;em_rx_process_limit);
+
+/*********************************************************************
+ *  Device identification routine
+ *
+ *  em_probe determines if the driver should be loaded on
+ *  adapter based on PCI vendor/device id of the adapter.
+ *
+ *  return BUS_PROBE_DEFAULT on success, positive on failure
+ *********************************************************************/
+
+static int
+em_probe(device_t dev)
+{
+	char		adapter_name[60];
+	uint16_t	pci_vendor_id = 0;
+	uint16_t	pci_device_id = 0;
+	uint16_t	pci_subvendor_id = 0;
+	uint16_t	pci_subdevice_id = 0;
+	em_vendor_info_t *ent;
+
+	INIT_DEBUGOUT(&quot;em_probe: begin&quot;);
+
+	pci_vendor_id = pci_get_vendor(dev);
+	if (pci_vendor_id != EM_VENDOR_ID)
+		return (ENXIO);
+
+	pci_device_id = pci_get_device(dev);
+	pci_subvendor_id = pci_get_subvendor(dev);
+	pci_subdevice_id = pci_get_subdevice(dev);
+
+	ent = em_vendor_info_array;
+	while (ent-&gt;vendor_id != 0) {
+		if ((pci_vendor_id == ent-&gt;vendor_id) &amp;&amp;
+		    (pci_device_id == ent-&gt;device_id) &amp;&amp;
+
+		    ((pci_subvendor_id == ent-&gt;subvendor_id) ||
+		    (ent-&gt;subvendor_id == PCI_ANY_ID)) &amp;&amp;
+
+		    ((pci_subdevice_id == ent-&gt;subdevice_id) ||
+		    (ent-&gt;subdevice_id == PCI_ANY_ID))) {
+			sprintf(adapter_name, &quot;%s %s&quot;,
+				em_strings[ent-&gt;index],
+				em_driver_version);
+			device_set_desc_copy(dev, adapter_name);
+			return (BUS_PROBE_DEFAULT);
+		}
+		ent++;
+	}
+
+	return (ENXIO);
+}
+
+/*********************************************************************
+ *  Device initialization routine
+ *
+ *  The attach entry point is called when the driver is being loaded.
+ *  This routine identifies the type of hardware, allocates all resources
+ *  and initializes the hardware.
+ *
+ *  return 0 on success, positive on failure
+ *********************************************************************/
+
+static int
+em_attach(device_t dev)
+{
+	struct adapter	*adapter;
+	int		tsize, rsize;
+	int		error = 0;
+
+	INIT_DEBUGOUT(&quot;em_attach: begin&quot;);
+
+	adapter = device_get_softc(dev);
+	adapter-&gt;dev = adapter-&gt;osdep.dev = dev;
+	EM_LOCK_INIT(adapter, device_get_nameunit(dev));
+
+	/* SYSCTL stuff */
+	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;debug_info&quot;, CTLTYPE_INT|CTLFLAG_RW, adapter, 0,
+	    em_sysctl_debug_info, &quot;I&quot;, &quot;Debug Information&quot;);
+
+	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;stats&quot;, CTLTYPE_INT|CTLFLAG_RW, adapter, 0,
+	    em_sysctl_stats, &quot;I&quot;, &quot;Statistics&quot;);
+
+	callout_init_mtx(&amp;adapter-&gt;timer, &amp;adapter-&gt;mtx, 0);
+	callout_init_mtx(&amp;adapter-&gt;tx_fifo_timer, &amp;adapter-&gt;mtx, 0);
+
+	/* Determine hardware revision */
+	em_identify_hardware(adapter);
+
+	/* Set up some sysctls for the tunable interrupt delays */
+	em_add_int_delay_sysctl(adapter, &quot;rx_int_delay&quot;,
+	    &quot;receive interrupt delay in usecs&quot;, &amp;adapter-&gt;rx_int_delay,
+	    E1000_REG_OFFSET(&amp;adapter-&gt;hw, RDTR), em_rx_int_delay_dflt);
+	em_add_int_delay_sysctl(adapter, &quot;tx_int_delay&quot;,
+	    &quot;transmit interrupt delay in usecs&quot;, &amp;adapter-&gt;tx_int_delay,
+	    E1000_REG_OFFSET(&amp;adapter-&gt;hw, TIDV), em_tx_int_delay_dflt);
+	if (adapter-&gt;hw.mac_type &gt;= em_82540) {
+		em_add_int_delay_sysctl(adapter, &quot;rx_abs_int_delay&quot;,
+		    &quot;receive interrupt delay limit in usecs&quot;,
+		    &amp;adapter-&gt;rx_abs_int_delay,
+		    E1000_REG_OFFSET(&amp;adapter-&gt;hw, RADV),
+		    em_rx_abs_int_delay_dflt);
+		em_add_int_delay_sysctl(adapter, &quot;tx_abs_int_delay&quot;,
+		    &quot;transmit interrupt delay limit in usecs&quot;,
+		    &amp;adapter-&gt;tx_abs_int_delay,
+		    E1000_REG_OFFSET(&amp;adapter-&gt;hw, TADV),
+		    em_tx_abs_int_delay_dflt);
+	}
+
+	/* Sysctls for limiting the amount of work done in the taskqueue */
+	em_add_rx_process_limit(adapter, &quot;rx_processing_limit&quot;,
+	    &quot;max number of rx packets to process&quot;, &amp;adapter-&gt;rx_process_limit,
+	    em_rx_process_limit);
+
+	/*
+	 * Validate number of transmit and receive descriptors. It
+	 * must not exceed hardware maximum, and must be multiple
+	 * of EM_DBA_ALIGN.
+	 */
+	if (((em_txd * sizeof(struct em_tx_desc)) % EM_DBA_ALIGN) != 0 ||
+	    (adapter-&gt;hw.mac_type &gt;= em_82544 &amp;&amp; em_txd &gt; EM_MAX_TXD) ||
+	    (adapter-&gt;hw.mac_type &lt; em_82544 &amp;&amp; em_txd &gt; EM_MAX_TXD_82543) ||
+	    (em_txd &lt; EM_MIN_TXD)) {
+		device_printf(dev, &quot;Using %d TX descriptors instead of %d!\n&quot;,
+		    EM_DEFAULT_TXD, em_txd);
+		adapter-&gt;num_tx_desc = EM_DEFAULT_TXD;
+	} else
+		adapter-&gt;num_tx_desc = em_txd;
+	if (((em_rxd * sizeof(struct em_rx_desc)) % EM_DBA_ALIGN) != 0 ||
+	    (adapter-&gt;hw.mac_type &gt;= em_82544 &amp;&amp; em_rxd &gt; EM_MAX_RXD) ||
+	    (adapter-&gt;hw.mac_type &lt; em_82544 &amp;&amp; em_rxd &gt; EM_MAX_RXD_82543) ||
+	    (em_rxd &lt; EM_MIN_RXD)) {
+		device_printf(dev, &quot;Using %d RX descriptors instead of %d!\n&quot;,
+		    EM_DEFAULT_RXD, em_rxd);
+		adapter-&gt;num_rx_desc = EM_DEFAULT_RXD;
+	} else
+		adapter-&gt;num_rx_desc = em_rxd;
+
+	adapter-&gt;hw.autoneg = DO_AUTO_NEG;
+	adapter-&gt;hw.wait_autoneg_complete = WAIT_FOR_AUTO_NEG_DEFAULT;
+	adapter-&gt;hw.autoneg_advertised = AUTONEG_ADV_DEFAULT;
+	adapter-&gt;hw.tbi_compatibility_en = TRUE;
+	adapter-&gt;rx_buffer_len = EM_RXBUFFER_2048;
+
+	adapter-&gt;hw.phy_init_script = 1;
+	adapter-&gt;hw.phy_reset_disable = FALSE;
+
+#ifndef EM_MASTER_SLAVE
+	adapter-&gt;hw.master_slave = em_ms_hw_default;
+#else
+	adapter-&gt;hw.master_slave = EM_MASTER_SLAVE;
+#endif
+	/*
+	 * Set the max frame size assuming standard ethernet
+	 * sized frames.
+	 */
+	adapter-&gt;hw.max_frame_size =
+	    ETHERMTU + ETHER_HDR_LEN + ETHER_CRC_LEN;
+
+	adapter-&gt;hw.min_frame_size =
+	    MINIMUM_ETHERNET_PACKET_SIZE + ETHER_CRC_LEN;
+
+	/*
+	 * This controls when hardware reports transmit completion
+	 * status.
+	 */
+	adapter-&gt;hw.report_tx_early = 1;
+	if (em_allocate_pci_resources(adapter)) {
+		device_printf(dev, &quot;Allocation of PCI resources failed\n&quot;);
+		error = ENXIO;
+		goto err_pci;
+	}
+	
+	/* Initialize eeprom parameters */
+	em_init_eeprom_params(&amp;adapter-&gt;hw);
+
+	tsize = roundup2(adapter-&gt;num_tx_desc * sizeof(struct em_tx_desc),
+	    EM_DBA_ALIGN);
+

[... truncated: 16812 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002209.html">[Haiku-commits] r21086 - haiku/trunk/src/documentation
</A></li>
	<LI>Next message: <A HREF="002212.html">[Haiku-commits] r21087 - in	haiku/trunk/src/add-ons/kernel/drivers/network/ipro1000: .	dev dev/em
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2210">[ date ]</a>
              <a href="thread.html#2210">[ thread ]</a>
              <a href="subject.html#2210">[ subject ]</a>
              <a href="author.html#2210">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
