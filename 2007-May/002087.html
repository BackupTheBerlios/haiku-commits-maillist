<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21007 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . fxp fxp/dev	fxp/dev/fxp
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21007%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20fxp%20fxp/dev%0A%09fxp/dev/fxp&In-Reply-To=%3C200705032142.l43Lgr2G026204%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002086.html">
   <LINK REL="Next"  HREF="002088.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21007 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . fxp fxp/dev	fxp/dev/fxp</H1>
    <B>hugosantos at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21007%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20fxp%20fxp/dev%0A%09fxp/dev/fxp&In-Reply-To=%3C200705032142.l43Lgr2G026204%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21007 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . fxp fxp/dev	fxp/dev/fxp">hugosantos at mail.berlios.de
       </A><BR>
    <I>Thu May  3 23:42:53 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002086.html">[Haiku-commits] r21006 - in haiku/trunk: headers/private/net	src/libs/compat/freebsd_network	src/libs/compat/freebsd_network/compat/sys
</A></li>
        <LI>Next message: <A HREF="002088.html">[Haiku-commits] r21008 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/devices/ethernet	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/stack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2087">[ date ]</a>
              <a href="thread.html#2087">[ thread ]</a>
              <a href="subject.html#2087">[ subject ]</a>
              <a href="author.html#2087">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hugosantos
Date: 2007-05-03 23:42:09 +0200 (Thu, 03 May 2007)
New Revision: 21007
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21007&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21007&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxp.c
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxpreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxpvar.h
   haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/rcvbundl.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
Log:
Added FreeBSD's 6.2 fxp driver (Intel Pro Express 100) to the source tree (original source, no modifications). It already builds and links but it is still a bit far from working.


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2007-05-03 21:18:21 UTC (rev 21006)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2007-05-03 21:42:09 UTC (rev 21007)
@@ -12,5 +12,7 @@
 SubInclude HAIKU_TOP src add-ons kernel drivers network vlance ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network wb840 ;
 
+SubInclude HAIKU_TOP src add-ons kernel drivers network fxp ;
+
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm440x ;
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm570x ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/fxp/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/fxp/Jamfile	2007-05-03 21:18:21 UTC (rev 21006)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/fxp/Jamfile	2007-05-03 21:42:09 UTC (rev 21007)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network fxp ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network fxp dev ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/Jamfile	2007-05-03 21:18:21 UTC (rev 21006)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/Jamfile	2007-05-03 21:42:09 UTC (rev 21007)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network fxp dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network fxp dev fxp ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/Jamfile	2007-05-03 21:18:21 UTC (rev 21006)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/Jamfile	2007-05-03 21:42:09 UTC (rev 21007)
@@ -0,0 +1,16 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network fxp dev fxp ;
+
+SubDirCcFlags -Wall ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 ] ;
+
+KernelAddon fxp :
+	if_fxp.c
+	: libfreebsd_network.a
+	;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxp.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxp.c	2007-05-03 21:18:21 UTC (rev 21006)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/fxp/dev/fxp/if_fxp.c	2007-05-03 21:42:09 UTC (rev 21007)
@@ -0,0 +1,2713 @@
+/*-
+ * Copyright (c) 1995, David Greenman
+ * Copyright (c) 2001 Jonathan Lemon &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jlemon at freebsd.org</A>&gt;
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/fxp/if_fxp.c,v 1.240.2.10.2.1 2006/11/20 16:21:12 rink Exp $&quot;);
+
+/*
+ * Intel EtherExpress Pro/100B PCI Fast Ethernet driver
+ */
+
+#ifdef HAVE_KERNEL_OPTION_HEADERS
+#include &quot;opt_device_polling.h&quot;
+#endif
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/endian.h&gt;
+#include &lt;sys/mbuf.h&gt;
+		/* #include &lt;sys/mutex.h&gt; */
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/sysctl.h&gt;
+
+#include &lt;net/if.h&gt;
+#include &lt;net/if_dl.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;net/bpf.h&gt;
+#include &lt;sys/sockio.h&gt;
+#include &lt;sys/bus.h&gt;
+#include &lt;machine/bus.h&gt;
+#include &lt;sys/rman.h&gt;
+#include &lt;machine/resource.h&gt;
+
+#include &lt;net/ethernet.h&gt;
+#include &lt;net/if_arp.h&gt;
+
+#include &lt;machine/clock.h&gt;	/* for DELAY */
+
+#include &lt;net/if_types.h&gt;
+#include &lt;net/if_vlan_var.h&gt;
+
+#ifdef FXP_IP_CSUM_WAR
+#include &lt;netinet/in.h&gt;
+#include &lt;netinet/in_systm.h&gt;
+#include &lt;netinet/ip.h&gt;
+#include &lt;machine/in_cksum.h&gt;
+#endif
+
+#include &lt;dev/pci/pcivar.h&gt;
+#include &lt;dev/pci/pcireg.h&gt;		/* for PCIM_CMD_xxx */
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+
+#include &lt;dev/fxp/if_fxpreg.h&gt;
+#include &lt;dev/fxp/if_fxpvar.h&gt;
+#include &lt;dev/fxp/rcvbundl.h&gt;
+
+MODULE_DEPEND(fxp, pci, 1, 1, 1);
+MODULE_DEPEND(fxp, ether, 1, 1, 1);
+MODULE_DEPEND(fxp, miibus, 1, 1, 1);
+#include &quot;miibus_if.h&quot;
+
+/*
+ * NOTE!  On the Alpha, we have an alignment constraint.  The
+ * card DMAs the packet immediately following the RFA.  However,
+ * the first thing in the packet is a 14-byte Ethernet header.
+ * This means that the packet is misaligned.  To compensate,
+ * we actually offset the RFA 2 bytes into the cluster.  This
+ * alignes the packet after the Ethernet header at a 32-bit
+ * boundary.  HOWEVER!  This means that the RFA is misaligned!
+ */
+#define	RFA_ALIGNMENT_FUDGE	2
+
+/*
+ * Set initial transmit threshold at 64 (512 bytes). This is
+ * increased by 64 (512 bytes) at a time, to maximum of 192
+ * (1536 bytes), if an underrun occurs.
+ */
+static int tx_threshold = 64;
+
+/*
+ * The configuration byte map has several undefined fields which
+ * must be one or must be zero.  Set up a template for these bits
+ * only, (assuming a 82557 chip) leaving the actual configuration
+ * to fxp_init.
+ *
+ * See struct fxp_cb_config for the bit definitions.
+ */
+static u_char fxp_cb_config_template[] = {
+	0x0, 0x0,		/* cb_status */
+	0x0, 0x0,		/* cb_command */
+	0x0, 0x0, 0x0, 0x0,	/* link_addr */
+	0x0,	/*  0 */
+	0x0,	/*  1 */
+	0x0,	/*  2 */
+	0x0,	/*  3 */
+	0x0,	/*  4 */
+	0x0,	/*  5 */
+	0x32,	/*  6 */
+	0x0,	/*  7 */
+	0x0,	/*  8 */
+	0x0,	/*  9 */
+	0x6,	/* 10 */
+	0x0,	/* 11 */
+	0x0,	/* 12 */
+	0x0,	/* 13 */
+	0xf2,	/* 14 */
+	0x48,	/* 15 */
+	0x0,	/* 16 */
+	0x40,	/* 17 */
+	0xf0,	/* 18 */
+	0x0,	/* 19 */
+	0x3f,	/* 20 */
+	0x5	/* 21 */
+};
+
+struct fxp_ident {
+	uint16_t	devid;
+	int16_t		revid;		/* -1 matches anything */
+	char 		*name;
+};
+
+/*
+ * Claim various Intel PCI device identifiers for this driver.  The
+ * sub-vendor and sub-device field are extensively used to identify
+ * particular variants, but we don't currently differentiate between
+ * them.
+ */
+static struct fxp_ident fxp_ident_table[] = {
+    { 0x1029,	-1,	&quot;Intel 82559 PCI/CardBus Pro/100&quot; },
+    { 0x1030,	-1,	&quot;Intel 82559 Pro/100 Ethernet&quot; },
+    { 0x1031,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 VE Ethernet&quot; },
+    { 0x1032,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 VE Ethernet&quot; },
+    { 0x1033,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },
+    { 0x1034,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },
+    { 0x1035,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },
+    { 0x1036,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },
+    { 0x1037,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 Ethernet&quot; },
+    { 0x1038,	-1,	&quot;Intel 82801CAM (ICH3) Pro/100 VM Ethernet&quot; },
+    { 0x1039,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 VE Ethernet&quot; },
+    { 0x103A,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 Ethernet&quot; },
+    { 0x103B,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 VM Ethernet&quot; },
+    { 0x103C,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 Ethernet&quot; },
+    { 0x103D,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 VE Ethernet&quot; },
+    { 0x103E,	-1,	&quot;Intel 82801DB (ICH4) Pro/100 VM Ethernet&quot; },
+    { 0x1050,	-1,	&quot;Intel 82801BA (D865) Pro/100 VE Ethernet&quot; },
+    { 0x1051,	-1,	&quot;Intel 82562ET (ICH5/ICH5R) Pro/100 VE Ethernet&quot; },
+    { 0x1059,	-1,	&quot;Intel 82551QM Pro/100 M Mobile Connection&quot; },
+    { 0x1064,	-1,	&quot;Intel 82562EZ (ICH6)&quot; },
+    { 0x1065,	-1,	&quot;Intel 82562ET/EZ/GT/GZ PRO/100 VE Ethernet&quot; },
+    { 0x1068,	-1,	&quot;Intel 82801FBM (ICH6-M) Pro/100 VE Ethernet&quot; },
+    { 0x1069,	-1,	&quot;Intel 82562EM/EX/GX Pro/100 Ethernet&quot; },
+    { 0x1092,	-1,	&quot;Intel Pro/100 VE Network Connection&quot; },
+    { 0x1093,	-1,	&quot;Intel Pro/100 VM Network Connection&quot; },
+    { 0x1094,	-1,	&quot;Intel Pro/100 946GZ (ICH7) Network Connection&quot; },
+    { 0x1209,	-1,	&quot;Intel 82559ER Embedded 10/100 Ethernet&quot; },
+    { 0x1229,	0x01,	&quot;Intel 82557 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x02,	&quot;Intel 82557 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x03,	&quot;Intel 82557 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x04,	&quot;Intel 82558 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x05,	&quot;Intel 82558 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x06,	&quot;Intel 82559 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x07,	&quot;Intel 82559 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x08,	&quot;Intel 82559 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x09,	&quot;Intel 82559ER Pro/100 Ethernet&quot; },
+    { 0x1229,	0x0c,	&quot;Intel 82550 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x0d,	&quot;Intel 82550 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x0e,	&quot;Intel 82550 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x0f,	&quot;Intel 82551 Pro/100 Ethernet&quot; },
+    { 0x1229,	0x10,	&quot;Intel 82551 Pro/100 Ethernet&quot; },
+    { 0x1229,	-1,	&quot;Intel 82557/8/9 Pro/100 Ethernet&quot; },
+    { 0x2449,	-1,	&quot;Intel 82801BA/CAM (ICH2/3) Pro/100 Ethernet&quot; },
+    { 0x27dc,	-1,	&quot;Intel 82801GB (ICH7) 10/100 Ethernet&quot; },
+    { 0,	-1,	NULL },
+};
+
+#ifdef FXP_IP_CSUM_WAR
+#define FXP_CSUM_FEATURES    (CSUM_IP | CSUM_TCP | CSUM_UDP)
+#else
+#define FXP_CSUM_FEATURES    (CSUM_TCP | CSUM_UDP)
+#endif
+
+static int		fxp_probe(device_t dev);
+static int		fxp_attach(device_t dev);
+static int		fxp_detach(device_t dev);
+static int		fxp_shutdown(device_t dev);
+static int		fxp_suspend(device_t dev);
+static int		fxp_resume(device_t dev);
+
+static void		fxp_intr(void *xsc);
+static void		fxp_intr_body(struct fxp_softc *sc, struct ifnet *ifp,
+			    uint8_t statack, int count);
+static void 		fxp_init(void *xsc);
+static void 		fxp_init_body(struct fxp_softc *sc);
+static void 		fxp_tick(void *xsc);
+static void 		fxp_start(struct ifnet *ifp);
+static void 		fxp_start_body(struct ifnet *ifp);
+static int		fxp_encap(struct fxp_softc *sc, struct mbuf *m_head);
+static void		fxp_stop(struct fxp_softc *sc);
+static void 		fxp_release(struct fxp_softc *sc);
+static int		fxp_ioctl(struct ifnet *ifp, u_long command,
+			    caddr_t data);
+static void 		fxp_watchdog(struct ifnet *ifp);
+static int		fxp_add_rfabuf(struct fxp_softc *sc,
+    			    struct fxp_rx *rxp);
+static int		fxp_mc_addrs(struct fxp_softc *sc);
+static void		fxp_mc_setup(struct fxp_softc *sc);
+static uint16_t		fxp_eeprom_getword(struct fxp_softc *sc, int offset,
+			    int autosize);
+static void 		fxp_eeprom_putword(struct fxp_softc *sc, int offset,
+			    uint16_t data);
+static void		fxp_autosize_eeprom(struct fxp_softc *sc);
+static void		fxp_read_eeprom(struct fxp_softc *sc, u_short *data,
+			    int offset, int words);
+static void		fxp_write_eeprom(struct fxp_softc *sc, u_short *data,
+			    int offset, int words);
+static int		fxp_ifmedia_upd(struct ifnet *ifp);
+static void		fxp_ifmedia_sts(struct ifnet *ifp,
+			    struct ifmediareq *ifmr);
+static int		fxp_serial_ifmedia_upd(struct ifnet *ifp);
+static void		fxp_serial_ifmedia_sts(struct ifnet *ifp,
+			    struct ifmediareq *ifmr);
+static volatile int	fxp_miibus_readreg(device_t dev, int phy, int reg);
+static void		fxp_miibus_writereg(device_t dev, int phy, int reg,
+			    int value);
+static void		fxp_load_ucode(struct fxp_softc *sc);
+static int		sysctl_int_range(SYSCTL_HANDLER_ARGS,
+			    int low, int high);
+static int		sysctl_hw_fxp_bundle_max(SYSCTL_HANDLER_ARGS);
+static int		sysctl_hw_fxp_int_delay(SYSCTL_HANDLER_ARGS);
+static void 		fxp_scb_wait(struct fxp_softc *sc);
+static void		fxp_scb_cmd(struct fxp_softc *sc, int cmd);
+static void		fxp_dma_wait(struct fxp_softc *sc,
+    			    volatile uint16_t *status, bus_dma_tag_t dmat,
+			    bus_dmamap_t map);
+
+static device_method_t fxp_methods[] = {
+	/* Device interface */
+	DEVMETHOD(device_probe,		fxp_probe),
+	DEVMETHOD(device_attach,	fxp_attach),
+	DEVMETHOD(device_detach,	fxp_detach),
+	DEVMETHOD(device_shutdown,	fxp_shutdown),
+	DEVMETHOD(device_suspend,	fxp_suspend),
+	DEVMETHOD(device_resume,	fxp_resume),
+
+	/* MII interface */
+	DEVMETHOD(miibus_readreg,	fxp_miibus_readreg),
+	DEVMETHOD(miibus_writereg,	fxp_miibus_writereg),
+
+	{ 0, 0 }
+};
+
+static driver_t fxp_driver = {
+	&quot;fxp&quot;,
+	fxp_methods,
+	sizeof(struct fxp_softc),
+};
+
+static devclass_t fxp_devclass;
+
+DRIVER_MODULE(fxp, pci, fxp_driver, fxp_devclass, 0, 0);
+DRIVER_MODULE(fxp, cardbus, fxp_driver, fxp_devclass, 0, 0);
+DRIVER_MODULE(miibus, fxp, miibus_driver, miibus_devclass, 0, 0);
+
+/*
+ * Wait for the previous command to be accepted (but not necessarily
+ * completed).
+ */
+static void
+fxp_scb_wait(struct fxp_softc *sc)
+{
+	union {
+		uint16_t w;
+		uint8_t b[2];
+	} flowctl;
+	int i = 10000;
+
+	while (CSR_READ_1(sc, FXP_CSR_SCB_COMMAND) &amp;&amp; --i)
+		DELAY(2);
+	if (i == 0) {
+		flowctl.b[0] = CSR_READ_1(sc, FXP_CSR_FLOWCONTROL);
+		flowctl.b[1] = CSR_READ_1(sc, FXP_CSR_FLOWCONTROL + 1);
+		device_printf(sc-&gt;dev, &quot;SCB timeout: 0x%x 0x%x 0x%x 0x%x\n&quot;,
+		    CSR_READ_1(sc, FXP_CSR_SCB_COMMAND),
+		    CSR_READ_1(sc, FXP_CSR_SCB_STATACK),
+		    CSR_READ_1(sc, FXP_CSR_SCB_RUSCUS), flowctl.w);
+	}
+}
+
+static void
+fxp_scb_cmd(struct fxp_softc *sc, int cmd)
+{
+
+	if (cmd == FXP_SCB_COMMAND_CU_RESUME &amp;&amp; sc-&gt;cu_resume_bug) {
+		CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, FXP_CB_COMMAND_NOP);
+		fxp_scb_wait(sc);
+	}
+	CSR_WRITE_1(sc, FXP_CSR_SCB_COMMAND, cmd);
+}
+
+static void
+fxp_dma_wait(struct fxp_softc *sc, volatile uint16_t *status,
+    bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	int i = 10000;
+
+	bus_dmamap_sync(dmat, map, BUS_DMASYNC_POSTREAD);
+	while (!(le16toh(*status) &amp; FXP_CB_STATUS_C) &amp;&amp; --i) {
+		DELAY(2);
+		bus_dmamap_sync(dmat, map, BUS_DMASYNC_POSTREAD);
+	}
+	if (i == 0)
+		device_printf(sc-&gt;dev, &quot;DMA timeout\n&quot;);
+}
+
+/*
+ * Return identification string if this device is ours.
+ */
+static int
+fxp_probe(device_t dev)
+{
+	uint16_t devid;
+	uint8_t revid;
+	struct fxp_ident *ident;
+
+	if (pci_get_vendor(dev) == FXP_VENDORID_INTEL) {
+		devid = pci_get_device(dev);
+		revid = pci_get_revid(dev);
+		for (ident = fxp_ident_table; ident-&gt;name != NULL; ident++) {
+			if (ident-&gt;devid == devid &amp;&amp;
+			    (ident-&gt;revid == revid || ident-&gt;revid == -1)) {
+				device_set_desc(dev, ident-&gt;name);
+				return (BUS_PROBE_DEFAULT);
+			}
+		}
+	}
+	return (ENXIO);
+}
+
+static void
+fxp_dma_map_addr(void *arg, bus_dma_segment_t *segs, int nseg, int error)
+{
+	uint32_t *addr;
+
+	if (error)
+		return;
+
+	KASSERT(nseg == 1, (&quot;too many DMA segments, %d should be 1&quot;, nseg));
+	addr = arg;
+	*addr = segs-&gt;ds_addr;
+}
+
+static int
+fxp_attach(device_t dev)
+{
+	struct fxp_softc *sc;
+	struct fxp_cb_tx *tcbp;
+	struct fxp_tx *txp;
+	struct fxp_rx *rxp;
+	struct ifnet *ifp;
+	uint32_t val;
+	uint16_t data, myea[ETHER_ADDR_LEN / 2];
+	u_char eaddr[ETHER_ADDR_LEN];
+	int i, rid, m1, m2, prefer_iomap;
+	int error;
+
+	error = 0;
+	sc = device_get_softc(dev);
+	sc-&gt;dev = dev;
+	mtx_init(&amp;sc-&gt;sc_mtx, device_get_nameunit(dev), MTX_NETWORK_LOCK,
+	    MTX_DEF);
+	callout_init_mtx(&amp;sc-&gt;stat_ch, &amp;sc-&gt;sc_mtx, 0);
+	ifmedia_init(&amp;sc-&gt;sc_media, 0, fxp_serial_ifmedia_upd,
+	    fxp_serial_ifmedia_sts);
+
+	ifp = sc-&gt;ifp = if_alloc(IFT_ETHER);
+	if (ifp == NULL) {
+		device_printf(dev, &quot;can not if_alloc()\n&quot;);
+		error = ENOSPC;
+		goto fail;
+	}
+
+	/*
+	 * Enable bus mastering.
+	 */
+	pci_enable_busmaster(dev);
+	val = pci_read_config(dev, PCIR_COMMAND, 2);
+
+	/*
+	 * Figure out which we should try first - memory mapping or i/o mapping?
+	 * We default to memory mapping. Then we accept an override from the
+	 * command line. Then we check to see which one is enabled.
+	 */
+	m1 = PCIM_CMD_MEMEN;
+	m2 = PCIM_CMD_PORTEN;
+	prefer_iomap = 0;
+	if (resource_int_value(device_get_name(dev), device_get_unit(dev),
+	    &quot;prefer_iomap&quot;, &amp;prefer_iomap) == 0 &amp;&amp; prefer_iomap != 0) {
+		m1 = PCIM_CMD_PORTEN;
+		m2 = PCIM_CMD_MEMEN;
+	}
+
+	sc-&gt;rtp = (m1 == PCIM_CMD_MEMEN)? SYS_RES_MEMORY : SYS_RES_IOPORT;
+	sc-&gt;rgd = (m1 == PCIM_CMD_MEMEN)? FXP_PCI_MMBA : FXP_PCI_IOBA;
+	sc-&gt;mem = bus_alloc_resource_any(dev, sc-&gt;rtp, &amp;sc-&gt;rgd, RF_ACTIVE);
+	if (sc-&gt;mem == NULL) {
+		sc-&gt;rtp =
+		    (m2 == PCIM_CMD_MEMEN)? SYS_RES_MEMORY : SYS_RES_IOPORT;
+		sc-&gt;rgd = (m2 == PCIM_CMD_MEMEN)? FXP_PCI_MMBA : FXP_PCI_IOBA;
+		sc-&gt;mem = bus_alloc_resource_any(dev, sc-&gt;rtp, &amp;sc-&gt;rgd,
+                                            RF_ACTIVE);
+	}
+
+	if (!sc-&gt;mem) {
+		error = ENXIO;
+		goto fail;
+        }
+	if (bootverbose) {
+		device_printf(dev, &quot;using %s space register mapping\n&quot;,
+		   sc-&gt;rtp == SYS_RES_MEMORY? &quot;memory&quot; : &quot;I/O&quot;);
+	}
+
+	sc-&gt;sc_st = rman_get_bustag(sc-&gt;mem);
+	sc-&gt;sc_sh = rman_get_bushandle(sc-&gt;mem);
+
+	/*
+	 * Allocate our interrupt.
+	 */
+	rid = 0;
+	sc-&gt;irq = bus_alloc_resource_any(dev, SYS_RES_IRQ, &amp;rid,
+				 RF_SHAREABLE | RF_ACTIVE);
+	if (sc-&gt;irq == NULL) {
+		device_printf(dev, &quot;could not map interrupt\n&quot;);
+		error = ENXIO;
+		goto fail;
+	}
+
+	/*
+	 * Reset to a stable state.
+	 */
+	CSR_WRITE_4(sc, FXP_CSR_PORT, FXP_PORT_SELECTIVE_RESET);
+	DELAY(10);
+
+	/*
+	 * Find out how large of an SEEPROM we have.
+	 */
+	fxp_autosize_eeprom(sc);
+
+	/*
+	 * Find out the chip revision; lump all 82557 revs together.
+	 */
+	fxp_read_eeprom(sc, &amp;data, 5, 1);
+	if ((data &gt;&gt; 8) == 1)
+		sc-&gt;revision = FXP_REV_82557;
+	else
+		sc-&gt;revision = pci_get_revid(dev);
+
+	/*
+	 * Determine whether we must use the 503 serial interface.
+	 */
+	fxp_read_eeprom(sc, &amp;data, 6, 1);
+	if (sc-&gt;revision == FXP_REV_82557 &amp;&amp; (data &amp; FXP_PHY_DEVICE_MASK) != 0
+	    &amp;&amp; (data &amp; FXP_PHY_SERIAL_ONLY))
+		sc-&gt;flags |= FXP_FLAG_SERIAL_MEDIA;
+
+	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;int_delay&quot;, CTLTYPE_INT | CTLFLAG_RW,
+	    &amp;sc-&gt;tunable_int_delay, 0, sysctl_hw_fxp_int_delay, &quot;I&quot;,
+	    &quot;FXP driver receive interrupt microcode bundling delay&quot;);
+	SYSCTL_ADD_PROC(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;bundle_max&quot;, CTLTYPE_INT | CTLFLAG_RW,
+	    &amp;sc-&gt;tunable_bundle_max, 0, sysctl_hw_fxp_bundle_max, &quot;I&quot;,
+	    &quot;FXP driver receive interrupt microcode bundle size limit&quot;);
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;rnr&quot;, CTLFLAG_RD, &amp;sc-&gt;rnr, 0,
+	    &quot;FXP RNR events&quot;);
+	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
+	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
+	    OID_AUTO, &quot;noflow&quot;, CTLFLAG_RW, &amp;sc-&gt;tunable_noflow, 0,
+	    &quot;FXP flow control disabled&quot;);
+
+	/*
+	 * Pull in device tunables.
+	 */
+	sc-&gt;tunable_int_delay = TUNABLE_INT_DELAY;
+	sc-&gt;tunable_bundle_max = TUNABLE_BUNDLE_MAX;
+	sc-&gt;tunable_noflow = 1;
+	(void) resource_int_value(device_get_name(dev), device_get_unit(dev),
+	    &quot;int_delay&quot;, &amp;sc-&gt;tunable_int_delay);
+	(void) resource_int_value(device_get_name(dev), device_get_unit(dev),
+	    &quot;bundle_max&quot;, &amp;sc-&gt;tunable_bundle_max);
+	(void) resource_int_value(device_get_name(dev), device_get_unit(dev),
+	    &quot;noflow&quot;, &amp;sc-&gt;tunable_noflow);
+	sc-&gt;rnr = 0;
+
+	/*
+	 * Enable workarounds for certain chip revision deficiencies.
+	 *
+	 * Systems based on the ICH2/ICH2-M chip from Intel, and possibly
+	 * some systems based a normal 82559 design, have a defect where
+	 * the chip can cause a PCI protocol violation if it receives
+	 * a CU_RESUME command when it is entering the IDLE state.  The 
+	 * workaround is to disable Dynamic Standby Mode, so the chip never
+	 * deasserts CLKRUN#, and always remains in an active state.
+	 *
+	 * See Intel 82801BA/82801BAM Specification Update, Errata #30.
+	 */
+	i = pci_get_device(dev);
+	if (i == 0x2449 || (i &gt; 0x1030 &amp;&amp; i &lt; 0x1039) ||
+	    sc-&gt;revision &gt;= FXP_REV_82559_A0) {
+		fxp_read_eeprom(sc, &amp;data, 10, 1);
+		if (data &amp; 0x02) {			/* STB enable */
+			uint16_t cksum;
+			int i;
+
+			device_printf(dev,
+			    &quot;Disabling dynamic standby mode in EEPROM\n&quot;);
+			data &amp;= ~0x02;
+			fxp_write_eeprom(sc, &amp;data, 10, 1);
+			device_printf(dev, &quot;New EEPROM ID: 0x%x\n&quot;, data);
+			cksum = 0;
+			for (i = 0; i &lt; (1 &lt;&lt; sc-&gt;eeprom_size) - 1; i++) {
+				fxp_read_eeprom(sc, &amp;data, i, 1);
+				cksum += data;
+			}
+			i = (1 &lt;&lt; sc-&gt;eeprom_size) - 1;
+			cksum = 0xBABA - cksum;
+			fxp_read_eeprom(sc, &amp;data, i, 1);
+			fxp_write_eeprom(sc, &amp;cksum, i, 1);
+			device_printf(dev,
+			    &quot;EEPROM checksum @ 0x%x: 0x%x -&gt; 0x%x\n&quot;,
+			    i, data, cksum);
+#if 1
+			/*
+			 * If the user elects to continue, try the software
+			 * workaround, as it is better than nothing.
+			 */
+			sc-&gt;flags |= FXP_FLAG_CU_RESUME_BUG;
+#endif
+		}
+	}
+
+	/*
+	 * If we are not a 82557 chip, we can enable extended features.
+	 */
+	if (sc-&gt;revision != FXP_REV_82557) {
+		/*
+		 * If MWI is enabled in the PCI configuration, and there
+		 * is a valid cacheline size (8 or 16 dwords), then tell
+		 * the board to turn on MWI.
+		 */
+		if (val &amp; PCIM_CMD_MWRICEN &amp;&amp;
+		    pci_read_config(dev, PCIR_CACHELNSZ, 1) != 0)
+			sc-&gt;flags |= FXP_FLAG_MWI_ENABLE;
+
+		/* turn on the extended TxCB feature */
+		sc-&gt;flags |= FXP_FLAG_EXT_TXCB;
+
+		/* enable reception of long frames for VLAN */
+		sc-&gt;flags |= FXP_FLAG_LONG_PKT_EN;
+	} else {
+		/* a hack to get long VLAN frames on a 82557 */
+		sc-&gt;flags |= FXP_FLAG_SAVE_BAD;
+	}
+
+	/*
+	 * Enable use of extended RFDs and TCBs for 82550
+	 * and later chips. Note: we need extended TXCB support
+	 * too, but that's already enabled by the code above.
+	 * Be careful to do this only on the right devices.
+	 */
+	if (sc-&gt;revision == FXP_REV_82550 || sc-&gt;revision == FXP_REV_82550_C ||
+	    sc-&gt;revision == FXP_REV_82551_E || sc-&gt;revision == FXP_REV_82551_F
+	    || sc-&gt;revision == FXP_REV_82551_10) {
+		sc-&gt;rfa_size = sizeof (struct fxp_rfa);
+		sc-&gt;tx_cmd = FXP_CB_COMMAND_IPCBXMIT;
+		sc-&gt;flags |= FXP_FLAG_EXT_RFA;
+	} else {
+		sc-&gt;rfa_size = sizeof (struct fxp_rfa) - FXP_RFAX_LEN;
+		sc-&gt;tx_cmd = FXP_CB_COMMAND_XMIT;
+	}
+
+	/*
+	 * Allocate DMA tags and DMA safe memory.
+	 */
+	sc-&gt;maxtxseg = FXP_NTXSEG;
+	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA)
+		sc-&gt;maxtxseg--;
+	error = bus_dma_tag_create(NULL, 2, 0, BUS_SPACE_MAXADDR_32BIT,
+	    BUS_SPACE_MAXADDR, NULL, NULL, MCLBYTES * sc-&gt;maxtxseg,
+	    sc-&gt;maxtxseg, MCLBYTES, 0, busdma_lock_mutex, &amp;Giant,
+	    &amp;sc-&gt;fxp_mtag);
+	if (error) {
+		device_printf(dev, &quot;could not allocate dma tag\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dma_tag_create(NULL, 4, 0, BUS_SPACE_MAXADDR_32BIT,
+	    BUS_SPACE_MAXADDR, NULL, NULL, sizeof(struct fxp_stats), 1,
+	    sizeof(struct fxp_stats), 0, busdma_lock_mutex, &amp;Giant,
+	    &amp;sc-&gt;fxp_stag);
+	if (error) {
+		device_printf(dev, &quot;could not allocate dma tag\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dmamem_alloc(sc-&gt;fxp_stag, (void **)&amp;sc-&gt;fxp_stats,
+	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;fxp_smap);
+	if (error)
+		goto fail;
+	error = bus_dmamap_load(sc-&gt;fxp_stag, sc-&gt;fxp_smap, sc-&gt;fxp_stats,
+	    sizeof(struct fxp_stats), fxp_dma_map_addr, &amp;sc-&gt;stats_addr, 0);
+	if (error) {
+		device_printf(dev, &quot;could not map the stats buffer\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dma_tag_create(NULL, 4, 0, BUS_SPACE_MAXADDR_32BIT,
+	    BUS_SPACE_MAXADDR, NULL, NULL, FXP_TXCB_SZ, 1,
+	    FXP_TXCB_SZ, 0, busdma_lock_mutex, &amp;Giant, &amp;sc-&gt;cbl_tag);
+	if (error) {
+		device_printf(dev, &quot;could not allocate dma tag\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dmamem_alloc(sc-&gt;cbl_tag, (void **)&amp;sc-&gt;fxp_desc.cbl_list,
+	    BUS_DMA_NOWAIT | BUS_DMA_ZERO, &amp;sc-&gt;cbl_map);
+	if (error)
+		goto fail;
+
+	error = bus_dmamap_load(sc-&gt;cbl_tag, sc-&gt;cbl_map,
+	    sc-&gt;fxp_desc.cbl_list, FXP_TXCB_SZ, fxp_dma_map_addr,
+	    &amp;sc-&gt;fxp_desc.cbl_addr, 0);
+	if (error) {
+		device_printf(dev, &quot;could not map DMA memory\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dma_tag_create(NULL, 4, 0, BUS_SPACE_MAXADDR_32BIT,
+	    BUS_SPACE_MAXADDR, NULL, NULL, sizeof(struct fxp_cb_mcs), 1,
+	    sizeof(struct fxp_cb_mcs), 0, busdma_lock_mutex, &amp;Giant,
+	    &amp;sc-&gt;mcs_tag);
+	if (error) {
+		device_printf(dev, &quot;could not allocate dma tag\n&quot;);
+		goto fail;
+	}
+
+	error = bus_dmamem_alloc(sc-&gt;mcs_tag, (void **)&amp;sc-&gt;mcsp,
+	    BUS_DMA_NOWAIT, &amp;sc-&gt;mcs_map);
+	if (error)
+		goto fail;
+	error = bus_dmamap_load(sc-&gt;mcs_tag, sc-&gt;mcs_map, sc-&gt;mcsp,
+	    sizeof(struct fxp_cb_mcs), fxp_dma_map_addr, &amp;sc-&gt;mcs_addr, 0);
+	if (error) {
+		device_printf(dev, &quot;can't map the multicast setup command\n&quot;);
+		goto fail;
+	}
+
+	/*
+	 * Pre-allocate the TX DMA maps and setup the pointers to
+	 * the TX command blocks.
+	 */
+	txp = sc-&gt;fxp_desc.tx_list;
+	tcbp = sc-&gt;fxp_desc.cbl_list;
+	for (i = 0; i &lt; FXP_NTXCB; i++) {
+		txp[i].tx_cb = tcbp + i;
+		error = bus_dmamap_create(sc-&gt;fxp_mtag, 0, &amp;txp[i].tx_map);
+		if (error) {
+			device_printf(dev, &quot;can't create DMA map for TX\n&quot;);
+			goto fail;
+		}
+	}
+	error = bus_dmamap_create(sc-&gt;fxp_mtag, 0, &amp;sc-&gt;spare_map);
+	if (error) {
+		device_printf(dev, &quot;can't create spare DMA map\n&quot;);
+		goto fail;
+	}
+
+	/*
+	 * Pre-allocate our receive buffers.
+	 */
+	sc-&gt;fxp_desc.rx_head = sc-&gt;fxp_desc.rx_tail = NULL;
+	for (i = 0; i &lt; FXP_NRFABUFS; i++) {
+		rxp = &amp;sc-&gt;fxp_desc.rx_list[i];
+		error = bus_dmamap_create(sc-&gt;fxp_mtag, 0, &amp;rxp-&gt;rx_map);
+		if (error) {
+			device_printf(dev, &quot;can't create DMA map for RX\n&quot;);
+			goto fail;
+		}
+		if (fxp_add_rfabuf(sc, rxp) != 0) {
+			error = ENOMEM;
+			goto fail;
+		}
+	}
+
+	/*
+	 * Read MAC address.
+	 */
+	fxp_read_eeprom(sc, myea, 0, 3);
+	eaddr[0] = myea[0] &amp; 0xff;
+	eaddr[1] = myea[0] &gt;&gt; 8;
+	eaddr[2] = myea[1] &amp; 0xff;
+	eaddr[3] = myea[1] &gt;&gt; 8;
+	eaddr[4] = myea[2] &amp; 0xff;
+	eaddr[5] = myea[2] &gt;&gt; 8;
+	if (bootverbose) {
+		device_printf(dev, &quot;PCI IDs: %04x %04x %04x %04x %04x\n&quot;,
+		    pci_get_vendor(dev), pci_get_device(dev),
+		    pci_get_subvendor(dev), pci_get_subdevice(dev),
+		    pci_get_revid(dev));
+		fxp_read_eeprom(sc, &amp;data, 10, 1);
+		device_printf(dev, &quot;Dynamic Standby mode is %s\n&quot;,
+		    data &amp; 0x02 ? &quot;enabled&quot; : &quot;disabled&quot;);
+	}
+
+	/*
+	 * If this is only a 10Mbps device, then there is no MII, and
+	 * the PHY will use a serial interface instead.
+	 *
+	 * The Seeq 80c24 AutoDUPLEX(tm) Ethernet Interface Adapter
+	 * doesn't have a programming interface of any sort.  The
+	 * media is sensed automatically based on how the link partner
+	 * is configured.  This is, in essence, manual configuration.
+	 */
+	if (sc-&gt;flags &amp; FXP_FLAG_SERIAL_MEDIA) {
+		ifmedia_add(&amp;sc-&gt;sc_media, IFM_ETHER|IFM_MANUAL, 0, NULL);
+		ifmedia_set(&amp;sc-&gt;sc_media, IFM_ETHER|IFM_MANUAL);
+	} else {
+		if (mii_phy_probe(dev, &amp;sc-&gt;miibus, fxp_ifmedia_upd,
+		    fxp_ifmedia_sts)) {
+	                device_printf(dev, &quot;MII without any PHY!\n&quot;);
+			error = ENXIO;
+			goto fail;
+		}
+	}
+
+	if_initname(ifp, device_get_name(dev), device_get_unit(dev));
+	ifp-&gt;if_init = fxp_init;
+	ifp-&gt;if_softc = sc;
+	ifp-&gt;if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
+	ifp-&gt;if_ioctl = fxp_ioctl;
+	ifp-&gt;if_start = fxp_start;
+	ifp-&gt;if_watchdog = fxp_watchdog;
+
+	ifp-&gt;if_capabilities = ifp-&gt;if_capenable = 0;
+
+	/* Enable checksum offload for 82550 or better chips */
+	if (sc-&gt;flags &amp; FXP_FLAG_EXT_RFA) {
+		ifp-&gt;if_hwassist = FXP_CSUM_FEATURES;
+		ifp-&gt;if_capabilities |= IFCAP_HWCSUM;
+		ifp-&gt;if_capenable |= IFCAP_HWCSUM;
+	}
+
+#ifdef DEVICE_POLLING
+	/* Inform the world we support polling. */
+	ifp-&gt;if_capabilities |= IFCAP_POLLING;
+#endif
+
+	/*
+	 * Attach the interface.
+	 */
+	ether_ifattach(ifp, eaddr);
+
+	/*
+	 * Tell the upper layer(s) we support long frames.
+	 * Must appear after the call to ether_ifattach() because
+	 * ether_ifattach() sets ifi_hdrlen to the default value.
+	 */
+	ifp-&gt;if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
+	ifp-&gt;if_capabilities |= IFCAP_VLAN_MTU;
+	ifp-&gt;if_capenable |= IFCAP_VLAN_MTU; /* the hw bits already set */
+
+	/*
+	 * Let the system queue as many packets as we have available
+	 * TX descriptors.
+	 */
+	IFQ_SET_MAXLEN(&amp;ifp-&gt;if_snd, FXP_NTXCB - 1);
+	ifp-&gt;if_snd.ifq_drv_maxlen = FXP_NTXCB - 1;
+	IFQ_SET_READY(&amp;ifp-&gt;if_snd);
+
+	/* 
+	 * Hook our interrupt after all initialization is complete.
+	 */
+	error = bus_setup_intr(dev, sc-&gt;irq, INTR_TYPE_NET | INTR_MPSAFE,
+			       fxp_intr, sc, &amp;sc-&gt;ih);
+	if (error) {
+		device_printf(dev, &quot;could not setup irq\n&quot;);
+		ether_ifdetach(sc-&gt;ifp);
+		goto fail;
+	}
+
+fail:
+	if (error)
+		fxp_release(sc);
+	return (error);
+}
+
+/*
+ * Release all resources.  The softc lock should not be held and the
+ * interrupt should already be torn down.
+ */
+static void
+fxp_release(struct fxp_softc *sc)
+{
+	struct fxp_rx *rxp;
+	struct fxp_tx *txp;
+	int i;
+
+	FXP_LOCK_ASSERT(sc, MA_NOTOWNED);
+	KASSERT(sc-&gt;ih == NULL,
+	    (&quot;fxp_release() called with intr handle still active&quot;));
+	if (sc-&gt;miibus)
+		device_delete_child(sc-&gt;dev, sc-&gt;miibus);
+	bus_generic_detach(sc-&gt;dev);
+	ifmedia_removeall(&amp;sc-&gt;sc_media);
+	if (sc-&gt;fxp_desc.cbl_list) {
+		bus_dmamap_unload(sc-&gt;cbl_tag, sc-&gt;cbl_map);
+		bus_dmamem_free(sc-&gt;cbl_tag, sc-&gt;fxp_desc.cbl_list,
+		    sc-&gt;cbl_map);
+	}
+	if (sc-&gt;fxp_stats) {
+		bus_dmamap_unload(sc-&gt;fxp_stag, sc-&gt;fxp_smap);
+		bus_dmamem_free(sc-&gt;fxp_stag, sc-&gt;fxp_stats, sc-&gt;fxp_smap);
+	}
+	if (sc-&gt;mcsp) {
+		bus_dmamap_unload(sc-&gt;mcs_tag, sc-&gt;mcs_map);
+		bus_dmamem_free(sc-&gt;mcs_tag, sc-&gt;mcsp, sc-&gt;mcs_map);
+	}
+	if (sc-&gt;irq)
+		bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, 0, sc-&gt;irq);
+	if (sc-&gt;mem)
+		bus_release_resource(sc-&gt;dev, sc-&gt;rtp, sc-&gt;rgd, sc-&gt;mem);
+	if (sc-&gt;fxp_mtag) {
+		for (i = 0; i &lt; FXP_NRFABUFS; i++) {
+			rxp = &amp;sc-&gt;fxp_desc.rx_list[i];
+			if (rxp-&gt;rx_mbuf != NULL) {
+				bus_dmamap_sync(sc-&gt;fxp_mtag, rxp-&gt;rx_map,
+				    BUS_DMASYNC_POSTREAD);
+				bus_dmamap_unload(sc-&gt;fxp_mtag, rxp-&gt;rx_map);
+				m_freem(rxp-&gt;rx_mbuf);
+			}
+			bus_dmamap_destroy(sc-&gt;fxp_mtag, rxp-&gt;rx_map);
+		}
+		bus_dmamap_destroy(sc-&gt;fxp_mtag, sc-&gt;spare_map);
+		for (i = 0; i &lt; FXP_NTXCB; i++) {
+			txp = &amp;sc-&gt;fxp_desc.tx_list[i];
+			if (txp-&gt;tx_mbuf != NULL) {
+				bus_dmamap_sync(sc-&gt;fxp_mtag, txp-&gt;tx_map,
+				    BUS_DMASYNC_POSTWRITE);
+				bus_dmamap_unload(sc-&gt;fxp_mtag, txp-&gt;tx_map);
+				m_freem(txp-&gt;tx_mbuf);
+			}
+			bus_dmamap_destroy(sc-&gt;fxp_mtag, txp-&gt;tx_map);
+		}
+		bus_dma_tag_destroy(sc-&gt;fxp_mtag);
+	}
+	if (sc-&gt;fxp_stag)
+		bus_dma_tag_destroy(sc-&gt;fxp_stag);
+	if (sc-&gt;cbl_tag)
+		bus_dma_tag_destroy(sc-&gt;cbl_tag);
+	if (sc-&gt;mcs_tag)
+		bus_dma_tag_destroy(sc-&gt;mcs_tag);
+	if (sc-&gt;ifp)
+		if_free(sc-&gt;ifp);
+
+	mtx_destroy(&amp;sc-&gt;sc_mtx);
+}
+
+/*
+ * Detach interface.
+ */
+static int
+fxp_detach(device_t dev)
+{
+	struct fxp_softc *sc = device_get_softc(dev);
+
+#ifdef DEVICE_POLLING
+	if (sc-&gt;ifp-&gt;if_capenable &amp; IFCAP_POLLING)   
+		ether_poll_deregister(sc-&gt;ifp);
+#endif
+
+	FXP_LOCK(sc);
+	sc-&gt;suspended = 1;	/* Do same thing as we do for suspend */
+	/*
+	 * Stop DMA and drop transmit queue, but disable interrupts first.
+	 */
+	CSR_WRITE_1(sc, FXP_CSR_SCB_INTRCNTL, FXP_SCB_INTR_DISABLE);
+	fxp_stop(sc);
+	FXP_UNLOCK(sc);
+	callout_drain(&amp;sc-&gt;stat_ch);
+
+	/*
+	 * Close down routes etc.
+	 */
+	ether_ifdetach(sc-&gt;ifp);
+
+	/*
+	 * Unhook interrupt before dropping lock. This is to prevent
+	 * races with fxp_intr().
+	 */
+	bus_teardown_intr(sc-&gt;dev, sc-&gt;irq, sc-&gt;ih);
+	sc-&gt;ih = NULL;
+
+	/* Release our allocated resources. */
+	fxp_release(sc);
+	return (0);
+}
+
+/*
+ * Device shutdown routine. Called at system shutdown after sync. The

[... truncated: 3732 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002086.html">[Haiku-commits] r21006 - in haiku/trunk: headers/private/net	src/libs/compat/freebsd_network	src/libs/compat/freebsd_network/compat/sys
</A></li>
	<LI>Next message: <A HREF="002088.html">[Haiku-commits] r21008 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/devices/ethernet	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/stack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2087">[ date ]</a>
              <a href="thread.html#2087">[ thread ]</a>
              <a href="subject.html#2087">[ subject ]</a>
              <a href="author.html#2087">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
