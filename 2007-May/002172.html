<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21054 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21054%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/bfs&In-Reply-To=%3C200705071226.l47CQMdc029437%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002170.html">
   <LINK REL="Next"  HREF="002173.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21054 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21054%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/bfs&In-Reply-To=%3C200705071226.l47CQMdc029437%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21054 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs">axeld at mail.berlios.de
       </A><BR>
    <I>Mon May  7 14:26:22 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002170.html">[Haiku-commits] r21053 - in haiku/trunk/src:	add-ons/kernel/file_systems/bfs	tests/add-ons/kernel/file_systems/bfs/r5
</A></li>
        <LI>Next message: <A HREF="002173.html">[Haiku-commits] r21055 - in haiku/trunk: headers/private/fs_shell	src/tools/fs_shell
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2172">[ date ]</a>
              <a href="thread.html#2172">[ thread ]</a>
              <a href="subject.html#2172">[ subject ]</a>
              <a href="author.html#2172">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-05-07 14:26:21 +0200 (Mon, 07 May 2007)
New Revision: 21054
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21054&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21054&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/BPlusTree.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/BPlusTree.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Debug.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Lock.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp
Log:
* Removed unused code when USER is defined - the fs_shell no longer does this, but
  provides a kernel emulation layer.
* Renamed all private BPlusTree methods to have the '_' prefix.
* Removed useless set_sem_owner() from Lock.h - all semaphores created in the kernel
  always belong to the system team automatically.
* Some cleanup.


Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/BPlusTree.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/BPlusTree.cpp	2007-05-07 10:56:40 UTC (rev 21053)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/BPlusTree.cpp	2007-05-07 12:26:21 UTC (rev 21054)
@@ -1,13 +1,14 @@
-/* BPlusTree - BFS B+Tree implementation
+/*
+ * Copyright 2001-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+ * This file may be used under the terms of the MIT License.
  *
  * Roughly based on 'btlib' written by Marcus J. Ranum - it shares
  * no code but achieves binary compatibility with the on disk format.
- *
- * Copyright 2001-2006, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
- * This file may be used under the terms of the MIT License.
  */
 
+//! B+Tree implementation
 
+
 #include &quot;Debug.h&quot;
 #include &quot;BPlusTree.h&quot;
 #include &quot;Inode.h&quot;
@@ -215,7 +216,8 @@
 		uint8 *block;
 
 		if (transaction != NULL) {
-			block = (uint8 *)block_cache_get_writable(volume-&gt;BlockCache(), fBlockNumber, transaction-&gt;ID());
+			block = (uint8 *)block_cache_get_writable(volume-&gt;BlockCache(),
+				fBlockNumber, transaction-&gt;ID());
 			fWritable = true;
 		} else {
 			block = (uint8 *)block_cache_get(volume-&gt;BlockCache(), fBlockNumber);
@@ -270,7 +272,8 @@
 
 
 status_t
-CachedNode::Allocate(Transaction &amp;transaction, bplustree_node **_node, off_t *_offset)
+CachedNode::Allocate(Transaction &amp;transaction, bplustree_node **_node,
+	off_t *_offset)
 {
 	if (fTree == NULL || fTree-&gt;fHeader == NULL || fTree-&gt;fStream == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
@@ -307,7 +310,8 @@
 	// the maximum_size has to be changed before the call to SetTo() - or
 	// else it will fail because the requested node is out of bounds
 	off_t offset = header-&gt;MaximumSize();
-	header-&gt;maximum_size = HOST_ENDIAN_TO_BFS_INT64(header-&gt;MaximumSize() + fTree-&gt;fNodeSize);
+	header-&gt;maximum_size = HOST_ENDIAN_TO_BFS_INT64(header-&gt;MaximumSize()
+		+ fTree-&gt;fNodeSize);
 
 	if (SetToWritable(transaction, offset, false) != NULL) {
 		fNode-&gt;Initialize();
@@ -318,7 +322,8 @@
 	}
 
 	// revert header size to old value
-	header-&gt;maximum_size = HOST_ENDIAN_TO_BFS_INT64(header-&gt;MaximumSize() - fTree-&gt;fNodeSize);
+	header-&gt;maximum_size = HOST_ENDIAN_TO_BFS_INT64(header-&gt;MaximumSize()
+		- fTree-&gt;fNodeSize);
 	RETURN_ERROR(B_ERROR);
 }
 
@@ -374,8 +379,7 @@
 }
 
 
-/** Create a new B+Tree on the specified stream */
-
+/*! Create a new B+Tree on the specified stream */
 status_t
 BPlusTree::SetTo(Transaction &amp;transaction, Inode *stream, int32 nodeSize)
 {
@@ -397,8 +401,8 @@
 
 	fHeader = header;
 	fAllowDuplicates = ((stream-&gt;Mode() &amp; S_INDEX_DIR) == S_INDEX_DIR
-						&amp;&amp; stream-&gt;BlockRun() != stream-&gt;Parent())
-						|| (stream-&gt;Mode() &amp; S_ALLOW_DUPS) != 0;
+			&amp;&amp; stream-&gt;BlockRun() != stream-&gt;Parent())
+		|| (stream-&gt;Mode() &amp; S_ALLOW_DUPS) != 0;
 
 	fNodeSize = nodeSize;
 
@@ -460,13 +464,16 @@
 	fNodeSize = fHeader-&gt;NodeSize();
 
 	{
-		uint32 toMode[] = {S_STR_INDEX, S_INT_INDEX, S_UINT_INDEX, S_LONG_LONG_INDEX,
-						   S_ULONG_LONG_INDEX, S_FLOAT_INDEX, S_DOUBLE_INDEX};
-		uint32 mode = stream-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX | S_LONG_LONG_INDEX
-						   | S_ULONG_LONG_INDEX | S_FLOAT_INDEX | S_DOUBLE_INDEX);
+		uint32 toMode[] = {S_STR_INDEX, S_INT_INDEX, S_UINT_INDEX,
+			S_LONG_LONG_INDEX, S_ULONG_LONG_INDEX, S_FLOAT_INDEX,
+			S_DOUBLE_INDEX};
+		uint32 mode = stream-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX
+			| S_UINT_INDEX | S_LONG_LONG_INDEX | S_ULONG_LONG_INDEX
+			| S_FLOAT_INDEX | S_DOUBLE_INDEX);
 
 		if (fHeader-&gt;DataType() &gt; BPLUSTREE_DOUBLE_TYPE
-			|| (stream-&gt;Mode() &amp; S_INDEX_DIR) &amp;&amp; toMode[fHeader-&gt;DataType()] != mode
+			|| (stream-&gt;Mode() &amp; S_INDEX_DIR)
+				&amp;&amp; toMode[fHeader-&gt;DataType()] != mode
 			|| !stream-&gt;IsContainer()) {
 			D(	dump_bplustree_header(fHeader);
 				dump_inode(&amp;stream-&gt;Node());
@@ -477,8 +484,8 @@
 		// although it's in stat.h, the S_ALLOW_DUPS flag is obviously unused
 		// in the original BFS code - we will honour it nevertheless
 		fAllowDuplicates = ((stream-&gt;Mode() &amp; S_INDEX_DIR) == S_INDEX_DIR
-							&amp;&amp; stream-&gt;BlockRun() != stream-&gt;Parent())
-							|| (stream-&gt;Mode() &amp; S_ALLOW_DUPS) != 0;
+			&amp;&amp; stream-&gt;BlockRun() != stream-&gt;Parent())
+			|| (stream-&gt;Mode() &amp; S_ALLOW_DUPS) != 0;
 	}
 
 	CachedNode cached(this, fHeader-&gt;RootNode());
@@ -548,8 +555,8 @@
 
 
 void
-BPlusTree::UpdateIterators(off_t offset, off_t nextOffset, uint16 keyIndex, uint16 splitAt,
-	int8 change)
+BPlusTree::_UpdateIterators(off_t offset, off_t nextOffset, uint16 keyIndex,
+	uint16 splitAt, int8 change)
 {
 	// Although every iterator which is affected by this update currently
 	// waits on a semaphore, other iterators could be added/removed at
@@ -566,7 +573,7 @@
 
 
 void
-BPlusTree::AddIterator(TreeIterator *iterator)
+BPlusTree::_AddIterator(TreeIterator *iterator)
 {
 	if (fIteratorLock.Lock() &lt; B_OK)
 		return;
@@ -578,7 +585,7 @@
 
 
 void 
-BPlusTree::RemoveIterator(TreeIterator *iterator)
+BPlusTree::_RemoveIterator(TreeIterator *iterator)
 {
 	if (fIteratorLock.Lock() &lt; B_OK)
 		return;
@@ -590,7 +597,8 @@
 
 
 int32
-BPlusTree::CompareKeys(const void *key1, int keyLength1, const void *key2, int keyLength2)
+BPlusTree::_CompareKeys(const void *key1, int keyLength1, const void *key2,
+	int keyLength2)
 {
 	type_code type = 0;
 	switch (fHeader-&gt;data_type) {
@@ -621,8 +629,8 @@
 
 
 status_t
-BPlusTree::FindKey(const bplustree_node *node, const uint8 *key, uint16 keyLength,
-	uint16 *_index, off_t *_next)
+BPlusTree::_FindKey(const bplustree_node *node, const uint8 *key,
+	uint16 keyLength, uint16 *_index, off_t *_next)
 {
 #ifdef DEBUG
 		NodeChecker checker(node, fNodeSize, &quot;find&quot;);
@@ -645,13 +653,14 @@
 
 		uint16 searchLength;
 		uint8 *searchKey = node-&gt;KeyAt(i, &amp;searchLength);
-		if (searchKey + searchLength + sizeof(off_t) + sizeof(uint16) &gt; (uint8 *)node + fNodeSize
+		if (searchKey + searchLength + sizeof(off_t) + sizeof(uint16)
+				&gt; (uint8 *)node + fNodeSize
 			|| searchLength &gt; BPLUSTREE_MAX_KEY_LENGTH) {
 			fStream-&gt;GetVolume()-&gt;Panic();
 			RETURN_ERROR(B_BAD_DATA);
 		}
 
-		int32 cmp = CompareKeys(key, keyLength, searchKey, searchLength);
+		int32 cmp = _CompareKeys(key, keyLength, searchKey, searchLength);
 		if (cmp &lt; 0) {
 			last = i - 1;
 			saveIndex = i;
@@ -678,13 +687,14 @@
 }
 
 
-/**	Prepares the stack to contain all nodes that were passed while
- *	following the key, from the root node to the leaf node that could
- *	or should contain that key.
- */
-
+/*!
+	Prepares the stack to contain all nodes that were passed while
+	following the key, from the root node to the leaf node that could
+	or should contain that key.
+*/
 status_t
-BPlusTree::SeekDown(Stack&lt;node_and_key&gt; &amp;stack, const uint8 *key, uint16 keyLength)
+BPlusTree::_SeekDown(Stack&lt;node_and_key&gt; &amp;stack, const uint8 *key,
+	uint16 keyLength)
 {
 	// set the root node to begin with
 	node_and_key nodeAndKey;
@@ -703,7 +713,8 @@
 		}
 
 		off_t nextOffset;
-		status_t status = FindKey(node, key, keyLength, &amp;nodeAndKey.keyIndex, &amp;nextOffset);
+		status_t status = _FindKey(node, key, keyLength, &amp;nodeAndKey.keyIndex,
+			&amp;nextOffset);
 
 		if (status == B_ENTRY_NOT_FOUND &amp;&amp; nextOffset == nodeAndKey.nodeOffset)
 			RETURN_ERROR(B_ERROR);
@@ -714,17 +725,18 @@
 		nodeAndKey.nodeOffset = nextOffset;
 	}
 
-	FATAL((&quot;BPlusTree::SeekDown() could not open node %Ld\n&quot;, nodeAndKey.nodeOffset));
+	FATAL((&quot;BPlusTree::SeekDown() could not open node %Ld\n&quot;,
+		nodeAndKey.nodeOffset));
 	return B_ERROR;
 }
 
 
-/**	This will find a free duplicate fragment in the given bplustree_node.
- *	The CachedNode will be set to the writable fragment on success.
- */
-
+/*!
+	This will find a free duplicate fragment in the given bplustree_node.
+	The CachedNode will be set to the writable fragment on success.
+*/
 status_t
-BPlusTree::FindFreeDuplicateFragment(Transaction &amp;transaction,
+BPlusTree::_FindFreeDuplicateFragment(Transaction &amp;transaction,
 	const bplustree_node *node, CachedNode &amp;cached,
 	off_t *_offset, bplustree_node **_fragment, uint32 *_index)
 {
@@ -765,7 +777,7 @@
 
 
 status_t
-BPlusTree::InsertDuplicate(Transaction &amp;transaction, CachedNode &amp;cached,
+BPlusTree::_InsertDuplicate(Transaction &amp;transaction, CachedNode &amp;cached,
 	const bplustree_node *node, uint16 index, off_t value)
 {
 	CachedNode cachedDuplicate(this);
@@ -784,7 +796,8 @@
 			if (duplicate == NULL)
 				return B_IO_ERROR;
 
-			duplicate_array *array = duplicate-&gt;FragmentAt(bplustree_node::FragmentIndex(oldValue));
+			duplicate_array *array = duplicate-&gt;FragmentAt(
+				bplustree_node::FragmentIndex(oldValue));
 			if (array-&gt;count &gt; NUM_FRAGMENT_VALUES
 				|| array-&gt;count &lt; 1) {
 				FATAL((&quot;insertDuplicate: Invalid array[%d] size in fragment %Ld == %Ld!\n&quot;,
@@ -803,9 +816,10 @@
 					// reuse it as a duplicate node
 					offset = bplustree_node::FragmentOffset(oldValue);
 
-					memmove(duplicate-&gt;DuplicateArray(), array, (NUM_FRAGMENT_VALUES + 1) * sizeof(off_t));
-					duplicate-&gt;left_link = duplicate-&gt;right_link = HOST_ENDIAN_TO_BFS_INT64(
-						(uint64)BPLUSTREE_NULL);
+					memmove(duplicate-&gt;DuplicateArray(), array,
+						(NUM_FRAGMENT_VALUES + 1) * sizeof(off_t));
+					duplicate-&gt;left_link = duplicate-&gt;right_link
+						= HOST_ENDIAN_TO_BFS_INT64((uint64)BPLUSTREE_NULL);
 
 					array = duplicate-&gt;DuplicateArray();
 					array-&gt;Insert(value);
@@ -816,13 +830,15 @@
 						// the old duplicate has not been touched, so we can reuse it
 
 					bplustree_node *newDuplicate;
-					status = cachedDuplicate.Allocate(transaction, &amp;newDuplicate, &amp;offset);
+					status = cachedDuplicate.Allocate(transaction,
+						&amp;newDuplicate, &amp;offset);
 					if (status &lt; B_OK)
 						RETURN_ERROR(status);
 
 					// copy the array from the fragment node to the duplicate node
 					// and free the old entry (by zero'ing all values)
-					newDuplicate-&gt;overflow_link = HOST_ENDIAN_TO_BFS_INT64(array-&gt;count);
+					newDuplicate-&gt;overflow_link = HOST_ENDIAN_TO_BFS_INT64(
+						array-&gt;count);
 					memcpy(&amp;newDuplicate-&gt;all_key_count, &amp;array-&gt;values[0],
 						array-&gt;count * sizeof(off_t));
 					memset(array, 0, (NUM_FRAGMENT_VALUES + 1) * sizeof(off_t));
@@ -894,10 +910,11 @@
 
 	uint32 fragmentIndex = 0;
 	bplustree_node *fragment;
-	if (FindFreeDuplicateFragment(transaction, node, cachedDuplicate,
+	if (_FindFreeDuplicateFragment(transaction, node, cachedDuplicate,
 			&amp;offset, &amp;fragment, &amp;fragmentIndex) != B_OK) {
 		// allocate a new duplicate fragment node
-		if ((status = cachedDuplicate.Allocate(transaction, &amp;fragment, &amp;offset)) &lt; B_OK)
+		if ((status = cachedDuplicate.Allocate(transaction, &amp;fragment,
+				&amp;offset)) &lt; B_OK)
 			RETURN_ERROR(status);
 
 		memset(fragment, 0, fNodeSize);
@@ -918,8 +935,8 @@
 
 
 void
-BPlusTree::InsertKey(bplustree_node *node, uint16 index, uint8 *key, uint16 keyLength,
-	off_t value)
+BPlusTree::_InsertKey(bplustree_node *node, uint16 index, uint8 *key,
+	uint16 keyLength, off_t value)
 {
 	// should never happen, but who knows?
 	if (index &gt; node-&gt;NumKeys())
@@ -930,13 +947,15 @@
 	uint8 *keys = node-&gt;Keys();
 
 	node-&gt;all_key_count = HOST_ENDIAN_TO_BFS_INT16(node-&gt;NumKeys() + 1);
-	node-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(node-&gt;AllKeyLength() + keyLength);
+	node-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(node-&gt;AllKeyLength()
+		+ keyLength);
 
 	off_t *newValues = node-&gt;Values();
 	uint16 *newKeyLengths = node-&gt;KeyLengths();
 
 	// move values and copy new value into them
-	memmove(newValues + index + 1, values + index, sizeof(off_t) * (node-&gt;NumKeys() - 1 - index));
+	memmove(newValues + index + 1, values + index,
+		sizeof(off_t) * (node-&gt;NumKeys() - 1 - index));
 	memmove(newValues, values, sizeof(off_t) * index);
 
 	newValues[index] = HOST_ENDIAN_TO_BFS_INT64(value);
@@ -950,7 +969,8 @@
 
 	int32 keyStart;
 	newKeyLengths[index] = HOST_ENDIAN_TO_BFS_INT16(keyLength
-		+ (keyStart = index &gt; 0 ? BFS_ENDIAN_TO_HOST_INT16(newKeyLengths[index - 1]) : 0));
+		+ (keyStart = index &gt; 0
+			? BFS_ENDIAN_TO_HOST_INT16(newKeyLengths[index - 1]) : 0));
 
 	// move keys and copy new key into them
 	uint16 length = BFS_ENDIAN_TO_HOST_INT16(newKeyLengths[index]);
@@ -962,14 +982,15 @@
 }
 
 
-/**	Splits the \a node into two halves - the other half will be put into \a other.
- *	It also takes care to create a new overflow link if the node to split is an
- *	index node.
- */
-
+/*!
+	Splits the \a node into two halves - the other half will be put into \a other.
+	It also takes care to create a new overflow link if the node to split is an
+	index node.
+*/
 status_t
-BPlusTree::SplitNode(bplustree_node *node, off_t nodeOffset, bplustree_node *other,
-	off_t otherOffset, uint16 *_keyIndex, uint8 *key, uint16 *_keyLength, off_t *_value)
+BPlusTree::_SplitNode(bplustree_node *node, off_t nodeOffset,
+	bplustree_node *other, off_t otherOffset, uint16 *_keyIndex, uint8 *key,
+	uint16 *_keyLength, off_t *_value)
 {
 	if (*_keyIndex &gt; node-&gt;NumKeys() + 1)
 		return B_BAD_VALUE;
@@ -992,14 +1013,18 @@
 	size_t size = fNodeSize &gt;&gt; 1;
 	int32 out, in;
 	for (in = out = 0; in &lt; node-&gt;NumKeys() + 1;) {
-		if (!bytes)
-			bytesBefore = in &gt; 0 ? BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in - 1]) : 0;
+		if (!bytes) {
+			bytesBefore = in &gt; 0
+				? BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in - 1]) : 0;
+		}
 
 		if (in == keyIndex &amp;&amp; !bytes) {
 			bytes = *_keyLength;
 		} else {
-			if (keyIndex &lt; out)
-				bytesAfter = BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in]) - bytesBefore;
+			if (keyIndex &lt; out) {
+				bytesAfter = BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in])
+					- bytesBefore;
+			}
 
 			in++;
 		}
@@ -1022,7 +1047,8 @@
 
 	other-&gt;left_link = node-&gt;left_link;
 	other-&gt;right_link = HOST_ENDIAN_TO_BFS_INT64(nodeOffset);
-	other-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(bytes + bytesBefore + bytesAfter);
+	other-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(bytes + bytesBefore
+		+ bytesAfter);
 	other-&gt;all_key_count = HOST_ENDIAN_TO_BFS_INT16(out);
 
 	uint16 *outKeyLengths = other-&gt;KeyLengths();
@@ -1043,13 +1069,15 @@
 
 		if (bytesAfter) {
 			// copy the keys after the new key
-			memcpy(outKeys + bytesBefore + bytes, inKeys + bytesBefore, bytesAfter);
+			memcpy(outKeys + bytesBefore + bytes, inKeys + bytesBefore,
+				bytesAfter);
 			keys = out - keyIndex - 1;
 			for (int32 i = 0;i &lt; keys;i++) {
 				outKeyLengths[keyIndex + i + 1] = HOST_ENDIAN_TO_BFS_INT16(
 					BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[keyIndex + i]) + bytes);
 			}
-			memcpy(outKeyValues + keyIndex + 1, inKeyValues + keyIndex, keys * sizeof(off_t));
+			memcpy(outKeyValues + keyIndex + 1, inKeyValues + keyIndex,
+				keys * sizeof(off_t));
 		}
 	}
 
@@ -1080,7 +1108,8 @@
 			// If a key is dropped (is not the new key), we have to copy
 			// it, because it would be lost if not.
 			uint8 *droppedKey = node-&gt;KeyAt(in, &amp;newLength);
-			if (droppedKey + newLength + sizeof(off_t) + sizeof(uint16) &gt; (uint8 *)node + fNodeSize
+			if (droppedKey + newLength + sizeof(off_t) + sizeof(uint16)
+					&gt; (uint8 *)node + fNodeSize
 				|| newLength &gt; BPLUSTREE_MAX_KEY_LENGTH) {
 				fStream-&gt;GetVolume()-&gt;Panic();
 				RETURN_ERROR(B_BAD_DATA);
@@ -1106,7 +1135,8 @@
 			// it's enough to set bytesBefore once here, because we do
 			// not need to know the exact length of all keys in this
 			// loop
-			bytesBefore = in &gt; skip ? BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in - 1]) : 0;
+			bytesBefore = in &gt; skip
+				? BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in - 1]) : 0;
 			bytes = *_keyLength;
 		} else {
 			if (in &lt; node-&gt;NumKeys()) {
@@ -1132,9 +1162,10 @@
 	}
 
 	// adjust the byte counts (since we were a bit lazy in the loop)
-	if (keyIndex &gt;= in &amp;&amp; keyIndex - skip &lt; out)
-		bytesAfter = BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in]) - bytesBefore - total;
-	else if (keyIndex &lt; skip)
+	if (keyIndex &gt;= in &amp;&amp; keyIndex - skip &lt; out) {
+		bytesAfter = BFS_ENDIAN_TO_HOST_INT16(inKeyLengths[in])
+			- bytesBefore - total;
+	} else if (keyIndex &lt; skip)
 		bytesBefore = node-&gt;AllKeyLength() - total;
 
 	if (bytesBefore &lt; 0 || bytesAfter &lt; 0)
@@ -1142,7 +1173,8 @@
 
 	node-&gt;left_link = HOST_ENDIAN_TO_BFS_INT64(otherOffset);
 		// right link, and overflow link can stay the same
-	node-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(bytes + bytesBefore + bytesAfter);
+	node-&gt;all_key_length = HOST_ENDIAN_TO_BFS_INT16(bytes + bytesBefore
+		+ bytesAfter);
 	node-&gt;all_key_count = HOST_ENDIAN_TO_BFS_INT16(out - 1);
 
 	// array positions have changed
@@ -1157,19 +1189,25 @@
 
 	if (bytesBefore)
 		memmove(inKeys, inKeys + total, bytesBefore);
-	if (bytesAfter)
-		memmove(inKeys + bytesBefore + bytes, inKeys + total + bytesBefore, bytesAfter);
+	if (bytesAfter) {
+		memmove(inKeys + bytesBefore + bytes, inKeys + total + bytesBefore,
+			bytesAfter);
+	}
 
 	if (bytesBefore)
 		memmove(outKeyLengths, inKeyLengths + skip, keys * sizeof(uint16));
 	in = out - keyIndex - 1;
-	if (bytesAfter)
-		memmove(outKeyLengths + keyIndex + 1, inKeyLengths + skip + keyIndex, in * sizeof(uint16));
+	if (bytesAfter) {
+		memmove(outKeyLengths + keyIndex + 1, inKeyLengths + skip + keyIndex,
+			in * sizeof(uint16));
+	}
 
 	if (bytesBefore)
 		memmove(outKeyValues, inKeyValues + skip, keys * sizeof(off_t));
-	if (bytesAfter)
-		memmove(outKeyValues + keyIndex + 1, inKeyValues + skip + keyIndex, in * sizeof(off_t));
+	if (bytesAfter) {
+		memmove(outKeyValues + keyIndex + 1, inKeyValues + skip + keyIndex,
+			in * sizeof(off_t));
+	}
 
 	if (bytes) {
 		// finally, copy the newly inserted key (don't overwrite anything)
@@ -1196,14 +1234,16 @@
 }
 
 
-/**	This inserts a key into the tree. The changes made to the tree will
- *	all be part of the \a transaction.
- */
-
+/*!
+	This inserts a key into the tree. The changes made to the tree will
+	all be part of the \a transaction.
+*/
 status_t
-BPlusTree::Insert(Transaction &amp;transaction, const uint8 *key, uint16 keyLength, off_t value)
+BPlusTree::Insert(Transaction &amp;transaction, const uint8 *key, uint16 keyLength,
+	off_t value)
 {
-	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
+	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH
+		|| keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
 		RETURN_ERROR(B_BAD_VALUE);
 #ifdef DEBUG
 	if (value &lt; 0)
@@ -1214,7 +1254,7 @@
 	WriteLocked locked(fStream-&gt;Lock());
 
 	Stack&lt;node_and_key&gt; stack;
-	if (SeekDown(stack, key, keyLength) != B_OK)
+	if (_SeekDown(stack, key, keyLength) != B_OK)
 		RETURN_ERROR(B_ERROR);
 
 	uint8 keyBuffer[BPLUSTREE_MAX_KEY_LENGTH + 1];
@@ -1226,23 +1266,26 @@
 	const bplustree_node *node;
 
 	CachedNode cached(this);
-	while (stack.Pop(&amp;nodeAndKey) &amp;&amp; (node = cached.SetTo(nodeAndKey.nodeOffset)) != NULL) {
+	while (stack.Pop(&amp;nodeAndKey)
+		&amp;&amp; (node = cached.SetTo(nodeAndKey.nodeOffset)) != NULL) {
 #ifdef DEBUG
 		NodeChecker checker(node, fNodeSize, &quot;insert&quot;);
 #endif
 		if (node-&gt;IsLeaf()) {
 			// first round, check for duplicate entries
-			status_t status = FindKey(node, key, keyLength, &amp;nodeAndKey.keyIndex);
+			status_t status = _FindKey(node, key, keyLength,
+				&amp;nodeAndKey.keyIndex);
 
 			// is this a duplicate entry?
 			if (status == B_OK) {
 				if (fAllowDuplicates) {
-					status = InsertDuplicate(transaction, cached, node, nodeAndKey.keyIndex, value);
+					status = _InsertDuplicate(transaction, cached, node,
+						nodeAndKey.keyIndex, value);
 					if (status != B_OK)
 						RETURN_ERROR(status);
 					return B_OK;
 				}
-				
+
 				RETURN_ERROR(B_NAME_IN_USE);
 			}
 		}
@@ -1252,11 +1295,14 @@
 			return B_IO_ERROR;
 
 		// is the node big enough to hold the pair?
-		if (int32(round_up(sizeof(bplustree_node) + writableNode-&gt;AllKeyLength() + keyLength)
-			+ (writableNode-&gt;NumKeys() + 1) * (sizeof(uint16) + sizeof(off_t))) &lt; fNodeSize)
-		{
-			InsertKey(writableNode, nodeAndKey.keyIndex, keyBuffer, keyLength, value);
-			UpdateIterators(nodeAndKey.nodeOffset, BPLUSTREE_NULL, nodeAndKey.keyIndex, 0, 1);
+		if (int32(round_up(sizeof(bplustree_node)
+				+ writableNode-&gt;AllKeyLength() + keyLength)
+				+ (writableNode-&gt;NumKeys() + 1) * (sizeof(uint16)
+				+ sizeof(off_t))) &lt; fNodeSize) {
+			_InsertKey(writableNode, nodeAndKey.keyIndex,
+				keyBuffer, keyLength, value);
+			_UpdateIterators(nodeAndKey.nodeOffset, BPLUSTREE_NULL,
+				nodeAndKey.keyIndex, 0, 1);
 
 			return B_OK;
 		} else {
@@ -1268,7 +1314,8 @@
 			off_t newRoot = BPLUSTREE_NULL;
 			if (nodeAndKey.nodeOffset == fHeader-&gt;RootNode()) {
 				bplustree_node *root;
-				status_t status = cachedNewRoot.Allocate(transaction, &amp;root, &amp;newRoot);
+				status_t status = cachedNewRoot.Allocate(transaction, &amp;root,
+					&amp;newRoot);
 				if (status &lt; B_OK) {
 					// The tree is most likely corrupted!
 					// But it's still sane at leaf level - we could set
@@ -1283,14 +1330,16 @@
 			// reserve space for the other node
 			bplustree_node *other;
 			off_t otherOffset;
-			status_t status = cachedOther.Allocate(transaction, &amp;other, &amp;otherOffset);
+			status_t status = cachedOther.Allocate(transaction, &amp;other,
+				&amp;otherOffset);
 			if (status &lt; B_OK) {
 				cachedNewRoot.Free(transaction, newRoot);
 				RETURN_ERROR(status);
 			}
 
-			if (SplitNode(writableNode, nodeAndKey.nodeOffset, other, otherOffset,
-					&amp;nodeAndKey.keyIndex, keyBuffer, &amp;keyLength, &amp;value) &lt; B_OK) {
+			if (_SplitNode(writableNode, nodeAndKey.nodeOffset, other,
+					otherOffset, &amp;nodeAndKey.keyIndex, keyBuffer, &amp;keyLength,
+					&amp;value) &lt; B_OK) {
 				// free root node &amp; other node here
 				cachedOther.Free(transaction, otherOffset);					
 				cachedNewRoot.Free(transaction, newRoot);
@@ -1302,11 +1351,12 @@
 			NodeChecker otherChecker(other, fNodeSize, &quot;insert split other&quot;);
 #endif
 
-			UpdateIterators(nodeAndKey.nodeOffset, otherOffset, nodeAndKey.keyIndex,
-				writableNode-&gt;NumKeys(), 1);
+			_UpdateIterators(nodeAndKey.nodeOffset, otherOffset,
+				nodeAndKey.keyIndex, writableNode-&gt;NumKeys(), 1);
 
 			// update the right link of the node in the left of the new node
-			if ((other = cachedOther.SetToWritable(transaction, other-&gt;LeftLink())) != NULL) {
+			if ((other = cachedOther.SetToWritable(transaction,
+					other-&gt;LeftLink())) != NULL) {
 				other-&gt;right_link = HOST_ENDIAN_TO_BFS_INT64(otherOffset);
 			}
 
@@ -1314,16 +1364,20 @@
 			if (newRoot != BPLUSTREE_NULL) {
 				bplustree_node *root = cachedNewRoot.Node();
 
-				InsertKey(root, 0, keyBuffer, keyLength, writableNode-&gt;LeftLink());
-				root-&gt;overflow_link = HOST_ENDIAN_TO_BFS_INT64(nodeAndKey.nodeOffset);
+				_InsertKey(root, 0, keyBuffer, keyLength,
+					writableNode-&gt;LeftLink());
+				root-&gt;overflow_link = HOST_ENDIAN_TO_BFS_INT64(
+					nodeAndKey.nodeOffset);
 
-				bplustree_header *header = fCachedHeader.MakeWritableHeader(transaction);
+				bplustree_header *header
+					= fCachedHeader.MakeWritableHeader(transaction);
 				if (header == NULL)
 					return B_IO_ERROR;
 
 				// finally, update header to point to the new root
 				header-&gt;root_node_pointer = HOST_ENDIAN_TO_BFS_INT64(newRoot);
-				header-&gt;max_number_of_levels = HOST_ENDIAN_TO_BFS_INT32(header-&gt;MaxNumberOfLevels() + 1);
+				header-&gt;max_number_of_levels = HOST_ENDIAN_TO_BFS_INT32(
+					header-&gt;MaxNumberOfLevels() + 1);
 
 				return B_OK;
 			}
@@ -1333,13 +1387,14 @@
 }
 
 
-/**	Removes the duplicate index/value pair from the tree.
- *	It's part of the private tree interface.
- */
-
+/*!
+	Removes the duplicate index/value pair from the tree.
+	It's part of the private tree interface.
+*/
 status_t
-BPlusTree::RemoveDuplicate(Transaction &amp;transaction, const bplustree_node *node,
-	CachedNode &amp;cached, uint16 index, off_t value)
+BPlusTree::_RemoveDuplicate(Transaction &amp;transaction,
+	const bplustree_node *node, CachedNode &amp;cached, uint16 index,
+	off_t value)
 {
 	off_t *values = node-&gt;Values();
 	off_t oldValue = BFS_ENDIAN_TO_HOST_INT64(values[index]);
@@ -1353,7 +1408,8 @@
 
 	// if it's a duplicate fragment, remove the entry from there
 	if (bplustree_node::LinkType(oldValue) == BPLUSTREE_DUPLICATE_FRAGMENT) {
-		duplicate_array *array = duplicate-&gt;FragmentAt(bplustree_node::FragmentIndex(oldValue));
+		duplicate_array *array = duplicate-&gt;FragmentAt(
+			bplustree_node::FragmentIndex(oldValue));
 
 		if (array-&gt;count &gt; NUM_FRAGMENT_VALUES
 			|| array-&gt;count &lt; 1) {
@@ -1488,7 +1544,7 @@
 			bplustree_node *fragment = NULL;
 			uint32 fragmentIndex = 0;
 			off_t offset;
-			if (FindFreeDuplicateFragment(transaction, node, cachedOther,
+			if (_FindFreeDuplicateFragment(transaction, node, cachedOther,
 					&amp;offset, &amp;fragment, &amp;fragmentIndex) == B_OK) {
 				// move to other node
 				duplicate_array *target = fragment-&gt;FragmentAt(fragmentIndex);
@@ -1514,14 +1570,14 @@
 }
 
 
-/** Removes the key with the given index from the specified node.
- *	Since it has to get the key from the node anyway (to obtain it's
- *	pointer), it's not needed to pass the key &amp; its length, although
- *	the calling method (BPlusTree::Remove()) have this data.
- */
-
+/*!
+	Removes the key with the given index from the specified node.
+	Since it has to get the key from the node anyway (to obtain it's
+	pointer), it's not needed to pass the key &amp; its length, although
+	the calling method (BPlusTree::Remove()) have this data.
+*/
 void
-BPlusTree::RemoveKey(bplustree_node *node, uint16 index)
+BPlusTree::_RemoveKey(bplustree_node *node, uint16 index)
 {
 	// should never happen, but who knows?
 	if (index &gt; node-&gt;NumKeys() &amp;&amp; node-&gt;NumKeys() &gt; 0) {
@@ -1575,35 +1631,38 @@
 }
 
 
-/**	Removes the specified key from the tree. The &quot;value&quot; parameter is only used
- *	for trees which allow duplicates, so you may safely ignore it.
- *	It's not an optional parameter, so at least you have to think about it.
- */
-
+/*!
+	Removes the specified key from the tree. The &quot;value&quot; parameter is only used
+	for trees which allow duplicates, so you may safely ignore it.
+	It's not an optional parameter, so at least you have to think about it.
+*/
 status_t
-BPlusTree::Remove(Transaction &amp;transaction, const uint8 *key, uint16 keyLength, off_t value)
+BPlusTree::Remove(Transaction &amp;transaction, const uint8 *key, uint16 keyLength,
+	off_t value)
 {
-	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
+	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH
+		|| keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
 		RETURN_ERROR(B_BAD_VALUE);
 
 	// lock access to stream
 	WriteLocked locked(fStream-&gt;Lock());
 
 	Stack&lt;node_and_key&gt; stack;
-	if (SeekDown(stack, key, keyLength) != B_OK)
+	if (_SeekDown(stack, key, keyLength) != B_OK)
 		RETURN_ERROR(B_ERROR);
 
 	node_and_key nodeAndKey;
 	const bplustree_node *node;
 
 	CachedNode cached(this);
-	while (stack.Pop(&amp;nodeAndKey) &amp;&amp; (node = cached.SetTo(nodeAndKey.nodeOffset)) != NULL) {
+	while (stack.Pop(&amp;nodeAndKey)
+		&amp;&amp; (node = cached.SetTo(nodeAndKey.nodeOffset)) != NULL) {
 #ifdef DEBUG
 		NodeChecker checker(node, fNodeSize, &quot;remove&quot;);
 #endif
 		if (node-&gt;IsLeaf()) {
 			// first round, check for duplicate entries
-			status_t status = FindKey(node, key, keyLength, &amp;nodeAndKey.keyIndex);
+			status_t status = _FindKey(node, key, keyLength, &amp;nodeAndKey.keyIndex);
 			if (status &lt; B_OK)
 				RETURN_ERROR(status);
 
@@ -1611,15 +1670,16 @@
 			// to the next node after the current - if there aren't any
 			// more nodes, we need a way to prevent the TreeIterators to
 			// touch the old node again, we use BPLUSTREE_FREE for this
-			off_t next = node-&gt;RightLink() == BPLUSTREE_NULL ? BPLUSTREE_FREE : node-&gt;RightLink();
-			UpdateIterators(nodeAndKey.nodeOffset, node-&gt;NumKeys() == 1 ?
-								next : BPLUSTREE_NULL, nodeAndKey.keyIndex, 0 , -1);
+			off_t next = node-&gt;RightLink() == BPLUSTREE_NULL
+				? BPLUSTREE_FREE : node-&gt;RightLink();
+			_UpdateIterators(nodeAndKey.nodeOffset, node-&gt;NumKeys() == 1
+				? next : BPLUSTREE_NULL, nodeAndKey.keyIndex, 0 , -1);
 
 			// is this a duplicate entry?
 			if (bplustree_node::IsDuplicate(BFS_ENDIAN_TO_HOST_INT64(
 					node-&gt;Values()[nodeAndKey.keyIndex]))) {
 				if (fAllowDuplicates) {
-					return RemoveDuplicate(transaction, node, cached,
+					return _RemoveDuplicate(transaction, node, cached,
 						nodeAndKey.keyIndex, value);
 				} else {
 					FATAL((&quot;dupliate node found where no duplicates are allowed!\n&quot;));
@@ -1658,7 +1718,7 @@
 		// the overflow link, so we have to drop the last key)
 		if (writableNode-&gt;NumKeys() &gt; 1
 			|| !writableNode-&gt;IsLeaf() &amp;&amp; writableNode-&gt;NumKeys() == 1) {
-			RemoveKey(writableNode, nodeAndKey.keyIndex);
+			_RemoveKey(writableNode, nodeAndKey.keyIndex);
 			return B_OK;
 		}
 
@@ -1680,19 +1740,21 @@
 }
 
 
-/**	Replaces the value for the key in the tree.
- *	Returns B_OK if the key could be found and its value replaced,
- *	B_ENTRY_NOT_FOUND if the key couldn't be found, and other errors
- *	to indicate that something went terribly wrong.
- *	Note that this doesn't work with duplicates - it will just
- *	return B_BAD_TYPE if you call this function on a tree where
- *	duplicates are allowed.
- */
-
+/*!
+	Replaces the value for the key in the tree.
+	Returns B_OK if the key could be found and its value replaced,
+	B_ENTRY_NOT_FOUND if the key couldn't be found, and other errors
+	to indicate that something went terribly wrong.
+	Note that this doesn't work with duplicates - it will just
+	return B_BAD_TYPE if you call this function on a tree where
+	duplicates are allowed.
+*/
 status_t
-BPlusTree::Replace(Transaction &amp;transaction, const uint8 *key, uint16 keyLength, off_t value)
+BPlusTree::Replace(Transaction &amp;transaction, const uint8 *key,
+	uint16 keyLength, off_t value)
 {
-	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH
+	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH
+		|| keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH
 		|| key == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
@@ -1709,7 +1771,7 @@
 	while ((node = cached.SetTo(nodeOffset)) != NULL) {
 		uint16 keyIndex = 0;
 		off_t nextOffset;
-		status_t status = FindKey(node, key, keyLength, &amp;keyIndex, &amp;nextOffset);
+		status_t status = _FindKey(node, key, keyLength, &amp;keyIndex, &amp;nextOffset);
 
 		if (node-&gt;OverflowLink() == BPLUSTREE_NULL) {
 			if (status == B_OK) {
@@ -1730,22 +1792,23 @@
 }
 
 
-/**	Searches the key in the tree, and stores the offset found in
- *	_value, if successful.
- *	It's very similar to BPlusTree::SeekDown(), but doesn't fill
- *	a stack while it descends the tree.
- *	Returns B_OK when the key could be found, B_ENTRY_NOT_FOUND
- *	if not. It can also return other errors to indicate that
- *	something went wrong.
- *	Note that this doesn't work with duplicates - it will just
- *	return B_BAD_TYPE if you call this function on a tree where
- *	duplicates are allowed.
- */
-
+/*!
+	Searches the key in the tree, and stores the offset found in
+	_value, if successful.
+	It's very similar to BPlusTree::SeekDown(), but doesn't fill
+	a stack while it descends the tree.
+	Returns B_OK when the key could be found, B_ENTRY_NOT_FOUND
+	if not. It can also return other errors to indicate that
+	something went wrong.
+	Note that this doesn't work with duplicates - it will just
+	return B_BAD_TYPE if you call this function on a tree where
+	duplicates are allowed.
+*/
 status_t
 BPlusTree::Find(const uint8 *key, uint16 keyLength, off_t *_value)
 {
-	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH || keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH
+	if (keyLength &lt; BPLUSTREE_MIN_KEY_LENGTH
+		|| keyLength &gt; BPLUSTREE_MAX_KEY_LENGTH
 		|| key == NULL)
 		RETURN_ERROR(B_BAD_VALUE);
 
@@ -1766,7 +1829,7 @@
 	while ((node = cached.SetTo(nodeOffset)) != NULL) {
 		uint16 keyIndex = 0;
 		off_t nextOffset;
-		status_t status = FindKey(node, key, keyLength, &amp;keyIndex, &amp;nextOffset);
+		status_t status = _FindKey(node, key, keyLength, &amp;keyIndex, &amp;nextOffset);
 
 #ifdef DEBUG
 		levels++;
@@ -1799,14 +1862,14 @@
 	fCurrentNodeOffset(BPLUSTREE_NULL),
 	fNext(NULL)
 {
-	tree-&gt;AddIterator(this);
+	tree-&gt;_AddIterator(this);
 }
 
 
 TreeIterator::~TreeIterator()
 {
 	if (fTree)
-		fTree-&gt;RemoveIterator(this);
+		fTree-&gt;_RemoveIterator(this);
 }
 
 
@@ -1840,7 +1903,8 @@
 			nextOffset = node-&gt;OverflowLink();
 		else {
 			if (node-&gt;AllKeyLength() &gt; fTree-&gt;fNodeSize
-				|| (uint32)node-&gt;Values() &gt; (uint32)node + fTree-&gt;fNodeSize - 8 * node-&gt;NumKeys())
+				|| (uint32)node-&gt;Values() &gt; (uint32)node + fTree-&gt;fNodeSize
+					- 8 * node-&gt;NumKeys())
 				RETURN_ERROR(B_ERROR);
 
 			nextOffset = BFS_ENDIAN_TO_HOST_INT64(node-&gt;Values()[0]);
@@ -1856,21 +1920,21 @@
 }
 
 
-/**	Iterates through the tree in the specified direction.
- *	When it iterates through duplicates, the &quot;key&quot; is only updated for the
- *	first entry - if you need to know when this happens, use the &quot;duplicate&quot;
- *	parameter which is 0 for no duplicate, 1 for the first, and 2 for all
- *	the other duplicates.
- *	That's not too nice, but saves the 256 bytes that would be needed to
- *	store the last key - if this will ever become an issue, it will be
- *	easy to change.
- *	The other advantage of this is, that the queries can skip all duplicates
- *	at once when they are not relevant to them.
- */
-
+/*!
+	Iterates through the tree in the specified direction.
+	When it iterates through duplicates, the &quot;key&quot; is only updated for the
+	first entry - if you need to know when this happens, use the &quot;duplicate&quot;
+	parameter which is 0 for no duplicate, 1 for the first, and 2 for all
+	the other duplicates.
+	That's not too nice, but saves the 256 bytes that would be needed to
+	store the last key - if this will ever become an issue, it will be
+	easy to change.
+	The other advantage of this is, that the queries can skip all duplicates
+	at once when they are not relevant to them.
+*/
 status_t
-TreeIterator::Traverse(int8 direction, void *key, uint16 *keyLength, uint16 maxLength,
-	off_t *value, uint16 *duplicate)
+TreeIterator::Traverse(int8 direction, void *key, uint16 *keyLength,
+	uint16 maxLength, off_t *value, uint16 *duplicate)
 {
 	if (fTree == NULL)
 		return B_INTERRUPTED;
@@ -2007,11 +2071,11 @@
 }
 
 
-/**	This is more or less a copy of BPlusTree::Find() - but it just
- *	sets the current position in the iterator, regardless of if the
- *	key could be found or not.
- */
-
+/*!
+	This is more or less a copy of BPlusTree::Find() - but it just
+	sets the current position in the iterator, regardless of if the
+	key could be found or not.
+*/
 status_t 
 TreeIterator::Find(const uint8 *key, uint16 keyLength)
 {
@@ -2031,7 +2095,8 @@
 	while ((node = cached.SetTo(nodeOffset)) != NULL) {
 		uint16 keyIndex = 0;
 		off_t nextOffset;
-		status_t status = fTree-&gt;FindKey(node, key, keyLength, &amp;keyIndex, &amp;nextOffset);
+		status_t status = fTree-&gt;_FindKey(node, key, keyLength, &amp;keyIndex,
+			&amp;nextOffset);
 
 		if (node-&gt;OverflowLink() == BPLUSTREE_NULL) {
 			fCurrentNodeOffset = nodeOffset;
@@ -2160,12 +2225,11 @@
 }
 
 
-/**	Although the name suggests it, this function doesn't return the real
- *	used fragment count; at least, it can only count to two: it returns
- *	0, if there is no fragment used, 1 if there is only one fragment
- *	used, and 2 if there are at least 2 fragments used.
- */
-
+/*!	Although the name suggests it, this function doesn't return the real
+	used fragment count; at least, it can only count to two: it returns
+	0, if there is no fragment used, 1 if there is only one fragment
+	used, and 2 if there are at least 2 fragments used.
+*/
 uint32
 bplustree_node::FragmentsUsed(uint32 nodeSize) const
 {
@@ -2210,14 +2274,11 @@
 
 
 int32
-compareKeys(type_code type, const void *key1, int keyLength1, const void *key2, int keyLength2)
+compareKeys(type_code type, const void *key1, int keyLength1,
+	const void *key2, int keyLength2)
 {
 	// if one of the keys is NULL, bail out gracefully
 	if (key1 == NULL || key2 == NULL) {
-//#if USER
-//		// that's here to see if it's reasonable to handle this case nicely at all
-//		DEBUGGER((&quot;compareKeys() got NULL key!&quot;));
-//#endif
 		// even if it's most probably a bug in the calling code, we try to

[... truncated: 469 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002170.html">[Haiku-commits] r21053 - in haiku/trunk/src:	add-ons/kernel/file_systems/bfs	tests/add-ons/kernel/file_systems/bfs/r5
</A></li>
	<LI>Next message: <A HREF="002173.html">[Haiku-commits] r21055 - in haiku/trunk: headers/private/fs_shell	src/tools/fs_shell
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2172">[ date ]</a>
              <a href="thread.html#2172">[ thread ]</a>
              <a href="subject.html#2172">[ subject ]</a>
              <a href="author.html#2172">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
