<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r21210 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/datalink_protocols/arp	src/add-ons/kernel/network/datalink_protocols/ethernet_frame	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/protocols/icmp	src/add-ons/kernel/network/protocols/ipv4	src/add-ons/kernel/network/protocols/tcp	src/add-ons/kernel/network/protocols/udp	src/add-ons/kernel/network/stack
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21210%20-%20in%20haiku/trunk%3A%20headers/private/net%0A%09src/add-ons/kernel/network/datalink_protocols/arp%0A%09src/add-ons/kernel/network/datalink_protocols/ethernet_frame%0A%09src/add-ons/kernel/network/devices/loopback%0A%09src/add-ons/kernel/network/protocols/icmp%0A%09src/add-ons/kernel/network/protocols/ipv4%0A%09src/add-ons/kernel/network/protocols/tcp%0A%09src/add-ons/kernel/network/protocols/udp%0A%09src/add-ons/kernel/network/stack&In-Reply-To=%3C200705230348.l4N3mwAG021130%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002392.html">
   <LINK REL="Next"  HREF="002395.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r21210 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/datalink_protocols/arp	src/add-ons/kernel/network/datalink_protocols/ethernet_frame	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/protocols/icmp	src/add-ons/kernel/network/protocols/ipv4	src/add-ons/kernel/network/protocols/tcp	src/add-ons/kernel/network/protocols/udp	src/add-ons/kernel/network/stack</H1>
    <B>hugosantos at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r21210%20-%20in%20haiku/trunk%3A%20headers/private/net%0A%09src/add-ons/kernel/network/datalink_protocols/arp%0A%09src/add-ons/kernel/network/datalink_protocols/ethernet_frame%0A%09src/add-ons/kernel/network/devices/loopback%0A%09src/add-ons/kernel/network/protocols/icmp%0A%09src/add-ons/kernel/network/protocols/ipv4%0A%09src/add-ons/kernel/network/protocols/tcp%0A%09src/add-ons/kernel/network/protocols/udp%0A%09src/add-ons/kernel/network/stack&In-Reply-To=%3C200705230348.l4N3mwAG021130%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r21210 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/datalink_protocols/arp	src/add-ons/kernel/network/datalink_protocols/ethernet_frame	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/protocols/icmp	src/add-ons/kernel/network/protocols/ipv4	src/add-ons/kernel/network/protocols/tcp	src/add-ons/kernel/network/protocols/udp	src/add-ons/kernel/network/stack">hugosantos at mail.berlios.de
       </A><BR>
    <I>Wed May 23 05:48:58 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="002392.html">[Haiku-commits] r21209 - in haiku/trunk/src/add-ons/translators: .	hpgs hpgs/lib
</A></li>
        <LI>Next message: <A HREF="002395.html">[Haiku-commits] r21211 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/protocols/icmp	src/add-ons/kernel/network/protocols/tcp	src/add-ons/kernel/network/stack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2394">[ date ]</a>
              <a href="thread.html#2394">[ thread ]</a>
              <a href="subject.html#2394">[ subject ]</a>
              <a href="author.html#2394">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hugosantos
Date: 2007-05-23 05:48:23 +0200 (Wed, 23 May 2007)
New Revision: 21210
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=21210&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=21210&amp;view=rev</A>

Modified:
   haiku/trunk/headers/private/net/NetUtilities.h
   haiku/trunk/headers/private/net/net_buffer.h
   haiku/trunk/src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp
   haiku/trunk/src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp
   haiku/trunk/src/add-ons/kernel/network/devices/loopback/loopback.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/icmp/icmp.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/multicast.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/tcp/EndpointManager.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp
   haiku/trunk/src/add-ons/kernel/network/protocols/udp/udp.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/datalink.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/net_buffer.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp
   haiku/trunk/src/add-ons/kernel/network/stack/routes.cpp
Log:
net_buffer: preparing for better metadata management


Modified: haiku/trunk/headers/private/net/NetUtilities.h
===================================================================
--- haiku/trunk/headers/private/net/NetUtilities.h	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/headers/private/net/NetUtilities.h	2007-05-23 03:48:23 UTC (rev 21210)
@@ -88,8 +88,8 @@
 	net_buffer_module_info *bufferModule, net_buffer *buffer, uint16 protocol)
 {
 	Checksum checksum;
-	addressModule-&gt;checksum_address(&amp;checksum, (sockaddr *)&amp;buffer-&gt;source);
-	addressModule-&gt;checksum_address(&amp;checksum, (sockaddr *)&amp;buffer-&gt;destination);
+	addressModule-&gt;checksum_address(&amp;checksum, buffer-&gt;source);
+	addressModule-&gt;checksum_address(&amp;checksum, buffer-&gt;destination);
 	checksum &lt;&lt; (uint16)htons(protocol) &lt;&lt; (uint16)htons(buffer-&gt;size)
 		&lt;&lt; Checksum::BufferHelper(buffer, bufferModule);
 	return checksum;

Modified: haiku/trunk/headers/private/net/net_buffer.h
===================================================================
--- haiku/trunk/headers/private/net/net_buffer.h	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/headers/private/net/net_buffer.h	2007-05-23 03:48:23 UTC (rev 21210)
@@ -19,8 +19,9 @@
 
 	// TODO: we should think about moving the address fields into the buffer data itself
 	//	via associated data or something like this. Or this structure as a whole, too...
-	struct sockaddr_storage source;
-	struct sockaddr_storage destination;
+
+	struct sockaddr *source;
+	struct sockaddr *destination;
 	struct net_interface *interface;
 	union {
 		struct {

Modified: haiku/trunk/src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/datalink_protocols/arp/arp.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -241,7 +241,7 @@
 
 		TRACE((&quot;  ARP Dequeing packet %p...\n&quot;, buffer));
 
-		memcpy(&amp;buffer-&gt;destination, &amp;hardware_address,
+		memcpy(buffer-&gt;destination, &amp;hardware_address,
 			hardware_address.sdl_len);
 		protocol-&gt;next-&gt;module-&gt;send_data(protocol-&gt;next, buffer);
 	}
@@ -375,7 +375,7 @@
 	BenaphoreLocker locker(sCacheLock);
 
 	if (!sIgnoreReplies) {
-		arp_update_entry(header.protocol_sender, (sockaddr_dl *)&amp;buffer-&gt;source, 0);
+		arp_update_entry(header.protocol_sender, (sockaddr_dl *)buffer-&gt;source, 0);
 			// remember the address of the sender as we might need it later
 	}
 
@@ -401,9 +401,9 @@
 	header.protocol_sender = entry-&gt;protocol_address;
 
 	// exchange source and destination address
-	memcpy(LLADDR((sockaddr_dl *)&amp;buffer-&gt;source), header.hardware_sender,
+	memcpy(LLADDR((sockaddr_dl *)buffer-&gt;source), header.hardware_sender,
 		ETHER_ADDRESS_LENGTH);
-	memcpy(LLADDR((sockaddr_dl *)&amp;buffer-&gt;destination), header.hardware_target,
+	memcpy(LLADDR((sockaddr_dl *)buffer-&gt;destination), header.hardware_target,
 		ETHER_ADDRESS_LENGTH);
 
 	buffer-&gt;flags = 0;
@@ -420,7 +420,7 @@
 		return;
 
 	BenaphoreLocker locker(sCacheLock);
-	arp_update_entry(header.protocol_sender, (sockaddr_dl *)&amp;buffer-&gt;source, 0);
+	arp_update_entry(header.protocol_sender, (sockaddr_dl *)buffer-&gt;source, 0);
 }
 
 
@@ -602,7 +602,7 @@
 
 	// prepare source and target addresses
 
-	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)&amp;entry-&gt;request_buffer-&gt;source;
+	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)entry-&gt;request_buffer-&gt;source;
 	source.sdl_len = sizeof(sockaddr_dl);
 	source.sdl_family = AF_DLI;
 	source.sdl_index = device-&gt;index;
@@ -807,26 +807,26 @@
 		// TODO: this could be cached - the lookup isn't really needed at all
 
 		arp_entry *entry = arp_entry::Lookup(
-			((struct sockaddr_in *)&amp;buffer-&gt;source)-&gt;sin_addr.s_addr);
+			((struct sockaddr_in *)buffer-&gt;source)-&gt;sin_addr.s_addr);
 		if (entry == NULL)
 			return B_ERROR;
 
-		memcpy(&amp;buffer-&gt;source, &amp;entry-&gt;hardware_address,
+		memcpy(buffer-&gt;source, &amp;entry-&gt;hardware_address,
 			entry-&gt;hardware_address.sdl_len);
 
 		if (buffer-&gt;flags &amp; MSG_MCAST) {
 			sockaddr_dl multicastDestination;
 			ipv4_to_ether_multicast(&amp;multicastDestination,
-				(sockaddr_in *)&amp;buffer-&gt;destination);
-			memcpy(&amp;buffer-&gt;destination, &amp;multicastDestination,
+				(sockaddr_in *)buffer-&gt;destination);
+			memcpy(buffer-&gt;destination, &amp;multicastDestination,
 				sizeof(multicastDestination));
 		} else if ((buffer-&gt;flags &amp; MSG_BCAST) == 0) {
 			// Lookup destination (we may need to wait for this)
 			entry = arp_entry::Lookup(
-				((struct sockaddr_in *)&amp;buffer-&gt;destination)-&gt;sin_addr.s_addr);
+				((struct sockaddr_in *)buffer-&gt;destination)-&gt;sin_addr.s_addr);
 			if (entry == NULL) {
 				status_t status = arp_start_resolve(protocol,
-					((struct sockaddr_in *)&amp;buffer-&gt;destination)-&gt;sin_addr.s_addr, &amp;entry);
+					((struct sockaddr_in *)buffer-&gt;destination)-&gt;sin_addr.s_addr, &amp;entry);
 				if (status &lt; B_OK)
 					return status;
 			}
@@ -841,7 +841,7 @@
 				return B_OK;
 			}
 
-			memcpy(&amp;buffer-&gt;destination, &amp;entry-&gt;hardware_address,
+			memcpy(buffer-&gt;destination, &amp;entry-&gt;hardware_address,
 				entry-&gt;hardware_address.sdl_len);
 		}
 	}

Modified: haiku/trunk/src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/datalink_protocols/ethernet_frame/ethernet_frame.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -45,8 +45,8 @@
 	ether_header &amp;header = bufferHeader.Data();
 	uint16 type = ntohs(header.type);
 
-	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)&amp;buffer-&gt;source;
-	struct sockaddr_dl &amp;destination = *(struct sockaddr_dl *)&amp;buffer-&gt;destination;
+	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)buffer-&gt;source;
+	struct sockaddr_dl &amp;destination = *(struct sockaddr_dl *)buffer-&gt;destination;
 
 	source.sdl_len = sizeof(sockaddr_dl);
 	source.sdl_family = AF_DLI;
@@ -119,8 +119,8 @@
 ethernet_frame_send_data(net_datalink_protocol *protocol,
 	net_buffer *buffer)
 {
-	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)&amp;buffer-&gt;source;
-	struct sockaddr_dl &amp;destination = *(struct sockaddr_dl *)&amp;buffer-&gt;destination;
+	struct sockaddr_dl &amp;source = *(struct sockaddr_dl *)buffer-&gt;source;
+	struct sockaddr_dl &amp;destination = *(struct sockaddr_dl *)buffer-&gt;destination;
 
 	if (source.sdl_family != AF_DLI || source.sdl_type != IFT_ETHER)
 		return B_ERROR;

Modified: haiku/trunk/src/add-ons/kernel/network/devices/loopback/loopback.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/devices/loopback/loopback.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/devices/loopback/loopback.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -13,6 +13,7 @@
 
 #include &lt;KernelExport.h&gt;
 
+#include &lt;algorithm&gt;
 #include &lt;net/if.h&gt;
 #include &lt;net/if_types.h&gt;
 #include &lt;net/if_media.h&gt;
@@ -157,9 +158,8 @@
 	if (status &lt; B_OK)
 		return status;
 
-	// switch network addresses before delivering
-	swap_memory(&amp;buffer-&gt;source, &amp;buffer-&gt;destination,
-		max_c(buffer-&gt;source.ss_len, buffer-&gt;destination.ss_len));
+	// swap network addresses before delivering
+	std::swap(buffer-&gt;source, buffer-&gt;destination);
 
 	*_buffer = buffer;
 	return B_OK;

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/icmp/icmp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/icmp/icmp.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/icmp/icmp.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -15,6 +15,7 @@
 #include &lt;KernelExport.h&gt;
 #include &lt;util/list.h&gt;
 
+#include &lt;algorithm&gt;
 #include &lt;netinet/in.h&gt;
 #include &lt;new&gt;
 #include &lt;stdlib.h&gt;
@@ -254,7 +255,7 @@
 			if (buffer-&gt;interface != NULL)
 				domain = buffer-&gt;interface-&gt;domain;
 			else
-				domain = sStackModule-&gt;get_domain(buffer-&gt;source.ss_family);
+				domain = sStackModule-&gt;get_domain(buffer-&gt;source-&gt;sa_family);
 			if (domain == NULL || domain-&gt;module == NULL)
 				break;
 
@@ -262,9 +263,7 @@
 			if (reply == NULL)
 				return B_NO_MEMORY;
 
-			// switch source/destination address
-			memcpy(&amp;reply-&gt;source, &amp;buffer-&gt;destination, buffer-&gt;destination.ss_len);
-			memcpy(&amp;reply-&gt;destination, &amp;buffer-&gt;source, buffer-&gt;source.ss_len);
+			std::swap(reply-&gt;source, reply-&gt;destination);
 
 			// There already is an ICMP header, and we'll reuse it
 			NetBufferHeaderReader&lt;icmp_header&gt; header(reply);

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/ipv4.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -646,7 +646,7 @@
 
 	BenaphoreLocker _(sMulticastGroupsLock);
 
-	sockaddr_in *multicastAddr = (sockaddr_in *)&amp;buffer-&gt;destination;
+	sockaddr_in *multicastAddr = (sockaddr_in *)buffer-&gt;destination;
 
 	MulticastState::ValueIterator it = sMulticastState-&gt;Lookup(std::make_pair(
 		&amp;multicastAddr-&gt;sin_addr, buffer-&gt;interface-&gt;index));
@@ -769,13 +769,14 @@
 }
 
 
-static inline void
+static inline sockaddr *
 fill_sockaddr_in(sockaddr_in *target, in_addr_t address)
 {
 	memset(target, 0, sizeof(sockaddr_in));
 	target-&gt;sin_family = AF_INET;
 	target-&gt;sin_len = sizeof(sockaddr_in);
 	target-&gt;sin_addr.s_addr = address;
+	return (sockaddr *)target;
 }
 
 
@@ -867,13 +868,8 @@
 get_multicast_interface(ipv4_protocol *protocol, const in_addr *address)
 {
 	sockaddr_in groupAddr;
-	memset(&amp;groupAddr, 0, sizeof(groupAddr));
-	groupAddr.sin_family = AF_INET;
-	if (address)
-		groupAddr.sin_addr = *address;
-
 	net_route *route = sDatalinkModule-&gt;get_route(sDomain,
-		(sockaddr *)&amp;groupAddr);
+		fill_sockaddr_in(&amp;groupAddr, address ? address-&gt;s_addr : INADDR_ANY));
 	if (route == NULL)
 		return NULL;
 
@@ -891,10 +887,8 @@
 		interface = get_multicast_interface(protocol, groupAddr);
 	} else {
 		sockaddr_in address;
-		fill_sockaddr_in(&amp;address, interfaceAddr-&gt;s_addr);
-
 		interface = sDatalinkModule-&gt;get_interface_with_address(sDomain,
-			(sockaddr *)&amp;address);
+			fill_sockaddr_in(&amp;address, interfaceAddr-&gt;s_addr));
 	}
 
 	if (interface == NULL)
@@ -1255,8 +1249,8 @@
 	TRACE_SK(protocol, &quot;SendRoutedData(%p, %p [%ld bytes])&quot;, route, buffer,
 		buffer-&gt;size);
 
-	sockaddr_in &amp;source = *(sockaddr_in *)&amp;buffer-&gt;source;
-	sockaddr_in &amp;destination = *(sockaddr_in *)&amp;buffer-&gt;destination;
+	sockaddr_in &amp;source = *(sockaddr_in *)buffer-&gt;source;
+	sockaddr_in &amp;destination = *(sockaddr_in *)buffer-&gt;destination;
 
 	bool headerIncluded = false, checksumNeeded = true;
 	if (protocol != NULL)
@@ -1348,8 +1342,8 @@
 		if (buffer-&gt;size &lt; sizeof(ipv4_header))
 			return EINVAL;
 
-		sockaddr_in *source = (sockaddr_in *)&amp;buffer-&gt;source;
-		sockaddr_in *destination = (sockaddr_in *)&amp;buffer-&gt;destination;
+		sockaddr_in *source = (sockaddr_in *)buffer-&gt;source;
+		sockaddr_in *destination = (sockaddr_in *)buffer-&gt;destination;
 
 		fill_sockaddr_in(source, *NetBufferField&lt;in_addr_t,
 			offsetof(ipv4_header, source)&gt;(buffer));
@@ -1445,8 +1439,8 @@
 	if (gBufferModule-&gt;checksum(buffer, 0, headerLength, true) != 0)
 		return B_BAD_DATA;
 
-	struct sockaddr_in &amp;source = *(struct sockaddr_in *)&amp;buffer-&gt;source;
-	struct sockaddr_in &amp;destination = *(struct sockaddr_in *)&amp;buffer-&gt;destination;
+	struct sockaddr_in &amp;source = *(struct sockaddr_in *)buffer-&gt;source;
+	struct sockaddr_in &amp;destination = *(struct sockaddr_in *)buffer-&gt;destination;
 
 	fill_sockaddr_in(&amp;source, header.source);
 	fill_sockaddr_in(&amp;destination, header.destination);

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/multicast.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/multicast.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/ipv4/multicast.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -133,7 +133,7 @@
 MulticastGroupInterface&lt;Addressing&gt;::FilterAccepts(net_buffer *buffer) const
 {
 	bool has = fAddresses.Has(Addressing::AddressFromSockAddr(
-		(sockaddr *)&amp;buffer-&gt;source));
+		buffer-&gt;source));
 
 	return (has &amp;&amp; fFilterMode == kInclude)
 		|| (!has &amp;&amp; fFilterMode == kExclude);

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/tcp/EndpointManager.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/tcp/EndpointManager.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/tcp/EndpointManager.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -386,10 +386,8 @@
 	if (reply == NULL)
 		return B_NO_MEMORY;
 
-	AddressModule()-&gt;set_to((sockaddr *)&amp;reply-&gt;source,
-		(sockaddr *)&amp;buffer-&gt;destination);
-	AddressModule()-&gt;set_to((sockaddr *)&amp;reply-&gt;destination,
-		(sockaddr *)&amp;buffer-&gt;source);
+	AddressModule()-&gt;set_to(reply-&gt;source, buffer-&gt;destination);
+	AddressModule()-&gt;set_to(reply-&gt;destination, buffer-&gt;source);
 
 	tcp_segment_header outSegment(TCP_FLAG_RESET);
 	outSegment.sequence = 0;

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/tcp/TCPEndpoint.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -48,7 +48,7 @@
 // Forward RTO-Recovery, RFC 4138
 
 #define PrintAddress(address) \
-	AddressString(Domain(), (const sockaddr *)(address), true).Data()
+	AddressString(Domain(), address, true).Data()
 
 //#define TRACE_TCP
 //#define PROBE_TCP
@@ -64,8 +64,8 @@
 #ifdef PROBE_TCP
 #	define PROBE(buffer, window) \
 	dprintf(&quot;TCP PROBE %llu %s %s %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %llu\n&quot;, \
-		system_time(), PrintAddress(&amp;buffer-&gt;source), \
-		PrintAddress(&amp;buffer-&gt;destination), buffer-&gt;size, (uint32)fSendNext, \
+		system_time(), PrintAddress(buffer-&gt;source), \
+		PrintAddress(buffer-&gt;destination), buffer-&gt;size, (uint32)fSendNext, \
 		(uint32)fSendUnacknowledged, fCongestionWindow, fSlowStartThreshold, \
 		window, fSendWindow, (uint32)(fSendMax - fSendUnacknowledged), \
 		fSendQueue.Available(fSendNext), fSendQueue.Used(), fRetransmitTimeout)
@@ -852,8 +852,8 @@
 	fState = SYNCHRONIZE_RECEIVED;
 	fManager = parent-&gt;fManager;
 
-	LocalAddress().SetTo(&amp;buffer-&gt;destination);
-	PeerAddress().SetTo(&amp;buffer-&gt;source);
+	LocalAddress().SetTo(buffer-&gt;destination);
+	PeerAddress().SetTo(buffer-&gt;source);
 
 	TRACE(&quot;Spawn()&quot;);
 
@@ -958,8 +958,8 @@
 	RecursiveLocker locker(fLock);
 
 	TRACE(&quot;SegmentReceived(): buffer %p (%lu bytes) address %s to %s&quot;,
-		buffer, buffer-&gt;size, PrintAddress(&amp;buffer-&gt;source),
-		PrintAddress(&amp;buffer-&gt;destination));
+		buffer, buffer-&gt;size, PrintAddress(buffer-&gt;source),
+		PrintAddress(buffer-&gt;destination));
 	TRACE(&quot;                   flags 0x%x, seq %lu, ack %lu, wnd %lu&quot;,
 		segment.flags, segment.sequence, segment.acknowledge,
 		(uint32)segment.advertised_window &lt;&lt; fSendWindowShift);
@@ -1241,15 +1241,15 @@
 			return status;
 		}
 
-		LocalAddress().CopyTo(&amp;buffer-&gt;source);
-		PeerAddress().CopyTo(&amp;buffer-&gt;destination);
+		LocalAddress().CopyTo(buffer-&gt;source);
+		PeerAddress().CopyTo(buffer-&gt;destination);
 
 		uint32 size = buffer-&gt;size;
 		segment.sequence = fSendNext;
 
 		TRACE(&quot;SendQueued(): buffer %p (%lu bytes) address %s to %s&quot;,
-			buffer, buffer-&gt;size, PrintAddress(&amp;buffer-&gt;source),
-			PrintAddress(&amp;buffer-&gt;destination));
+			buffer, buffer-&gt;size, PrintAddress(buffer-&gt;source),
+			PrintAddress(buffer-&gt;destination));
 		TRACE(&quot;              flags 0x%x, seq %lu, ack %lu, rwnd %hu, cwnd %lu&quot;
 			&quot;, ssthresh %lu&quot;, segment.flags, segment.sequence,
 			segment.acknowledge, segment.advertised_window,

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/tcp/tcp.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -206,8 +206,8 @@
 
 	tcp_header &amp;header = bufferHeader.Data();
 
-	header.source_port = addressModule-&gt;get_port((sockaddr *)&amp;buffer-&gt;source);
-	header.destination_port = addressModule-&gt;get_port((sockaddr *)&amp;buffer-&gt;destination);
+	header.source_port = addressModule-&gt;get_port(buffer-&gt;source);
+	header.destination_port = addressModule-&gt;get_port(buffer-&gt;destination);
 	header.sequence = htonl(segment.sequence);
 	header.acknowledge = (segment.flags &amp; TCP_FLAG_ACKNOWLEDGE)
 		? htonl(segment.acknowledge) : 0;
@@ -614,13 +614,12 @@
 			IPPROTO_TCP) != 0)
 		return B_BAD_DATA;
 
-	addressModule-&gt;set_port((sockaddr *)&amp;buffer-&gt;source, header.source_port);
-	addressModule-&gt;set_port((sockaddr *)&amp;buffer-&gt;destination,
-		header.destination_port);
+	addressModule-&gt;set_port(buffer-&gt;source, header.source_port);
+	addressModule-&gt;set_port(buffer-&gt;destination, header.destination_port);
 
 	TRACE((&quot;  Looking for: peer %s, local %s\n&quot;,
-		AddressString(domain, (sockaddr *)&amp;buffer-&gt;source, true).Data(),
-		AddressString(domain, (sockaddr *)&amp;buffer-&gt;destination, true).Data()));
+		AddressString(domain, buffer-&gt;source, true).Data(),
+		AddressString(domain, buffer-&gt;destination, true).Data()));
 	//dump_tcp_header(header);
 	//gBufferModule-&gt;dump(buffer);
 
@@ -643,7 +642,7 @@
 	int32 segmentAction = DROP;
 
 	TCPEndpoint *endpoint = endpointManager-&gt;FindConnection(
-		(sockaddr *)&amp;buffer-&gt;destination, (sockaddr *)&amp;buffer-&gt;source);
+		buffer-&gt;destination, buffer-&gt;source);
 	if (endpoint != NULL)
 		segmentAction = endpoint-&gt;SegmentReceived(segment, buffer);
 	else if ((segment.flags &amp; TCP_FLAG_RESET) == 0)

Modified: haiku/trunk/src/add-ons/kernel/network/protocols/udp/udp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/protocols/udp/udp.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/protocols/udp/udp.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -454,8 +454,8 @@
 status_t
 UdpDomainSupport::_DemuxBroadcast(net_buffer *buffer)
 {
-	sockaddr *peerAddr = (sockaddr *)&amp;buffer-&gt;source;
-	sockaddr *broadcastAddr = (sockaddr *)&amp;buffer-&gt;destination;
+	sockaddr *peerAddr = buffer-&gt;source;
+	sockaddr *broadcastAddr = buffer-&gt;destination;
 	sockaddr *mask = NULL;
 	if (buffer-&gt;interface)
 		mask = (sockaddr *)buffer-&gt;interface-&gt;mask;
@@ -501,8 +501,8 @@
 status_t
 UdpDomainSupport::_DemuxUnicast(net_buffer *buffer)
 {
-	struct sockaddr *peerAddr = (struct sockaddr *)&amp;buffer-&gt;source;
-	struct sockaddr *localAddr = (struct sockaddr *)&amp;buffer-&gt;destination;
+	struct sockaddr *peerAddr = buffer-&gt;source;
+	struct sockaddr *localAddr = buffer-&gt;destination;
 
 	TRACE_DOMAIN(&quot;_DemuxUnicast(%p)&quot;, buffer);
 
@@ -678,8 +678,8 @@
 	net_domain *domain = buffer-&gt;interface-&gt;domain;
 	net_address_module_info *addressModule = domain-&gt;address_module;
 
-	SocketAddress source(addressModule, &amp;buffer-&gt;source);
-	SocketAddress destination(addressModule, &amp;buffer-&gt;destination);
+	SocketAddress source(addressModule, buffer-&gt;source);
+	SocketAddress destination(addressModule, buffer-&gt;destination);
 
 	source.SetPort(header.source_port);
 	destination.SetPort(header.destination_port);
@@ -863,9 +863,8 @@
 	if (header.Status() &lt; B_OK)
 		return header.Status();
 
-	header-&gt;source_port = AddressModule()-&gt;get_port((sockaddr *)&amp;buffer-&gt;source);
-	header-&gt;destination_port = AddressModule()-&gt;get_port(
-		(sockaddr *)&amp;buffer-&gt;destination);
+	header-&gt;source_port = AddressModule()-&gt;get_port(buffer-&gt;source);
+	header-&gt;destination_port = AddressModule()-&gt;get_port(buffer-&gt;destination);
 	header-&gt;udp_length = htons(buffer-&gt;size);
 		// the udp-header is already included in the buffer-size
 	header-&gt;udp_checksum = 0;

Modified: haiku/trunk/src/add-ons/kernel/network/stack/datalink.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/datalink.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/stack/datalink.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -355,7 +355,7 @@
 		// instead of the destination address:
 		if (route-&gt;gateway == NULL)
 			return B_MISMATCHED_VALUES;
-		memcpy(&amp;buffer-&gt;destination, route-&gt;gateway, sizeof(sockaddr));
+		memcpy(buffer-&gt;destination, route-&gt;gateway, route-&gt;gateway-&gt;sa_len);
 	}
 
 	// this goes out to the datalink protocols

Modified: haiku/trunk/src/add-ons/kernel/network/stack/net_buffer.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/net_buffer.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/stack/net_buffer.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -62,6 +62,11 @@
 struct net_buffer_private : net_buffer {
 	struct list	buffers;
 	data_node	first_node;
+
+	struct {
+		struct sockaddr_storage source;
+		struct sockaddr_storage destination;
+	} storage;
 };
 
 
@@ -328,8 +333,12 @@
 	list_init(&amp;buffer-&gt;buffers);
 	list_add_item(&amp;buffer-&gt;buffers, &amp;buffer-&gt;first_node);
 
-	buffer-&gt;source.ss_len = 0;
-	buffer-&gt;destination.ss_len = 0;
+	buffer-&gt;source = (sockaddr *)&amp;buffer-&gt;storage.source;
+	buffer-&gt;destination = (sockaddr *)&amp;buffer-&gt;storage.destination;
+
+	buffer-&gt;storage.source.ss_len = 0;
+	buffer-&gt;storage.destination.ss_len = 0;
+
 	buffer-&gt;interface = NULL;
 	buffer-&gt;offset = 0;
 	buffer-&gt;flags = 0;
@@ -355,6 +364,22 @@
 }
 
 
+static void
+copy_metadata(net_buffer *destination, const net_buffer *source)
+{
+	memcpy(destination-&gt;source, source-&gt;source,
+		min_c(source-&gt;source-&gt;sa_len, sizeof(sockaddr_storage)));
+	memcpy(destination-&gt;destination, source-&gt;destination,
+		min_c(source-&gt;destination-&gt;sa_len, sizeof(sockaddr_storage)));
+
+	destination-&gt;flags = source-&gt;flags;
+	destination-&gt;interface = source-&gt;interface;
+	destination-&gt;offset = source-&gt;offset;
+	destination-&gt;size = source-&gt;size;
+	destination-&gt;protocol = source-&gt;protocol;
+}
+
+
 /*!	Creates a duplicate of the \a buffer. The new buffer does not share internal
 	storage; they are completely independent from each other.
 */
@@ -381,19 +406,8 @@
 			break;
 	}
 
-	// copy meta data from source buffer
+	copy_metadata(duplicate, buffer);
 
-	memcpy(&amp;duplicate-&gt;source, &amp;buffer-&gt;source,
-		min_c(buffer-&gt;source.ss_len, sizeof(sockaddr_storage)));
-	memcpy(&amp;duplicate-&gt;destination, &amp;buffer-&gt;destination,
-		min_c(buffer-&gt;destination.ss_len, sizeof(sockaddr_storage)));
-
-	duplicate-&gt;flags = buffer-&gt;flags;
-	duplicate-&gt;interface = buffer-&gt;interface;
-	duplicate-&gt;offset = buffer-&gt;offset;
-	duplicate-&gt;size = buffer-&gt;size;
-	duplicate-&gt;protocol = buffer-&gt;protocol;
-
 	return duplicate;
 }
 
@@ -423,6 +437,9 @@
 		return NULL;
 	}
 
+	clone-&gt;source = (sockaddr *)&amp;clone-&gt;storage.source;
+	clone-&gt;destination = (sockaddr *)&amp;clone-&gt;storage.destination;
+
 	list_init(&amp;clone-&gt;buffers);
 
 	// grab reference to this buffer - all additional nodes will get
@@ -465,19 +482,8 @@
 		}
 	}
 
-	// copy meta data from source buffer
+	copy_metadata(clone, buffer);
 
-	memcpy(&amp;clone-&gt;source, &amp;buffer-&gt;source,
-		min_c(buffer-&gt;source.ss_len, sizeof(sockaddr_storage)));
-	memcpy(&amp;clone-&gt;destination, &amp;buffer-&gt;destination,
-		min_c(buffer-&gt;destination.ss_len, sizeof(sockaddr_storage)));
-
-	clone-&gt;flags = buffer-&gt;flags;
-	clone-&gt;interface = buffer-&gt;interface;
-	clone-&gt;offset = buffer-&gt;offset;
-	clone-&gt;size = buffer-&gt;size;
-	clone-&gt;protocol = buffer-&gt;protocol;
-
 	return clone;
 }
 

Modified: haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/stack/net_socket.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -176,8 +176,8 @@
 		}
 	}
 
-	memcpy(&amp;buffer-&gt;source, &amp;socket-&gt;address, socket-&gt;address.ss_len);
-	memcpy(&amp;buffer-&gt;destination, &amp;socket-&gt;peer, socket-&gt;peer.ss_len);
+	memcpy(buffer-&gt;source, &amp;socket-&gt;address, socket-&gt;address.ss_len);
+	memcpy(buffer-&gt;destination, &amp;socket-&gt;peer, socket-&gt;peer.ss_len);
 	size_t size = buffer-&gt;size;
 
 	ssize_t bytesWritten = socket-&gt;first_info-&gt;send_data(socket-&gt;first_protocol,
@@ -840,8 +840,8 @@
 		}
 
 		if (header-&gt;msg_name != NULL) {
-			header-&gt;msg_namelen = min_c(nameLen, buffer-&gt;source.ss_len);
-			memcpy(header-&gt;msg_name, &amp;buffer-&gt;source, header-&gt;msg_namelen);
+			header-&gt;msg_namelen = min_c(nameLen, buffer-&gt;source-&gt;sa_len);
+			memcpy(header-&gt;msg_name, buffer-&gt;source, header-&gt;msg_namelen);
 		}
 	}
 
@@ -929,8 +929,8 @@
 	}
 
 	buffer-&gt;flags = flags;
-	memcpy(&amp;buffer-&gt;source, &amp;socket-&gt;address, socket-&gt;address.ss_len);
-	memcpy(&amp;buffer-&gt;destination, address, addressLength);
+	memcpy(buffer-&gt;source, &amp;socket-&gt;address, socket-&gt;address.ss_len);
+	memcpy(buffer-&gt;destination, address, addressLength);
 
 	status_t status = socket-&gt;first_info-&gt;send_data(socket-&gt;first_protocol,
 		buffer);

Modified: haiku/trunk/src/add-ons/kernel/network/stack/routes.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/network/stack/routes.cpp	2007-05-22 22:32:50 UTC (rev 21209)
+++ haiku/trunk/src/add-ons/kernel/network/stack/routes.cpp	2007-05-23 03:48:23 UTC (rev 21210)
@@ -542,13 +542,12 @@
 
 	BenaphoreLocker _(domain-&gt;lock);
 
-	net_route *route = get_route_internal(domain,
-		(sockaddr *)&amp;buffer-&gt;destination);
+	net_route *route = get_route_internal(domain, buffer-&gt;destination);
 	if (route == NULL)
 		return ENETUNREACH;
 
 	status_t status = B_OK;
-	sockaddr *source = (sockaddr *)&amp;buffer-&gt;source;
+	sockaddr *source = buffer-&gt;source;
 
 	// TODO we are quite relaxed in the address checking here
 	//      as we might proceed with srcaddr=INADDR_ANY.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002392.html">[Haiku-commits] r21209 - in haiku/trunk/src/add-ons/translators: .	hpgs hpgs/lib
</A></li>
	<LI>Next message: <A HREF="002395.html">[Haiku-commits] r21211 - in haiku/trunk: headers/private/net	src/add-ons/kernel/network/devices/loopback	src/add-ons/kernel/network/protocols/icmp	src/add-ons/kernel/network/protocols/tcp	src/add-ons/kernel/network/stack
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2394">[ date ]</a>
              <a href="thread.html#2394">[ thread ]</a>
              <a href="subject.html#2394">[ subject ]</a>
              <a href="author.html#2394">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
