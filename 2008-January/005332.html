<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23370 - in haiku/trunk: build/jam	headers/private/kernel headers/private/kernel/arch	headers/private/kernel/arch/x86 src/system/boot	src/system/boot/arch/m68k src/system/boot/arch/ppc	src/system/boot/arch/x86 src/system/kernel	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/fs src/system/kernel/lib	src/system/libroot/os src/system/libroot/os/arch/x86	src/system/libroot/posix/string	src/system/libroot/posix/string/arch/x86 src/tools/gensyscalls
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23370%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/kernel%20headers/private/kernel/arch%0A%09headers/private/kernel/arch/x86%20src/system/boot%0A%09src/system/boot/arch/m68k%20src/system/boot/arch/ppc%0A%09src/system/boot/arch/x86%20src/system/kernel%0A%09src/system/kernel/arch/x86%20src/system/kernel/debug%0A%09src/system/kernel/fs%20src/system/kernel/lib%0A%09src/system/libroot/os%20src/system/libroot/os/arch/x86%0A%09src/system/libroot/posix/string%0A%09src/system/libroot/posix/string/arch/x86%20src/tools/gensyscalls&In-Reply-To=%3C200801110036.m0B0alHi030804%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005331.html">
   <LINK REL="Next"  HREF="005333.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23370 - in haiku/trunk: build/jam	headers/private/kernel headers/private/kernel/arch	headers/private/kernel/arch/x86 src/system/boot	src/system/boot/arch/m68k src/system/boot/arch/ppc	src/system/boot/arch/x86 src/system/kernel	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/fs src/system/kernel/lib	src/system/libroot/os src/system/libroot/os/arch/x86	src/system/libroot/posix/string	src/system/libroot/posix/string/arch/x86 src/tools/gensyscalls</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23370%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/kernel%20headers/private/kernel/arch%0A%09headers/private/kernel/arch/x86%20src/system/boot%0A%09src/system/boot/arch/m68k%20src/system/boot/arch/ppc%0A%09src/system/boot/arch/x86%20src/system/kernel%0A%09src/system/kernel/arch/x86%20src/system/kernel/debug%0A%09src/system/kernel/fs%20src/system/kernel/lib%0A%09src/system/libroot/os%20src/system/libroot/os/arch/x86%0A%09src/system/libroot/posix/string%0A%09src/system/libroot/posix/string/arch/x86%20src/tools/gensyscalls&In-Reply-To=%3C200801110036.m0B0alHi030804%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23370 - in haiku/trunk: build/jam	headers/private/kernel headers/private/kernel/arch	headers/private/kernel/arch/x86 src/system/boot	src/system/boot/arch/m68k src/system/boot/arch/ppc	src/system/boot/arch/x86 src/system/kernel	src/system/kernel/arch/x86 src/system/kernel/debug	src/system/kernel/fs src/system/kernel/lib	src/system/libroot/os src/system/libroot/os/arch/x86	src/system/libroot/posix/string	src/system/libroot/posix/string/arch/x86 src/tools/gensyscalls">bonefish at mail.berlios.de
       </A><BR>
    <I>Fri Jan 11 01:36:47 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="005331.html">[Haiku-commits] r23369 -	haiku/trunk/src/system/boot/platform/atari_m68k
</A></li>
        <LI>Next message: <A HREF="005333.html">[Haiku-commits] r23371 - haiku/trunk/src/tests/system/benchmarks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5332">[ date ]</a>
              <a href="thread.html#5332">[ thread ]</a>
              <a href="subject.html#5332">[ subject ]</a>
              <a href="author.html#5332">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-01-11 01:36:44 +0100 (Fri, 11 Jan 2008)
New Revision: 23370
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23370&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23370&amp;view=rev</A>

Added:
   haiku/trunk/headers/private/kernel/arch/x86/arch_commpage.h
   haiku/trunk/headers/private/kernel/commpage.h
   haiku/trunk/src/system/kernel/arch/x86/arch_commpage.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_string.S
   haiku/trunk/src/system/kernel/arch/x86/asm_offsets.cpp
   haiku/trunk/src/system/kernel/commpage.cpp
Removed:
   haiku/trunk/headers/private/kernel/arch/x86/commpage.h
   haiku/trunk/src/system/kernel/arch/x86/commpage.c
Modified:
   haiku/trunk/build/jam/BuildSetup
   haiku/trunk/build/jam/KernelRules
   haiku/trunk/build/jam/MainBuildRules
   haiku/trunk/headers/private/kernel/arch/thread.h
   haiku/trunk/headers/private/kernel/arch/user_debugger.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_kernel.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_thread.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_thread_types.h
   haiku/trunk/headers/private/kernel/arch/x86/arch_user_debugger.h
   haiku/trunk/headers/private/kernel/ksyscalls.h
   haiku/trunk/headers/private/kernel/thread.h
   haiku/trunk/headers/private/kernel/thread_types.h
   haiku/trunk/headers/private/kernel/user_debugger.h
   haiku/trunk/src/system/boot/Jamfile
   haiku/trunk/src/system/boot/arch/m68k/Jamfile
   haiku/trunk/src/system/boot/arch/ppc/Jamfile
   haiku/trunk/src/system/boot/arch/x86/Jamfile
   haiku/trunk/src/system/kernel/Jamfile
   haiku/trunk/src/system/kernel/arch/x86/Jamfile
   haiku/trunk/src/system/kernel/arch/x86/arch_cpu.c
   haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp
   haiku/trunk/src/system/kernel/arch/x86/arch_int.c
   haiku/trunk/src/system/kernel/arch/x86/arch_interrupts.S
   haiku/trunk/src/system/kernel/arch/x86/arch_thread.c
   haiku/trunk/src/system/kernel/arch/x86/arch_user_debugger.cpp
   haiku/trunk/src/system/kernel/arch/x86/interrupts.h
   haiku/trunk/src/system/kernel/arch/x86/syscall.S
   haiku/trunk/src/system/kernel/debug/user_debugger.cpp
   haiku/trunk/src/system/kernel/fs/fd.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/kernel/lib/Jamfile
   haiku/trunk/src/system/kernel/main.c
   haiku/trunk/src/system/kernel/real_time_clock.c
   haiku/trunk/src/system/kernel/signal.cpp
   haiku/trunk/src/system/kernel/syscalls.c
   haiku/trunk/src/system/kernel/thread.cpp
   haiku/trunk/src/system/libroot/os/arch/x86/syscalls.inc
   haiku/trunk/src/system/libroot/os/time.c
   haiku/trunk/src/system/libroot/posix/string/Jamfile
   haiku/trunk/src/system/libroot/posix/string/arch/x86/arch_string.S
   haiku/trunk/src/tools/gensyscalls/gensyscalls.cpp
Log:
Merged branch haiku/branches/developer/bonefish/optimization revision
23139 into trunk, with roughly the following changes (for details svn
log the branch):
* The int 99 syscall handler is now fully in assembly.
* Added a sysenter/sysexit handler and use it on Pentiums that support
  it (via commpage).
* Got rid of i386_handle_trap(). A bit of functionality was moved into
  the assembly handler which now uses a jump table to call C functions
  handling the respective interrupt.
* Some optimizations to get user debugger support code out of the
  interrupt handling path.
* Introduced a thread::flags fields which allows to skip handling of
  rare events (signals, user debug enabling/disabling) on the
  common interrupt handling path.
* Got rid of the explicit iframe stack. The iframes can still be
  retrieved by iterating through the stack frames.
* Made the commpage an architecture independent feature. It's used for
  the real time data stuff (instead of creating a separate area).
* The x86 CPU modules can now provide processor optimized versions for
  common functions (currently memcpy() only). They are used in the
  kernel and are provided to the userland via commpage entries.
* Introduced build system feature allowing easy use of C structure
  member offsets in assembly code.

Changes after merging:
* Fixed merge conflict in src/system/kernel/arch/x86/arch_debug.cpp
  (caused by refactoring and introduction of &quot;call&quot; debugger command).



Modified: haiku/trunk/build/jam/BuildSetup
===================================================================
--- haiku/trunk/build/jam/BuildSetup	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/build/jam/BuildSetup	2008-01-11 00:36:44 UTC (rev 23370)
@@ -193,9 +193,10 @@
 HAIKU_C++FLAGS += -Wno-multichar ;
 
 HAIKU_KERNEL_CCFLAGS += -finline -fno-builtin -Wno-multichar
-	-DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) -D_KERNEL_MODE ;
+	-DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) ;
 HAIKU_KERNEL_C++FLAGS += -finline -fno-builtin -fno-exceptions -Wno-multichar
-	-DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) -D_KERNEL_MODE ;
+	-DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) ;
+HAIKU_KERNEL_DEFINES += _KERNEL_MODE ;
 
 if $(HAIKU_GCC_VERSION[1]) &gt;= 3 {
 	HAIKU_KERNEL_C++FLAGS += -fno-use-cxa-atexit ;
@@ -432,6 +433,7 @@
 	-DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) -D_KERNEL_MODE ;
 HOST_KERNEL_C++FLAGS += $(HOST_GCC_BASE_FLAGS) -finline -fno-builtin
 	-fno-exceptions -DBOCHS_DEBUG_HACK=$(BOCHS_DEBUG_HACK) -D_KERNEL_MODE ;
+HOST_KERNEL_DEFINES += _KERNEL_MODE ;
 
 HOST_KERNEL_PIC_CCFLAGS = -fno-pic ;
 HOST_KERNEL_PIC_LINKFLAGS = ;
@@ -647,6 +649,7 @@
 
 	HDRS CPPFLAGS CCFLAGS C++FLAGS LDFLAGS LINK LINKFLAGS DEFINES
 	ARFLAGS UNARFLAGS
+	KERNEL_DEFINES
 
 	KERNEL_CCFLAGS KERNEL_C++FLAGS
 	KERNEL_PIC_CCFLAGS KERNEL_PIC_LINKFLAGS

Modified: haiku/trunk/build/jam/KernelRules
===================================================================
--- haiku/trunk/build/jam/KernelRules	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/build/jam/KernelRules	2008-01-11 00:36:44 UTC (rev 23370)
@@ -20,6 +20,7 @@
 		# add kernel flags for the object
 		ObjectCcFlags $(object) : $(TARGET_KERNEL_CCFLAGS) $(2) ;
 		ObjectC++Flags $(object) : $(TARGET_KERNEL_C++FLAGS) $(2) ;
+		ObjectDefines $(object) : $(TARGET_KERNEL_DEFINES) ;
 
 		# override warning flags
 		TARGET_WARNING_CCFLAGS on $(object) = $(TARGET_KERNEL_WARNING_CCFLAGS) ;

Modified: haiku/trunk/build/jam/MainBuildRules
===================================================================
--- haiku/trunk/build/jam/MainBuildRules	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/build/jam/MainBuildRules	2008-01-11 00:36:44 UTC (rev 23370)
@@ -212,7 +212,119 @@
 	$(LINK) $(LINKFLAGS) -o &quot;$(1)&quot; &quot;$(2)&quot; &quot;$(NEEDLIBS)&quot; $(LINKLIBS)
 }
 
+rule CreateAsmStructOffsetsHeader header : source
+{
+	# CreateAsmStructOffsetsHeader header : source
+	#
+	# Grist will be added to both header and source.
 
+	header = [ FGristFiles $(header) ] ;
+	source = [ FGristFiles $(source) ] ;
+
+	# find out which headers, defines, etc. to use
+	local headers ;
+	local sysHeaders ;
+	local defines ;
+	local flags ;
+	local includesSeparator ;
+	local localIncludesOption ;
+	local systemIncludesOption ;
+	
+	on $(header) { # use on $(1) variable values
+		if ! $(PLATFORM) in $(SUPPORTED_PLATFORMS) {
+			return ;
+		}
+
+		# headers and defines
+		headers = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;
+		sysHeaders = $(SUBDIRSYSHDRS) $(SYSHDRS) ;
+		defines = $(DEFINES) ;
+
+		if $(PLATFORM) = host {
+			sysHeaders += $(HOST_HDRS) ;
+			defines += $(HOST_DEFINES) ;
+	
+			if $(USES_BE_API) {
+				sysHeaders += $(HOST_BE_API_HEADERS) ;
+			}
+	
+		} else {
+			sysHeaders += $(TARGET_HDRS) ;
+			defines += $(TARGET_DEFINES) ;
+		}
+
+		# optimization flags
+		if $(DEBUG) = 0 {
+			flags += $(OPTIM) ;
+		} else {
+			flags += -O0 ;
+		}
+	
+		if $(PLATFORM) = host {
+			# warning flags
+			if $(WARNINGS) != 0 {
+				flags += $(HOST_WARNING_C++FLAGS) ;
+			}
+	
+			# debug and other flags
+			flags += $(HOST_C++FLAGS) $(HOST_DEBUG_$(DEBUG)_C++FLAGS)
+				$(SUBDIRC++FLAGS) $(C++FLAGS) ;
+		
+			if $(USES_BE_API) {
+				flags += $(HOST_BE_API_C++FLAGS) ;
+			}
+	
+			C++ on $(header) = $(HOST_C++) ;
+		
+			includesSeparator = $(HOST_INCLUDES_SEPARATOR) ;
+			localIncludesOption = $(HOST_LOCAL_INCLUDES_OPTION) ;
+			systemIncludesOption = $(HOST_SYSTEM_INCLUDES_OPTION) ;
+
+		} else {
+			# warning flags
+			if $(WARNINGS) != 0 {
+				flags += $(TARGET_WARNING_C++FLAGS) ;
+			}
+	
+			# debug and other flags
+			flags += $(TARGET_C++FLAGS) $(TARGET_DEBUG_$(DEBUG)_C++FLAGS)
+				$(SUBDIRC++FLAGS) $(C++FLAGS) ;
+	
+			C++ on $(header) = $(TARGET_C++) ;
+
+			includesSeparator = $(TARGET_INCLUDES_SEPARATOR) ;
+			localIncludesOption = $(TARGET_LOCAL_INCLUDES_OPTION) ;
+			systemIncludesOption = $(TARGET_SYSTEM_INCLUDES_OPTION) ;
+		}
+	}
+
+	# locate object, search for source, and set on target variables
+
+	Depends $(header) : $(source) ;
+	SEARCH on $(source) += $(SEARCH_SOURCE) ;
+	MakeLocateArch $(header) ;
+	LocalClean clean : $(header) ;
+
+	HDRRULE on $(source) = HdrRule ;
+	HDRSCAN on $(source) = $(HDRPATTERN) ;
+	HDRSEARCH on $(source) = $(headers) $(sysHeaders) $(STDHDRS) ;
+	HDRGRIST on $(source) = $(HDRGRIST) ;
+
+	C++FLAGS on $(header) = $(flags) ;
+	CCHDRS on $(header) = [ FIncludes $(headers) : $(localIncludesOption) ]
+		$(includesSeparator)
+		[ FSysIncludes $(sysHeaders) : $(systemIncludesOption) ] ;
+	CCDEFS on $(header) = [ FDefines $(defines) ] ;
+
+	CreateAsmStructOffsetsHeader1 $(header) : $(source) ;
+}
+
+actions CreateAsmStructOffsetsHeader1
+{
+ 	$(C++) -S &quot;$(2)&quot; $(C++FLAGS) $(CCDEFS) $(CCHDRS) -o - \
+		| grep &quot;#define&quot; | sed -e 's/\$//' &gt; &quot;$(1)&quot;
+}
+
 rule MergeObjectFromObjects
 {
 	# MergeObjectFromObjects &lt;name&gt; : &lt;objects&gt; : &lt;other objects&gt; ;

Modified: haiku/trunk/headers/private/kernel/arch/thread.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/thread.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/thread.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -46,6 +46,9 @@
 void arch_store_fork_frame(struct arch_fork_arg *arg);
 void arch_restore_fork_frame(struct arch_fork_arg *arg);
 
+#define arch_syscall_64_bit_return_value()
+	// overridden by architectures that need special handling
+
 #ifdef __cplusplus
 }
 #endif

Modified: haiku/trunk/headers/private/kernel/arch/user_debugger.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/user_debugger.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/user_debugger.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -22,6 +22,8 @@
 void arch_clear_thread_debug_info(struct arch_thread_debug_info *info);
 void arch_destroy_thread_debug_info(struct arch_thread_debug_info *info);
 
+void arch_update_thread_single_step();
+
 void arch_set_debug_cpu_state(const struct debug_cpu_state *cpuState);
 void arch_get_debug_cpu_state(struct debug_cpu_state *cpuState);
 
@@ -29,6 +31,7 @@
 status_t arch_clear_breakpoint(void *address);
 status_t arch_set_watchpoint(void *address, uint32 type, int32 length);
 status_t arch_clear_watchpoint(void *address);
+bool arch_has_breakpoints(struct arch_team_debug_info *info);
 
 #if KERNEL_BREAKPOINTS
 status_t arch_set_kernel_breakpoint(void *address);

Copied: haiku/trunk/headers/private/kernel/arch/x86/arch_commpage.h (from rev 23365, haiku/branches/developer/bonefish/optimization/headers/private/kernel/arch/x86/arch_commpage.h)

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_cpu.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -9,14 +9,21 @@
 #define _KERNEL_ARCH_x86_CPU_H
 
 
+#ifndef _ASSEMBLER
+
 #include &lt;module.h&gt;
 #include &lt;arch/x86/descriptors.h&gt;
 
+#endif	// !_ASSEMBLER
 
+
 // MSR registers (possibly Intel specific)
 #define IA32_MSR_APIC_BASE				0x1b
 
 #define IA32_MSR_MTRR_CAPABILITIES		0xfe
+#define IA32_MSR_SYSENTER_CS			0x174
+#define IA32_MSR_SYSENTER_ESP			0x175
+#define IA32_MSR_SYSENTER_EIP			0x176
 #define IA32_MSR_MTRR_DEFAULT_TYPE		0x2ff
 #define IA32_MSR_MTRR_PHYSICAL_BASE_0	0x200
 #define IA32_MSR_MTRR_PHYSICAL_MASK_0	0x201
@@ -81,6 +88,20 @@
 #define IA32_MTR_WRITE_PROTECTED	5
 #define IA32_MTR_WRITE_BACK			6
 
+
+// iframe types
+#define IFRAME_TYPE_SYSCALL	0x1
+#define IFRAME_TYPE_OTHER	0x2
+#define IFRAME_TYPE_MASK	0xf
+
+
+#ifndef _ASSEMBLER
+
+typedef struct x86_optimized_functions {
+	void 	(*memcpy)(void* dest, const void* source, size_t count);
+	void*	memcpy_end;
+} x86_optimized_functions;
+
 typedef struct x86_cpu_module_info {
 	module_info	info;
 	uint32		(*count_mtrrs)(void);
@@ -89,6 +110,8 @@
 	void		(*set_mtrr)(uint32 index, uint64 base, uint64 length, uint8 type);
 	status_t	(*get_mtrr)(uint32 index, uint64 *_base, uint64 *_length,
 					uint8 *_type);
+
+	void		(*get_optimized_functions)(x86_optimized_functions* functions);
 } x86_cpu_module_info;
 
 
@@ -110,6 +133,7 @@
 };
 
 struct iframe {
+	uint32 type;	// iframe type
 	uint32 gs;
 	uint32 fs;
 	uint32 es;
@@ -277,5 +301,6 @@
 }	// extern &quot;C&quot; {
 #endif
 
+#endif	// !_ASSEMBLER
 
 #endif	/* _KERNEL_ARCH_x86_CPU_H */

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_kernel.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_kernel.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_kernel.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -5,7 +5,9 @@
 #ifndef _KERNEL_ARCH_x86_KERNEL_H
 #define _KERNEL_ARCH_x86_KERNEL_H
 
-#include &lt;arch/cpu.h&gt;
+#ifndef _ASSEMBLER
+#	include &lt;arch/cpu.h&gt;
+#endif
 
 // memory layout
 #define KERNEL_BASE 0x80000000

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_thread.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_thread.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_thread.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -16,15 +16,17 @@
 extern &quot;C&quot; {
 #endif
 
-void x86_push_iframe(struct iframe_stack *stack, struct iframe *frame);
-void x86_pop_iframe(struct iframe_stack *stack);
 struct iframe *i386_get_user_iframe(void);
 void *x86_next_page_directory(struct thread *from, struct thread *to);
 
 void i386_return_from_signal();
 void i386_end_return_from_signal();
 
+// override empty macro
+#undef arch_syscall_64_bit_return_value
+void arch_syscall_64_bit_return_value();
 
+
 static
 inline struct thread *
 arch_thread_get_current_thread(void)

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_thread_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_thread_types.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_thread_types.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -19,13 +19,6 @@
 	uint32 *ss;
 };
 
-#define	IFRAME_TRACE_DEPTH 4
-
-struct iframe_stack {
-	struct iframe *frames[IFRAME_TRACE_DEPTH];
-	int32	index;
-};
-
 // architecture specific thread info
 struct arch_thread {
 	struct farcall current_stack;
@@ -33,9 +26,6 @@
 
 	// 512 byte floating point save point - this must be 16 byte aligned
 	uint8 fpu_state[512];
-
-	// used to track interrupts on this thread
-	struct iframe_stack	iframes;
 } _ALIGNED(16);
 
 struct arch_team {

Modified: haiku/trunk/headers/private/kernel/arch/x86/arch_user_debugger.h
===================================================================
--- haiku/trunk/headers/private/kernel/arch/x86/arch_user_debugger.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/arch/x86/arch_user_debugger.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -5,7 +5,7 @@
 #ifndef _KERNEL_ARCH_X86_USER_DEBUGGER_H
 #define _KERNEL_ARCH_X86_USER_DEBUGGER_H
 
-#define ARCH_INIT_USER_DEBUG i386_init_user_debug
+#define ARCH_INIT_USER_DEBUG x86_init_user_debug
 
 // number of breakpoints the CPU supports
 // Actually it supports 4, but DR3 is used to hold the struct thread*.
@@ -94,11 +94,6 @@
 	X86_BREAKPOINT_LENGTH_4	= 0x3,
 };
 
-// thread debug flags
-enum {
-	X86_THREAD_DEBUG_DR7_SET			= 0x01,
-};
-
 struct arch_breakpoint {
 	void	*address;	// NULL, if deactivated
 	uint32	type;		// one of the architecture types above
@@ -122,14 +117,13 @@
 struct iframe;
 struct thread;
 
-extern void i386_init_user_debug_at_kernel_exit(struct iframe *frame);
-extern void i386_exit_user_debug_at_kernel_entry();
-extern void i386_reinit_user_debug_after_context_switch(struct thread *thread);
+extern void x86_init_user_debug_at_kernel_exit(struct iframe *frame);
+extern void x86_exit_user_debug_at_kernel_entry();
 
-extern int i386_handle_debug_exception(struct iframe *frame);
-extern int i386_handle_breakpoint_exception(struct iframe *frame);
+extern void x86_handle_debug_exception(struct iframe *frame);
+extern void x86_handle_breakpoint_exception(struct iframe *frame);
 
-extern void i386_init_user_debug();
+extern void x86_init_user_debug();
 
 #ifdef __cplusplus
 }

Deleted: haiku/trunk/headers/private/kernel/arch/x86/commpage.h

Copied: haiku/trunk/headers/private/kernel/commpage.h (from rev 23365, haiku/branches/developer/bonefish/optimization/headers/private/kernel/commpage.h)

Modified: haiku/trunk/headers/private/kernel/ksyscalls.h
===================================================================
--- haiku/trunk/headers/private/kernel/ksyscalls.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/ksyscalls.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -9,7 +9,7 @@
 #include &lt;SupportDefs.h&gt;
 
 
-typedef struct {
+typedef struct syscall_info {
 	void	*function;		// pointer to the syscall function
 	int		parameter_size;	// summed up parameter size
 } syscall_info;

Modified: haiku/trunk/headers/private/kernel/thread.h
===================================================================
--- haiku/trunk/headers/private/kernel/thread.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/thread.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -26,9 +26,10 @@
 struct thread *thread_dequeue(struct thread_queue *q);
 struct thread *thread_dequeue_id(struct thread_queue *q, thread_id id);
 
-void thread_at_kernel_entry(void);
+void thread_at_kernel_entry(bigtime_t now);
 	// called when the thread enters the kernel on behalf of the thread
 void thread_at_kernel_exit(void);
+void thread_at_kernel_exit_no_signals(void);
 void thread_reset_for_exec(void);
 
 status_t thread_init(struct kernel_args *args);
@@ -69,6 +70,8 @@
 status_t select_thread(int32 object, struct select_info *info, bool kernel);
 status_t deselect_thread(int32 object, struct select_info *info, bool kernel);
 
+#define syscall_64_bit_return_value() arch_syscall_64_bit_return_value()
+
 // used in syscalls.c
 status_t _user_set_thread_priority(thread_id thread, int32 newPriority);
 status_t _user_rename_thread(thread_id thread, const char *name);

Modified: haiku/trunk/headers/private/kernel/thread_types.h
===================================================================
--- haiku/trunk/headers/private/kernel/thread_types.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/thread_types.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -7,6 +7,7 @@
 #ifndef _KERNEL_THREAD_TYPES_H
 #define _KERNEL_THREAD_TYPES_H
 
+#ifndef _ASSEMBLER
 
 #include &lt;cbuf.h&gt;
 #include &lt;smp.h&gt;
@@ -182,6 +183,9 @@
 typedef int32 (*thread_entry_func)(thread_func, void *);
 
 struct thread {
+	int32			flags;			// summary of events relevant in interrupt
+									// handlers (signals pending, user debugging
+									// enabled, etc.)
 	struct thread	*all_next;
 	struct thread	*team_next;
 	struct thread	*queue_next;	/* i.e. run queue, release queue, etc. */
@@ -246,6 +250,7 @@
 	// stack
 	area_id			kernel_stack_area;
 	addr_t			kernel_stack_base;
+	addr_t			kernel_stack_top;
 	area_id			user_stack_area;
 	addr_t			user_stack_base;
 	size_t			user_stack_size;
@@ -268,4 +273,17 @@
 	struct thread *tail;
 };
 
+
+#endif	// !_ASSEMBLER
+
+
+// bits for the thread::flags field
+#define	THREAD_FLAGS_SIGNALS_PENDING		0x01
+#define	THREAD_FLAGS_DEBUG_THREAD			0x02
+#define	THREAD_FLAGS_DEBUGGER_INSTALLED		0x04
+#define	THREAD_FLAGS_BREAKPOINTS_DEFINED	0x08
+#define	THREAD_FLAGS_BREAKPOINTS_INSTALLED	0x10
+#define	THREAD_FLAGS_64_BIT_SYSCALL_RETURN	0x20
+
+
 #endif	/* _KERNEL_THREAD_TYPES_H */

Modified: haiku/trunk/headers/private/kernel/user_debugger.h
===================================================================
--- haiku/trunk/headers/private/kernel/user_debugger.h	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/headers/private/kernel/user_debugger.h	2008-01-11 00:36:44 UTC (rev 23370)
@@ -144,6 +144,7 @@
 
 void init_user_debug();
 
+
 // debug event callbacks
 
 void user_debug_pre_syscall(uint32 syscall, void *args);
@@ -155,6 +156,7 @@
 void user_debug_stop_thread();
 void user_debug_team_created(team_id teamID);
 void user_debug_team_deleted(team_id teamID, port_id debuggerPort);
+void user_debug_update_new_thread_flags(thread_id threadID);
 void user_debug_thread_created(thread_id threadID);
 void user_debug_thread_deleted(team_id teamID, thread_id threadID);
 void user_debug_image_created(const image_info *imageInfo);

Modified: haiku/trunk/src/system/boot/Jamfile
===================================================================
--- haiku/trunk/src/system/boot/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/boot/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -22,14 +22,8 @@
 	strchr.o
 	strrchr.o
 	strtol.o
-	arch_string.o
 ;
 
-local platformObjects = ;
-if $(TARGET_ARCH) = x86 {
-	platformObjects += &lt;src!system!kernel!arch!$(TARGET_ARCH)&gt;cpuid.o ;
-}
-
 AddResources zbeos : boot_loader.rdef ;
 
 KernelLd boot_loader_$(TARGET_BOOT_PLATFORM) :
@@ -50,9 +44,6 @@
 	# kernel)
 	$(librootFunctions:G=src!system!kernel!lib)
 
-	# platform specific objects
-	$(platformObjects)
-
 	: $(HAIKU_TOP)/src/system/ldscripts/$(TARGET_ARCH)/boot_loader_$(TARGET_BOOT_PLATFORM).ld
 	: -Bstatic
 ;

Modified: haiku/trunk/src/system/boot/arch/m68k/Jamfile
===================================================================
--- haiku/trunk/src/system/boot/arch/m68k/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/boot/arch/m68k/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -1,17 +1,14 @@
 SubDir HAIKU_TOP src system boot arch m68k ;
 
-{
-	local defines =
-		_BOOT_MODE
-	;
+DEFINES += _BOOT_MODE ;
 
-	defines = [ FDefines $(defines) ] ;
-	SubDirCcFlags $(defines) -Wall -Wno-multichar ;
-	SubDirC++Flags $(defines) -Wall -Wno-multichar -fno-rtti ;
-}
+local librootArchObjects =
+	&lt;src!system!libroot!posix!string!arch!$(TARGET_ARCH)&gt;arch_string.o
+;
 
 KernelMergeObject boot_arch_m68k.o :
 	arch_elf.cpp
+	$(librootArchObjects)
 ;
 
 SEARCH on [ FGristFiles arch_elf.cpp ]

Modified: haiku/trunk/src/system/boot/arch/ppc/Jamfile
===================================================================
--- haiku/trunk/src/system/boot/arch/ppc/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/boot/arch/ppc/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -1,17 +1,14 @@
 SubDir HAIKU_TOP src system boot arch ppc ;
 
-{
-	local defines =
-		_BOOT_MODE
-	;
+DEFINES += _BOOT_MODE ;
 
-	defines = [ FDefines $(defines) ] ;
-	SubDirCcFlags $(defines) -Wall -Wno-multichar ;
-	SubDirC++Flags $(defines) -Wall -Wno-multichar -fno-rtti ;
-}
+local librootArchObjects =
+	&lt;src!system!libroot!posix!string!arch!$(TARGET_ARCH)&gt;arch_string.o
+;
 
 KernelMergeObject boot_arch_ppc.o :
 	arch_elf.cpp
+	$(librootArchObjects)
 ;
 
 SEARCH on [ FGristFiles arch_elf.cpp ]

Modified: haiku/trunk/src/system/boot/arch/x86/Jamfile
===================================================================
--- haiku/trunk/src/system/boot/arch/x86/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/boot/arch/x86/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -1,18 +1,22 @@
 SubDir HAIKU_TOP src system boot arch x86 ;
 
-{
-	local defines =
-		_BOOT_MODE
-	;
+DEFINES += _BOOT_MODE ;
 
-	defines = [ FDefines $(defines) ] ;
-	SubDirCcFlags $(defines) -Wall -Wno-multichar ;
-	SubDirC++Flags $(defines) -Wall -Wno-multichar -fno-rtti ;
-}
+local kernelArchSources =
+	arch_elf.c
+	arch_string.S
+;
 
+local kernelArchObjects =
+	&lt;src!system!kernel!arch!$(TARGET_ARCH)&gt;cpuid.o
+;
+
 KernelMergeObject boot_arch_x86.o :
-	arch_elf.c
+	$(kernelArchSources)
+	: # additional flags
+	:
+	$(kernelArchObjects)
 ;
 
-SEARCH on [ FGristFiles arch_elf.c ]
+SEARCH on [ FGristFiles $(kernelArchSources) ]
     = [ FDirName $(HAIKU_TOP) src system kernel arch $(TARGET_ARCH) ] ;

Modified: haiku/trunk/src/system/kernel/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/kernel/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -16,6 +16,7 @@
 
 KernelMergeObject kernel_core.o :
 	boot_item.cpp
+	commpage.cpp
 	condition_variable.cpp
 	cpu.c
 	elf.cpp

Modified: haiku/trunk/src/system/kernel/arch/x86/Jamfile
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/Jamfile	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/kernel/arch/x86/Jamfile	2008-01-11 00:36:44 UTC (rev 23370)
@@ -11,6 +11,7 @@
 SEARCH_SOURCE += [ FDirName $(SUBDIR) $(DOTDOT) generic ] ;
 
 KernelStaticLibrary libx86 :
+	arch_commpage.cpp
 	arch_cpu.c
 	arch_debug.cpp
 	arch_debug_console.c
@@ -20,6 +21,7 @@
 #	arch_selector.c
 	arch_real_time_clock.c
 	arch_smp.c
+	arch_string.S
 	arch_thread.c
 	arch_timer.c
 	arch_vm.cpp
@@ -31,7 +33,6 @@
 	apm.cpp
 	bios.cpp
 	cpuid.S
-	commpage.c
 	syscall.S
 
 	generic_vm_physical_page_mapper.cpp
@@ -39,6 +40,10 @@
 	$(TARGET_KERNEL_PIC_CCFLAGS) -Wno-unused
 ;
 
+CreateAsmStructOffsetsHeader asm_offsets.h : asm_offsets.cpp ;
+
 # We need to specify the dependency on the generated syscalls file explicitly.
 Includes [ FGristFiles arch_x86.S arch_interrupts.S ]
 	: &lt;syscalls&gt;syscall_numbers.h ;
+Includes [ FGristFiles arch_interrupts.S ]
+	: &lt;syscalls&gt;syscall_table.h ;

Copied: haiku/trunk/src/system/kernel/arch/x86/arch_commpage.cpp (from rev 23365, haiku/branches/developer/bonefish/optimization/src/system/kernel/arch/x86/arch_commpage.cpp)

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_cpu.c
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_cpu.c	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_cpu.c	2008-01-11 00:36:44 UTC (rev 23370)
@@ -14,6 +14,7 @@
 #include &lt;stdio.h&gt;
 
 #include &lt;boot_device.h&gt;
+#include &lt;commpage.h&gt;
 #include &lt;smp.h&gt;
 #include &lt;tls.h&gt;
 #include &lt;vm.h&gt;
@@ -21,7 +22,6 @@
 #include &lt;arch_system_info.h&gt;
 #include &lt;arch/x86/selector.h&gt;
 #include &lt;boot/kernel_args.h&gt;
-#include &lt;arch/x86/commpage.h&gt;
 
 #include &quot;interrupts.h&quot;
 
@@ -76,6 +76,16 @@
 
 static x86_cpu_module_info *sCpuModule;
 
+
+extern void	memcpy_generic(void* dest, const void* source, size_t count);
+extern int	memcpy_generic_end;
+
+x86_optimized_functions gOptimizedFunctions = {
+	.memcpy		= memcpy_generic,
+	.memcpy_end	= &amp;memcpy_generic_end
+};
+
+
 /**	Disable CPU caches, and invalidate them. */
 
 static void
@@ -516,9 +526,6 @@
 	// setup SSE2/3 support
 	init_sse();
 
-	// initialize the commpage support
-	commpage_init();
-
 	return B_OK;
 }
 
@@ -545,6 +552,24 @@
 	if (x86_count_mtrrs() &gt; 0)
 		call_all_cpus(&amp;init_mtrrs, NULL);
 
+	// get optimized functions from the CPU module
+	if (sCpuModule != NULL &amp;&amp; sCpuModule-&gt;get_optimized_functions != NULL) {
+		x86_optimized_functions functions;
+		memset(&amp;functions, 0, sizeof(functions));
+
+		sCpuModule-&gt;get_optimized_functions(&amp;functions);
+
+		if (functions.memcpy != NULL) {
+			gOptimizedFunctions.memcpy = functions.memcpy;
+			gOptimizedFunctions.memcpy_end = functions.memcpy_end;
+		}
+	}
+
+	// put the optimized functions into the commpage
+	fill_commpage_entry(COMMPAGE_ENTRY_X86_MEMCPY, gOptimizedFunctions.memcpy,
+		(addr_t)gOptimizedFunctions.memcpy_end
+			- (addr_t)gOptimizedFunctions.memcpy);
+
 	return B_OK;
 }
 

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_debug.cpp	2008-01-11 00:36:44 UTC (rev 23370)
@@ -145,7 +145,7 @@
 
 static void
 setup_for_thread(char *arg, struct thread **_thread, uint32 *_ebp,
-	struct iframe_stack **_frameStack, uint32 *_oldPageDirectory)
+	uint32 *_oldPageDirectory)
 {
 	struct thread *thread = NULL;
 
@@ -180,21 +180,60 @@
 		thread = thread_get_current_thread();
 	}
 
-	// We don't have a thread pointer early in the boot process
-	if (thread != NULL)
-		*_frameStack = &amp;thread-&gt;arch_info.iframes;
-	else
-		*_frameStack = &gBootFrameStack;
-
 	*_thread = thread;
 }
 
 
+static bool
+is_kernel_stack_address(struct thread* thread, addr_t address)
+{
+	// We don't have a thread pointer in the early boot process, but then we are
+	// on the kernel stack for sure.
+	if (thread == NULL)
+		return IS_KERNEL_ADDRESS(address);
+
+	return address &gt;= thread-&gt;kernel_stack_base
+		&amp;&amp; address &lt; thread-&gt;kernel_stack_base + KERNEL_STACK_SIZE;
+}
+
+
+static bool
+is_iframe(struct thread* thread, addr_t frame)
+{
+	return is_kernel_stack_address(thread, frame)
+		&amp;&amp; (*(addr_t*)frame &amp; ~IFRAME_TYPE_MASK) == 0;
+}
+
+
+static struct iframe *
+find_previous_iframe(struct thread *thread, addr_t frame)
+{
+	// iterate backwards through the stack frames, until we hit an iframe
+	while (is_kernel_stack_address(thread, frame)) {
+		if (is_iframe(thread, frame))
+			return (struct iframe*)frame;
+
+		frame = *(addr_t*)frame;
+	}
+
+	return NULL;
+}
+
+
+static struct iframe*
+get_previous_iframe(struct thread* thread, struct iframe* frame)
+{
+	if (frame == NULL)
+		return NULL;
+
+	return find_previous_iframe(thread, frame-&gt;ebp);
+}
+
+
 static int
 stack_trace(int argc, char **argv)
 {
 	uint32 previousLocations[NUM_PREVIOUS_LOCATIONS];
-	struct iframe_stack *frameStack;
 	struct thread *thread = NULL;
 	addr_t oldPageDirectory = 0;
 	uint32 ebp = x86_read_ebp();
@@ -205,7 +244,7 @@
 		return 0;
 	}
 
-	setup_for_thread(argc == 2 ? argv[1] : NULL, &amp;thread, &amp;ebp, &amp;frameStack,
+	setup_for_thread(argc == 2 ? argv[1] : NULL, &amp;thread, &amp;ebp,
 		&amp;oldPageDirectory);
 
 	if (thread != NULL) {
@@ -224,18 +263,14 @@
 
 	kprintf(&quot;frame            caller     &lt;image&gt;:function + offset\n&quot;);
 
+	bool onKernelStack = true;
+
 	for (;;) {
-		bool isIFrame = false;
-		// see if the ebp matches the iframe
-		for (i = 0; i &lt; frameStack-&gt;index; i++) {
-			if (ebp == ((uint32)frameStack-&gt;frames[i] - 8)) {
-				// it's an iframe
-				isIFrame = true;
-			}
-		}
+		onKernelStack = onKernelStack
+			&amp;&amp; is_kernel_stack_address(thread, ebp);
 
-		if (isIFrame) {
-			struct iframe *frame = (struct iframe *)(ebp + 8);
+		if (onKernelStack &amp;&amp; is_iframe(thread, ebp)) {
+			struct iframe *frame = (struct iframe *)ebp;
 
 			print_iframe(frame);
 			print_stack_frame(thread, frame-&gt;eip, ebp, frame-&gt;ebp);
@@ -328,7 +363,6 @@
 static int
 show_call(int argc, char **argv)
 {
-	struct iframe_stack *frameStack;
 	struct thread *thread = NULL;
 	addr_t oldPageDirectory = 0;
 	uint32 ebp = x86_read_ebp();
@@ -348,7 +382,7 @@
 		return 0;
 	}
 
-	setup_for_thread(argc == 3 ? argv[1] : NULL, &amp;thread, &amp;ebp, &amp;frameStack,
+	setup_for_thread(argc == 3 ? argv[1] : NULL, &amp;thread, &amp;ebp,
 		&amp;oldPageDirectory);
 
 	int32 callIndex = strtoul(argv[argc == 3 ? 2 : 1], NULL, 0);
@@ -356,20 +390,15 @@
 	if (thread != NULL)
 		kprintf(&quot;thread %ld, %s\n&quot;, thread-&gt;id, thread-&gt;name);
 
-	int32 index = 1;
-	for (; index &lt;= callIndex; index++) {
-		bool isIFrame = false;
-		// see if the ebp matches the iframe
-		for (int32 i = 0; i &lt; frameStack-&gt;index; i++) {
-			if (ebp == ((uint32)frameStack-&gt;frames[i] - 8)) {
-				// it's an iframe
-				isIFrame = true;
-			}
-		}
+	bool onKernelStack = true;
 
-		if (isIFrame) {
-			struct iframe *frame = (struct iframe *)(ebp + 8);
+	for (int32 index = 1; index &lt;= callIndex; index++) {
+		onKernelStack = onKernelStack
+			&amp;&amp; is_kernel_stack_address(thread, ebp);
 
+		if (onKernelStack &amp;&amp; is_iframe(thread, ebp)) {
+			struct iframe *frame = (struct iframe *)ebp;
+
 			if (index == callIndex)
 				print_call(thread, frame-&gt;eip, ebp, argCount);
 
@@ -406,7 +435,6 @@
 static int
 dump_iframes(int argc, char **argv)
 {
-	struct iframe_stack *frameStack;
 	struct thread *thread = NULL;
 	int32 i;
 
@@ -424,17 +452,13 @@
 		return 0;
 	}
 
-	// We don't have a thread pointer early in the boot process
 	if (thread != NULL)
-		frameStack = &amp;thread-&gt;arch_info.iframes;
-	else
-		frameStack = &gBootFrameStack;
-
-	if (thread != NULL)
 		kprintf(&quot;iframes for thread 0x%lx \&quot;%s\&quot;\n&quot;, thread-&gt;id, thread-&gt;name);
 
-	for (i = 0; i &lt; frameStack-&gt;index; i++) {
-		print_iframe(frameStack-&gt;frames[i]);
+	struct iframe* frame = find_previous_iframe(thread, x86_read_ebp());
+	while (frame != NULL) {
+		print_iframe(frame);
+		frame = get_previous_iframe(thread, frame);
 	}
 
 	return 0;

Modified: haiku/trunk/src/system/kernel/arch/x86/arch_int.c
===================================================================
--- haiku/trunk/src/system/kernel/arch/x86/arch_int.c	2008-01-11 00:22:09 UTC (rev 23369)
+++ haiku/trunk/src/system/kernel/arch/x86/arch_int.c	2008-01-11 00:36:44 UTC (rev 23370)
@@ -99,8 +99,6 @@
 
 #define MAX_ARGS 16
 
-struct iframe_stack gBootFrameStack;
-
 typedef struct {
 	uint32 a, b;
 } desc_table;
@@ -109,7 +107,13 @@
 static uint16 sLevelTriggeredInterrupts;
 	// binary mask: 1 level, 0 edge
 
+// table with functions handling respective interrupts
+typedef void interrupt_handler_function(struct iframe* frame);
+#define INTERRUPT_HANDLER_TABLE_SIZE 256
+interrupt_handler_function* gInterruptHandlerTable[
+	INTERRUPT_HANDLER_TABLE_SIZE];
 
+
 static void
 set_gate(desc_table *gate_addr, addr_t addr, int type, int dpl)
 {
@@ -320,259 +324,192 @@
 
 
 static void
-fatal_exception(struct iframe *frame)
+invalid_exception(struct iframe* frame)
 {
+	struct thread* thread = thread_get_current_thread();
 	char name[32];
-	panic(&quot;Fatal exception \&quot;%s\&quot; occurred! Error code: 0x%lx\n&quot;,
-		exception_name(frame-&gt;vector, name, sizeof(name)), frame-&gt;error_code);
+	panic(&quot;unhandled trap 0x%lx (%s) at ip 0x%lx, thread 0x%lx!\n&quot;,
+		frame-&gt;vector, exception_name(frame-&gt;vector, name, sizeof(name)),
+		frame-&gt;eip, thread ? thread-&gt;id : -1);
 }
 
 

[... truncated: 2200 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005331.html">[Haiku-commits] r23369 -	haiku/trunk/src/system/boot/platform/atari_m68k
</A></li>
	<LI>Next message: <A HREF="005333.html">[Haiku-commits] r23371 - haiku/trunk/src/tests/system/benchmarks
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5332">[ date ]</a>
              <a href="thread.html#5332">[ thread ]</a>
              <a href="subject.html#5332">[ subject ]</a>
              <a href="author.html#5332">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
