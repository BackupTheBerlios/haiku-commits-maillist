<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r23754 - in haiku/trunk: build/jam	headers/private/graphics src/add-ons/accelerants/nvidia/engine	src/add-ons/accelerants/via/engine	src/add-ons/kernel/bus_managers/agp src/add-ons/kernel/busses	src/add-ons/kernel/busses/agp_gart	src/add-ons/kernel/drivers/graphics/intel_extreme	src/add-ons/kernel/drivers/graphics/nvidia	src/add-ons/kernel/drivers/graphics/radeon	src/add-ons/kernel/drivers/graphics/via
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-January/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23754%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/graphics%20src/add-ons/accelerants/nvidia/engine%0A%09src/add-ons/accelerants/via/engine%0A%09src/add-ons/kernel/bus_managers/agp%20src/add-ons/kernel/busses%0A%09src/add-ons/kernel/busses/agp_gart%0A%09src/add-ons/kernel/drivers/graphics/intel_extreme%0A%09src/add-ons/kernel/drivers/graphics/nvidia%0A%09src/add-ons/kernel/drivers/graphics/radeon%0A%09src/add-ons/kernel/drivers/graphics/via&In-Reply-To=%3C200801262218.m0QMIsmV000186%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="005790.html">
   <LINK REL="Next"  HREF="005792.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r23754 - in haiku/trunk: build/jam	headers/private/graphics src/add-ons/accelerants/nvidia/engine	src/add-ons/accelerants/via/engine	src/add-ons/kernel/bus_managers/agp src/add-ons/kernel/busses	src/add-ons/kernel/busses/agp_gart	src/add-ons/kernel/drivers/graphics/intel_extreme	src/add-ons/kernel/drivers/graphics/nvidia	src/add-ons/kernel/drivers/graphics/radeon	src/add-ons/kernel/drivers/graphics/via</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r23754%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/private/graphics%20src/add-ons/accelerants/nvidia/engine%0A%09src/add-ons/accelerants/via/engine%0A%09src/add-ons/kernel/bus_managers/agp%20src/add-ons/kernel/busses%0A%09src/add-ons/kernel/busses/agp_gart%0A%09src/add-ons/kernel/drivers/graphics/intel_extreme%0A%09src/add-ons/kernel/drivers/graphics/nvidia%0A%09src/add-ons/kernel/drivers/graphics/radeon%0A%09src/add-ons/kernel/drivers/graphics/via&In-Reply-To=%3C200801262218.m0QMIsmV000186%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r23754 - in haiku/trunk: build/jam	headers/private/graphics src/add-ons/accelerants/nvidia/engine	src/add-ons/accelerants/via/engine	src/add-ons/kernel/bus_managers/agp src/add-ons/kernel/busses	src/add-ons/kernel/busses/agp_gart	src/add-ons/kernel/drivers/graphics/intel_extreme	src/add-ons/kernel/drivers/graphics/nvidia	src/add-ons/kernel/drivers/graphics/radeon	src/add-ons/kernel/drivers/graphics/via">axeld at mail.berlios.de
       </A><BR>
    <I>Sat Jan 26 23:18:54 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="005790.html">[Haiku-commits] r23753 - in haiku/trunk:	headers/private/graphics/intel_extreme	src/add-ons/accelerants/intel_extreme	src/add-ons/kernel/drivers/graphics/intel_extreme
</A></li>
        <LI>Next message: <A HREF="005792.html">[Haiku-commits] r23755 - haiku/trunk/src/add-ons/kernel/generic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5791">[ date ]</a>
              <a href="thread.html#5791">[ thread ]</a>
              <a href="subject.html#5791">[ subject ]</a>
              <a href="author.html#5791">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-01-26 23:18:52 +0100 (Sat, 26 Jan 2008)
New Revision: 23754
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=23754&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=23754&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/busses/agp_gart/
   haiku/trunk/src/add-ons/kernel/busses/agp_gart/Jamfile
   haiku/trunk/src/add-ons/kernel/busses/agp_gart/intel_gart.cpp
Removed:
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/README.html
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/UPDATE.html
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.h
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.settings
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/module.cpp
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/headers/private/graphics/AGP.h
   haiku/trunk/src/add-ons/accelerants/nvidia/engine/nv_agp.c
   haiku/trunk/src/add-ons/accelerants/via/engine/agp.c
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/Jamfile
   haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.cpp
   haiku/trunk/src/add-ons/kernel/busses/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/graphics/intel_extreme/driver.cpp
   haiku/trunk/src/add-ons/kernel/drivers/graphics/nvidia/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/agp.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/driver.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/global_data.c
   haiku/trunk/src/add-ons/kernel/drivers/graphics/radeon/radeon_driver.h
   haiku/trunk/src/add-ons/kernel/drivers/graphics/via/driver.c
Log:
* More or less completely rewrote the AGP bus manager.
* It now also serves as a generic GART manager and accepts bus modules as well
  as custom modules of graphics drivers if they want to (could be used for the
  Radeon PCI GART stuff, for example).
* Implemented GART support module for Intel i965 and G33 chipsets (the other
  Intel chips will come later).
* Renamed agp bus manager to agp_gart to reflect its new functionality (even
  though the AGP functionality is already outdated (due to PCIe), the GART
  stuff remains current).
* Adapted existing users of the AGP bus manager to the API changes.
* Not very well tested yet...


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/build/jam/HaikuImage	2008-01-26 22:18:52 UTC (rev 23754)
@@ -125,7 +125,7 @@
 ;
 #BEOS_ADD_ONS_DRIVERS_ACPI = $(X86_ONLY)acpi_button ;
 BEOS_ADD_ONS_BUS_MANAGERS = pci $(X86_ONLY)ps2 $(X86_ONLY)isa ide scsi
-	config_manager $(X86_ONLY)agp usb firewire
+	config_manager agp_gart usb firewire
 ;
 BEOS_ADD_ONS_FILE_SYSTEMS = bfs cdda fat googlefs iso9660 nfs ;
 
@@ -133,6 +133,8 @@
 # modules
 AddFilesToHaikuImage beos system add-ons kernel bus_managers
 	: $(BEOS_ADD_ONS_BUS_MANAGERS) ;
+AddFilesToHaikuImage beos system add-ons kernel busses agp_gart
+	: &lt;agp_gart&gt;intel ;
 AddFilesToHaikuImage beos system add-ons kernel busses ide
 	: generic_ide_pci $(X86_ONLY)ide_isa silicon_image_3112 legacy_sata ;
 AddFilesToHaikuImage beos system add-ons kernel busses scsi

Modified: haiku/trunk/headers/private/graphics/AGP.h
===================================================================
--- haiku/trunk/headers/private/graphics/AGP.h	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/headers/private/graphics/AGP.h	2008-01-26 22:18:52 UTC (rev 23754)
@@ -1,108 +1,123 @@
-/*******************************************************************************
-/
-/	File:		AGP.h
-/
-/	Description:	Interface to the AGP bus and driver.
-/	For more information, see &quot;AGP interface specification&quot;, Revision 2.0 and 3.0,
-/	Intel Corporation, 1998-2002.
-/
-/	Rudolf Cornelissen 6/2004-7/2004.
-/
-*******************************************************************************/
-
-#if !defined(_AGP_H_)
+/*
+ * Copyright 2004-2008, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ */
+#ifndef _AGP_H_
 #define _AGP_H_
 
+
 #include &lt;bus_manager.h&gt;
 
-#ifdef __cplusplus
-extern &quot;C&quot; {
-#endif
 
-
-/* -----
-	agp device info
------ */
-
 typedef struct agp_info {
-	ushort	vendor_id;				/* vendor id */
-	ushort	device_id;				/* device id */
-	uchar	bus;					/* bus number */
-	uchar	device;					/* device number on bus */
-	uchar	function;				/* function number in device */
-	uchar	class_sub;				/* specific device function */
-	uchar	class_base;				/* device type (display vs host bridge) */
-	struct
-	{
-		uint32	agp_cap_id;	/* AGP capability register as defined in the AGP standard */
-		uint32	agp_stat;	/* AGP STATUS register as defined in the AGP standard */
-		uint32	agp_cmd;	/* AGP COMMAND register as defined in the AGP standard */
+	ushort	vendor_id;			/* vendor id */
+	ushort	device_id;			/* device id */
+	uchar	bus;				/* bus number */
+	uchar	device;				/* device number on bus */
+	uchar	function;			/* function number in device */
+	uchar	class_sub;			/* specific device function */
+	uchar	class_base;			/* device type (display vs host bridge) */
+	struct {
+		uint32	capability_id;	/* AGP capability register as defined in the AGP standard */
+		uint32	status;			/* AGP STATUS register as defined in the AGP standard */
+		uint32	command;		/* AGP COMMAND register as defined in the AGP standard */
 	} interface;
-	status_t	status;		/* B_OK if usable, B_ERROR if device did not respond
-							 * according to the AGP standard */
 } agp_info;
 
-typedef struct agp_module_info agp_module_info;
+typedef struct aperture_info {
+	addr_t	physical_base;
+	addr_t	base;
+	size_t	size;
+	size_t	reserved_size;	
+} aperture_info;
 
-struct agp_module_info {
-	bus_manager_info	binfo;
-
-	long			(*get_nth_agp_info) (
-						long		index,	/* index into agp device table */
-						agp_info 	*info	/* caller-supplied buffer for info */
-					);
-	void			(*enable_agp) (
-						uint32	*command	/* max. mode to set */
-					);
-	//fixme: GART and APERTURE stuff is lacking for now, add here...
+/* flags for allocate_memory */
+enum {
+	B_APERTURE_NON_RESERVED		= 0x01,
+	B_APERTURE_NEED_PHYSICAL	= 0x02,
 };
 
-#define	B_AGP_MODULE_NAME		&quot;bus_managers/agp/v0&quot;
+typedef int32 aperture_id;
+typedef struct gart_bus_module_info gart_bus_module_info;
 
+typedef struct agp_gart_module_info {
+	bus_manager_info info;
 
-/* ---
-	value for the AGP_id field in the agp_cap_id register
---- */
-#define AGP_id	0x02	/* AGP device identification */
+	// AGP functionality
+	status_t	(*get_nth_agp_info)(uint32 index, agp_info *info);
+	status_t	(*acquire_agp)(void);
+	void		(*release_agp)(void);
+	uint32		(*set_agp_mode)(uint32 command);
 
+	// GART functionality
+	aperture_id	(*map_aperture)(uint8 bus, uint8 device, uint8 function,
+					size_t size, addr_t *_apertureBase);
+	aperture_id	(*map_custom_aperture)(gart_bus_module_info *module,
+					addr_t *_apertureBase);
+	status_t	(*unmap_aperture)(aperture_id id);
+	status_t	(*get_aperture_info)(aperture_id id, aperture_info *info);
 
-/* ---
-	masks for capability ID register bits
---- */
-#define AGP_id_mask		0x000000ff	/* AGP capability identification, contains value 0x02 for AGP device */
-#define AGP_next_ptr	0x0000ff00	/* pointer to next item in PCI capabilities list, contains 0x00 if this is last item */
-#define AGP_next_ptr_shift		 8
-#define AGP_rev_minor	0x000f0000	/* AGP Revision minor number reported */
-#define AGP_rev_minor_shift		16
-#define AGP_rev_major	0x00f00000	/* AGP Revision major number reported */
-#define AGP_rev_major_shift		20
+	status_t	(*allocate_memory)(aperture_id id, size_t size,
+					size_t alignment, uint32 flags, addr_t *_apertureBase,
+					addr_t *_physicalBase);
+	status_t	(*deallocate_memory)(aperture_id id, addr_t apertureBase);
+	status_t	(*reserve_aperture)(aperture_id id, size_t size,
+					addr_t *_apertureBase);
+	status_t	(*unreserve_aperture)(aperture_id id, addr_t apertureBase);
+	status_t	(*bind_aperture)(aperture_id id, area_id area, addr_t base,
+					size_t size, size_t alignment, bool physical,
+					addr_t reservedBase, addr_t *_apertureBase);
+	status_t	(*unbind_aperture)(aperture_id id, addr_t apertureBase);
+} agp_gart_module_info;
 
+#define	B_AGP_GART_MODULE_NAME &quot;bus_managers/agp_gart/v0&quot;
 
-/* ---
-	masks for status and command register bits
---- */
-#define AGP_2_1x		0x00000001	/* AGP Revision 2.0 1x speed transfer mode */
-#define AGP_2_2x		0x00000002	/* AGP Revision 2.0 2x speed transfer mode */
-#define AGP_2_4x		0x00000004	/* AGP Revision 2.0 4x speed transfer mode */
-#define AGP_3_4x		0x00000001	/* AGP Revision 3.0 4x speed transfer mode */
-#define AGP_3_8x		0x00000002	/* AGP Revision 3.0 8x speed transfer mode */
-#define AGP_rates		0x00000007	/* mask for supported rates info */
-#define AGP_rate_rev	0x00000008	/* 0 if AGP Revision 2.0 or earlier rate scheme, 1 if AGP Revision 3.0 rate scheme */
-#define AGP_FW			0x00000010	/* 1 if fastwrite transfers supported */
-#define AGP_4G			0x00000020	/* 1 if adresses above 4G bytes supported */
-#define AGP_SBA			0x00000200	/* 1 if sideband adressing supported */
-#define AGP_RQ			0xff000000	/* max. number of enqueued AGP command requests supported, minus one */
-#define AGP_RQ_shift			24
+struct agp_gart_for_bus_module_info {
+	module_info info;
+};
 
+#define B_AGP_GART_FOR_BUS_MODULE_NAME &quot;bus_managers/agp_gart/bus/v0&quot;
 
-/* ---
-	masks for command register bits
---- */
-#define AGP_enable		0x00000100	/* set to 1 if AGP should be enabled */
+struct agp_gart_bus_module_info {
+	module_info info;
 
+	// TODO: add some stuff for non-generic AGP support as well
 
-#ifdef __cplusplus
-}
-#endif
+	status_t	(*create_aperture)(uint8 bus, uint8 device, uint8 function,
+					size_t size, void **_aperture);
+	void		(*delete_aperture)(void *aperture);
 
-#endif
+	status_t	(*get_aperture_info)(void *aperture, aperture_info *info);
+	status_t	(*set_aperture_size)(void *aperture, size_t size);
+	status_t	(*bind_page)(void *aperture, uint32 offset,
+					addr_t physicalAddress);
+	status_t	(*unbind_page)(void *aperture, uint32 offset);
+	void		(*flush_tlbs)(void *aperture);
+};
+
+/* defines for capability ID register bits */
+#define AGP_REV_MINOR		0x000f0000	/* AGP Revision minor number reported */
+#define AGP_REV_MINOR_SHIFT	16
+#define AGP_REV_MAJOR		0x00f00000	/* AGP Revision major number reported */
+#define AGP_REV_MAJOR_SHIFT	20
+
+/* defines for status and command register bits */
+#define AGP_2_1x			0x00000001	/* AGP Revision 2.0 1x speed transfer mode */
+#define AGP_2_2x			0x00000002	/* AGP Revision 2.0 2x speed transfer mode */
+#define AGP_2_4x			0x00000004	/* AGP Revision 2.0 4x speed transfer mode */
+#define AGP_3_4x			0x00000001	/* AGP Revision 3.0 4x speed transfer mode */
+#define AGP_3_8x			0x00000002	/* AGP Revision 3.0 8x speed transfer mode */
+#define AGP_RATE_MASK		0x00000007	/* mask for supported rates info */
+#define AGP_3_MODE			0x00000008	/* 0 if AGP Revision 2.0 or earlier rate scheme,
+										 * 1 if AGP Revision 3.0 rate scheme */
+#define AGP_FAST_WRITE		0x00000010	/* 1 if fast write transfers supported */
+#define AGP_ABOVE_4G		0x00000020	/* 1 if adresses above 4G bytes supported */
+#define AGP_SBA				0x00000200	/* 1 if side band adressing supported */
+#define AGP_REQUEST			0xff000000	/* max. number of enqueued AGP command requests
+										 * supported, minus one */
+#define AGP_REQUEST_SHIFT	24
+
+/* masks for command register bits */
+#define AGP_ENABLE			0x00000100	/* set to 1 if AGP should be enabled */
+
+#endif	/* _AGP_H_ */

Modified: haiku/trunk/src/add-ons/accelerants/nvidia/engine/nv_agp.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/nvidia/engine/nv_agp.c	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/src/add-ons/accelerants/nvidia/engine/nv_agp.c	2008-01-26 22:18:52 UTC (rev 23754)
@@ -10,7 +10,9 @@
 static void nv_agp_list_info(agp_info ai);
 static void nv_agp_list_active(uint32 cmd);
 
-status_t nv_agp_setup(bool enable_agp)
+
+status_t
+nv_agp_setup(bool enable_agp)
 {
 	nv_nth_agp_info nai;
 	nv_cmd_agp nca;
@@ -24,8 +26,7 @@
 	/* first try to enable FW support on our card if user requested this
 	 * ('unsupported' tweak!)
 	 * This has no effect on PCI cards. */
-	if (si-&gt;settings.unhide_fw)
-	{
+	if (si-&gt;settings.unhide_fw) {
 		uint32 reg;
 
 		LOG(4, (&quot;AGP: STRAPINFO2 contains $%08x\n&quot;, NV_REG32(NV32_NVSTRAPINFO2)));
@@ -43,15 +44,13 @@
 	nca.magic = nai.magic = NV_PRIVATE_DATA_MAGIC;
 
 	/* contact driver and get a pointer to the registers and shared data */
-	for (index = 0; index &lt; 8; index++)
-	{
+	for (index = 0; index &lt; 8; index++) {
 		/* get nth AGP device info */
 		nai.index = index;
 		ioctl(fd, NV_GET_NTH_AGP_INFO, &amp;nai, sizeof(nai));
 
 		/* abort if no agp busmanager found */
-		if (!nai.agp_bus)
-		{
+		if (!nai.agp_bus) {
 			LOG(4,(&quot;AGP: no AGP busmanager found.\n&quot;));
 			/* don't touch AGP command register, we don't know what has been setup:
 			 * touching it anyway might 'hang' the graphics card! */
@@ -60,8 +59,7 @@
 		}
 
 		/* exit if we didn't get device info for this index */
-		if (!nai.exist)
-		{
+		if (!nai.exist) {
 			if (index != 0)
 				LOG(4,(&quot;AGP: end of AGP capable devices list.\n&quot;));
 			else
@@ -72,12 +70,11 @@
 		LOG(4,(&quot;AGP: AGP capable device #%d:\n&quot;, (index + 1)));
 
 		/* see if we are this one */
-		if ((nai.agpi.device_id == si-&gt;device_id) &amp;&amp;
-			(nai.agpi.vendor_id == si-&gt;vendor_id) &amp;&amp;
-			(nai.agpi.bus == si-&gt;bus) &amp;&amp;
-			(nai.agpi.device == si-&gt;device) &amp;&amp;
-			(nai.agpi.function == si-&gt;function))
-		{
+		if (nai.agpi.device_id == si-&gt;device_id
+			&amp;&amp; nai.agpi.vendor_id == si-&gt;vendor_id
+			&amp;&amp; nai.agpi.bus == si-&gt;bus
+			&amp;&amp; nai.agpi.device == si-&gt;device
+			&amp;&amp; nai.agpi.function == si-&gt;function) {
 			LOG(4,(&quot;AGP: (this is the device this accelerant controls)\n&quot;));
 			agp = true;
 			/* remember our info */
@@ -95,8 +92,7 @@
 	 * AGP type cards as nVidia PCI cards still have AGP registers that pretend to
 	 * support AGP.
 	 * We rely on the AGP busmanager to iterate trough this list for us. */
-	if (!agp)
-	{
+	if (!agp) {
 		LOG(4,(&quot;AGP: the graphicscard this accelerant controls is PCI type.\n&quot;));
 
 		/* make sure card is set for PCI access */
@@ -105,8 +101,7 @@
 		return B_ERROR;
 	}
 
-	if (si-&gt;settings.force_pci || !enable_agp)
-	{
+	if (si-&gt;settings.force_pci || !enable_agp) {
 		/* set PCI mode if specified by user in nv.settings */
 		if (enable_agp)
 			LOG(4,(&quot;AGP: forcing PCI mode (specified in nv.settings)\n&quot;));
@@ -117,31 +112,33 @@
 		 * (the AGP speed scheme is of no consequence now) */
 		nca.cmd = 0x00000000;
 		ioctl(fd, NV_ENABLE_AGP, &amp;nca, sizeof(nca));
-	}
-	else
-	{
+	} else {
 		/* activate AGP mode */
 		LOG(4,(&quot;AGP: activating AGP mode...\n&quot;));
 
 		/* let the AGP busmanager worry about what mode to set.. */
 		nca.cmd = 0xfffffff7;
 		/* ..but we do need to select the right speed scheme fetched from our card */
-		if (nv_ai.interface.agp_stat &amp; AGP_rate_rev) nca.cmd |= AGP_rate_rev;
+		if (nv_ai.interface.status &amp; AGP_3_MODE)
+			nca.cmd |= AGP_3_MODE;
 		ioctl(fd, NV_ENABLE_AGP, &amp;nca, sizeof(nca));
 		/* tell the engine in may use AGP transfers if AGP is up and running */
-		if (nca.cmd &amp; AGP_enable) si-&gt;engine.agp_mode = true;
+		if (nca.cmd &amp; AGP_ENABLE)
+			si-&gt;engine.agp_mode = true;
 	}
 
 	/* list mode now activated,
 	 * make sure we have the correct speed scheme for logging */
-	nv_agp_list_active(nca.cmd | (nv_ai.interface.agp_stat &amp; AGP_rate_rev));
+	nv_agp_list_active(nca.cmd | (nv_ai.interface.status &amp; AGP_3_MODE));
 
 	/* extra check */
 	LOG(4,(&quot;AGP: graphics card AGPCMD register readback $%08x\n&quot;, CFGR(AGPCMD)));
 	return B_OK;
 }
 
-static void nv_agp_list_info(agp_info ai)
+
+static void
+nv_agp_list_info(agp_info ai)
 {
 	/*
 		list device
@@ -158,45 +155,46 @@
 		list capabilities
 	*/
 	LOG(4,(&quot;AGP: this device supports AGP specification %d.%d;\n&quot;,
-		((ai.interface.agp_cap_id &amp; AGP_rev_major) &gt;&gt; AGP_rev_major_shift),
-		((ai.interface.agp_cap_id &amp; AGP_rev_minor) &gt;&gt; AGP_rev_minor_shift)));
+		((ai.interface.capability_id &amp; AGP_REV_MAJOR) &gt;&gt; AGP_REV_MAJOR_SHIFT),
+		((ai.interface.capability_id &amp; AGP_REV_MINOR) &gt;&gt; AGP_REV_MINOR_SHIFT)));
 
 	/* the AGP devices determine AGP speed scheme version used on power-up/reset */
-	if (!(ai.interface.agp_stat &amp; AGP_rate_rev))
-	{
+	if (!(ai.interface.status &amp; AGP_3_MODE)) {
 		/* AGP 2.0 scheme applies */
-		if (ai.interface.agp_stat &amp; AGP_2_1x)
+		if (ai.interface.status &amp; AGP_2_1x)
 			LOG(4,(&quot;AGP: AGP 2.0 1x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_2_2x)
+		if (ai.interface.status &amp; AGP_2_2x)
 			LOG(4,(&quot;AGP: AGP 2.0 2x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_2_4x)
+		if (ai.interface.status &amp; AGP_2_4x)
 			LOG(4,(&quot;AGP: AGP 2.0 4x mode is available\n&quot;));
-	}
-	else
-	{
+	} else {
 		/* AGP 3.0 scheme applies */
-		if (ai.interface.agp_stat &amp; AGP_3_4x)
+		if (ai.interface.status &amp; AGP_3_4x)
 			LOG(4,(&quot;AGP: AGP 3.0 4x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_3_8x)
+		if (ai.interface.status &amp; AGP_3_8x)
 			LOG(4,(&quot;AGP: AGP 3.0 8x mode is available\n&quot;));
 	}
-	if (ai.interface.agp_stat &amp; AGP_FW) LOG(4,(&quot;AGP: fastwrite transfers are supported\n&quot;));
-	if (ai.interface.agp_stat &amp; AGP_SBA) LOG(4,(&quot;AGP: sideband adressing is supported\n&quot;));
+	if (ai.interface.status &amp; AGP_FAST_WRITE)
+		LOG(4,(&quot;AGP: fastwrite transfers are supported\n&quot;));
+	if (ai.interface.status &amp; AGP_SBA)
+		LOG(4,(&quot;AGP: sideband adressing is supported\n&quot;));
 	LOG(4,(&quot;AGP: %d queued AGP requests can be handled.\n&quot;,
-		(((ai.interface.agp_stat &amp; AGP_RQ) &gt;&gt; AGP_RQ_shift) + 1)));
+		(((ai.interface.status &amp; AGP_REQUEST) &gt;&gt; AGP_REQUEST_SHIFT) + 1)));
 
 	/*
 		list current settings,
 		make sure we have the correct speed scheme for logging
 	 */
-	nv_agp_list_active(ai.interface.agp_cmd | (ai.interface.agp_stat &amp; AGP_rate_rev));
+	nv_agp_list_active(ai.interface.command
+		| (ai.interface.status &amp; AGP_3_MODE));
 }
 
-static void nv_agp_list_active(uint32 cmd)
+
+static void
+nv_agp_list_active(uint32 cmd)
 {
 	LOG(4,(&quot;AGP: listing settings now in use:\n&quot;));
-	if (!(cmd &amp; AGP_rate_rev))
-	{
+	if (!(cmd &amp; AGP_3_MODE)) {
 		/* AGP 2.0 scheme applies */
 		if (cmd &amp; AGP_2_1x)
 			LOG(4,(&quot;AGP: AGP 2.0 1x mode is set\n&quot;));
@@ -204,20 +202,20 @@
 			LOG(4,(&quot;AGP: AGP 2.0 2x mode is set\n&quot;));
 		if (cmd &amp; AGP_2_4x)
 			LOG(4,(&quot;AGP: AGP 2.0 4x mode is set\n&quot;));
-	}
-	else
-	{
+	} else {
 		/* AGP 3.0 scheme applies */
 		if (cmd &amp; AGP_3_4x)
 			LOG(4,(&quot;AGP: AGP 3.0 4x mode is set\n&quot;));
 		if (cmd &amp; AGP_3_8x)
 			LOG(4,(&quot;AGP: AGP 3.0 8x mode is set\n&quot;));
 	}
-	if (cmd &amp; AGP_FW) LOG(4,(&quot;AGP: fastwrite transfers are enabled\n&quot;));
-	if (cmd &amp; AGP_SBA) LOG(4,(&quot;AGP: sideband adressing is enabled\n&quot;));
+	if (cmd &amp; AGP_FAST_WRITE)
+		LOG(4,(&quot;AGP: fastwrite transfers are enabled\n&quot;));
+	if (cmd &amp; AGP_SBA)
+		LOG(4,(&quot;AGP: sideband adressing is enabled\n&quot;));
 	LOG(4,(&quot;AGP: max. AGP queued request depth is set to %d\n&quot;,
-		(((cmd &amp; AGP_RQ) &gt;&gt; AGP_RQ_shift) + 1)));
-	if (cmd &amp; AGP_enable)
+		(((cmd &amp; AGP_REQUEST) &gt;&gt; AGP_REQUEST_SHIFT) + 1)));
+	if (cmd &amp; AGP_ENABLE)
 		LOG(4,(&quot;AGP: the AGP interface is enabled.\n&quot;));
 	else
 		LOG(4,(&quot;AGP: the AGP interface is disabled.\n&quot;));

Modified: haiku/trunk/src/add-ons/accelerants/via/engine/agp.c
===================================================================
--- haiku/trunk/src/add-ons/accelerants/via/engine/agp.c	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/src/add-ons/accelerants/via/engine/agp.c	2008-01-26 22:18:52 UTC (rev 23754)
@@ -7,10 +7,9 @@
 #include &lt;unistd.h&gt;
 #include &quot;std.h&quot;
 
-static void eng_agp_list_info(agp_info ai);
-static void eng_agp_list_active(uint32 cmd);
 
-status_t eng_agp_setup(void)
+status_t
+eng_agp_setup(void)
 {
 	eng_nth_agp_info nai;
 	eng_cmd_agp nca;
@@ -18,37 +17,17 @@
 	agp_info eng_ai;
 	bool agp = false;
 
-	/* first try to enable FW support on our card if user requested this
-	 * ('unsupported' tweak!)
-	 * This has no effect on PCI cards. */
-//	if (si-&gt;settings.unhide_fw)
-//	{
-//		uint32 reg;
-
-//		LOG(4, (&quot;AGP: STRAPINFO2 contains $%08x\n&quot;, ENG_REG32(RG32_NVSTRAPINFO2)));
-
-//		LOG(4, (&quot;AGP: attempting to enable fastwrite support..\n&quot;));
-		/* 'force' FW support */
-//		reg = (ENG_REG32(RG32_NVSTRAPINFO2) &amp; ~0x00000800);
-		/* enable strapinfo overwrite */
-//		ENG_REG32(RG32_NVSTRAPINFO2) = (reg | 0x80000000);
-
-//		LOG(4, (&quot;AGP: STRAPINFO2 now contains $%08x\n&quot;, ENG_REG32(RG32_NVSTRAPINFO2)));
-//	}
-
 	/* set the magic number so the via kerneldriver knows we're for real */
 	nca.magic = nai.magic = VIA_PRIVATE_DATA_MAGIC;
 
 	/* contact driver and get a pointer to the registers and shared data */
-	for (index = 0; index &lt; 8; index++)
-	{
+	for (index = 0; index &lt; 8; index++) {
 		/* get nth AGP device info */
 		nai.index = index;
 		ioctl(fd, ENG_GET_NTH_AGP_INFO, &amp;nai, sizeof(nai));
 
 		/* abort if no agp busmanager found */
-		if (!nai.agp_bus)
-		{
+		if (!nai.agp_bus) {
 			LOG(4,(&quot;AGP: no AGP busmanager found.\n&quot;));
 			/* don't touch AGP command register, we don't know what has been setup:
 			 * touching it anyway might 'hang' the graphics card! */
@@ -57,8 +36,7 @@
 		}
 
 		/* exit if we didn't get device info for this index */
-		if (!nai.exist)
-		{
+		if (!nai.exist) {
 			if (index != 0)
 				LOG(4,(&quot;AGP: end of AGP capable devices list.\n&quot;));
 			else
@@ -69,20 +47,16 @@
 		LOG(4,(&quot;AGP: AGP capable device #%d:\n&quot;, (index + 1)));
 
 		/* see if we are this one */
-		if ((nai.agpi.device_id == si-&gt;device_id) &amp;&amp;
-			(nai.agpi.vendor_id == si-&gt;vendor_id) &amp;&amp;
-			(nai.agpi.bus == si-&gt;bus) &amp;&amp;
-			(nai.agpi.device == si-&gt;device) &amp;&amp;
-			(nai.agpi.function == si-&gt;function))
-		{
+		if (nai.agpi.device_id == si-&gt;device_id
+			&amp;&amp; nai.agpi.vendor_id == si-&gt;vendor_id
+			&amp;&amp; nai.agpi.bus == si-&gt;bus
+			&amp;&amp; nai.agpi.device == si-&gt;device
+			&amp;&amp; nai.agpi.function == si-&gt;function) {
 			LOG(4,(&quot;AGP: (this is the device this accelerant controls)\n&quot;));
 			agp = true;
 			/* remember our info */
 			eng_ai = nai.agpi;
 		}
-
-		/* log capabilities */
-		eng_agp_list_info(nai.agpi);
 	}
 
 	/* if our card is not an AGP type, abort here */
@@ -92,8 +66,7 @@
 	 * AGP type cards as PCI cards still might have AGP registers that pretend to
 	 * support AGP.
 	 * We rely on the AGP busmanager to iterate trough this list for us. */
-	if (!agp)
-	{
+	if (!agp) {
 		LOG(4,(&quot;AGP: the graphicscard this accelerant controls is PCI type.\n&quot;));
 
 		/* make sure card is set for PCI access */
@@ -102,8 +75,7 @@
 		return B_ERROR;
 	}
 
-	if (si-&gt;settings.force_pci)
-	{
+	if (si-&gt;settings.force_pci) {
 		/* set PCI mode if specified by user in skel.settings */
 		LOG(4,(&quot;AGP: forcing PCI mode (specified in via.settings)\n&quot;));
 
@@ -111,106 +83,20 @@
 		 * (the AGP speed scheme is of no consequence now) */
 		nca.cmd = 0x00000000;
 		ioctl(fd, ENG_ENABLE_AGP, &amp;nca, sizeof(nca));
-	}
-	else
-	{
+	} else {
 		/* activate AGP mode */
 		LOG(4,(&quot;AGP: activating AGP mode...\n&quot;));
 
 		/* let the AGP busmanager worry about what mode to set.. */
 		nca.cmd = 0xfffffff7;
 		/* ..but we do need to select the right speed scheme fetched from our card */
-		if (eng_ai.interface.agp_stat &amp; AGP_rate_rev) nca.cmd |= AGP_rate_rev;
+		if (eng_ai.interface.status &amp; AGP_3_MODE)
+			nca.cmd |= AGP_3_MODE;
 		ioctl(fd, ENG_ENABLE_AGP, &amp;nca, sizeof(nca));
 	}
 
-	/* list mode now activated,
-	 * make sure we have the correct speed scheme for logging */
-	eng_agp_list_active(nca.cmd | (eng_ai.interface.agp_stat &amp; AGP_rate_rev));
-
 	/* extra check */
 //	LOG(4,(&quot;AGP: graphics card AGPCMD register readback $%08x\n&quot;, CFGR(AGPCMD)));
 	return B_OK;
 }
 
-static void eng_agp_list_info(agp_info ai)
-{
-	/*
-		list device
-	*/
-	if (ai.class_base == PCI_display)
-		LOG(4,(&quot;AGP: device is a graphicscard, subclass ID is $%02x\n&quot;, ai.class_sub));
-	else
-		LOG(4,(&quot;AGP: device is a hostbridge, subclass ID is $%02x\n&quot;, ai.class_sub));
-	LOG(4,(&quot;AGP: vendor ID $%04x\n&quot;, ai.vendor_id));
-	LOG(4,(&quot;AGP: device ID $%04x\n&quot;, ai.device_id));
-	LOG(4,(&quot;AGP: bus %d, device %d, function %d\n&quot;, ai.bus, ai.device, ai.function));
-
-	/*
-		list capabilities
-	*/
-	LOG(4,(&quot;AGP: this device supports AGP specification %d.%d;\n&quot;,
-		((ai.interface.agp_cap_id &amp; AGP_rev_major) &gt;&gt; AGP_rev_major_shift),
-		((ai.interface.agp_cap_id &amp; AGP_rev_minor) &gt;&gt; AGP_rev_minor_shift)));
-
-	/* the AGP devices determine AGP speed scheme version used on power-up/reset */
-	if (!(ai.interface.agp_stat &amp; AGP_rate_rev))
-	{
-		/* AGP 2.0 scheme applies */
-		if (ai.interface.agp_stat &amp; AGP_2_1x)
-			LOG(4,(&quot;AGP: AGP 2.0 1x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_2_2x)
-			LOG(4,(&quot;AGP: AGP 2.0 2x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_2_4x)
-			LOG(4,(&quot;AGP: AGP 2.0 4x mode is available\n&quot;));
-	}
-	else
-	{
-		/* AGP 3.0 scheme applies */
-		if (ai.interface.agp_stat &amp; AGP_3_4x)
-			LOG(4,(&quot;AGP: AGP 3.0 4x mode is available\n&quot;));
-		if (ai.interface.agp_stat &amp; AGP_3_8x)
-			LOG(4,(&quot;AGP: AGP 3.0 8x mode is available\n&quot;));
-	}
-	if (ai.interface.agp_stat &amp; AGP_FW) LOG(4,(&quot;AGP: fastwrite transfers are supported\n&quot;));
-	if (ai.interface.agp_stat &amp; AGP_SBA) LOG(4,(&quot;AGP: sideband adressing is supported\n&quot;));
-	LOG(4,(&quot;AGP: %d queued AGP requests can be handled.\n&quot;,
-		(((ai.interface.agp_stat &amp; AGP_RQ) &gt;&gt; AGP_RQ_shift) + 1)));
-
-	/*
-		list current settings,
-		make sure we have the correct speed scheme for logging
-	 */
-	eng_agp_list_active(ai.interface.agp_cmd | (ai.interface.agp_stat &amp; AGP_rate_rev));
-}
-
-static void eng_agp_list_active(uint32 cmd)
-{
-	LOG(4,(&quot;AGP: listing settings now in use:\n&quot;));
-	if (!(cmd &amp; AGP_rate_rev))
-	{
-		/* AGP 2.0 scheme applies */
-		if (cmd &amp; AGP_2_1x)
-			LOG(4,(&quot;AGP: AGP 2.0 1x mode is set\n&quot;));
-		if (cmd &amp; AGP_2_2x)
-			LOG(4,(&quot;AGP: AGP 2.0 2x mode is set\n&quot;));
-		if (cmd &amp; AGP_2_4x)
-			LOG(4,(&quot;AGP: AGP 2.0 4x mode is set\n&quot;));
-	}
-	else
-	{
-		/* AGP 3.0 scheme applies */
-		if (cmd &amp; AGP_3_4x)
-			LOG(4,(&quot;AGP: AGP 3.0 4x mode is set\n&quot;));
-		if (cmd &amp; AGP_3_8x)
-			LOG(4,(&quot;AGP: AGP 3.0 8x mode is set\n&quot;));
-	}
-	if (cmd &amp; AGP_FW) LOG(4,(&quot;AGP: fastwrite transfers are enabled\n&quot;));
-	if (cmd &amp; AGP_SBA) LOG(4,(&quot;AGP: sideband adressing is enabled\n&quot;));
-	LOG(4,(&quot;AGP: max. AGP queued request depth is set to %d\n&quot;,
-		(((cmd &amp; AGP_RQ) &gt;&gt; AGP_RQ_shift) + 1)));
-	if (cmd &amp; AGP_enable)
-		LOG(4,(&quot;AGP: the AGP interface is enabled.\n&quot;));
-	else
-		LOG(4,(&quot;AGP: the AGP interface is disabled.\n&quot;));
-}

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/agp/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/agp/Jamfile	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/agp/Jamfile	2008-01-26 22:18:52 UTC (rev 23754)
@@ -1,23 +1,13 @@
 SubDir HAIKU_TOP src add-ons kernel bus_managers agp ;
 
 SetSubDirSupportedPlatformsBeOSCompatible ;
+SubDirC++Flags -fno-rtti ;
 
-UsePrivateHeaders graphics ;
+UsePrivateHeaders [ FDirName kernel boot platform $(TARGET_BOOT_PLATFORM) ] ;
+UsePrivateHeaders [ FDirName kernel arch $(TARGET_ARCH) ] ;
+UsePrivateHeaders [ FDirName graphics intel_extreme ] ;
+UsePrivateHeaders graphics kernel ;
 
-Package haiku-agp :
-	README.html
-	UPDATE.html
-	 ;
-
-Package haiku-agp :
-	agp :
-	boot home config add-ons kernel bus_managers ;
-
-Package haiku-agp :
-	agp.settings :
-	boot home config settings kernel drivers ;
-
-KernelAddon agp :
+KernelAddon agp_gart :
 	agp.cpp
-	module.cpp
 	;

Deleted: haiku/trunk/src/add-ons/kernel/bus_managers/agp/README.html

Deleted: haiku/trunk/src/add-ons/kernel/bus_managers/agp/UPDATE.html

Modified: haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.cpp	2008-01-26 21:59:02 UTC (rev 23753)
+++ haiku/trunk/src/add-ons/kernel/bus_managers/agp/agp.cpp	2008-01-26 22:18:52 UTC (rev 23754)
@@ -1,538 +1,1149 @@
 /*
-	written by Rudolf Cornelissen 7/2004-4/2006
-*/
+ * Copyright 2008, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A> All rights reserved.
+ * Copyright 2004-2006, Rudolf Cornelissen. All rights reserved.
+ *
+ * Distributed under the terms of the MIT License.
+ */
 
+// TODO: rethink the AGP interface for more than one bridge/device!
+//	(should be done with the new driver API then)
+
 /*
 	Notes:
-	-currently we just setup all found devices with AGP interface to the same highest common mode,
-	we don't distinquish different AGP buses.
+	- currently we just setup all found devices with AGP interface to the same
+	highest common mode, we don't distinquish different AGP busses.
+	TODO: it might be a better idea to just setup one instead.
 
-	-no aperture and GART support, just enabling AGP transfer mode. Aperture and GART support are
-	probably easiest to setup for AGP3, as this version of the standard defines all registers needed
-	so we can probably program in the same universal way as we are doing right now. AGP2 requires
-	specific 'drivers' for each chipset outthere, as the registers are implemented in a lot of
-	different ways here.
-	Aperture and GART support is only usefull, once we setup hardware 3D acceleration.
+	- AGP3 defines 'asynchronous request size' and 'calibration cycle' fields
+	in the status and command registers. Currently programming zero's which will
+	make it work, although further optimisation is possible.
 
-	-AGP3 defines 'asynchronous request size' and 'calibration cycle' fields in the status and command
-	registers. Currently programming zero's which will make it work, although further optimisation
-	is possible.
-
-	-AGP3.5 also defines isochronous transfers which are not implemented here: the hardware keeps them
-	disabled by default.
+	- AGP3.5 also defines isochronous transfers which are not implemented here:
+	the hardware keeps them disabled by default.
 */
 
-#include &lt;malloc.h&gt;
-#include &lt;driver_settings.h&gt;
-#include &lt;stdlib.h&gt; // for strtoXX
-#include &quot;agp.h&quot;
 
-typedef struct {
-	sem_id	sem;
-	int32	ben;
-} benaphore;
+#include &lt;AGP.h&gt;
 
-#define INIT_BEN(x)		x.sem = create_sem(0, &quot;AGP &quot;#x&quot; benaphore&quot;);  x.ben = 0;
-#define AQUIRE_BEN(x)	if((atomic_add(&amp;(x.ben), 1)) &gt;= 1) acquire_sem(x.sem);
-#define RELEASE_BEN(x)	if((atomic_add(&amp;(x.ben), -1)) &gt; 1) release_sem(x.sem);
-#define	DELETE_BEN(x)	delete_sem(x.sem);
+#include &lt;stdlib.h&gt;
 
+#include &lt;KernelExport.h&gt;
+#include &lt;PCI.h&gt;
+
+#include &lt;util/OpenHashTable.h&gt;
+#ifdef __HAIKU__
+#	include &lt;kernel/lock.h&gt;
+#	include &lt;vm_page.h&gt;
+#	include &lt;vm_types.h&gt;
+#endif
+
+#include &lt;lock.h&gt;
+
+#ifndef __HAIKU__
+#	define PCI_capabilities_ptr		0x34
+#	define PCI_status_capabilities	0x0010
+#	define PCI_cap_id_agp			0x02
+#	define B_NOT_SUPPORTED			B_ERROR
+#endif
+
+#define TRACE_AGP
+#ifdef TRACE_AGP
+#	define TRACE(x...) dprintf(&quot;\33[36mAGP:\33[0m &quot; x)
+#else
+#	define TRACE(x...) ;
+#endif
+
+
 #define MAX_DEVICES	  8
 
+#define AGP_ID(address) (address)
+#define AGP_STATUS(address) (address + 4)
+#define AGP_COMMAND(address) (address + 8)
+
+#define ROUNDUP(a, b) (((a) + ((b)-1)) &amp; ~((b)-1))
+
 /* read and write to PCI config space */
-#define get_pci(o, s) (*pci_bus-&gt;read_pci_config)(pcii-&gt;bus, pcii-&gt;device, pcii-&gt;function, (o), (s))
-#define set_pci(o, s, v) (*pci_bus-&gt;write_pci_config)(pcii-&gt;bus, pcii-&gt;device, pcii-&gt;function, (o), (s), (v))
+#define get_pci_config(info, offset, size) \
+	(sPCI-&gt;read_pci_config((info).bus, (info).device, (info).function, \
+		(offset), (size)))
+#define set_pci_config(info, offset, size, value) \
+	(sPCI-&gt;write_pci_config((info).bus, (info).device, (info).function, \
+		(offset), (size), (value)))
 
-/* these structures are private to the module */
-typedef struct device_info device_info;
+#define RESERVED_APERTURE			0x80000000
+#define ALLOCATED_APERTURE			0x40000000
+#define BIND_APERTURE				0x20000000
+#define APERTURE_PUBLIC_FLAGS_MASK	0x0000ffff
 
-struct device_info {
-	uint8		agp_adress;				/* location of AGP interface in PCI capabilities list */
-	agp_info	agpi;					/* agp info for this device */
-	pci_info	pcii;					/* pci info for this device */
+struct aperture_memory : HashTableLink&lt;aperture_memory&gt; {
+	aperture_memory *next;
+	addr_t		base;
+	size_t		size;
+	uint32		flags;
+#ifdef __HAIKU__
+	union {
+		vm_page	**pages;
+		vm_page *page;
+	};
+#else
+	area_id		area;
+#endif
 };
 
-typedef struct {
-	long		count;							/* number of devices actually found */
-	benaphore	kernel;							/* for serializing access */
-	device_info	di[MAX_DEVICES];				/* device specific stuff */
-} DeviceData;
+class Aperture;
 
-typedef struct settings { //see comments in agp.settings
-	uint32 max_speed;
-	bool   block_agp;
-	bool   block_sba;
-	bool   block_fw;
-} settings;
+class MemoryHashDefinition {
+public:
+	typedef addr_t KeyType;
+	typedef aperture_memory ValueType;
 
-/* prototypes for our private functions */
-static bool has_AGP_interface(pci_info *pcii, uint8 *adress);
-static status_t probe_devices(void);
-static void read_settings(void);
-static void check_settings(uint32 *command);
-static void check_capabilities(uint32 agp_stat, uint32 *command);
+	MemoryHashDefinition(aperture_info &amp;info) : fInfo(info) {}
 
+	size_t HashKey(const KeyType &amp;base) const
+		{ return (base - fInfo.base) / B_PAGE_SIZE; }
+	size_t Hash(aperture_memory *memory) const
+		{ return (memory-&gt;base - fInfo.base) / B_PAGE_SIZE; }
+	bool Compare(const KeyType &amp;base, aperture_memory *memory) const
+		{ return base == memory-&gt;base; }
+	HashTableLink&lt;aperture_memory&gt; *GetLink(aperture_memory *memory) const
+		{ return memory; }
 
-static DeviceData		*pd;
-static pci_module_info	*pci_bus;
+private:
+	aperture_info	&fInfo;
+};
 
-static settings current_settings = { //see comments in agp.settings
-	0,          // max_speed
-	false,		// block_agp
-	false,      // block_sba
-	true,       // block_fw
+typedef OpenHashTable&lt;MemoryHashDefinition&gt; MemoryHashTable;
+
+struct agp_device_info {
+	uint8		address;	/* location of AGP interface in PCI capabilities */
+	agp_info	info;
 };
 
+class Aperture : public HashTableLink&lt;Aperture&gt; {
+public:
+	Aperture(agp_gart_bus_module_info *module, void *aperture);
+	~Aperture();
 
-status_t init(void)
+	status_t InitCheck() const { return fLock.sem &gt;= B_OK ? B_OK : fLock.sem; }
+
+	void DeleteMemory(aperture_memory *memory);
+	aperture_memory *CreateMemory(size_t size, size_t alignment, uint32 flags);
+
+	status_t AllocateMemory(aperture_memory *memory, uint32 flags);
+
+	status_t UnbindMemory(aperture_memory *memory);
+	status_t BindMemory(aperture_memory *memory, addr_t base, size_t size,
+		bool physical);
+
+	status_t GetInfo(aperture_info *info);
+
+	aperture_memory *GetMemory(addr_t base) { return fHashTable.Lookup(base); }
+
+	addr_t Base() const { return fInfo.base; }
+	addr_t Size() const { return fInfo.size; }
+	int32 ID() const { return fID; }
+	struct lock &amp;Lock() { return fLock; }
+
+private:
+	void _Free(aperture_memory *memory);
+
+	void _Remove(aperture_memory *memory);
+	status_t _Insert(aperture_memory *memory, size_t size, size_t alignment,
+		uint32 flags);
+
+	struct lock					fLock;
+	agp_gart_bus_module_info	*fModule;
+	int32						fID;
+	aperture_info				fInfo;
+	MemoryHashTable				fHashTable;
+	aperture_memory				*fFirstMemory;
+	void						*fPrivateAperture;
+};
+
+class ApertureHashDefinition {
+public:
+	typedef int32 KeyType;
+	typedef Aperture ValueType;
+
+	size_t HashKey(const KeyType &amp;id) const
+		{ return id; }
+	size_t Hash(Aperture *aperture) const
+		{ return aperture-&gt;ID(); }
+	bool Compare(const KeyType &amp;id, Aperture *aperture) const
+		{ return id == aperture-&gt;ID(); }
+	HashTableLink&lt;Aperture&gt; *GetLink(Aperture *aperture) const
+		{ return aperture; }
+};
+
+typedef OpenHashTable&lt;ApertureHashDefinition&gt; ApertureHashTable;
+
+
+static agp_device_info sDeviceInfos[MAX_DEVICES];
+static uint32 sDeviceCount;
+static pci_module_info *sPCI;
+static int32 sAcquired;
+static ApertureHashTable sApertureHashTable;
+static int32 sNextApertureID;
+static struct lock sLock;
+
+
+//	#pragma mark - private support functions
+
+
+/*!	Makes sure that all bits lower than the maximum supported rate is set. */
+static uint32
+fix_rate_support(uint32 command)
 {
-	/* get a handle for the pci bus */
-	if (get_module(B_PCI_MODULE_NAME, (module_info **)&amp;pci_bus) != B_OK)
-		return B_ERROR;
+	if ((command &amp; AGP_3_MODE) != 0) {
+		if ((command &amp; AGP_3_8x) != 0)
+			command |= AGP_3_4x;
 
-	/* private data */
-	pd = (DeviceData *)calloc(1, sizeof(DeviceData));
-	if (!pd)
-	{

[... truncated: 2490 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="005790.html">[Haiku-commits] r23753 - in haiku/trunk:	headers/private/graphics/intel_extreme	src/add-ons/accelerants/intel_extreme	src/add-ons/kernel/drivers/graphics/intel_extreme
</A></li>
	<LI>Next message: <A HREF="005792.html">[Haiku-commits] r23755 - haiku/trunk/src/add-ons/kernel/generic
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5791">[ date ]</a>
              <a href="thread.html#5791">[ thread ]</a>
              <a href="subject.html#5791">[ subject ]</a>
              <a href="author.html#5791">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
