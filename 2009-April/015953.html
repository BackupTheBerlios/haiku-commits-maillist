<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30245 - in haiku/trunk/src/bin/debug: .	scheduling_recorder
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30245%20-%20in%20haiku/trunk/src/bin/debug%3A%20.%0A%09scheduling_recorder&In-Reply-To=%3C200904181741.n3IHfmtR003020%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015952.html">
   <LINK REL="Next"  HREF="015954.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30245 - in haiku/trunk/src/bin/debug: .	scheduling_recorder</H1>
    <B>bonefish at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30245%20-%20in%20haiku/trunk/src/bin/debug%3A%20.%0A%09scheduling_recorder&In-Reply-To=%3C200904181741.n3IHfmtR003020%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30245 - in haiku/trunk/src/bin/debug: .	scheduling_recorder">bonefish at mail.berlios.de
       </A><BR>
    <I>Sat Apr 18 19:41:48 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="015952.html">[Haiku-commits] r30244 - in haiku/trunk: headers/private/debug	src/kits/debug
</A></li>
        <LI>Next message: <A HREF="015954.html">[Haiku-commits] r30246 - haiku/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15953">[ date ]</a>
              <a href="thread.html#15953">[ thread ]</a>
              <a href="subject.html#15953">[ subject ]</a>
              <a href="author.html#15953">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2009-04-18 19:41:46 +0200 (Sat, 18 Apr 2009)
New Revision: 30245
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30245&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30245&amp;view=rev</A>

Added:
   haiku/trunk/src/bin/debug/scheduling_recorder/
   haiku/trunk/src/bin/debug/scheduling_recorder/Jamfile
   haiku/trunk/src/bin/debug/scheduling_recorder/scheduling_recorder.cpp
Modified:
   haiku/trunk/src/bin/debug/Jamfile
Log:
Added a simple tool &quot;scheduling_recorder&quot; that records scheduling information
(as generated by the system profiling interface) to a file for later analysis.
Only the analysis tool is missing, yet. :-)


Modified: haiku/trunk/src/bin/debug/Jamfile
===================================================================
--- haiku/trunk/src/bin/debug/Jamfile	2009-04-18 17:38:21 UTC (rev 30244)
+++ haiku/trunk/src/bin/debug/Jamfile	2009-04-18 17:41:46 UTC (rev 30245)
@@ -9,5 +9,6 @@
 
 HaikuSubInclude ltrace ;
 HaikuSubInclude profile ;
+HaikuSubInclude scheduling_recorder ;
 HaikuSubInclude strace ;
 HaikuSubInclude time_stats ;

Added: haiku/trunk/src/bin/debug/scheduling_recorder/Jamfile
===================================================================
--- haiku/trunk/src/bin/debug/scheduling_recorder/Jamfile	2009-04-18 17:38:21 UTC (rev 30244)
+++ haiku/trunk/src/bin/debug/scheduling_recorder/Jamfile	2009-04-18 17:41:46 UTC (rev 30245)
@@ -0,0 +1,16 @@
+SubDir HAIKU_TOP src bin debug scheduling_recorder ;
+
+UsePrivateHeaders debug kernel libroot shared ;
+UsePrivateSystemHeaders ;
+
+SubDirHdrs [ FDirName $(SUBDIR) $(DOTDOT) ] ;
+
+BinCommand scheduling_recorder
+	:
+	scheduling_recorder.cpp
+	:
+	&lt;bin&gt;debug_utils.a
+	libdebug.so
+	be
+	$(TARGET_LIBSTDC++)
+;

Added: haiku/trunk/src/bin/debug/scheduling_recorder/scheduling_recorder.cpp
===================================================================
--- haiku/trunk/src/bin/debug/scheduling_recorder/scheduling_recorder.cpp	2009-04-18 17:38:21 UTC (rev 30244)
+++ haiku/trunk/src/bin/debug/scheduling_recorder/scheduling_recorder.cpp	2009-04-18 17:41:46 UTC (rev 30245)
@@ -0,0 +1,314 @@
+/*
+ * Copyright 2009, Ingo Weinhold, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">ingo_weinhold at gmx.de.</A>
+ * Distributed under the terms of the MIT License.
+ */
+
+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;getopt.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;File.h&gt;
+
+#include &lt;syscalls.h&gt;
+#include &lt;system_profiler_defs.h&gt;
+
+#include &lt;DebugEventStream.h&gt;
+
+#include &quot;debug_utils.h&quot;
+
+
+#define SCHEDULING_RECORDING_AREA_SIZE	(4 * 1024 * 1024)
+
+#define DEBUG_EVENT_MASK (B_SYSTEM_PROFILER_TEAM_EVENTS				\
+							| B_SYSTEM_PROFILER_THREAD_EVENTS		\
+							| B_SYSTEM_PROFILER_SCHEDULING_EVENTS)
+
+
+extern const char* __progname;
+const char* kCommandName = __progname;
+
+
+static const char* kUsage =
+	&quot;Usage: %s [ &lt;options&gt; ] &lt;output file&gt; [ &lt;command line&gt; ]\n&quot;
+	&quot;Records thread scheduling information to a file for later analysis.\n&quot;
+	&quot;If a command line &lt;command line&gt; is given, recording starts right before\&quot;
+	&quot;executing the command and steps when the respective team quits.\n&quot;
+	&quot;\n&quot;
+	&quot;Options:\n&quot;
+	&quot;  -l           - When a command line is given: Start recording before\n&quot;
+	&quot;                 executable has been loaded.\n&quot;
+	&quot;  -h, --help   - Print this usage info.\n&quot;
+;
+
+
+static void
+print_usage_and_exit(bool error)
+{
+    fprintf(error ? stderr : stdout, kUsage, kCommandName);
+    exit(error ? 1 : 0);
+}
+
+
+class Recorder {
+public:
+	Recorder()
+		:
+		fMainTeam(-1),
+		fSkipLoading(true),
+		fCaughtDeadlySignal(false)
+	{
+	}
+
+	~Recorder()
+	{
+		fOutput.Flush();
+	}
+
+
+	status_t Init(const char* outputFile)
+	{
+		// open file
+		status_t error = fOutputFile.SetTo(outputFile,
+			B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
+		if (error != B_OK) {
+			fprintf(stderr, &quot;Error: Failed to open \&quot;%s\&quot;: %s\n&quot;, outputFile,
+				strerror(error));
+			return error;
+		}
+
+		// create output stream
+		error = fOutput.SetTo(&amp;fOutputFile, 0, DEBUG_EVENT_MASK);
+		if (error != B_OK) {
+			fprintf(stderr, &quot;Error: Failed to initialize the output &quot;
+				&quot;stream: %s\n&quot;, strerror(error));
+			return error;
+		}
+
+		return B_OK;
+	}
+
+	void SetSkipLoading(bool skipLoading)
+	{
+		fSkipLoading = skipLoading;
+	}
+
+	void Run(const char* const* programArgs, int programArgCount)
+	{
+		// Load the executable, if we have to.
+		thread_id threadID = -1;
+		if (programArgCount &gt;= 1) {
+			threadID = load_program(programArgs, programArgCount,
+				!fSkipLoading);
+			if (threadID &lt; 0) {
+				fprintf(stderr, &quot;%s: Failed to start `%s': %s\n&quot;, kCommandName,
+					programArgs[0], strerror(threadID));
+				exit(1);
+			}
+			fMainTeam = threadID;
+		}
+
+		// install signal handlers so we can exit gracefully
+		struct sigaction action;
+		action.sa_handler = (sighandler_t)_SignalHandler;
+		sigemptyset(&amp;action.sa_mask);
+		action.sa_userdata = this;
+		if (sigaction(SIGHUP, &amp;action, NULL) &lt; 0
+			|| sigaction(SIGINT, &amp;action, NULL) &lt; 0
+			|| sigaction(SIGQUIT, &amp;action, NULL) &lt; 0) {
+			fprintf(stderr, &quot;%s: Failed to install signal handlers: %s\n&quot;,
+				kCommandName, strerror(errno));
+			exit(1);
+		}
+
+		// create an area for the sample buffer
+		system_profiler_buffer_header* bufferHeader;
+		area_id area = create_area(&quot;profiling buffer&quot;, (void**)&amp;bufferHeader,
+			B_ANY_ADDRESS, SCHEDULING_RECORDING_AREA_SIZE, B_NO_LOCK,
+			B_READ_AREA | B_WRITE_AREA);
+		if (area &lt; 0) {
+			fprintf(stderr, &quot;%s: Failed to create sample area: %s\n&quot;,
+				kCommandName, strerror(area));
+			exit(1);
+		}
+
+		uint8* bufferBase = (uint8*)(bufferHeader + 1);
+		size_t totalBufferSize = SCHEDULING_RECORDING_AREA_SIZE
+			- (bufferBase - (uint8*)bufferHeader);
+
+		// start profiling
+		system_profiler_parameters profilerParameters;
+		profilerParameters.buffer_area = area;
+		profilerParameters.flags = DEBUG_EVENT_MASK;
+		profilerParameters.locking_lookup_size = 64 * 1024;
+
+		status_t error = _kern_system_profiler_start(&amp;profilerParameters);
+		if (error != B_OK) {
+			fprintf(stderr, &quot;%s: Failed to start profiling: %s\n&quot;, kCommandName,
+				strerror(error));
+			exit(1);
+		}
+
+		// resume the loaded team, if we have one
+		if (threadID &gt;= 0)
+			resume_thread(threadID);
+
+		// main event loop
+		while (true) {
+			// get the current buffer
+			size_t bufferStart = bufferHeader-&gt;start;
+			size_t bufferSize = bufferHeader-&gt;size;
+			uint8* buffer = bufferBase + bufferStart;
+//printf(&quot;processing buffer of size %lu bytes\n&quot;, bufferSize);
+
+			bool quit;
+			if (bufferStart + bufferSize &lt;= totalBufferSize) {
+				quit = _ProcessEventBuffer(buffer, bufferSize);
+			} else {
+				size_t remainingSize = bufferStart + bufferSize
+					- totalBufferSize;
+				quit = _ProcessEventBuffer(buffer, bufferSize - remainingSize)
+					|| _ProcessEventBuffer(bufferBase, remainingSize);
+			}
+
+			if (quit)
+				break;
+
+			// get next buffer
+			error = _kern_system_profiler_next_buffer(bufferSize);
+
+			if (error != B_OK) {
+				if (error == B_INTERRUPTED) {
+					if (fCaughtDeadlySignal)
+						break;
+					continue;
+				}
+
+				fprintf(stderr, &quot;%s: Failed to get next sample buffer: %s\n&quot;,
+					kCommandName, strerror(error));
+				break;
+			}
+		}
+
+		// stop profiling
+		_kern_system_profiler_stop();
+	}
+
+private:
+	bool _ProcessEventBuffer(uint8* buffer, size_t bufferSize)
+	{
+//printf(&quot;_ProcessEventBuffer(%p, %lu)\n&quot;, buffer, bufferSize);
+		const uint8* bufferStart = buffer;
+		const uint8* bufferEnd = buffer + bufferSize;
+		size_t usableBufferSize = bufferSize;
+		bool quit = false;
+
+		while (buffer &lt; bufferEnd) {
+			system_profiler_event_header* header
+				= (system_profiler_event_header*)buffer;
+
+			buffer += sizeof(system_profiler_event_header);
+
+			if (header-&gt;event == B_SYSTEM_PROFILER_BUFFER_END) {
+				// Marks the end of the ring buffer -- we need to ignore the
+				// remaining bytes.
+				usableBufferSize = (uint8*)header - bufferStart;
+				break;
+			}
+
+			if (header-&gt;event == B_SYSTEM_PROFILER_TEAM_REMOVED) {
+				system_profiler_team_removed* event
+					= (system_profiler_team_removed*)buffer;
+
+				// quit, if the main team we're interested in is gone
+				if (fMainTeam &gt;= 0 &amp;&amp; event-&gt;team == fMainTeam) {
+					usableBufferSize = buffer + header-&gt;size - bufferStart;
+					quit = true;
+					break;
+				}
+			}
+
+			buffer += header-&gt;size;
+		}
+
+		// write buffer to file
+		if (usableBufferSize &gt; 0) {
+			status_t error = fOutput.Write(bufferStart, usableBufferSize);
+			if (error != B_OK) {
+				fprintf(stderr, &quot;%s: Failed to write buffer: %s\n&quot;,
+					kCommandName, strerror(error));
+				quit = true;
+			}
+		}
+
+		return quit;
+	}
+
+
+	static void _SignalHandler(int signal, void* data)
+	{
+		Recorder* self = (Recorder*)data;
+		self-&gt;fCaughtDeadlySignal = true;
+	}
+
+private:
+	BFile					fOutputFile;
+	BDebugEventOutputStream	fOutput;
+	team_id					fMainTeam;
+	bool					fSkipLoading;
+	bool					fCaughtDeadlySignal;
+};
+
+
+int
+main(int argc, const char* const* argv)
+{
+	Recorder recorder;
+
+	while (true) {
+		static struct option sLongOptions[] = {
+			{ &quot;help&quot;, no_argument, 0, 'h' },
+			{ 0, 0, 0, 0 }
+		};
+
+		opterr = 0; // don't print errors
+		int c = getopt_long(argc, (char**)argv, &quot;+hl&quot;, sLongOptions, NULL);
+		if (c == -1)
+			break;
+
+		switch (c) {
+			case 'h':
+				print_usage_and_exit(false);
+				break;
+			case 'l':
+				recorder.SetSkipLoading(false);
+				break;
+
+			default:
+				print_usage_and_exit(true);
+				break;
+		}
+	}
+
+	// Remaining arguments should be the output file and the optional command
+	// line.
+	if (optind &gt;= argc)
+		print_usage_and_exit(true);
+
+	const char* outputFile = argv[optind++];
+	const char* const* programArgs = argv + optind;
+	int programArgCount = argc - optind;
+
+	// prepare for battle
+	if (recorder.Init(outputFile) != B_OK)
+		exit(1);
+
+	// start the action
+	recorder.Run(programArgs, programArgCount);
+
+	return 0;
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015952.html">[Haiku-commits] r30244 - in haiku/trunk: headers/private/debug	src/kits/debug
</A></li>
	<LI>Next message: <A HREF="015954.html">[Haiku-commits] r30246 - haiku/trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15953">[ date ]</a>
              <a href="thread.html#15953">[ thread ]</a>
              <a href="subject.html#15953">[ subject ]</a>
              <a href="author.html#15953">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
