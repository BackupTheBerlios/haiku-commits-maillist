<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r29906 - in haiku/trunk: data/etc/licenses	src/apps/aboutsystem src/apps/poorman src/apps/poorman/libhttpd
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29906%20-%20in%20haiku/trunk%3A%20data/etc/licenses%0A%09src/apps/aboutsystem%20src/apps/poorman%20src/apps/poorman/libhttpd&In-Reply-To=%3C200904042103.n34L3aHE019900%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015425.html">
   <LINK REL="Next"  HREF="015429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r29906 - in haiku/trunk: data/etc/licenses	src/apps/aboutsystem src/apps/poorman src/apps/poorman/libhttpd</H1>
    <B>stippi at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r29906%20-%20in%20haiku/trunk%3A%20data/etc/licenses%0A%09src/apps/aboutsystem%20src/apps/poorman%20src/apps/poorman/libhttpd&In-Reply-To=%3C200904042103.n34L3aHE019900%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r29906 - in haiku/trunk: data/etc/licenses	src/apps/aboutsystem src/apps/poorman src/apps/poorman/libhttpd">stippi at mail.berlios.de
       </A><BR>
    <I>Sat Apr  4 23:03:36 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="015425.html">[Haiku-commits] r29905 - haiku/trunk/src/kits/tracker
</A></li>
        <LI>Next message: <A HREF="015429.html">[Haiku-commits] r29907 - haiku/trunk/src/system/kernel/debug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15427">[ date ]</a>
              <a href="thread.html#15427">[ thread ]</a>
              <a href="subject.html#15427">[ subject ]</a>
              <a href="author.html#15427">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2009-04-04 23:03:19 +0200 (Sat, 04 Apr 2009)
New Revision: 29906
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=29906&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=29906&amp;view=rev</A>

Added:
   haiku/trunk/data/etc/licenses/LibHTTPd
   haiku/trunk/src/apps/poorman/PoorManLogger.cpp
   haiku/trunk/src/apps/poorman/PoorManLogger.h
   haiku/trunk/src/apps/poorman/PoorManServer.cpp
   haiku/trunk/src/apps/poorman/PoorManServer.h
   haiku/trunk/src/apps/poorman/libhttpd/
   haiku/trunk/src/apps/poorman/libhttpd/README
   haiku/trunk/src/apps/poorman/libhttpd/config.h
   haiku/trunk/src/apps/poorman/libhttpd/libhttpd.c
   haiku/trunk/src/apps/poorman/libhttpd/libhttpd.h
   haiku/trunk/src/apps/poorman/libhttpd/match.c
   haiku/trunk/src/apps/poorman/libhttpd/match.h
   haiku/trunk/src/apps/poorman/libhttpd/mime_encodings.txt
   haiku/trunk/src/apps/poorman/libhttpd/mime_types.txt
   haiku/trunk/src/apps/poorman/libhttpd/tdate_parse.c
   haiku/trunk/src/apps/poorman/libhttpd/tdate_parse.h
   haiku/trunk/src/apps/poorman/libhttpd/version.h
Removed:
   haiku/trunk/src/apps/poorman/PoorManMainView.cpp
   haiku/trunk/src/apps/poorman/PoorManMainView.h
Modified:
   haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp
   haiku/trunk/src/apps/poorman/Jamfile
   haiku/trunk/src/apps/poorman/PoorMan.cpp
   haiku/trunk/src/apps/poorman/PoorManApplication.cpp
   haiku/trunk/src/apps/poorman/PoorManApplication.h
   haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.cpp
   haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.h
   haiku/trunk/src/apps/poorman/PoorManWindow.cpp
   haiku/trunk/src/apps/poorman/PoorManWindow.h
   haiku/trunk/src/apps/poorman/StatusSlider.cpp
   haiku/trunk/src/apps/poorman/StatusSlider.h
   haiku/trunk/src/apps/poorman/constants.cpp
   haiku/trunk/src/apps/poorman/constants.h
Log:
Patch by Ma Jie: Basically - make Poorman (the webserver) work. Libhttpd from
Jef Poskanzer is providing the backend, but had to be adopted in some ways.
Other issues in Poorman have been resolved.

When testing the license integration, I stumbled over some AboutSystem bugs,
basically clicking licenses would not open them. I fixed those in this patch,
sorry for mixing that up.

Note to Ma Jie: I changed the encoding of the libhttpd files to UTF-8!
(This affects only the (C) glyph.) Thanks a lot for your awesome work on
Poorman, it's really appreciated!


Added: haiku/trunk/data/etc/licenses/LibHTTPd
===================================================================
--- haiku/trunk/data/etc/licenses/LibHTTPd	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/data/etc/licenses/LibHTTPd	2009-04-04 21:03:19 UTC (rev 29906)
@@ -0,0 +1,25 @@
+/*
+** Copyright &#169; 1995,1998,1999,2000,2001 by Jef Poskanzer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jef at mail.acme.com</A>&gt;.
+** All rights reserved.
+**
+** Redistribution and use in source and binary forms, with or without
+** modification, are permitted provided that the following conditions
+** are met:
+** 1. Redistributions of source code must retain the above copyright
+**    notice, this list of conditions and the following disclaimer.
+** 2. Redistributions in binary form must reproduce the above copyright
+**    notice, this list of conditions and the following disclaimer in the
+**    documentation and/or other materials provided with the distribution.
+**
+** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+** SUCH DAMAGE.
+*/

Modified: haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp
===================================================================
--- haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/aboutsystem/AboutSystem.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -565,7 +565,7 @@
 	_GetLicensesPath(licensesPath);
 
 	BPath mitPath(licensesPath);
-	mitPath.Append(&quot;MIT license&quot;);
+	mitPath.Append(&quot;MIT&quot;);
 
 	font.SetSize(be_bold_font-&gt;Size() + 4);
 	font.SetFace(B_BOLD_FACE);
@@ -808,6 +808,13 @@
 //		&quot;<A HREF="http://www.opensound.com">http://www.opensound.com</A>&quot;);
 // BSD license
 
+	// libhttpd copyright (used as Poorman backend)
+	AddCopyrightEntry(&quot;libhttpd&quot;,
+		&quot;Copyright &quot; B_UTF8_COPYRIGHT &quot;1995,1998,1999,2000,2001 by &quot;
+		&quot;Jef Poskanzer. All rights reserved.&quot;,
+		Licenses(&quot;LibHTTPd&quot;, NULL),
+		&quot;<A HREF="http://www.acme.com/software/thttpd/">http://www.acme.com/software/thttpd/</A>&quot;);
+
 #ifdef __INTEL__
 	// Udis86 copyrights
 	AddCopyrightEntry(&quot;Udis86&quot;,
@@ -1018,7 +1025,7 @@
 		for (int32 i = 0; i &lt; licenses.CountLicenses(); i++) {
 			const char* license = licenses.LicenseAt(i);
 			BString licensePath(licensesPath.Path());
-			licensePath += license;
+			licensePath &lt;&lt; '/' &lt;&lt; license;
 
 			if (i &gt; 0)
 				fCreditsView-&gt;Insert(&quot;, &quot;);

Modified: haiku/trunk/src/apps/poorman/Jamfile
===================================================================
--- haiku/trunk/src/apps/poorman/Jamfile	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/Jamfile	2009-04-04 21:03:19 UTC (rev 29906)
@@ -1,19 +1,53 @@
 SubDir HAIKU_TOP src apps poorman ;
 
+SubDirCcFlags [ FDefines HAVE__PROGNAME=1 HAVE_FCNTL_H=1 HAVE_GRP_H=1 HAVE_MEMORY_H=1 HAVE_POLL_H=1 HAVE_SYS_POLL_H=1 TIME_WITH_SYS_TIME=1 HAVE_DIRENT_H=1 HAVE_STRERROR=1 HAVE_WAITPID=1 HAVE_VSNPRINTF=1 HAVE_SETSID=1 HAVE_SIGSET=1 HAVE_ATOLL=1 HAVE_UNISTD_H=1 HAVE_GETPAGESIZE=1 HAVE_MMAP=1 HAVE_SELECT=1 HAVE_POLL=1 HAVE_TM_GMTOFF=1 HAVE_SOCKLENT=1 HAVE_INT64T=1 ] ;
+
+SEARCH_SOURCE += [ FDirName $(HAIKU_TOP) src apps poorman libhttpd ] ;
+
+rule THTTPMakeHeader header : text
+{
+        header = [ FGristFiles $(header) ] ;
+        text = [ FGristFiles $(text) ] ;
+
+        SEARCH on $(text) = $(SEARCH_SOURCE) ;
+        MakeLocateArch $(header) ;
+
+        Depends $(header) : $(text) ;
+        LocalClean clean : $(header) ;
+
+        THTTPMakeHeader1 $(header) : $(text) ;
+}
+
+actions THTTPMakeHeader1
+{
+		rm -f $(1)
+		sed &lt; $(2) &gt; $(1) \
+			-e 's/#.*//' -e 's/[ 	]*$//' -e '/^$/d' \
+			-e 's/[ 	][ 	]*/&quot;, 0, &quot;/' -e 's/^/{ &quot;/' -e 's/$/&quot;, 0 },/'
+}
+
+THTTPMakeHeader mime_encodings.h : mime_encodings.txt ;
+THTTPMakeHeader mime_types.h : mime_types.txt ;
+
 AddResources PoorMan : PoorMan.rdef ;
 
 Application PoorMan : PoorMan.cpp
-	PoorManMainView.cpp
 	PoorManWindow.cpp
 	PoorManView.cpp
 	PoorManAdvancedView.cpp
 	StatusSlider.cpp
+	PoorManServer.cpp
 	PoorManSiteView.cpp
+	PoorManLogger.cpp
 	PoorManLoggingView.cpp
 	PoorManPreferencesWindow.cpp 
 	PoorManApplication.cpp
 	constants.cpp
-	: be tracker $(TARGET_LIBSTDC++)
+	
+	# libhttpd
+	libhttpd.c
+	match.c
+	tdate_parse.c
+	
+	: be network tracker $(TARGET_LIBSTDC++)
 	;
-
-

Modified: haiku/trunk/src/apps/poorman/PoorMan.cpp
===================================================================
--- haiku/trunk/src/apps/poorman/PoorMan.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorMan.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -18,4 +18,4 @@
 	//printf(&quot;be_app: %p&quot;, be_app);
 	
 	return 0;
-}
\ No newline at end of file
+}

Modified: haiku/trunk/src/apps/poorman/PoorManApplication.cpp
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManApplication.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManApplication.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -5,30 +5,35 @@
  *	Version: 0.1
  */
 
+#include &lt;Application.h&gt;
 #include &lt;Alert.h&gt;
+#include &lt;Directory.h&gt;
 
 #include &quot;constants.h&quot;
-#include &quot;PoorManView.h&quot;
 #include &quot;PoorManApplication.h&quot;
+#include &quot;PoorManWindow.h&quot;
 
-
 PoorManApplication::PoorManApplication()
 	: BApplication(STR_APP_SIG),
-	  status(false), hits(0)
+	  mainWindow(NULL)
 {
-	// -------------------------------------------
-	// Main Window
-	//PoorManView		* mainView;
-	BRect			  mainRect;
-	
-	mainRect.Set(30.0f, 30.0f, 355.0f, 185.0f);
+	BRect mainRect(82.0f, 30.0f, 400.0f, 350.0f);
 	mainWindow = new PoorManWindow(mainRect);
+	mainWindow-&gt;Hide();
+	mainWindow-&gt;Show();
 	
-	//mainRect.OffsetTo(B_ORIGIN);
-	//mainView = new PoorManView(mainRect, STR_APP_NAME);
-	//mainView-&gt;SetViewColor(216,216,216,255);
+	BDirectory webDir;
+	if(mainWindow-&gt;ReadSettings() != B_OK){
+		if(webDir.SetTo(STR_DEFAULT_WEB_DIRECTORY) != B_OK)
+			mainWindow-&gt;DefaultSettings();
+	} else {
+		if(webDir.SetTo(mainWindow-&gt;WebDir()) != B_OK)
+			mainWindow-&gt;DefaultSettings();
+	}
 	
-	mainWindow-&gt;Show();	
+	mainWindow-&gt;StartServer();
+	mainWindow-&gt;SetDirLabel(mainWindow-&gt;WebDir());
+	mainWindow-&gt;Show();
 }
 
 void 

Modified: haiku/trunk/src/apps/poorman/PoorManApplication.h
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManApplication.h	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManApplication.h	2009-04-04 21:03:19 UTC (rev 29906)
@@ -11,8 +11,8 @@
 
 #include &lt;Application.h&gt;
 
-#include &quot;PoorManWindow.h&quot;
-#include &quot;PoorManPreferencesWindow.h&quot;
+class PoorManWindow;
+//#include &quot;PoorManPreferencesWindow.h&quot;
 
 
 class PoorManApplication: public BApplication
@@ -23,13 +23,13 @@
 PoorManWindow *	GetPoorManWindow() { return mainWindow; }
 private:
 			PoorManWindow				* mainWindow;
-			PoorManPreferencesWindow	* prefWindow;
+			//PoorManPreferencesWindow	* prefWindow;
 			
 			// --------------------------------------------
 			// settings variables
-			bool	status;
-			char	directory[512];
-			uint32	hits;	
+			//bool	status;
+			//char	directory[512];
+			//uint32	hits;	
 	
 };
 

Added: haiku/trunk/src/apps/poorman/PoorManLogger.cpp
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManLogger.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManLogger.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Author(s):
+ *		Ma Jie, china.majie at gmail
+ */
+
+#include &quot;PoorManLogger.h&quot;
+
+#include &lt;time.h&gt;
+#include &lt;netinet/in.h&gt;
+
+#include &lt;Messenger.h&gt;
+#include &lt;Message.h&gt;
+#include &lt;TypeConstants.h&gt;
+
+#include &quot;PoorManApplication.h&quot;
+#include &quot;PoorManWindow.h&quot;
+
+void
+poorman_log(const char* msg, bool needTimeHeader,
+	in_addr_t addr, rgb_color color)
+{
+	time_t now = time(NULL);
+	
+	PoorManWindow* window = static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;GetPoorManWindow();
+
+	if(!window-&gt;LogConsoleFlag() &amp;&amp; !window-&gt;LogFileFlag())
+		return;
+	
+	BMessenger messenger(window);
+	BMessage message(MSG_LOG);
+	
+	if(message.AddString(&quot;cstring&quot;, msg) != B_OK)
+		return;
+	if(needTimeHeader){
+		if(message.AddData(&quot;time_t&quot;, B_TIME_TYPE, &amp;now, sizeof(time_t)) != B_OK)
+			return;
+	}
+	if(addr != INADDR_NONE)
+		message.AddData(&quot;in_addr_t&quot;, B_ANY_TYPE, &amp;addr, sizeof(in_addr_t));
+	
+	if(color != BLACK)
+		message.AddData(&quot;rgb_color&quot;, B_RGB_COLOR_TYPE, &amp;color, sizeof(rgb_color));
+
+	messenger.SendMessage(&amp;message, (BHandler*)NULL, 1000000);
+}

Added: haiku/trunk/src/apps/poorman/PoorManLogger.h
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManLogger.h	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManLogger.h	2009-04-04 21:03:19 UTC (rev 29906)
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Author(s):
+ *		Ma Jie, china.majie at gmail
+ */
+#ifndef POOR_MAN_LOG_H
+#define POOR_MAN_LOG_H
+
+#include &lt;netinet/in.h&gt;
+
+#include &quot;constants.h&quot; //for rgb_color BLACK
+
+#ifdef __cplusplus
+	extern &quot;C&quot;
+	void poorman_log(
+		const char* msg,
+		bool needTimeHeader = true,
+		in_addr_t addr = INADDR_NONE,
+		rgb_color color = BLACK
+	);
+#else //c version is for libhttpd
+	void poorman_log(
+		const char* msg,
+		bool needTimeHeader,
+		in_addr_t addr,
+		rgb_color color
+	);
+#endif
+
+
+#endif	// POOR_MAN_LOG_H

Deleted: haiku/trunk/src/apps/poorman/PoorManMainView.cpp

Deleted: haiku/trunk/src/apps/poorman/PoorManMainView.h

Modified: haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.cpp
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -8,14 +8,14 @@
 #include &lt;Window.h&gt;
 #include &lt;Box.h&gt;
 #include &lt;Directory.h&gt;
-#include &lt;iostream&gt;
+#include &lt;Debug.h&gt;
 
 #include &quot;constants.h&quot;
 #include &quot;PoorManWindow.h&quot;
 #include &quot;PoorManApplication.h&quot;
 #include &quot;PoorManPreferencesWindow.h&quot;
+#include &quot;PoorManServer.h&quot;
 
-
 PoorManPreferencesWindow::PoorManPreferencesWindow(BRect frame, char * name)
 	: BWindow(frame, name, B_TITLED_WINDOW, B_NOT_ZOOMABLE | B_NOT_RESIZABLE),
 	webDirFilePanel(NULL),
@@ -102,7 +102,7 @@
 	BMessenger messenger(this);
 	BMessage message(MSG_FILE_PANEL_SELECT_WEB_DIR);
 	webDirFilePanel = new BFilePanel(B_OPEN_PANEL, &amp;messenger, NULL,
-		B_DIRECTORY_NODE, false, &amp;message);
+		B_DIRECTORY_NODE, false, &amp;message, NULL, true);
 
 	webDirFilePanel-&gt;SetPanelDirectory(new BDirectory(&quot;/boot/home/public_html&quot;));
 	webDirFilePanel-&gt;SetButtonLabel(B_DEFAULT_BUTTON, &quot;Select&quot;);
@@ -120,39 +120,44 @@
 
 }
 
-
 PoorManPreferencesWindow::~PoorManPreferencesWindow()
 {
 	delete logFilePanel;
 	delete webDirFilePanel;
 }
 
-
 void
 PoorManPreferencesWindow::MessageReceived(BMessage* message)
 {
 	switch (message-&gt;what) {
 	case MSG_PREF_BTN_DONE:
 			PoorManWindow		*	win;
+			PoorManServer* server;
 			win = ((PoorManApplication *)be_app)-&gt;GetPoorManWindow();
+			server = win-&gt;GetServer();
 
-			std::cout &lt;&lt; &quot;Pref Window: sendDir CheckBox: &quot; &lt;&lt; siteView-&gt;SendDirValue() &lt;&lt; std::endl;
+			PRINT((&quot;Pref Window: sendDir CheckBox: %d\n&quot;, siteView-&gt;SendDirValue()));
+			server-&gt;SetListDir(siteView-&gt;SendDirValue());
 			win-&gt;SetDirListFlag(siteView-&gt;SendDirValue());
-			std::cout &lt;&lt; &quot;Pref Window: indexFileName TextControl: &quot; &lt;&lt; siteView-&gt;IndexFileName() &lt;&lt; std::endl;
-			win-&gt;SetIndexFileName(siteView-&gt;IndexFileName());
-			std::cout &lt;&lt; &quot;Pref Window: webDir: &quot; &lt;&lt; siteView-&gt;WebDir() &lt;&lt; std::endl;
-			win-&gt;SetWebDir(siteView-&gt;WebDir());
-			win-&gt;SetDirLabel(siteView-&gt;WebDir());
+			PRINT((&quot;Pref Window: indexFileName TextControl: %s\n&quot;, siteView-&gt;IndexFileName()));
+			if(server-&gt;SetIndexName(siteView-&gt;IndexFileName()) == B_OK)
+				win-&gt;SetIndexFileName(siteView-&gt;IndexFileName());
+			PRINT((&quot;Pref Window: webDir: %s\n&quot;, siteView-&gt;WebDir()));
+			if(server-&gt;SetWebDir(siteView-&gt;WebDir()) == B_OK){
+				win-&gt;SetWebDir(siteView-&gt;WebDir());
+				win-&gt;SetDirLabel(siteView-&gt;WebDir());
+			}
 
-			std::cout &lt;&lt; &quot;Pref Window: logConsole CheckBox: &quot; &lt;&lt; loggingView-&gt;LogConsoleValue() &lt;&lt; std::endl;
+			PRINT((&quot;Pref Window: logConsole CheckBox: %d\n&quot;, loggingView-&gt;LogConsoleValue()));
 			win-&gt;SetLogConsoleFlag(loggingView-&gt;LogConsoleValue());
-			std::cout &lt;&lt; &quot;Pref Window: logFile CheckBox: &quot; &lt;&lt; loggingView-&gt;LogFileValue() &lt;&lt; std::endl;
+			PRINT((&quot;Pref Window: logFile CheckBox: %d\n&quot;, loggingView-&gt;LogFileValue()));
 			win-&gt;SetLogFileFlag(loggingView-&gt;LogFileValue());
-			std::cout &lt;&lt; &quot;Pref Window: logFileName: &quot; &lt;&lt; loggingView-&gt;LogFileName() &lt;&lt; std::endl;
+			PRINT((&quot;Pref Window: logFileName: %s\n&quot;, loggingView-&gt;LogFileName()));
 			win-&gt;SetLogPath(loggingView-&gt;LogFileName());
 
-			std::cout &lt;&lt; &quot;Pref Window: MaxConnections Slider: &quot; &lt;&lt; advancedView-&gt;MaxSimultaneousConnections() &lt;&lt; std::endl;
-			win-&gt;SetMaxConnections(advancedView-&gt;MaxSimultaneousConnections());
+			PRINT((&quot;Pref Window: MaxConnections Slider: %ld\n&quot;, advancedView-&gt;MaxSimultaneousConnections()));
+			server-&gt;SetMaxConns(advancedView-&gt;MaxSimultaneousConnections());
+			win-&gt;SetMaxConnections((int16)advancedView-&gt;MaxSimultaneousConnections());
 
 
 			if (Lock())
@@ -169,7 +174,7 @@
 		break;
 	case MSG_FILE_PANEL_SELECT_WEB_DIR:
 			// handle the open BMessage from the Select Web Directory File Panel
-			std::cout &lt;&lt; &quot;Select Web Directory:\n&quot; &lt;&lt; std::endl;
+			PRINT((&quot;Select Web Directory:\n&quot;));
 			SelectWebDir(message);
 		break;
 	case MSG_PREF_LOG_BTN_CREATE_FILE:
@@ -178,12 +183,12 @@
 		break;
 	case MSG_FILE_PANEL_CREATE_LOG_FILE:
 			// handle the save BMessage from the Create Log File Panel
-			std::cout &lt;&lt; &quot;Create Log File:\n&quot; &lt;&lt; std::endl;
+			PRINT((&quot;Create Log File:\n&quot;));
 			CreateLogFile(message);
 		break;
 	case MSG_PREF_ADV_SLD_MAX_CONNECTION:
 			max_connections = advancedView-&gt;MaxSimultaneousConnections();
-			std::cout &lt;&lt; &quot;Max Connections: &quot; &lt;&lt; max_connections &lt;&lt; std::endl;
+			PRINT((&quot;Max Connections: %ld\n&quot;, max_connections));
 		break;
 
 	default:
@@ -212,8 +217,20 @@
 	//	;//return err;
 	entry.GetPath(&amp;path);
 
-	std::cout &lt;&lt; &quot;DIR: &quot; &lt;&lt; path.Path() &lt;&lt; std::endl;
+	PRINT((&quot;DIR: %s\n&quot;, path.Path()));
 	siteView-&gt;SetWebDir(path.Path());
+	
+	bool temp;
+	if(message-&gt;FindBool(&quot;Default Dialog&quot;, &amp;temp) == B_OK){
+		PoorManWindow* win = ((PoorManApplication *)be_app)-&gt;GetPoorManWindow();
+		if(win-&gt;GetServer()-&gt;SetWebDir(siteView-&gt;WebDir()) == B_OK){
+			win-&gt;SetWebDir(siteView-&gt;WebDir());
+			win-&gt;SetDirLabel(siteView-&gt;WebDir());
+		}
+		win-&gt;StartServer();
+		if(Lock())
+			Quit();
+	}
 }
 
 void
@@ -236,7 +253,7 @@
 	//	;//return err;
 	entry.GetPath(&amp;path);
 	path.Append(name);
-	std::cout &lt;&lt; &quot;Log File: &quot; &lt;&lt; path.Path() &lt;&lt; std::endl;
+	PRINT((&quot;Log File: %s\n&quot;, path.Path()));
 
 	if (err == B_OK)
 	{
@@ -246,3 +263,15 @@
 
 	// mark the checkbox
 }
+
+/*A special version for &quot;the default dialog&quot;, don't use it in MessageReceived()*/
+void
+PoorManPreferencesWindow::ShowWebDirFilePanel()
+{
+	BMessage message(MSG_FILE_PANEL_SELECT_WEB_DIR);
+	message.AddBool(&quot;Default Dialog&quot;, true);
+	
+	webDirFilePanel-&gt;SetMessage(&amp;message);
+	if(!webDirFilePanel-&gt;IsShowing())
+		webDirFilePanel-&gt;Show();
+}

Modified: haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.h
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.h	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManPreferencesWindow.h	2009-04-04 21:03:19 UTC (rev 29906)
@@ -72,7 +72,7 @@
 
 virtual	void	MessageReceived(BMessage * message);
 
-		void	ShowWebDirFilePanel() { if (!webDirFilePanel-&gt;IsShowing()) webDirFilePanel-&gt;Show(); }
+		void	ShowWebDirFilePanel();
 		void	SelectWebDir(BMessage * message);
 		void	CreateLogFile(BMessage * message);
 };

Added: haiku/trunk/src/apps/poorman/PoorManServer.cpp
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManServer.cpp	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManServer.cpp	2009-04-04 21:03:19 UTC (rev 29906)
@@ -0,0 +1,424 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Author(s):
+ *		Ma Jie, china.majie at gmail
+ */
+
+#include &quot;PoorManServer.h&quot;
+
+#include &lt;pthread.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;time.h&gt; //for struct timeval
+#include &lt;sys/socket.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;arpa/inet.h&gt;
+
+#include &lt;File.h&gt;
+#include &lt;Debug.h&gt;
+#include &lt;OS.h&gt;
+#include &lt;String.h&gt;
+#include &lt;StorageDefs.h&gt;
+#include &lt;SupportDefs.h&gt;
+
+#include &quot;PoorManApplication.h&quot;
+#include &quot;PoorManLogger.h&quot;
+#include &quot;PoorManWindow.h&quot;
+#include &quot;libhttpd/libhttpd.h&quot;
+
+PoorManServer::PoorManServer(const char* webDir,
+	int32 maxConns,	bool listDir,const char* idxName)
+	:fIsRunning(false),
+	 fMaxConns(maxConns),
+	 fIndexName(new char[strlen(idxName)+1]),
+	 fCurConns(0)
+{
+	fHttpdServer = httpd_initialize(
+		(char*)0,//hostname
+		(httpd_sockaddr*)0,//sa4P
+		(httpd_sockaddr*)0,//sa6P
+		(unsigned short)80,//port
+		(char*)0,//cgi pattern
+		0,//cgi_limit
+		&quot;iso-8859-1&quot;,//charset
+		&quot;&quot;,//p3p
+		-1,//max_age
+		const_cast&lt;char*&gt;(webDir),//cwd
+		1,//no_log
+		(FILE*)0,//logfp
+		0,//no_symlink_check
+		0,//vhost
+		0,//global_passwd
+		(char*)0,//url_pattern
+		(char*)0,//local_pattern
+		0//no_empty_referers
+	);
+	
+	strcpy(fIndexName, idxName);
+	
+	size_t cwdLen = strlen(fHttpdServer-&gt;cwd);
+	if(fHttpdServer-&gt;cwd[cwdLen-1] == '/'){
+		fHttpdServer-&gt;cwd[cwdLen-1] = '\0';
+	}
+	
+	fHttpdServer-&gt;do_list_dir = (listDir?1:0);
+	fHttpdServer-&gt;index_name = fIndexName;
+	
+	pthread_rwlock_init(&amp;fWebDirLock, NULL);
+	pthread_rwlock_init(&amp;fIndexNameLock, NULL);
+}
+
+PoorManServer::~PoorManServer()
+{
+	Stop();
+	httpd_terminate(fHttpdServer);
+	delete[] fIndexName;
+	pthread_rwlock_destroy(&amp;fWebDirLock);
+	pthread_rwlock_destroy(&amp;fIndexNameLock);
+}
+
+status_t PoorManServer::Run()
+{
+	if(chdir(fHttpdServer-&gt;cwd) == -1){
+		poorman_log(&quot;no web directory, can't start up.\n&quot;, false, INADDR_NONE, RED);
+		return B_ERROR;
+	}
+	
+	httpd_sockaddr sa4;
+	memset(&amp;sa4,0,sizeof(httpd_sockaddr));
+	sa4.sa_in.sin_family = AF_INET;
+	sa4.sa_in.sin_port = htons(80);
+	sa4.sa_in.sin_addr.s_addr = htonl(INADDR_ANY);
+	fHttpdServer-&gt;listen4_fd = httpd_initialize_listen_socket(&amp;sa4);
+	if(fHttpdServer-&gt;listen4_fd == -1)
+		return B_ERROR;
+
+	fListenerTid = spawn_thread(
+		PoorManServer::_Listener,
+		&quot;www listener&quot;,
+		B_NORMAL_PRIORITY,
+		static_cast&lt;void*&gt;(this)
+	);
+	if(fListenerTid &lt; B_OK){
+		poorman_log(&quot;can't create listener thread.\n&quot;, false, INADDR_NONE, RED);
+		return B_ERROR;
+	}
+	fIsRunning = true;
+	if(resume_thread(fListenerTid) != B_OK){
+		fIsRunning = false;
+		return B_ERROR;
+	}
+	
+	//our server is up and running
+	return B_OK;
+}
+
+status_t PoorManServer::Stop()
+{
+	if(fIsRunning){
+		fIsRunning = false;
+		httpd_unlisten(fHttpdServer);
+	}
+	return B_OK;
+}
+
+/*The Web Dir is not changed if an error occured.
+ */
+status_t PoorManServer::SetWebDir(const char* webDir)
+{
+	if(chdir(webDir) == -1){
+		//log it
+		return B_ERROR;
+	}
+
+	char* tmp = strdup(webDir);
+	if(tmp == NULL)
+		return B_ERROR;
+	
+	if(pthread_rwlock_wrlock(&amp;fWebDirLock) == 0){
+		free(fHttpdServer-&gt;cwd);
+		fHttpdServer-&gt;cwd = tmp;
+		if(tmp[strlen(tmp)-1] == '/'){
+			tmp[strlen(tmp)-1] = '\0';
+		}
+		pthread_rwlock_unlock(&amp;fWebDirLock);
+	} else {
+		free(tmp);
+		return B_ERROR;
+	}
+
+	return B_OK;
+}
+
+status_t PoorManServer::SetMaxConns(int32 count)
+{
+	fMaxConns = count;
+	return B_OK;
+}
+
+status_t PoorManServer::SetListDir(bool listDir)
+{
+	fHttpdServer-&gt;do_list_dir = (listDir?1:0);
+	return B_OK;
+}
+
+status_t PoorManServer::SetIndexName(const char* idxName)
+{
+	size_t length = strlen(idxName);
+	if(length &gt; B_PATH_NAME_LENGTH+1)
+		return B_ERROR;
+	
+	char* tmp = new char[length+1];
+	if(tmp == NULL)
+		return B_ERROR;
+	
+	strcpy(tmp, idxName);
+	if(pthread_rwlock_wrlock(&amp;fIndexNameLock) == 0){
+		delete[] fIndexName;
+		fIndexName = tmp;
+		fHttpdServer-&gt;index_name = fIndexName;
+		pthread_rwlock_unlock(&amp;fIndexNameLock);
+	} else {
+		delete[] tmp;
+		return B_ERROR;
+	}
+	
+	return B_OK;
+}
+
+int32 PoorManServer::_Listener(void* data)
+{
+	PRINT((&quot;The listener thread is working.\n&quot;));
+	int retval;
+	thread_id tid;
+	httpd_conn* hc;
+	PoorManServer* s = static_cast&lt;PoorManServer*&gt;(data);
+	
+	while(s-&gt;fIsRunning){
+		hc = new httpd_conn;
+		hc-&gt;initialized = 0;
+		PRINT((&quot;calling httpd_get_conn()\n&quot;));
+		retval = //accept(), blocked here
+			httpd_get_conn(s-&gt;fHttpdServer, s-&gt;fHttpdServer-&gt;listen4_fd, hc);
+		switch (retval){
+		case GC_OK:
+			break;
+		case GC_FAIL:
+			httpd_destroy_conn(hc);
+			delete hc;
+			s-&gt;fIsRunning = false;
+			return -1;
+		case GC_NO_MORE: //should not happen, since we have a blocking socket
+			httpd_destroy_conn(hc);
+			continue;
+			break;
+		default: //shouldn't happen
+			continue;
+			break;
+		}
+		
+		if(s-&gt;fCurConns &gt; s-&gt;fMaxConns){
+			httpd_send_err(hc, 503,
+				httpd_err503title, &quot;&quot;, httpd_err503form, &quot;&quot;);
+			httpd_write_response(hc);
+			continue;
+		}
+		
+		tid = spawn_thread(
+			PoorManServer::_Worker,
+			&quot;www connection&quot;,
+			B_NORMAL_PRIORITY,
+			static_cast&lt;void*&gt;(s)
+		);
+		if(tid &lt; B_OK){
+			continue;
+		}
+		/*We don't check the return code here.
+		 *As we can't kill a thread that doesn't receive the
+		 *httpd_conn, we simply let it die itself.
+		 */
+		send_data(tid, 512, &amp;hc, sizeof(httpd_conn*));
+		atomic_add(&amp;s-&gt;fCurConns, 1);
+		resume_thread(tid);
+	}//while
+	return 0;
+}
+
+int32 PoorManServer::_Worker(void* data)
+{
+	static const struct timeval kTimeVal = {60, 0};
+	PoorManServer* s = static_cast&lt;PoorManServer*&gt;(data);
+	httpd_conn* hc;
+	int retval;
+	
+	if(has_data(find_thread(NULL))){
+		thread_id sender;
+		if(receive_data(&amp;sender, &amp;hc, sizeof(httpd_conn*)) != 512)
+			goto cleanup;
+	} else {
+		goto cleanup;
+	}
+	
+	PRINT((&quot;A worker thread starts to work.\n&quot;));
+
+	setsockopt(hc-&gt;conn_fd, SOL_SOCKET, SO_RCVTIMEO, &amp;kTimeVal, sizeof(struct timeval));	
+	retval = recv(
+		hc-&gt;conn_fd,
+		&amp;(hc-&gt;read_buf[hc-&gt;read_idx]),
+		hc-&gt;read_size - hc-&gt;read_idx,
+		0
+	);
+	if(retval &lt; 0)
+		goto cleanup;
+
+	hc-&gt;read_idx += retval;
+	switch(httpd_got_request(hc)){
+	case GR_GOT_REQUEST:
+		break;
+	case GR_BAD_REQUEST:
+		httpd_send_err(hc,400,httpd_err400title,&quot;&quot;,httpd_err400form,&quot;&quot;);
+		httpd_write_response(hc);//fall through
+	case GR_NO_REQUEST: //fall through
+	default: //won't happen
+		goto cleanup;
+		break;
+	}
+	
+	if(httpd_parse_request(hc) &lt; 0){
+		httpd_write_response(hc);
+		goto cleanup;
+	}
+	
+	retval = httpd_start_request(hc,(struct timeval*)0);
+	if(retval &lt; 0){
+		httpd_write_response(hc);
+		goto cleanup;
+	}
+	
+	/*true means the connection is already handled
+	 *by the directory index generator in httpd_start_request().
+	 */
+	if(hc-&gt;file_address == (char*) 0){
+		static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;GetPoorManWindow()-&gt;SetHits(
+			static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;GetPoorManWindow()-&gt;GetHits()+1
+		);
+		hc-&gt;conn_fd = -1;
+		goto cleanup;
+	}
+	
+	switch(hc-&gt;method){
+	case METHOD_GET:
+		s-&gt;_HandleGet(hc);
+		break;
+	case METHOD_HEAD:
+		s-&gt;_HandleHead(hc);
+		break;
+	case METHOD_POST:
+		s-&gt;_HandlePost(hc);
+		break;
+	default:
+		break;
+	}
+	
+cleanup: ;
+	httpd_close_conn(hc,(struct timeval*)0);
+	httpd_destroy_conn(hc);
+	
+	delete hc;
+	atomic_add(&amp;s-&gt;fCurConns, -1);
+	return 0;
+}
+
+status_t PoorManServer::_HandleGet(httpd_conn* hc)
+{
+	PRINT((&quot;HandleGet() called\n&quot;));
+	
+	off_t length;
+	ssize_t bytesRead;
+	uint8* buf;
+	BString log;
+	
+	BFile file(hc-&gt;expnfilename, B_READ_ONLY);
+	if(file.InitCheck() != B_OK)
+		return B_ERROR;
+	
+	buf = new uint8[POOR_MAN_BUF_SIZE];
+	if(buf == NULL)
+		return B_ERROR;
+	
+	if(hc-&gt;got_range == 1)
+		length = hc-&gt;last_byte_index + 1 - hc-&gt;first_byte_index;
+	else 
+		length = hc-&gt;sb.st_size;
+	
+	static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;GetPoorManWindow()-&gt;SetHits(
+		static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;GetPoorManWindow()-&gt;GetHits()+1
+	);
+	
+	log.SetTo(&quot;Sending file: &quot;);
+	if(pthread_rwlock_rdlock(&amp;fWebDirLock) == 0){
+		log &lt;&lt; hc-&gt;hs-&gt;cwd;
+		pthread_rwlock_unlock(&amp;fWebDirLock);
+	}
+	log &lt;&lt; '/' &lt;&lt; hc-&gt;expnfilename &lt;&lt; '\n';
+	poorman_log(log.String(), true, hc-&gt;client_addr.sa_in.sin_addr.s_addr);
+	
+	//send mime headers
+	if(send(hc-&gt;conn_fd,hc-&gt;response,hc-&gt;responselen,0) &lt; 0){
+		delete [] buf;
+		return B_ERROR;
+	}
+	
+	file.Seek(hc-&gt;first_byte_index, SEEK_SET);
+	while(true){
+		bytesRead = file.Read(buf, POOR_MAN_BUF_SIZE);
+		if(bytesRead == 0)
+			break;
+		else if(bytesRead &lt; 0){
+			delete [] buf;
+			return B_ERROR;
+		}
+		if(send(hc-&gt;conn_fd, (void*)buf, bytesRead, 0) &lt; 0){
+			log.SetTo(&quot;Error sending file: &quot;);
+			if(pthread_rwlock_rdlock(&amp;fWebDirLock) == 0){
+				log &lt;&lt; hc-&gt;hs-&gt;cwd;
+				pthread_rwlock_unlock(&amp;fWebDirLock);
+			}
+			log &lt;&lt; '/' &lt;&lt; hc-&gt;expnfilename &lt;&lt; '\n';
+			poorman_log(log.String(), true, hc-&gt;client_addr.sa_in.sin_addr.s_addr, RED);
+			delete [] buf;
+			return B_ERROR;
+		}
+	}
+	
+	delete [] buf;
+	return B_OK;
+}
+
+status_t PoorManServer::_HandleHead(httpd_conn* hc)
+{
+	int retval = send(hc-&gt;conn_fd,hc-&gt;response,hc-&gt;responselen,0);
+	if(retval == -1)
+		return B_ERROR;
+	return B_OK;
+}
+
+status_t PoorManServer::_HandlePost(httpd_conn* hc)
+{
+	//not implemented
+	return B_OK;
+}
+
+pthread_rwlock_t* get_web_dir_lock()
+{
+	return static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;
+		GetPoorManWindow()-&gt;GetServer()-&gt;GetWebDirLock();
+}
+
+pthread_rwlock_t* get_index_name_lock()
+{
+	return static_cast&lt;PoorManApplication*&gt;(be_app)-&gt;
+		GetPoorManWindow()-&gt;GetServer()-&gt;GetIndexNameLock();
+}

Added: haiku/trunk/src/apps/poorman/PoorManServer.h
===================================================================
--- haiku/trunk/src/apps/poorman/PoorManServer.h	2009-04-04 17:26:52 UTC (rev 29905)
+++ haiku/trunk/src/apps/poorman/PoorManServer.h	2009-04-04 21:03:19 UTC (rev 29906)
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2009 Haiku Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Author(s):
+ *		Ma Jie, china.majie at gmail
+ */
+#ifndef POOR_MAN_SERVER_H
+#define POOR_MAN_SERVER_H
+
+#include &lt;pthread.h&gt;
+
+#include &lt;OS.h&gt;
+#include &lt;SupportDefs.h&gt;
+
+#include &quot;libhttpd/libhttpd.h&quot;
+
+#define POOR_MAN_BUF_SIZE 1048576ll
+
+#ifdef __cplusplus
+class PoorManServer{
+public:
+						PoorManServer(const char* webDir, int32 maxConns,
+							bool listDir, const char* idxName);
+	virtual             ~PoorManServer();
+
+			status_t	Run();
+			status_t	Stop();
+
+			bool        IsRunning()const{return fIsRunning;}
+			
+			status_t    SetWebDir(const char* webDir);
+			status_t    SetMaxConns(int32 count);
+			status_t	SetListDir(bool listDir);
+			status_t	SetIndexName(const char* idxName);
+
+			pthread_rwlock_t* GetWebDirLock(){return &fWebDirLock;}
+			pthread_rwlock_t* GetIndexNameLock(){return &fIndexNameLock;}
+private:
+			bool        fIsRunning;
+			int32       fMaxConns;//Max Thread Count
+			char*		fIndexName;//Index File Name
+			
+			thread_id	  fListenerTid;
+			int32		  fCurConns;
+			httpd_server* fHttpdServer;
+			
+			pthread_rwlock_t fWebDirLock;
+			pthread_rwlock_t fIndexNameLock;
+			
+			PoorManServer(){}
+			PoorManServer(PoorManServer&amp; s){}
+			PoorManServer&amp; operator=(PoorManServer&amp; s){return *this;}
+
+	//two thread functions.
+	static 	int32		_Listener(void* data);
+	static  int32		_Worker(void* data);
+	
+			status_t   _HandleGet(httpd_conn* hc);
+			status_t   _HandleHead(httpd_conn* hc);
+			status_t   _HandlePost(httpd_conn* hc);
+};
+#endif

[... truncated: 6171 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015425.html">[Haiku-commits] r29905 - haiku/trunk/src/kits/tracker
</A></li>
	<LI>Next message: <A HREF="015429.html">[Haiku-commits] r29907 - haiku/trunk/src/system/kernel/debug
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15427">[ date ]</a>
              <a href="thread.html#15427">[ thread ]</a>
              <a href="subject.html#15427">[ subject ]</a>
              <a href="author.html#15427">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
