<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30137 -	haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30137%20-%0A%09haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib&In-Reply-To=%3C200904121232.n3CCWunn000228%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015779.html">
   <LINK REL="Next"  HREF="015784.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30137 -	haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib</H1>
    <B>anevilyak at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30137%20-%0A%09haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib&In-Reply-To=%3C200904121232.n3CCWunn000228%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30137 -	haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib">anevilyak at mail.berlios.de
       </A><BR>
    <I>Sun Apr 12 14:32:56 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="015779.html">[Haiku-commits] r30136 - in	haiku/trunk/src/add-ons/media/plugins/ape_reader:	LibMonkeysAudio MAClib
</A></li>
        <LI>Next message: <A HREF="015784.html">[Haiku-commits] r30138 -	haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15783">[ date ]</a>
              <a href="thread.html#15783">[ thread ]</a>
              <a href="subject.html#15783">[ subject ]</a>
              <a href="author.html#15783">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: anevilyak
Date: 2009-04-12 14:32:49 +0200 (Sun, 12 Apr 2009)
New Revision: 30137
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30137&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30137&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCreate.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCreate.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEDecompress.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEDecompress.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEHeader.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEHeader.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEInfo.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APEInfo.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APELink.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APELink.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APESimple.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APETag.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APETag.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/All.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Assembly.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Assembly.nasm
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/BitArray.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/BitArray.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/CharacterHelper.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/CharacterHelper.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/CircleBuffer.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/CircleBuffer.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/GlobalFunctions.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/GlobalFunctions.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/ID3Genres.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/IO.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Jamfile
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MACLib.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MACLib.dsp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MACLib.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MACProgressHelper.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MACProgressHelper.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MD5.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/MD5.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/NNFilter.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/NNFilter.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/NewPredictor.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/NewPredictor.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/NoWindows.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Predictor.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Prepare.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Prepare.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/RollBuffer.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/ScaledFirstOrderFilter.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/SmartPtr.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/StartFilter.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/StdLibFileIO.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/StdLibFileIO.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/Tools.inc
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/UnBitArray.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/UnBitArray.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/UnBitArrayBase.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/UnBitArrayBase.h
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/WAVInputSource.cpp
   haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/WAVInputSource.h
Log:
These were using CR/LF for some reason.



Modified: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.cpp	2009-04-12 10:08:22 UTC (rev 30136)
+++ haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.cpp	2009-04-12 12:32:49 UTC (rev 30137)
@@ -1,246 +1,246 @@
-#include &quot;All.h&quot;
-#include &quot;APECompress.h&quot;
-#include IO_HEADER_FILE
-#include &quot;APECompressCreate.h&quot;
-#include &quot;WAVInputSource.h&quot;
-
-CAPECompress::CAPECompress()
-{
-    m_nBufferHead        = 0;
-    m_nBufferTail        = 0;
-    m_nBufferSize        = 0;
-    m_bBufferLocked        = FALSE;
-    m_bOwnsOutputIO        = FALSE;
-    m_pioOutput            = NULL;
-
-    m_spAPECompressCreate.Assign(new CAPECompressCreate());
-
-    m_pBuffer = NULL;
-}
-
-CAPECompress::~CAPECompress()
-{
-    SAFE_ARRAY_DELETE(m_pBuffer)
-
-    if (m_bOwnsOutputIO)
-    {
-        SAFE_DELETE(m_pioOutput)
-    }
-}
-
-int CAPECompress::Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
-{
-    m_pioOutput = new IO_CLASS_NAME;
-    m_bOwnsOutputIO = TRUE;
-    
-    if (m_pioOutput-&gt;Create(pOutputFilename) != 0)
-    {
-        return ERROR_INVALID_OUTPUT_FILE;
-    }
-        
-    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
-        pHeaderData, nHeaderBytes);
-    
-    SAFE_ARRAY_DELETE(m_pBuffer)
-    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
-    m_pBuffer = new unsigned char [m_nBufferSize];
-    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
-
-    return ERROR_SUCCESS;
-}
-
-int CAPECompress::StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
-{
-    m_pioOutput = pioOutput;
-    m_bOwnsOutputIO = FALSE;
-
-    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
-        pHeaderData, nHeaderBytes);
-
-    SAFE_ARRAY_DELETE(m_pBuffer)
-    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
-    m_pBuffer = new unsigned char [m_nBufferSize];
-    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
-
-    return ERROR_SUCCESS;
-}
-
-int CAPECompress::GetBufferBytesAvailable()
-{
-    return m_nBufferSize - m_nBufferTail;
-}
-
-int CAPECompress::UnlockBuffer(int nBytesAdded, BOOL bProcess)
-{
-    if (m_bBufferLocked == FALSE)
-        return ERROR_UNDEFINED;
-    
-    m_nBufferTail += nBytesAdded;
-    m_bBufferLocked = FALSE;
-    
-    if (bProcess)
-    {
-        int nRetVal = ProcessBuffer();
-        if (nRetVal != 0) { return nRetVal; }
-    }
-    
-    return ERROR_SUCCESS;
-}
-
-unsigned char * CAPECompress::LockBuffer(int * pBytesAvailable)
-{
-    if (m_pBuffer == NULL) { return NULL; }
-    
-    if (m_bBufferLocked)
-        return NULL;
-    
-    m_bBufferLocked = TRUE;
-    
-    if (pBytesAvailable)
-        *pBytesAvailable = GetBufferBytesAvailable();
-    
-    return &amp;m_pBuffer[m_nBufferTail];
-}
-
-int CAPECompress::AddData(unsigned char * pData, int nBytes)
-{
-    if (m_pBuffer == NULL) return ERROR_INSUFFICIENT_MEMORY;
-
-    int nBytesDone = 0;
-    
-    while (nBytesDone &lt; nBytes)
-    {
-        // lock the buffer
-        int nBytesAvailable = 0;
-        unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
-        if (pBuffer == NULL || nBytesAvailable &lt;= 0)
-            return ERROR_UNDEFINED;
-        
-        // calculate how many bytes to copy and add that much to the buffer
-        int nBytesToProcess = min(nBytesAvailable, nBytes - nBytesDone);
-        memcpy(pBuffer, &amp;pData[nBytesDone], nBytesToProcess);
-                        
-        // unlock the buffer (fail if not successful)
-        int nRetVal = UnlockBuffer(nBytesToProcess);
-        if (nRetVal != ERROR_SUCCESS)
-                return nRetVal;
-
-        // update our progress
-        nBytesDone += nBytesToProcess;
-    }
-
-    return ERROR_SUCCESS;
-} 
-
-int CAPECompress::Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes)
-{
-    RETURN_ON_ERROR(ProcessBuffer(TRUE))
-    return m_spAPECompressCreate-&gt;Finish(pTerminatingData, nTerminatingBytes, nWAVTerminatingBytes);
-}
-
-int CAPECompress::Kill()
-{
-    return ERROR_SUCCESS;
-}
-
-int CAPECompress::ProcessBuffer(BOOL bFinalize)
-{
-    if (m_pBuffer == NULL) { return ERROR_UNDEFINED; }
-    
-    try
-    {
-        // process as much as possible
-        int nThreshold = (bFinalize) ? 0 : m_spAPECompressCreate-&gt;GetFullFrameBytes();
-        
-        while ((m_nBufferTail - m_nBufferHead) &gt;= nThreshold)
-        {
-            int nFrameBytes = min(m_spAPECompressCreate-&gt;GetFullFrameBytes(), m_nBufferTail - m_nBufferHead);
-            
-            if (nFrameBytes == 0)
-                break;
-
-            int nRetVal = m_spAPECompressCreate-&gt;EncodeFrame(&amp;m_pBuffer[m_nBufferHead], nFrameBytes);
-            if (nRetVal != 0) { return nRetVal; }
-            
-            m_nBufferHead += nFrameBytes;
-        }
-        
-        // shift the buffer
-        if (m_nBufferHead != 0)
-        {
-            int nBytesLeft = m_nBufferTail - m_nBufferHead;
-            
-            if (nBytesLeft != 0)
-                memmove(m_pBuffer, &amp;m_pBuffer[m_nBufferHead], nBytesLeft);
-            
-            m_nBufferTail -= m_nBufferHead;
-            m_nBufferHead = 0;
-        }
-    }
-    catch(...)
-    {
-        return ERROR_UNDEFINED;
-    }
-    
-    return ERROR_SUCCESS;
-}
-
-int CAPECompress::AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes, int * pBytesAdded)
-{
-    // error check the parameters
-    if (pInputSource == NULL) return ERROR_BAD_PARAMETER;
-
-    // initialize
-    if (pBytesAdded) *pBytesAdded = 0;
-        
-    // lock the buffer
-    int nBytesAvailable = 0;
-    unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
-    if ((pBuffer == NULL) || (nBytesAvailable == 0))
-        return ERROR_INSUFFICIENT_MEMORY;
-    
-    // calculate the 'ideal' number of bytes
-    unsigned int nBytesRead = 0;
-
-    int nIdealBytes = m_spAPECompressCreate-&gt;GetFullFrameBytes() - (m_nBufferTail - m_nBufferHead);
-    if (nIdealBytes &gt; 0)
-    {
-        // get the data
-        int nBytesToAdd = nBytesAvailable;
-        
-        if (nMaxBytes &gt; 0)
-        {
-            if (nBytesToAdd &gt; nMaxBytes) nBytesToAdd = nMaxBytes;
-        }
-
-        if (nBytesToAdd &gt; nIdealBytes) nBytesToAdd = nIdealBytes;
-
-        // always make requests along block boundaries
-        while ((nBytesToAdd % m_wfeInput.nBlockAlign) != 0)
-            nBytesToAdd--;
-
-        int nBlocksToAdd = nBytesToAdd / m_wfeInput.nBlockAlign;
-
-        // get data
-        int nBlocksAdded = 0;
-        int nRetVal = pInputSource-&gt;GetData(pBuffer, nBlocksToAdd, &amp;nBlocksAdded);
-        if (nRetVal != 0)
-            return ERROR_IO_READ;
-        else
-            nBytesRead = (nBlocksAdded * m_wfeInput.nBlockAlign);
-        
-        // store the bytes read
-        if (pBytesAdded)
-            *pBytesAdded = nBytesRead;
-    }
-        
-    // unlock the data and process
-    int nRetVal = UnlockBuffer(nBytesRead, TRUE);
-    if (nRetVal != 0)
-    {
-        return nRetVal;
-    }
-    
-    return ERROR_SUCCESS;
-}
-
+#include &quot;All.h&quot;
+#include &quot;APECompress.h&quot;
+#include IO_HEADER_FILE
+#include &quot;APECompressCreate.h&quot;
+#include &quot;WAVInputSource.h&quot;
+
+CAPECompress::CAPECompress()
+{
+    m_nBufferHead        = 0;
+    m_nBufferTail        = 0;
+    m_nBufferSize        = 0;
+    m_bBufferLocked        = FALSE;
+    m_bOwnsOutputIO        = FALSE;
+    m_pioOutput            = NULL;
+
+    m_spAPECompressCreate.Assign(new CAPECompressCreate());
+
+    m_pBuffer = NULL;
+}
+
+CAPECompress::~CAPECompress()
+{
+    SAFE_ARRAY_DELETE(m_pBuffer)
+
+    if (m_bOwnsOutputIO)
+    {
+        SAFE_DELETE(m_pioOutput)
+    }
+}
+
+int CAPECompress::Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
+{
+    m_pioOutput = new IO_CLASS_NAME;
+    m_bOwnsOutputIO = TRUE;
+    
+    if (m_pioOutput-&gt;Create(pOutputFilename) != 0)
+    {
+        return ERROR_INVALID_OUTPUT_FILE;
+    }
+        
+    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
+        pHeaderData, nHeaderBytes);
+    
+    SAFE_ARRAY_DELETE(m_pBuffer)
+    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
+    m_pBuffer = new unsigned char [m_nBufferSize];
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel, const void * pHeaderData, int nHeaderBytes)
+{
+    m_pioOutput = pioOutput;
+    m_bOwnsOutputIO = FALSE;
+
+    m_spAPECompressCreate-&gt;Start(m_pioOutput, pwfeInput, nMaxAudioBytes, nCompressionLevel,
+        pHeaderData, nHeaderBytes);
+
+    SAFE_ARRAY_DELETE(m_pBuffer)
+    m_nBufferSize = m_spAPECompressCreate-&gt;GetFullFrameBytes();
+    m_pBuffer = new unsigned char [m_nBufferSize];
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::GetBufferBytesAvailable()
+{
+    return m_nBufferSize - m_nBufferTail;
+}
+
+int CAPECompress::UnlockBuffer(int nBytesAdded, BOOL bProcess)
+{
+    if (m_bBufferLocked == FALSE)
+        return ERROR_UNDEFINED;
+    
+    m_nBufferTail += nBytesAdded;
+    m_bBufferLocked = FALSE;
+    
+    if (bProcess)
+    {
+        int nRetVal = ProcessBuffer();
+        if (nRetVal != 0) { return nRetVal; }
+    }
+    
+    return ERROR_SUCCESS;
+}
+
+unsigned char * CAPECompress::LockBuffer(int * pBytesAvailable)
+{
+    if (m_pBuffer == NULL) { return NULL; }
+    
+    if (m_bBufferLocked)
+        return NULL;
+    
+    m_bBufferLocked = TRUE;
+    
+    if (pBytesAvailable)
+        *pBytesAvailable = GetBufferBytesAvailable();
+    
+    return &amp;m_pBuffer[m_nBufferTail];
+}
+
+int CAPECompress::AddData(unsigned char * pData, int nBytes)
+{
+    if (m_pBuffer == NULL) return ERROR_INSUFFICIENT_MEMORY;
+
+    int nBytesDone = 0;
+    
+    while (nBytesDone &lt; nBytes)
+    {
+        // lock the buffer
+        int nBytesAvailable = 0;
+        unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
+        if (pBuffer == NULL || nBytesAvailable &lt;= 0)
+            return ERROR_UNDEFINED;
+        
+        // calculate how many bytes to copy and add that much to the buffer
+        int nBytesToProcess = min(nBytesAvailable, nBytes - nBytesDone);
+        memcpy(pBuffer, &amp;pData[nBytesDone], nBytesToProcess);
+                        
+        // unlock the buffer (fail if not successful)
+        int nRetVal = UnlockBuffer(nBytesToProcess);
+        if (nRetVal != ERROR_SUCCESS)
+                return nRetVal;
+
+        // update our progress
+        nBytesDone += nBytesToProcess;
+    }
+
+    return ERROR_SUCCESS;
+} 
+
+int CAPECompress::Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes)
+{
+    RETURN_ON_ERROR(ProcessBuffer(TRUE))
+    return m_spAPECompressCreate-&gt;Finish(pTerminatingData, nTerminatingBytes, nWAVTerminatingBytes);
+}
+
+int CAPECompress::Kill()
+{
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::ProcessBuffer(BOOL bFinalize)
+{
+    if (m_pBuffer == NULL) { return ERROR_UNDEFINED; }
+    
+    try
+    {
+        // process as much as possible
+        int nThreshold = (bFinalize) ? 0 : m_spAPECompressCreate-&gt;GetFullFrameBytes();
+        
+        while ((m_nBufferTail - m_nBufferHead) &gt;= nThreshold)
+        {
+            int nFrameBytes = min(m_spAPECompressCreate-&gt;GetFullFrameBytes(), m_nBufferTail - m_nBufferHead);
+            
+            if (nFrameBytes == 0)
+                break;
+
+            int nRetVal = m_spAPECompressCreate-&gt;EncodeFrame(&amp;m_pBuffer[m_nBufferHead], nFrameBytes);
+            if (nRetVal != 0) { return nRetVal; }
+            
+            m_nBufferHead += nFrameBytes;
+        }
+        
+        // shift the buffer
+        if (m_nBufferHead != 0)
+        {
+            int nBytesLeft = m_nBufferTail - m_nBufferHead;
+            
+            if (nBytesLeft != 0)
+                memmove(m_pBuffer, &amp;m_pBuffer[m_nBufferHead], nBytesLeft);
+            
+            m_nBufferTail -= m_nBufferHead;
+            m_nBufferHead = 0;
+        }
+    }
+    catch(...)
+    {
+        return ERROR_UNDEFINED;
+    }
+    
+    return ERROR_SUCCESS;
+}
+
+int CAPECompress::AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes, int * pBytesAdded)
+{
+    // error check the parameters
+    if (pInputSource == NULL) return ERROR_BAD_PARAMETER;
+
+    // initialize
+    if (pBytesAdded) *pBytesAdded = 0;
+        
+    // lock the buffer
+    int nBytesAvailable = 0;
+    unsigned char * pBuffer = LockBuffer(&amp;nBytesAvailable);
+    if ((pBuffer == NULL) || (nBytesAvailable == 0))
+        return ERROR_INSUFFICIENT_MEMORY;
+    
+    // calculate the 'ideal' number of bytes
+    unsigned int nBytesRead = 0;
+
+    int nIdealBytes = m_spAPECompressCreate-&gt;GetFullFrameBytes() - (m_nBufferTail - m_nBufferHead);
+    if (nIdealBytes &gt; 0)
+    {
+        // get the data
+        int nBytesToAdd = nBytesAvailable;
+        
+        if (nMaxBytes &gt; 0)
+        {
+            if (nBytesToAdd &gt; nMaxBytes) nBytesToAdd = nMaxBytes;
+        }
+
+        if (nBytesToAdd &gt; nIdealBytes) nBytesToAdd = nIdealBytes;
+
+        // always make requests along block boundaries
+        while ((nBytesToAdd % m_wfeInput.nBlockAlign) != 0)
+            nBytesToAdd--;
+
+        int nBlocksToAdd = nBytesToAdd / m_wfeInput.nBlockAlign;
+
+        // get data
+        int nBlocksAdded = 0;
+        int nRetVal = pInputSource-&gt;GetData(pBuffer, nBlocksToAdd, &amp;nBlocksAdded);
+        if (nRetVal != 0)
+            return ERROR_IO_READ;
+        else
+            nBytesRead = (nBlocksAdded * m_wfeInput.nBlockAlign);
+        
+        // store the bytes read
+        if (pBytesAdded)
+            *pBytesAdded = nBytesRead;
+    }
+        
+    // unlock the data and process
+    int nRetVal = UnlockBuffer(nBytesRead, TRUE);
+    if (nRetVal != 0)
+    {
+        return nRetVal;
+    }
+    
+    return ERROR_SUCCESS;
+}
+


Property changes on: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.h	2009-04-12 10:08:22 UTC (rev 30136)
+++ haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.h	2009-04-12 12:32:49 UTC (rev 30137)
@@ -1,56 +1,56 @@
-#ifndef APE_APECOMPRESS_H
-#define APE_APECOMPRESS_H
-
-#include &quot;MACLib.h&quot;
-class CAPECompressCreate;
-
-/*************************************************************************************************
-CAPECompress - uses the CAPECompressHub to provide a simpler compression interface (with buffering, etc)
-*************************************************************************************************/
-class CAPECompress : public IAPECompress
-{
-public:
-
-    CAPECompress();
-    ~CAPECompress();
-
-    // start encoding
-    int Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
-    int StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
-    
-    // add data / compress data
-
-    // allows linear, immediate access to the buffer (fast)
-    int GetBufferBytesAvailable();
-    int UnlockBuffer(int nBytesAdded, BOOL bProcess = TRUE);
-    unsigned char * LockBuffer(int * pBytesAvailable);
-    
-    // slower, but easier than locking and unlocking (copies data)
-    int AddData(unsigned char * pData, int nBytes);
-    
-    // use a CIO (input source) to add data
-    int AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes = -1, int * pBytesAdded = NULL);
-    
-    // finish / kill
-    int Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes);
-    int Kill();
-    
-private:
-    
-    int    ProcessBuffer(BOOL bFinalize = FALSE);
-    
-    CSmartPtr&lt;CAPECompressCreate&gt; m_spAPECompressCreate;
-
-    int                m_nBufferHead;
-    int                m_nBufferTail;
-    int                m_nBufferSize;
-    unsigned char * m_pBuffer;
-    BOOL            m_bBufferLocked;
-
-    CIO    *            m_pioOutput;
-    BOOL            m_bOwnsOutputIO;
-    WAVEFORMATEX    m_wfeInput;
-
-};
-
-#endif // #ifndef APE_APECOMPRESS_H
+#ifndef APE_APECOMPRESS_H
+#define APE_APECOMPRESS_H
+
+#include &quot;MACLib.h&quot;
+class CAPECompressCreate;
+
+/*************************************************************************************************
+CAPECompress - uses the CAPECompressHub to provide a simpler compression interface (with buffering, etc)
+*************************************************************************************************/
+class CAPECompress : public IAPECompress
+{
+public:
+
+    CAPECompress();
+    ~CAPECompress();
+
+    // start encoding
+    int Start(const wchar_t * pOutputFilename, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
+    int StartEx(CIO * pioOutput, const WAVEFORMATEX * pwfeInput, int nMaxAudioBytes, int nCompressionLevel = COMPRESSION_LEVEL_NORMAL, const void * pHeaderData = NULL, int nHeaderBytes = CREATE_WAV_HEADER_ON_DECOMPRESSION);
+    
+    // add data / compress data
+
+    // allows linear, immediate access to the buffer (fast)
+    int GetBufferBytesAvailable();
+    int UnlockBuffer(int nBytesAdded, BOOL bProcess = TRUE);
+    unsigned char * LockBuffer(int * pBytesAvailable);
+    
+    // slower, but easier than locking and unlocking (copies data)
+    int AddData(unsigned char * pData, int nBytes);
+    
+    // use a CIO (input source) to add data
+    int AddDataFromInputSource(CInputSource * pInputSource, int nMaxBytes = -1, int * pBytesAdded = NULL);
+    
+    // finish / kill
+    int Finish(unsigned char * pTerminatingData, int nTerminatingBytes, int nWAVTerminatingBytes);
+    int Kill();
+    
+private:
+    
+    int    ProcessBuffer(BOOL bFinalize = FALSE);
+    
+    CSmartPtr&lt;CAPECompressCreate&gt; m_spAPECompressCreate;
+
+    int                m_nBufferHead;
+    int                m_nBufferTail;
+    int                m_nBufferSize;
+    unsigned char * m_pBuffer;
+    BOOL            m_bBufferLocked;
+
+    CIO    *            m_pioOutput;
+    BOOL            m_bOwnsOutputIO;
+    WAVEFORMATEX    m_wfeInput;
+
+};
+
+#endif // #ifndef APE_APECOMPRESS_H


Property changes on: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompress.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.cpp	2009-04-12 10:08:22 UTC (rev 30136)
+++ haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.cpp	2009-04-12 12:32:49 UTC (rev 30137)
@@ -1,126 +1,126 @@
-#include &quot;All.h&quot;
-#include &quot;APECompressCore.h&quot;
-
-#include &quot;BitArray.h&quot;
-#include &quot;Prepare.h&quot;
-#include &quot;NewPredictor.h&quot;
-
-CAPECompressCore::CAPECompressCore(CIO * pIO, const WAVEFORMATEX * pwfeInput, int nMaxFrameBlocks, int nCompressionLevel)
-{
-    m_spBitArray.Assign(new CBitArray(pIO));
-    m_spDataX.Assign(new int [nMaxFrameBlocks], TRUE);
-    m_spDataY.Assign(new int [nMaxFrameBlocks], TRUE);
-    m_spTempData.Assign(new int [nMaxFrameBlocks], TRUE);
-    m_spPrepare.Assign(new CPrepare);
-    m_spPredictorX.Assign(new CPredictorCompressNormal(nCompressionLevel));
-    m_spPredictorY.Assign(new CPredictorCompressNormal(nCompressionLevel));
-
-    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
-    m_nPeakLevel = 0;
-}
-
-CAPECompressCore::~CAPECompressCore()
-{
-}
-
-int CAPECompressCore::EncodeFrame(const void * pInputData, int nInputBytes)
-{
-    // variables
-    const int nInputBlocks = nInputBytes / m_wfeInput.nBlockAlign;
-    int nSpecialCodes = 0;
-
-    // always start a new frame on a byte boundary
-    m_spBitArray-&gt;AdvanceToByteBoundary();
-    
-    // do the preparation stage
-    RETURN_ON_ERROR(Prepare(pInputData, nInputBytes, &amp;nSpecialCodes))
-
-    m_spPredictorX-&gt;Flush();
-    m_spPredictorY-&gt;Flush();
-
-    m_spBitArray-&gt;FlushState(m_BitArrayStateX);
-    m_spBitArray-&gt;FlushState(m_BitArrayStateY);
-
-    m_spBitArray-&gt;FlushBitArray();
-
-    if (m_wfeInput.nChannels == 2) 
-    {
-        BOOL bEncodeX = TRUE;
-        BOOL bEncodeY = TRUE;
-        
-        if ((nSpecialCodes &amp; SPECIAL_FRAME_LEFT_SILENCE) &amp;&amp; 
-            (nSpecialCodes &amp; SPECIAL_FRAME_RIGHT_SILENCE)) 
-        {
-            bEncodeX = FALSE;
-            bEncodeY = FALSE;
-        }
-        
-        if (nSpecialCodes &amp; SPECIAL_FRAME_PSEUDO_STEREO) 
-        {
-            bEncodeY = FALSE;
-        }
-        
-        if (bEncodeX &amp;&amp; bEncodeY)
-        {
-            int nLastX = 0;
-            for (int z = 0; z &lt; nInputBlocks; z++)
-            {
-                m_spBitArray-&gt;EncodeValue(m_spPredictorY-&gt;CompressValue(m_spDataY[z], nLastX), m_BitArrayStateY);
-                m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z], m_spDataY[z]), m_BitArrayStateX);
-                
-                nLastX = m_spDataX[z];
-            }
-        }
-        else if (bEncodeX) 
-        {
-            for (int z = 0; z &lt; nInputBlocks; z++)
-            {
-                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z]), m_BitArrayStateX))
-            }
-        }
-        else if (bEncodeY) 
-        {
-            for (int z = 0; z &lt; nInputBlocks; z++)
-            {
-                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorY-&gt;CompressValue(m_spDataY[z]), m_BitArrayStateY))
-            }
-        }
-    }
-    else if (m_wfeInput.nChannels == 1) 
-    {
-        if (!(nSpecialCodes &amp; SPECIAL_FRAME_MONO_SILENCE))
-        {
-            for (int z = 0; z &lt; nInputBlocks; z++)
-            {
-                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z]), m_BitArrayStateX))
-            }
-        }
-    }    
-
-    m_spBitArray-&gt;Finalize();
-
-    // return success
-    return 0;
-}
-
-int CAPECompressCore::Prepare(const void * pInputData, int nInputBytes, int * pSpecialCodes)
-{
-    // variable declares
-    *pSpecialCodes = 0;
-    unsigned int nCRC = 0;
-    
-    // do the preparation
-    RETURN_ON_ERROR(m_spPrepare-&gt;Prepare((unsigned char *) pInputData, nInputBytes, &amp;m_wfeInput, m_spDataX, m_spDataY,
-        &amp;nCRC, pSpecialCodes, &amp;m_nPeakLevel))
-    
-    // store the CRC
-    RETURN_ON_ERROR(m_spBitArray-&gt;EncodeUnsignedLong(nCRC))
-    
-    // store any special codes
-    if (*pSpecialCodes != 0) 
-    {
-        RETURN_ON_ERROR(m_spBitArray-&gt;EncodeUnsignedLong(*pSpecialCodes))
-    }
-    
-    return 0;
-}
+#include &quot;All.h&quot;
+#include &quot;APECompressCore.h&quot;
+
+#include &quot;BitArray.h&quot;
+#include &quot;Prepare.h&quot;
+#include &quot;NewPredictor.h&quot;
+
+CAPECompressCore::CAPECompressCore(CIO * pIO, const WAVEFORMATEX * pwfeInput, int nMaxFrameBlocks, int nCompressionLevel)
+{
+    m_spBitArray.Assign(new CBitArray(pIO));
+    m_spDataX.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spDataY.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spTempData.Assign(new int [nMaxFrameBlocks], TRUE);
+    m_spPrepare.Assign(new CPrepare);
+    m_spPredictorX.Assign(new CPredictorCompressNormal(nCompressionLevel));
+    m_spPredictorY.Assign(new CPredictorCompressNormal(nCompressionLevel));
+
+    memcpy(&amp;m_wfeInput, pwfeInput, sizeof(WAVEFORMATEX));
+    m_nPeakLevel = 0;
+}
+
+CAPECompressCore::~CAPECompressCore()
+{
+}
+
+int CAPECompressCore::EncodeFrame(const void * pInputData, int nInputBytes)
+{
+    // variables
+    const int nInputBlocks = nInputBytes / m_wfeInput.nBlockAlign;
+    int nSpecialCodes = 0;
+
+    // always start a new frame on a byte boundary
+    m_spBitArray-&gt;AdvanceToByteBoundary();
+    
+    // do the preparation stage
+    RETURN_ON_ERROR(Prepare(pInputData, nInputBytes, &amp;nSpecialCodes))
+
+    m_spPredictorX-&gt;Flush();
+    m_spPredictorY-&gt;Flush();
+
+    m_spBitArray-&gt;FlushState(m_BitArrayStateX);
+    m_spBitArray-&gt;FlushState(m_BitArrayStateY);
+
+    m_spBitArray-&gt;FlushBitArray();
+
+    if (m_wfeInput.nChannels == 2) 
+    {
+        BOOL bEncodeX = TRUE;
+        BOOL bEncodeY = TRUE;
+        
+        if ((nSpecialCodes &amp; SPECIAL_FRAME_LEFT_SILENCE) &amp;&amp; 
+            (nSpecialCodes &amp; SPECIAL_FRAME_RIGHT_SILENCE)) 
+        {
+            bEncodeX = FALSE;
+            bEncodeY = FALSE;
+        }
+        
+        if (nSpecialCodes &amp; SPECIAL_FRAME_PSEUDO_STEREO) 
+        {
+            bEncodeY = FALSE;
+        }
+        
+        if (bEncodeX &amp;&amp; bEncodeY)
+        {
+            int nLastX = 0;
+            for (int z = 0; z &lt; nInputBlocks; z++)
+            {
+                m_spBitArray-&gt;EncodeValue(m_spPredictorY-&gt;CompressValue(m_spDataY[z], nLastX), m_BitArrayStateY);
+                m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z], m_spDataY[z]), m_BitArrayStateX);
+                
+                nLastX = m_spDataX[z];
+            }
+        }
+        else if (bEncodeX) 
+        {
+            for (int z = 0; z &lt; nInputBlocks; z++)
+            {
+                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z]), m_BitArrayStateX))
+            }
+        }
+        else if (bEncodeY) 
+        {
+            for (int z = 0; z &lt; nInputBlocks; z++)
+            {
+                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorY-&gt;CompressValue(m_spDataY[z]), m_BitArrayStateY))
+            }
+        }
+    }
+    else if (m_wfeInput.nChannels == 1) 
+    {
+        if (!(nSpecialCodes &amp; SPECIAL_FRAME_MONO_SILENCE))
+        {
+            for (int z = 0; z &lt; nInputBlocks; z++)
+            {
+                RETURN_ON_ERROR(m_spBitArray-&gt;EncodeValue(m_spPredictorX-&gt;CompressValue(m_spDataX[z]), m_BitArrayStateX))
+            }
+        }
+    }    
+
+    m_spBitArray-&gt;Finalize();
+
+    // return success
+    return 0;
+}
+
+int CAPECompressCore::Prepare(const void * pInputData, int nInputBytes, int * pSpecialCodes)
+{
+    // variable declares
+    *pSpecialCodes = 0;
+    unsigned int nCRC = 0;
+    
+    // do the preparation
+    RETURN_ON_ERROR(m_spPrepare-&gt;Prepare((unsigned char *) pInputData, nInputBytes, &amp;m_wfeInput, m_spDataX, m_spDataY,
+        &amp;nCRC, pSpecialCodes, &amp;m_nPeakLevel))
+    
+    // store the CRC
+    RETURN_ON_ERROR(m_spBitArray-&gt;EncodeUnsignedLong(nCRC))
+    
+    // store any special codes
+    if (*pSpecialCodes != 0) 
+    {
+        RETURN_ON_ERROR(m_spBitArray-&gt;EncodeUnsignedLong(*pSpecialCodes))
+    }
+    
+    return 0;
+}


Property changes on: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.h	2009-04-12 10:08:22 UTC (rev 30136)
+++ haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.h	2009-04-12 12:32:49 UTC (rev 30137)
@@ -1,41 +1,41 @@
-#ifndef APE_APECOMPRESSCORE_H
-#define APE_APECOMPRESSCORE_H
-
-#include &quot;APECompress.h&quot;
-#include &quot;BitArray.h&quot;
-
-class CPrepare;
-class IPredictorCompress;
-
-/*************************************************************************************************
-CAPECompressCore - manages the core of compression and bitstream output
-*************************************************************************************************/
-class  CAPECompressCore
-{
-public:
-    CAPECompressCore(CIO * pIO, const WAVEFORMATEX * pwfeInput, int nMaxFrameBlocks, int nCompressionLevel);
-    ~CAPECompressCore();
-
-    int EncodeFrame(const void * pInputData, int nInputBytes);
-
-    CBitArray * GetBitArray() { return m_spBitArray.GetPtr(); }
-    int GetPeakLevel() { return m_nPeakLevel; }
-
-private:
-
-    int Prepare(const void * pInputData, int nInputBytes, int * pSpecialCodes);
-
-    CSmartPtr&lt;CBitArray&gt; m_spBitArray;
-    CSmartPtr&lt;IPredictorCompress&gt; m_spPredictorX;
-    CSmartPtr&lt;IPredictorCompress&gt; m_spPredictorY;
-    BIT_ARRAY_STATE    m_BitArrayStateX;
-    BIT_ARRAY_STATE    m_BitArrayStateY;
-    CSmartPtr&lt;int&gt; m_spDataX;
-    CSmartPtr&lt;int&gt; m_spDataY;
-    CSmartPtr&lt;int&gt; m_spTempData;
-    CSmartPtr&lt;CPrepare&gt; m_spPrepare;
-    WAVEFORMATEX m_wfeInput;
-    int    m_nPeakLevel;
-};
-
-#endif // #ifndef APE_APECOMPRESSCORE_H
+#ifndef APE_APECOMPRESSCORE_H
+#define APE_APECOMPRESSCORE_H
+
+#include &quot;APECompress.h&quot;
+#include &quot;BitArray.h&quot;
+
+class CPrepare;
+class IPredictorCompress;
+
+/*************************************************************************************************
+CAPECompressCore - manages the core of compression and bitstream output
+*************************************************************************************************/
+class  CAPECompressCore
+{
+public:
+    CAPECompressCore(CIO * pIO, const WAVEFORMATEX * pwfeInput, int nMaxFrameBlocks, int nCompressionLevel);
+    ~CAPECompressCore();
+
+    int EncodeFrame(const void * pInputData, int nInputBytes);
+
+    CBitArray * GetBitArray() { return m_spBitArray.GetPtr(); }
+    int GetPeakLevel() { return m_nPeakLevel; }
+
+private:
+
+    int Prepare(const void * pInputData, int nInputBytes, int * pSpecialCodes);
+
+    CSmartPtr&lt;CBitArray&gt; m_spBitArray;
+    CSmartPtr&lt;IPredictorCompress&gt; m_spPredictorX;
+    CSmartPtr&lt;IPredictorCompress&gt; m_spPredictorY;
+    BIT_ARRAY_STATE    m_BitArrayStateX;
+    BIT_ARRAY_STATE    m_BitArrayStateY;
+    CSmartPtr&lt;int&gt; m_spDataX;
+    CSmartPtr&lt;int&gt; m_spDataY;
+    CSmartPtr&lt;int&gt; m_spTempData;
+    CSmartPtr&lt;CPrepare&gt; m_spPrepare;
+    WAVEFORMATEX m_wfeInput;
+    int    m_nPeakLevel;
+};
+
+#endif // #ifndef APE_APECOMPRESSCORE_H


Property changes on: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCore.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCreate.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCreate.cpp	2009-04-12 10:08:22 UTC (rev 30136)
+++ haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib/APECompressCreate.cpp	2009-04-12 12:32:49 UTC (rev 30137)
@@ -1,218 +1,218 @@
-#include &quot;All.h&quot;
-#include &quot;IO.h&quot;
-#include &quot;APECompressCreate.h&quot;
-
-#include &quot;APECompressCore.h&quot;
-
-CAPECompressCreate::CAPECompressCreate()
-{
-    m_nMaxFrames = 0;

[... truncated: 16826 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015779.html">[Haiku-commits] r30136 - in	haiku/trunk/src/add-ons/media/plugins/ape_reader:	LibMonkeysAudio MAClib
</A></li>
	<LI>Next message: <A HREF="015784.html">[Haiku-commits] r30138 -	haiku/trunk/src/add-ons/media/plugins/ape_reader/MAClib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15783">[ date ]</a>
              <a href="thread.html#15783">[ thread ]</a>
              <a href="subject.html#15783">[ subject ]</a>
              <a href="author.html#15783">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
