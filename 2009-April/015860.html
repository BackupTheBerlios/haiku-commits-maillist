<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30187 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: .	ppc sparc
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30187%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec%3A%20.%0A%09ppc%20sparc&In-Reply-To=%3C200904152338.n3FNcGEP004908%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="015859.html">
   <LINK REL="Next"  HREF="015861.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30187 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: .	ppc sparc</H1>
    <B>phoudoin at mail.berlios.de</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30187%20-%20in%0A%09haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec%3A%20.%0A%09ppc%20sparc&In-Reply-To=%3C200904152338.n3FNcGEP004908%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30187 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: .	ppc sparc">phoudoin at mail.berlios.de
       </A><BR>
    <I>Thu Apr 16 01:38:16 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="015859.html">[Haiku-commits] r30186 - haiku/trunk/src/bin/debug/profile
</A></li>
        <LI>Next message: <A HREF="015861.html">[Haiku-commits] r30187 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: .	ppc sparc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15860">[ date ]</a>
              <a href="thread.html#15860">[ thread ]</a>
              <a href="subject.html#15860">[ subject ]</a>
              <a href="author.html#15860">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: phoudoin
Date: 2009-04-16 01:38:05 +0200 (Thu, 16 Apr 2009)
New Revision: 30187
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30187&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30187&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/check_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_altivec.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_ppc.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_ppc.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/fdct_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/fft_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/float_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/gcc_fixes.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/gmc_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/h264_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/h264_template_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/idct_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/imgresample_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/imgresample_altivec.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/int_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/mathops.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/mpegvideo_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/snow_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/types_altivec.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/util_altivec.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/vc1dsp_altivec.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/sparc/
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/sparc/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/sparc/dsputil_vis.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/sparc/simple_idct_vis.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/sparc/vis.h
Log:
* Imported ppc and sparc architectures optimized codes from ffmpeg 0.5.
* Added Jamfiles to build libavcodec_ppc.a and libavcodec_sparc.a. 
  UNTESTED.



Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/Jamfile	2009-04-15 23:20:56 UTC (rev 30186)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/Jamfile	2009-04-15 23:38:05 UTC (rev 30187)
@@ -0,0 +1,62 @@
+SubDir HAIKU_TOP src add-ons media plugins avcodec libavcodec ppc ;
+
+SubDirHdrs [ FDirName $(SUBDIR) .. ] ;
+SubDirHdrs [ FDirName $(SUBDIR) ../.. ] ;
+SubDirHdrs [ FDirName $(SUBDIR) ../../libavutil ] ;
+SubDirHdrs [ FDirName $(SUBDIR) ../../libswscale ] ;
+
+# filter warnings we don't want here
+TARGET_WARNING_CCFLAGS = [ FFilter $(TARGET_WARNING_CCFLAGS)
+	: -Wall -Wmissing-prototypes -Wsign-compare -Wpointer-arith ] ;
+
+if $(HAIKU_GCC_VERSION[1]) &gt;= 3 {
+	SubDirCcFlags -fomit-frame-pointer -fno-pic ;
+} else {
+	SubDirCcFlags -fomit-frame-pointer -DPIC ;
+}
+
+local defines ;
+defines = HAVE_AV_CONFIG_H=1 ;
+
+if $(TARGET_ARCH) = x86 {
+    defines += ARCH_X86=1 ARCH_X86_32=1 ARCH_PPC=0 ARCH_SPARC=0 ;
+    defines += HAVE_AMD3DNOW=0 HAVE_AMD3DNOWEXT=0 ;
+    defines += HAVE_MMX=1 HAVE_MMX2=1 HAVE_SSE=0 HAVE_SSE3=1 ; 
+    defines += HAVE_ALTIVEC=0 ;
+	defines += HAVE_VIS=0 ;
+} else if $(TARGET_ARCH) = ppc {
+    defines += ARCH_X86=0 ARCH_X86_32=0 ARCH_PPC=1 ARCH_SPARC=0 ;
+    defines += HAVE_AMD3DNOW=0 HAVE_AMD3DNOWEXT=0 ;
+    defines += HAVE_MMX=0 HAVE_MMX2=0 HAVE_SSE=0 HAVE_SSE3=0 ; 
+    defines += HAVE_ALTIVEC=1 ;
+	defines += HAVE_VIS=0 ;
+} else if $(TARGET_ARCH) = sparc {
+    defines += ARCH_X86=0 ARCH_X86_32=0 ARCH_PPC=0 ARCH_SPARC=1 ;
+    defines += HAVE_AMD3DNOW=0 HAVE_AMD3DNOWEXT=0 ;
+    defines += HAVE_MMX=0 HAVE_MMX2=0 HAVE_SSE=0 HAVE_SSE3=0 ; 
+    defines += HAVE_ALTIVEC=0 ;
+	defines += HAVE_VIS=1 ;
+}
+
+defines = [ FDefines $(defines) ] ;
+SubDirCcFlags $(defines) ;
+SubDirC++Flags $(defines) ;
+
+StaticLibrary libavcodec_ppc.a :
+	check_altivec.c
+    float_altivec.c
+    int_altivec.c
+	dsputil_altivec.c
+	dsputil_ppc.c
+    fdct_altivec.c
+    fft_altivec.c
+    idct_altivec.c
+    gmc_altivec.c
+    imgresample_altivec.c
+    h264_altivec.c
+#   h264_template_altivec.c
+    mpegvideo_altivec.c
+    vc1dsp_altivec.c
+    snow_altivec.c
+;
+

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/check_altivec.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/check_altivec.c	2009-04-15 23:20:56 UTC (rev 30186)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/check_altivec.c	2009-04-15 23:38:05 UTC (rev 30187)
@@ -0,0 +1,84 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+/**
+ * @file libavcodec/ppc/check_altivec.c
+ * Checks for AltiVec presence.
+ */
+
+#ifdef __APPLE__
+#undef _POSIX_C_SOURCE
+#include &lt;sys/sysctl.h&gt;
+#elif defined(__OpenBSD__)
+#include &lt;sys/param.h&gt;
+#include &lt;sys/sysctl.h&gt;
+#include &lt;machine/cpu.h&gt;
+#elif defined(__AMIGAOS4__)
+#include &lt;exec/exec.h&gt;
+#include &lt;interfaces/exec.h&gt;
+#include &lt;proto/exec.h&gt;
+#endif /* __APPLE__ */
+
+/**
+ * This function MAY rely on signal() or fork() in order to make sure AltiVec
+ * is present.
+ */
+
+int has_altivec(void)
+{
+#ifdef __AMIGAOS4__
+    ULONG result = 0;
+    extern struct ExecIFace *IExec;
+
+    IExec-&gt;GetCPUInfoTags(GCIT_VectorUnit, &amp;result, TAG_DONE);
+    if (result == VECTORTYPE_ALTIVEC) return 1;
+    return 0;
+#elif defined(__APPLE__) || defined(__OpenBSD__)
+#ifdef __OpenBSD__
+    int sels[2] = {CTL_MACHDEP, CPU_ALTIVEC};
+#else
+    int sels[2] = {CTL_HW, HW_VECTORUNIT};
+#endif
+    int has_vu = 0;
+    size_t len = sizeof(has_vu);
+    int err;
+
+    err = sysctl(sels, 2, &amp;has_vu, &amp;len, NULL, 0);
+
+    if (err == 0) return has_vu != 0;
+    return 0;
+#elif defined(RUNTIME_CPUDETECT)
+    int proc_ver;
+    // Support of mfspr PVR emulation added in Linux 2.6.17.
+    __asm__ volatile(&quot;mfspr %0, 287&quot; : &quot;=r&quot; (proc_ver));
+    proc_ver &gt;&gt;= 16;
+    if (proc_ver  &amp; 0x8000 ||
+        proc_ver == 0x000c ||
+        proc_ver == 0x0039 || proc_ver == 0x003c ||
+        proc_ver == 0x0044 || proc_ver == 0x0045 ||
+        proc_ver == 0x0070)
+        return 1;
+    return 0;
+#else
+    // Since we were compiled for AltiVec, just assume we have it
+    // until someone comes up with a proper way (not involving signal hacks).
+    return 1;
+#endif /* __AMIGAOS4__ */
+}
+

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_altivec.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_altivec.c	2009-04-15 23:20:56 UTC (rev 30186)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/ppc/dsputil_altivec.c	2009-04-15 23:38:05 UTC (rev 30187)
@@ -0,0 +1,1455 @@
+/*
+ * Copyright (c) 2002 Brian Foley
+ * Copyright (c) 2002 Dieter Shirley
+ * Copyright (c) 2003-2004 Romain Dolbeau &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">romain at dolbeau.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;libavcodec/dsputil.h&quot;
+
+#include &quot;gcc_fixes.h&quot;
+
+#include &quot;dsputil_ppc.h&quot;
+#include &quot;util_altivec.h&quot;
+#include &quot;types_altivec.h&quot;
+
+int sad16_x2_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned char zero = (const vector unsigned char)vec_splat_u8(0);
+    vector unsigned char *tv;
+    vector unsigned char pix1v, pix2v, pix2iv, avgv, t5;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+
+    s = 0;
+    sad = (vector unsigned int)vec_splat_u32(0);
+    for (i = 0; i &lt; h; i++) {
+        /* Read unaligned pixels into our vectors. The vectors are as follows:
+           pix1v: pix1[0]-pix1[15]
+           pix2v: pix2[0]-pix2[15]      pix2iv: pix2[1]-pix2[16] */
+        tv = (vector unsigned char *) pix1;
+        pix1v = vec_perm(tv[0], tv[1], vec_lvsl(0, pix1));
+
+        tv = (vector unsigned char *) &amp;pix2[0];
+        pix2v = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix2[0]));
+
+        tv = (vector unsigned char *) &amp;pix2[1];
+        pix2iv = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix2[1]));
+
+        /* Calculate the average vector */
+        avgv = vec_avg(pix2v, pix2iv);
+
+        /* Calculate a sum of abs differences vector */
+        t5 = vec_sub(vec_max(pix1v, avgv), vec_min(pix1v, avgv));
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t5, sad);
+
+        pix1 += line_size;
+        pix2 += line_size;
+    }
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+
+    return s;
+}
+
+int sad16_y2_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned char zero = (const vector unsigned char)vec_splat_u8(0);
+    vector unsigned char *tv;
+    vector unsigned char pix1v, pix2v, pix3v, avgv, t5;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+    uint8_t *pix3 = pix2 + line_size;
+
+    s = 0;
+    sad = (vector unsigned int)vec_splat_u32(0);
+
+    /* Due to the fact that pix3 = pix2 + line_size, the pix3 of one
+       iteration becomes pix2 in the next iteration. We can use this
+       fact to avoid a potentially expensive unaligned read, each
+       time around the loop.
+       Read unaligned pixels into our vectors. The vectors are as follows:
+       pix2v: pix2[0]-pix2[15]
+       Split the pixel vectors into shorts */
+    tv = (vector unsigned char *) &amp;pix2[0];
+    pix2v = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix2[0]));
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read unaligned pixels into our vectors. The vectors are as follows:
+           pix1v: pix1[0]-pix1[15]
+           pix3v: pix3[0]-pix3[15] */
+        tv = (vector unsigned char *) pix1;
+        pix1v = vec_perm(tv[0], tv[1], vec_lvsl(0, pix1));
+
+        tv = (vector unsigned char *) &amp;pix3[0];
+        pix3v = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix3[0]));
+
+        /* Calculate the average vector */
+        avgv = vec_avg(pix2v, pix3v);
+
+        /* Calculate a sum of abs differences vector */
+        t5 = vec_sub(vec_max(pix1v, avgv), vec_min(pix1v, avgv));
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t5, sad);
+
+        pix1 += line_size;
+        pix2v = pix3v;
+        pix3 += line_size;
+
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+    return s;
+}
+
+int sad16_xy2_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    uint8_t *pix3 = pix2 + line_size;
+    const vector unsigned char zero = (const vector unsigned char)vec_splat_u8(0);
+    const vector unsigned short two = (const vector unsigned short)vec_splat_u16(2);
+    vector unsigned char *tv, avgv, t5;
+    vector unsigned char pix1v, pix2v, pix3v, pix2iv, pix3iv;
+    vector unsigned short pix2lv, pix2hv, pix2ilv, pix2ihv;
+    vector unsigned short pix3lv, pix3hv, pix3ilv, pix3ihv;
+    vector unsigned short avghv, avglv;
+    vector unsigned short t1, t2, t3, t4;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+
+    sad = (vector unsigned int)vec_splat_u32(0);
+
+    s = 0;
+
+    /* Due to the fact that pix3 = pix2 + line_size, the pix3 of one
+       iteration becomes pix2 in the next iteration. We can use this
+       fact to avoid a potentially expensive unaligned read, as well
+       as some splitting, and vector addition each time around the loop.
+       Read unaligned pixels into our vectors. The vectors are as follows:
+       pix2v: pix2[0]-pix2[15]  pix2iv: pix2[1]-pix2[16]
+       Split the pixel vectors into shorts */
+    tv = (vector unsigned char *) &amp;pix2[0];
+    pix2v = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix2[0]));
+
+    tv = (vector unsigned char *) &amp;pix2[1];
+    pix2iv = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix2[1]));
+
+    pix2hv  = (vector unsigned short) vec_mergeh(zero, pix2v);
+    pix2lv  = (vector unsigned short) vec_mergel(zero, pix2v);
+    pix2ihv = (vector unsigned short) vec_mergeh(zero, pix2iv);
+    pix2ilv = (vector unsigned short) vec_mergel(zero, pix2iv);
+    t1 = vec_add(pix2hv, pix2ihv);
+    t2 = vec_add(pix2lv, pix2ilv);
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read unaligned pixels into our vectors. The vectors are as follows:
+           pix1v: pix1[0]-pix1[15]
+           pix3v: pix3[0]-pix3[15]      pix3iv: pix3[1]-pix3[16] */
+        tv = (vector unsigned char *) pix1;
+        pix1v = vec_perm(tv[0], tv[1], vec_lvsl(0, pix1));
+
+        tv = (vector unsigned char *) &amp;pix3[0];
+        pix3v = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix3[0]));
+
+        tv = (vector unsigned char *) &amp;pix3[1];
+        pix3iv = vec_perm(tv[0], tv[1], vec_lvsl(0, &amp;pix3[1]));
+
+        /* Note that AltiVec does have vec_avg, but this works on vector pairs
+           and rounds up. We could do avg(avg(a,b),avg(c,d)), but the rounding
+           would mean that, for example, avg(3,0,0,1) = 2, when it should be 1.
+           Instead, we have to split the pixel vectors into vectors of shorts,
+           and do the averaging by hand. */
+
+        /* Split the pixel vectors into shorts */
+        pix3hv  = (vector unsigned short) vec_mergeh(zero, pix3v);
+        pix3lv  = (vector unsigned short) vec_mergel(zero, pix3v);
+        pix3ihv = (vector unsigned short) vec_mergeh(zero, pix3iv);
+        pix3ilv = (vector unsigned short) vec_mergel(zero, pix3iv);
+
+        /* Do the averaging on them */
+        t3 = vec_add(pix3hv, pix3ihv);
+        t4 = vec_add(pix3lv, pix3ilv);
+
+        avghv = vec_sr(vec_add(vec_add(t1, t3), two), two);
+        avglv = vec_sr(vec_add(vec_add(t2, t4), two), two);
+
+        /* Pack the shorts back into a result */
+        avgv = vec_pack(avghv, avglv);
+
+        /* Calculate a sum of abs differences vector */
+        t5 = vec_sub(vec_max(pix1v, avgv), vec_min(pix1v, avgv));
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t5, sad);
+
+        pix1 += line_size;
+        pix3 += line_size;
+        /* Transfer the calculated values for pix3 into pix2 */
+        t1 = t3;
+        t2 = t4;
+    }
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+
+    return s;
+}
+
+int sad16_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char perm1, perm2, *pix1v, *pix2v;
+    vector unsigned char t1, t2, t3,t4, t5;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+
+    sad = (vector unsigned int)vec_splat_u32(0);
+
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read potentially unaligned pixels into t1 and t2 */
+        perm1 = vec_lvsl(0, pix1);
+        pix1v = (vector unsigned char *) pix1;
+        perm2 = vec_lvsl(0, pix2);
+        pix2v = (vector unsigned char *) pix2;
+        t1 = vec_perm(pix1v[0], pix1v[1], perm1);
+        t2 = vec_perm(pix2v[0], pix2v[1], perm2);
+
+        /* Calculate a sum of abs differences vector */
+        t3 = vec_max(t1, t2);
+        t4 = vec_min(t1, t2);
+        t5 = vec_sub(t3, t4);
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t5, sad);
+
+        pix1 += line_size;
+        pix2 += line_size;
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+
+    return s;
+}
+
+int sad8_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char perm1, perm2, permclear, *pix1v, *pix2v;
+    vector unsigned char t1, t2, t3,t4, t5;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+
+    sad = (vector unsigned int)vec_splat_u32(0);
+
+    permclear = (vector unsigned char){255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0};
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read potentially unaligned pixels into t1 and t2
+           Since we're reading 16 pixels, and actually only want 8,
+           mask out the last 8 pixels. The 0s don't change the sum. */
+        perm1 = vec_lvsl(0, pix1);
+        pix1v = (vector unsigned char *) pix1;
+        perm2 = vec_lvsl(0, pix2);
+        pix2v = (vector unsigned char *) pix2;
+        t1 = vec_and(vec_perm(pix1v[0], pix1v[1], perm1), permclear);
+        t2 = vec_and(vec_perm(pix2v[0], pix2v[1], perm2), permclear);
+
+        /* Calculate a sum of abs differences vector */
+        t3 = vec_max(t1, t2);
+        t4 = vec_min(t1, t2);
+        t5 = vec_sub(t3, t4);
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t5, sad);
+
+        pix1 += line_size;
+        pix2 += line_size;
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+
+    return s;
+}
+
+int pix_norm1_altivec(uint8_t *pix, int line_size)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char *tv;
+    vector unsigned char pixv;
+    vector unsigned int sv;
+    vector signed int sum;
+
+    sv = (vector unsigned int)vec_splat_u32(0);
+
+    s = 0;
+    for (i = 0; i &lt; 16; i++) {
+        /* Read in the potentially unaligned pixels */
+        tv = (vector unsigned char *) pix;
+        pixv = vec_perm(tv[0], tv[1], vec_lvsl(0, pix));
+
+        /* Square the values, and add them to our sum */
+        sv = vec_msum(pixv, pixv, sv);
+
+        pix += line_size;
+    }
+    /* Sum up the four partial sums, and put the result into s */
+    sum = vec_sums((vector signed int) sv, (vector signed int) zero);
+    sum = vec_splat(sum, 3);
+    vec_ste(sum, 0, &amp;s);
+
+    return s;
+}
+
+/**
+ * Sum of Squared Errors for a 8x8 block.
+ * AltiVec-enhanced.
+ * It's the sad8_altivec code above w/ squaring added.
+ */
+int sse8_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char perm1, perm2, permclear, *pix1v, *pix2v;
+    vector unsigned char t1, t2, t3,t4, t5;
+    vector unsigned int sum;
+    vector signed int sumsqr;
+
+    sum = (vector unsigned int)vec_splat_u32(0);
+
+    permclear = (vector unsigned char){255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0};
+
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read potentially unaligned pixels into t1 and t2
+           Since we're reading 16 pixels, and actually only want 8,
+           mask out the last 8 pixels. The 0s don't change the sum. */
+        perm1 = vec_lvsl(0, pix1);
+        pix1v = (vector unsigned char *) pix1;
+        perm2 = vec_lvsl(0, pix2);
+        pix2v = (vector unsigned char *) pix2;
+        t1 = vec_and(vec_perm(pix1v[0], pix1v[1], perm1), permclear);
+        t2 = vec_and(vec_perm(pix2v[0], pix2v[1], perm2), permclear);
+
+        /* Since we want to use unsigned chars, we can take advantage
+           of the fact that abs(a-b)^2 = (a-b)^2. */
+
+        /* Calculate abs differences vector */
+        t3 = vec_max(t1, t2);
+        t4 = vec_min(t1, t2);
+        t5 = vec_sub(t3, t4);
+
+        /* Square the values and add them to our sum */
+        sum = vec_msum(t5, t5, sum);
+
+        pix1 += line_size;
+        pix2 += line_size;
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumsqr = vec_sums((vector signed int) sum, (vector signed int) zero);
+    sumsqr = vec_splat(sumsqr, 3);
+    vec_ste(sumsqr, 0, &amp;s);
+
+    return s;
+}
+
+/**
+ * Sum of Squared Errors for a 16x16 block.
+ * AltiVec-enhanced.
+ * It's the sad16_altivec code above w/ squaring added.
+ */
+int sse16_altivec(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+{
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char perm1, perm2, *pix1v, *pix2v;
+    vector unsigned char t1, t2, t3,t4, t5;
+    vector unsigned int sum;
+    vector signed int sumsqr;
+
+    sum = (vector unsigned int)vec_splat_u32(0);
+
+    for (i = 0; i &lt; h; i++) {
+        /* Read potentially unaligned pixels into t1 and t2 */
+        perm1 = vec_lvsl(0, pix1);
+        pix1v = (vector unsigned char *) pix1;
+        perm2 = vec_lvsl(0, pix2);
+        pix2v = (vector unsigned char *) pix2;
+        t1 = vec_perm(pix1v[0], pix1v[1], perm1);
+        t2 = vec_perm(pix2v[0], pix2v[1], perm2);
+
+        /* Since we want to use unsigned chars, we can take advantage
+           of the fact that abs(a-b)^2 = (a-b)^2. */
+
+        /* Calculate abs differences vector */
+        t3 = vec_max(t1, t2);
+        t4 = vec_min(t1, t2);
+        t5 = vec_sub(t3, t4);
+
+        /* Square the values and add them to our sum */
+        sum = vec_msum(t5, t5, sum);
+
+        pix1 += line_size;
+        pix2 += line_size;
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumsqr = vec_sums((vector signed int) sum, (vector signed int) zero);
+    sumsqr = vec_splat(sumsqr, 3);
+    vec_ste(sumsqr, 0, &amp;s);
+
+    return s;
+}
+
+int pix_sum_altivec(uint8_t * pix, int line_size)
+{
+    const vector unsigned int zero = (const vector unsigned int)vec_splat_u32(0);
+    vector unsigned char perm, *pixv;
+    vector unsigned char t1;
+    vector unsigned int sad;
+    vector signed int sumdiffs;
+
+    int i;
+    DECLARE_ALIGNED_16(int, s);
+
+    sad = (vector unsigned int)vec_splat_u32(0);
+
+    for (i = 0; i &lt; 16; i++) {
+        /* Read the potentially unaligned 16 pixels into t1 */
+        perm = vec_lvsl(0, pix);
+        pixv = (vector unsigned char *) pix;
+        t1 = vec_perm(pixv[0], pixv[1], perm);
+
+        /* Add each 4 pixel group together and put 4 results into sad */
+        sad = vec_sum4s(t1, sad);
+
+        pix += line_size;
+    }
+
+    /* Sum up the four partial sums, and put the result into s */
+    sumdiffs = vec_sums((vector signed int) sad, (vector signed int) zero);
+    sumdiffs = vec_splat(sumdiffs, 3);
+    vec_ste(sumdiffs, 0, &amp;s);
+
+    return s;
+}
+
+void get_pixels_altivec(DCTELEM *restrict block, const uint8_t *pixels, int line_size)
+{
+    int i;
+    vector unsigned char perm, bytes, *pixv;
+    const vector unsigned char zero = (const vector unsigned char)vec_splat_u8(0);
+    vector signed short shorts;
+
+    for (i = 0; i &lt; 8; i++) {
+        // Read potentially unaligned pixels.
+        // We're reading 16 pixels, and actually only want 8,
+        // but we simply ignore the extras.
+        perm = vec_lvsl(0, pixels);
+        pixv = (vector unsigned char *) pixels;
+        bytes = vec_perm(pixv[0], pixv[1], perm);
+
+        // convert the bytes into shorts
+        shorts = (vector signed short)vec_mergeh(zero, bytes);
+
+        // save the data to the block, we assume the block is 16-byte aligned
+        vec_st(shorts, i*16, (vector signed short*)block);
+
+        pixels += line_size;
+    }
+}
+
+void diff_pixels_altivec(DCTELEM *restrict block, const uint8_t *s1,
+        const uint8_t *s2, int stride)
+{
+    int i;
+    vector unsigned char perm, bytes, *pixv;
+    const vector unsigned char zero = (const vector unsigned char)vec_splat_u8(0);
+    vector signed short shorts1, shorts2;
+
+    for (i = 0; i &lt; 4; i++) {
+        // Read potentially unaligned pixels
+        // We're reading 16 pixels, and actually only want 8,
+        // but we simply ignore the extras.
+        perm = vec_lvsl(0, s1);
+        pixv = (vector unsigned char *) s1;
+        bytes = vec_perm(pixv[0], pixv[1], perm);
+
+        // convert the bytes into shorts
+        shorts1 = (vector signed short)vec_mergeh(zero, bytes);
+
+        // Do the same for the second block of pixels
+        perm = vec_lvsl(0, s2);
+        pixv = (vector unsigned char *) s2;
+        bytes = vec_perm(pixv[0], pixv[1], perm);
+
+        // convert the bytes into shorts
+        shorts2 = (vector signed short)vec_mergeh(zero, bytes);
+
+        // Do the subtraction
+        shorts1 = vec_sub(shorts1, shorts2);
+
+        // save the data to the block, we assume the block is 16-byte aligned
+        vec_st(shorts1, 0, (vector signed short*)block);
+
+        s1 += stride;
+        s2 += stride;
+        block += 8;
+
+
+        // The code below is a copy of the code above... This is a manual
+        // unroll.
+
+        // Read potentially unaligned pixels
+        // We're reading 16 pixels, and actually only want 8,
+        // but we simply ignore the extras.
+        perm = vec_lvsl(0, s1);
+        pixv = (vector unsigned char *) s1;
+        bytes = vec_perm(pixv[0], pixv[1], perm);
+
+        // convert the bytes into shorts
+        shorts1 = (vector signed short)vec_mergeh(zero, bytes);
+
+        // Do the same for the second block of pixels
+        perm = vec_lvsl(0, s2);
+        pixv = (vector unsigned char *) s2;
+        bytes = vec_perm(pixv[0], pixv[1], perm);
+
+        // convert the bytes into shorts
+        shorts2 = (vector signed short)vec_mergeh(zero, bytes);
+
+        // Do the subtraction
+        shorts1 = vec_sub(shorts1, shorts2);
+
+        // save the data to the block, we assume the block is 16-byte aligned
+        vec_st(shorts1, 0, (vector signed short*)block);
+
+        s1 += stride;
+        s2 += stride;
+        block += 8;
+    }
+}
+
+
+static void clear_block_altivec(DCTELEM *block) {
+    LOAD_ZERO;
+    vec_st(zero_s16v,   0, block);
+    vec_st(zero_s16v,  16, block);
+    vec_st(zero_s16v,  32, block);
+    vec_st(zero_s16v,  48, block);
+    vec_st(zero_s16v,  64, block);
+    vec_st(zero_s16v,  80, block);
+    vec_st(zero_s16v,  96, block);
+    vec_st(zero_s16v, 112, block);
+}
+
+
+void add_bytes_altivec(uint8_t *dst, uint8_t *src, int w) {
+    register int i;
+    register vector unsigned char vdst, vsrc;
+
+    /* dst and src are 16 bytes-aligned (guaranteed) */
+    for (i = 0 ; (i + 15) &lt; w ; i+=16) {
+        vdst = vec_ld(i, (unsigned char*)dst);
+        vsrc = vec_ld(i, (unsigned char*)src);
+        vdst = vec_add(vsrc, vdst);
+        vec_st(vdst, i, (unsigned char*)dst);
+    }
+    /* if w is not a multiple of 16 */
+    for (; (i &lt; w) ; i++) {
+        dst[i] = src[i];
+    }
+}
+
+/* next one assumes that ((line_size % 16) == 0) */
+void put_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
+{
+POWERPC_PERF_DECLARE(altivec_put_pixels16_num, 1);
+    register vector unsigned char pixelsv1, pixelsv2;
+    register vector unsigned char pixelsv1B, pixelsv2B;
+    register vector unsigned char pixelsv1C, pixelsv2C;
+    register vector unsigned char pixelsv1D, pixelsv2D;
+
+    register vector unsigned char perm = vec_lvsl(0, pixels);
+    int i;
+    register int line_size_2 = line_size &lt;&lt; 1;
+    register int line_size_3 = line_size + line_size_2;
+    register int line_size_4 = line_size &lt;&lt; 2;
+
+POWERPC_PERF_START_COUNT(altivec_put_pixels16_num, 1);
+// hand-unrolling the loop by 4 gains about 15%
+// mininum execution time goes from 74 to 60 cycles
+// it's faster than -funroll-loops, but using
+// -funroll-loops w/ this is bad - 74 cycles again.
+// all this is on a 7450, tuning for the 7450
+#if 0
+    for (i = 0; i &lt; h; i++) {
+        pixelsv1 = vec_ld(0, (unsigned char*)pixels);
+        pixelsv2 = vec_ld(16, (unsigned char*)pixels);
+        vec_st(vec_perm(pixelsv1, pixelsv2, perm),
+               0, (unsigned char*)block);
+        pixels+=line_size;
+        block +=line_size;
+    }
+#else
+    for (i = 0; i &lt; h; i += 4) {
+        pixelsv1 = vec_ld(0, (unsigned char*)pixels);
+        pixelsv2 = vec_ld(15, (unsigned char*)pixels);
+        pixelsv1B = vec_ld(line_size, (unsigned char*)pixels);
+        pixelsv2B = vec_ld(15 + line_size, (unsigned char*)pixels);
+        pixelsv1C = vec_ld(line_size_2, (unsigned char*)pixels);
+        pixelsv2C = vec_ld(15 + line_size_2, (unsigned char*)pixels);
+        pixelsv1D = vec_ld(line_size_3, (unsigned char*)pixels);
+        pixelsv2D = vec_ld(15 + line_size_3, (unsigned char*)pixels);
+        vec_st(vec_perm(pixelsv1, pixelsv2, perm),
+               0, (unsigned char*)block);
+        vec_st(vec_perm(pixelsv1B, pixelsv2B, perm),
+               line_size, (unsigned char*)block);
+        vec_st(vec_perm(pixelsv1C, pixelsv2C, perm),
+               line_size_2, (unsigned char*)block);
+        vec_st(vec_perm(pixelsv1D, pixelsv2D, perm),
+               line_size_3, (unsigned char*)block);
+        pixels+=line_size_4;
+        block +=line_size_4;
+    }
+#endif
+POWERPC_PERF_STOP_COUNT(altivec_put_pixels16_num, 1);
+}
+
+/* next one assumes that ((line_size % 16) == 0) */
+#define op_avg(a,b)  a = ( ((a)|(b)) - ((((a)^(b))&amp;0xFEFEFEFEUL)&gt;&gt;1) )
+void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
+{
+POWERPC_PERF_DECLARE(altivec_avg_pixels16_num, 1);
+    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;
+    register vector unsigned char perm = vec_lvsl(0, pixels);
+    int i;
+
+POWERPC_PERF_START_COUNT(altivec_avg_pixels16_num, 1);
+
+    for (i = 0; i &lt; h; i++) {
+        pixelsv1 = vec_ld(0, (unsigned char*)pixels);
+        pixelsv2 = vec_ld(16, (unsigned char*)pixels);
+        blockv = vec_ld(0, block);
+        pixelsv = vec_perm(pixelsv1, pixelsv2, perm);
+        blockv = vec_avg(blockv,pixelsv);
+        vec_st(blockv, 0, (unsigned char*)block);
+        pixels+=line_size;
+        block +=line_size;
+    }
+
+POWERPC_PERF_STOP_COUNT(altivec_avg_pixels16_num, 1);
+}
+
+/* next one assumes that ((line_size % 8) == 0) */
+void avg_pixels8_altivec(uint8_t * block, const uint8_t * pixels, int line_size, int h)
+{
+POWERPC_PERF_DECLARE(altivec_avg_pixels8_num, 1);
+    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;
+    int i;
+
+POWERPC_PERF_START_COUNT(altivec_avg_pixels8_num, 1);
+
+   for (i = 0; i &lt; h; i++) {
+       /* block is 8 bytes-aligned, so we're either in the
+          left block (16 bytes-aligned) or in the right block (not) */
+       int rightside = ((unsigned long)block &amp; 0x0000000F);
+
+       blockv = vec_ld(0, block);
+       pixelsv1 = vec_ld(0, (unsigned char*)pixels);
+       pixelsv2 = vec_ld(16, (unsigned char*)pixels);
+       pixelsv = vec_perm(pixelsv1, pixelsv2, vec_lvsl(0, pixels));
+
+       if (rightside) {
+           pixelsv = vec_perm(blockv, pixelsv, vcprm(0,1,s0,s1));
+       } else {
+           pixelsv = vec_perm(blockv, pixelsv, vcprm(s0,s1,2,3));
+       }
+
+       blockv = vec_avg(blockv, pixelsv);
+
+       vec_st(blockv, 0, block);
+
+       pixels += line_size;
+       block += line_size;
+   }
+
+POWERPC_PERF_STOP_COUNT(altivec_avg_pixels8_num, 1);
+}
+
+/* next one assumes that ((line_size % 8) == 0) */
+void put_pixels8_xy2_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
+{
+POWERPC_PERF_DECLARE(altivec_put_pixels8_xy2_num, 1);
+    register int i;
+    register vector unsigned char pixelsv1, pixelsv2, pixelsavg;
+    register vector unsigned char blockv, temp1, temp2;
+    register vector unsigned short pixelssum1, pixelssum2, temp3;
+    register const vector unsigned char vczero = (const vector unsigned char)vec_splat_u8(0);
+    register const vector unsigned short vctwo = (const vector unsigned short)vec_splat_u16(2);
+
+    temp1 = vec_ld(0, pixels);
+    temp2 = vec_ld(16, pixels);
+    pixelsv1 = vec_perm(temp1, temp2, vec_lvsl(0, pixels));
+    if ((((unsigned long)pixels) &amp; 0x0000000F) ==  0x0000000F) {
+        pixelsv2 = temp2;
+    } else {
+        pixelsv2 = vec_perm(temp1, temp2, vec_lvsl(1, pixels));
+    }
+    pixelsv1 = vec_mergeh(vczero, pixelsv1);
+    pixelsv2 = vec_mergeh(vczero, pixelsv2);
+    pixelssum1 = vec_add((vector unsigned short)pixelsv1,
+                         (vector unsigned short)pixelsv2);
+    pixelssum1 = vec_add(pixelssum1, vctwo);
+
+POWERPC_PERF_START_COUNT(altivec_put_pixels8_xy2_num, 1);
+    for (i = 0; i &lt; h ; i++) {
+        int rightside = ((unsigned long)block &amp; 0x0000000F);
+        blockv = vec_ld(0, block);
+
+        temp1 = vec_ld(line_size, pixels);
+        temp2 = vec_ld(line_size + 16, pixels);
+        pixelsv1 = vec_perm(temp1, temp2, vec_lvsl(line_size, pixels));
+        if (((((unsigned long)pixels) + line_size) &amp; 0x0000000F) ==  0x0000000F) {
+            pixelsv2 = temp2;
+        } else {
+            pixelsv2 = vec_perm(temp1, temp2, vec_lvsl(line_size + 1, pixels));
+        }
+
+        pixelsv1 = vec_mergeh(vczero, pixelsv1);
+        pixelsv2 = vec_mergeh(vczero, pixelsv2);
+        pixelssum2 = vec_add((vector unsigned short)pixelsv1,
+                             (vector unsigned short)pixelsv2);
+        temp3 = vec_add(pixelssum1, pixelssum2);
+        temp3 = vec_sra(temp3, vctwo);
+        pixelssum1 = vec_add(pixelssum2, vctwo);
+        pixelsavg = vec_packsu(temp3, (vector unsigned short) vczero);
+
+        if (rightside) {
+            blockv = vec_perm(blockv, pixelsavg, vcprm(0, 1, s0, s1));
+        } else {
+            blockv = vec_perm(blockv, pixelsavg, vcprm(s0, s1, 2, 3));
+        }
+
+        vec_st(blockv, 0, block);
+
+        block += line_size;
+        pixels += line_size;
+    }
+
+POWERPC_PERF_STOP_COUNT(altivec_put_pixels8_xy2_num, 1);
+}
+
+/* next one assumes that ((line_size % 8) == 0) */
+void put_no_rnd_pixels8_xy2_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)
+{
+POWERPC_PERF_DECLARE(altivec_put_no_rnd_pixels8_xy2_num, 1);
+    register int i;
+    register vector unsigned char pixelsv1, pixelsv2, pixelsavg;
+    register vector unsigned char blockv, temp1, temp2;
+    register vector unsigned short pixelssum1, pixelssum2, temp3;
+    register const vector unsigned char vczero = (const vector unsigned char)vec_splat_u8(0);
+    register const vector unsigned short vcone = (const vector unsigned short)vec_splat_u16(1);
+    register const vector unsigned short vctwo = (const vector unsigned short)vec_splat_u16(2);
+
+    temp1 = vec_ld(0, pixels);
+    temp2 = vec_ld(16, pixels);
+    pixelsv1 = vec_perm(temp1, temp2, vec_lvsl(0, pixels));
+    if ((((unsigned long)pixels) &amp; 0x0000000F) ==  0x0000000F) {
+        pixelsv2 = temp2;
+    } else {
+        pixelsv2 = vec_perm(temp1, temp2, vec_lvsl(1, pixels));
+    }
+    pixelsv1 = vec_mergeh(vczero, pixelsv1);
+    pixelsv2 = vec_mergeh(vczero, pixelsv2);
+    pixelssum1 = vec_add((vector unsigned short)pixelsv1,
+                         (vector unsigned short)pixelsv2);
+    pixelssum1 = vec_add(pixelssum1, vcone);
+
+POWERPC_PERF_START_COUNT(altivec_put_no_rnd_pixels8_xy2_num, 1);
+    for (i = 0; i &lt; h ; i++) {
+        int rightside = ((unsigned long)block &amp; 0x0000000F);
+        blockv = vec_ld(0, block);
+
+        temp1 = vec_ld(line_size, pixels);
+        temp2 = vec_ld(line_size + 16, pixels);
+        pixelsv1 = vec_perm(temp1, temp2, vec_lvsl(line_size, pixels));
+        if (((((unsigned long)pixels) + line_size) &amp; 0x0000000F) ==  0x0000000F) {
+            pixelsv2 = temp2;
+        } else {
+            pixelsv2 = vec_perm(temp1, temp2, vec_lvsl(line_size + 1, pixels));
+        }
+
+        pixelsv1 = vec_mergeh(vczero, pixelsv1);
+        pixelsv2 = vec_mergeh(vczero, pixelsv2);
+        pixelssum2 = vec_add((vector unsigned short)pixelsv1,
+                             (vector unsigned short)pixelsv2);
+        temp3 = vec_add(pixelssum1, pixelssum2);
+        temp3 = vec_sra(temp3, vctwo);
+        pixelssum1 = vec_add(pixelssum2, vcone);
+        pixelsavg = vec_packsu(temp3, (vector unsigned short) vczero);
+
+        if (rightside) {
+            blockv = vec_perm(blockv, pixelsavg, vcprm(0, 1, s0, s1));

[... truncated: 11711 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="015859.html">[Haiku-commits] r30186 - haiku/trunk/src/bin/debug/profile
</A></li>
	<LI>Next message: <A HREF="015861.html">[Haiku-commits] r30187 - in	haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec: .	ppc sparc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#15860">[ date ]</a>
              <a href="thread.html#15860">[ thread ]</a>
              <a href="subject.html#15860">[ subject ]</a>
              <a href="author.html#15860">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
