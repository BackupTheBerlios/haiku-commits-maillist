<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r30498 - in haiku/trunk/src/add-ons/media/plugins:	. avcodec avcodec/libavcodec avcodec/libavcodec/x86	avcodec/libavutil avcodec/libswscale mov_reader	mov_reader/libMOV mp4_reader/libMP4 wav_reader
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30498%20-%20in%20haiku/trunk/src/add-ons/media/plugins%3A%0A%09.%20avcodec%20avcodec/libavcodec%20avcodec/libavcodec/x86%0A%09avcodec/libavutil%20avcodec/libswscale%20mov_reader%0A%09mov_reader/libMOV%20mp4_reader/libMP4%20wav_reader&In-Reply-To=%3C200904301023.n3UANGVG021249%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="016318.html">
   <LINK REL="Next"  HREF="016320.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r30498 - in haiku/trunk/src/add-ons/media/plugins:	. avcodec avcodec/libavcodec avcodec/libavcodec/x86	avcodec/libavutil avcodec/libswscale mov_reader	mov_reader/libMOV mp4_reader/libMP4 wav_reader</H1>
    <B>dlmcpaul at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r30498%20-%20in%20haiku/trunk/src/add-ons/media/plugins%3A%0A%09.%20avcodec%20avcodec/libavcodec%20avcodec/libavcodec/x86%0A%09avcodec/libavutil%20avcodec/libswscale%20mov_reader%0A%09mov_reader/libMOV%20mp4_reader/libMP4%20wav_reader&In-Reply-To=%3C200904301023.n3UANGVG021249%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r30498 - in haiku/trunk/src/add-ons/media/plugins:	. avcodec avcodec/libavcodec avcodec/libavcodec/x86	avcodec/libavutil avcodec/libswscale mov_reader	mov_reader/libMOV mp4_reader/libMP4 wav_reader">dlmcpaul at mail.berlios.de
       </A><BR>
    <I>Thu Apr 30 12:23:16 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="016318.html">[Haiku-commits] r30497 - in	haiku/trunk/src/add-ons/media/plugins/asf_reader: . libasf
</A></li>
        <LI>Next message: <A HREF="016320.html">[Haiku-commits] r30498 - in haiku/trunk/src/add-ons/media/plugins: . avcodec avcodec/libavcodec avcodec/libavcodec/x86	avcodec/libavutil avcodec/libswscale mov_reader	mov_reader/libMOV mp4_reader/libMP4 wav_reader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16319">[ date ]</a>
              <a href="thread.html#16319">[ thread ]</a>
              <a href="subject.html#16319">[ subject ]</a>
              <a href="author.html#16319">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: dlmcpaul
Date: 2009-04-30 12:23:13 +0200 (Thu, 30 Apr 2009)
New Revision: 30498
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=30498&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=30498&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.cpp
Modified:
   haiku/trunk/src/add-ons/media/plugins/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_util.cpp
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/config.h
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/h264.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/dsputil_mmx.c
   haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
   haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.cpp
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.h
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVFileReader.cpp
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVFileReader.h
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVParser.cpp
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVParser.h
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVTrakAtom.cpp
   haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/QTStructs.h
   haiku/trunk/src/add-ons/media/plugins/mov_reader/mov_reader.cpp
   haiku/trunk/src/add-ons/media/plugins/mp4_reader/libMP4/MP4FileReader.cpp
   haiku/trunk/src/add-ons/media/plugins/wav_reader/WavReaderPlugin.cpp
   haiku/trunk/src/add-ons/media/plugins/wav_reader/WavReaderPlugin.h
   haiku/trunk/src/add-ons/media/plugins/wav_reader/wav.h
Log:
include asf_reader in compilation may break GCC4 builds

Modified: haiku/trunk/src/add-ons/media/plugins/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -22,6 +22,8 @@
 SubInclude HAIKU_TOP src add-ons media plugins mov_reader ;
 SubInclude HAIKU_TOP src add-ons media plugins mp4_reader ;
 
+SubInclude HAIKU_TOP src add-ons media plugins asf_reader ;
+
 # The following add-ons are GPL licensed, and can only be used with
 # software whose license is GPL compatible. To include these GPL
 # licensed add-ons, you need to run configure with the --include-gpl-addons

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -8,12 +8,14 @@
 SubDirHdrs [ FDirName $(SUBDIR) libavutil ] ;
 SubDirHdrs [ FDirName $(SUBDIR) libswscale ] ;
 
+SubDirCcFlags -fomit-frame-pointer -DPIC -fno-common ;
+
 Addon avcodec :
  	avcodec.cpp
  	codectbl.cpp
 	gfx_conv_c.cpp
 	gfx_conv_c_lookup.cpp
-#	gfx_conv_mmx.cpp
+	gfx_conv_mmx.cpp
  	gfx_util.cpp
 	:  
 	libavcodec.a

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/avcodec.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -466,12 +466,18 @@
 			if (fChunkBufferSize == 0) {
 				media_header chunk_mh;
 				status_t err;
+				printf(&quot;Asking for more data after %Ld frames\n&quot;,fFrame);
 				err = GetNextChunk(&amp;fChunkBuffer, &amp;fChunkBufferSize, &amp;chunk_mh);
+				if (err == B_LAST_BUFFER_ERROR) {
+					printf(&quot;Last Chunk with chunk size %ld\n&quot;,fChunkBufferSize);
+					return err;
+				}
 				if (err != B_OK || fChunkBufferSize &lt; 0) {
-					TRACE(&quot;GetNextChunk error %ld\n&quot;,fChunkBufferSize);
+					printf(&quot;GetNextChunk error %ld\n&quot;,fChunkBufferSize);
 					fChunkBufferSize = 0;
 					break;
 				}
+				printf(&quot;Got a Chunk with start time of %Ld\n&quot;,chunk_mh.start_time);
 				fChunkBufferOffset = 0;
 				fStartTime = chunk_mh.start_time;
 				if (*out_frameCount == 0)

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/codectbl.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -69,6 +69,7 @@
 
 	{CODEC_ID_WMAV1,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x160, &quot;MS WMA v1&quot;},
 	{CODEC_ID_WMAV2,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x161, &quot;MS WMA v2&quot;},
+	{CODEC_ID_VOXWARE,	B_MEDIA_ENCODED_AUDIO,	B_WAV_FORMAT_FAMILY,	0x75, &quot;Voxware&quot;},
 
 	{CODEC_ID_CINEPAK,	B_MEDIA_ENCODED_VIDEO, B_AVI_FORMAT_FAMILY,	FOURCC('cvid'), &quot;Cinepak Video&quot;},
 	{CODEC_ID_CINEPAK,	B_MEDIA_ENCODED_VIDEO, B_QUICKTIME_FORMAT_FAMILY,	'cvid', &quot;Cinepak Video&quot;},

Added: haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -0,0 +1,38 @@
+extern &quot;C&quot; {
+#include &quot;libavcodec/imgconvert.h&quot;
+}
+
+void gfx_conv_null_mmx(AVFrame *in, AVFrame *out, int width, int height) {
+	memcpy(out-&gt;data[0], in-&gt;data[0], height * in-&gt;linesize[0]);
+}
+
+void gfx_conv_yuv410p_ycbcr422_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_YUV422P,(const AVPicture *)in,PIX_FMT_YUV410P,width,height);
+}
+
+void gfx_conv_yuv411p_ycbcr422_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_YUV422P,(const AVPicture *)in,PIX_FMT_YUV411P,width,height);
+}
+
+void gfx_conv_yuv420p_ycbcr422_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_YUV422P,(const AVPicture *)in,PIX_FMT_YUV420P,width,height);
+}
+
+void gfx_conv_yuv410p_rgb32_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_RGB32,(const AVPicture *)in,PIX_FMT_YUV410P,width,height);
+}
+
+void gfx_conv_yuv411p_rgb32_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_RGB32,(const AVPicture *)in,PIX_FMT_YUV411P,width,height);
+}
+
+void gfx_conv_yuv420p_rgb32_mmx(AVFrame *in, AVFrame *out, int width, int height)
+{
+	img_convert((AVPicture *)out,PIX_FMT_RGB32,(const AVPicture *)in,PIX_FMT_YUV420P,width,height);
+}
+

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.h	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_conv_mmx.h	2009-04-30 10:23:13 UTC (rev 30498)
@@ -5,8 +5,6 @@
 #include &lt;GraphicsDefs.h&gt;
 #include &quot;libavcodec/avcodec.h&quot;
 
-bool IsMmxCpu();
-
 void gfx_conv_null_mmx(AVFrame *in, AVFrame *out, int width, int height);
 
 void gfx_conv_yuv410p_ycbcr422_mmx(AVFrame *in, AVFrame *out, int width, int height);

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_util.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_util.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/gfx_util.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -16,14 +16,14 @@
 #endif
 
 //#define INCLUDE_MMX 	defined(__INTEL__)
-#define INCLUDE_MMX 	0
+#define INCLUDE_MMX 	1
 
 // this function will try to find the best colorspaces for both the ff-codec and 
 // the Media Kit sides.
 gfx_convert_func resolve_colorspace(color_space colorSpace, PixelFormat pixelFormat)
 {
 #if INCLUDE_MMX
-	bool mmx = IsMmxCpu();
+	bool mmx = true;
 #endif
 
 	switch (colorSpace)

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -14,7 +14,7 @@
 if $(HAIKU_GCC_VERSION[1]) &gt;= 3 {
 	SubDirCcFlags -fomit-frame-pointer -fno-pic ;
 } else {
-	SubDirCcFlags -fomit-frame-pointer -DPIC ;
+	SubDirCcFlags -fomit-frame-pointer -DPIC -fno-common ;
 }
 
 local defines ;

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/config.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/config.h	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/config.h	2009-04-30 10:23:13 UTC (rev 30498)
@@ -54,7 +54,9 @@
 #define HAVE_DLFCN_H 0
 #define HAVE_DLOPEN 0
 #define HAVE_DOS_PATHS 0
-#define HAVE_EBP_AVAILABLE 0
+// Jamfile must have -fomit_frame_pointer
+#define HAVE_EBP_AVAILABLE 1
+// We use position independant code so no EBX
 #define HAVE_EBX_AVAILABLE 0
 #define HAVE_FAST_64BIT 0
 #define HAVE_FAST_CMOV 0
@@ -75,10 +77,10 @@
 #define HAVE_MACHINE_IOCTL_BT848_H 0
 #define HAVE_MACHINE_IOCTL_METEOR_H 0
 #define HAVE_MALLOC_H 1
-#define HAVE_MEMALIGN 1
+#define HAVE_MEMALIGN 0
 #define HAVE_MKSTEMP 1
 #define HAVE_PLD 0
-#define HAVE_POSIX_MEMALIGN 0
+#define HAVE_POSIX_MEMALIGN 1
 #define HAVE_PPC64 0
 #define HAVE_ROUND 1
 #define HAVE_ROUNDF 1

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/h264.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/h264.c	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/h264.c	2009-04-30 10:23:13 UTC (rev 30498)
@@ -2412,6 +2412,8 @@
         }
     }
 }
+#include &lt;stdio.h&gt;
+#undef printf
 
 static av_always_inline void hl_decode_mb_internal(H264Context *h, int simple){
     MpegEncContext * const s = &amp;h-&gt;s;
@@ -2420,6 +2422,8 @@
     const int mb_xy= h-&gt;mb_xy;
     const int mb_type= s-&gt;current_picture.mb_type[mb_xy];
     uint8_t  *dest_y, *dest_cb, *dest_cr;
+    uintptr_t v;
+    size_t align;
     int linesize, uvlinesize /*dct_offset*/;
     int i;
     int *block_offset = &amp;h-&gt;block_offset[0];
@@ -2433,6 +2437,14 @@
     dest_cb = s-&gt;current_picture.data[1] + (mb_x + mb_y * s-&gt;uvlinesize) * 8;
     dest_cr = s-&gt;current_picture.data[2] + (mb_x + mb_y * s-&gt;uvlinesize) * 8;
 
+  v = (uintptr_t)dest_y;
+
+  align = ffs((int)v);
+
+  printf(&quot;aligned(16): %s: address: %p alignment: %d (2^%u)\n&quot;,
+        align &gt; 4 ? &quot;PASS&quot; : &quot;FAIL&quot;, v, 1&lt;&lt;(align-1), align-1);
+
+
     s-&gt;dsp.prefetch(dest_y + (s-&gt;mb_x&amp;3)*4*s-&gt;linesize + 64, s-&gt;linesize, 4);
     s-&gt;dsp.prefetch(dest_cb + (s-&gt;mb_x&amp;7)*s-&gt;uvlinesize + 64, dest_cr - dest_cb, 2);
 

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -19,7 +19,7 @@
 defines = HAVE_AV_CONFIG_H=1 ;
 defines += ARCH_X86=1 ARCH_X86_32=1 ARCH_PPC=0 ARCH_SPARC=0 ;
 defines += HAVE_AMD3DNOW=0 HAVE_AMD3DNOWEXT=0 ;
-defines += HAVE_MMX=1 HAVE_MMX2=1 HAVE_SSE=0 HAVE_SSE3=1 ; 
+defines += HAVE_MMX=1 HAVE_MMX2=1 HAVE_SSE=1 HAVE_SSE3=1 ; 
 defines += HAVE_ALTIVEC=0 ;
 defines += HAVE_VIS=0 ;
 

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/dsputil_mmx.c
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/dsputil_mmx.c	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavcodec/x86/dsputil_mmx.c	2009-04-30 10:23:13 UTC (rev 30498)
@@ -2391,6 +2391,56 @@
 #define ff_float_to_int16_interleave6_3dnow(a,b,c) float_to_int16_interleave_misc_3dnow(a,b,c,6)
 #define ff_float_to_int16_interleave6_3dn2(a,b,c)  float_to_int16_interleave_misc_3dnow(a,b,c,6)
 #endif
+
+#include &lt;stdio.h&gt;
+#undef printf
+
+void haiku_x264_deblock_v_luma_sse2(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0) {
+
+  uintptr_t v = (uintptr_t)pix;
+  size_t align1;
+  size_t align2;
+
+  align1 = ffs((int)v);
+  printf(&quot;V pix aligned(16): %s: address: %p alignment: %d (2^%u)\n&quot;,
+        align1 &gt; 4 ? &quot;PASS&quot; : &quot;FAIL&quot;, v, 1&lt;&lt;(align1-1), align1-1);
+
+  v = (uintptr_t)tc0;
+
+  align2 = ffs((int)v);
+  printf(&quot;V tc0 aligned(16): %s: address: %p alignment: %d (2^%u)\n&quot;,
+        align2 &gt; 4 ? &quot;PASS&quot; : &quot;FAIL&quot;, v, 1&lt;&lt;(align2-1), align2-1);
+
+	if (align1 &gt; 4 &amp;&amp; align2 &gt; 4) {
+		ff_x264_deblock_v_luma_sse2(pix, stride, alpha, beta, tc0);
+	} else {
+		h264_v_loop_filter_luma_mmx2(pix, stride, alpha, beta, tc0);
+	}
+}
+
+void haiku_x264_deblock_h_luma_sse2(uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0) {
+
+  uintptr_t v = (uintptr_t)pix;
+  size_t align1;
+  size_t align2;
+
+  align1 = ffs((int)v);
+  printf(&quot;H pix aligned(16): %s: address: %p alignment: %d (2^%u)\n&quot;,
+        align1 &gt; 4 ? &quot;PASS&quot; : &quot;FAIL&quot;, v, 1&lt;&lt;(align1-1), align1-1);
+
+  v = (uintptr_t)tc0;
+
+  align2 = ffs((int)v);
+  printf(&quot;H tc0 aligned(16): %s: address: %p alignment: %d (2^%u)\n&quot;,
+        align2 &gt; 4 ? &quot;PASS&quot; : &quot;FAIL&quot;, v, 1&lt;&lt;(align2-1), align2-1);
+
+	if (align1 &gt; 4 &amp;&amp; align2 &gt; 4) {
+		ff_x264_deblock_h_luma_sse2(pix, stride, alpha, beta, tc0);
+	} else {
+		h264_h_loop_filter_luma_mmx2(pix, stride, alpha, beta, tc0);
+	}
+}
+
 #define ff_float_to_int16_interleave6_sse2 ff_float_to_int16_interleave6_sse
 
 #define FLOAT_TO_INT16_INTERLEAVE(cpu, body) \
@@ -2945,8 +2995,8 @@
 #endif
             if( mm_flags&amp;FF_MM_SSE2 ){
 #if ARCH_X86_64 || !defined(__ICC) || __ICC &gt; 1100
-                c-&gt;h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;
-                c-&gt;h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;
+                c-&gt;h264_v_loop_filter_luma = haiku_x264_deblock_v_luma_sse2;
+                c-&gt;h264_h_loop_filter_luma = haiku_x264_deblock_h_luma_sse2;
                 c-&gt;h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;
                 c-&gt;h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;
 #endif

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libavutil/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -7,7 +7,7 @@
 SubDirHdrs [ FDirName $(SUBDIR) .. ] ;
 SubDirHdrs [ FDirName $(SUBDIR) ../libavcodec ] ;
 
-SubDirCcFlags -fomit-frame-pointer -DPIC ;
+SubDirCcFlags -fomit-frame-pointer -DPIC -fno-common ;
 #SubDirCcFlags -DHAVE_AV_CONFIG_H=1 ;
 
 StaticLibrary libavutil.a :

Modified: haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/avcodec/libswscale/Jamfile	2009-04-30 10:23:13 UTC (rev 30498)
@@ -8,7 +8,7 @@
 TARGET_WARNING_CCFLAGS = [ FFilter $(TARGET_WARNING_CCFLAGS)
 	: -Wall -Wmissing-prototypes -Wsign-compare -Wpointer-arith ] ;
 
-SubDirCcFlags -fomit-frame-pointer -DPIC ;
+SubDirCcFlags -fomit-frame-pointer -DPIC -fno-common ;
 
 local arch_sources ;
 arch_sources = ;

Modified: haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -41,6 +41,17 @@
 	parentAtom = NULL;
 }
 
+char	*AtomBase::getAtomTypeAsFourcc()
+{
+	fourcc[0] = (char)((atomType &gt;&gt; 24) &amp; 0xff);
+	fourcc[1] = (char)((atomType &gt;&gt; 16) &amp; 0xff);
+	fourcc[2] = (char)((atomType &gt;&gt; 8) &amp; 0xff);
+	fourcc[3] = (char)((atomType &gt;&gt; 0) &amp; 0xff);
+	fourcc[4] = '\0';
+
+	return fourcc;
+}
+
 char *AtomBase::getAtomName()
 {
 	char *_result;
@@ -107,7 +118,7 @@
 void	AtomBase::DisplayAtoms(uint32 pindent)
 {
 	Indent(pindent);
-	printf(&quot;%s\n&quot;,getAtomName());
+	printf(&quot;(%s)\n&quot;,getAtomName());
 }
 
 void	AtomBase::Indent(uint32 pindent)
@@ -124,10 +135,6 @@
 
 void AtomBase::ReadArrayHeader(array_header *pHeader)
 {
-	Read(&amp;pHeader-&gt;Version);
-	Read(&amp;pHeader-&gt;Flags1);
-	Read(&amp;pHeader-&gt;Flags2);
-	Read(&amp;pHeader-&gt;Flags3);
 	Read(&amp;pHeader-&gt;NoEntries);
 }
 
@@ -164,6 +171,17 @@
 	*value = B_BENDIAN_TO_HOST_INT32(*value);
 }
 
+void	AtomBase::Read(int32	*value)
+{
+	uint32	bytes_read;
+	
+	bytes_read = getStream()-&gt;Read(value,sizeof(int32));
+	
+	// Assert((bytes_read == sizeof(int32),&quot;Read Error&quot;);
+	
+	*value = B_BENDIAN_TO_HOST_INT32(*value);
+}
+
 void	AtomBase::Read(uint16	*value)
 {
 	uint32	bytes_read;
@@ -202,6 +220,52 @@
 	// Assert((bytes_read == maxread,&quot;Read Error&quot;);
 }
 
+uint64	AtomBase::GetBits(uint64 buffer, uint8 startBit, uint8 totalBits)
+{
+	// startBit should range from 0-63, totalBits should range from 1-64
+	if ((startBit &lt; 64) &amp;&amp; (totalBits &gt; 0) &amp;&amp; (totalBits &lt;= 64) &amp;&amp; (startBit + totalBits &lt;= 64)) {
+		// Ok pull from the buffer the bits wanted.
+		buffer = buffer &lt;&lt; startBit;
+		buffer = buffer &gt;&gt; (64 - (totalBits + startBit) + startBit);
+		
+		printf(&quot;buffer = %Ld\n&quot;,buffer);
+		
+		return buffer;
+	}
+	
+	return 0L;
+}
+
+uint32	AtomBase::GetBits(uint32 buffer, uint8 startBit, uint8 totalBits)
+{
+	// startBit should range from 0-31, totalBits should range from 1-32
+	if ((startBit &lt; 32) &amp;&amp; (totalBits &gt; 0) &amp;&amp; (totalBits &lt;= 32) &amp;&amp; (startBit + totalBits &lt;= 32)) {
+		// Ok pull from the buffer the bits wanted.
+		buffer = buffer &lt;&lt; startBit;
+		buffer = buffer &gt;&gt; (32 - (startBit + totalBits) + startBit);
+		
+		return buffer;
+	}
+
+	return 0;
+}
+
+FullAtom::FullAtom(BPositionIO *pStream, off_t pstreamOffset, uint32 patomType, uint64 patomSize) : AtomBase(pStream, pstreamOffset, patomType, patomSize)
+{
+}
+
+FullAtom::~FullAtom()
+{
+}
+
+void	FullAtom::OnProcessMetaData()
+{
+	Read(&amp;Version);
+	Read(&amp;Flags1);
+	Read(&amp;Flags2);
+	Read(&amp;Flags3);
+}
+
 AtomContainer::AtomContainer(BPositionIO *pStream, off_t pstreamOffset, uint32 patomType, uint64 patomSize) : AtomBase(pStream, pstreamOffset, patomType, patomSize)
 {
 	TotalChildren = 0;
@@ -214,7 +278,7 @@
 void	AtomContainer::DisplayAtoms(uint32 pindent)
 {
 	Indent(pindent);
-	printf(&quot;%ld:%s\n&quot;,TotalChildren,getAtomName());
+	printf(&quot;%ld:(%s)\n&quot;,TotalChildren,getAtomName());
 	pindent++;
 	// for each child
 	for (uint32 i = 0;i &lt; TotalChildren;i++) {

Modified: haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.h
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.h	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVAtom.h	2009-04-30 10:23:13 UTC (rev 30498)
@@ -101,17 +101,18 @@
 	
 	uint64	getAtomSize() {return atomSize;};
 	uint32	getAtomType() {return atomType;};
-	off_t	getAtomOffset() {return atomOffset;};
-	off_t	getStreamOffset() {return streamOffset;};
+	char	*getAtomTypeAsFourcc();
+	off_t	getAtomOffset() { return atomOffset; };
+	off_t	getStreamOffset() { return streamOffset; };
 	
-	uint64	getDataSize() {return atomSize - 8;};
-
+	uint64	getDataSize() { return atomSize - 8;};
+	
 	uint64	getBytesRemaining();
 	
-	bool	IsType(uint32 patomType) {return patomType == atomType;};
+	bool	IsType(uint32 patomType) { return patomType == atomType; };
 	
-	void	setAtomOffset(off_t patomOffset) {atomOffset = patomOffset;};
-	void	setStreamOffset(off_t pstreamOffset) {streamOffset = pstreamOffset;};
+	void	setAtomOffset(off_t patomOffset) { atomOffset = patomOffset; };
+	void	setStreamOffset(off_t pstreamOffset) { streamOffset = pstreamOffset; };
 	
 	char 	*getAtomName();
 	
@@ -134,20 +135,42 @@
 	
 	void	setParent(AtomBase *pParent) {parentAtom = pParent;};
 	AtomBase *getParent() { return parentAtom;};
-	
+
 	void	Read(uint64	*value);
 	void	Read(uint32	*value);
+	void	Read(int32	*value);
 	void	Read(uint16	*value);
 	void	Read(uint8	*value);
 	void	Read(char	*value, uint32 maxread);
 	void	Read(uint8	*value, uint32 maxread);
+	
+	uint64	GetBits(uint64 buffer, uint8 startBit, uint8 totalBits);
+	uint32	GetBits(uint32 buffer, uint8 startBit, uint8 totalBits);
 };
 
+class FullAtom : public AtomBase {
+public:
+			FullAtom(BPositionIO *pStream, off_t pstreamOffset, uint32 patomType, uint64 patomSize);
+	virtual	~FullAtom();
+
+	virtual void	OnProcessMetaData();
+	uint8	getVersion() {return Version;};
+	uint8	getFlags1()	{return Flags1;};
+	uint8	getFlags2()	{return Flags2;};
+	uint8	getFlags3()	{return Flags3;};
+	
+private:
+	uint8	Version;
+	uint8	Flags1;
+	uint8	Flags2;
+	uint8	Flags3;
+};
+
 class AtomContainer : public AtomBase {
 
 /*
 
-	This is an Atom that contains other atoms.  It has children that may be Containter Atoms or Standard Atoms
+	This is an Atom that contains other atoms.  It has children that may be Container Atoms or Standard Atoms
 
 */
 

Modified: haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVFileReader.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVFileReader.cpp	2009-04-30 10:21:34 UTC (rev 30497)
+++ haiku/trunk/src/add-ons/media/plugins/mov_reader/libMOV/MOVFileReader.cpp	2009-04-30 10:23:13 UTC (rev 30498)
@@ -39,14 +39,13 @@
 MOVFileReader::MOVFileReader(BPositionIO *pStream)
 {
 	theStream = pStream;
-	
+
 	// Find Size of Stream, need to rethink this for non seekable streams
 	theStream-&gt;Seek(0,SEEK_END);
 	StreamSize = theStream-&gt;Position();
-	
 	theStream-&gt;Seek(0,SEEK_SET);
 	TotalChildren = 0;
-	
+
 	theMVHDAtom = NULL;
 }
 
@@ -56,41 +55,52 @@
 	theMVHDAtom = NULL;
 }
 
-bool MOVFileReader::IsEndOfData(off_t pPosition)
+bool 
+MOVFileReader::IsEndOfData(off_t position)
 {
-AtomBase	*aAtomBase;
+	AtomBase* aAtomBase;
 
-	aAtomBase = GetChildAtom(uint32('mdat'),0);
-	if (aAtomBase) {
-		MDATAtom *aMdatAtom = dynamic_cast&lt;MDATAtom *&gt;(aAtomBase);
-		return pPosition &gt;= aMdatAtom-&gt;getEOF();
+	// check all mdat atoms to make sure position is within one of them
+
+	for (uint32 index=0;index&lt;CountChildAtoms('mdat');index++) {
+		aAtomBase = GetChildAtom(uint32('mdat'),index);
+		if ((aAtomBase) &amp;&amp; (aAtomBase-&gt;getAtomSize() &gt; 8)) {
+			MDATAtom *aMDATAtom = dynamic_cast&lt;MDATAtom *&gt;(aAtomBase);
+			if (position &gt;= aMDATAtom-&gt;getAtomOffset() &amp;&amp; position &lt;= aMDATAtom-&gt;getEOF()) {
+				return false;
+			}
+		}
 	}
-	
+
 	return true;
 }
 
-bool MOVFileReader::IsEndOfFile(off_t pPosition)
+bool 
+MOVFileReader::IsEndOfFile(off_t position)
 {
-	return (pPosition &gt;= StreamSize);
+	return (position &gt;= StreamSize);
 }
 
-bool MOVFileReader::IsEndOfFile()
+bool 
+MOVFileReader::IsEndOfFile()
 {
-	return (theStream-&gt;Position() &gt;= StreamSize);
+	return theStream-&gt;Position() &gt;= StreamSize;
 }
 
-bool MOVFileReader::AddChild(AtomBase *pChildAtom)
+bool 
+MOVFileReader::AddChild(AtomBase *childAtom)
 {
-	if (pChildAtom) {
-		atomChildren[TotalChildren++] = pChildAtom;
+	if (childAtom) {
+		atomChildren[TotalChildren++] = childAtom;
 		return true;
 	}
 	return false;
 }
 
-AtomBase *MOVFileReader::GetChildAtom(uint32 patomType, uint32 offset)
+AtomBase *
+MOVFileReader::GetChildAtom(uint32 patomType, uint32 offset)
 {
-	for (uint32 i=0;i&lt;TotalChildren;i++) {
+	for (uint32 i = 0; i &lt; TotalChildren; i++) {
 		if (atomChildren[i]-&gt;IsType(patomType)) {
 			// found match, skip if offset non zero.
 			if (offset == 0) {
@@ -113,7 +123,8 @@
 	return NULL;
 }
 
-uint32	MOVFileReader::CountChildAtoms(uint32 patomType)
+uint32
+MOVFileReader::CountChildAtoms(uint32 patomType)
 {
 	uint32 count = 0;
 
@@ -123,9 +134,10 @@
 	return count;
 }
 
-MVHDAtom	*MOVFileReader::getMVHDAtom()
+MVHDAtom*
+MOVFileReader::getMVHDAtom()
 {
-AtomBase *aAtomBase;
+	AtomBase *aAtomBase;
 
 	if (theMVHDAtom == NULL) {
 		aAtomBase = GetChildAtom(uint32('mvhd'));
@@ -136,164 +148,184 @@
 	return theMVHDAtom;
 }
 
-uint32 MOVFileReader::getMovieTimeScale()
+
+void
+MOVFileReader::BuildSuperIndex()
 {
+	AtomBase *aAtomBase;
+
+	for (uint32 stream=0;stream&lt;getStreamCount();stream++) {
+		aAtomBase = GetChildAtom(uint32('trak'),stream);
+		if (aAtomBase) {
+			TRAKAtom *aTrakAtom = dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase);
+			for (uint32 chunkid=1;chunkid&lt;=aTrakAtom-&gt;getTotalChunks();chunkid++) {
+				theChunkSuperIndex.AddChunkIndex(stream,chunkid,aTrakAtom-&gt;getOffsetForChunk(chunkid));
+			}
+		}
+	}
+
+	// Add end of file to index
+	aAtomBase = GetChildAtom(uint32('mdat'),0);
+	if (aAtomBase) {
+		MDATAtom *aMdatAtom = dynamic_cast&lt;MDATAtom *&gt;(aAtomBase);
+		theChunkSuperIndex.AddChunkIndex(0,0,aMdatAtom-&gt;getEOF());
+	}
+}
+
+
+uint32
+MOVFileReader::getMovieTimeScale()
+{
 	return getMVHDAtom()-&gt;getTimeScale();
 }
 
-bigtime_t	MOVFileReader::getMovieDuration()
+bigtime_t
+MOVFileReader::getMovieDuration()
 {
-	return ((bigtime_t(getMVHDAtom()-&gt;getDuration()) * 1000000L) / getMovieTimeScale());
+	return bigtime_t((getMVHDAtom()-&gt;getDuration() * 1000000.0) / getMovieTimeScale());
 }
 
-uint32	MOVFileReader::getStreamCount()
+uint32
+MOVFileReader::getStreamCount()
 {
 	// count the number of tracks in the file
-	return (CountChildAtoms(uint32('trak')));
+	return CountChildAtoms(uint32('trak'));
 }
 
-bigtime_t	MOVFileReader::getVideoDuration(uint32 stream_index)
+bigtime_t
+MOVFileReader::getVideoDuration(uint32 streamIndex)
 {
-AtomBase *aAtomBase;
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
 
-	aAtomBase = GetChildAtom(uint32('trak'),stream_index);
-	
-	if ((aAtomBase) &amp;&amp; (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo())) {
-		return (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;Duration(1));
-	}
-	
+	if (aAtomBase &amp;&amp; dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo())
+		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;Duration(1);
+
 	return 0;
 }
 
-bigtime_t	MOVFileReader::getAudioDuration(uint32 stream_index)
+bigtime_t
+MOVFileReader::getAudioDuration(uint32 streamIndex)
 {
-AtomBase *aAtomBase;
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
 
-	aAtomBase = GetChildAtom(uint32('trak'),stream_index);
-	
-	if ((aAtomBase) &amp;&amp; (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio())) {
-		return (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;Duration(1));
-	}
-	
+	if (aAtomBase &amp;&amp; dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio())
+		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;Duration(1);
+
 	return 0;
 }
 
-bigtime_t	MOVFileReader::getMaxDuration()
+bigtime_t
+MOVFileReader::getMaxDuration()
 {
-AtomBase *aAtomBase;
-int32	video_index,audio_index;
-	video_index = -1;
-	audio_index = -1;
+	AtomBase *aAtomBase;
+	int32 videoIndex = -1;
+	int32 audioIndex = -1;
 
 	// find the active video and audio tracks
-	for (uint32 i=0;i&lt;getStreamCount();i++) {
-		aAtomBase = GetChildAtom(uint32('trak'),i);
-		
+	for (uint32 i = 0; i &lt; getStreamCount(); i++) {
+		aAtomBase = GetChildAtom(uint32('trak'), i);
+
 		if ((aAtomBase) &amp;&amp; (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsActive())) {
 			if (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio()) {
-				audio_index = int32(i);
+				audioIndex = int32(i);
 			}
 			if (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo()) {
-				video_index = int32(i);
+				videoIndex = int32(i);
 			}
 		}
 	}
 
-	if ((video_index &gt;= 0) &amp;&amp; (audio_index &gt;= 0)) {
-		return MAX(getVideoDuration(video_index),getAudioDuration(audio_index));
+	if (videoIndex &gt;= 0 &amp;&amp; audioIndex &gt;= 0) {
+		return max_c(getVideoDuration(videoIndex),
+			getAudioDuration(audioIndex));
 	}
-	if ((video_index &lt; 0) &amp;&amp; (audio_index &gt;= 0)) {
-		return getAudioDuration(audio_index);
+	if (videoIndex &lt; 0 &amp;&amp; audioIndex &gt;= 0) {
+		return getAudioDuration(audioIndex);
 	}
-	if ((video_index &gt;= 0) &amp;&amp; (audio_index &lt; 0)) {
-		return getVideoDuration(video_index);
+	if (videoIndex &gt;= 0 &amp;&amp; audioIndex &lt; 0) {
+		return getVideoDuration(videoIndex);
 	}
-	
+
 	return 0;
 }
 
-uint32	MOVFileReader::getVideoFrameCount(uint32 stream_index)
+uint32
+MOVFileReader::getFrameCount(uint32 streamIndex)
 {
-AtomBase *aAtomBase;
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
 
-	aAtomBase = GetChildAtom(uint32('trak'),stream_index);
-	
-	if ((aAtomBase) &amp;&amp; (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo())) {
-
+	if (aAtomBase) {
 		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;FrameCount();
 	}
-	
+
 	return 1;
 }
 
-uint32	MOVFileReader::getAudioFrameCount(uint32 stream_index)
+uint32
+MOVFileReader::getAudioChunkCount(uint32 streamIndex)
 {
-	if (IsAudio(stream_index)) {
-		return uint32(((getAudioDuration(stream_index) * AudioFormat(stream_index)-&gt;SampleRate) / 1000000L) + 0.5);
-	}
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
+
+	if (aAtomBase &amp;&amp; dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio())
+		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;getTotalChunks();
 	
 	return 0;
 }
 
-bool	MOVFileReader::IsVideo(uint32 stream_index)
+bool	
+MOVFileReader::IsVideo(uint32 streamIndex)
 {
-	// Look for a trak with a vmhd atom
+	// Look for a 'trak' with a vmhd atom
 
-	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),stream_index);
-	
-	if (aAtomBase) {
-		return (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo());
-	}
-	
-	// No trak
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
+	if (aAtomBase)
+		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsVideo();
+
+	// No track
 	return false;
 }
 
-bool	MOVFileReader::IsAudio(uint32 stream_index)
+bool
+MOVFileReader::IsAudio(uint32 streamIndex)
 {
-	// Look for a trak with a smhd atom
+	// Look for a 'trak' with a smhd atom
 
-	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),stream_index);
-	
-	if (aAtomBase) {
-		return (dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio());
-	}
-	
-	// No trak
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
+
+	if (aAtomBase)
+		return dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase)-&gt;IsAudio();
+
+	// No track
 	return false;
 }
 
-uint32	MOVFileReader::getFirstFrameInChunk(uint32 stream_index, uint32 pChunkID)
+uint32
+MOVFileReader::getFirstFrameInChunk(uint32 streamIndex, uint32 pChunkID)
 {
 	// Find Track
-	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),stream_index);
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'), streamIndex);
 	if (aAtomBase) {
 		TRAKAtom *aTrakAtom = dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase);
-		
+
 		return aTrakAtom-&gt;getFirstSampleInChunk(pChunkID);
 	}
-	
+
 	return 0;
 }
 
-uint32	MOVFileReader::getNoFramesInChunk(uint32 stream_index, uint32 pFrameNo)
+uint32
+MOVFileReader::getNoFramesInChunk(uint32 streamIndex, uint32 pFrameNo)
 {
 	// Find Track
-	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),stream_index);
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),streamIndex);
 	if (aAtomBase) {
 		TRAKAtom *aTrakAtom = dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase);
 		uint32 ChunkNo = 1;
 
-		if (IsAudio(stream_index)) {
-			ChunkNo = pFrameNo;			
-		}
-		
-		if (IsVideo(stream_index)) {
-			uint32 SampleNo = aTrakAtom-&gt;getSampleForFrame(pFrameNo);
+		uint32 SampleNo = aTrakAtom-&gt;getSampleForFrame(pFrameNo);
 
-			uint32 OffsetInChunk;
-			ChunkNo = aTrakAtom-&gt;getChunkForSample(SampleNo, &amp;OffsetInChunk);
-		}
+		uint32 OffsetInChunk;
+		ChunkNo = aTrakAtom-&gt;getChunkForSample(SampleNo, &amp;OffsetInChunk);
 
 		return aTrakAtom-&gt;getNoSamplesInChunk(ChunkNo);
 	}
@@ -301,78 +333,54 @@
 	return 0;
 }
 
-uint64	MOVFileReader::getOffsetForFrame(uint32 stream_index, uint32 pFrameNo)
+uint64
+MOVFileReader::getOffsetForFrame(uint32 streamIndex, uint32 pFrameNo)
 {
 	// Find Track
-	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),stream_index);
+	AtomBase *aAtomBase = GetChildAtom(uint32('trak'),streamIndex);
 	if (aAtomBase) {
 		TRAKAtom *aTrakAtom = dynamic_cast&lt;TRAKAtom *&gt;(aAtomBase);
 
-		if (IsAudio(stream_index)) {
-			// FrameNo is really chunk No for audio
-			uint32 ChunkNo = pFrameNo;
-
+		if (pFrameNo &lt; aTrakAtom-&gt;FrameCount()) {
+			// Get time for Frame
+			bigtime_t Time = aTrakAtom-&gt;getTimeForFrame(pFrameNo);
+			
+			// Get Sample for Time
+			uint32 SampleNo = aTrakAtom-&gt;getSampleForTime(Time);
+			
+			// Get Chunk For Sample and the offset for the frame within that chunk
+			uint32 OffsetInChunk;
+			uint32 ChunkNo = aTrakAtom-&gt;getChunkForSample(SampleNo, &amp;OffsetInChunk);
 			// Get Offset For Chunk
-			return aTrakAtom-&gt;getOffsetForChunk(ChunkNo);
-		}
+			uint64 OffsetNo = aTrakAtom-&gt;getOffsetForChunk(ChunkNo);
 
-		if (IsVideo(stream_index)) {
-
-			if (pFrameNo &lt; aTrakAtom-&gt;FrameCount()) {
-				// Get Sample for Frame
-				uint32 SampleNo = aTrakAtom-&gt;getSampleForFrame(pFrameNo);
-				// Get Chunk For Sample and the offset for the frame within that chunk
-				uint32 OffsetInChunk;
-				uint32 ChunkNo = aTrakAtom-&gt;getChunkForSample(SampleNo, &amp;OffsetInChunk);
-				// Get Offset For Chunk
-				uint64 OffsetNo = aTrakAtom-&gt;getOffsetForChunk(ChunkNo);
-
-				if (ChunkNo != 0) {
-					uint32 SampleSize;
-					// Adjust the Offset for the Offset in the chunk
-					if (aTrakAtom-&gt;IsSingleSampleSize()) {
-						SampleSize = aTrakAtom-&gt;getSizeForSample(SampleNo);
-						OffsetNo = OffsetNo + (OffsetInChunk * SampleSize);
-					} else {
-						// This is bad news performance wise
-						for (uint32 i=1;i&lt;=OffsetInChunk;i++) {
-							SampleSize = aTrakAtom-&gt;getSizeForSample(SampleNo-i);
-							OffsetNo = OffsetNo + SampleSize;
-						}
+			if (ChunkNo != 0) {
+				uint32 SizeForSample;
+				// Adjust the Offset for the Offset in the chunk
+				if (aTrakAtom-&gt;IsSingleSampleSize()) {
+					SizeForSample = aTrakAtom-&gt;getSizeForSample(SampleNo);
+					OffsetNo = OffsetNo + (OffsetInChunk * SizeForSample);
+				} else {
+					// This is bad news performance wise
+					for (uint32 i=1;i&lt;=OffsetInChunk;i++) {
+						SizeForSample = aTrakAtom-&gt;getSizeForSample(SampleNo-i);
+						OffsetNo = OffsetNo + SizeForSample;
 					}
 				}
+			}
 		
-				return OffsetNo;

[... truncated: 1912 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="016318.html">[Haiku-commits] r30497 - in	haiku/trunk/src/add-ons/media/plugins/asf_reader: . libasf
</A></li>
	<LI>Next message: <A HREF="016320.html">[Haiku-commits] r30498 - in haiku/trunk/src/add-ons/media/plugins: . avcodec avcodec/libavcodec avcodec/libavcodec/x86	avcodec/libavutil avcodec/libswscale mov_reader	mov_reader/libMOV mp4_reader/libMP4 wav_reader
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#16319">[ date ]</a>
              <a href="thread.html#16319">[ thread ]</a>
              <a href="subject.html#16319">[ subject ]</a>
              <a href="author.html#16319">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
