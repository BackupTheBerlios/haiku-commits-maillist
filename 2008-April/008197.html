<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r25177 - in haiku/trunk/src/kits: game mail media	shared storage translation
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25177%20-%20in%20haiku/trunk/src/kits%3A%20game%20mail%20media%0A%09shared%20storage%20translation&In-Reply-To=%3C200804261216.m3QCGtng020706%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="008196.html">
   <LINK REL="Next"  HREF="008206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r25177 - in haiku/trunk/src/kits: game mail media	shared storage translation</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r25177%20-%20in%20haiku/trunk/src/kits%3A%20game%20mail%20media%0A%09shared%20storage%20translation&In-Reply-To=%3C200804261216.m3QCGtng020706%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r25177 - in haiku/trunk/src/kits: game mail media	shared storage translation">korli at mail.berlios.de
       </A><BR>
    <I>Sat Apr 26 14:16:55 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="008196.html">[Haiku-commits] r25176 - in haiku/trunk/src/tests/add-ons/kernel/file_systems: . beserved beserved/AuthLib beserved/BeManager beserved/BeSure beserved/FileSharing beserved/FileSharing-Windows beserved/FileSharing-Windows/res beserved/Menus beserved/MyNetwork beserved/MyNetwork/DOC beserved/bt_fs beserved/bt_fs/backups beserved/bt_fs/ksocket_v3 beserved/bt_fs/ksocket_v3/ksocketd beserved/bt_fs/ksocket_v3/libksocket beserved/documentation beserved/documentation/images beserved/lshosts beserved/mounthost beserved/server beserved/server-1.2.6 beserved/server-Windows beserved/transport
</A></li>
        <LI>Next message: <A HREF="008206.html">[Haiku-commits] r25178 - haiku/trunk/src/preferences/keymap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8197">[ date ]</a>
              <a href="thread.html#8197">[ thread ]</a>
              <a href="subject.html#8197">[ subject ]</a>
              <a href="author.html#8197">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2008-04-26 14:16:53 +0200 (Sat, 26 Apr 2008)
New Revision: 25177
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=25177&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=25177&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/game/FileGameSound.cpp
   haiku/trunk/src/kits/game/GameProducer.cpp
   haiku/trunk/src/kits/game/GameSoundBuffer.cpp
   haiku/trunk/src/kits/game/GameSoundDevice.cpp
   haiku/trunk/src/kits/mail/NodeMessage.cpp
   haiku/trunk/src/kits/media/MediaFiles.cpp
   haiku/trunk/src/kits/media/ParameterWeb.cpp
   haiku/trunk/src/kits/shared/CommandPipe.cpp
   haiku/trunk/src/kits/storage/AddOnMonitorHandler.cpp
   haiku/trunk/src/kits/translation/BitmapStream.cpp
Log:
style cleanup


Modified: haiku/trunk/src/kits/game/FileGameSound.cpp
===================================================================
--- haiku/trunk/src/kits/game/FileGameSound.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/game/FileGameSound.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -33,13 +33,11 @@
 {
 	int32 samples = *bytes / sizeof(int16);
 	
-	for(int32 byte = 0; byte &lt; samples; byte++)
-	{
+	for (int32 byte = 0; byte &lt; samples; byte++) {
 		float gain = *ramp-&gt;value;
 		data[byte] = uint8(float(buffer[byte]) * gain);
 				
-		if (ChangeRamp(ramp))
-		{
+		if (ChangeRamp(ramp)) {
 			*bytes = byte * sizeof(int16);
 			return true;
 		}
@@ -52,13 +50,11 @@
 {
 	int32 samples = *bytes / sizeof(int16);
 	
-	for(int32 byte = 0; byte &lt; samples; byte++)
-	{
+	for (int32 byte = 0; byte &lt; samples; byte++) {
 		float gain = *ramp-&gt;value;
 		data[byte] = int16(float(buffer[byte]) * gain);
 				
-		if (ChangeRamp(ramp))
-		{
+		if (ChangeRamp(ramp)) {
 			*bytes = byte * sizeof(int16);
 			return true;
 		}
@@ -72,13 +68,11 @@
 	size_t byte = 0;
 	bool bytesAreReady = (*bytes &gt; 0);
 
-	while(bytesAreReady)
-	{
+	while (bytesAreReady) {
 		float gain = *ramp-&gt;value;
 		data[byte] = int32(float(buffer[byte]) * gain);
 		
-		if (ChangeRamp(ramp))
-		{
+		if (ChangeRamp(ramp)) {
 			*bytes = byte;
 			return true;
 		}
@@ -95,13 +89,11 @@
 	size_t byte = 0;
 	bool bytesAreReady = (*bytes &gt; 0);
 
-	while(bytesAreReady)
-	{
+	while (bytesAreReady) {
 		float gain = *ramp-&gt;value;
 		data[byte] = buffer[byte] * gain;
 		
-		if (ChangeRamp(ramp))
-		{
+		if (ChangeRamp(ramp)) {
 			*bytes = byte;
 			return true;
 		}
@@ -145,8 +137,7 @@
  		fPaused(false),
  		fPauseGain(1.0)
 {
-	if (InitCheck() == B_OK)
-	{
+	if (InitCheck() == B_OK) {
 		entry_ref node;
 	
 		if (get_ref_for_path(file, &amp;node) != B_OK)
@@ -159,10 +150,10 @@
 
 BFileGameSound::~BFileGameSound()
 {
-	if (fReadThread &gt;= 0) kill_thread(fReadThread);
+	if (fReadThread &gt;= 0) 
+		kill_thread(fReadThread);
 	
-	if (fAudioStream)
-	{	
+	if (fAudioStream) {
 		if (fAudioStream-&gt;stream) 
 			fAudioStream-&gt;file-&gt;ReleaseTrack(fAudioStream-&gt;stream);
 	
@@ -307,16 +298,14 @@
 BFileGameSound::SetPaused(bool isPaused,
 						  bigtime_t rampTime)
 {
-	if (fPaused != isPaused)
-	{
+	if (fPaused != isPaused) {
 		Lock();
 	
 		// Clear any old ramping	
 		delete fPausing;
 		fPausing = NULL;
 	
-		if (rampTime &gt; 100000) 
-		{
+		if (rampTime &gt; 100000) {
 			// Setup for ramping
 			if (isPaused)
 				fPausing = InitRamp(&amp;fPauseGain, 0.0, Format().frame_rate, rampTime);
@@ -335,9 +324,11 @@
 int32
 BFileGameSound::IsPaused()
 {
-	if (fPausing) return B_PAUSE_IN_PROGRESS;
+	if (fPausing)
+		return B_PAUSE_IN_PROGRESS;
 	
-	if (fPaused) return B_PAUSED;
+	if (fPaused)
+		return B_PAUSED;
 	
 	return B_NOT_PAUSED;
 }
@@ -403,7 +394,6 @@
 bool
 BFileGameSound::Load()
 {
-	
 	if (fPlayPosition != 0) {
 		if (fBufferSize &gt; fPlayPosition)
 			memcpy(fBuffer, fBuffer + fPlayPosition, fBufferSize - fPlayPosition);

Modified: haiku/trunk/src/kits/game/GameProducer.cpp
===================================================================
--- haiku/trunk/src/kits/game/GameProducer.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/game/GameProducer.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -217,59 +217,55 @@
 	// If something earlier failed, Connect() might still be called, but with a non-zero
 	// error code.  When that happens we simply unreserve the connection and do
 	// nothing else.
-	if (error)
-	{
+	if (error) {
 		fOutput.destination = media_destination::null;
 		fOutput.format = fPreferredFormat;
+		return;
 	}
-	else
-	{
-		// Okay, the connection has been confirmed.  Record the destination and format
-		// that we agreed on, and report our connection name again.
-		fOutput.destination = destination;
-		fOutput.format = format;
-		strncpy(io_name, fOutput.name, B_MEDIA_NAME_LENGTH);
 
-		// Now that we're connected, we can determine our downstream latency.
-		// Do so, then make sure we get our events early enough.
-		media_node_id id;
-		FindLatencyFor(fOutput.destination, &amp;fLatency, &amp;id);
+	// Okay, the connection has been confirmed.  Record the destination and format
+	// that we agreed on, and report our connection name again.
+	fOutput.destination = destination;
+	fOutput.format = format;
+	strncpy(io_name, fOutput.name, B_MEDIA_NAME_LENGTH);
 
-		// Use a dry run to see how long it takes me to fill a buffer of data
+	// Now that we're connected, we can determine our downstream latency.
+	// Do so, then make sure we get our events early enough.
+	media_node_id id;
+	FindLatencyFor(fOutput.destination, &amp;fLatency, &amp;id);
+
+	// Use a dry run to see how long it takes me to fill a buffer of data
 		
-		// The first step to setup the buffer
-		bigtime_t start, produceLatency;
-		int32 frames = int32(fOutput.format.u.raw_audio.buffer_size / fFrameSize);
-		float* data = new float[frames * 2];
+	// The first step to setup the buffer
+	bigtime_t start, produceLatency;
+	int32 frames = int32(fOutput.format.u.raw_audio.buffer_size / fFrameSize);
+	float* data = new float[frames * 2];
 	
-		// Second, fill the buffer
-		start = ::system_time();
-		for(int32 i = 0; i &lt; frames; i++)
-		{
-			data[i*2] = 0.8 * float(i/frames);
-			data[i*2+1] = 0.8 * float(i/frames);
-		}
-		produceLatency = ::system_time();
+	// Second, fill the buffer
+	start = ::system_time();
+	for (int32 i = 0; i &lt; frames; i++) {
+		data[i*2] = 0.8 * float(i/frames);
+		data[i*2+1] = 0.8 * float(i/frames);
+	}
+	produceLatency = ::system_time();
 		
-		// Thid, calculate the latency
-		fInternalLatency = produceLatency - start;
-		SetEventLatency(fLatency + fInternalLatency);
+	// Third, calculate the latency
+	fInternalLatency = produceLatency - start;
+	SetEventLatency(fLatency + fInternalLatency);
 			
-		// Finaily, clean up
-		delete [] data;
+	// Finaily, clean up
+	delete [] data;
 		
-		// reset our buffer duration, etc. to avoid later calculations
-		bigtime_t duration = bigtime_t(1000000) * frames / bigtime_t(fOutput.format.u.raw_audio.frame_rate);
-		SetBufferDuration(duration);
+	// reset our buffer duration, etc. to avoid later calculations
+	bigtime_t duration = bigtime_t(1000000) * frames / bigtime_t(fOutput.format.u.raw_audio.frame_rate);
+	SetBufferDuration(duration);
 
-		// Set up the buffer group for our connection, as long as nobody handed us a
-		// buffer group (via SetBufferGroup()) prior to this.  
-		if (!fBufferGroup)
-		{
-			size_t size = fOutput.format.u.raw_audio.buffer_size;
-			int32 count = int32(fLatency / BufferDuration() + 2);
-			fBufferGroup = new BBufferGroup(size, count);
-		}
+	// Set up the buffer group for our connection, as long as nobody handed us a
+	// buffer group (via SetBufferGroup()) prior to this.  
+	if (!fBufferGroup) {
+		size_t size = fOutput.format.u.raw_audio.buffer_size;
+		int32 count = int32(fLatency / BufferDuration() + 2);
+		fBufferGroup = new BBufferGroup(size, count);
 	}
 }
 
@@ -278,8 +274,7 @@
 GameProducer::Disconnect(const media_source&amp; what, const media_destination&amp; where)
 {
 	// Make sure that our connection is the one being disconnected
-	if ((where == fOutput.destination) &amp;&amp; (what == fOutput.source))
-	{
+	if ((where == fOutput.destination) &amp;&amp; (what == fOutput.source)) {
 		fOutput.destination = media_destination::null;
 		fOutput.format = fPreferredFormat;
 		delete fBufferGroup;
@@ -300,10 +295,12 @@
 GameProducer::SetBufferGroup(const media_source&amp; for_source, BBufferGroup* newGroup)
 {
 	// verify that we didn't get bogus arguments before we proceed
-	if (for_source != fOutput.source) return B_MEDIA_BAD_SOURCE;
+	if (for_source != fOutput.source)
+		return B_MEDIA_BAD_SOURCE;
 
 	// Are we being passed the buffer group we're already using?
-	if (newGroup == fBufferGroup) return B_OK;
+	if (newGroup == fBufferGroup)
+		return B_OK;
 
 	// Ahh, someone wants us to use a different buffer group.  At this point we delete
 	// the one we are using and use the specified one instead.  If the specified group is
@@ -312,13 +309,10 @@
 	// *before* deleting the buffer group, otherwise we'll deadlock waiting for that
 	// buffer to be recycled!
 	delete fBufferGroup;		// waits for all buffers to recycle
-	if (newGroup != NULL)
-	{
+	if (newGroup != NULL) {
 		// we were given a valid group; just use that one from now on
 		fBufferGroup = newGroup;
-	}
-	else
-	{
+	} else {
 		// we were passed a NULL group pointer; that means we construct
 		// our own buffer group to use from now on
 		size_t size = fOutput.format.u.raw_audio.buffer_size;
@@ -344,17 +338,13 @@
 {
 	// If we're late, we need to catch up.  Respond in a manner appropriate to our
 	// current run mode.
-	if (what == fOutput.source)
-	{
-		if (RunMode() == B_RECORDING)
-		{
+	if (what == fOutput.source) {
+		if (RunMode() == B_RECORDING) {
 			// A hardware capture node can't adjust; it simply emits buffers at
 			// appropriate points.  We (partially) simulate this by not adjusting
 			// our behavior upon receiving late notices -- after all, the hardware
 			// can't choose to capture &quot;sooner&quot;....
-		}
-		else if (RunMode() == B_INCREASE_LATENCY)
-		{
+		} else if (RunMode() == B_INCREASE_LATENCY) {
 			// We're late, and our run mode dictates that we try to produce buffers
 			// earlier in order to catch up.  This argues that the downstream nodes are
 			// not properly reporting their latency, but there's not much we can do about
@@ -362,9 +352,7 @@
 			// compensate.
 			fInternalLatency += how_much;
 			SetEventLatency(fLatency + fInternalLatency);
-		}
-		else
-		{
+		} else {
 			// The other run modes dictate various strategies for sacrificing data quality
 			// in the interests of timely data delivery.  The way *we* do this is to skip
 			// a buffer, which catches us up in time by one buffer duration.
@@ -382,8 +370,7 @@
 	// buffers earlier (or later) than we were previously.  Make sure that the
 	// connection that changed is ours, and adjust to the new downstream
 	// latency if so.
-	if ((source == fOutput.source) &amp;&amp; (destination == fOutput.destination))
-	{
+	if ((source == fOutput.source) &amp;&amp; (destination == fOutput.destination)) {
 		fLatency = new_latency;
 		SetEventLatency(fLatency + fInternalLatency);
 	}
@@ -435,8 +422,7 @@
 {
 	// We don't support offline run mode, so broadcast an error if we're set to
 	// B_OFFLINE.  Unfortunately, we can't actually reject the mode change...
-	if (B_OFFLINE == mode)
-	{
+	if (B_OFFLINE == mode) {
 		ReportError(B_NODE_FAILED_SET_RUN_MODE);
 	}
 }
@@ -450,8 +436,7 @@
 	{
 	case BTimedEventQueue::B_START:
 		// don't do anything if we're already running
-		if (RunState() != B_STARTED)
-		{
+		if (RunState() != B_STARTED) {
 			// We are going to start sending buffers so setup the needed bookkeeping
 			fFramesSent = 0;
 			fStartTime = event-&gt;event_time;
@@ -476,17 +461,16 @@
 	case BTimedEventQueue::B_HANDLE_BUFFER:
 		{
 			// make sure we're both started *and* connected before delivering a buffer
-			if ((RunState() == BMediaEventLooper::B_STARTED) &amp;&amp; (fOutput.destination != media_destination::null))
-			{
+			if ((RunState() == BMediaEventLooper::B_STARTED) 
+				&amp;&amp; (fOutput.destination != media_destination::null)) {
 				// Get the next buffer of data
 				BBuffer* buffer = FillNextBuffer(event-&gt;event_time);
-				if (buffer)
-				{
+				if (buffer) {
 					// send the buffer downstream if and only if output is enabled
 					status_t err = B_ERROR;
-					if (fOutputEnabled) err = SendBuffer(buffer, fOutput.destination);
-					if (err)
-					{
+					if (fOutputEnabled)
+						err = SendBuffer(buffer, fOutput.destination);
+					if (err) {
 						// we need to recycle the buffer ourselves if output is disabled or
 						// if the call to SendBuffer() fails
 						buffer-&gt;Recycle();
@@ -511,8 +495,6 @@
 }
 
 
-// --------------------------------
-//  GameProducer		
 BBuffer* 
 GameProducer::FillNextBuffer(bigtime_t event_time)
 {	
@@ -521,7 +503,8 @@
 
 	// if we fail to get a buffer (for example, if the request times out), we skip this
 	// buffer and go on to the next, to avoid locking up the control thread
-	if (!buf) return NULL;
+	if (!buf) 
+		return NULL;
 
 	// we need to discribe the buffer
 	int64 frames = int64(fOutput.format.u.raw_audio.buffer_size / fFrameSize);
@@ -537,15 +520,12 @@
 	hdr-&gt;time_source = TimeSource()-&gt;ID();
 	
 	bigtime_t stamp;
-	if (RunMode() == B_RECORDING)
-	{
+	if (RunMode() == B_RECORDING) {
 		// In B_RECORDING mode, we stamp with the capture time.  We're not
 		// really a hardware capture node, but we simulate it by using the (precalculated)
 		// time at which this buffer &quot;should&quot; have been created.
 		stamp = event_time;
-	}
-	else
-	{
+	} else {
 		// okay, we're in one of the &quot;live&quot; performance run modes.  in these modes, we
 		// stamp the buffer with the time at which the buffer should be rendered to the
 		// output, not with the capture time.  fStartTime is the cached value of the
@@ -559,4 +539,3 @@
 	return buf;
 }
 
-

Modified: haiku/trunk/src/kits/game/GameSoundBuffer.cpp
===================================================================
--- haiku/trunk/src/kits/game/GameSoundBuffer.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/game/GameSoundBuffer.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -93,8 +93,7 @@
 {
 	BMediaRoster* r = BMediaRoster::Roster();
 	
-	if (fIsConnected)
-	{
+	if (fIsConnected) {
 		// Ordinarily we'd stop *all* of the nodes in the chain at this point.  However,
 		// one of the nodes is the System Mixer, and stopping the Mixer is a Bad Idea (tm).
 		// So, we just disconnect from it, and release our references to the nodes that
@@ -172,24 +171,21 @@
 	if (pan &lt; -1.0 || pan &gt; 1.0)
 		return B_BAD_VALUE;
 	
-	if (fPanRamp) delete fPanRamp;
+	if (fPanRamp) 
+		delete fPanRamp;
 	
-	if (duration &lt; 100000)
-	{
+	if (duration &lt; 100000) {
 		fPan = pan;
 		
-		if (fPan &lt; 0.0)
-		{
+		if (fPan &lt; 0.0) {
 			fPanLeft = 1.0;
 			fPanRight = 1.0 + fPan;
-		}
-		else
-		{
+		} else {
 			fPanRight = 1.0;
 			fPanLeft = 1.0 - fPan;
 		}	
-	}	
-	else fPanRamp = InitRamp(&amp;fPan, pan, fFormat.frame_rate, duration);
+	} else 
+		fPanRamp = InitRamp(&amp;fPan, pan, fFormat.frame_rate, duration);
 		
 	return B_OK;
 }	
@@ -199,18 +195,18 @@
 GameSoundBuffer::GetAttributes(gs_attribute * attributes,
 							   size_t attributeCount)
 {
-	for(size_t i = 0; i &lt; attributeCount; i++)
-	{
-		switch(attributes[i].attribute)
-		{
+	for (size_t i = 0; i &lt; attributeCount; i++) {
+		switch(attributes[i].attribute) {
 			case B_GS_GAIN:
 				attributes[i].value = fGain;
-				if (fGainRamp) attributes[i].duration = fGainRamp-&gt;duration;
+				if (fGainRamp) 
+					attributes[i].duration = fGainRamp-&gt;duration;
 				break;
 			
 			case B_GS_PAN:
 				attributes[i].value = fPan;
-				if (fPanRamp) attributes[i].duration = fGainRamp-&gt;duration;
+				if (fPanRamp) 
+					attributes[i].duration = fGainRamp-&gt;duration;
 			
 			case B_GS_LOOPING:
 				attributes[i].value = (fLooping) ? -1.0 : 0.0;
@@ -232,10 +228,8 @@
 {
 	status_t error = B_OK;
 
-	for(size_t i = 0; i &lt; attributeCount; i++)
-	{	
-		switch(attributes[i].attribute)
-		{
+	for (size_t i = 0; i &lt; attributeCount; i++) {
+		switch(attributes[i].attribute) {
 			case B_GS_GAIN:
 				error = SetGain(attributes[i].value, attributes[i].duration);
 				break;
@@ -264,12 +258,10 @@
 			
 	FillBuffer(buffer, frames);
 	
-	switch(fFormat.format)
-	{
+	switch(fFormat.format) {
 		case gs_audio_format::B_GS_U8:
 		{
-			for(int64 i = 0; i &lt; frames; i++)
-			{
+			for (int64 i = 0; i &lt; frames; i++) {
 				ApplyMod((uint8*)data, (uint8*)buffer, i, fGain, pan);
 				UpdateMods();
 			}
@@ -279,8 +271,7 @@
 		
 		case gs_audio_format::B_GS_S16:
 		{		
-			for(int64 i = 0; i &lt; frames; i++)
-			{
+			for (int64 i = 0; i &lt; frames; i++) {
 				ApplyMod((int16*)data, (int16*)buffer, i, fGain, pan);
 				UpdateMods();
 			}
@@ -290,8 +281,7 @@
 		
 		case gs_audio_format::B_GS_S32:
 		{
-			for(int64 i = 0; i &lt; frames; i++)
-			{
+			for (int64 i = 0; i &lt; frames; i++) {
 				ApplyMod((int32*)data, (int32*)buffer, i, fGain, pan);
 				UpdateMods();
 			}
@@ -301,8 +291,7 @@
  		
  		case gs_audio_format::B_GS_F:
  		{
-			for(int64 i = 0; i &lt; frames; i++)
-			{
+			for (int64 i = 0; i &lt; frames; i++) {
 				ApplyMod((float*)data, (float*)buffer, i, fGain, pan);
 				UpdateMods();
 			}
@@ -320,32 +309,23 @@
 GameSoundBuffer::UpdateMods()
 {		
 	// adjust the gain if needed		
-	if (fGainRamp)
-	{
-		if (ChangeRamp(fGainRamp))
-		{
+	if (fGainRamp) {
+		if (ChangeRamp(fGainRamp)) {
 			delete fGainRamp;
 			fGainRamp = NULL;
 		}
 	}
 		
 	// adjust the ramp if needed
-	if (fPanRamp)
-	{
-		if (ChangeRamp(fPanRamp))
-		{
+	if (fPanRamp) {
+		if (ChangeRamp(fPanRamp)) {
 			delete fPanRamp;
 			fPanRamp = NULL;
-		}
-		else
-		{
-			if (fPan &lt; 0.0)
-			{
+		} else {
+			if (fPan &lt; 0.0) {
 				fPanLeft = 1.0;
 				fPanRight = 1.0 + fPan;
-			}
-			else
-			{
+			} else {
 				fPanRight = 1.0;
 				fPanLeft = 1.0 - fPan;
 			}
@@ -378,14 +358,16 @@
 	status_t err;
 	
 	err = r-&gt;RegisterNode(fNode);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	// make sure the Media Roster knows that we're using the node
 	r-&gt;GetNodeFor(fNode-&gt;Node().node, &amp;fConnection-&gt;producer);
 
 	// connect to the mixer
 	fConnection-&gt;consumer = *consumer;
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	// set the producer's time source to be the &quot;default&quot; time source, which
 	// the Mixer uses too.
@@ -397,17 +379,20 @@
 	media_output soundOutput;
 	int32 count = 1;
 	err = r-&gt;GetFreeOutputsFor(fConnection-&gt;producer, &amp;soundOutput, 1, &amp;count);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	count = 1;
 	err = r-&gt;GetFreeInputsFor(fConnection-&gt;consumer, &amp;mixerInput, 1, &amp;count);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 
 	// got the endpoints; now we connect it!
 	media_format format;
 	format.type = B_MEDIA_RAW_AUDIO;	
 	format.u.raw_audio = media_raw_audio_format::wildcard;
 	err = r-&gt;Connect(soundOutput.source, mixerInput.destination, &amp;format, &amp;soundOutput, &amp;mixerInput);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	// the inputs and outputs might have been reassigned during the
 	// nodes' negotiation of the Connect().  That's why we wait until
@@ -424,7 +409,8 @@
 status_t
 GameSoundBuffer::StartPlaying()
 {
-	if (fIsPlaying) return EALREADY;
+	if (fIsPlaying) 
+		return EALREADY;
 	
 	BMediaRoster* r = BMediaRoster::Roster();
 	BTimeSource* ts = r-&gt;MakeTimeSourceFor(fConnection-&gt;producer);
@@ -445,7 +431,8 @@
 status_t
 GameSoundBuffer::StopPlaying()
 {
-	if (!fIsPlaying) return EALREADY;
+	if (!fIsPlaying) 
+		return EALREADY;
 	
 	BMediaRoster* r = BMediaRoster::Roster();
 	r-&gt;StopNode(fConnection-&gt;producer, 0, true);		// synchronous stop
@@ -499,27 +486,22 @@
 	char * buffer = (char*)data;
 	size_t bytes = fFrameSize * frames;
 	
-	if (fPosition + bytes &gt;= fBufferSize)
-	{
-		if (fPosition &lt; fBufferSize)
-		{
+	if (fPosition + bytes &gt;= fBufferSize) {
+		if (fPosition &lt; fBufferSize) {
 			// copy the remaining frames
 			size_t remainder = fBufferSize - fPosition;
 			memcpy(buffer, &amp;fBuffer[fPosition], remainder);
 		
-			if (fLooping) 
-			{
+			if (fLooping) {
 				// restart the sound from the begging
 				memcpy(&amp;buffer[remainder], fBuffer, bytes - remainder);
 				fPosition = bytes - remainder;
-			}
-			else fPosition = fBufferSize;
-		}
-		else memset(data, 0, bytes);
+			} else
+				fPosition = fBufferSize;
+		} else
+			memset(data, 0, bytes);
 			// there is nothing left to play
-	}
-	else 
-	{
+	} else {
 		memcpy(buffer, &amp;fBuffer[fPosition], bytes);
 		fPosition += bytes;
 	}
@@ -549,3 +531,4 @@
 	size_t bytes = fFrameSize * frames;	
 	object-&gt;FillBuffer(buffer, bytes);
 }
+

Modified: haiku/trunk/src/kits/game/GameSoundDevice.cpp
===================================================================
--- haiku/trunk/src/kits/game/GameSoundDevice.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/game/GameSoundDevice.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -61,8 +61,7 @@
 {
 	deviceCount--;
 	
-	if (deviceCount &lt;= 0)
-	{
+	if (deviceCount &lt;= 0) {
 		delete theDevice;
 		theDevice = NULL;
 	}
@@ -79,7 +78,7 @@
 	fInitError = Connect();
 	
 	fSounds = new GameSoundBuffer*[kInitSoundCount];
-	for(int32 i = 0; i &lt; kInitSoundCount; i++)
+	for (int32 i = 0; i &lt; kInitSoundCount; i++)
 		fSounds[i] = NULL;	
 }
 
@@ -89,14 +88,13 @@
 	BMediaRoster* r = BMediaRoster::Roster();
 
 	// We need to stop all the sounds before we stop the mixer
-	for(int32 i = 0; i &lt; fSoundCount; i++)
-	{
-		if (fSounds[i]) fSounds[i]-&gt;StopPlaying();
+	for (int32 i = 0; i &lt; fSoundCount; i++) {
+		if (fSounds[i])
+			fSounds[i]-&gt;StopPlaying();
 		delete fSounds[i];
 	}
 	
-	if (fIsConnected)
-	{
+	if (fIsConnected) {
 		// stop the nodes if they are running
 		r-&gt;StopNode(fConnection-&gt;producer, 0, true);		// synchronous stop
 	
@@ -150,13 +148,13 @@
 								const void * data,
 								int64 frames)
 {
-	if (frames &lt;= 0 || !sound) return B_BAD_VALUE;
+	if (frames &lt;= 0 || !sound) 
+		return B_BAD_VALUE;
 	
 	status_t err = B_MEDIA_TOO_MANY_BUFFERS;	
 	int32 position = AllocateSound();
 	
-	if (position &gt;= 0)
-	{
+	if (position &gt;= 0) {
 		fSounds[position] = new SimpleSoundBuffer(format, data, frames);
 		err = fSounds[position]-&gt;Connect(&amp;fConnection-&gt;producer);
 	}	
@@ -171,13 +169,13 @@
 								const void * object,
 								const gs_audio_format * format)
 {
-	if (!object || !sound) return B_BAD_VALUE;
+	if (!object || !sound) 
+		return B_BAD_VALUE;
 	
 	status_t err = B_MEDIA_TOO_MANY_BUFFERS;	
 	int32 position = AllocateSound();
 	
-	if (position &gt;= 0)
-	{
+	if (position &gt;= 0) {
 		fSounds[position] = new StreamingSoundBuffer(format, object);
 		err = fSounds[position]-&gt;Connect(&amp;fConnection-&gt;producer);
 	}	
@@ -193,8 +191,7 @@
 	if (sound &lt;= 0)
 		return;
 
-	if (fSounds[sound-1])
-	{
+	if (fSounds[sound-1]) {
 		// We must stop playback befor destroying the sound or else
 		// we may recieve fatel errors.
 		fSounds[sound-1]-&gt;StopPlaying();
@@ -218,8 +215,8 @@
 	if (fSounds[sound-1]-&gt;Data()) {
 		data = malloc(format-&gt;buffer_size);
 		memcpy(data, fSounds[sound-1]-&gt;Data(), format-&gt;buffer_size);
-	}
-	else data = NULL;
+	} else
+		data = NULL;
 	
 	return B_OK;	
 }
@@ -270,7 +267,8 @@
 								gs_attribute * attributes,
 								size_t attributeCount)
 {
-	if (!fSounds[sound-1]) return B_ERROR;
+	if (!fSounds[sound-1]) 
+		return B_ERROR;
 		
 	return fSounds[sound-1]-&gt;GetAttributes(attributes, attributeCount); 
 }
@@ -281,7 +279,8 @@
 								gs_attribute * attributes,
 								size_t attributeCount)
 {
-	if (!fSounds[sound-1]) return B_ERROR;
+	if (!fSounds[sound-1]) 
+		return B_ERROR;
 	
 	return fSounds[sound-1]-&gt;SetAttributes(attributes, attributeCount);
 }				
@@ -297,29 +296,35 @@
 	dormant_node_info mixer_dormant_info;
 	int32 mixer_count = 1; // for now, we only care about the first  we find.
 	err = r-&gt;GetDormantNodes(&amp;mixer_dormant_info, &amp;mixer_count, 0, 0, 0, B_SYSTEM_MIXER, 0);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	//fMixer = new media_node;
 	err = r-&gt;InstantiateDormantNode(mixer_dormant_info, &amp;fConnection-&gt;producer);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	// retieve the system's audio mixer
 	err = r-&gt;GetAudioMixer(&amp;fConnection-&gt;consumer);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	int32 count = 1;
 	media_input mixerInput;
 	err = r-&gt;GetFreeInputsFor(fConnection-&gt;consumer, &amp;mixerInput, 1, &amp;count);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	count = 1;
 	media_output mixerOutput;
 	err = r-&gt;GetFreeOutputsFor(fConnection-&gt;producer, &amp;mixerOutput, 1, &amp;count);
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	media_format format(mixerOutput.format);
 	err = r-&gt;Connect(mixerOutput.source, mixerInput.destination, &amp;format, &amp;mixerOutput, &amp;mixerInput);
-	if (err != B_OK) return err;	
+	if (err != B_OK) 
+		return err;	
 	
 	// set the producer's time source to be the &quot;default&quot; time source, which
 	// the Mixer uses too.
@@ -329,13 +334,12 @@
 	// Start our mixer's time source if need be. Chances are, it won't need to be, 
 	// but if we forget to do this, our mixer might not do anything at all.
 	BTimeSource* mixerTimeSource = r-&gt;MakeTimeSourceFor(fConnection-&gt;producer);
-	if (! mixerTimeSource) return B_ERROR;
+	if (!mixerTimeSource) 
+		return B_ERROR;
 
-	if (!mixerTimeSource-&gt;IsRunning()) 
-	{
+	if (!mixerTimeSource-&gt;IsRunning()) {
 		status_t err = r-&gt;StartNode(mixerTimeSource-&gt;Node(), BTimeSource::RealTime());
-		if (err != B_OK) 
-		{
+		if (err != B_OK) {
 			mixerTimeSource-&gt;Release();
 			return err;
 		}
@@ -345,7 +349,8 @@
 	bigtime_t tpNow = mixerTimeSource-&gt;Now();
 	err = r-&gt;StartNode(fConnection-&gt;producer, tpNow + 10000);
 	mixerTimeSource-&gt;Release();
-	if (err != B_OK) return err;
+	if (err != B_OK) 
+		return err;
 	
 	// the inputs and outputs might have been reassigned during the
 	// nodes' negotiation of the Connect().  That's why we wait until
@@ -366,16 +371,16 @@
 int32
 BGameSoundDevice::AllocateSound()
 {
-	for(int32 i = 0; i &lt; fSoundCount; i++)
+	for (int32 i = 0; i &lt; fSoundCount; i++)
 		if (!fSounds[i])
 			return i;
 	
 	// we need to allocate new space for the sound
 	GameSoundBuffer ** sounds = new GameSoundBuffer*[fSoundCount + kGrowth];
-	for(int32 i = 0; i &lt; fSoundCount; i++)
+	for (int32 i = 0; i &lt; fSoundCount; i++)
 		sounds[i] = fSounds[i];
 		
-	for(int32 i	= fSoundCount; i &lt; fSoundCount + kGrowth; i++)
+	for (int32 i = fSoundCount; i &lt; fSoundCount + kGrowth; i++)
 		sounds[i] = NULL;
 	
 	// replace the old list	

Modified: haiku/trunk/src/kits/mail/NodeMessage.cpp
===================================================================
--- haiku/trunk/src/kits/mail/NodeMessage.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/mail/NodeMessage.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -27,10 +27,9 @@
 	ssize_t     bytes;
 	const void *data;
 	
-	for(int32 i = 0;
+	for (int32 i = 0;
 		m.GetInfo(B_ANY_TYPE, i, &amp;name, &amp;type) == 0;
-		i++)
-	{
+		i++) {
 		m.FindData (name,type,0,&amp;data,&amp;bytes);
 		n.WriteAttr(name,type,0, data, bytes);
 	}
@@ -45,8 +44,7 @@
 	char *buf = NULL;
 	
 	n.RewindAttrs();
-	while (n.GetNextAttrName(name)==B_OK)
-	{
+	while (n.GetNextAttrName(name) == B_OK) {
 		if (n.GetAttrInfo(name,&amp;info) != B_OK)
 			continue;
 

Modified: haiku/trunk/src/kits/media/MediaFiles.cpp
===================================================================
--- haiku/trunk/src/kits/media/MediaFiles.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/media/MediaFiles.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -37,7 +37,7 @@
 	server_rewindtypes_request request;
 	server_rewindtypes_reply reply;
 	
-	for(int32 i = 0; i &lt; m_types.CountItems(); i++)
+	for (int32 i = 0; i &lt; m_types.CountItems(); i++)
 		delete (BString*)m_types.ItemAt(i);
 		
 	m_types.MakeEmpty();
@@ -97,7 +97,7 @@
 	server_rewindrefs_request request;
 	server_rewindrefs_reply reply;
 	
-	for(int32 i = 0; i &lt; m_items.CountItems(); i++)
+	for (int32 i = 0; i &lt; m_items.CountItems(); i++)
 		delete (BString*)m_items.ItemAt(i);
 		
 	m_items.MakeEmpty();

Modified: haiku/trunk/src/kits/media/ParameterWeb.cpp
===================================================================
--- haiku/trunk/src/kits/media/ParameterWeb.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/media/ParameterWeb.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -344,7 +344,7 @@
 	CALLED();
 
 	if (mGroups != NULL) {
-		for(int32 i = mGroups-&gt;CountItems(); i-- &gt; 0;) {
+		for (int32 i = mGroups-&gt;CountItems(); i-- &gt; 0;) {
 			delete static_cast&lt;BParameterGroup *&gt;(mGroups-&gt;ItemAt(i));
 		}
 
@@ -1097,7 +1097,7 @@
 	//Clear all existing parameters/subgroups
 	int i;
 	if (mControls != NULL) {
-		for(i = 0; i &lt; mControls-&gt;CountItems(); i++) {
+		for (i = 0; i &lt; mControls-&gt;CountItems(); i++) {
 			BParameter *CurrentItem = static_cast&lt;BParameter *&gt;(mControls-&gt;ItemAt(i));
 			if (CurrentItem != NULL) {
 				delete CurrentItem;
@@ -2135,7 +2135,7 @@
 	ASSERT(mInputs != NULL);
 
 	int32 count = mInputs-&gt;CountItems();
-	for(int32 i = 0; i &lt; count; i++) {
+	for (int32 i = 0; i &lt; count; i++) {
 		BParameter *parameter = static_cast&lt;BParameter *&gt;(mInputs-&gt;ItemAt(i));
 		AddItem(i, parameter-&gt;Name());
 	}
@@ -2153,7 +2153,7 @@
 	ASSERT(mOutputs != NULL);
 
 	int32 count = mOutputs-&gt;CountItems();
-	for(int32 i = 0; i &lt; count; i++) {
+	for (int32 i = 0; i &lt; count; i++) {
 		BParameter *parameter = static_cast&lt;BParameter *&gt;(mOutputs-&gt;ItemAt(i));
 		AddItem(i, parameter-&gt;Name());
 	}
@@ -2174,7 +2174,7 @@
 	}
 	mValues-&gt;MakeEmpty();
 
-	for(int32 i = mSelections-&gt;CountItems(); i-- &gt; 0;) {
+	for (int32 i = mSelections-&gt;CountItems(); i-- &gt; 0;) {
 		free(static_cast&lt;char *&gt;(mSelections-&gt;ItemAt(i)));
 	}
 	mSelections-&gt;MakeEmpty();

Modified: haiku/trunk/src/kits/shared/CommandPipe.cpp
===================================================================
--- haiku/trunk/src/kits/shared/CommandPipe.cpp	2008-04-26 11:46:00 UTC (rev 25176)
+++ haiku/trunk/src/kits/shared/CommandPipe.cpp	2008-04-26 12:16:53 UTC (rev 25177)
@@ -54,7 +54,7 @@
 BCommandPipe::FlushArgs()
 {
 	// Delete all arguments from the list
-	for(int32 i = 0; i &lt; fArgList.CountItems(); i++)
+	for (int32 i = 0; i &lt; fArgList.CountItems(); i++)
 		free(fArgList.RemoveItem(0L));

[... truncated: 215 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="008196.html">[Haiku-commits] r25176 - in haiku/trunk/src/tests/add-ons/kernel/file_systems: . beserved beserved/AuthLib beserved/BeManager beserved/BeSure beserved/FileSharing beserved/FileSharing-Windows beserved/FileSharing-Windows/res beserved/Menus beserved/MyNetwork beserved/MyNetwork/DOC beserved/bt_fs beserved/bt_fs/backups beserved/bt_fs/ksocket_v3 beserved/bt_fs/ksocket_v3/ksocketd beserved/bt_fs/ksocket_v3/libksocket beserved/documentation beserved/documentation/images beserved/lshosts beserved/mounthost beserved/server beserved/server-1.2.6 beserved/server-Windows beserved/transport
</A></li>
	<LI>Next message: <A HREF="008206.html">[Haiku-commits] r25178 - haiku/trunk/src/preferences/keymap
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#8197">[ date ]</a>
              <a href="thread.html#8197">[ thread ]</a>
              <a href="subject.html#8197">[ subject ]</a>
              <a href="author.html#8197">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
