<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r24723 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . syskonnect	syskonnect/dev syskonnect/dev/mii syskonnect/dev/sk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24723%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20syskonnect%0A%09syskonnect/dev%20syskonnect/dev/mii%20syskonnect/dev/sk&In-Reply-To=%3C200804011817.m31IHWdN019489%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007347.html">
   <LINK REL="Next"  HREF="007333.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r24723 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . syskonnect	syskonnect/dev syskonnect/dev/mii syskonnect/dev/sk</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24723%20-%20in%0A%09haiku/trunk/src/add-ons/kernel/drivers/network%3A%20.%20syskonnect%0A%09syskonnect/dev%20syskonnect/dev/mii%20syskonnect/dev/sk&In-Reply-To=%3C200804011817.m31IHWdN019489%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r24723 - in	haiku/trunk/src/add-ons/kernel/drivers/network: . syskonnect	syskonnect/dev syskonnect/dev/mii syskonnect/dev/sk">axeld at mail.berlios.de
       </A><BR>
    <I>Tue Apr  1 20:17:32 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="007347.html">[Haiku-commits] r24710 - in haiku/trunk: headers/posix src/system/libroot/posix/pthread
</A></li>
        <LI>Next message: <A HREF="007333.html">[Haiku-commits] r24724 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7331">[ date ]</a>
              <a href="thread.html#7331">[ thread ]</a>
              <a href="subject.html#7331">[ subject ]</a>
              <a href="author.html#7331">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2008-04-01 20:17:28 +0200 (Tue, 01 Apr 2008)
New Revision: 24723
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=24723&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=24723&amp;view=rev</A>

Added:
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/brgphyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/miidevs.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/ukphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/ukphy_subr.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/xmphy.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/xmphyreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/Jamfile
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/glue.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/if_sk.c
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/if_skreg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/xmaciireg.h
   haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/sk/yukonreg.h
Modified:
   haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
Log:
Applied patch by Euan Kirkhope:
* Imported FreeBSD driver &quot;sk&quot; as syskonnect into the Haiku tree, and
  wrote the necessary glue code to let it run.


Modified: haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/Jamfile	2008-04-01 18:17:28 UTC (rev 24723)
@@ -19,6 +19,7 @@
 SubInclude HAIKU_TOP src add-ons kernel drivers network marvell_yukon ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network nforce ;
 SubInclude HAIKU_TOP src add-ons kernel drivers network pcnet ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network syskonnect ;
 
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm440x ;
 SubIncludeGPL HAIKU_TOP src add-ons kernel drivers network bcm570x ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/Jamfile	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/Jamfile	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,3 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network syskonnect ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network syskonnect dev ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/Jamfile	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/Jamfile	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,4 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network syskonnect dev ;
+
+SubInclude HAIKU_TOP src add-ons kernel drivers network syskonnect dev mii ;
+SubInclude HAIKU_TOP src add-ons kernel drivers network syskonnect dev sk ;

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/Jamfile
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/Jamfile	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/Jamfile	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,17 @@
+SubDir HAIKU_TOP src add-ons kernel drivers network syskonnect dev mii ;
+
+UsePrivateHeaders kernel net ;
+
+UseHeaders [ FDirName $(SUBDIR) .. .. ] : true ;
+UseHeaders [ FDirName $(HAIKU_TOP) src libs compat freebsd_network compat ] : true ;
+
+SubDirCcFlags [ FDefines _KERNEL=1 FBSD_DRIVER=1 ] ;
+
+KernelStaticLibrary syskonnect_mii.a
+	:
+	xmphy.c
+	e1000phy.c
+	ukphy.c
+	ukphy_subr.c
+	;
+

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/brgphyreg.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/brgphyreg.h	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/brgphyreg.h	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,364 @@
+/*-
+ * Copyright (c) 2000
+ *	Bill Paul &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">wpaul at ee.columbia.edu</A>&gt;.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by Bill Paul.
+ * 4. Neither the name of the author nor the names of any co-contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/dev/mii/brgphyreg.h,v 1.6.2.2 2007/06/14 21:07:19 davidch Exp $
+ */
+
+#ifndef _DEV_MII_BRGPHYREG_H_
+#define	_DEV_MII_BRGPHYREG_H_
+
+/*
+ * Broadcom BCM5400 registers
+ */
+
+#define	BRGPHY_MII_BMCR	    	0x00
+#define	BRGPHY_BMCR_RESET		0x8000
+#define	BRGPHY_BMCR_LOOP		0x4000
+#define	BRGPHY_BMCR_SPD0		0x2000	/* Speed select, lower bit */
+#define	BRGPHY_BMCR_AUTOEN		0x1000	/* Autoneg enabled */
+#define	BRGPHY_BMCR_PDOWN		0x0800	/* Power down */
+#define	BRGPHY_BMCR_ISO			0x0400	/* Isolate */
+#define	BRGPHY_BMCR_STARTNEG	0x0200	/* Restart autoneg */
+#define	BRGPHY_BMCR_FDX			0x0100	/* Duplex mode */
+#define	BRGPHY_BMCR_CTEST		0x0080	/* Collision test enable */
+#define	BRGPHY_BMCR_SPD1		0x0040	/* Speed select, upper bit */
+
+#define	BRGPHY_S1000			BRGPHY_BMCR_SPD1	/* 1000mbps */
+#define	BRGPHY_S100				BRGPHY_BMCR_SPD0	/* 100mpbs */
+#define	BRGPHY_S10				0					/* 10mbps */
+
+#define	BRGPHY_MII_BMSR		0x01
+#define	BRGPHY_BMSR_EXTSTS	0x0100	/* Extended status present */
+#define	BRGPHY_BMSR_PRESUB	0x0040	/* Preamble surpression */
+#define	BRGPHY_BMSR_ACOMP	0x0020	/* Autoneg complete */
+#define	BRGPHY_BMSR_RFAULT	0x0010	/* Remote fault condition occured */
+#define	BRGPHY_BMSR_ANEG	0x0008	/* Autoneg capable */
+#define	BRGPHY_BMSR_LINK	0x0004	/* Link status */
+#define	BRGPHY_BMSR_JABBER	0x0002	/* Jabber detected */
+#define	BRGPHY_BMSR_EXT		0x0001	/* Extended capability */
+
+#define	BRGPHY_MII_ANAR		0x04
+#define	BRGPHY_ANAR_NP		0x8000	/* Next page */
+#define	BRGPHY_ANAR_RF		0x2000	/* Remote fault */
+#define	BRGPHY_ANAR_ASP		0x0800	/* Asymmetric Pause */
+#define	BRGPHY_ANAR_PC		0x0400	/* Pause capable */
+#define	BRGPHY_ANAR_SEL		0x001F	/* Selector field, 00001=Ethernet */
+
+#define	BRGPHY_MII_ANLPAR	0x05
+#define	BRGPHY_ANLPAR_NP	0x8000	/* Next page */
+#define	BRGPHY_ANLPAR_RF	0x2000	/* Remote fault */
+#define	BRGPHY_ANLPAR_ASP	0x0800	/* Asymmetric Pause */
+#define	BRGPHY_ANLPAR_PC	0x0400	/* Pause capable */
+#define	BRGPHY_ANLPAR_SEL	0x001F	/* Selector field, 00001=Ethernet */
+
+#define	BRGPHY_SEL_TYPE		0x0001	/* Ethernet */
+
+#define	BRGPHY_MII_ANER		0x06
+#define	BRGPHY_ANER_PDF		0x0010	/* Parallel detection fault */
+#define	BRGPHY_ANER_LPNP	0x0008	/* Link partner can next page */
+#define	BRGPHY_ANER_NP		0x0004	/* Local PHY can next page */
+#define	BRGPHY_ANER_RX		0x0002	/* Next page received */
+#define	BRGPHY_ANER_LPAN	0x0001 	/* Link partner autoneg capable */
+
+#define	BRGPHY_MII_NEXTP	0x07	/* Next page */
+
+#define	BRGPHY_MII_NEXTP_LP	0x08	/* Next page of link partner */
+
+#define	BRGPHY_MII_1000CTL	0x09	/* 1000baseT control */
+#define	BRGPHY_1000CTL_TST	0xE000	/* Test modes */
+#define	BRGPHY_1000CTL_MSE	0x1000	/* Master/Slave enable */
+#define	BRGPHY_1000CTL_MSC	0x0800	/* Master/Slave configuration */
+#define	BRGPHY_1000CTL_RD	0x0400	/* Repeater/DTE */
+#define	BRGPHY_1000CTL_AFD	0x0200	/* Advertise full duplex */
+#define	BRGPHY_1000CTL_AHD	0x0100	/* Advertise half duplex */
+
+#define	BRGPHY_MII_1000STS	0x0A	/* 1000baseT status */
+#define	BRGPHY_1000STS_MSF	0x8000	/* Master/slave fault */
+#define	BRGPHY_1000STS_MSR	0x4000	/* Master/slave result */
+#define	BRGPHY_1000STS_LRS	0x2000	/* Local receiver status */
+#define	BRGPHY_1000STS_RRS	0x1000	/* Remote receiver status */
+#define	BRGPHY_1000STS_LPFD	0x0800	/* Link partner can FD */
+#define	BRGPHY_1000STS_LPHD	0x0400	/* Link partner can HD */
+#define	BRGPHY_1000STS_IEC	0x00FF	/* Idle error count */
+
+#define	BRGPHY_MII_EXTSTS	0x0F	/* Extended status */
+#define	BRGPHY_EXTSTS_X_FD_CAP	0x8000	/* 1000base-X FD capable */
+#define	BRGPHY_EXTSTS_X_HD_CAP	0x4000	/* 1000base-X HD capable */
+#define	BRGPHY_EXTSTS_T_FD_CAP	0x2000	/* 1000base-T FD capable */
+#define	BRGPHY_EXTSTS_T_HD_CAP	0x1000	/* 1000base-T HD capable */
+
+#define	BRGPHY_MII_PHY_EXTCTL	0x10	/* PHY extended control */
+#define	BRGPHY_PHY_EXTCTL_MAC_PHY	0x8000	/* 10BIT/GMI-interface */
+#define	BRGPHY_PHY_EXTCTL_DIS_CROSS	0x4000	/* Disable MDI crossover */
+#define	BRGPHY_PHY_EXTCTL_TX_DIS	0x2000	/* TX output disabled */
+#define	BRGPHY_PHY_EXTCTL_INT_DIS	0x1000	/* Interrupts disabled */
+#define	BRGPHY_PHY_EXTCTL_F_INT		0x0800	/* Force interrupt */
+#define	BRGPHY_PHY_EXTCTL_BY_45		0x0400	/* Bypass 4B5B-Decoder */
+#define	BRGPHY_PHY_EXTCTL_BY_SCR	0x0200	/* Bypass scrambler */
+#define	BRGPHY_PHY_EXTCTL_BY_MLT3	0x0100	/* Bypass MLT3 encoder */
+#define	BRGPHY_PHY_EXTCTL_BY_RXA	0x0080	/* Bypass RX alignment */
+#define	BRGPHY_PHY_EXTCTL_RES_SCR	0x0040	/* Reset scrambler */
+#define	BRGPHY_PHY_EXTCTL_EN_LTR	0x0020	/* Enable LED traffic mode */
+#define	BRGPHY_PHY_EXTCTL_LED_ON	0x0010	/* Force LEDs on */
+#define	BRGPHY_PHY_EXTCTL_LED_OFF	0x0008	/* Force LEDs off */
+#define	BRGPHY_PHY_EXTCTL_EX_IPG	0x0004	/* Extended TX IPG mode */
+#define	BRGPHY_PHY_EXTCTL_3_LED		0x0002	/* Three link LED mode */
+#define	BRGPHY_PHY_EXTCTL_HIGH_LA	0x0001	/* GMII Fifo Elasticy (?) */
+
+#define	BRGPHY_MII_PHY_EXTSTS	0x11	/* PHY extended status */
+#define	BRGPHY_PHY_EXTSTS_CROSS_STAT	0x2000	/* MDI crossover status */
+#define	BRGPHY_PHY_EXTSTS_INT_STAT	0x1000	/* Interrupt status */
+#define	BRGPHY_PHY_EXTSTS_RRS		0x0800	/* Remote receiver status */
+#define	BRGPHY_PHY_EXTSTS_LRS		0x0400	/* Local receiver status */
+#define	BRGPHY_PHY_EXTSTS_LOCKED	0x0200	/* Locked */
+#define	BRGPHY_PHY_EXTSTS_LS		0x0100	/* Link status */
+#define	BRGPHY_PHY_EXTSTS_RF		0x0080	/* Remove fault */
+#define	BRGPHY_PHY_EXTSTS_CE_ER		0x0040	/* Carrier ext error */
+#define	BRGPHY_PHY_EXTSTS_BAD_SSD	0x0020	/* Bad SSD */
+#define	BRGPHY_PHY_EXTSTS_BAD_ESD	0x0010	/* Bad ESS */
+#define	BRGPHY_PHY_EXTSTS_RX_ER		0x0008	/* RX error */
+#define	BRGPHY_PHY_EXTSTS_TX_ER		0x0004	/* TX error */
+#define	BRGPHY_PHY_EXTSTS_LOCK_ER	0x0002	/* Lock error */
+#define	BRGPHY_PHY_EXTSTS_MLT3_ER	0x0001	/* MLT3 code error */
+
+#define	BRGPHY_MII_RXERRCNT	0x12	/* RX error counter */
+
+#define	BRGPHY_MII_FCERRCNT	0x13	/* False carrier sense counter */
+#define	BGRPHY_FCERRCNT		0x00FF	/* False carrier counter */
+
+#define	BRGPHY_MII_RXNOCNT	0x14	/* RX not OK counter */
+#define	BRGPHY_RXNOCNT_LOCAL	0xFF00	/* Local RX not OK counter */
+#define	BRGPHY_RXNOCNT_REMOTE	0x00FF	/* Local RX not OK counter */
+
+#define	BRGPHY_MII_DSP_RW_PORT	0x15	/* DSP coefficient r/w port */
+
+#define	BRGPHY_MII_DSP_ADDR_REG	0x17	/* DSP coefficient addr register */
+
+#define	BRGPHY_DSP_TAP_NUMBER_MASK		0x00
+#define	BRGPHY_DSP_AGC_A			0x00
+#define	BRGPHY_DSP_AGC_B			0x01
+#define	BRGPHY_DSP_MSE_PAIR_STATUS		0x02
+#define	BRGPHY_DSP_SOFT_DECISION		0x03
+#define	BRGPHY_DSP_PHASE_REG			0x04
+#define	BRGPHY_DSP_SKEW				0x05
+#define	BRGPHY_DSP_POWER_SAVER_UPPER_BOUND	0x06
+#define	BRGPHY_DSP_POWER_SAVER_LOWER_BOUND	0x07
+#define	BRGPHY_DSP_LAST_ECHO			0x08
+#define	BRGPHY_DSP_FREQUENCY			0x09
+#define	BRGPHY_DSP_PLL_BANDWIDTH		0x0A
+#define	BRGPHY_DSP_PLL_PHASE_OFFSET		0x0B
+
+#define	BRGPHYDSP_FILTER_DCOFFSET		0x0C00
+#define	BRGPHY_DSP_FILTER_FEXT3			0x0B00
+#define	BRGPHY_DSP_FILTER_FEXT2			0x0A00
+#define	BRGPHY_DSP_FILTER_FEXT1			0x0900
+#define	BRGPHY_DSP_FILTER_FEXT0			0x0800
+#define	BRGPHY_DSP_FILTER_NEXT3			0x0700
+#define	BRGPHY_DSP_FILTER_NEXT2			0x0600
+#define	BRGPHY_DSP_FILTER_NEXT1			0x0500
+#define	BRGPHY_DSP_FILTER_NEXT0			0x0400
+#define	BRGPHY_DSP_FILTER_ECHO			0x0300
+#define	BRGPHY_DSP_FILTER_DFE			0x0200
+#define	BRGPHY_DSP_FILTER_FFE			0x0100
+
+#define	BRGPHY_DSP_CONTROL_ALL_FILTERS		0x1000
+
+#define	BRGPHY_DSP_SEL_CH_0			0x0000
+#define	BRGPHY_DSP_SEL_CH_1			0x2000
+#define	BRGPHY_DSP_SEL_CH_2			0x4000
+#define	BRGPHY_DSP_SEL_CH_3			0x6000
+
+#define	BRGPHY_MII_AUXCTL	0x18	/* AUX control */
+#define	BRGPHY_AUXCTL_LOW_SQ	0x8000	/* Low squelch */
+#define	BRGPHY_AUXCTL_LONG_PKT	0x4000	/* RX long packets */
+#define	BRGPHY_AUXCTL_ER_CTL	0x3000	/* Edgerate control */
+#define	BRGPHY_AUXCTL_TX_TST	0x0400	/* TX test, always 1 */
+#define	BRGPHY_AUXCTL_DIS_PRF	0x0080	/* dis part resp filter */
+#define	BRGPHY_AUXCTL_DIAG_MODE	0x0004	/* Diagnostic mode */
+
+#define	BRGPHY_MII_AUXSTS	0x19	/* AUX status */
+#define	BRGPHY_AUXSTS_ACOMP	0x8000	/* Autoneg complete */
+#define	BRGPHY_AUXSTS_AN_ACK	0x4000	/* Autoneg complete ack */
+#define	BRGPHY_AUXSTS_AN_ACK_D	0x2000	/* Autoneg complete ack detect */
+#define	BRGPHY_AUXSTS_AN_NPW	0x1000	/* Autoneg next page wait */
+#define	BRGPHY_AUXSTS_AN_RES	0x0700	/* Autoneg HCD */
+#define	BRGPHY_AUXSTS_PDF	0x0080	/* Parallel detect. fault */
+#define	BRGPHY_AUXSTS_RF	0x0040	/* Remote fault */
+#define	BRGPHY_AUXSTS_ANP_R	0x0020	/* Autoneg page received */
+#define	BRGPHY_AUXSTS_LP_ANAB	0x0010	/* Link partner autoneg ability */
+#define	BRGPHY_AUXSTS_LP_NPAB	0x0008	/* Link partner next page ability */
+#define	BRGPHY_AUXSTS_LINK	0x0004	/* Link status */
+#define	BRGPHY_AUXSTS_PRR	0x0002	/* Pause resolution-RX */
+#define	BRGPHY_AUXSTS_PRT	0x0001	/* Pause resolution-TX */
+
+#define	BRGPHY_RES_1000FD	0x0700	/* 1000baseT full duplex */
+#define	BRGPHY_RES_1000HD	0x0600	/* 1000baseT half duplex */
+#define	BRGPHY_RES_100FD	0x0500	/* 100baseT full duplex */
+#define	BRGPHY_RES_100T4	0x0400	/* 100baseT4 */
+#define	BRGPHY_RES_100HD	0x0300	/* 100baseT half duplex */
+#define	BRGPHY_RES_10FD		0x0200	/* 10baseT full duplex */
+#define	BRGPHY_RES_10HD		0x0100	/* 10baseT half duplex */
+
+#define	BRGPHY_MII_ISR		0x1A	/* Interrupt status */
+#define	BRGPHY_ISR_PSERR	0x4000	/* Pair swap error */
+#define	BRGPHY_ISR_MDXI_SC	0x2000	/* MDIX Status Change */
+#define	BRGPHY_ISR_HCT		0x1000	/* Counter above 32K */
+#define	BRGPHY_ISR_LCT		0x0800	/* All counter below 128 */
+#define	BRGPHY_ISR_AN_PR	0x0400	/* Autoneg page received */
+#define	BRGPHY_ISR_NO_HDCL	0x0200	/* No HCD Link */
+#define	BRGPHY_ISR_NO_HDC	0x0100	/* No HCD */
+#define	BRGPHY_ISR_USHDC	0x0080	/* Negotiated Unsupported HCD */
+#define	BRGPHY_ISR_SCR_S_ERR	0x0040	/* Scrambler sync error */
+#define	BRGPHY_ISR_RRS_CHG	0x0020	/* Remote RX status change */
+#define	BRGPHY_ISR_LRS_CHG	0x0010	/* Local RX status change */
+#define	BRGPHY_ISR_DUP_CHG	0x0008	/* Duplex mode change */
+#define	BRGPHY_ISR_LSP_CHG	0x0004	/* Link speed changed */
+#define	BRGPHY_ISR_LNK_CHG	0x0002	/* Link status change */
+#define	BRGPHY_ISR_CRCERR	0x0001	/* CRC error */
+
+#define	BRGPHY_MII_IMR		0x1B	/* Interrupt mask */
+#define	BRGPHY_IMR_PSERR	0x4000	/* Pair swap error */
+#define	BRGPHY_IMR_MDXI_SC	0x2000	/* MDIX Status Change */
+#define	BRGPHY_IMR_HCT		0x1000	/* Counter above 32K */
+#define	BRGPHY_IMR_LCT		0x0800	/* All counter below 128 */
+#define	BRGPHY_IMR_AN_PR	0x0400	/* Autoneg page received */
+#define	BRGPHY_IMR_NO_HDCL	0x0200	/* No HCD Link */
+#define	BRGPHY_IMR_NO_HDC	0x0100	/* No HCD */
+#define	BRGPHY_IMR_USHDC	0x0080	/* Negotiated Unsupported HCD */
+#define	BRGPHY_IMR_SCR_S_ERR	0x0040	/* Scrambler sync error */
+#define	BRGPHY_IMR_RRS_CHG	0x0020	/* Remote RX status change */
+#define	BRGPHY_IMR_LRS_CHG	0x0010	/* Local RX status change */
+#define	BRGPHY_IMR_DUP_CHG	0x0008	/* Duplex mode change */
+#define	BRGPHY_IMR_LSP_CHG	0x0004	/* Link speed changed */
+#define	BRGPHY_IMR_LNK_CHG	0x0002	/* Link status change */
+#define	BRGPHY_IMR_CRCERR	0x0001	/* CRC error */
+
+/*******************************************************/
+/* Begin: Shared SerDes PHY register definitions       */
+/*******************************************************/
+
+/* SerDes autoneg is different from copper */
+#define BRGPHY_SERDES_ANAR				0x04
+#define BRGPHY_SERDES_ANAR_FDX			0x0020
+#define BRGPHY_SERDES_ANAR_HDX			0x0040
+#define BRGPHY_SERDES_ANAR_NO_PAUSE		(0x0 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANAR_SYM_PAUSE	(0x1 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANAR_ASYM_PAUSE	(0x2 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANAR_BOTH_PAUSE	(0x3 &lt;&lt; 7)
+
+#define BRGPHY_SERDES_ANLPAR			0x05
+#define BRGPHY_SERDES_ANLPAR_FDX		0x0020
+#define BRGPHY_SERDES_ANLPAR_HDX		0x0040
+#define BRGPHY_SERDES_ANLPAR_NO_PAUSE	(0x0 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANLPAR_SYM_PAUSE	(0x1 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANLPAR_ASYM_PAUSE	(0x2 &lt;&lt; 7)
+#define BRGPHY_SERDES_ANLPAR_BOTH_PAUSE	(0x3 &lt;&lt; 7)
+
+/*******************************************************/
+/* End: Shared SerDes PHY register definitions         */
+/*******************************************************/
+
+/*******************************************************/
+/* Begin: PHY register values for the 5706 PHY         */
+/*******************************************************/
+
+/* 
+ * Shadow register 0x1C, bit 15 is write enable,
+ * bits 14-10 select function (0x00 to 0x1F).
+ */
+#define BRGPHY_MII_SHADOW_1C			0x1C
+#define BRGPHY_SHADOW_1C_WRITE_EN		0x8000
+#define BRGPHY_SHADOW_1C_SELECT_MASK	0x7C00
+
+/* Shadow 0x1C Mode Control Register (select value 0x1F) */
+#define BRGPHY_SHADOW_1C_MODE_CTRL		(0x1F &lt;&lt; 10)
+/* When set, Regs 0-0x0F are 1000X, else 1000T */
+#define BRGPHY_SHADOW_1C_ENA_1000X		0x0001	
+
+#define	BRGPHY_MII_TEST1	0x1E
+#define	BRGPHY_TEST1_TRIM_EN	0x0010
+#define	BRGPHY_TEST1_CRC_EN	0x8000
+
+#define BRGPHY_MII_TEST2		0x1F
+
+/*******************************************************/
+/* End: PHY register values for the 5706 PHY           */
+/*******************************************************/
+
+/*******************************************************/
+/* Begin: PHY register values for the 5708S SerDes PHY */
+/*******************************************************/
+
+/* Autoneg Next Page Transmit 1 Regiser */
+#define BRGPHY_5708S_ANEG_NXT_PG_XMIT1			0x0B
+#define BRGPHY_5708S_ANEG_NXT_PG_XMIT1_25G		0x0001
+
+/* Use the BLOCK_ADDR register to select the page for registers 0x10 to 0x1E */
+#define BRGPHY_5708S_BLOCK_ADDR					0x1f
+#define BRGPHY_5708S_DIG_PG0 					0x0000
+#define BRGPHY_5708S_DIG3_PG2					0x0002
+#define BRGPHY_5708S_TX_MISC_PG5				0x0005
+
+/* 5708S SerDes &quot;Digital&quot; Registers (page 0) */
+#define BRGPHY_5708S_PG0_1000X_CTL1				0x10
+#define BRGPHY_5708S_PG0_1000X_CTL1_AUTODET_EN	0x0010
+#define BRGPHY_5708S_PG0_1000X_CTL1_FIBER_MODE	0x0001
+
+#define BRGPHY_5708S_PG0_1000X_STAT1			0x14
+#define BRGPHY_5708S_PG0_1000X_STAT1_LINK		0x0002
+#define BRGPHY_5708S_PG0_1000X_STAT1_FDX		0x0004
+#define BRGPHY_5708S_PG0_1000X_STAT1_SPEED_MASK	0x0018
+#define BRGPHY_5708S_PG0_1000X_STAT1_SPEED_10	(0x0 &lt;&lt; 3)
+#define BRGPHY_5708S_PG0_1000X_STAT1_SPEED_100	(0x1 &lt;&lt; 3)
+#define BRGPHY_5708S_PG0_1000X_STAT1_SPEED_1G	(0x2 &lt;&lt; 3)
+#define BRGPHY_5708S_PG0_1000X_STAT1_SPEED_25G	(0x3 &lt;&lt; 3)
+
+
+#define BRGPHY_5708S_PG0_1000X_CTL2				0x11
+#define BRGPHY_5708S_PG0_1000X_CTL2_PAR_DET_EN	0x0001
+
+/* 5708S SerDes &quot;Digital 3&quot; Registers (page 2) */
+#define BRGPHY_5708S_PG2_DIGCTL_3_0				0x10
+#define BRGPHY_5708S_PG2_DIGCTL_3_0_USE_IEEE	0x0001
+
+/* 5708S SerDes &quot;TX Misc&quot; Registers (page 5) */
+#define BRGPHY_5708S_PG5_2500STATUS1			0x10
+#define BRGPHY_5708S_PG5_TXACTL1				0x15
+#define BRGPHY_5708S_PG5_TXACTL3				0x17
+
+/*******************************************************/
+/* End: PHY register values for the 5708S SerDes PHY   */
+/*******************************************************/
+
+#define	BRGPHY_INTRS	\
+	~(BRGPHY_IMR_LNK_CHG|BRGPHY_IMR_LSP_CHG|BRGPHY_IMR_DUP_CHG)
+
+#endif /* _DEV_BRGPHY_MIIREG_H_ */

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phy.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phy.c	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phy.c	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,513 @@
+/*-
+ * Principal Author: Parag Patel
+ * Copyright (c) 2001
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Additonal Copyright (c) 2001 by Traakan Software under same licence.
+ * Secondary Author: Matthew Jacob
+ */
+
+#include &lt;sys/cdefs.h&gt;
+__FBSDID(&quot;$FreeBSD: src/sys/dev/mii/e1000phy.c,v 1.18 2006/12/11 11:09:48 yongari Exp $&quot;);
+
+/*
+ * driver for the Marvell 88E1000 series external 1000/100/10-BT PHY.
+ */
+
+/*
+ * Support added for the Marvell 88E1011 (Alaska) 1000/100/10baseTX and
+ * 1000baseSX PHY.
+ * Nathan Binkert &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">nate at openbsd.org</A>&gt;
+ * Jung-uk Kim &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jkim at niksun.com</A>&gt;
+ */
+
+#include &lt;sys/param.h&gt;
+#include &lt;sys/systm.h&gt;
+#include &lt;sys/kernel.h&gt;
+#include &lt;sys/module.h&gt;
+#include &lt;sys/socket.h&gt;
+#include &lt;sys/bus.h&gt;
+
+
+#include &lt;net/if.h&gt;
+#include &lt;net/if_media.h&gt;
+
+#include &lt;dev/mii/mii.h&gt;
+#include &lt;dev/mii/miivar.h&gt;
+#include &quot;miidevs.h&quot;
+
+#include &lt;dev/mii/e1000phyreg.h&gt;
+
+#include &quot;miibus_if.h&quot;
+
+static int	e1000phy_probe(device_t);
+static int	e1000phy_attach(device_t);
+
+struct e1000phy_softc {
+	struct mii_softc mii_sc;
+	int mii_model;
+};
+
+static device_method_t e1000phy_methods[] = {
+	/* device interface */
+	DEVMETHOD(device_probe,		e1000phy_probe),
+	DEVMETHOD(device_attach,	e1000phy_attach),
+	DEVMETHOD(device_detach,	mii_phy_detach),
+	DEVMETHOD(device_shutdown,	bus_generic_shutdown),
+	{ 0, 0 }
+};
+
+static devclass_t e1000phy_devclass;
+static driver_t e1000phy_driver = {
+	&quot;e1000phy&quot;,
+	e1000phy_methods,
+	sizeof(struct e1000phy_softc)
+};
+
+DRIVER_MODULE(e1000phy, miibus, e1000phy_driver, e1000phy_devclass, 0, 0);
+
+static int	e1000phy_service(struct mii_softc *, struct mii_data *, int);
+static void	e1000phy_status(struct mii_softc *);
+static void	e1000phy_reset(struct mii_softc *);
+static int	e1000phy_mii_phy_auto(struct e1000phy_softc *);
+
+static const struct mii_phydesc e1000phys[] = {
+	MII_PHY_DESC(MARVELL, E1000),
+	MII_PHY_DESC(MARVELL, E1011),
+	MII_PHY_DESC(MARVELL, E1000_3),
+	MII_PHY_DESC(MARVELL, E1000S),
+	MII_PHY_DESC(MARVELL, E1000_5),
+	MII_PHY_DESC(MARVELL, E1000_6),
+	MII_PHY_DESC(MARVELL, E3082),
+	MII_PHY_DESC(MARVELL, E1112),
+	MII_PHY_DESC(MARVELL, E1149),
+	MII_PHY_DESC(MARVELL, E1111),
+	MII_PHY_DESC(MARVELL, E1116),
+	MII_PHY_DESC(MARVELL, E1118),
+	MII_PHY_DESC(xxMARVELL, E1000),
+	MII_PHY_DESC(xxMARVELL, E1011),
+	MII_PHY_DESC(xxMARVELL, E1000_3),
+	MII_PHY_DESC(xxMARVELL, E1000_5),
+	MII_PHY_DESC(xxMARVELL, E1111),
+	MII_PHY_END
+};
+
+static int
+e1000phy_probe(device_t	dev)
+{
+
+	return (mii_phy_dev_probe(dev, e1000phys, BUS_PROBE_DEFAULT));
+}
+
+static int
+e1000phy_attach(device_t dev)
+{
+	struct e1000phy_softc *esc;
+	struct mii_softc *sc;
+	struct mii_attach_args *ma;
+	struct mii_data *mii;
+	int fast_ether;
+
+	esc = device_get_softc(dev);
+	sc = &amp;esc-&gt;mii_sc;
+	ma = device_get_ivars(dev);
+	sc-&gt;mii_dev = device_get_parent(dev);
+	mii = device_get_softc(sc-&gt;mii_dev);
+	LIST_INSERT_HEAD(&amp;mii-&gt;mii_phys, sc, mii_list);
+
+	sc-&gt;mii_inst = mii-&gt;mii_instance;
+	sc-&gt;mii_phy = ma-&gt;mii_phyno;
+	sc-&gt;mii_service = e1000phy_service;
+	sc-&gt;mii_pdata = mii;
+	sc-&gt;mii_anegticks = MII_ANEGTICKS_GIGE;
+	mii-&gt;mii_instance++;
+
+	fast_ether = 0;
+	esc-&gt;mii_model = MII_MODEL(ma-&gt;mii_id2);
+	switch (esc-&gt;mii_model) {
+	case MII_MODEL_MARVELL_E1011:
+	case MII_MODEL_MARVELL_E1112:
+		if (PHY_READ(sc, E1000_ESSR) &amp; E1000_ESSR_FIBER_LINK)
+			sc-&gt;mii_flags |= MIIF_HAVEFIBER;
+		break;
+	case MII_MODEL_MARVELL_E3082:
+		/* 88E3082 10/100 Fast Ethernet PHY. */
+		sc-&gt;mii_anegticks = MII_ANEGTICKS;
+		fast_ether = 1;
+		break;
+	}
+
+	e1000phy_reset(sc);
+
+	device_printf(dev, &quot; &quot;);
+
+#define	ADD(m, c)	ifmedia_add(&amp;mii-&gt;mii_media, (m), (c), NULL)
+	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc-&gt;mii_inst),
+	    E1000_CR_ISOLATE);
+	if ((sc-&gt;mii_flags &amp; MIIF_HAVEFIBER) == 0) {
+		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc-&gt;mii_inst),
+		    E1000_CR_SPEED_10);
+		printf(&quot;10baseT, &quot;);
+		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc-&gt;mii_inst),
+		    E1000_CR_SPEED_10 | E1000_CR_FULL_DUPLEX);
+		printf(&quot;10baseT-FDX, &quot;);
+		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc-&gt;mii_inst),
+		    E1000_CR_SPEED_100);
+		printf(&quot;100baseTX, &quot;);
+		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc-&gt;mii_inst),
+		    E1000_CR_SPEED_100 | E1000_CR_FULL_DUPLEX);
+		printf(&quot;100baseTX-FDX, &quot;);
+		if (fast_ether == 0) {
+			/*
+			 * 1000BT-simplex not supported; driver must ignore
+			 * this entry, but it must be present in order to
+			 * manually set full-duplex.
+			 */
+			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
+			    sc-&gt;mii_inst), E1000_CR_SPEED_1000);
+			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
+			    sc-&gt;mii_inst),
+			    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
+			printf(&quot;1000baseTX-FDX, &quot;);
+		}
+	} else {
+		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX, sc-&gt;mii_inst),
+		    E1000_CR_SPEED_1000 | E1000_CR_FULL_DUPLEX);
+		printf(&quot;1000baseSX-FDX, &quot;);
+	}
+	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc-&gt;mii_inst), 0);
+	printf(&quot;auto\n&quot;);
+#undef ADD
+
+	MIIBUS_MEDIAINIT(sc-&gt;mii_dev);
+	return (0);
+}
+
+static void
+e1000phy_reset(struct mii_softc *sc)
+{
+	struct e1000phy_softc *esc;
+	uint16_t reg;
+
+	esc = (struct e1000phy_softc *)sc;
+	reg = PHY_READ(sc, E1000_SCR);
+	if ((sc-&gt;mii_flags &amp; MIIF_HAVEFIBER) != 0) {
+		reg &amp;= ~E1000_SCR_AUTO_X_MODE;
+		PHY_WRITE(sc, E1000_SCR, reg);
+		if (esc-&gt;mii_model == MII_MODEL_MARVELL_E1112) {
+			/* Select 1000BASE-X only mode. */
+			PHY_WRITE(sc, E1000_EADR, 2);
+			reg = PHY_READ(sc, E1000_SCR);
+			reg &amp;= ~E1000_SCR_MODE_MASK;
+			reg |= E1000_SCR_MODE_1000BX;
+			PHY_WRITE(sc, E1000_SCR, reg);
+			PHY_WRITE(sc, E1000_EADR, 1);
+		}
+	} else {
+		switch (esc-&gt;mii_model) {
+		case MII_MODEL_MARVELL_E1111:
+		case MII_MODEL_MARVELL_E1112:
+		case MII_MODEL_MARVELL_E1116:
+		case MII_MODEL_MARVELL_E1118:
+		case MII_MODEL_MARVELL_E1149:
+			/* Disable energy detect mode. */
+			reg &amp;= ~E1000_SCR_EN_DETECT_MASK;
+			reg |= E1000_SCR_AUTO_X_MODE;
+			break;
+		case MII_MODEL_MARVELL_E3082:
+			reg |= (E1000_SCR_AUTO_X_MODE &gt;&gt; 1);
+			break;
+		default:
+			reg &amp;= ~E1000_SCR_AUTO_X_MODE;
+			break;
+		}
+		/* Enable CRS on TX. */
+		reg |= E1000_SCR_ASSERT_CRS_ON_TX;
+		/* Auto correction for reversed cable polarity. */
+		reg &amp;= ~E1000_SCR_POLARITY_REVERSAL;
+		PHY_WRITE(sc, E1000_SCR, reg);
+	}
+
+	switch (MII_MODEL(esc-&gt;mii_model)) {
+	case MII_MODEL_MARVELL_E3082:
+	case MII_MODEL_MARVELL_E1112:
+	case MII_MODEL_MARVELL_E1116:
+	case MII_MODEL_MARVELL_E1118:
+	case MII_MODEL_MARVELL_E1149:
+		break;
+	default:
+		/* Force TX_CLK to 25MHz clock. */
+		reg = PHY_READ(sc, E1000_ESCR);
+		reg |= E1000_ESCR_TX_CLK_25;
+		PHY_WRITE(sc, E1000_ESCR, reg);
+		break;
+	}
+
+	/* Reset the PHY so all changes take effect. */
+	reg = PHY_READ(sc, E1000_CR);
+	reg |= E1000_CR_RESET;
+	PHY_WRITE(sc, E1000_CR, reg);
+}
+
+static int
+e1000phy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
+{
+	struct ifmedia_entry *ife = mii-&gt;mii_media.ifm_cur;
+	struct e1000phy_softc *esc = (struct e1000phy_softc *)sc;
+	uint16_t speed, gig;
+	int reg;
+
+	switch (cmd) {
+	case MII_POLLSTAT:
+		/*
+		 * If we're not polling our PHY instance, just return.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst)
+			return (0);
+		break;
+
+	case MII_MEDIACHG:
+		/*
+		 * If the media indicates a different PHY instance,
+		 * isolate ourselves.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst) {
+			reg = PHY_READ(sc, E1000_CR);
+			PHY_WRITE(sc, E1000_CR, reg | E1000_CR_ISOLATE);
+			return (0);
+		}
+
+		/*
+		 * If the interface is not up, don't do anything.
+		 */
+		if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_UP) == 0)
+			break;
+
+		if (IFM_SUBTYPE(ife-&gt;ifm_media) == IFM_AUTO) {
+			e1000phy_mii_phy_auto(esc);
+			break;
+		}
+
+		speed = 0;
+		switch (IFM_SUBTYPE(ife-&gt;ifm_media)) {
+		case IFM_1000_T:
+			if (esc-&gt;mii_model == MII_MODEL_MARVELL_E3082)
+				return (EINVAL);
+			speed = E1000_CR_SPEED_1000;
+			break;
+		case IFM_1000_SX:
+			if (esc-&gt;mii_model == MII_MODEL_MARVELL_E3082)
+				return (EINVAL);
+			speed = E1000_CR_SPEED_1000;
+			break;
+		case IFM_100_TX:
+			speed = E1000_CR_SPEED_100;
+			break;
+		case IFM_10_T:
+			speed = E1000_CR_SPEED_10;
+			break;
+		case IFM_NONE:
+			reg = PHY_READ(sc, E1000_CR);
+			PHY_WRITE(sc, E1000_CR,
+			    reg | E1000_CR_ISOLATE | E1000_CR_POWER_DOWN);
+			goto done;
+		default:
+			return (EINVAL);
+		}
+
+		if (((ife-&gt;ifm_media &amp; IFM_GMASK) &amp; IFM_FDX) != 0) {
+			speed |= E1000_CR_FULL_DUPLEX;
+			gig = E1000_1GCR_1000T_FD;
+		} else
+			gig = E1000_1GCR_1000T;
+
+		reg = PHY_READ(sc, E1000_CR);
+		reg &amp;= ~E1000_CR_AUTO_NEG_ENABLE;
+		PHY_WRITE(sc, E1000_CR, reg | E1000_CR_RESET);
+
+		/*
+		 * When setting the link manually, one side must
+		 * be the master and the other the slave. However
+		 * ifmedia doesn't give us a good way to specify
+		 * this, so we fake it by using one of the LINK
+		 * flags. If LINK0 is set, we program the PHY to
+		 * be a master, otherwise it's a slave.
+		 */
+		if (IFM_SUBTYPE(ife-&gt;ifm_media) == IFM_1000_T ||
+		    (IFM_SUBTYPE(ife-&gt;ifm_media) == IFM_1000_SX)) {
+			if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_LINK0))
+				PHY_WRITE(sc, E1000_1GCR, gig |
+				    E1000_1GCR_MS_ENABLE | E1000_1GCR_MS_VALUE);
+			else
+				PHY_WRITE(sc, E1000_1GCR, gig |
+				    E1000_1GCR_MS_ENABLE);
+		} else {
+			if (esc-&gt;mii_model != MII_MODEL_MARVELL_E3082)
+				PHY_WRITE(sc, E1000_1GCR, 0);
+		}
+		PHY_WRITE(sc, E1000_AR, E1000_AR_SELECTOR_FIELD);
+		PHY_WRITE(sc, E1000_CR, speed | E1000_CR_RESET);
+done:
+		break;
+	case MII_TICK:
+		/*
+		 * If we're not currently selected, just return.
+		 */
+		if (IFM_INST(ife-&gt;ifm_media) != sc-&gt;mii_inst)
+			return (0);
+
+		/*
+		 * Is the interface even up?
+		 */
+		if ((mii-&gt;mii_ifp-&gt;if_flags &amp; IFF_UP) == 0)
+			return (0);
+
+		/*
+		 * Only used for autonegotiation.
+		 */
+		if (IFM_SUBTYPE(ife-&gt;ifm_media) != IFM_AUTO)
+			break;
+
+		/*
+		 * check for link.
+		 * Read the status register twice; BMSR_LINK is latch-low.
+		 */
+		reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
+		if (reg &amp; BMSR_LINK) {
+			sc-&gt;mii_ticks = 0;
+			break;
+		}
+
+		/* Announce link loss right after it happens. */
+		if (sc-&gt;mii_ticks &lt;= sc-&gt;mii_anegticks)
+			return (0);
+
+		sc-&gt;mii_ticks = 0;
+		e1000phy_reset(sc);
+		e1000phy_mii_phy_auto(esc);
+		break;
+	}
+
+	/* Update the media status. */
+	e1000phy_status(sc);
+
+	/* Callback if something changed. */
+	mii_phy_update(sc, cmd);
+	return (0);
+}
+
+static void
+e1000phy_status(struct mii_softc *sc)
+{
+	struct mii_data *mii = sc-&gt;mii_pdata;
+	int bmsr, bmcr, esr, gsr, ssr, isr, ar, lpar;
+
+	mii-&gt;mii_media_status = IFM_AVALID;
+	mii-&gt;mii_media_active = IFM_ETHER;
+
+	bmsr = PHY_READ(sc, E1000_SR) | PHY_READ(sc, E1000_SR);
+	esr = PHY_READ(sc, E1000_ESR);
+	bmcr = PHY_READ(sc, E1000_CR);
+	ssr = PHY_READ(sc, E1000_SSR);
+	isr = PHY_READ(sc, E1000_ISR);
+	ar = PHY_READ(sc, E1000_AR);
+	lpar = PHY_READ(sc, E1000_LPAR);
+
+	if (bmsr &amp; E1000_SR_LINK_STATUS)
+		mii-&gt;mii_media_status |= IFM_ACTIVE;
+
+	if (bmcr &amp; E1000_CR_LOOPBACK)
+		mii-&gt;mii_media_active |= IFM_LOOP;
+
+	if ((((bmcr &amp; E1000_CR_AUTO_NEG_ENABLE) != 0) &amp;&amp;
+	    ((bmsr &amp; E1000_SR_AUTO_NEG_COMPLETE) == 0)) ||
+	    ((ssr &amp; E1000_SSR_LINK) == 0) ||
+	    ((ssr &amp; E1000_SSR_SPD_DPLX_RESOLVED) == 0)) {
+		/* Erg, still trying, I guess... */
+		mii-&gt;mii_media_active |= IFM_NONE;
+		return;
+	}
+
+	if ((sc-&gt;mii_flags &amp; MIIF_HAVEFIBER) == 0) {
+		if (ssr &amp; E1000_SSR_1000MBS)
+			mii-&gt;mii_media_active |= IFM_1000_T;
+		else if (ssr &amp; E1000_SSR_100MBS)
+			mii-&gt;mii_media_active |= IFM_100_TX;
+		else
+			mii-&gt;mii_media_active |= IFM_10_T;
+	} else {
+		if (ssr &amp; E1000_SSR_1000MBS)
+			mii-&gt;mii_media_active |= IFM_1000_SX;
+	}
+
+	if (ssr &amp; E1000_SSR_DUPLEX)
+		mii-&gt;mii_media_active |= IFM_FDX;
+	else
+		mii-&gt;mii_media_active |= IFM_HDX;
+
+	if ((sc-&gt;mii_flags &amp; MIIF_HAVEFIBER) == 0) {
+		/* FLAG0==rx-flow-control FLAG1==tx-flow-control */
+		if ((ar &amp; E1000_AR_PAUSE) &amp;&amp; (lpar &amp; E1000_LPAR_PAUSE)) {
+			mii-&gt;mii_media_active |= IFM_FLAG0 | IFM_FLAG1;
+		} else if (!(ar &amp; E1000_AR_PAUSE) &amp;&amp; (ar &amp; E1000_AR_ASM_DIR) &amp;&amp;
+		    (lpar &amp; E1000_LPAR_PAUSE) &amp;&amp; (lpar &amp; E1000_LPAR_ASM_DIR)) {
+			mii-&gt;mii_media_active |= IFM_FLAG1;
+		} else if ((ar &amp; E1000_AR_PAUSE) &amp;&amp; (ar &amp; E1000_AR_ASM_DIR) &amp;&amp;
+		    !(lpar &amp; E1000_LPAR_PAUSE) &amp;&amp; (lpar &amp; E1000_LPAR_ASM_DIR)) {
+			mii-&gt;mii_media_active |= IFM_FLAG0;
+		}
+	}
+
+	/* FLAG2 : local PHY resolved to MASTER */
+	if ((IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_1000_T) ||
+	    (IFM_SUBTYPE(mii-&gt;mii_media_active) == IFM_1000_SX)) {
+		PHY_READ(sc, E1000_1GSR);
+		gsr = PHY_READ(sc, E1000_1GSR);
+		if ((gsr &amp; E1000_1GSR_MS_CONFIG_RES) != 0)
+			mii-&gt;mii_media_active |= IFM_FLAG2;
+	}
+}
+
+static int
+e1000phy_mii_phy_auto(struct e1000phy_softc *esc)
+{
+	struct mii_softc *sc;
+
+	sc = &amp;esc-&gt;mii_sc;
+	if ((sc-&gt;mii_flags &amp; MIIF_HAVEFIBER) == 0)
+		PHY_WRITE(sc, E1000_AR, E1000_AR_10T | E1000_AR_10T_FD |
+		    E1000_AR_100TX | E1000_AR_100TX_FD |
+		    E1000_AR_PAUSE | E1000_AR_ASM_DIR);
+	else
+		PHY_WRITE(sc, E1000_AR, E1000_FA_1000X_FD | E1000_FA_1000X |
+		    E1000_FA_SYM_PAUSE | E1000_FA_ASYM_PAUSE);
+	if (esc-&gt;mii_model != MII_MODEL_MARVELL_E3082)
+		PHY_WRITE(sc, E1000_1GCR,
+		    E1000_1GCR_1000T_FD | E1000_1GCR_1000T);
+	PHY_WRITE(sc, E1000_CR,
+	    E1000_CR_AUTO_NEG_ENABLE | E1000_CR_RESTART_AUTO_NEG);
+
+	return (EJUSTRETURN);
+}

Added: haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phyreg.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phyreg.h	2008-04-01 17:59:51 UTC (rev 24722)
+++ haiku/trunk/src/add-ons/kernel/drivers/network/syskonnect/dev/mii/e1000phyreg.h	2008-04-01 18:17:28 UTC (rev 24723)
@@ -0,0 +1,324 @@
+/* $FreeBSD: src/sys/dev/mii/e1000phyreg.h,v 1.4 2006/12/11 10:43:32 yongari Exp $ */
+/*-
+ * Principal Author: Parag Patel
+ * Copyright (c) 2001
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice unmodified, this list of conditions, and the following
+ *    disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * Additonal Copyright (c) 2001 by Traakan Software under same licence.
+ * Secondary Author: Matthew Jacob
+ */
+
+/*-
+ * Derived by information released by Intel under the following license:
+ *
+ * Copyright (c) 1999 - 2001, Intel Corporation 
+ * 
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ * 
+ *  1. Redistributions of source code must retain the above copyright notice, 
+ *     this list of conditions and the following disclaimer.
+ * 
+ *  2. Redistributions in binary form must reproduce the above copyright notice,
+ *     this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ * 
+ *  3. Neither the name of Intel Corporation nor the names of its contributors 
+ *     may be used to endorse or promote products derived from this software 

[... truncated: 7424 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007347.html">[Haiku-commits] r24710 - in haiku/trunk: headers/posix src/system/libroot/posix/pthread
</A></li>
	<LI>Next message: <A HREF="007333.html">[Haiku-commits] r24724 - haiku/trunk/src/system/kernel/arch/x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7331">[ date ]</a>
              <a href="thread.html#7331">[ thread ]</a>
              <a href="subject.html#7331">[ subject ]</a>
              <a href="author.html#7331">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
