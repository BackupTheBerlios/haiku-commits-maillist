<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r24839 - haiku/trunk/src/kits/interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24839%20-%20haiku/trunk/src/kits/interface&In-Reply-To=%3C200804061656.m36GuVWY014321%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007543.html">
   <LINK REL="Next"  HREF="007545.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r24839 - haiku/trunk/src/kits/interface</H1>
    <B>stippi at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24839%20-%20haiku/trunk/src/kits/interface&In-Reply-To=%3C200804061656.m36GuVWY014321%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r24839 - haiku/trunk/src/kits/interface">stippi at mail.berlios.de
       </A><BR>
    <I>Sun Apr  6 18:56:31 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="007543.html">[Haiku-commits] r24838 - haiku/trunk/src/kits/interface
</A></li>
        <LI>Next message: <A HREF="007545.html">[Haiku-commits] r24840 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7544">[ date ]</a>
              <a href="thread.html#7544">[ thread ]</a>
              <a href="subject.html#7544">[ subject ]</a>
              <a href="author.html#7544">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: stippi
Date: 2008-04-06 18:56:30 +0200 (Sun, 06 Apr 2008)
New Revision: 24839
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=24839&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=24839&amp;view=rev</A>

Modified:
   haiku/trunk/src/kits/interface/ScrollBar.cpp
Log:
More style cleanup.


Modified: haiku/trunk/src/kits/interface/ScrollBar.cpp
===================================================================
--- haiku/trunk/src/kits/interface/ScrollBar.cpp	2008-04-06 16:47:43 UTC (rev 24838)
+++ haiku/trunk/src/kits/interface/ScrollBar.cpp	2008-04-06 16:56:30 UTC (rev 24839)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001-2007, Haiku, Inc.
+ * Copyright (c) 2001-2008, Haiku, Inc.
  * Distributed under the terms of the MIT license.
  *
  * Authors:
@@ -42,10 +42,10 @@
 #define SBC_SETPROPORTIONAL 2
 #define SBC_SETSTYLE 3
 
-// Quick constants for determining which arrow is down and are defined with respect
-// to double arrow mode. ARROW1 and ARROW4 refer to the outer pair of arrows and
-// ARROW2 and ARROW3 refer to the inner ones. ARROW1 points left/up and ARROW4
-// points right/down.
+// Quick constants for determining which arrow is down and are defined with
+// respect to double arrow mode. ARROW1 and ARROW4 refer to the outer pair of
+// arrows and ARROW2 and ARROW3 refer to the inner ones. ARROW1 points left/up
+// and ARROW4 points right/down.
 #define ARROW1 0
 #define ARROW2 1
 #define ARROW3 2
@@ -53,8 +53,9 @@
 #define THUMB 4
 #define NOARROW -1
 
-// Because the R5 version kept a lot of data on server-side, we need to kludge our way
-// into binary compatibility
+
+// Because the R5 version kept a lot of data on server-side, we need to kludge
+// our way into binary compatibility
 class BScrollBar::Private {
 public:
 	Private(BScrollBar* scrollBar)
@@ -122,6 +123,7 @@
 	int8				fButtonDown;
 };
 
+
 // This thread is spawned when a button is initially pushed and repeatedly scrolls
 // the scrollbar by a little bit after a short delay
 int32
@@ -131,6 +133,7 @@
 	return privateData-&gt;ButtonRepeaterThread();
 }
 
+
 int32
 BScrollBar::Private::ButtonRepeaterThread()
 {
@@ -238,7 +241,7 @@
 	free(fTargetName);
 }
 
-// Instantiate
+
 BArchivable*
 BScrollBar::Instantiate(BMessage *data)
 {
@@ -247,7 +250,7 @@
 	return NULL;
 }
 
-// Archive
+
 status_t
 BScrollBar::Archive(BMessage *data, bool deep) const
 {
@@ -277,7 +280,7 @@
 	return err;
 }
 
-// AttachedToWindow
+
 void
 BScrollBar::AttachedToWindow()
 {
@@ -314,7 +317,7 @@
 
 */
 
-// SetValue
+
 void
 BScrollBar::SetValue(float value)
 {
@@ -338,14 +341,14 @@
 	ValueChanged(fValue);
 }
 
-// Value
+
 float
 BScrollBar::Value() const
 {
 	return fValue;
 }
 
-// ValueChanged
+
 void
 BScrollBar::ValueChanged(float newValue)
 {
@@ -369,7 +372,7 @@
 	SetValue(newValue);
 }
 
-// SetProportion
+
 void
 BScrollBar::SetProportion(float value)
 {
@@ -396,14 +399,14 @@
 	}
 }
 
-// Proportion
+
 float
 BScrollBar::Proportion() const
 {
 	return fProportion;
 }
 
-// SetRange
+
 void
 BScrollBar::SetRange(float min, float max)
 {
@@ -431,7 +434,7 @@
 	}
 }
 
-// GetRange
+
 void
 BScrollBar::GetRange(float *min, float *max) const
 {
@@ -441,7 +444,7 @@
 		*max = fMax;
 }
 
-// SetSteps
+
 void
 BScrollBar::SetSteps(float smallStep, float largeStep)
 {
@@ -474,7 +477,7 @@
 	// they don't
 }
 
-// GetSteps
+
 void
 BScrollBar::GetSteps(float* smallStep, float* largeStep) const
 {
@@ -484,7 +487,7 @@
 		*largeStep = fLargeStep;
 }
 
-// SetTarget
+
 void
 BScrollBar::SetTarget(BView *target)
 {
@@ -502,9 +505,9 @@
 		fTargetName = NULL;
 }
 
-// SetTarget
+
 void
-BScrollBar::SetTarget(const char *targetName)
+BScrollBar::SetTarget(const char* targetName)
 {
 	if (!targetName)
 		return;
@@ -512,39 +515,39 @@
 	if (!Window())
 		debugger(&quot;Method requires window and doesn't have one&quot;);
 
-	BView *target = Window()-&gt;FindView(targetName);
+	BView* target = Window()-&gt;FindView(targetName);
 	if (target)
 		SetTarget(target);
 }
 
-// Target
-BView *
+
+BView*
 BScrollBar::Target() const
 {
 	return fTarget;
 }
 
-// Orientation
+
 orientation
 BScrollBar::Orientation() const
 {
 	return fOrientation;
 }
 
-// MessageReceived
+
 void
-BScrollBar::MessageReceived(BMessage *msg)
+BScrollBar::MessageReceived(BMessage* message)
 {
-	switch(msg-&gt;what) {
+	switch(message-&gt;what) {
 		case B_VALUE_CHANGED:
 		{
 			int32 value;
-			if (msg-&gt;FindInt32(&quot;value&quot;, &amp;value) == B_OK)
+			if (message-&gt;FindInt32(&quot;value&quot;, &amp;value) == B_OK)
 				ValueChanged(value);
 			break;
 		}
 		default:
-			BView::MessageReceived(msg);
+			BView::MessageReceived(message);
 			break;
 	}
 }
@@ -633,7 +636,7 @@
 	}
 }
 
-// MouseUp
+
 void
 BScrollBar::MouseUp(BPoint pt)
 {
@@ -647,11 +650,12 @@
 	fPrivateData-&gt;fDoRepeat = false;
 }
 
-// MouseMoved
+
 void
 BScrollBar::MouseMoved(BPoint where, uint32 transit, const BMessage* message)
 {
-	if (!fPrivateData-&gt;fEnabled || fMin &gt;= fMax || fProportion &gt;= 1.0 || fProportion &lt; 0.0)
+	if (!fPrivateData-&gt;fEnabled || fMin &gt;= fMax || fProportion &gt;= 1.0
+		|| fProportion &lt; 0.0)
 		return;
 
 	if (fPrivateData-&gt;fButtonDown != NOARROW) {
@@ -659,7 +663,8 @@
 			SetValue(_ValueFor(where + fPrivateData-&gt;fClickOffset));
 		} else {
 			// suspend the repeating if the mouse is not over the button
-			bool repeat = _ButtonRectFor(fPrivateData-&gt;fButtonDown).Contains(where);
+			bool repeat = _ButtonRectFor(fPrivateData-&gt;fButtonDown).Contains(
+				where);
 			if (fPrivateData-&gt;fDoRepeat != repeat) {
 				fPrivateData-&gt;fDoRepeat = repeat;
 				Invalidate(_ButtonRectFor(fPrivateData-&gt;fButtonDown));
@@ -670,21 +675,24 @@
 		if (fPrivateData-&gt;fDoRepeat) {
 			_UpdateTargetValue(where);
 			// we might have to turn arround
-			if ((fValue &lt; fPrivateData-&gt;fStopValue &amp;&amp; fPrivateData-&gt;fThumbInc &lt; 0) ||
-				(fValue &gt; fPrivateData-&gt;fStopValue &amp;&amp; fPrivateData-&gt;fThumbInc &gt; 0))
+			if ((fValue &lt; fPrivateData-&gt;fStopValue
+					&amp;&amp; fPrivateData-&gt;fThumbInc &lt; 0)
+				|| (fValue &gt; fPrivateData-&gt;fStopValue
+					&amp;&amp; fPrivateData-&gt;fThumbInc &gt; 0)) {
 				fPrivateData-&gt;fThumbInc = -fPrivateData-&gt;fThumbInc;
+			}
 		}
 	}
 }
 
-// DetachedFromWindow
+
 void
 BScrollBar::DetachedFromWindow()
 {
 	BView::DetachedFromWindow();
 }
 
-// Draw
+
 void
 BScrollBar::Draw(BRect updateRect)
 {
@@ -692,7 +700,8 @@
 
 	rgb_color normal = ui_color(B_PANEL_BACKGROUND_COLOR);
 
-	// stroke a dark frame arround the entire scrollbar (independent of enabled state)
+	// stroke a dark frame arround the entire scrollbar
+	// (independent of enabled state)
 	SetHighColor(tint_color(normal, B_DARKEN_2_TINT));
 	StrokeRect(bounds);
 	bounds.InsetBy(1.0, 1.0);
@@ -735,7 +744,8 @@
 			_DrawArrowButton(ARROW_RIGHT, doubleArrows, buttonFrame, updateRect,
 				enabled, fPrivateData-&gt;fButtonDown == ARROW2);
 
-			buttonFrame.OffsetTo(bounds.right - ((bounds.Height() * 2) + 1), bounds.top);
+			buttonFrame.OffsetTo(bounds.right - ((bounds.Height() * 2) + 1),
+				bounds.top);
 			_DrawArrowButton(ARROW_LEFT, doubleArrows, buttonFrame, updateRect,
 				enabled, fPrivateData-&gt;fButtonDown == ARROW3);
 
@@ -875,11 +885,13 @@
 		// fill and additional dark lines
 		thumbBG.InsetBy(1.0, 1.0);
 		if (fOrientation == B_HORIZONTAL) {
-			BRect leftOfThumb(thumbBG.left + 1, thumbBG.top, rect.left - 1, thumbBG.bottom);
+			BRect leftOfThumb(thumbBG.left + 1, thumbBG.top, rect.left - 1,
+				thumbBG.bottom);
 			if (leftOfThumb.IsValid())
 				FillRect(leftOfThumb);
 
-			BRect rightOfThumb(rect.right + 3, thumbBG.top, thumbBG.right, thumbBG.bottom);
+			BRect rightOfThumb(rect.right + 3, thumbBG.top, thumbBG.right,
+				thumbBG.bottom);
 			if (rightOfThumb.IsValid())
 				FillRect(rightOfThumb);
 
@@ -987,36 +999,36 @@
 	}
 }
 
-// FrameMoved
+
 void
 BScrollBar::FrameMoved(BPoint newPosition)
 {
 	BView::FrameMoved(newPosition);
 }
 
-// FrameResized
+
 void
-BScrollBar::FrameResized(float new_width, float new_height)
+BScrollBar::FrameResized(float newWidth, float newHeight)
 {
 	_UpdateThumbFrame();
 }
 
-// ResolveSpecifier
+
 BHandler*
-BScrollBar::ResolveSpecifier(BMessage *msg, int32 index,
-		BMessage *specifier, int32 form, const char *property)
+BScrollBar::ResolveSpecifier(BMessage* message, int32 index,
+	BMessage* specifier, int32 form, const char *property)
 {
-	return BView::ResolveSpecifier(msg, index, specifier, form, property);
+	return BView::ResolveSpecifier(message, index, specifier, form, property);
 }
 
-// ResizeToPreferred
+
 void
 BScrollBar::ResizeToPreferred()
 {
 	BView::ResizeToPreferred();
 }
 
-// GetPreferredSize
+
 void
 BScrollBar::GetPreferredSize(float* _width, float* _height)
 {
@@ -1033,41 +1045,42 @@
 	}
 }
 
-// MakeFocus
+
 void
 BScrollBar::MakeFocus(bool state)
 {
 	BView::MakeFocus(state);
 }
 
-// AllAttached
+
 void
 BScrollBar::AllAttached()
 {
 	BView::AllAttached();
 }
 
-// AllDetached
+
 void
 BScrollBar::AllDetached()
 {
 	BView::AllDetached();
 }
 
-// GetSupportedSuites
+
 status_t
 BScrollBar::GetSupportedSuites(BMessage *message)
 {
 	return BView::GetSupportedSuites(message);
 }
 
-// Perform
+
 status_t
-BScrollBar::Perform(perform_code d, void *arg)
+BScrollBar::Perform(perform_code d, void* arg)
 {
 	return BView::Perform(d, arg);
 }
 
+
 #if DISABLES_ON_WINDOW_DEACTIVATION
 void
 BScrollBar::WindowActivated(bool active)
@@ -1077,19 +1090,21 @@
 }
 #endif // DISABLES_ON_WINDOW_DEACTIVATION
 
+
 void BScrollBar::_ReservedScrollBar1() {}
 void BScrollBar::_ReservedScrollBar2() {}
 void BScrollBar::_ReservedScrollBar3() {}
 void BScrollBar::_ReservedScrollBar4() {}
 
-// operator=
-BScrollBar &amp;
-BScrollBar::operator=(const BScrollBar &amp;)
+
+
+BScrollBar&amp;
+BScrollBar::operator=(const BScrollBar&amp;)
 {
 	return *this;
 }
 
-// _DoubleArrows
+
 bool
 BScrollBar::_DoubleArrows() const
 {
@@ -1107,7 +1122,7 @@
 	}
 }
 
-// _UpdateThumbFrame
+
 void
 BScrollBar::_UpdateThumbFrame()
 {
@@ -1158,7 +1173,8 @@
 	thumbSize--;
 
 	// the thumb can be scrolled within the remaining area &quot;maxSize - thumbSize&quot;
-	float offset = floorf(((fValue - fMin) / (fMax - fMin + 1.0)) * (maxSize - thumbSize));
+	float offset = floorf(((fValue - fMin) / (fMax - fMin + 1.0))
+		* (maxSize - thumbSize));
 
 	if (_DoubleArrows()) {
 		offset += buttonSize * 2;
@@ -1169,15 +1185,18 @@
 	offset++;
 
 	if (fOrientation == B_VERTICAL) {
-		fPrivateData-&gt;fThumbFrame.bottom = fPrivateData-&gt;fThumbFrame.top + thumbSize;
+		fPrivateData-&gt;fThumbFrame.bottom = fPrivateData-&gt;fThumbFrame.top
+			+ thumbSize;
 		fPrivateData-&gt;fThumbFrame.OffsetBy(0.0, offset);
 	} else {
-		fPrivateData-&gt;fThumbFrame.right = fPrivateData-&gt;fThumbFrame.left + thumbSize;
+		fPrivateData-&gt;fThumbFrame.right = fPrivateData-&gt;fThumbFrame.left
+			+ thumbSize;
 		fPrivateData-&gt;fThumbFrame.OffsetBy(offset, 0.0);
 	}
 
 	if (Window()) {
-		BRect invalid = oldFrame.IsValid() ? oldFrame | fPrivateData-&gt;fThumbFrame
+		BRect invalid = oldFrame.IsValid() ?
+			oldFrame | fPrivateData-&gt;fThumbFrame
 			: fPrivateData-&gt;fThumbFrame;
 		// account for those two dark lines
 		if (fOrientation == B_HORIZONTAL)
@@ -1188,7 +1207,7 @@
 	}
 }
 
-// _ValueFor
+
 float
 BScrollBar::_ValueFor(BPoint where) const
 {
@@ -1234,7 +1253,7 @@
 		return ceilf(value - 0.5);
 }
 
-// _ButtonFor
+
 int32
 BScrollBar::_ButtonFor(BPoint where) const
 {
@@ -1284,7 +1303,7 @@
 	return NOARROW;
 }
 
-// _ButtonRectFor
+
 BRect
 BScrollBar::_ButtonRectFor(int32 button) const
 {
@@ -1334,7 +1353,7 @@
 	return rect;
 }
 
-// _UpdateTargetValue
+
 void
 BScrollBar::_UpdateTargetValue(BPoint where)
 {
@@ -1347,7 +1366,7 @@
 	}
 }
 
-// _UpdateArrowButtons
+
 void
 BScrollBar::_UpdateArrowButtons()
 {
@@ -1368,22 +1387,26 @@
 	}
 }
 
-// control_scrollbar
+
 status_t
 control_scrollbar(scroll_bar_info *info, BScrollBar *bar)
 {
 	if (!bar || !info)
 		return B_BAD_VALUE;
 
-	if (bar-&gt;fPrivateData-&gt;fScrollBarInfo.double_arrows != info-&gt;double_arrows) {
+	if (bar-&gt;fPrivateData-&gt;fScrollBarInfo.double_arrows
+		!= info-&gt;double_arrows) {
 		bar-&gt;fPrivateData-&gt;fScrollBarInfo.double_arrows = info-&gt;double_arrows;
 
 		int8 multiplier = (info-&gt;double_arrows) ? 1 : -1;
 
-		if (bar-&gt;fOrientation == B_VERTICAL)
-			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(0, multiplier * B_H_SCROLL_BAR_HEIGHT);
-		else
-			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(multiplier * B_V_SCROLL_BAR_WIDTH, 0);
+		if (bar-&gt;fOrientation == B_VERTICAL) {
+			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(0, multiplier
+				* B_H_SCROLL_BAR_HEIGHT);
+		} else {
+			bar-&gt;fPrivateData-&gt;fThumbFrame.OffsetBy(multiplier
+				* B_V_SCROLL_BAR_WIDTH, 0);
+		}
 	}
 
 	bar-&gt;fPrivateData-&gt;fScrollBarInfo.proportional = info-&gt;proportional;
@@ -1406,7 +1429,7 @@
 	return B_OK;
 }
 
-// _DrawDisabledBackground
+
 void
 BScrollBar::_DrawDisabledBackground(BRect area,
 									const rgb_color&amp; light,
@@ -1473,7 +1496,7 @@
 	}
 }
 
-// _DrawArrowButton
+
 void
 BScrollBar::_DrawArrowButton(int32 direction, bool doubleArrows, BRect r,
 							 const BRect&amp; updateRect, bool enabled, bool down)
@@ -1491,13 +1514,16 @@
 		arrow = tint_color(c, B_DARKEN_MAX_TINT);
 
 	} else {
-		// Add a usability perk - disable buttons if they would not do anything -
-		// like a left arrow if the value==fMin
+		// Add a usability perk - disable buttons if they would not do anything
+		// - like a left arrow if the value == fMin
 // NOTE: disabled because of too much visual noise/distraction
-/*		if ((direction == ARROW_LEFT || direction == ARROW_UP) &amp;&amp; (fValue == fMin) )
+/*		if ((direction == ARROW_LEFT || direction == ARROW_UP)
+			&amp;&amp; (fValue == fMin)) {
 			use_enabled_colors = false;
-		else if ((direction == ARROW_RIGHT || direction == ARROW_DOWN) &amp;&amp; (fValue == fMax) )
-			use_enabled_colors = false;*/
+		} else if ((direction == ARROW_RIGHT || direction == ARROW_DOWN)
+			&amp;&amp; (fValue == fMax)) {
+			use_enabled_colors = false;
+		}*/
 
 		if (enabled) {
 			light = tint_color(c, B_LIGHTEN_MAX_TINT);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007543.html">[Haiku-commits] r24838 - haiku/trunk/src/kits/interface
</A></li>
	<LI>Next message: <A HREF="007545.html">[Haiku-commits] r24840 - haiku/trunk/src/kits/interface
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7544">[ date ]</a>
              <a href="thread.html#7544">[ thread ]</a>
              <a href="subject.html#7544">[ subject ]</a>
              <a href="author.html#7544">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
