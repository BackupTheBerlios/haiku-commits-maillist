<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r24816 - in haiku/trunk: build/jam	headers/os/drivers headers/private/fs_shell	headers/private/kernel src/add-ons/kernel/file_systems/bfs	src/system/kernel/fs src/system/libroot/posix/sys src/tools/fs_shell
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24816%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers%20headers/private/fs_shell%0A%09headers/private/kernel%20src/add-ons/kernel/file_systems/bfs%0A%09src/system/kernel/fs%20src/system/libroot/posix/sys%20src/tools/fs_shell&In-Reply-To=%3C200804052305.m35N5KpM020495%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007516.html">
   <LINK REL="Next"  HREF="007519.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r24816 - in haiku/trunk: build/jam	headers/os/drivers headers/private/fs_shell	headers/private/kernel src/add-ons/kernel/file_systems/bfs	src/system/kernel/fs src/system/libroot/posix/sys src/tools/fs_shell</H1>
    <B>bonefish at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24816%20-%20in%20haiku/trunk%3A%20build/jam%0A%09headers/os/drivers%20headers/private/fs_shell%0A%09headers/private/kernel%20src/add-ons/kernel/file_systems/bfs%0A%09src/system/kernel/fs%20src/system/libroot/posix/sys%20src/tools/fs_shell&In-Reply-To=%3C200804052305.m35N5KpM020495%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r24816 - in haiku/trunk: build/jam	headers/os/drivers headers/private/fs_shell	headers/private/kernel src/add-ons/kernel/file_systems/bfs	src/system/kernel/fs src/system/libroot/posix/sys src/tools/fs_shell">bonefish at mail.berlios.de
       </A><BR>
    <I>Sun Apr  6 01:05:20 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="007516.html">[Haiku-commits] r24815 -	haiku/trunk/src/system/kernel/disk_device_manager
</A></li>
        <LI>Next message: <A HREF="007519.html">[Haiku-commits] r24817 - haiku/trunk/src/system/kernel/fs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7517">[ date ]</a>
              <a href="thread.html#7517">[ thread ]</a>
              <a href="subject.html#7517">[ subject ]</a>
              <a href="author.html#7517">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: bonefish
Date: 2008-04-06 01:05:16 +0200 (Sun, 06 Apr 2008)
New Revision: 24816
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=24816&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=24816&amp;view=rev</A>

Added:
   haiku/trunk/src/system/kernel/fs/fifo.h
Modified:
   haiku/trunk/build/jam/HaikuImage
   haiku/trunk/headers/os/drivers/fs_interface.h
   haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h
   haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
   haiku/trunk/headers/private/kernel/syscalls.h
   haiku/trunk/headers/private/kernel/vfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Volume.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/bfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/kernel_interface.cpp
   haiku/trunk/src/system/kernel/fs/devfs.cpp
   haiku/trunk/src/system/kernel/fs/pipefs.cpp
   haiku/trunk/src/system/kernel/fs/rootfs.cpp
   haiku/trunk/src/system/kernel/fs/vfs.cpp
   haiku/trunk/src/system/libroot/posix/sys/mkfifo.c
   haiku/trunk/src/tools/fs_shell/vfs.cpp
Log:
* Reorganized the FS interface a little:
  - Moved most file_system_module_info hooks into separate structures.
    Those that operate on mounted volumes to fs_volume_ops, those
    operating on a vnode to fs_vnode_ops.
  - Got rid of the fs_volume, fs_cookie, fs_vnode typedefs. We use void*
    again.
  - Instead of a void* volume and node cookie hooks are passed a
    fs_volume and fs_vnode structure pointer, which contain the cookie
    and an ops pointer (fs_volume a few more things).
  - The VFS {new,publish,get,...}_vnode() functions take a fs_volume*
    instead of the volume ID. So does vfs_get_fs_node_from_path().
  - Added type and flags arguments to publish_vnode() and the
    get_vnode() hook and removed the type argument from lookup() hook.
    Added vnode::type using formerly unused bits to store the node type.
    Simplified a few things in the VFS due to the now always available
    node type.
  - Added fs_volume_ops::{create,delete}_sub_vnode() and
    fs_vnode_ops::get_super_vnode() hooks. They are used to support file
    system layers, e.g. allowing to extend an FS not supporting BeOS
    attribute with attribute support. Needs some more work in the VFS.
  - Added fs_vnode_ops::create_special_node() hook for creating special
    nodes (e.g. FIFOs).
* Adjusted the built-in file systems and BFS according to the interface
  changes. Removed all other FSs from the image for the time being.
  We'll see whether further API changes are necessary before porting
  them.
* Adjusted the bfs_shell accordingly.
* Implemented create_special_node() in rootfs to support special nodes.
* Added support for FIFOs:
  - Added syscall _kern_create_fifo() (used by mkfifo()), which creates
    a special node (type S_IFIFO) in the respective file system.
  - When a special node is published the VFS creates a respective sub
    node. Currently only FIFOs are supported.
  - Added a little support for FIFO subnodes by using functionality from
    the pipefs.
  - Added mkfifo to the image. It can create FIFOs in the rootfs, but
    the FIFOs aren't really usable ATM, since they still work like
    pipes, i.e. readers and writers need to have them open at the same
    time.
* Some smaller changes in the VFS:
  - Made the *_CALL macros nicer to use (vargs).
  - Refactored FS entry lookup into new function lookup_dir_entry().
  - create_vnode() no longer just calls the FS create() hook. First it
    looks up the entry and uses open_vnode(), if it already exists. This
    is necessary for two reasons: 1) The FS might not support create()
    while still allowing to open() entries. 2) When the FS has other
    layers on to of it (or the respective node) it might not be
    responsible for opening the node.


Modified: haiku/trunk/build/jam/HaikuImage
===================================================================
--- haiku/trunk/build/jam/HaikuImage	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/build/jam/HaikuImage	2008-04-05 23:05:16 UTC (rev 24816)
@@ -35,7 +35,7 @@
 	ideinfo idestatus ifconfig &lt;bin&gt;install installsound iroster isvolume join
 	keymap kill less lessecho lesskey link listarea listattr listdev listimage
 	listport listres listsem ln locate logger login logname ls lsindex m4 make
-	makebootable md5sum merge mimeset mkdos mkdir mkindex modifiers mount
+	makebootable md5sum merge mimeset mkdos mkdir mkfifo mkindex modifiers mount
 	mount_nfs mountvolume mv nc netstat nl nohup od open paste patch pathchk pc
 	ping play playfile playsound playwav pr prio printenv printf ps ptx pwd
 	query quit readlink release renice rescan rlog rm rmattr rmindex rmdir roster route
@@ -134,7 +134,8 @@
 BEOS_ADD_ONS_BUS_MANAGERS = pci $(X86_ONLY)ps2 $(X86_ONLY)isa ide scsi
 	config_manager agp_gart usb firewire
 ;
-BEOS_ADD_ONS_FILE_SYSTEMS = bfs cdda fat googlefs iso9660 nfs $(GPL_ONLY)ntfs ;
+BEOS_ADD_ONS_FILE_SYSTEMS = bfs ;
+#cdda fat googlefs iso9660 nfs $(GPL_ONLY)ntfs ;
 
 
 # modules

Modified: haiku/trunk/headers/os/drivers/fs_interface.h
===================================================================
--- haiku/trunk/headers/os/drivers/fs_interface.h	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/headers/os/drivers/fs_interface.h	2008-04-05 23:05:16 UTC (rev 24816)
@@ -21,11 +21,6 @@
 struct fs_info;
 struct select_sync;
 
-/* the file system's private data structures */
-typedef void *fs_volume;
-typedef void *fs_cookie;
-typedef void *fs_vnode;
-
 /* additional flags passed to write_stat() (see NodeMonitor.h for the others) */
 // NOTE: Changing the constants here or in NodeMonitor.h will break
 // src/kits/storage/LibBeAdapter.cpp:_kern_write_stat().
@@ -42,162 +37,217 @@
 
 #define	B_CURRENT_FS_API_VERSION &quot;/v1&quot;
 
+// flags for publish_vnode() and fs_volume_ops::get_vnode()
+#define B_VNODE_PUBLISH_REMOVED					0x01
+#define B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE	0x02
+
+
 #ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
-typedef struct file_system_module_info {
-	struct module_info	info;
-	const char*			pretty_name;
-	uint32				flags;	// DDM flags
+typedef struct fs_volume fs_volume;
+typedef struct fs_volume_ops fs_volume_ops;
+typedef struct fs_vnode fs_vnode;
+typedef struct fs_vnode_ops fs_vnode_ops;
 
-	/* scanning (the device is write locked) */
-	float (*identify_partition)(int fd, partition_data *partition,
-				void **cookie);
-	status_t (*scan_partition)(int fd, partition_data *partition,
-				void *cookie);
-	void (*free_identify_partition_cookie)(partition_data *partition,
-				void *cookie);
-	void (*free_partition_content_cookie)(partition_data *partition);
 
-	/* general operations */
-	status_t (*mount)(dev_t id, const char *device, uint32 flags,
-				const char *args, fs_volume *_fs, ino_t *_rootVnodeID);
-	status_t (*unmount)(fs_volume fs);
+struct fs_volume {
+	dev_t			id;
+	int32			layer;
+	void*			private_volume;
+	fs_volume_ops*	ops;
+	fs_volume*		sub_volume;
+	fs_volume*		super_volume;
+};
 
-	status_t (*read_fs_info)(fs_volume fs, struct fs_info *info);
-	status_t (*write_fs_info)(fs_volume fs, const struct fs_info *info,
+struct fs_vnode {
+	void*			private_node;
+	fs_vnode_ops*	ops;
+};
+
+struct fs_volume_ops {
+	status_t (*unmount)(fs_volume *volume);
+
+	status_t (*read_fs_info)(fs_volume *volume, struct fs_info *info);
+	status_t (*write_fs_info)(fs_volume *volume, const struct fs_info *info,
 				uint32 mask);
-	status_t (*sync)(fs_volume fs);
+	status_t (*sync)(fs_volume *volume);
 
+	status_t (*get_vnode)(fs_volume *volume, ino_t id, fs_vnode *vnode,
+				int *_type, uint32 *_flags, bool reenter);
+
+	/* index directory &amp; index operations */
+	status_t (*open_index_dir)(fs_volume *volume, void **cookie);
+	status_t (*close_index_dir)(fs_volume *volume, void *cookie);
+	status_t (*free_index_dir_cookie)(fs_volume *volume, void *cookie);
+	status_t (*read_index_dir)(fs_volume *volume, void *cookie,
+				struct dirent *buffer, size_t bufferSize, uint32 *_num);
+	status_t (*rewind_index_dir)(fs_volume *volume, void *cookie);
+
+	status_t (*create_index)(fs_volume *volume, const char *name, uint32 type,
+				uint32 flags);
+	status_t (*remove_index)(fs_volume *volume, const char *name);
+	status_t (*read_index_stat)(fs_volume *volume, const char *name,
+				struct stat *stat);
+
+	/* query operations */
+	status_t (*open_query)(fs_volume *volume, const char *query, uint32 flags,
+				port_id port, uint32 token, void **_cookie);
+	status_t (*close_query)(fs_volume *volume, void *cookie);
+	status_t (*free_query_cookie)(fs_volume *volume, void *cookie);
+	status_t (*read_query)(fs_volume *volume, void *cookie,
+				struct dirent *buffer, size_t bufferSize, uint32 *_num);
+	status_t (*rewind_query)(fs_volume *volume, void *cookie);
+
+	/* support for FS layers */
+	status_t (*create_sub_vnode)(fs_volume *volume, ino_t id, fs_vnode *vnode);
+	status_t (*delete_sub_vnode)(fs_volume *volume, fs_vnode *vnode);
+};
+
+struct fs_vnode_ops {
 	/* vnode operations */
-	status_t (*lookup)(fs_volume fs, fs_vnode dir, const char *name,
-				ino_t *_id, int *_type);
-	status_t (*get_vnode_name)(fs_volume fs, fs_vnode vnode, char *buffer,
+	status_t (*lookup)(fs_volume *volume, fs_vnode *dir, const char *name,
+				ino_t *_id);
+	status_t (*get_vnode_name)(fs_volume *volume, fs_vnode *vnode, char *buffer,
 				size_t bufferSize);
 
-	status_t (*get_vnode)(fs_volume fs, ino_t id, fs_vnode *_vnode,
-				bool reenter);
-	status_t (*put_vnode)(fs_volume fs, fs_vnode vnode, bool reenter);
-	status_t (*remove_vnode)(fs_volume fs, fs_vnode vnode, bool reenter);
+	status_t (*put_vnode)(fs_volume *volume, fs_vnode *vnode, bool reenter);
+	status_t (*remove_vnode)(fs_volume *volume, fs_vnode *vnode, bool reenter);
 
 	/* VM file access */
-	bool (*can_page)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*read_pages)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	bool (*can_page)(fs_volume *volume, fs_vnode *vnode, void *cookie);
+	status_t (*read_pages)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes,
 				bool reenter);
-	status_t (*write_pages)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
-				off_t pos, const iovec *vecs, size_t count, size_t *_numBytes,
-				bool reenter);
+	status_t (*write_pages)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie, off_t pos, const iovec *vecs, size_t count,
+				size_t *_numBytes, bool reenter);
 
 	/* cache file access */
-	status_t (*get_file_map)(fs_volume fs, fs_vnode vnode, off_t offset,
+	status_t (*get_file_map)(fs_volume *volume, fs_vnode *vnode, off_t offset,
 				size_t size, struct file_io_vec *vecs, size_t *_count);
 
 	/* common operations */
-	status_t (*ioctl)(fs_volume fs, fs_vnode vnode, fs_cookie cookie, ulong op,
-				void *buffer, size_t length);
-	status_t (*set_flags)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*ioctl)(fs_volume *volume, fs_vnode *vnode, void *cookie,
+				ulong op, void *buffer, size_t length);
+	status_t (*set_flags)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				int flags);
-	status_t (*select)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*select)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				uint8 event, uint32 ref, selectsync *sync);
-	status_t (*deselect)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*deselect)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				uint8 event, selectsync *sync);
-	status_t (*fsync)(fs_volume fs, fs_vnode vnode);
+	status_t (*fsync)(fs_volume *volume, fs_vnode *vnode);
 
-	status_t (*read_symlink)(fs_volume fs, fs_vnode link, char *buffer,
+	status_t (*read_symlink)(fs_volume *volume, fs_vnode *link, char *buffer,
 				size_t *_bufferSize);
-	status_t (*create_symlink)(fs_volume fs, fs_vnode dir, const char *name,
-				const char *path, int mode);
+	status_t (*create_symlink)(fs_volume *volume, fs_vnode *dir,
+				const char *name, const char *path, int mode);
 
-	status_t (*link)(fs_volume fs, fs_vnode dir, const char *name,
-				fs_vnode vnode);
-	status_t (*unlink)(fs_volume fs, fs_vnode dir, const char *name);
-	status_t (*rename)(fs_volume fs, fs_vnode fromDir, const char *fromName,
-				fs_vnode toDir, const char *toName);
+	status_t (*link)(fs_volume *volume, fs_vnode *dir, const char *name,
+				fs_vnode *vnode);
+	status_t (*unlink)(fs_volume *volume, fs_vnode *dir, const char *name);
+	status_t (*rename)(fs_volume *volume, fs_vnode *fromDir,
+				const char *fromName, fs_vnode *toDir, const char *toName);
 
-	status_t (*access)(fs_volume fs, fs_vnode vnode, int mode);
-	status_t (*read_stat)(fs_volume fs, fs_vnode vnode, struct stat *stat);
-	status_t (*write_stat)(fs_volume fs, fs_vnode vnode,
+	status_t (*access)(fs_volume *volume, fs_vnode *vnode, int mode);
+	status_t (*read_stat)(fs_volume *volume, fs_vnode *vnode,
+				struct stat *stat);
+	status_t (*write_stat)(fs_volume *volume, fs_vnode *vnode,
 				const struct stat *stat, uint32 statMask);
 
 	/* file operations */
-	status_t (*create)(fs_volume fs, fs_vnode dir, const char *name,
-				int openMode, int perms, fs_cookie *_cookie,
+	status_t (*create)(fs_volume *volume, fs_vnode *dir, const char *name,
+				int openMode, int perms, void **_cookie,
 				ino_t *_newVnodeID);
-	status_t (*open)(fs_volume fs, fs_vnode vnode, int openMode,
-				fs_cookie *_cookie);
-	status_t (*close)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*free_cookie)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*read)(fs_volume fs, fs_vnode vnode, fs_cookie cookie, off_t pos,
-				void *buffer, size_t *length);
-	status_t (*write)(fs_volume fs, fs_vnode vnode, fs_cookie cookie, off_t pos,
-				const void *buffer, size_t *length);
+	status_t (*open)(fs_volume *volume, fs_vnode *vnode, int openMode,
+				void **_cookie);
+	status_t (*close)(fs_volume *volume, fs_vnode *vnode, void *cookie);
+	status_t (*free_cookie)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*read)(fs_volume *volume, fs_vnode *vnode, void *cookie,
+				off_t pos, void *buffer, size_t *length);
+	status_t (*write)(fs_volume *volume, fs_vnode *vnode, void *cookie,
+				off_t pos, const void *buffer, size_t *length);
 
 	/* directory operations */
-	status_t (*create_dir)(fs_volume fs, fs_vnode parent, const char *name,
-				int perms, ino_t *_newVnodeID);
-	status_t (*remove_dir)(fs_volume fs, fs_vnode parent, const char *name);
-	status_t (*open_dir)(fs_volume fs, fs_vnode vnode, fs_cookie *_cookie);
-	status_t (*close_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*free_dir_cookie)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*read_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*create_dir)(fs_volume *volume, fs_vnode *parent,
+				const char *name, int perms, ino_t *_newVnodeID);
+	status_t (*remove_dir)(fs_volume *volume, fs_vnode *parent,
+				const char *name);
+	status_t (*open_dir)(fs_volume *volume, fs_vnode *vnode,
+				void **_cookie);
+	status_t (*close_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie);
+	status_t (*free_dir_cookie)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*read_dir)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				struct dirent *buffer, size_t bufferSize, uint32 *_num);
-	status_t (*rewind_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
+	status_t (*rewind_dir)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
 
 	/* attribute directory operations */
-	status_t (*open_attr_dir)(fs_volume fs, fs_vnode vnode, fs_cookie *_cookie);
-	status_t (*close_attr_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*free_attr_dir_cookie)(fs_volume fs, fs_vnode vnode,
-				fs_cookie cookie);
-	status_t (*read_attr_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
-				struct dirent *buffer, size_t bufferSize, uint32 *_num);
-	status_t (*rewind_attr_dir)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
+	status_t (*open_attr_dir)(fs_volume *volume, fs_vnode *vnode,
+				void **_cookie);
+	status_t (*close_attr_dir)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*free_attr_dir_cookie)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*read_attr_dir)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie, struct dirent *buffer, size_t bufferSize,
+				uint32 *_num);
+	status_t (*rewind_attr_dir)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
 
 	/* attribute operations */
-	status_t (*create_attr)(fs_volume fs, fs_vnode vnode, const char *name,
-				uint32 type, int openMode, fs_cookie *_cookie);
-	status_t (*open_attr)(fs_volume fs, fs_vnode vnode, const char *name,
-				int openMode, fs_cookie *_cookie);
-	status_t (*close_attr)(fs_volume fs, fs_vnode vnode, fs_cookie cookie);
-	status_t (*free_attr_cookie)(fs_volume fs, fs_vnode vnode,
-				fs_cookie cookie);
-	status_t (*read_attr)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*create_attr)(fs_volume *volume, fs_vnode *vnode,
+				const char *name, uint32 type, int openMode,
+				void **_cookie);
+	status_t (*open_attr)(fs_volume *volume, fs_vnode *vnode, const char *name,
+				int openMode, void **_cookie);
+	status_t (*close_attr)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*free_attr_cookie)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie);
+	status_t (*read_attr)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				off_t pos, void *buffer, size_t *length);
-	status_t (*write_attr)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
+	status_t (*write_attr)(fs_volume *volume, fs_vnode *vnode, void *cookie,
 				off_t pos, const void *buffer, size_t *length);
 
-	status_t (*read_attr_stat)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
-				struct stat *stat);
-	status_t (*write_attr_stat)(fs_volume fs, fs_vnode vnode, fs_cookie cookie,
-				const struct stat *stat, int statMask);
-	status_t (*rename_attr)(fs_volume fs, fs_vnode fromVnode,
-				const char *fromName, fs_vnode toVnode, const char *toName);
-	status_t (*remove_attr)(fs_volume fs, fs_vnode vnode, const char *name);
+	status_t (*read_attr_stat)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie, struct stat *stat);
+	status_t (*write_attr_stat)(fs_volume *volume, fs_vnode *vnode,
+				void *cookie, const struct stat *stat, int statMask);
+	status_t (*rename_attr)(fs_volume *volume, fs_vnode *fromVnode,
+				const char *fromName, fs_vnode *toVnode, const char *toName);
+	status_t (*remove_attr)(fs_volume *volume, fs_vnode *vnode,
+				const char *name);
 
-	/* index directory &amp; index operations */
-	status_t (*open_index_dir)(fs_volume fs, fs_cookie *cookie);
-	status_t (*close_index_dir)(fs_volume fs, fs_cookie cookie);
-	status_t (*free_index_dir_cookie)(fs_volume fs, fs_cookie cookie);
-	status_t (*read_index_dir)(fs_volume fs, fs_cookie cookie,
-				struct dirent *buffer, size_t bufferSize, uint32 *_num);
-	status_t (*rewind_index_dir)(fs_volume fs, fs_cookie cookie);
+	/* support for node and FS layers */
+	status_t (*create_special_node)(fs_volume *volume, fs_vnode *dir,
+				const char *name, fs_vnode *subVnode, mode_t mode, uint32 flags,
+				fs_vnode *_superVnode, ino_t *_nodeID);
+	status_t (*get_super_vnode)(fs_volume *volume, fs_vnode *vnode,
+				fs_volume *superVolume, fs_vnode *superVnode);
+};
 
-	status_t (*create_index)(fs_volume fs, const char *name, uint32 type,
-				uint32 flags);
-	status_t (*remove_index)(fs_volume fs, const char *name);
-	status_t (*read_index_stat)(fs_volume fs, const char *name,
-				struct stat *stat);
+typedef struct file_system_module_info {
+	struct module_info	info;
+	const char*			pretty_name;
+	uint32				flags;	// DDM flags
 
-	/* query operations */
-	status_t (*open_query)(fs_volume fs, const char *query, uint32 flags,
-				port_id port, uint32 token, fs_cookie *_cookie);
-	status_t (*close_query)(fs_volume fs, fs_cookie cookie);
-	status_t (*free_query_cookie)(fs_volume fs, fs_cookie cookie);
-	status_t (*read_query)(fs_volume fs, fs_cookie cookie,
-				struct dirent *buffer, size_t bufferSize, uint32 *_num);
-	status_t (*rewind_query)(fs_volume fs, fs_cookie cookie);
+	/* scanning (the device is write locked) */
+	float (*identify_partition)(int fd, partition_data *partition,
+				void **cookie);
+	status_t (*scan_partition)(int fd, partition_data *partition,
+				void *cookie);
+	void (*free_identify_partition_cookie)(partition_data *partition,
+				void *cookie);
+	void (*free_partition_content_cookie)(partition_data *partition);
 
+	/* general operations */
+	status_t (*mount)(fs_volume *volume, const char *device, uint32 flags,
+				const char *args, ino_t *_rootVnodeID);
+
 	/* capability querying (the device is read locked) */
 	uint32 (*get_supported_operations)(partition_data* partition, uint32 mask);
 
@@ -233,17 +283,19 @@
 
 
 /* file system add-ons only prototypes */
-extern status_t new_vnode(dev_t mountID, ino_t vnodeID,
-					fs_vnode privateNode);
-extern status_t publish_vnode(dev_t mountID, ino_t vnodeID,
-					fs_vnode privateNode);
-extern status_t get_vnode(dev_t mountID, ino_t vnodeID,
-					fs_vnode *_privateNode);
-extern status_t put_vnode(dev_t mountID, ino_t vnodeID);
-extern status_t remove_vnode(dev_t mountID, ino_t vnodeID);
-extern status_t unremove_vnode(dev_t mountID, ino_t vnodeID);
-extern status_t get_vnode_removed(dev_t mountID, ino_t vnodeID,
-					bool* removed);
+extern status_t new_vnode(fs_volume *volume, ino_t vnodeID, void *privateNode,
+					fs_vnode_ops *ops);
+extern status_t publish_vnode(fs_volume *volume, ino_t vnodeID,
+					void *privateNode, fs_vnode_ops *ops, int type,
+					uint32 flags);
+extern status_t get_vnode(fs_volume *volume, ino_t vnodeID,
+					void **_privateNode);
+extern status_t put_vnode(fs_volume *volume, ino_t vnodeID);
+extern status_t remove_vnode(fs_volume *volume, ino_t vnodeID);
+extern status_t unremove_vnode(fs_volume *volume, ino_t vnodeID);
+extern status_t get_vnode_removed(fs_volume *volume, ino_t vnodeID,
+					bool *removed);
+
 extern status_t read_pages(int fd, off_t pos, const struct iovec *vecs,
 					size_t count, size_t *_numBytes, bool fsReenter);
 extern status_t write_pages(int fd, off_t pos, const struct iovec *vecs,
@@ -257,10 +309,6 @@
 					const struct iovec *vecs, size_t vecCount,
 					uint32 *_vecIndex, size_t *_vecOffset, size_t *_bytes);
 
-// Deprecated! Will disappear soon!
-extern status_t notify_listener(int op, dev_t device, ino_t parentNode,
-					ino_t toParentNode, ino_t node, const char *name);
-
 extern status_t notify_entry_created(dev_t device, ino_t directory,
 					const char *name, ino_t node);
 extern status_t notify_entry_removed(dev_t device, ino_t directory,

Modified: haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/headers/private/fs_shell/fssh_api_wrapper.h	2008-04-05 23:05:16 UTC (rev 24816)
@@ -870,11 +870,6 @@
 #define mount_id	fssh_mount_id
 #define vnode_id	fssh_vnode_id
 
-/* the file system's private data structures */
-#define fs_volume	fssh_fs_volume
-#define fs_cookie	fssh_fs_cookie
-#define fs_vnode	fssh_fs_vnode
-
 /* additional flags passed to write_stat() */
 #define B_STAT_SIZE_INSECURE	FSSH_B_STAT_SIZE_INSECURE
 
@@ -885,6 +880,14 @@
 
 #define B_CURRENT_FS_API_VERSION	FSSH_B_CURRENT_FS_API_VERSION
 
+// flags for publish_vnode() and fs_volume_ops::get_vnode()
+#define B_VNODE_PUBLISH_REMOVED					FSSH_B_VNODE_PUBLISH_REMOVED
+#define B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE	FSSH_B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE
+
+#define fs_volume				fssh_fs_volume
+#define fs_volume_ops			fssh_fs_volume_ops
+#define fs_vnode				fssh_fs_vnode
+#define fs_vnode_ops			fssh_fs_vnode_ops
 #define file_system_module_info	fssh_file_system_module_info
 
 

Modified: haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h
===================================================================
--- haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/headers/private/fs_shell/fssh_fs_interface.h	2008-04-05 23:05:16 UTC (rev 24816)
@@ -24,9 +24,7 @@
 typedef fssh_ino_t fssh_vnode_id;
 
 /* the file system's private data structures */
-typedef void *fssh_fs_volume;
 typedef void *fssh_fs_cookie;
-typedef void *fssh_fs_vnode;
 
 /* additional flags passed to write_stat() */
 #define FSSH_B_STAT_SIZE_INSECURE	0x2000
@@ -41,197 +39,250 @@
 
 #define	FSSH_B_CURRENT_FS_API_VERSION &quot;/v1&quot;
 
+// flags for publish_vnode() and fs_volume_ops::get_vnode()
+#define FSSH_B_VNODE_PUBLISH_REMOVED				0x01
+#define FSSH_B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE	0x02
+
+
 #ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
-typedef struct fssh_file_system_module_info {
-	struct fssh_module_info	info;
-	const char*				pretty_name;
-	uint32_t				flags;	// DDM flags
+typedef struct fssh_fs_volume fssh_fs_volume;
+typedef struct fssh_fs_volume_ops fssh_fs_volume_ops;
+typedef struct fssh_fs_vnode fssh_fs_vnode;
+typedef struct fssh_fs_vnode_ops fssh_fs_vnode_ops;
 
-	/* scanning (the device is write locked) */
-	float (*identify_partition)(int fd, fssh_partition_data *partition,
-				void **cookie);
-	fssh_status_t (*scan_partition)(int fd, fssh_partition_data *partition,
-				void *cookie);
-	void (*free_identify_partition_cookie)(fssh_partition_data *partition,
-				void *cookie);
-	void (*free_partition_content_cookie)(fssh_partition_data *partition);
 
-	/* general operations */
-	fssh_status_t (*mount)(fssh_mount_id id, const char *device, uint32_t flags,
-				const char *args, fssh_fs_volume *_fs,
-				fssh_vnode_id *_rootVnodeID);
-	fssh_status_t (*unmount)(fssh_fs_volume fs);
+struct fssh_fs_volume {
+	fssh_dev_t			id;
+	int32_t				layer;
+	void*				private_volume;
+	fssh_fs_volume_ops*	ops;
+	fssh_fs_volume*		sub_volume;
+	fssh_fs_volume*		super_volume;
+};
 
-	fssh_status_t (*read_fs_info)(fssh_fs_volume fs, struct fssh_fs_info *info);
-	fssh_status_t (*write_fs_info)(fssh_fs_volume fs,
+struct fssh_fs_vnode {
+	void*				private_node;
+	fssh_fs_vnode_ops*	ops;
+};
+
+struct fssh_fs_volume_ops {
+	fssh_status_t (*unmount)(fssh_fs_volume *volume);
+
+	fssh_status_t (*read_fs_info)(fssh_fs_volume *volume,
+				struct fssh_fs_info *info);
+	fssh_status_t (*write_fs_info)(fssh_fs_volume *volume,
 				const struct fssh_fs_info *info, uint32_t mask);
-	fssh_status_t (*sync)(fssh_fs_volume fs);
+	fssh_status_t (*sync)(fssh_fs_volume *volume);
 
+	fssh_status_t (*get_vnode)(fssh_fs_volume *volume, fssh_vnode_id id,
+				fssh_fs_vnode *_vnode, int *_type, uint32_t *_flags,
+				bool reenter);
+
+	/* index directory &amp; index operations */
+	fssh_status_t (*open_index_dir)(fssh_fs_volume *volume,
+				fssh_fs_cookie *cookie);
+	fssh_status_t (*close_index_dir)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie);
+	fssh_status_t (*free_index_dir_cookie)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie);
+	fssh_status_t (*read_index_dir)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie, struct fssh_dirent *buffer,
+				fssh_size_t bufferSize, uint32_t *_num);
+	fssh_status_t (*rewind_index_dir)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie);
+
+	fssh_status_t (*create_index)(fssh_fs_volume *volume, const char *name,
+				uint32_t type, uint32_t flags);
+	fssh_status_t (*remove_index)(fssh_fs_volume *volume, const char *name);
+	fssh_status_t (*read_index_stat)(fssh_fs_volume *volume, const char *name,
+				struct fssh_stat *stat);
+
+	/* query operations */
+	fssh_status_t (*open_query)(fssh_fs_volume *volume, const char *query,
+				uint32_t flags, fssh_port_id port, uint32_t token,
+				fssh_fs_cookie *_cookie);
+	fssh_status_t (*close_query)(fssh_fs_volume *volume, fssh_fs_cookie cookie);
+	fssh_status_t (*free_query_cookie)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie);
+	fssh_status_t (*read_query)(fssh_fs_volume *volume, fssh_fs_cookie cookie,
+				struct fssh_dirent *buffer, fssh_size_t bufferSize,
+				uint32_t *_num);
+	fssh_status_t (*rewind_query)(fssh_fs_volume *volume,
+				fssh_fs_cookie cookie);
+
+	/* support for FS layers */
+	fssh_status_t (*create_sub_vnode)(fssh_fs_volume *volume, fssh_ino_t id,
+		fssh_fs_vnode *vnode);
+	fssh_status_t (*delete_sub_vnode)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode);
+};
+
+struct fssh_fs_vnode_ops {
 	/* vnode operations */
-	fssh_status_t (*lookup)(fssh_fs_volume fs, fssh_fs_vnode dir,
-				const char *name, fssh_vnode_id *_id, int *_type);
-	fssh_status_t (*get_vnode_name)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				char *buffer, fssh_size_t bufferSize);
+	fssh_status_t (*lookup)(fssh_fs_volume *volume, fssh_fs_vnode *dir,
+				const char *name, fssh_vnode_id *_id);
+	fssh_status_t (*get_vnode_name)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, char *buffer, fssh_size_t bufferSize);
 
-	fssh_status_t (*get_vnode)(fssh_fs_volume fs, fssh_vnode_id id,
-				fssh_fs_vnode *_vnode, bool reenter);
-	fssh_status_t (*put_vnode)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*put_vnode)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				bool reenter);
-	fssh_status_t (*remove_vnode)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*remove_vnode)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				bool reenter);
 
 	/* VM file access */
-	bool (*can_page)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	bool (*can_page)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
-	fssh_status_t (*read_pages)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*read_pages)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
 				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
-	fssh_status_t (*write_pages)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*write_pages)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const fssh_iovec *vecs,
 				fssh_size_t count, fssh_size_t *_numBytes, bool reenter);
 
 	/* cache file access */
-	fssh_status_t (*get_file_map)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*get_file_map)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_off_t offset, fssh_size_t size,
 				struct fssh_file_io_vec *vecs, fssh_size_t *_count);
 
 	/* common operations */
-	fssh_status_t (*ioctl)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*ioctl)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_ulong op, void *buffer,
 				fssh_size_t length);
-	fssh_status_t (*set_flags)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*set_flags)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, int flags);
-	fssh_status_t (*select)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*select)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, uint8_t event, uint32_t ref,
 				fssh_selectsync *sync);
-	fssh_status_t (*deselect)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*deselect)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, uint8_t event, fssh_selectsync *sync);
-	fssh_status_t (*fsync)(fssh_fs_volume fs, fssh_fs_vnode vnode);
+	fssh_status_t (*fsync)(fssh_fs_volume *volume, fssh_fs_vnode *vnode);
 
-	fssh_status_t (*read_symlink)(fssh_fs_volume fs, fssh_fs_vnode link,
+	fssh_status_t (*read_symlink)(fssh_fs_volume *volume, fssh_fs_vnode *link,
 				char *buffer, fssh_size_t *_bufferSize);
-	fssh_status_t (*create_symlink)(fssh_fs_volume fs, fssh_fs_vnode dir,
+	fssh_status_t (*create_symlink)(fssh_fs_volume *volume, fssh_fs_vnode *dir,
 				const char *name, const char *path, int mode);
 
-	fssh_status_t (*link)(fssh_fs_volume fs, fssh_fs_vnode dir,
-				const char *name, fssh_fs_vnode vnode);
-	fssh_status_t (*unlink)(fssh_fs_volume fs, fssh_fs_vnode dir,
+	fssh_status_t (*link)(fssh_fs_volume *volume, fssh_fs_vnode *dir,
+				const char *name, fssh_fs_vnode *vnode);
+	fssh_status_t (*unlink)(fssh_fs_volume *volume, fssh_fs_vnode *dir,
 				const char *name);
-	fssh_status_t (*rename)(fssh_fs_volume fs, fssh_fs_vnode fromDir,
-				const char *fromName, fssh_fs_vnode toDir, const char *toName);
+	fssh_status_t (*rename)(fssh_fs_volume *volume, fssh_fs_vnode *fromDir,
+				const char *fromName, fssh_fs_vnode *toDir, const char *toName);
 
-	fssh_status_t (*access)(fssh_fs_volume fs, fssh_fs_vnode vnode, int mode);
-	fssh_status_t (*read_stat)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*access)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
+				int mode);
+	fssh_status_t (*read_stat)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				struct fssh_stat *stat);
-	fssh_status_t (*write_stat)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*write_stat)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				const struct fssh_stat *stat, uint32_t statMask);
 
 	/* file operations */
-	fssh_status_t (*create)(fssh_fs_volume fs, fssh_fs_vnode dir,
+	fssh_status_t (*create)(fssh_fs_volume *volume, fssh_fs_vnode *dir,
 				const char *name, int openMode, int perms,
 				fssh_fs_cookie *_cookie, fssh_vnode_id *_newVnodeID);
-	fssh_status_t (*open)(fssh_fs_volume fs, fssh_fs_vnode vnode, int openMode,
-				fssh_fs_cookie *_cookie);
-	fssh_status_t (*close)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*open)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
+				int openMode, fssh_fs_cookie *_cookie);
+	fssh_status_t (*close)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
-	fssh_status_t (*free_cookie)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*free_cookie)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
-	fssh_status_t (*read)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*read)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, void *buffer,
 				fssh_size_t *length);
-	fssh_status_t (*write)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*write)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const void *buffer,
 				fssh_size_t *length);
 
 	/* directory operations */
-	fssh_status_t (*create_dir)(fssh_fs_volume fs, fssh_fs_vnode parent,
+	fssh_status_t (*create_dir)(fssh_fs_volume *volume, fssh_fs_vnode *parent,
 				const char *name, int perms, fssh_vnode_id *_newVnodeID);
-	fssh_status_t (*remove_dir)(fssh_fs_volume fs, fssh_fs_vnode parent,
+	fssh_status_t (*remove_dir)(fssh_fs_volume *volume, fssh_fs_vnode *parent,
 				const char *name);
-	fssh_status_t (*open_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*open_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie *_cookie);
-	fssh_status_t (*close_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*close_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
-	fssh_status_t (*free_dir_cookie)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie);
-	fssh_status_t (*read_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*free_dir_cookie)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie);
+	fssh_status_t (*read_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, struct fssh_dirent *buffer,
 				fssh_size_t bufferSize, uint32_t *_num);
-	fssh_status_t (*rewind_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*rewind_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
 
 	/* attribute directory operations */
-	fssh_status_t (*open_attr_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*open_attr_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie *_cookie);
-	fssh_status_t (*close_attr_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie);
-	fssh_status_t (*free_attr_dir_cookie)(fssh_fs_volume fs,
-				fssh_fs_vnode vnode, fssh_fs_cookie cookie);
-	fssh_status_t (*read_attr_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*close_attr_dir)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie);
+	fssh_status_t (*free_attr_dir_cookie)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie);
+	fssh_status_t (*read_attr_dir)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, struct fssh_dirent *buffer,
 				fssh_size_t bufferSize, uint32_t *_num);
-	fssh_status_t (*rewind_attr_dir)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie);
+	fssh_status_t (*rewind_attr_dir)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie);
 
 	/* attribute operations */
-	fssh_status_t (*create_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*create_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				const char *name, uint32_t type, int openMode,
 				fssh_fs_cookie *_cookie);
-	fssh_status_t (*open_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*open_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				const char *name, int openMode, fssh_fs_cookie *_cookie);
-	fssh_status_t (*close_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*close_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie);
-	fssh_status_t (*free_attr_cookie)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie);
-	fssh_status_t (*read_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*free_attr_cookie)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie);
+	fssh_status_t (*read_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, void *buffer,
 				fssh_size_t *length);
-	fssh_status_t (*write_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*write_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				fssh_fs_cookie cookie, fssh_off_t pos, const void *buffer,
 				fssh_size_t *length);
 
-	fssh_status_t (*read_attr_stat)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie, struct fssh_stat *stat);
-	fssh_status_t (*write_attr_stat)(fssh_fs_volume fs, fssh_fs_vnode vnode,
-				fssh_fs_cookie cookie, const struct fssh_stat *stat,
-				int statMask);
-	fssh_status_t (*rename_attr)(fssh_fs_volume fs, fssh_fs_vnode fromVnode,
-				const char *fromName, fssh_fs_vnode toVnode,
-				const char *toName);
-	fssh_status_t (*remove_attr)(fssh_fs_volume fs, fssh_fs_vnode vnode,
+	fssh_status_t (*read_attr_stat)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie,
+				struct fssh_stat *stat);
+	fssh_status_t (*write_attr_stat)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_cookie cookie,
+				const struct fssh_stat *stat, int statMask);
+	fssh_status_t (*rename_attr)(fssh_fs_volume *volume,
+				fssh_fs_vnode *fromVnode, const char *fromName,
+				fssh_fs_vnode *toVnode, const char *toName);
+	fssh_status_t (*remove_attr)(fssh_fs_volume *volume, fssh_fs_vnode *vnode,
 				const char *name);
 
-	/* index directory &amp; index operations */
-	fssh_status_t (*open_index_dir)(fssh_fs_volume fs, fssh_fs_cookie *cookie);
-	fssh_status_t (*close_index_dir)(fssh_fs_volume fs, fssh_fs_cookie cookie);
-	fssh_status_t (*free_index_dir_cookie)(fssh_fs_volume fs,
-				fssh_fs_cookie cookie);
-	fssh_status_t (*read_index_dir)(fssh_fs_volume fs, fssh_fs_cookie cookie,
-				struct fssh_dirent *buffer, fssh_size_t bufferSize,
-				uint32_t *_num);
-	fssh_status_t (*rewind_index_dir)(fssh_fs_volume fs, fssh_fs_cookie cookie);
+	/* support for vnode and FS layers */
+	fssh_status_t (*create_special_node)(fssh_fs_volume *volume,
+				fssh_fs_vnode *dir, const char *name, fssh_fs_vnode *subVnode,
+				fssh_mode_t mode, uint32_t flags, fssh_fs_vnode *_superVnode,
+				fssh_ino_t *_nodeID);
+	fssh_status_t (*get_super_vnode)(fssh_fs_volume *volume,
+				fssh_fs_vnode *vnode, fssh_fs_volume *superVolume,
+				fssh_fs_vnode *superVnode);
+};
 
-	fssh_status_t (*create_index)(fssh_fs_volume fs, const char *name,
-				uint32_t type, uint32_t flags);
-	fssh_status_t (*remove_index)(fssh_fs_volume fs, const char *name);
-	fssh_status_t (*read_index_stat)(fssh_fs_volume fs, const char *name,
-				struct fssh_stat *stat);
+typedef struct fssh_file_system_module_info {
+	struct fssh_module_info	info;
+	const char*				pretty_name;
+	uint32_t				flags;	// DDM flags
 
-	/* query operations */
-	fssh_status_t (*open_query)(fssh_fs_volume fs, const char *query,
-				uint32_t flags, fssh_port_id port, uint32_t token,
-				fssh_fs_cookie *_cookie);
-	fssh_status_t (*close_query)(fssh_fs_volume fs, fssh_fs_cookie cookie);
-	fssh_status_t (*free_query_cookie)(fssh_fs_volume fs,
-				fssh_fs_cookie cookie);
-	fssh_status_t (*read_query)(fssh_fs_volume fs, fssh_fs_cookie cookie,
-				struct fssh_dirent *buffer, fssh_size_t bufferSize,
-				uint32_t *_num);
-	fssh_status_t (*rewind_query)(fssh_fs_volume fs, fssh_fs_cookie cookie);
+	/* scanning (the device is write locked) */
+	float (*identify_partition)(int fd, fssh_partition_data *partition,
+				void **cookie);
+	fssh_status_t (*scan_partition)(int fd, fssh_partition_data *partition,
+				void *cookie);
+	void (*free_identify_partition_cookie)(fssh_partition_data *partition,
+				void *cookie);
+	void (*free_partition_content_cookie)(fssh_partition_data *partition);
 
+	/* general operations */
+	fssh_status_t (*mount)(fssh_fs_volume *volume, const char *device,
+				uint32_t flags, const char *args, fssh_vnode_id *_rootVnodeID);
+
 	/* capability querying (the device is read locked) */
 	uint32_t (*get_supported_operations)(fssh_partition_data* partition,
 				uint32_t mask);
@@ -269,20 +320,23 @@
 
 
 /* file system add-ons only prototypes */
-extern fssh_status_t fssh_new_vnode(fssh_mount_id mountID,
-				fssh_vnode_id vnodeID, fssh_fs_vnode privateNode);
-extern fssh_status_t fssh_publish_vnode(fssh_mount_id mountID,
-				fssh_vnode_id vnodeID, fssh_fs_vnode privateNode);
-extern fssh_status_t fssh_get_vnode(fssh_mount_id mountID,
-				fssh_vnode_id vnodeID, fssh_fs_vnode *_privateNode);
-extern fssh_status_t fssh_put_vnode(fssh_mount_id mountID,
+extern fssh_status_t fssh_new_vnode(fssh_fs_volume *volume,
+				fssh_vnode_id vnodeID, void *privateNode,
+				fssh_fs_vnode_ops *ops);
+extern fssh_status_t fssh_publish_vnode(fssh_fs_volume *volume,
+				fssh_vnode_id vnodeID, void *privateNode,
+				fssh_fs_vnode_ops *ops, int type, uint32_t flags);
+extern fssh_status_t fssh_get_vnode(fssh_fs_volume *volume,
+				fssh_vnode_id vnodeID, void **_privateNode);
+extern fssh_status_t fssh_put_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID);
-extern fssh_status_t fssh_remove_vnode(fssh_mount_id mountID,
+extern fssh_status_t fssh_remove_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID);
-extern fssh_status_t fssh_unremove_vnode(fssh_mount_id mountID,
+extern fssh_status_t fssh_unremove_vnode(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID);
-extern fssh_status_t fssh_get_vnode_removed(fssh_mount_id mountID,
+extern fssh_status_t fssh_get_vnode_removed(fssh_fs_volume *volume,
 				fssh_vnode_id vnodeID, bool* removed);
+
 extern fssh_status_t fssh_read_pages(int fd, fssh_off_t pos,
 				const struct fssh_iovec *vecs, fssh_size_t count,
 				fssh_size_t *_numBytes, bool fsReenter);

Modified: haiku/trunk/headers/private/kernel/syscalls.h
===================================================================
--- haiku/trunk/headers/private/kernel/syscalls.h	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/headers/private/kernel/syscalls.h	2008-04-05 23:05:16 UTC (rev 24816)
@@ -178,6 +178,7 @@
 extern status_t		_kern_unlink(int fd, const char *path);
 extern status_t		_kern_rename(int oldDir, const char *oldpath, int newDir,
 						const char *newpath);
+extern status_t		_kern_create_fifo(const char *path, mode_t perms);
 extern status_t		_kern_access(const char *path, int mode);
 extern ssize_t		_kern_select(int numfds, struct fd_set *readSet,
 						struct fd_set *writeSet, struct fd_set *errorSet,

Modified: haiku/trunk/headers/private/kernel/vfs.h
===================================================================
--- haiku/trunk/headers/private/kernel/vfs.h	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/headers/private/kernel/vfs.h	2008-04-05 23:05:16 UTC (rev 24816)
@@ -104,7 +104,7 @@
 			bool allocate);
 status_t vfs_get_file_map(struct vnode *vnode, off_t offset, size_t size,
 			struct file_io_vec *vecs, size_t *_count);
-status_t vfs_get_fs_node_from_path(dev_t mountID, const char *path,
+status_t vfs_get_fs_node_from_path(fs_volume *volume, const char *path,
 			bool kernel, void **_node);
 status_t vfs_stat_vnode(struct vnode *vnode, struct stat *stat);
 status_t vfs_stat_entry_ref(dev_t device, ino_t inode, struct stat *stat);
@@ -171,6 +171,7 @@
 status_t _user_unlink(int fd, const char *path);
 status_t _user_rename(int oldFD, const char *oldpath, int newFD,
 			const char *newpath);
+status_t _user_create_fifo(const char *path, mode_t perms);
 status_t _user_access(const char *path, int mode);
 ssize_t _user_select(int numfds, fd_set *readSet, fd_set *writeSet, fd_set *errorSet,
 			bigtime_t timeout, const sigset_t *sigMask);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/BlockAllocator.cpp	2008-04-05 23:05:16 UTC (rev 24816)
@@ -954,7 +954,7 @@
 		cookie-&gt;iterator = NULL;
 
 		// the current directory inode is still locked in memory
-		put_vnode(fVolume-&gt;ID(), fVolume-&gt;ToVnode(cookie-&gt;current));
+		put_vnode(fVolume-&gt;FSVolume(), fVolume-&gt;ToVnode(cookie-&gt;current));
 	}
 
 	// if CheckNextNode() could completely work through, we can
@@ -1089,7 +1089,7 @@
 			cookie-&gt;iterator = NULL;
 
 			// unlock the directory's inode from memory
-			put_vnode(fVolume-&gt;ID(), fVolume-&gt;ToVnode(cookie-&gt;current));
+			put_vnode(fVolume-&gt;FSVolume(), fVolume-&gt;ToVnode(cookie-&gt;current));
 
 			continue;
 		} else if (status == B_OK) {

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2008-04-05 23:05:16 UTC (rev 24816)
@@ -34,7 +34,7 @@
 		return;
 
 	if (fVolume-&gt;ID() &gt;= 0)
-		put_vnode(fVolume-&gt;ID(), fNode-&gt;ID());
+		put_vnode(fVolume-&gt;FSVolume(), fNode-&gt;ID());
 }
 
 
@@ -45,7 +45,7 @@
 		return;
 
 	if (fVolume-&gt;ID() &gt;= 0)
-		put_vnode(fVolume-&gt;ID(), fNode-&gt;ID());
+		put_vnode(fVolume-&gt;FSVolume(), fNode-&gt;ID());
 	fNode = NULL;
 	fName = NULL;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2008-04-05 22:08:47 UTC (rev 24815)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2008-04-05 23:05:16 UTC (rev 24816)
@@ -169,7 +169,7 @@
 			fInode-&gt;Node().flags &amp;= ~HOST_ENDIAN_TO_BFS_INT32(INODE_IN_USE);
 				// this unblocks any pending bfs_read_vnode() calls
 			fInode-&gt;Free(*fTransaction);
-			remove_vnode(volume-&gt;ID(), fInode-&gt;ID());
+			remove_vnode(volume-&gt;FSVolume(), fInode-&gt;ID());
 		} else
 			volume-&gt;Free(*fTransaction, fRun);
 	}
@@ -199,7 +199,8 @@
 		RETURN_ERROR(B_NO_MEMORY);
 
 	if (volume-&gt;ID() &gt;= 0) {
-		status = new_vnode(volume-&gt;ID(), fInode-&gt;ID(), fInode);
+		status = new_vnode(volume-&gt;FSVolume(), fInode-&gt;ID(), fInode,
+			&amp;gBFSVnodeOps);
 		if (status &lt; B_OK) {
 			delete fInode;
 			fInode = NULL;
@@ -247,8 +248,10 @@
 		return status;
 	}
 
-	if (!fInode-&gt;IsSymLink() &amp;&amp; volume-&gt;ID() &gt;= 0)
-		status = publish_vnode(volume-&gt;ID(), fInode-&gt;ID(), fInode);
+	if (!fInode-&gt;IsSymLink() &amp;&amp; volume-&gt;ID() &gt;= 0) {
+		status = publish_vnode(volume-&gt;FSVolume(), fInode-&gt;ID(), fInode,
+			&amp;gBFSVnodeOps, fInode-&gt;Mode(), 0);
+	}
 
 	if (status == B_OK) {
 		cache_add_transaction_listener(volume-&gt;BlockCache(), fTransaction-&gt;ID(),
@@ -933,14 +936,14 @@
 
 	if (attributes-&gt;IsEmpty()) {
 		// remove attribute directory (don't fail if that can't be done)
-		if (remove_vnode(fVolume-&gt;ID(), attributes-&gt;ID()) == B_OK) {
+		if (remove_vnode(fVolume-&gt;FSVolume(), attributes-&gt;ID()) == B_OK) {
 			// update the inode, so that no one will ever doubt it's deleted :-)
 			attributes-&gt;Node().flags |= HOST_ENDIAN_TO_BFS_INT32(INODE_DELETED);
 			if (attributes-&gt;WriteBack(transaction) == B_OK) {
 				Attributes().SetTo(0, 0, 0);
 				WriteBack(transaction);
 			} else
-				unremove_vnode(fVolume-&gt;ID(), attributes-&gt;ID());
+				unremove_vnode(fVolume-&gt;FSVolume(), attributes-&gt;ID());
 		}
 	}
 
@@ -1188,7 +1191,7 @@
 	if (attribute == NULL)
 		return;
 
-	put_vnode(fVolume-&gt;ID(), attribute-&gt;ID());
+	put_vnode(fVolume-&gt;FSVolume(), attribute-&gt;ID());
 }
 
 
@@ -2240,12 +2243,12 @@
 	}
 

[... truncated: 7462 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007516.html">[Haiku-commits] r24815 -	haiku/trunk/src/system/kernel/disk_device_manager
</A></li>
	<LI>Next message: <A HREF="007519.html">[Haiku-commits] r24817 - haiku/trunk/src/system/kernel/fs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7517">[ date ]</a>
              <a href="thread.html#7517">[ thread ]</a>
              <a href="subject.html#7517">[ subject ]</a>
              <a href="author.html#7517">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
