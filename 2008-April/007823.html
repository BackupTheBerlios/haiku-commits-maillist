<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r24995 -	haiku/trunk/src/add-ons/kernel/file_systems/fat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2008-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24995%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/fat&In-Reply-To=%3C200804171002.m3HA2onp026607%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="007822.html">
   <LINK REL="Next"  HREF="007824.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r24995 -	haiku/trunk/src/add-ons/kernel/file_systems/fat</H1>
    <B>mmlr at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r24995%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/fat&In-Reply-To=%3C200804171002.m3HA2onp026607%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r24995 -	haiku/trunk/src/add-ons/kernel/file_systems/fat">mmlr at mail.berlios.de
       </A><BR>
    <I>Thu Apr 17 12:02:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="007822.html">[Haiku-commits] r24994 - in haiku/trunk: build/jam	src/add-ons/kernel/file_systems/iso9660
</A></li>
        <LI>Next message: <A HREF="007824.html">[Haiku-commits] r24996 -	haiku/trunk/src/add-ons/kernel/file_systems/fat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7823">[ date ]</a>
              <a href="thread.html#7823">[ thread ]</a>
              <a href="subject.html#7823">[ subject ]</a>
              <a href="author.html#7823">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mmlr
Date: 2008-04-17 12:02:49 +0200 (Thu, 17 Apr 2008)
New Revision: 24995
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=24995&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=24995&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.h
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.h
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h
   haiku/trunk/src/add-ons/kernel/file_systems/fat/encodings.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/fat/fat.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/file.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/iter.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/mime_table.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/util.c
   haiku/trunk/src/add-ons/kernel/file_systems/fat/vcache.c
Log:
Just a bit of cleanup, remove trailing whitespace mostly. No functional changes.

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.c	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.c	2008-04-17 10:02:49 UTC (rev 24995)
@@ -45,7 +45,7 @@
 
 		if (filename[namelen-ext_len-1] != '.')
 			continue;
-		
+
 		if (!strcasecmp(filename + namelen - ext_len, p-&gt;extension))
 			break;
 	}
@@ -56,7 +56,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_open_attrdir(fs_volume *_vol, fs_vnode *_node, void **_cookie)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;
@@ -77,13 +77,14 @@
 		return ENOMEM;
 	}
 	*(int32 *)(*_cookie) = 0;
-	
+
 	UNLOCK_VOL(vol);
-	
+
 	return 0;
 }
 
-status_t 
+
+status_t
 dosfs_close_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;
@@ -100,14 +101,14 @@
 	}
 
 	*(int32 *)_cookie = 1;
-	
+
 	UNLOCK_VOL(vol);
-	
+
 	return 0;
 }
 
 
-status_t 
+status_t
 dosfs_free_attrdir_cookie(fs_volume *_vol, fs_vnode *_node, void *_cookie)
 {
 	TOUCH(_vol); TOUCH(_node);
@@ -126,7 +127,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_rewind_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie)
 {
 	TOUCH(_vol); TOUCH(_node);
@@ -143,8 +144,8 @@
 }
 
 
-status_t 
-dosfs_read_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie, 
+status_t
+dosfs_read_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie,
 	struct dirent *entry, size_t bufsize, uint32 *num)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;
@@ -167,7 +168,7 @@
 
 	if ((*cookie == 0) &amp;&amp; (node-&gt;mime)) {
 		*num = 1;
-		
+
 		entry-&gt;d_ino = node-&gt;vnid;
 		entry-&gt;d_dev = vol-&gt;id;
 		entry-&gt;d_reclen = 10;
@@ -177,7 +178,7 @@
 	*cookie = 1;
 
 	UNLOCK_VOL(vol);
-	
+
 	return 0;
 }
 
@@ -191,7 +192,7 @@
 
 	if (strcmp(name, &quot;BEOS:TYPE&quot;))
 		return ENOENT;
-	
+
 	LOCK_VOL(vol);
 
 	if (node-&gt;mime == NULL) {
@@ -200,7 +201,7 @@
 	}
 
 	UNLOCK_VOL(vol);
-	
+
 	*_cookie = &kBeOSTypeCookie;
 	return B_OK;
 }
@@ -220,7 +221,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_read_attr_stat(fs_volume *_vol, fs_vnode *_node, void *_cookie,
 	struct stat *stat)
 {
@@ -244,7 +245,7 @@
 		UNLOCK_VOL(vol);
 		return ENOENT;
 	}
-	
+
 	stat-&gt;st_type = MIME_STRING_TYPE;
 	stat-&gt;st_size = strlen(node-&gt;mime) + 1;
 
@@ -253,7 +254,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_read_attr(fs_volume *_vol, fs_vnode *_node, void *_cookie, off_t pos,
 	void *buffer, size_t *_length)
 {
@@ -264,7 +265,7 @@
 
 	if (_cookie != &amp;kBeOSTypeCookie)
 		return ENOENT;
-		
+
 	LOCK_VOL(vol);
 
 	if (check_nspace_magic(vol, &quot;dosfs_read_attr&quot;) ||
@@ -291,6 +292,7 @@
 	return 0;
 }
 
+
 // suck up application attempts to set mime types; this hides an unsightly
 // error message printed out by zip
 status_t
@@ -303,6 +305,6 @@
 
 	if (_cookie != &amp;kBeOSTypeCookie)
 		return ENOSYS;
-		
+
 	return B_OK;
 }

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.h	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/attr.h	2008-04-17 10:02:49 UTC (rev 24995)
@@ -14,7 +14,7 @@
 status_t dosfs_free_attrdir_cookie(fs_volume *_vol, fs_vnode *_node,
 	void *_cookie);
 status_t dosfs_rewind_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie);
-status_t dosfs_read_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie, 
+status_t dosfs_read_attrdir(fs_volume *_vol, fs_vnode *_node, void *_cookie,
 	struct dirent *buf, size_t bufsize, uint32 *num);
 status_t dosfs_open_attr(fs_volume *_vol, fs_vnode *_node, const char *name,
 	int openMode, void **_cookie);

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.c	2008-04-17 10:02:49 UTC (rev 24995)
@@ -3,7 +3,7 @@
 	This file may be used under the terms of the Be Sample Code License.
 */
 
-#include &lt;KernelExport.h&gt; 
+#include &lt;KernelExport.h&gt;
 
 #include &lt;stdlib.h&gt;
 #include &lt;dirent.h&gt;
@@ -90,7 +90,7 @@
 			}
 			return ENOENT;
 		}
-	
+
 		if (buffer[0] == 0xe5) { // skip erased entries
 			if (start_index != 0xffff) {
 				dprintf(&quot;lfn entry (%s) with intervening erased entries\n&quot;, filename);
@@ -99,9 +99,9 @@
 			DPRINTF(2, (&quot;entry erased, skipping...\n&quot;));
 			continue;
 		}
-		
+
 		if (buffer[0xb] == 0xf) { // long file name
-			if ((buffer[0xc] != 0) || 
+			if ((buffer[0xc] != 0) ||
 				(buffer[0x1a] != 0) || (buffer[0x1b] != 0)) {
 				dprintf(&quot;invalid long file name: reserved fields munged\n&quot;);
 				continue;
@@ -118,7 +118,7 @@
 				for (i = 1; i &lt; 0x20; i += 2) {
 					if (*(uint16 *)&amp;buffer[i] == 0xffff)
 						break;
-					*puni++ = *(uint16 *)&amp;buffer[i]; 
+					*puni++ = *(uint16 *)&amp;buffer[i];
 					if (i == 0x9) i+=3;
 					if (i == 0x18) i+=2;
 				}
@@ -163,7 +163,7 @@
 	// process long name
 	if (start_index != 0xffff) {
 		if (lfn_count != 1) {
-			dprintf(&quot;unfinished lfn in directory\n&quot;); 
+			dprintf(&quot;unfinished lfn in directory\n&quot;);
 			start_index = 0xffff;
 		} else {
 			if (unicode_to_utf8(uni, filename_len, (uint8*)filename, len)) {
@@ -311,7 +311,7 @@
 			break;
 		}
 
-		result = ENOTEMPTY;		
+		result = ENOTEMPTY;
 	}
 
 	diri_free(&amp;iter);
@@ -458,7 +458,7 @@
 	uint8 *buffer;
 	struct _dirent_info_ info;
 	struct diri diri;
-	
+
 	DPRINTF(0, (&quot;erasing directory entries %lx through %lx\n&quot;,
 		node-&gt;sindex, node-&gt;eindex));
 	buffer = diri_init(vol,VNODE_PARENT_DIR_CLUSTER(node), node-&gt;sindex, &amp;diri);
@@ -474,7 +474,7 @@
 
 	if (result &lt; 0)
 		return result;
-	
+
 	if (info.sindex != node-&gt;sindex || info.eindex != node-&gt;eindex) {
 		// any other attributes may be in a state of flux due to wstat calls
 		dprintf(&quot;erase_dir_entry: directory entry doesn't match\n&quot;);
@@ -564,7 +564,7 @@
 	struct diri diri;
 	uint8 *buffer;
 	status_t result = ENOENT;
-	
+
 	buffer = diri_init(vol, dir-&gt;cluster, 0, &amp;diri);
 	while (buffer) {
 		if (buffer[0] == 0)
@@ -669,7 +669,7 @@
 	// if at end of directory, last_entry flag will be true as it should be
 
 	diri_free(&amp;diri);
-	
+
 	if (error != B_OK &amp;&amp; error != ENOENT)
 		return error;
 
@@ -691,7 +691,7 @@
 			DPRINTF(0, (&quot;_create_dir_entry_: out of space in root directory\n&quot;));
 			return ENOSPC;
 		}
-	
+
 		// otherwise grow directory to fit
 		clusters_needed = ((*ne + 1) * 0x20 +
 			vol-&gt;bytes_per_sector*vol-&gt;sectors_per_cluster - 1) /
@@ -759,7 +759,7 @@
 	buffer[0x1e] = (i &gt;&gt; 16) &amp; 0xff;
 	buffer[0x1f] = (i &gt;&gt; 24) &amp; 0xff;
 	diri_mark_dirty(&amp;diri);
-	
+
 	if (last_entry) {
 		// add end of directory markers to the rest of the
 		// cluster; need to clear all the other entries or else
@@ -769,7 +769,7 @@
 			diri_mark_dirty(&amp;diri);
 		}
 	}
-	
+
 	diri_free(&amp;diri);
 
 	return 0;
@@ -804,10 +804,10 @@
 {
 	unsigned int i;
 	unsigned int len = strlen(name);
-	
+
 	if (len &lt;= 0)
 		return false;
-	
+
 	// names ending with a dot are not allowed
 	if (name[len - 1] == '.')
 		return false;
@@ -883,7 +883,7 @@
 			error = B_OK;
 		else
 			error = find_short_name(vol, dir, nshort);
-			
+
 		if (error == B_OK) {
 			do {
 				memcpy(nshort, tshort, 11);
@@ -922,7 +922,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_read_vnode(fs_volume *_vol, ino_t vnid, fs_vnode *_node, int *_type,
 	uint32 *_flags, bool reenter)
 {
@@ -980,7 +980,7 @@
 		result = ENOENT;
 		goto bi;
 	}
-	
+
 	while (1) {
 		result = _next_dirent_(&amp;iter, &amp;info, filename, 512);
 		if (result &lt; 0) {
@@ -1033,7 +1033,7 @@
 			* vol-&gt;sectors_per_cluster * vol-&gt;bytes_per_sector;
 	}
 	if (entry-&gt;cluster) {
-		entry-&gt;end_cluster = get_nth_fat_entry(vol, info.cluster, 
+		entry-&gt;end_cluster = get_nth_fat_entry(vol, info.cluster,
 			(entry-&gt;st_size + vol-&gt;bytes_per_sector * vol-&gt;sectors_per_cluster - 1) /
 			vol-&gt;bytes_per_sector / vol-&gt;sectors_per_cluster - 1);
 	} else
@@ -1064,7 +1064,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_walk(fs_volume *_vol, fs_vnode *_dir, const char *file, ino_t *_vnid)
 {
 	/* Starting at the base, find file in the subdir, and return path
@@ -1097,7 +1097,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_access(fs_volume *_vol, fs_vnode *_node, int mode)
 {
 	status_t result = B_OK;
@@ -1133,7 +1133,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_readlink(fs_volume *_vol, fs_vnode *_node, char *buf, size_t *bufsize)
 {
 	TOUCH(_vol); TOUCH(_node); TOUCH(buf); TOUCH(bufsize);
@@ -1145,7 +1145,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_opendir(fs_volume *_vol, fs_vnode *_node, void **_cookie)
 {
 	nspace *vol = (nspace*)_vol-&gt;private_volume;
@@ -1190,7 +1190,7 @@
 	cookie-&gt;current_index = 0;
 
 	result = B_NO_ERROR;
-	
+
 bi:
 	*_cookie = (void*)cookie;
 
@@ -1203,8 +1203,8 @@
 }
 
 
-status_t 
-dosfs_readdir(fs_volume *_vol, fs_vnode *_dir, void *_cookie, 
+status_t
+dosfs_readdir(fs_volume *_vol, fs_vnode *_dir, void *_cookie,
 	struct dirent *entry, size_t bufsize, uint32 *num)
 {
 	int 		result = ENOENT;
@@ -1214,7 +1214,7 @@
 	struct		diri diri;
 
 	LOCK_VOL(vol);
-	
+
 	if (check_nspace_magic(vol, &quot;dosfs_readdir&quot;) ||
 		check_vnode_magic(dir, &quot;dosfs_readdir&quot;) ||
 		check_dircookie_magic(cookie, &quot;dosfs_readdir&quot;)) {
@@ -1260,7 +1260,7 @@
 
 	if (dir-&gt;vnid == vol-&gt;root_vnode.vnid)
 		cookie-&gt;current_index += 2;
-	
+
 	if (result == B_NO_ERROR) {
 		*num = 1;
 		entry-&gt;d_dev = vol-&gt;id;
@@ -1282,8 +1282,8 @@
 
 	return result;
 }
-			
 
+
 status_t
 dosfs_rewinddir(fs_volume *_vol, fs_vnode *_node, void* _cookie)
 {
@@ -1310,7 +1310,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_closedir(fs_volume *_vol, fs_vnode *_node, void *_cookie)
 {
 	TOUCH(_vol); TOUCH(_node); TOUCH(_cookie);
@@ -1321,7 +1321,7 @@
 }
 
 
-status_t 
+status_t
 dosfs_free_dircookie(fs_volume *_vol, fs_vnode *_node, void *_cookie)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.h	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dir.h	2008-04-17 10:02:49 UTC (rev 24995)
@@ -12,13 +12,13 @@
 status_t 	findfile_nocase(nspace *vol, vnode *dir, const char *file,
 				ino_t *vnid, vnode **node);
 status_t 	findfile_nocase_duplicates(nspace *vol, vnode *dir, const char *file,
-				ino_t *vnid, vnode **node, bool *dups_exist);				
+				ino_t *vnid, vnode **node, bool *dups_exist);
 status_t 	findfile_case_duplicates(nspace *vol, vnode *dir, const char *file,
-				ino_t *vnid, vnode **node, bool *dups_exist);				
+				ino_t *vnid, vnode **node, bool *dups_exist);
 status_t	erase_dir_entry(nspace *vol, vnode *node);
 status_t	compact_directory(nspace *vol, vnode *dir);
 status_t	create_volume_label(nspace *vol, const char name[11], uint32 *index);
-status_t	create_dir_entry(nspace *vol, vnode *dir, vnode *node, 
+status_t	create_dir_entry(nspace *vol, vnode *dir, vnode *node,
 				const char *name, uint32 *ns, uint32 *ne);
 
 status_t	dosfs_read_vnode(fs_volume *_vol, ino_t vnid, fs_vnode *_node,

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.c	2008-04-17 10:02:49 UTC (rev 24995)
@@ -335,12 +335,12 @@
 			  of sectors.  They say that they have 196576 sectors but they
 			  really only have 196192.  This check is a work-around for their
 			  brain-deadness.
-			*/  
+			*/
 			unsigned char bogus_zip_data[] = {
 				0x00, 0x02, 0x04, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00,
 				0xf8, 0xc0, 0x00, 0x20, 0x00, 0x40, 0x00, 0x20, 0x00, 0x00
 			};
-			
+
 			if (memcmp(buf+0x0b, bogus_zip_data, sizeof(bogus_zip_data)) == 0 &amp;&amp;
 				vol-&gt;total_sectors == 196576 &amp;&amp;
 				((off_t)geo.sectors_per_track *
@@ -370,8 +370,8 @@
 		vol-&gt;root_vnode.st_size = vol-&gt;root_sectors * vol-&gt;bytes_per_sector;
 
 		vol-&gt;data_start = vol-&gt;root_start + vol-&gt;root_sectors;
-		vol-&gt;total_clusters = (vol-&gt;total_sectors - vol-&gt;data_start) / vol-&gt;sectors_per_cluster;	
-		
+		vol-&gt;total_clusters = (vol-&gt;total_sectors - vol-&gt;data_start) / vol-&gt;sectors_per_cluster;
+
 		// XXX: uncertain about border cases; win32 sdk says cutoffs are at
 		//      at ff6/ff7 (or fff6/fff7), but that doesn't make much sense
 		if (vol-&gt;total_clusters &gt; 0xff1)
@@ -389,7 +389,7 @@
 	}
 
 	// perform sanity checks on the FAT
-		
+
 	// the media descriptor in active FAT should match the one in the BPB
 	if ((err = read_pos(vol-&gt;fd, vol-&gt;bytes_per_sector*(vol-&gt;reserved_sectors + vol-&gt;active_fat * vol-&gt;sectors_per_fat), (void *)buf, 0x200)) != 0x200) {
 		dprintf(&quot;dosfs: error reading FAT\n&quot;);
@@ -417,7 +417,7 @@
 					dprintf(&quot;dosfs error: media descriptor mismatch in fat # %ld (%x != %x)\n&quot;, i, buf2[0], vol-&gt;media_descriptor);
 					goto error;
 				}
-#if 0			
+#if 0
 				// checking for exact matches of fats is too
 				// restrictive; allow these to go through in
 				// case the fat is corrupted for some reason
@@ -474,13 +474,13 @@
 		uint32 free_count, last_allocated;
 		err = get_fsinfo(vol, &amp;free_count, &amp;last_allocated);
 		if (err &gt;= 0) {
-			if (free_count &lt; vol-&gt;total_clusters) 
+			if (free_count &lt; vol-&gt;total_clusters)
 				vol-&gt;free_clusters = free_count;
 			else {
 				dprintf(&quot;free cluster count from fsinfo block invalid %lx\n&quot;, free_count);
 				err = -1;
 			}
-			if (last_allocated &lt; vol-&gt;total_clusters) 
+			if (last_allocated &lt; vol-&gt;total_clusters)
 				vol-&gt;last_allocated = last_allocated; //update to a closer match
 		}
 		if (err &lt; 0) {
@@ -541,7 +541,7 @@
 	if (!memcmp(vol-&gt;vol_label, &quot;__RO__     &quot;, 11)) {
 		vol-&gt;flags |= B_FS_IS_READONLY;
 	}
-	
+
 	*newVol = vol;
 	return B_NO_ERROR;
 
@@ -584,7 +584,7 @@
 	uint32 sectors_per_fat;
 	char name[12];
 	identify_cookie *cookie;
-	
+
 	// read in the boot sector
 	if (read_pos(fd, 0, (void*)buf, 512) != 512) {
 		return -1;
@@ -638,7 +638,7 @@
 			}
 		}
 	}
-	
+
 	cookie = (identify_cookie *)malloc(sizeof(identify_cookie));
 	if (!cookie)
 		return -1;
@@ -729,11 +729,11 @@
 		char name[32];
 
 		if (check_nspace_magic(vol, &quot;dosfs_mount&quot;)) return EINVAL;
-		
+
 		*_rootID = vol-&gt;root_vnode.vnid;
 		_vol-&gt;private_volume = (void *)vol;
 		_vol-&gt;ops = &gFATVolumeOps;
-		
+
 		// You MUST do this. Create the vnode for the root.
 		result = publish_vnode(_vol, *_rootID, (void*)&amp;(vol-&gt;root_vnode),
 			&amp;gFATVnodeOps, make_mode(vol, &amp;vol-&gt;root_vnode), 0);
@@ -776,7 +776,7 @@
 		&amp;&amp; (vol-&gt;flags &amp; B_FS_IS_READONLY) == 0) {
 		uchar *buffer;
 		int32 tid = cache_start_transaction(vol-&gt;fBlockCache);
-		if ((buffer = (uchar *)block_cache_get_writable_etc(vol-&gt;fBlockCache, 
+		if ((buffer = (uchar *)block_cache_get_writable_etc(vol-&gt;fBlockCache,
 				vol-&gt;fsinfo_sector, 0, vol-&gt;bytes_per_sector, tid)) != NULL) {
 			if ((read32(buffer,0) == 0x41615252) &amp;&amp; (read32(buffer,0x1e4) == 0x61417272) &amp;&amp; (read16(buffer,0x1fe) == 0xaa55)) {
 				//number of free clusters
@@ -784,7 +784,7 @@
 				buffer[0x1e9] = ((vol-&gt;free_clusters &gt;&gt; 8) &amp; 0xff);
 				buffer[0x1ea] = ((vol-&gt;free_clusters &gt;&gt; 16) &amp; 0xff);
 				buffer[0x1eb] = ((vol-&gt;free_clusters &gt;&gt; 24) &amp; 0xff);
-				//cluster number of most recently allocated cluster 
+				//cluster number of most recently allocated cluster
 				buffer[0x1ec] = (vol-&gt;last_allocated &amp; 0xff);
 				buffer[0x1ed] = ((vol-&gt;last_allocated &gt;&gt; 8) &amp; 0xff);
 				buffer[0x1ee] = ((vol-&gt;last_allocated &gt;&gt; 16) &amp; 0xff);
@@ -804,19 +804,21 @@
 	}
 }
 
-static status_t get_fsinfo(nspace *vol, uint32 *free_count, uint32 *last_allocated)
+
+static status_t
+get_fsinfo(nspace *vol, uint32 *free_count, uint32 *last_allocated)
 {
 	uchar *buffer;
 	int32 result;
 
 	if ((vol-&gt;fat_bits != 32) || (vol-&gt;fsinfo_sector == 0xffff))
 		return B_ERROR;
-		
+
 	if ((buffer = (uchar *)block_cache_get_etc(vol-&gt;fBlockCache, vol-&gt;fsinfo_sector, 0, vol-&gt;bytes_per_sector)) == NULL) {
 		dprintf(&quot;get_fsinfo: error getting fsinfo sector %x\n&quot;, vol-&gt;fsinfo_sector);
 		return EIO;
 	}
-	
+
 	if ((read32(buffer,0) == 0x41615252) &amp;&amp; (read32(buffer,0x1e4) == 0x61417272) &amp;&amp; (read16(buffer,0x1fe) == 0xaa55)) {
 		*free_count = read32(buffer,0x1e8);
 		*last_allocated = read32(buffer,0x1ec);
@@ -831,7 +833,7 @@
 }
 
 
-static status_t 
+static status_t
 dosfs_unmount(fs_volume *_vol)
 {
 	int result = B_NO_ERROR;
@@ -839,16 +841,16 @@
 	nspace* vol = (nspace*)_vol-&gt;private_volume;
 
 	LOCK_VOL(vol);
-	
+
 	if (check_nspace_magic(vol, &quot;dosfs_unmount&quot;)) {
 		UNLOCK_VOL(vol);
 		return EINVAL;
 	}
-	
+
 	DPRINTF(0, (&quot;dosfs_unmount volume %lx\n&quot;, vol-&gt;id));
 
 	update_fsinfo(vol);
-	
+
 	// Unlike in BeOS, we need to put the reference to our root node ourselves
 	put_vnode(_vol, vol-&gt;root_vnode.vnid);
 	block_cache_delete(vol-&gt;fBlockCache, true);
@@ -880,8 +882,9 @@
 	return result;
 }
 
+
 // dosfs_read_fs_stat - Fill in fs_info struct for device.
-static status_t 
+static status_t
 dosfs_read_fs_stat(fs_volume *_vol, struct fs_info * fss)
 {
 	nspace* vol = (nspace*)_vol-&gt;private_volume;
@@ -897,16 +900,16 @@
 	DPRINTF(1, (&quot;dosfs_read_fs_stat called\n&quot;));
 
 	// fss-&gt;dev and fss-&gt;root filled in by kernel
-	
+
 	// File system flags.
 	fss-&gt;flags = vol-&gt;flags;
-	
+
 	// FS block size.
 	fss-&gt;block_size = vol-&gt;bytes_per_sector * vol-&gt;sectors_per_cluster;
 
 	// IO size - specifies buffer size for file copying
 	fss-&gt;io_size = 65536;
-	
+
 	// Total blocks
 	fss-&gt;total_blocks = vol-&gt;total_clusters;
 
@@ -933,12 +936,13 @@
 
 	// File system name
 	strcpy(fss-&gt;fsh_name, &quot;fat&quot;);
-	
+
 	UNLOCK_VOL(vol);
 
 	return B_OK;
 }
 
+
 static status_t
 dosfs_write_fs_stat(fs_volume *_vol, const struct fs_info * fss, uint32 mask)
 {
@@ -1025,18 +1029,18 @@
 		if (result == 0)
 			memcpy(vol-&gt;vol_label, name, 11);
 	}
-	
+
 	if (vol-&gt;fs_flags &amp; FS_FLAGS_OP_SYNC)
 		_dosfs_sync(vol);
-	
+
 bi:	UNLOCK_VOL(vol);
 
 	return result;
 }
 
 
-static status_t 
-dosfs_ioctl(fs_volume *_vol, fs_vnode *_node, void *cookie, ulong code, 
+static status_t
+dosfs_ioctl(fs_volume *_vol, fs_vnode *_node, void *cookie, ulong code,
 	void *buf, size_t len)
 {
 	status_t result = B_OK;
@@ -1079,7 +1083,7 @@
 			dprintf(&quot;root vnode id = %Lx\n&quot;, vol-&gt;root_vnode.vnid);
 			dprintf(&quot;volume label [%11.11s]\n&quot;, vol-&gt;vol_label);
 			break;
-			
+
 		case 100001 :
 			dprintf(&quot;vnode id %Lx, dir vnid = %Lx\n&quot;, node-&gt;vnid, node-&gt;dir_vnid);
 			dprintf(&quot;si = %lx, ei = %lx\n&quot;, node-&gt;sindex, node-&gt;eindex);
@@ -1131,12 +1135,12 @@
 }
 
 
-status_t 
+status_t
 _dosfs_sync(nspace *vol)
 {
 	if (check_nspace_magic(vol, &quot;dosfs_sync&quot;))
 		return EINVAL;
-	
+
 	update_fsinfo(vol);
 	block_cache_sync(vol-&gt;fBlockCache);
 
@@ -1144,14 +1148,14 @@
 }
 
 
-static status_t 
+static status_t
 dosfs_sync(fs_volume *_vol)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;
 	status_t err;
 
 	DPRINTF(0, (&quot;dosfs_sync called on volume %lx\n&quot;, vol-&gt;id));
-	
+
 	LOCK_VOL(vol);
 	err = _dosfs_sync(vol);
 	UNLOCK_VOL(vol);
@@ -1160,7 +1164,7 @@
 }
 
 
-static status_t 
+static status_t
 dosfs_fsync(fs_volume *_vol, fs_vnode *_node)
 {
 	nspace *vol = (nspace *)_vol-&gt;private_volume;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/dosfs.h	2008-04-17 10:02:49 UTC (rev 24995)
@@ -84,7 +84,7 @@
 	 * on the disk (or at least in the cache) so that get_next_dirent continues
 	 * to function properly
 	 */
-	uint32		sindex, eindex;	// starting and ending index of directory entry	
+	uint32		sindex, eindex;	// starting and ending index of directory entry
 	uint32		cluster;		// starting cluster of the data
 	uint32		mode;			// dos-style attributes
 	off_t		st_size;		// in bytes
@@ -98,7 +98,7 @@
 
 #if TRACK_FILENAME
 	char		*filename;
-#endif	
+#endif
 } vnode;
 
 // mode bits
@@ -122,7 +122,7 @@
 	char			device[256];
 	uint32			flags;			// see &lt;fcntl.be.h&gt; for modes
 	void			*fBlockCache;
-	
+
 	// info from bpb
 	uint32	bytes_per_sector;
 	uint32	sectors_per_cluster;

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/encodings.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/encodings.cpp	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/encodings.cpp	2008-04-17 10:02:49 UTC (rev 24995)
@@ -570,7 +570,7 @@
 0x6DC6, 0x6DEC, 0x6DDE, 0x6DCC, 0x6DE8, 0x6DD2, 0x6DC5, 0x6DFA, 0x6DD9, 0x6DE4, 0x6DD5, 0x6DEA, 0x6DEE, 0x6E2D, 0x6E6E, 0x6E2E,
 0x6E19, 0x6E72, 0x6E5F, 0x6E3E, 0x6E23, 0x6E6B, 0x6E2B, 0x6E76, 0x6E4D, 0x6E1F, 0x6E43, 0x6E3A, 0x6E4E, 0x6E24, 0x6EFF, 0x6E1D,
 0x6E38, 0x6E82, 0x6EAA, 0x6E98, 0x6EC9, 0x6EB7, 0x6ED3, 0x6EBD, 0x6EAF, 0x6EC4, 0x6EB2, 0x6ED4, 0x6ED5, 0x6E8F, 0x6EA5, 0x6EC2,
-0x6E9F, 0x6F41, 0x6F11, 0x704C, 0x6EEC, 0x6EF8, 0x6EFE, 0x6F3F, 0x6EF2, 0x6F31, 0x6EEF, 0x6F32, 0x6ECC, 0x0000, 0x0000, 0x0000, 
+0x6E9F, 0x6F41, 0x6F11, 0x704C, 0x6EEC, 0x6EF8, 0x6EFE, 0x6F3F, 0x6EF2, 0x6F31, 0x6EEF, 0x6F32, 0x6ECC, 0x0000, 0x0000, 0x0000,
 0xFFFF
 };
 
@@ -830,7 +830,7 @@
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0xFFFF
 };
 
@@ -871,7 +871,7 @@
 		str[3] = 0x80 | (val&amp;0x3f);\
 		uni_str += 2; str += 4;\
 	}\
-}	
+}
 
 // Pierre's Uber Macro
 #define u_hostendian_to_utf8(str, uni_str)\
@@ -925,7 +925,7 @@
 }
 
 // Count the number of bytes of a UTF-8 character
-#define utf8_char_len(c) ((((int32)0xE5000000 &gt;&gt; ((c &gt;&gt; 3) &amp; 0x1E)) &amp; 3) + 1) 
+#define utf8_char_len(c) ((((int32)0xE5000000 &gt;&gt; ((c &gt;&gt; 3) &amp; 0x1E)) &amp; 3) + 1)
 
 // converts LENDIAN unicode to utf8
 static status_t
@@ -939,7 +939,7 @@
 	int32 dstLimit = *dstLen;
 	int32 srcCount = 0;
 	int32 dstCount = 0;
-	
+
 	for (srcCount = 0; srcCount &lt; srcLimit; srcCount += 2) {
 		uint16  *UNICODE = (uint16 *)&amp;src[srcCount];
 		uchar	utf8[4];
@@ -965,7 +965,7 @@
 }
 
 // utf8 to LENDIAN unicode
-static status_t 
+static status_t
 _utf8_to_lendian_unicode(
 	const char	*src,
 	int32		*srcLen,
@@ -984,7 +984,7 @@
 		int     err_flag;
 
 		if ((srcCount + utf8_char_len(src[srcCount])) &gt; srcLimit)
-			break; 
+			break;
 
 		utf8_to_u_hostendian(UTF8, UNICODE, err_flag);
 		if(err_flag == 1)
@@ -1023,10 +1023,10 @@
 		uint16	*UNICODE = &unicode;
 		uchar	utf8[4];
 		uchar	*UTF8 = utf8;
-		
+	
 		*(uint32 *)utf8 = 0;
 		u_hostendian_to_utf8(UTF8, UNICODE);
-		
+	
 		int32 utf8Len = UTF8 - utf8;
 		if ((dstCount + utf8Len) &gt; dstLimit)
 			break;
@@ -1057,13 +1057,13 @@
 
 	while ((srcCount &lt; srcLimit) &amp;&amp; (dstCount &lt; dstLimit)) {
 		if ((srcCount + utf8_char_len(src[srcCount])) &gt; srcLimit)
-			break; 
+			break;
 
 		uint16 unicode;
 		uint16 *UNICODE = &unicode;
 		int				err_flag;
 		bool			multibyte = false;
-		const uint16	*table = NULL;	
+		const uint16	*table = NULL;
 		uchar			*UTF8 = (uchar *)src + srcCount;
 
 		utf8_to_u_hostendian(UTF8, UNICODE, err_flag);
@@ -1077,7 +1077,7 @@
 					uint16 offset = sjistables[t].offset;
 
 					if (offset == 0x0000)
-						dst[dstCount] = i; 
+						dst[dstCount] = i;
 					else {
 						if ((dstCount + 1) &lt; dstLimit) {
 							uint16 sjis = offset + i;
@@ -1127,7 +1127,7 @@
 
 // takes a unicode name of unilen uchar's and converts to a utf8 name of at
 // most utf8len uint8's
-status_t unicode_to_utf8(const uchar *uni, uint32 unilen, uint8 *utf8, 
+status_t unicode_to_utf8(const uchar *uni, uint32 unilen, uint8 *utf8,
 	uint32 utf8len)
 {
 	status_t result;
@@ -1259,7 +1259,7 @@
 		if (nshort[i] == ' ') break;
 		if (is_initial_sjis_byte(nshort[i])) i++;
 	}
-	
+
 	memcpy(nshort + last, buffer, len);
 	memset(nshort + last + len, ' ', 8 - (last + len));
 
@@ -1459,8 +1459,8 @@
 		dprintf(&quot;generate_short_name_sjis error: %lx (%s)\n&quot;, result, strerror(result));
 	}
 
-	free(sjis);	
-	
+	free(sjis);
+
 	return result;
 }
 
@@ -1514,7 +1514,7 @@
 	pos = 0;
 	for (i=0;i&lt;8;i++) {
 		if (msdos[i] == ' ') break;
-		normalized[pos++] = ((i == 0) &amp;&amp; (msdos[i] == 5)) ? 0xe5 : 
+		normalized[pos++] = ((i == 0) &amp;&amp; (msdos[i] == 5)) ? 0xe5 :
 			(toLower ? tolower(msdos[i]) : msdos[i]);
 	}
 
@@ -1539,24 +1539,24 @@
 	int i, len;
 
 	if (encoding != MS_DOS_CONVERSION) return true;
-	
+
 	for ( ; *utf8name != 0; utf8name++) {
 		if (!BEGINS_UTF8CHAR(*utf8name)) continue;
 		if (*utf8name == '.') break;
 		leading++;
 		if (leading &gt; 8) return true;
-		if ((nshort[leading - 1] == '_') &amp;&amp; (*utf8name != '_')) return true; 
+		if ((nshort[leading - 1] == '_') &amp;&amp; (*utf8name != '_')) return true;
 	}
-	
+
 	if (*utf8name != 0) {
 		utf8name++;
-	
+
 		for ( ; *utf8name != 0; utf8name++) {
 			if (!BEGINS_UTF8CHAR(*utf8name)) continue;
 			if (*utf8name == '.') return true;
 			trailing++;
 			if (trailing &gt; 3) return true;
-			if ((nshort[leading + trailing - 1] == '_') &amp;&amp; (*utf8name != '_')) return true; 
+			if ((nshort[leading + trailing - 1] == '_') &amp;&amp; (*utf8name != '_')) return true;
 		}
 	}
 
@@ -1567,7 +1567,7 @@
 	for (i = 8, len = 0; i &lt; 11; i++)
 		if (nshort[i] != ' ') len++;
 	if (len != trailing) return true;
-	
+
 	return false;
 }
 

Modified: haiku/trunk/src/add-ons/kernel/file_systems/fat/fat.c
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/fat/fat.c	2008-04-17 06:26:43 UTC (rev 24994)
+++ haiku/trunk/src/add-ons/kernel/file_systems/fat/fat.c	2008-04-17 10:02:49 UTC (rev 24995)
@@ -2,7 +2,7 @@
 	Copyright 1999-2001, Be Incorporated.   All Rights Reserved.
 	This file may be used under the terms of the Be Sample Code License.
 */
-#include &lt;KernelExport.h&gt; 

[... truncated: 726 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="007822.html">[Haiku-commits] r24994 - in haiku/trunk: build/jam	src/add-ons/kernel/file_systems/iso9660
</A></li>
	<LI>Next message: <A HREF="007824.html">[Haiku-commits] r24996 -	haiku/trunk/src/add-ons/kernel/file_systems/fat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7823">[ date ]</a>
              <a href="thread.html#7823">[ thread ]</a>
              <a href="subject.html#7823">[ subject ]</a>
              <a href="author.html#7823">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
