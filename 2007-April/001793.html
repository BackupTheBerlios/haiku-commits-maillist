<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r20809 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20809%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/bfs&In-Reply-To=%3C200704251047.l3PAlQA6029609%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001792.html">
   <LINK REL="Next"  HREF="001794.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r20809 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs</H1>
    <B>axeld at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20809%20-%0A%09haiku/trunk/src/add-ons/kernel/file_systems/bfs&In-Reply-To=%3C200704251047.l3PAlQA6029609%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r20809 -	haiku/trunk/src/add-ons/kernel/file_systems/bfs">axeld at mail.berlios.de
       </A><BR>
    <I>Wed Apr 25 12:47:26 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001792.html">[Haiku-commits] r20808 - haiku/trunk/src/system/kernel
</A></li>
        <LI>Next message: <A HREF="001794.html">[Haiku-commits] r20810 -	haiku/trunk/src/tests/add-ons/kernel/file_systems/bfs/r5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1793">[ date ]</a>
              <a href="thread.html#1793">[ thread ]</a>
              <a href="subject.html#1793">[ subject ]</a>
              <a href="author.html#1793">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: axeld
Date: 2007-04-25 12:47:24 +0200 (Wed, 25 Apr 2007)
New Revision: 20809
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=20809&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=20809&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
   haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
Log:
* Changed Inode::WriteAttribute() so that it no longer reads from the old
  attribute when its size was 0 - this also fixes calling Index::Update()
  with invalid values, and therefore bug #1178.
* Style cleanup: honour 80 column limit a bit more, use doxygen style comments.


Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2007-04-25 08:25:10 UTC (rev 20808)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Index.cpp	2007-04-25 10:47:24 UTC (rev 20809)
@@ -1,10 +1,11 @@
-/* Index - index access functions
- *
- * Copyright 2001-2006, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
+/* 
+ * Copyright 2001-2007, Axel D&#246;rfler, <A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">axeld at pinc-software.de.</A>
  * This file may be used under the terms of the MIT License.
  */
 
+//! index access functions
 
+
 #include &quot;Debug.h&quot;
 #include &quot;Index.h&quot;
 #include &quot;Volume.h&quot;
@@ -50,13 +51,13 @@
 }
 
 
-/** Sets the index to specified one. Returns an error if the index could
- *	not be found or initialized.
- *	Note, Index::Update() may be called on the object even if this method
- *	failed previously. In this case, it will only update live queries for
- *	the updated attribute.
- */
-
+/*!
+	Sets the index to specified one. Returns an error if the index could
+	not be found or initialized.
+	Note, Index::Update() may be called on the object even if this method
+	failed previously. In this case, it will only update live queries for
+	the updated attribute.
+*/
 status_t
 Index::SetTo(const char *name)
 {
@@ -88,7 +89,8 @@
 		return B_ENTRY_NOT_FOUND;
 
 	if (fNode == NULL) {
-		FATAL((&quot;fatal error at Index::InitCheck(), get_vnode() returned NULL pointer\n&quot;));
+		FATAL((&quot;fatal error at Index::InitCheck(), get_vnode() returned &quot;
+			&quot;NULL pointer\n&quot;));
 		return B_ERROR;
 	}
 
@@ -97,19 +99,20 @@
 }
 
 
-/** Returns a standard type code for the stat() index type codes. Returns
- *	zero if the type is not known (can only happen if the mode field is
- *	corrupted somehow or not that of an index).
- */
-
+/*!
+	Returns a standard type code for the stat() index type codes. Returns
+	zero if the type is not known (can only happen if the mode field is
+	corrupted somehow or not that of an index).
+*/
 uint32
 Index::Type()
 {
 	if (fNode == NULL)
 		return 0;
 
-	switch (fNode-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX | S_LONG_LONG_INDEX |
-							 S_ULONG_LONG_INDEX | S_FLOAT_INDEX | S_DOUBLE_INDEX)) {
+	switch (fNode-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX
+			| S_LONG_LONG_INDEX | S_ULONG_LONG_INDEX | S_FLOAT_INDEX
+			| S_DOUBLE_INDEX)) {
 		case S_INT_INDEX:
 			return B_INT32_TYPE;
 		case S_UINT_INDEX:
@@ -136,8 +139,9 @@
 	if (fNode == NULL)
 		return 0;
 	
-	int32 mode = fNode-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX | S_LONG_LONG_INDEX |
-								  S_ULONG_LONG_INDEX | S_FLOAT_INDEX | S_DOUBLE_INDEX);
+	int32 mode = fNode-&gt;Mode() &amp; (S_STR_INDEX | S_INT_INDEX | S_UINT_INDEX
+		| S_LONG_LONG_INDEX | S_ULONG_LONG_INDEX | S_FLOAT_INDEX
+		| S_DOUBLE_INDEX);
 
 	if (mode == S_STR_INDEX)
 		// string indices don't have a fixed key size
@@ -209,16 +213,17 @@
 }
 
 
-/**	Updates the specified index, the oldKey will be removed from, the newKey
- *	inserted into the tree.
- *	If the method returns B_BAD_INDEX, it means the index couldn't be found -
- *	the most common reason will be that the index doesn't exist.
- *	You may not want to let the whole transaction fail because of that.
- */
-
+/*!
+	Updates the specified index, the oldKey will be removed from, the newKey
+	inserted into the tree.
+	If the method returns B_BAD_INDEX, it means the index couldn't be found -
+	the most common reason will be that the index doesn't exist.
+	You may not want to let the whole transaction fail because of that.
+*/
 status_t
-Index::Update(Transaction &amp;transaction, const char *name, int32 type, const uint8 *oldKey,
-	uint16 oldLength, const uint8 *newKey, uint16 newLength, Inode *inode)
+Index::Update(Transaction &amp;transaction, const char *name, int32 type,
+	const uint8 *oldKey, uint16 oldLength, const uint8 *newKey,
+	uint16 newLength, Inode *inode)
 {
 	if (name == NULL
 		|| oldKey == NULL &amp;&amp; newKey == NULL
@@ -237,11 +242,12 @@
 		return B_OK;
 
 	// update all live queries about the change, if they have an index or not
-	if (type != 0)
-		fVolume-&gt;UpdateLiveQueries(inode, name, type, oldKey, oldLength, newKey, newLength);
+	if (type != 0) {
+		fVolume-&gt;UpdateLiveQueries(inode, name, type, oldKey, oldLength,
+			newKey, newLength);
+	}
 
-	status_t status;
-	if (((name != fName || strcmp(name, fName)) &amp;&amp; (status = SetTo(name)) &lt; B_OK)
+	if (((name != fName || strcmp(name, fName)) &amp;&amp; SetTo(name) &lt; B_OK)
 		|| fNode == NULL)
 		return B_BAD_INDEX;
 
@@ -250,19 +256,23 @@
 		return B_OK;
 
 	// same for the live query update
-	if (type == 0)
-		fVolume-&gt;UpdateLiveQueries(inode, name, Type(), oldKey, oldLength, newKey, newLength);
-		
+	if (type == 0) {
+		fVolume-&gt;UpdateLiveQueries(inode, name, Type(), oldKey, oldLength,
+			newKey, newLength);
+	}
+
 	BPlusTree *tree;
-	if ((status = Node()-&gt;GetTree(&amp;tree)) &lt; B_OK)
+	status_t status = Node()-&gt;GetTree(&amp;tree);
+	if (status &lt; B_OK)
 		return status;
 
 	// remove the old key from the tree
 
 	if (oldKey != NULL) {
-		status = tree-&gt;Remove(transaction, (const uint8 *)oldKey, oldLength, inode-&gt;ID());
+		status = tree-&gt;Remove(transaction, (const uint8 *)oldKey, oldLength,
+			inode-&gt;ID());
 		if (status == B_ENTRY_NOT_FOUND) {
-			// That's not nice, but should be no reason to let the whole thing fail
+			// That's not nice, but no reason to let the whole thing fail
 			INFORM((&quot;Could not find value in index \&quot;%s\&quot;!\n&quot;, name));
 		} else if (status &lt; B_OK)
 			return status;
@@ -270,8 +280,10 @@
 
 	// add the new key to the tree
 
-	if (newKey != NULL)
-		status = tree-&gt;Insert(transaction, (const uint8 *)newKey, newLength, inode-&gt;ID());
+	if (newKey != NULL) {
+		status = tree-&gt;Insert(transaction, (const uint8 *)newKey, newLength,
+			inode-&gt;ID());
+	}
 
 	RETURN_ERROR(status);
 }
@@ -297,8 +309,8 @@
 {
 	ASSERT(inode-&gt;IsRegularNode());
 
-	uint16 oldLength = oldName ? strlen(oldName) : 0;
-	uint16 newLength = newName ? strlen(newName) : 0;
+	uint16 oldLength = oldName != NULL ? strlen(oldName) : 0;
+	uint16 newLength = newName != NULL ? strlen(newName) : 0;
 	return Update(transaction, &quot;name&quot;, B_STRING_TYPE, (uint8 *)oldName,
 		oldLength, (uint8 *)newName, newLength, inode);
 }
@@ -310,7 +322,8 @@
 	ASSERT(inode-&gt;IsFile());
 
 	off_t size = inode-&gt;Size();
-	return Update(transaction, &quot;size&quot;, B_INT64_TYPE, NULL, 0, (uint8 *)&amp;size, sizeof(int64), inode);
+	return Update(transaction, &quot;size&quot;, B_INT64_TYPE, NULL, 0, (uint8 *)&amp;size,
+		sizeof(int64), inode);
 }
 
 
@@ -321,7 +334,8 @@
 
 	// Inode::OldSize() is the size that's in the index
 	off_t size = inode-&gt;OldSize();
-	return Update(transaction, &quot;size&quot;, B_INT64_TYPE, (uint8 *)&amp;size, sizeof(int64), NULL, 0, inode);
+	return Update(transaction, &quot;size&quot;, B_INT64_TYPE, (uint8 *)&amp;size,
+		sizeof(int64), NULL, 0, inode);
 }
 
 
@@ -333,8 +347,9 @@
 	off_t oldSize = inode-&gt;OldSize();
 	off_t newSize = inode-&gt;Size();
 
-	status_t status = Update(transaction, &quot;size&quot;, B_INT64_TYPE, (uint8 *)&amp;oldSize,
-		sizeof(int64), (uint8 *)&amp;newSize, sizeof(int64), inode);
+	status_t status = Update(transaction, &quot;size&quot;, B_INT64_TYPE,
+		(uint8 *)&amp;oldSize, sizeof(int64), (uint8 *)&amp;newSize, sizeof(int64),
+		inode);
 	if (status == B_OK)
 		inode-&gt;UpdateOldSize();
 
@@ -360,13 +375,14 @@
 
 	// Inode::OldLastModified() is the value which is in the index
 	off_t modified = inode-&gt;OldLastModified();
-	return Update(transaction, &quot;last_modified&quot;, B_INT64_TYPE, (uint8 *)&amp;modified,
-		sizeof(int64), NULL, 0, inode);
+	return Update(transaction, &quot;last_modified&quot;, B_INT64_TYPE,
+		(uint8 *)&amp;modified, sizeof(int64), NULL, 0, inode);
 }
 
 
 status_t
-Index::UpdateLastModified(Transaction &amp;transaction, Inode *inode, off_t modified)
+Index::UpdateLastModified(Transaction &amp;transaction, Inode *inode,
+	off_t modified)
 {
 	ASSERT(inode-&gt;IsFile() || inode-&gt;IsSymLink());
 
@@ -375,8 +391,9 @@
 		modified = (bigtime_t)time(NULL) &lt;&lt; INODE_TIME_SHIFT;
 	modified |= fVolume-&gt;GetUniqueID() &amp; INODE_TIME_MASK;
 
-	status_t status = Update(transaction, &quot;last_modified&quot;, B_INT64_TYPE, (uint8 *)&amp;oldModified,
-		sizeof(int64), (uint8 *)&amp;modified, sizeof(int64), inode);
+	status_t status = Update(transaction, &quot;last_modified&quot;, B_INT64_TYPE,
+		(uint8 *)&amp;oldModified, sizeof(int64), (uint8 *)&amp;modified,
+		sizeof(int64), inode);
 
 	inode-&gt;Node().last_modified_time = HOST_ENDIAN_TO_BFS_INT64(modified);
 	if (status == B_OK)

Modified: haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp
===================================================================
--- haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-04-25 08:25:10 UTC (rev 20808)
+++ haiku/trunk/src/add-ons/kernel/file_systems/bfs/Inode.cpp	2007-04-25 10:47:24 UTC (rev 20809)
@@ -166,7 +166,7 @@
 }
 
 
-//	#pragma mark -
+//	#pragma mark - Inode
 
 
 Inode::Inode(Volume *volume, vnode_id id)
@@ -349,14 +349,14 @@
 }
 
 
-/**	Tries to free up &quot;bytes&quot; space in the small_data section by moving
- *	attributes to real files. Used for system attributes like the name.
- *	You need to hold the fSmallDataLock when you call this method
- */
-
+/*!
+	Tries to free up &quot;bytes&quot; space in the small_data section by moving
+	attributes to real files. Used for system attributes like the name.
+	You need to hold the fSmallDataLock when you call this method
+*/
 status_t
-Inode::_MakeSpaceForSmallData(Transaction &amp;transaction, bfs_inode *node, const char *name,
-	int32 bytes)
+Inode::_MakeSpaceForSmallData(Transaction &amp;transaction, bfs_inode *node,
+	const char *name, int32 bytes)
 {
 	ASSERT(fSmallDataLock.IsLocked());
 
@@ -414,11 +414,11 @@
 }
 
 
-/**	Private function which removes the given attribute from the small_data
- *	section.
- *	You need to hold the fSmallDataLock when you call this method
- */
-
+/*!
+	Private function which removes the given attribute from the small_data
+	section.
+	You need to hold the fSmallDataLock when you call this method
+*/
 status_t
 Inode::_RemoveSmallData(bfs_inode *node, small_data *item, int32 index)
 {
@@ -446,16 +446,15 @@
 
 	// update all current iterators
 	AttributeIterator *iterator = NULL;
-	while ((iterator = fIterators.Next(iterator)) != NULL)
+	while ((iterator = fIterators.Next(iterator)) != NULL) {
 		iterator-&gt;Update(index, -1);
+	}
 
 	return B_OK;
 }
 
 
-/**	Removes the given attribute from the small_data section.
- */
-
+//!	Removes the given attribute from the small_data section.
 status_t
 Inode::_RemoveSmallData(Transaction &amp;transaction, NodeGetter &amp;nodeGetter,
 	const char *name)
@@ -487,18 +486,18 @@
 }
 
 
-/**	Try to place the given attribute in the small_data section - if the
- *	new attribute is too big to fit in that section, it returns B_DEVICE_FULL.
- *	In that case, the attribute should be written to a real attribute file;
- *	it's the caller's responsibility to remove any existing attributes in the small
- *	data section if that's the case.
- *
- *	Note that you need to write back the inode yourself after having called that
- *	method - it's a bad API decision that it needs a transaction but enforces you
- *	to write back the inode all by yourself, but it's just more efficient in most
- *	cases...
- */
+/*!
+	Try to place the given attribute in the small_data section - if the
+	new attribute is too big to fit in that section, it returns B_DEVICE_FULL.
+	In that case, the attribute should be written to a real attribute file;
+	it's the caller's responsibility to remove any existing attributes in the small
+	data section if that's the case.
 
+	Note that you need to write back the inode yourself after having called that
+	method - it's a bad API decision that it needs a transaction but enforces you
+	to write back the inode all by yourself, but it's just more efficient in most
+	cases...
+*/
 status_t
 Inode::_AddSmallData(Transaction &amp;transaction, NodeGetter &amp;nodeGetter,
 	const char *name, uint32 type, const uint8 *data, size_t length, bool force)
@@ -622,25 +621,26 @@
 
 	// update all current iterators
 	AttributeIterator *iterator = NULL;
-	while ((iterator = fIterators.Next(iterator)) != NULL)
+	while ((iterator = fIterators.Next(iterator)) != NULL) {
 		iterator-&gt;Update(index, 1);
+	}
 
 	return B_OK;
 }
 
 
-/**	Iterates through the small_data section of an inode.
- *	To start at the beginning of this section, you let smallData
- *	point to NULL, like:
- *		small_data *data = NULL;
- *		while (inode-&gt;GetNextSmallData(&amp;data) { ... }
- *
- *	This function is reentrant and doesn't allocate any memory;
- *	you can safely stop calling it at any point (you don't need
- *	to iterate through the whole list).
- *	You need to hold the fSmallDataLock when you call this method
- */
+/*!
+	Iterates through the small_data section of an inode.
+	To start at the beginning of this section, you let smallData
+	point to NULL, like:
+		small_data *data = NULL;
+		while (inode-&gt;GetNextSmallData(&amp;data) { ... }
 
+	This function is reentrant and doesn't allocate any memory;
+	you can safely stop calling it at any point (you don't need
+	to iterate through the whole list).
+	You need to hold the fSmallDataLock when you call this method
+*/
 status_t
 Inode::_GetNextSmallData(bfs_inode *node, small_data **_smallData) const
 {
@@ -667,11 +667,11 @@
 }
 
 
-/**	Finds the attribute &quot;name&quot; in the small data section, and
- *	returns a pointer to it (or NULL if it doesn't exist).
- *	You need to hold the fSmallDataLock when you call this method
- */
-
+/*!
+	Finds the attribute &quot;name&quot; in the small data section, and
+	returns a pointer to it (or NULL if it doesn't exist).
+	You need to hold the fSmallDataLock when you call this method
+*/
 small_data *
 Inode::FindSmallData(const bfs_inode *node, const char *name) const
 {
@@ -686,11 +686,11 @@
 }
 
 
-/** Returns a pointer to the node's name if present in the small data
- *	section, NULL otherwise.
- *	You need to hold the fSmallDataLock when you call this method
- */
-
+/*!
+	Returns a pointer to the node's name if present in the small data
+	section, NULL otherwise.
+	You need to hold the fSmallDataLock when you call this method
+*/
 const char *
 Inode::Name(const bfs_inode *node) const
 {
@@ -706,10 +706,10 @@
 }
 
 
-/** Copies the node's name into the provided buffer.
- *	The buffer should be B_FILE_NAME_LENGTH bytes large.
- */
-
+/*!
+	Copies the node's name into the provided buffer.
+	The buffer should be B_FILE_NAME_LENGTH bytes large.
+*/
 status_t
 Inode::GetName(char *buffer, size_t size) const
 {
@@ -725,13 +725,13 @@
 }
 
 
-/**	Changes or set the name of a file: in the inode small_data section only, it
- *	doesn't change it in the parent directory's b+tree.
- *	Note that you need to write back the inode yourself after having called
- *	that method. It suffers from the same API decision as AddSmallData() does
- *	(and for the same reason).
- */
-
+/*!
+	Changes or set the name of a file: in the inode small_data section only, it
+	doesn't change it in the parent directory's b+tree.
+	Note that you need to write back the inode yourself after having called
+	that method. It suffers from the same API decision as AddSmallData() does
+	(and for the same reason).
+*/
 status_t
 Inode::SetName(Transaction &amp;transaction, const char *name)
 {
@@ -793,11 +793,11 @@
 }
 
 
-/**	Reads data from the specified attribute.
- *	This is a high-level attribute function that understands attributes
- *	in the small_data section as well as real attribute files.
- */
-
+/*!
+	Reads data from the specified attribute.
+	This is a high-level attribute function that understands attributes
+	in the small_data section as well as real attribute files.
+*/
 status_t
 Inode::ReadAttribute(const char *name, int32 type, off_t pos, uint8 *buffer,
 	size_t *_length)
@@ -843,11 +843,11 @@
 }
 
 
-/**	Writes data to the specified attribute.
- *	This is a high-level attribute function that understands attributes
- *	in the small_data section as well as real attribute files.
- */
-
+/*!
+	Writes data to the specified attribute.
+	This is a high-level attribute function that understands attributes
+	in the small_data section as well as real attribute files.
+*/
 status_t
 Inode::WriteAttribute(Transaction &amp;transaction, const char *name, int32 type,
 	off_t pos, const uint8 *buffer, size_t *_length)
@@ -856,7 +856,7 @@
 	uint8 oldBuffer[BPLUSTREE_MAX_KEY_LENGTH], *oldData = NULL;
 	size_t oldLength = 0;
 
-	// ToDo: we actually depend on that the contents of &quot;buffer&quot; are constant.
+	// TODO: we actually depend on that the contents of &quot;buffer&quot; are constant.
 	// If they get changed during the write (hey, user programs), we may mess
 	// up our index trees!
 
@@ -874,9 +874,11 @@
 		small_data *smallData = FindSmallData(node.Node(), name);
 		if (smallData != NULL) {
 			oldLength = smallData-&gt;DataSize();
-			if (oldLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
-				oldLength = BPLUSTREE_MAX_KEY_LENGTH;
-			memcpy(oldData = oldBuffer, smallData-&gt;Data(), oldLength);
+			if (oldLength &gt; 0) {
+				if (oldLength &gt; BPLUSTREE_MAX_KEY_LENGTH)
+					oldLength = BPLUSTREE_MAX_KEY_LENGTH;
+				memcpy(oldData = oldBuffer, smallData-&gt;Data(), oldLength);
+			}
 		}
 		fSmallDataLock.Unlock();
 
@@ -903,7 +905,7 @@
 	if (attribute != NULL) {
 		if (attribute-&gt;Lock().LockWrite() == B_OK) {
 			// save the old attribute data (if this fails, oldLength will reflect it)
-			if (fVolume-&gt;CheckForLiveQuery(name)) {
+			if (fVolume-&gt;CheckForLiveQuery(name) &amp;&amp; attribute-&gt;Size() &gt; 0) {
 				oldLength = BPLUSTREE_MAX_KEY_LENGTH;
 				if (attribute-&gt;ReadAt(0, oldBuffer, &amp;oldLength) == B_OK)
 					oldData = oldBuffer;
@@ -931,7 +933,7 @@
 		ReleaseAttribute(attribute);
 	}
 
-	// ToDo: find a better way than this &quot;pos&quot; thing (the begin of the old key
+	// TODO: find a better way than this &quot;pos&quot; thing (the begin of the old key
 	//	must be copied to the start of the new one for a comparison)
 	if (status == B_OK &amp;&amp; pos == 0) {
 		// index only the first BPLUSTREE_MAX_KEY_LENGTH bytes
@@ -941,18 +943,20 @@
 
 		// Update index. Note, Index::Update() may be called even if initializing
 		// the index failed - it will just update the live queries in this case
-		if (pos &lt; length || pos &lt; oldLength)
-			index.Update(transaction, name, type, oldData, oldLength, buffer, length, this);
+		if (pos &lt; length || pos &lt; oldLength) {
+			index.Update(transaction, name, type, oldData, oldLength, buffer,
+				length, this);
+		}
 	}
 	return status;
 }
 
 
-/**	Removes the specified attribute from the inode.
- *	This is a high-level attribute function that understands attributes
- *	in the small_data section as well as real attribute files.
- */
-
+/*!
+	Removes the specified attribute from the inode.
+	This is a high-level attribute function that understands attributes
+	in the small_data section as well as real attribute files.
+*/
 status_t
 Inode::RemoveAttribute(Transaction &amp;transaction, const char *name)
 {
@@ -985,7 +989,7 @@
 
 
 status_t
-Inode::GetAttribute(const char *name, Inode **attribute)
+Inode::GetAttribute(const char *name, Inode **_attribute)
 {
 	// does this inode even have attributes?
 	if (Attributes().IsZero())
@@ -1002,13 +1006,15 @@
 	status_t status = attributes-&gt;GetTree(&amp;tree);
 	if (status == B_OK) {
 		vnode_id id;
-		if ((status = tree-&gt;Find((uint8 *)name, (uint16)strlen(name), &amp;id)) == B_OK) {
+		status = tree-&gt;Find((uint8 *)name, (uint16)strlen(name), &amp;id);
+		if (status == B_OK) {
 			Vnode vnode(fVolume, id);
+			Inode *inode;
 			// Check if the attribute is really an attribute
-			if (vnode.Get(attribute) &lt; B_OK
-				|| !(*attribute)-&gt;IsAttribute())
+			if (vnode.Get(&amp;inode) &lt; B_OK || !inode-&gt;IsAttribute())
 				return B_ERROR;
 
+			*_attribute = inode;
 			vnode.Keep();
 			return B_OK;
 		}
@@ -1049,15 +1055,15 @@
 }
 
 
-//	#pragma mark -
+//	#pragma mark - directory tree
 
 
-/**	Gives the caller direct access to the b+tree for a given directory.
- *	The tree is no longer created on demand, but when the inode is first
- *	created. That will report any potential errors upfront, saves locking,
- *	and should work as good (though a bit slower).
- */
-
+/*!
+	Gives the caller direct access to the b+tree for a given directory.
+	The tree is no longer created on demand, but when the inode is first
+	created. That will report any potential errors upfront, saves locking,
+	and should work as good (though a bit slower).
+*/
 status_t
 Inode::GetTree(BPlusTree **tree)
 {
@@ -1088,7 +1094,8 @@
 	char name[BPLUSTREE_MAX_KEY_LENGTH];
 	uint16 length;
 	vnode_id id;
-	while (iterator.GetNextEntry(name, &amp;length, B_FILE_NAME_LENGTH, &amp;id) == B_OK) {
+	while (iterator.GetNextEntry(name, &amp;length, B_FILE_NAME_LENGTH,
+			&amp;id) == B_OK) {
 		if (Mode() &amp; (S_ATTR_DIR | S_INDEX_DIR))
 			return false;
 
@@ -1099,14 +1106,17 @@
 }
 
 
-/** Finds the block_run where &quot;pos&quot; is located in the data_stream of
- *	the inode.
- *	If successful, &quot;offset&quot; will then be set to the file offset
- *	of the block_run returned; so &quot;pos - offset&quot; is for the block_run
- *	what &quot;pos&quot; is for the whole stream.
- *	The caller has to make sure that &quot;pos&quot; is inside the stream.
- */
+//	#pragma mark - data stream
 
+
+/*!
+	Finds the block_run where &quot;pos&quot; is located in the data_stream of
+	the inode.
+	If successful, &quot;offset&quot; will then be set to the file offset
+	of the block_run returned; so &quot;pos - offset&quot; is for the block_run
+	what &quot;pos&quot; is for the whole stream.
+	The caller has to make sure that &quot;pos&quot; is inside the stream.
+*/
 status_t
 Inode::FindBlockRun(off_t pos, block_run &amp;run, off_t &amp;offset)
 {
@@ -1121,7 +1131,8 @@
 			CachedBlock cached(fVolume);
 
 			off_t start = pos - data-&gt;MaxIndirectRange();
-			int32 indirectSize = (1L &lt;&lt; (INDIRECT_BLOCKS_SHIFT + cached.BlockShift()))
+			int32 indirectSize = (1L &lt;&lt; (INDIRECT_BLOCKS_SHIFT
+					+ cached.BlockShift()))
 				* (fVolume-&gt;BlockSize() / sizeof(block_run));
 			int32 directSize = NUM_ARRAY_BLOCKS &lt;&lt; cached.BlockShift();
 			int32 index = start / indirectSize;
@@ -1138,12 +1149,14 @@
 			int32 current = (start % indirectSize) / directSize;
 
 			indirect = (block_run *)cached.SetTo(
-					fVolume-&gt;ToBlock(indirect[index % runsPerBlock]) + current / runsPerBlock);
+				fVolume-&gt;ToBlock(indirect[index % runsPerBlock])
+				+ current / runsPerBlock);
 			if (indirect == NULL)
 				RETURN_ERROR(B_ERROR);
 
 			run = indirect[current % runsPerBlock];
-			offset = data-&gt;MaxIndirectRange() + (index * indirectSize) + (current * directSize);
+			offset = data-&gt;MaxIndirectRange() + (index * indirectSize)
+				+ (current * directSize);
 			//printf(&quot;\tfCurrent = %ld, fRunFileOffset = %Ld, fRunBlockEnd = %Ld, fRun = %ld,%d\n&quot;,fCurrent,fRunFileOffset,fRunBlockEnd,fRun.allocation_group,fRun.start);
 		} else {
 			// access to indirect blocks
@@ -1164,10 +1177,12 @@
 					if (indirect[current].IsZero())
 						break;
 
-					runBlockEnd += indirect[current].Length() &lt;&lt; cached.BlockShift();
+					runBlockEnd += indirect[current].Length()
+						&lt;&lt; cached.BlockShift();
 					if (runBlockEnd &gt; pos) {
 						run = indirect[current];
-						offset = runBlockEnd - (run.Length() &lt;&lt; cached.BlockShift());
+						offset = runBlockEnd - (run.Length()
+							&lt;&lt; cached.BlockShift());
 						//printf(&quot;reading from indirect block: %ld,%d\n&quot;,fRun.allocation_group,fRun.start);
 						//printf(&quot;### indirect-run[%ld] = (%ld,%d,%d), offset = %Ld\n&quot;,fCurrent,fRun.allocation_group,fRun.start,fRun.Length(),fRunFileOffset);
 						return fVolume-&gt;ValidateBlockRun(run);
@@ -1186,7 +1201,8 @@
 			if (data-&gt;direct[current].IsZero())
 				break;
 
-			runBlockEnd += data-&gt;direct[current].Length() &lt;&lt; fVolume-&gt;BlockShift();
+			runBlockEnd += data-&gt;direct[current].Length()
+				&lt;&lt; fVolume-&gt;BlockShift();
 			if (runBlockEnd &gt; pos) {
 				run = data-&gt;direct[current];
 				offset = runBlockEnd - (run.Length() &lt;&lt; fVolume-&gt;BlockShift());
@@ -1229,14 +1245,16 @@
 
 
 status_t
-Inode::WriteAt(Transaction &amp;transaction, off_t pos, const uint8 *buffer, size_t *_length)
+Inode::WriteAt(Transaction &amp;transaction, off_t pos, const uint8 *buffer,
+	size_t *_length)
 {
 	// update the last modification time in memory, it will be written
 	// back to the inode, and the index when the file is closed
 	// ToDo: should update the internal last modified time only at this point!
-	Node().last_modified_time = HOST_ENDIAN_TO_BFS_INT64((bigtime_t)time(NULL) &lt;&lt; INODE_TIME_SHIFT);
+	Node().last_modified_time = HOST_ENDIAN_TO_BFS_INT64((bigtime_t)time(NULL)
+		&lt;&lt; INODE_TIME_SHIFT);
 
-	// ToDo: support INODE_LOGGED!
+	// TODO: support INODE_LOGGED!
 #if 0
 	if (Flags() &amp; INODE_LOGGED)
 		return ((Stream&lt;Access::Logged&gt; *)this)-&gt;WriteAt(transaction, pos, buffer, _length);
@@ -1286,13 +1304,13 @@
 }
 
 
-/**	Fills the gap between the old file size and the new file size
- *	with zeros.
- *	It's more or less a copy of Inode::WriteAt() but it can handle
- *	length differences of more than just 4 GB, and it never uses
- *	the log, even if the INODE_LOGGED flag is set.
- */
-
+/*!
+	Fills the gap between the old file size and the new file size
+	with zeros.
+	It's more or less a copy of Inode::WriteAt() but it can handle
+	length differences of more than just 4 GB, and it never uses
+	the log, even if the INODE_LOGGED flag is set.
+*/
 status_t
 Inode::FillGapWithZeros(off_t pos, off_t newSize)
 {
@@ -1374,19 +1392,19 @@
 }
 
 
-/** Allocates NUM_ARRAY_BLOCKS blocks, and clears their contents. Growing
- *	the indirect and double indirect range uses this method.
- *	The allocated block_run is saved in &quot;run&quot;
- */
-
+/*!
+	Allocates NUM_ARRAY_BLOCKS blocks, and clears their contents. Growing
+	the indirect and double indirect range uses this method.
+	The allocated block_run is saved in &quot;run&quot;
+*/
 status_t
 Inode::_AllocateBlockArray(Transaction &amp;transaction, block_run &amp;run)
 {
 	if (!run.IsZero())
 		return B_BAD_VALUE;
 
-	status_t status = fVolume-&gt;Allocate(transaction, this, NUM_ARRAY_BLOCKS, run,
-		NUM_ARRAY_BLOCKS);
+	status_t status = fVolume-&gt;Allocate(transaction, this, NUM_ARRAY_BLOCKS,
+		run, NUM_ARRAY_BLOCKS);
 	if (status &lt; B_OK)
 		return status;
 
@@ -1395,7 +1413,8 @@
 	off_t block = fVolume-&gt;ToBlock(run);
 
 	for (int32 i = 0; i &lt; run.Length(); i++) {
-		block_run *runs = (block_run *)cached.SetToWritable(transaction, block + i, true);
+		block_run *runs = (block_run *)cached.SetToWritable(transaction,
+			block + i, true);
 		if (runs == NULL)
 			return B_IO_ERROR;
 	}
@@ -1432,7 +1451,8 @@
 		bytes = size - data-&gt;Size();
 
 	// do we have enough free blocks on the disk?
-	off_t blocksRequested = (bytes + fVolume-&gt;BlockSize() - 1) &gt;&gt; fVolume-&gt;BlockShift();
+	off_t blocksRequested = (bytes + fVolume-&gt;BlockSize() - 1)
+		&gt;&gt; fVolume-&gt;BlockShift();
 	if (blocksRequested &gt; fVolume-&gt;FreeBlocks())
 		return B_DEVICE_FULL;
 
@@ -1442,8 +1462,9 @@
 		// from the block allocator
 
 	// Should we preallocate some blocks (currently, always 64k)?
-	// Attributes, attribute directories, and long symlinks usually won't get that big,
-	// and should stay close to the inode - preallocating could be counterproductive.
+	// Attributes, attribute directories, and long symlinks usually won't get
+	// that big, and should stay close to the inode - preallocating could be
+	// counterproductive.
 	// Also, if free disk space is tight, we probably don't want to do this as well.
 	if (!IsAttribute() &amp;&amp; !IsAttributeDirectory() &amp;&amp; !IsSymLink()
 		&amp;&amp; blocksRequested &lt; (65536 &gt;&gt; fVolume-&gt;BlockShift())
@@ -1455,14 +1476,15 @@
 		// single allocation, so we need to iterate until we have
 		// enough blocks allocated
 		block_run run;
-		status_t status = fVolume-&gt;Allocate(transaction, this, blocksRequested, run, minimum);
+		status_t status = fVolume-&gt;Allocate(transaction, this, blocksRequested,
+			run, minimum);
 		if (status &lt; B_OK)
 			return status;
 
 		// okay, we have the needed blocks, so just distribute them to the
 		// different ranges of the stream (direct, indirect &amp; double indirect)
 
-		// ToDo: if anything goes wrong here, we probably want to free the
+		// TODO: if anything goes wrong here, we probably want to free the
 		// blocks that couldn't be distributed into the stream!
 
 		blocksNeeded -= run.Length();
@@ -1485,20 +1507,24 @@
 			if (free &lt; NUM_DIRECT_BLOCKS) {
 				// can we merge the last allocated run with the new one?
 				int32 last = free - 1;
-				if (free &gt; 0 &amp;&amp; data-&gt;direct[last].MergeableWith(run))
-					data-&gt;direct[last].length = HOST_ENDIAN_TO_BFS_INT16(data-&gt;direct[last].Length() + run.Length());
-				else
+				if (free &gt; 0 &amp;&amp; data-&gt;direct[last].MergeableWith(run)) {
+					data-&gt;direct[last].length = HOST_ENDIAN_TO_BFS_INT16(
+						data-&gt;direct[last].Length() + run.Length());
+				} else
 					data-&gt;direct[free] = run;
 
-				data-&gt;max_direct_range = HOST_ENDIAN_TO_BFS_INT64(data-&gt;MaxDirectRange() + run.Length() * fVolume-&gt;BlockSize());
-				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0 ? data-&gt;max_direct_range : size);
+				data-&gt;max_direct_range = HOST_ENDIAN_TO_BFS_INT64(
+					data-&gt;MaxDirectRange() + run.Length() * fVolume-&gt;BlockSize());
+				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0
+					? data-&gt;max_direct_range : size);
 				continue;
 			}
 		}
 
 		// Indirect block range
 
-		if (data-&gt;Size() &lt;= data-&gt;MaxIndirectRange() || !data-&gt;MaxIndirectRange()) {
+		if (data-&gt;Size() &lt;= data-&gt;MaxIndirectRange()
+			|| !data-&gt;MaxIndirectRange()) {
 			CachedBlock cached(fVolume);
 			block_run *runs = NULL;
 			uint32 free = 0;
@@ -1510,7 +1536,8 @@
 				if (status &lt; B_OK)
 					return status;
 
-				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(data-&gt;MaxDirectRange());
+				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(
+					data-&gt;MaxDirectRange());
 				// insert the block_run in the first block
 				runs = (block_run *)cached.SetTo(data-&gt;indirect);
 			} else {
@@ -1535,44 +1562,54 @@
 			}
 
 			if (runs != NULL) {
-				// try to insert the run to the last one - note that this doesn't
-				// take block borders into account, so it could be further optimized
+				// try to insert the run to the last one - note that this
+				// doesn't take block borders into account, so it could be
+				// further optimized
 				cached.MakeWritable(transaction);
 
 				int32 last = free - 1;
-				if (free &gt; 0 &amp;&amp; runs[last].MergeableWith(run))
-					runs[last].length = HOST_ENDIAN_TO_BFS_INT16(runs[last].Length() + run.Length());
-				else
+				if (free &gt; 0 &amp;&amp; runs[last].MergeableWith(run)) {
+					runs[last].length = HOST_ENDIAN_TO_BFS_INT16(
+						runs[last].Length() + run.Length());
+				} else
 					runs[free] = run;
 
-				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(data-&gt;MaxIndirectRange() + (run.Length() &lt;&lt; fVolume-&gt;BlockShift()));
-				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0 ? data-&gt;MaxIndirectRange() : size);
+				data-&gt;max_indirect_range = HOST_ENDIAN_TO_BFS_INT64(
+					data-&gt;MaxIndirectRange()
+					+ (run.Length() &lt;&lt; fVolume-&gt;BlockShift()));
+				data-&gt;size = HOST_ENDIAN_TO_BFS_INT64(blocksNeeded &gt; 0
+					? data-&gt;MaxIndirectRange() : size);
 				continue;
 			}
 		}
 
 		// Double indirect block range
 
-		if (data-&gt;Size() &lt;= data-&gt;MaxDoubleIndirectRange() || !data-&gt;max_double_indirect_range) {
+		if (data-&gt;Size() &lt;= data-&gt;MaxDoubleIndirectRange()
+			|| !data-&gt;max_double_indirect_range) {
 			while ((run.Length() % NUM_ARRAY_BLOCKS) != 0) {
-				// The number of allocated blocks isn't a multiple of NUM_ARRAY_BLOCKS,
-				// so we have to change this. This can happen the first time the stream
-				// grows into the double indirect range.
+				// The number of allocated blocks isn't a multiple of
+				// NUM_ARRAY_BLOCKS, so we have to change this. This can happen
+				// the first time the stream grows into the double
+				// indirect range.
 				// First, free the remaining blocks that don't fit into a multiple
 				// of NUM_ARRAY_BLOCKS
 				int32 rest = run.Length() % NUM_ARRAY_BLOCKS;
 				run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length() - rest);
 
-				status = fVolume-&gt;Free(transaction, block_run::Run(run.AllocationGroup(),
+				status = fVolume-&gt;Free(transaction,
+					block_run::Run(run.AllocationGroup(),
 					run.Start() + run.Length(), rest));
 				if (status &lt; B_OK)
 					return status;
 
 				blocksNeeded += rest;
-				blocksRequested = (blocksNeeded + NUM_ARRAY_BLOCKS - 1) &amp; ~(NUM_ARRAY_BLOCKS - 1);
+				blocksRequested = (blocksNeeded + NUM_ARRAY_BLOCKS - 1)
+					&amp; ~(NUM_ARRAY_BLOCKS - 1);
 				minimum = NUM_ARRAY_BLOCKS;
-					// we make sure here that we have at minimum NUM_ARRAY_BLOCKS allocated,
-					// so if the allocation succeeds, we don't run into an endless loop
+					// we make sure here that we have at minimum
+					// NUM_ARRAY_BLOCKS allocated, so if the allocation
+					// succeeds, we don't run into an endless loop
 
 				// Are there any blocks left in the run? If not, allocate a new one
 				if (run.length == 0)
@@ -1608,7 +1645,7 @@
 			block_run *array = NULL;
 			uint32 runLength = run.Length();
 
-			// ToDo: the following code is commented - it could be used to
+			// TODO: the following code is commented - it could be used to
 			// preallocate all needed block arrays to see in advance if the
 			// allocation will succeed.
 			// I will probably remove it later, because it's no perfect solution
@@ -1641,8 +1678,8 @@
 			while (run.length != 0) {
 				// get the indirect array block
 				if (array == NULL) {
-					array = (block_run *)cached.SetTo(fVolume-&gt;ToBlock(data-&gt;double_indirect)
-						+ indirectIndex / runsPerBlock);
+					array = (block_run *)cached.SetTo(fVolume-&gt;ToBlock(
+						data-&gt;double_indirect) + indirectIndex / runsPerBlock);
 					if (array == NULL)
 						return B_IO_ERROR;
 				}
@@ -1656,20 +1693,23 @@
 							return status;
 					}
 
-					block_run *runs = (block_run *)cachedDirect.SetToWritable(transaction,
-						fVolume-&gt;ToBlock(array[indirectIndex % runsPerBlock])
-						+ index / runsPerBlock);
+					block_run *runs = (block_run *)cachedDirect.SetToWritable(
+						transaction, fVolume-&gt;ToBlock(array[indirectIndex
+							% runsPerBlock]) + index / runsPerBlock);
 					if (runs == NULL)
 						return B_IO_ERROR;
 
 					do {
 						// insert the block_run into the array
 						runs[index % runsPerBlock] = run;
-						runs[index % runsPerBlock].length = HOST_ENDIAN_TO_BFS_INT16(NUM_ARRAY_BLOCKS);
+						runs[index % runsPerBlock].length
+							= HOST_ENDIAN_TO_BFS_INT16(NUM_ARRAY_BLOCKS);
 
 						// alter the remaining block_run
-						run.start = HOST_ENDIAN_TO_BFS_INT16(run.Start() + NUM_ARRAY_BLOCKS);
-						run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length() - NUM_ARRAY_BLOCKS);
+						run.start = HOST_ENDIAN_TO_BFS_INT16(run.Start()
+							+ NUM_ARRAY_BLOCKS);
+						run.length = HOST_ENDIAN_TO_BFS_INT16(run.Length()
+							- NUM_ARRAY_BLOCKS);
 					} while ((++index % runsPerBlock) != 0 &amp;&amp; run.length);
 				} while ((index % runsPerArray) != 0 &amp;&amp; run.length);
 
@@ -1679,8 +1719,11 @@
 				}
 			}
 
-			data-&gt;max_double_indirect_range = HOST_ENDIAN_TO_BFS_INT64(data-&gt;MaxDoubleIndirectRange() + (runLength &lt;&lt; fVolume-&gt;BlockShift()));
-			data-&gt;size = blocksNeeded &gt; 0 ? HOST_ENDIAN_TO_BFS_INT64(data-&gt;max_double_indirect_range) : size;
+			data-&gt;max_double_indirect_range = HOST_ENDIAN_TO_BFS_INT64(
+				data-&gt;MaxDoubleIndirectRange()
+				+ (runLength &lt;&lt; fVolume-&gt;BlockShift()));
+			data-&gt;size = blocksNeeded &gt; 0 ? HOST_ENDIAN_TO_BFS_INT64(
+				data-&gt;max_double_indirect_range) : size;
 
 			continue;
 		}
@@ -1695,8 +1738,8 @@
 
 

[... truncated: 270 lines follow ...]

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001792.html">[Haiku-commits] r20808 - haiku/trunk/src/system/kernel
</A></li>
	<LI>Next message: <A HREF="001794.html">[Haiku-commits] r20810 -	haiku/trunk/src/tests/add-ons/kernel/file_systems/bfs/r5
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1793">[ date ]</a>
              <a href="thread.html#1793">[ thread ]</a>
              <a href="subject.html#1793">[ subject ]</a>
              <a href="author.html#1793">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
