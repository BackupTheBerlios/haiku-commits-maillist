<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Haiku-commits] r20821 -	haiku/trunk/src/add-ons/media/media-add-ons/multi_audio
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/haiku-commits/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20821%20-%0A%09haiku/trunk/src/add-ons/media/media-add-ons/multi_audio&In-Reply-To=%3C200704251834.l3PIYLmZ004297%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001804.html">
   <LINK REL="Next"  HREF="001806.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Haiku-commits] r20821 -	haiku/trunk/src/add-ons/media/media-add-ons/multi_audio</H1>
    <B>korli at BerliOS</B> 
    <A HREF="mailto:haiku-commits%40lists.berlios.de?Subject=Re%3A%20%5BHaiku-commits%5D%20r20821%20-%0A%09haiku/trunk/src/add-ons/media/media-add-ons/multi_audio&In-Reply-To=%3C200704251834.l3PIYLmZ004297%40sheep.berlios.de%3E"
       TITLE="[Haiku-commits] r20821 -	haiku/trunk/src/add-ons/media/media-add-ons/multi_audio">korli at mail.berlios.de
       </A><BR>
    <I>Wed Apr 25 20:34:21 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="001804.html">[Haiku-commits] r20820 -	haiku/trunk/src/add-ons/media/media-add-ons/multi_audio
</A></li>
        <LI>Next message: <A HREF="001806.html">[Haiku-commits] r20822 - in haiku/trunk: headers/private/kernel/util	src/add-ons/kernel/network/protocols/tcp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1805">[ date ]</a>
              <a href="thread.html#1805">[ thread ]</a>
              <a href="subject.html#1805">[ subject ]</a>
              <a href="author.html#1805">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: korli
Date: 2007-04-25 20:34:20 +0200 (Wed, 25 Apr 2007)
New Revision: 20821
ViewCVS: <A HREF="http://svn.berlios.de/viewcvs/haiku?rev=20821&amp;view=rev">http://svn.berlios.de/viewcvs/haiku?rev=20821&amp;view=rev</A>

Modified:
   haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.cpp
   haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.h
   haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.cpp
   haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.h
Log:
code style


Modified: haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.cpp	2007-04-25 18:19:25 UTC (rev 20820)
+++ haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.cpp	2007-04-25 18:34:20 UTC (rev 20821)
@@ -1,30 +1,8 @@
 /*
- * multiaudio replacement media addon for BeOS
- *
  * Copyright (c) 2002, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
- *
- * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, 
- *   this list of conditions and the following disclaimer.
- * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
- *   and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
+ * Distributed under the terms of the MIT License.
  */
+
 #include &lt;MediaDefs.h&gt;
 #include &lt;MediaAddOn.h&gt;
 #include &lt;Errors.h&gt;
@@ -61,11 +39,11 @@
 MultiAudioAddOn::~MultiAudioAddOn()
 {
 	CALLED();
-	
+
 	void *device = NULL;
-	for ( int32 i = 0; (device = fDevices.ItemAt(i)); i++ )
+	for (int32 i = 0; (device = fDevices.ItemAt(i)); i++)
 		delete (MultiAudioDevice *)device;
-		
+
 	SaveSettings();
 }
 
@@ -75,12 +53,12 @@
 {
 	CALLED();
 	fInitCheckStatus = B_NO_INIT;
-	
-	if(RecursiveScan(&quot;/dev/audio/hmulti/&quot;)!=B_OK)
+
+	if (RecursiveScan(&quot;/dev/audio/hmulti/&quot;) != B_OK)
 		return;
-		
+
 	LoadSettings();
-	
+
 	fInitCheckStatus = B_OK;
 }
 
@@ -107,16 +85,16 @@
 {
 	CALLED();
 	if (out_info == 0) {
-		fprintf(stderr,&quot;&lt;- B_BAD_VALUE\n&quot;);
+		fprintf(stderr, &quot;&lt;- B_BAD_VALUE\n&quot;);
 		return B_BAD_VALUE; // we refuse to crash because you were stupid
-	}	
+	}
 	if (n &lt; 0 || n &gt; fDevices.CountItems() - 1) {
-		fprintf(stderr,&quot;&lt;- B_BAD_INDEX\n&quot;);
+		fprintf(stderr, &quot;&lt;- B_BAD_INDEX\n&quot;);
 		return B_BAD_INDEX;
 	}
-		
+
 	MultiAudioDevice *device = (MultiAudioDevice *) fDevices.ItemAt(n);
-		
+
 	flavor_info * infos = new flavor_info[1];
 	MultiAudioNode::GetFlavor(&amp;infos[0], n);
 	infos[0].name = device-&gt;MD.friendly_name;
@@ -125,41 +103,41 @@
 }
 
 BMediaNode * MultiAudioAddOn::InstantiateNodeFor(
-				const flavor_info * info,
-				BMessage * config,
-				status_t * out_error)
+	const flavor_info * info,
+	BMessage * config,
+	status_t * out_error)
 {
 	CALLED();
 	if (out_error == 0) {
-		fprintf(stderr,&quot;&lt;- NULL\n&quot;);
+		fprintf(stderr, &quot;&lt;- NULL\n&quot;);
 		return 0; // we refuse to crash because you were stupid
 	}
-	
+
 	MultiAudioDevice *device = (MultiAudioDevice*)fDevices.ItemAt(info-&gt;internal_id);
-	if(device == NULL) {
+	if (device == NULL) {
 		*out_error = B_ERROR;
 		return NULL;
 	}
-	
+
 #ifdef MULTI_SAVE
-	if(fSettings.FindMessage(device-&gt;MD.friendly_name, config)==B_OK) {
+	if (fSettings.FindMessage(device-&gt;MD.friendly_name, config) == B_OK) {
 		fSettings.RemoveData(device-&gt;MD.friendly_name);
 	}
 #endif
-	
-	MultiAudioNode * node
-		= new MultiAudioNode(this,
-						  device-&gt;MD.friendly_name,
-						  device,
-						  info-&gt;internal_id,
-						  config);
+
+	MultiAudioNode * node =
+		new MultiAudioNode(this,
+			device-&gt;MD.friendly_name,
+			device,
+			info-&gt;internal_id,
+			config);
 	if (node == 0) {
 		*out_error = B_NO_MEMORY;
-		fprintf(stderr,&quot;&lt;- B_NO_MEMORY\n&quot;);
-	} else { 
+		fprintf(stderr, &quot;&lt;- B_NO_MEMORY\n&quot;);
+	} else {
 		*out_error = node-&gt;InitCheck();
 	}
-	return node;	
+	return node;
 }
 
 status_t
@@ -171,23 +149,23 @@
 		into_message = new BMessage();
 		MultiAudioNode * node = dynamic_cast&lt;MultiAudioNode*&gt;(your_node);
 		if (node == 0) {
-			fprintf(stderr,&quot;&lt;- B_BAD_TYPE\n&quot;);
+			fprintf(stderr, &quot;&lt;- B_BAD_TYPE\n&quot;);
 			return B_BAD_TYPE;
 		}
-		if(node-&gt;GetConfigurationFor(into_message)==B_OK) {
+		if (node-&gt;GetConfigurationFor(into_message) == B_OK) {
 			fSettings.AddMessage(your_node-&gt;Name(), into_message);
-		}		
+		}
 		return B_OK;
 	}
-#endif	
+#endif
 	// currently never called by the media kit. Seems it is not implemented.
 	if (into_message == 0) {
-		fprintf(stderr,&quot;&lt;- B_BAD_VALUE\n&quot;);
+		fprintf(stderr, &quot;&lt;- B_BAD_VALUE\n&quot;);
 		return B_BAD_VALUE; // we refuse to crash because you were stupid
-	}	
+	}
 	MultiAudioNode * node = dynamic_cast&lt;MultiAudioNode*&gt;(your_node);
 	if (node == 0) {
-		fprintf(stderr,&quot;&lt;- B_BAD_TYPE\n&quot;);
+		fprintf(stderr, &quot;&lt;- B_BAD_TYPE\n&quot;);
 		return B_BAD_TYPE;
 	}
 	return node-&gt;GetConfigurationFor(into_message);
@@ -201,10 +179,10 @@
 }
 
 status_t MultiAudioAddOn::AutoStart(
-				int in_count,
-				BMediaNode ** out_node,
-				int32 * out_internal_id,
-				bool * out_has_more)
+	int in_count,
+	BMediaNode ** out_node,
+	int32 * out_internal_id,
+	bool * out_has_more)
 {
 	CALLED();
 	return B_OK;
@@ -214,22 +192,22 @@
 MultiAudioAddOn::RecursiveScan(char* rootPath, BEntry *rootEntry)
 {
 	CALLED();
-	
+
 	BDirectory root;
-	if(rootEntry!=NULL)
+	if (rootEntry != NULL)
 		root.SetTo(rootEntry);
-	else if(rootPath!=NULL) {
+	else if (rootPath != NULL) {
 		root.SetTo(rootPath);
 	} else {
 		PRINT((&quot;Error in MultiAudioAddOn::RecursiveScan null params\n&quot;));
 		return B_ERROR;
 	}
-	
+
 	BEntry entry;
-	
-	while(root.GetNextEntry(&amp;entry) &gt; B_ERROR) {
 
-		if(entry.IsDirectory()) {
+	while (root.GetNextEntry(&amp;entry) &gt; B_ERROR) {
+
+		if (entry.IsDirectory()) {
 			RecursiveScan(rootPath, &amp;entry);
 		} else {
 			BPath path;
@@ -243,7 +221,7 @@
 			}
 		}
 	}
-	
+
 	return B_OK;
 }
 
@@ -253,10 +231,10 @@
 {
 	CALLED();
 	BPath path;
-	if(find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {
+	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {
 		path.Append(SETTINGS_FILE);
-		BFile file(path.Path(),B_READ_WRITE|B_CREATE_FILE|B_ERASE_FILE);
-		if(file.InitCheck()==B_OK)
+		BFile file(path.Path(), B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE);
+		if (file.InitCheck() == B_OK)
 			fSettings.Flatten(&amp;file);
 	}
 }
@@ -267,16 +245,16 @@
 {
 	CALLED();
 	fSettings.MakeEmpty();
-	
+
 	BPath path;
-	if(find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {
+	if (find_directory(B_USER_SETTINGS_DIRECTORY, &amp;path) == B_OK) {
 		path.Append(SETTINGS_FILE);
-		BFile file(path.Path(),B_READ_ONLY);
-		if((file.InitCheck()==B_OK)&amp;&amp;(fSettings.Unflatten(&amp;file)==B_OK))
+		BFile file(path.Path(), B_READ_ONLY);
+		if ((file.InitCheck() == B_OK) &amp;&amp; (fSettings.Unflatten(&amp;file) == B_OK))
 		{
 			PRINT_OBJECT(fSettings);
 		} else {
-			PRINT((&quot;Error unflattening settings file %s\n&quot;,path.Path()));
-		}	
+			PRINT((&quot;Error unflattening settings file %s\n&quot;, path.Path()));
+		}
 	}
 }

Modified: haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.h
===================================================================
--- haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.h	2007-04-25 18:19:25 UTC (rev 20820)
+++ haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioAddOn.h	2007-04-25 18:34:20 UTC (rev 20821)
@@ -1,30 +1,8 @@
 /*
- * multiaudio replacement media addon for BeOS
- *
  * Copyright (c) 2002, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
- *
- * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, 
- *   this list of conditions and the following disclaimer.
- * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
- *   and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
+ * Distributed under the terms of the MIT License.
  */
+
 #ifndef _MULTIAUDIOADDON_H
 #define _MULTIAUDIOADDON_H
 
@@ -34,49 +12,49 @@
 #define SETTINGS_FILE					&quot;Media/multi_audio_settings&quot;
 
 class MultiAudioAddOn :
-    public BMediaAddOn
+	public BMediaAddOn
 {
-public:
-	virtual ~MultiAudioAddOn(void);
-	explicit MultiAudioAddOn(image_id image);
+	public:
+		virtual ~MultiAudioAddOn(void);
+		explicit MultiAudioAddOn(image_id image);
 
-/**************************/
-/* begin from BMediaAddOn */
-public:
-virtual	status_t InitCheck(
-				const char ** out_failure_text);
-virtual	int32 CountFlavors(void);
-virtual	status_t GetFlavorAt(
-				int32 n,
-				const flavor_info ** out_info);
-virtual	BMediaNode * InstantiateNodeFor(
-				const flavor_info * info,
-				BMessage * config,
-				status_t * out_error);
-virtual	status_t GetConfigurationFor(
-				BMediaNode * your_node,
-				BMessage * into_message);
-virtual	bool WantsAutoStart(void);
-virtual	status_t AutoStart(
-				int in_count,
-				BMediaNode ** out_node,
-				int32 * out_internal_id,
-				bool * out_has_more);
+		/**************************/
+		/* begin from BMediaAddOn */
+	public:
+		virtual	status_t InitCheck(
+			const char ** out_failure_text);
+		virtual	int32 CountFlavors(void);
+		virtual	status_t GetFlavorAt(
+			int32 n,
+			const flavor_info ** out_info);
+		virtual	BMediaNode * InstantiateNodeFor(
+			const flavor_info * info,
+			BMessage * config,
+			status_t * out_error);
+		virtual	status_t GetConfigurationFor(
+			BMediaNode * your_node,
+			BMessage * into_message);
+		virtual	bool WantsAutoStart(void);
+		virtual	status_t AutoStart(
+			int in_count,
+			BMediaNode ** out_node,
+			int32 * out_internal_id,
+			bool * out_has_more);
 
-/* end from BMediaAddOn */
-/************************/
+		/* end from BMediaAddOn */
+		/************************/
 
-private:
-	status_t RecursiveScan(char* path, BEntry *rootEntry = NULL);
-	void SaveSettings();
-	void LoadSettings();
-	
-	status_t 		fInitCheckStatus;
-	BList			fDevices;
-	
-	BMessage fSettings;				// settings loaded from settings directory
+	private:
+		status_t RecursiveScan(char* path, BEntry *rootEntry = NULL);
+		void SaveSettings();
+		void LoadSettings();
+
+		status_t 		fInitCheckStatus;
+		BList			fDevices;
+
+		BMessage fSettings;				// settings loaded from settings directory
 };
 
-extern &quot;C&quot; _EXPORT BMediaAddOn *make_media_addon( image_id you );
+extern &quot;C&quot; _EXPORT BMediaAddOn *make_media_addon(image_id you);
 
 #endif /* _MULTIAUDIOADDON_H */

Modified: haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.cpp
===================================================================
--- haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.cpp	2007-04-25 18:19:25 UTC (rev 20820)
+++ haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.cpp	2007-04-25 18:34:20 UTC (rev 20821)
@@ -1,30 +1,8 @@
 /*
- * multiaudio replacement media addon for BeOS
- *
- * Copyright (c) 2002, 2003, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
- *
- * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, 
- *   this list of conditions and the following disclaimer.
- * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
- *   and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
+ * Copyright (c) 2002-2007, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
+ * Distributed under the terms of the MIT License.
  */
+
 #include &quot;MultiAudioDevice.h&quot;
 #include &quot;debug.h&quot;
 #include &quot;driver_io.h&quot;
@@ -33,39 +11,41 @@
 #include &lt;string.h&gt;
 
 float SAMPLE_RATES[] = {
-			8000.0, 11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0, 44100.0,
-			48000.0, 64000.0, 88200.0, 96000.0, 176400.0, 192000.0, 384000.0, 1536000.0
-			};
+	8000.0, 11025.0, 12000.0, 16000.0, 22050.0, 24000.0, 32000.0, 44100.0,
+	48000.0, 64000.0, 88200.0, 96000.0, 176400.0, 192000.0, 384000.0, 1536000.0
+					   };
 
 
 float MultiAudioDevice::convert_multiaudio_rate_to_media_rate(uint32 rate)
 {
 	uint8 count = 0;
-	uint8 size = sizeof(SAMPLE_RATES)/sizeof(SAMPLE_RATES[0]);
-	while(count &lt; size) {
-		if(rate &amp; 1)
+	uint8 size = sizeof(SAMPLE_RATES) / sizeof(SAMPLE_RATES[0]);
+	while (count &lt; size) {
+		if (rate &amp; 1)
 			return SAMPLE_RATES[count];
 		count++;
-		rate &gt;&gt;= 1;	
+		rate &gt;&gt;= 1;
 	}
 	return 0.0;
 }
 
+
 uint32 MultiAudioDevice::convert_media_rate_to_multiaudio_rate(float rate)
 {
 	uint8 count = 0;
-	uint size = sizeof(SAMPLE_RATES)/sizeof(SAMPLE_RATES[0]);
-	while(count &lt; size) {
-		if(rate &lt;= SAMPLE_RATES[count])
+	uint size = sizeof(SAMPLE_RATES) / sizeof(SAMPLE_RATES[0]);
+	while (count &lt; size) {
+		if (rate &lt;= SAMPLE_RATES[count])
 			return (0x1 &lt;&lt; count);
 		count++;
 	}
 	return 0;
 }
 
+
 uint32 MultiAudioDevice::convert_multiaudio_format_to_media_format(uint32 fmt)
 {
-	switch(fmt) {
+	switch (fmt) {
 		case B_FMT_FLOAT:
 			return media_raw_audio_format::B_AUDIO_FLOAT;
 		case B_FMT_18BIT:
@@ -87,7 +67,7 @@
 
 int16 MultiAudioDevice::convert_multiaudio_format_to_valid_bits(uint32 fmt)
 {
-	switch(fmt) {
+	switch (fmt) {
 		case B_FMT_18BIT:
 			return 18;
 		case B_FMT_20BIT:
@@ -105,7 +85,7 @@
 
 uint32 MultiAudioDevice::convert_media_format_to_multiaudio_format(uint32 fmt)
 {
-	switch(fmt) {
+	switch (fmt) {
 		case media_raw_audio_format::B_AUDIO_FLOAT:
 			return B_FMT_FLOAT;
 		case media_raw_audio_format::B_AUDIO_INT:
@@ -121,36 +101,38 @@
 	}
 }
 
+
 uint32 MultiAudioDevice::select_multiaudio_rate(uint32 rate)
 {
 	//highest rate
 	uint32 crate = B_SR_1536000;
-	while(crate != 0) {
-		if(rate &amp; crate)
+	while (crate != 0) {
+		if (rate &amp; crate)
 			return crate;
 		crate &gt;&gt;= 1;
 	}
 	return 0;
 }
 
+
 uint32 MultiAudioDevice::select_multiaudio_format(uint32 fmt)
 {
 	//highest format
-	if(fmt &amp; B_FMT_FLOAT) {
+	if (fmt &amp; B_FMT_FLOAT) {
 		return B_FMT_FLOAT;
-	} else if(fmt &amp; B_FMT_32BIT) {
+	} else if (fmt &amp; B_FMT_32BIT) {
 		return B_FMT_32BIT;
-	} else if(fmt &amp; B_FMT_24BIT) {
+	} else if (fmt &amp; B_FMT_24BIT) {
 		return B_FMT_24BIT;
-	} else if(fmt &amp; B_FMT_20BIT) {
+	} else if (fmt &amp; B_FMT_20BIT) {
 		return B_FMT_20BIT;
-	} else if(fmt &amp; B_FMT_18BIT) {
+	} else if (fmt &amp; B_FMT_18BIT) {
 		return B_FMT_18BIT;
-	} else if(fmt &amp; B_FMT_16BIT) {
+	} else if (fmt &amp; B_FMT_16BIT) {
 		return B_FMT_16BIT;
-	} else if(fmt &amp; B_FMT_8BIT_S) {
+	} else if (fmt &amp; B_FMT_8BIT_S) {
 		return B_FMT_8BIT_S;
-	} else if(fmt &amp; B_FMT_8BIT_U) {
+	} else if (fmt &amp; B_FMT_8BIT_U) {
 		return B_FMT_8BIT_U;
 	} else
 		return 0;
@@ -161,8 +143,8 @@
 MultiAudioDevice::~MultiAudioDevice()
 {
 	CALLED();
-	if ( fd != 0 ) {
-		close( fd );
+	if (fd != 0) {
+		close(fd);
 	}
 }
 
@@ -170,15 +152,15 @@
 {
 	CALLED();
 	fInitCheckStatus = B_NO_INIT;
-	
+
 	strcpy(fDevice_name, name);
 	strcpy(fDevice_path, path);
-	
+
 	PRINT((&quot;name : %s, path : %s\n&quot;, fDevice_name, fDevice_path));
-	
-	if(InitDriver()!=B_OK)
+
+	if (InitDriver() != B_OK)
 		return;
-	
+
 	fInitCheckStatus = B_OK;
 }
 
@@ -195,7 +177,7 @@
 	multi_channel_enable 	MCE;
 	uint32					mce_enable_bits;
 	int rval, i, num_outputs, num_inputs, num_channels;
-	
+
 	CALLED();
 
 	//open the device driver for output
@@ -205,14 +187,14 @@
 		fprintf(stderr, &quot;Failed to open %s: %s\n&quot;, fDevice_path, strerror(errno));
 		return B_ERROR;
 	}
-	
+
 	//
 	// Get description
 	//
 	MD.info_size = sizeof(MD);
 	MD.request_channel_count = MAX_CHANNELS;
 	MD.channels = MCI;
-	rval = DRIVER_GET_DESCRIPTION(&amp;MD,0);
+	rval = DRIVER_GET_DESCRIPTION(&amp;MD, 0);
 	if (B_OK != rval)
 	{
 		fprintf(stderr, &quot;Failed on B_MULTI_GET_DESCRIPTION\n&quot;);
@@ -220,48 +202,48 @@
 	}
 
 	PRINT((&quot;Friendly name:\t%s\nVendor:\t\t%s\n&quot;,
-				MD.friendly_name,MD.vendor_info));
+		MD.friendly_name, MD.vendor_info));
 	PRINT((&quot;%ld outputs\t%ld inputs\n%ld out busses\t%ld in busses\n&quot;,
-				MD.output_channel_count,MD.input_channel_count,
-				MD.output_bus_channel_count,MD.input_bus_channel_count));
+		MD.output_channel_count, MD.input_channel_count,
+		MD.output_bus_channel_count, MD.input_bus_channel_count));
 	PRINT((&quot;\nChannels\n&quot;
-			 &quot;ID\tKind\tDesig\tConnectors\n&quot;));
+		&quot;ID\tKind\tDesig\tConnectors\n&quot;));
 
 	for (i = 0 ; i &lt; (MD.output_channel_count + MD.input_channel_count); i++)
 	{
-		PRINT((&quot;%ld\t%d\t0x%lx\t0x%lx\n&quot;,MD.channels[i].channel_id,
-											MD.channels[i].kind,
-											MD.channels[i].designations,
-											MD.channels[i].connectors));
-	}			 
+		PRINT((&quot;%ld\t%d\t0x%lx\t0x%lx\n&quot;, MD.channels[i].channel_id,
+			MD.channels[i].kind,
+			MD.channels[i].designations,
+			MD.channels[i].connectors));
+	}
 	PRINT((&quot;\n&quot;));
-	
-	PRINT((&quot;Output rates\t\t0x%lx\n&quot;,MD.output_rates));
-	PRINT((&quot;Input rates\t\t0x%lx\n&quot;,MD.input_rates));
-	PRINT((&quot;Max CVSR\t\t%.0f\n&quot;,MD.max_cvsr_rate));
-	PRINT((&quot;Min CVSR\t\t%.0f\n&quot;,MD.min_cvsr_rate));
-	PRINT((&quot;Output formats\t\t0x%lx\n&quot;,MD.output_formats));
-	PRINT((&quot;Input formats\t\t0x%lx\n&quot;,MD.input_formats));
-	PRINT((&quot;Lock sources\t\t0x%lx\n&quot;,MD.lock_sources));
-	PRINT((&quot;Timecode sources\t0x%lx\n&quot;,MD.timecode_sources));
-	PRINT((&quot;Interface flags\t\t0x%lx\n&quot;,MD.interface_flags));
-	PRINT((&quot;Control panel string:\t\t%s\n&quot;,MD.control_panel));
+
+	PRINT((&quot;Output rates\t\t0x%lx\n&quot;, MD.output_rates));
+	PRINT((&quot;Input rates\t\t0x%lx\n&quot;, MD.input_rates));
+	PRINT((&quot;Max CVSR\t\t%.0f\n&quot;, MD.max_cvsr_rate));
+	PRINT((&quot;Min CVSR\t\t%.0f\n&quot;, MD.min_cvsr_rate));
+	PRINT((&quot;Output formats\t\t0x%lx\n&quot;, MD.output_formats));
+	PRINT((&quot;Input formats\t\t0x%lx\n&quot;, MD.input_formats));
+	PRINT((&quot;Lock sources\t\t0x%lx\n&quot;, MD.lock_sources));
+	PRINT((&quot;Timecode sources\t0x%lx\n&quot;, MD.timecode_sources));
+	PRINT((&quot;Interface flags\t\t0x%lx\n&quot;, MD.interface_flags));
+	PRINT((&quot;Control panel string:\t\t%s\n&quot;, MD.control_panel));
 	PRINT((&quot;\n&quot;));
-	
+
 	num_outputs = MD.output_channel_count;
 	num_inputs = MD.input_channel_count;
 	num_channels = num_outputs + num_inputs;
-	
+
 	// Get and set enabled channels
 	MCE.info_size = sizeof(MCE);
-	MCE.enable_bits = (uchar *) &amp;mce_enable_bits;
+	MCE.enable_bits = (uchar *) &amp; mce_enable_bits;
 	rval = DRIVER_GET_ENABLED_CHANNELS(&amp;MCE, sizeof(MCE));
 	if (B_OK != rval)
 	{
-		fprintf(stderr, &quot;Failed on B_MULTI_GET_ENABLED_CHANNELS len is 0x%lx\n&quot;,sizeof(MCE));
+		fprintf(stderr, &quot;Failed on B_MULTI_GET_ENABLED_CHANNELS len is 0x%lx\n&quot;, sizeof(MCE));
 		return B_ERROR;
 	}
-	
+
 	mce_enable_bits = (1 &lt;&lt; num_channels) - 1;
 	MCE.lock_source = B_MULTI_LOCK_INTERNAL;
 	rval = DRIVER_SET_ENABLED_CHANNELS(&amp;MCE, 0);
@@ -270,7 +252,7 @@
 		fprintf(stderr, &quot;Failed on B_MULTI_SET_ENABLED_CHANNELS 0x%p 0x%x\n&quot;, MCE.enable_bits, *(MCE.enable_bits));
 		return B_ERROR;
 	}
-	
+
 	//
 	// Set the sample rate
 	//
@@ -287,7 +269,7 @@
 		fprintf(stderr, &quot;Failed on B_MULTI_SET_GLOBAL_FORMAT\n&quot;);
 		return B_ERROR;
 	}
-	
+
 	//
 	// Get the buffers
 	//
@@ -299,12 +281,12 @@
 	MBL.request_playback_buffer_size = 0;           //use the default......
 	MBL.request_playback_buffers = NB_BUFFERS;
 	MBL.request_playback_channels = num_outputs;
-	MBL.playback_buffers = (buffer_desc **) play_buffer_desc;	
+	MBL.playback_buffers = (buffer_desc **) play_buffer_desc;
 	MBL.request_record_buffer_size = 0;           //use the default......
 	MBL.request_record_buffers = NB_BUFFERS;
 	MBL.request_record_channels = num_inputs;
 	MBL.record_buffers = (buffer_desc **) record_buffer_desc;
-			
+
 	rval = DRIVER_GET_BUFFERS(&amp;MBL, 0);
 
 	if (B_OK != rval)
@@ -312,27 +294,27 @@
 		fprintf(stderr, &quot;Failed on B_MULTI_GET_BUFFERS\n&quot;);
 		return B_ERROR;
 	}
-	
+
 	for (i = 0; i &lt; MBL.return_playback_buffers; i++)
-		for (int j=0; j &lt; MBL.return_playback_channels; j++) {
+		for (int j = 0; j &lt; MBL.return_playback_channels; j++) {
 			PRINT((&quot;MBL.playback_buffers[%d][%d].base: %p\n&quot;,
-				i,j,MBL.playback_buffers[i][j].base));
+				i, j, MBL.playback_buffers[i][j].base));
 			PRINT((&quot;MBL.playback_buffers[%d][%d].stride: %i\n&quot;,
-				i,j,MBL.playback_buffers[i][j].stride));
+				i, j, MBL.playback_buffers[i][j].stride));
 		}
-	
+
 	for (i = 0; i &lt; MBL.return_record_buffers; i++)
-		for (int j=0; j &lt; MBL.return_record_channels; j++) {
+		for (int j = 0; j &lt; MBL.return_record_channels; j++) {
 			PRINT((&quot;MBL.record_buffers[%d][%d].base: %p\n&quot;,
-				i,j,MBL.record_buffers[i][j].base));
+				i, j, MBL.record_buffers[i][j].base));
 			PRINT((&quot;MBL.record_buffers[%d][%d].stride: %i\n&quot;,
-				i,j,MBL.record_buffers[i][j].stride));
+				i, j, MBL.record_buffers[i][j].stride));
 		}
-		
+
 	MMCI.info_size = sizeof(MMCI);
 	MMCI.control_count = MAX_CONTROLS;
 	MMCI.controls = MMC;
-	
+
 	rval = DRIVER_LIST_MIX_CONTROLS(&amp;MMCI, 0);
 
 	if (B_OK != rval)
@@ -340,11 +322,11 @@
 		fprintf(stderr, &quot;Failed on DRIVER_LIST_MIX_CONTROLS\n&quot;);
 		return B_ERROR;
 	}
-	
+
 	return B_OK;
 }
 
-int 
+int
 MultiAudioDevice::DoBufferExchange(multi_buffer_info *MBI)
 {
 	return DRIVER_BUFFER_EXCHANGE(MBI, 0);

Modified: haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.h
===================================================================
--- haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.h	2007-04-25 18:19:25 UTC (rev 20820)
+++ haiku/trunk/src/add-ons/media/media-add-ons/multi_audio/MultiAudioDevice.h	2007-04-25 18:34:20 UTC (rev 20821)
@@ -1,30 +1,8 @@
 /*
- * multiaudio replacement media addon for BeOS
- *
- * Copyright (c) 2002, 2003, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
- *
- * All rights reserved.
- * Redistribution and use in source and binary forms, with or without modification, 
- * are permitted provided that the following conditions are met:
- *
- * - Redistributions of source code must retain the above copyright notice, 
- *   this list of conditions and the following disclaimer.
- * - Redistributions in binary form must reproduce the above copyright notice,
- *   this list of conditions and the following disclaimer in the documentation 
- *   and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND 
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
- * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
+ * Copyright (c) 2002-2007, Jerome Duval (<A HREF="https://lists.berlios.de/mailman/listinfo/haiku-commits">jerome.duval at free.fr</A>)
+ * Distributed under the terms of the MIT License.
  */
+
 #ifndef _MULTIAUDIODEVICE_H
 #define _MULTIAUDIODEVICE_H
 
@@ -36,47 +14,47 @@
 
 class MultiAudioDevice
 {
-public:
-	explicit MultiAudioDevice(const char *name, const char* path);
-	virtual ~MultiAudioDevice(void);
-	
-	virtual status_t InitCheck(void) const;
+	public:
+		explicit MultiAudioDevice(const char *name, const char* path);
+		virtual ~MultiAudioDevice(void);
 
-	static float convert_multiaudio_rate_to_media_rate(uint32 rate);
-	static uint32 convert_media_rate_to_multiaudio_rate(float rate);
-	static uint32 convert_multiaudio_format_to_media_format(uint32 fmt);
-	static int16 convert_multiaudio_format_to_valid_bits(uint32 fmt);
-	static uint32 convert_media_format_to_multiaudio_format(uint32 fmt);
-	static uint32 select_multiaudio_rate(uint32 rate);
-	static uint32 select_multiaudio_format(uint32 fmt);
-	
-	int DoBufferExchange(multi_buffer_info *MBI);
-	int DoSetMix(multi_mix_value_info *MMVI);
-	int DoGetMix(multi_mix_value_info *MMVI);
+		virtual status_t InitCheck(void) const;
 
-private:
-	status_t			InitDriver();
-	
-	int						fd; 			//file descriptor for hw driver
-	char					fDevice_name[32];
-	char					fDevice_path[32];
+		static float convert_multiaudio_rate_to_media_rate(uint32 rate);
+		static uint32 convert_media_rate_to_multiaudio_rate(float rate);
+		static uint32 convert_multiaudio_format_to_media_format(uint32 fmt);
+		static int16 convert_multiaudio_format_to_valid_bits(uint32 fmt);
+		static uint32 convert_media_format_to_multiaudio_format(uint32 fmt);
+		static uint32 select_multiaudio_rate(uint32 rate);
+		static uint32 select_multiaudio_format(uint32 fmt);
 
-public:
-	multi_description		MD;
-	multi_channel_info		MCI[MAX_CHANNELS];
-	multi_format_info 		MFI;
-	multi_buffer_list 		MBL;
-	
-	multi_mix_control_info 	MMCI;
-	multi_mix_control		MMC[MAX_CONTROLS];
-		
-	buffer_desc		play_buffer_list[NB_BUFFERS * MAX_CHANNELS];
-	buffer_desc		record_buffer_list[NB_BUFFERS * MAX_CHANNELS];
-	buffer_desc 	*play_buffer_desc[NB_BUFFERS];
-	buffer_desc 	*record_buffer_desc[NB_BUFFERS];
+		int DoBufferExchange(multi_buffer_info *MBI);
+		int DoSetMix(multi_mix_value_info *MMVI);
+		int DoGetMix(multi_mix_value_info *MMVI);
 
-private:
-	status_t 				fInitCheckStatus;
+	private:
+		status_t			InitDriver();
+
+		int						fd; 			//file descriptor for hw driver
+		char					fDevice_name[32];
+		char					fDevice_path[32];
+
+	public:
+		multi_description		MD;
+		multi_channel_info		MCI[MAX_CHANNELS];
+		multi_format_info 		MFI;
+		multi_buffer_list 		MBL;
+
+		multi_mix_control_info 	MMCI;
+		multi_mix_control		MMC[MAX_CONTROLS];
+
+		buffer_desc		play_buffer_list[NB_BUFFERS * MAX_CHANNELS];
+		buffer_desc		record_buffer_list[NB_BUFFERS * MAX_CHANNELS];
+		buffer_desc 	*play_buffer_desc[NB_BUFFERS];
+		buffer_desc 	*record_buffer_desc[NB_BUFFERS];
+
+	private:
+		status_t 				fInitCheckStatus;
 };
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001804.html">[Haiku-commits] r20820 -	haiku/trunk/src/add-ons/media/media-add-ons/multi_audio
</A></li>
	<LI>Next message: <A HREF="001806.html">[Haiku-commits] r20822 - in haiku/trunk: headers/private/kernel/util	src/add-ons/kernel/network/protocols/tcp
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1805">[ date ]</a>
              <a href="thread.html#1805">[ thread ]</a>
              <a href="subject.html#1805">[ subject ]</a>
              <a href="author.html#1805">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/haiku-commits">More information about the Haiku-commits
mailing list</a><br>
</body></html>
